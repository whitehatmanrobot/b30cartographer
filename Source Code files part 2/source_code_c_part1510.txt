B scaling with non-premultiplied alpha surface");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_INVALIDPARAMS;
			}
		    }
		}
	    }
	}

	/*
	 * If filtering is to be explicitly enabled or disabled, verify that
	 * the hardware driver is capable of performing the blit as requested.
	 */
	if (dwFlags & (DDABLT_FILTERENABLE | DDABLT_FILTERDISABLE | DDABLT_FILTERTRANSPBORDER))
	{
	    /*
	     * Is driver capable of doing any kind of filtering at all?
	     */
	    if (!(caps.dwBothFXCaps & DDFXCAPS_BLTFILTER))
	    {
		GETFAILCODEBLT(caps.dwFXCaps,
			       caps.dwHELFXCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFXCAPS_BLTFILTER);
		if (fail)
		{
		    DPF_ERR("No driver support for filtered blit");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }
	    if (!(~dwFlags & (DDABLT_FILTERENABLE | DDABLT_FILTERDISABLE)))
	    {
		DPF_ERR("Illegal to both enable and disable filtering");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    if (!(~dwFlags & (DDABLT_FILTERTRANSPBORDER | DDABLT_FILTERDISABLE)))
	    {
		DPF_ERR("Illegal to set FILTERTRANSPBORDER if filtering is explicitly disabled");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    if ((dwFlags & DDABLT_FILTERENABLE) &&
                !(caps.dwBothFilterCaps & DDFILTCAPS_BLTQUALITYFILTER))
	    {
		GETFAILCODEBLT(caps.dwFilterCaps,
			       caps.dwHELFilterCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFILTCAPS_BLTQUALITYFILTER);
		if (fail)
		{
		    DPF_ERR("No driver support for filtered blit");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }
	    if ((dwFlags & DDABLT_FILTERDISABLE) &&
                !(caps.dwBothFilterCaps & DDFILTCAPS_BLTCANDISABLEFILTER))
	    {
		GETFAILCODEBLT(caps.dwFilterCaps,
			       caps.dwHELFilterCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFILTCAPS_BLTCANDISABLEFILTER);
		if (fail)
		{
		    DPF_ERR("Driver cannot disable filtering for blits");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }
	    if ((dwFlags & DDABLT_FILTERTRANSPBORDER) &&
                !(caps.dwBothFilterCaps & DDFILTCAPS_BLTTRANSPBORDER))
	    {
		GETFAILCODEBLT(caps.dwFilterCaps,
			       caps.dwHELFilterCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFILTCAPS_BLTTRANSPBORDER);
		if (fail)
		{
		    DPF_ERR("Driver cannot filter with transparent border");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }
	}

	/*
	 * Validate ARGB scaling factors.
	 */
	if (!(dwFlags & DDABLT_DEGRADEARGBSCALING) &&
		    *(LPDWORD)&ddargbScaleFactors != ~0UL &&
                    !(surf_src_lcl == NULL && ddargbScaleFactors.alpha == 255))
	{
	    /*
	     * Some kind of ARGB scaling is specified.  Can the driver
	     * do any kind of alpha blending at all?
	     */
            if (!(caps.dwBothFXCaps & DDFXCAPS_BLTALPHA))
	    {
		GETFAILCODEBLT(caps.dwFXCaps,
			       caps.dwHELFXCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFXCAPS_BLTALPHA);
		if (fail)
		{
		    DPF_ERR("ARGB scaling requested for blit, but not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }

	    /*
	     * We permit a color factor to be bigger than the alpha
	     * factor only if the hardware uses saturated arithmetic
	     * to prevent the calculated color value from overflowing.
	     */
	    if (!(dwFlags & DDABLT_NOBLEND) &&
		   (ddargbScaleFactors.red   > ddargbScaleFactors.alpha ||
		    ddargbScaleFactors.green > ddargbScaleFactors.alpha ||
		    ddargbScaleFactors.blue  > ddargbScaleFactors.alpha))
	    {
		/*
		 * Driver must be capable of doing saturated arithmetic.
		 */
		if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTSATURATE))
		{
		    GETFAILCODEBLT(caps.dwAlphaCaps,
				   caps.dwHELAlphaCaps,
				   sbi.halonly,
				   sbi.helonly,
				   DDALPHACAPS_BLTSATURATE);
		    if (fail)
		    {
			// Neither the H/W driver nor HEL can handle it, so fail.
			DPF_ERR("Driver can't do saturated arithmetic during alpha blending");
			LEAVE_BOTH_NOBUSY();
			return DDERR_NOALPHAHW;
		    }
		}
	    }
	    /*
	     * Is this an alpha-blit or an alpha-fill operation?
	     */
	    if (surf_src_lcl == NULL)
	    {
		/*
		 * This is an alpha fill.  Can the driver handle it?
		 */
		if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTALPHAFILL))
		{
		    GETFAILCODEBLT(caps.dwAlphaCaps,
				   caps.dwHELAlphaCaps,
				   sbi.halonly,
				   sbi.helonly,
				   DDALPHACAPS_BLTALPHAFILL);
		    if (fail)
		    {
			// Neither the H/W driver nor HEL can handle it, so fail.
			DPF_ERR("Driver can't do alpha-blended color-fill operation");
			LEAVE_BOTH_NOBUSY();
			return DDERR_NOALPHAHW;
		    }
		}
    	    }
	    else
	    {
    		/*
		 * Alpha blit.  Can the driver handle any ARGB scaling at all?
		 */
		#define ARGBSCALINGBITS   \
		(DDALPHACAPS_BLTARGBSCALE1F | DDALPHACAPS_BLTARGBSCALE2F | DDALPHACAPS_BLTARGBSCALE4F)

		if (!(caps.dwBothAlphaCaps & ARGBSCALINGBITS))
		{
		    GETFAILCODEBLT(caps.dwAlphaCaps,
				   caps.dwHELAlphaCaps,
				   sbi.halonly,
				   sbi.helonly,
				   ARGBSCALINGBITS);
		    if (fail)
		    {
			// Neither the H/W driver nor HEL can handle it, so fail.
			DPF_ERR("Driver can't handle any ARGB scaling at all");
			LEAVE_BOTH_NOBUSY();
			return DDERR_NOALPHAHW;
		    }
		}
		#undef ARGBSCALINGBITS

		if (ddargbScaleFactors.red != ddargbScaleFactors.green ||
			ddargbScaleFactors.red != ddargbScaleFactors.blue)
		{
		    /*
		     * Driver must be capable of doing 4-factor ARGB scaling.
		     */
		    if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTARGBSCALE4F))
		    {
			GETFAILCODEBLT(caps.dwAlphaCaps,
				       caps.dwHELAlphaCaps,
				       sbi.halonly,
				       sbi.helonly,
				       DDALPHACAPS_BLTARGBSCALE4F);
			if (fail)
			{
			    // Neither the H/W driver nor HEL can handle it, so fail.
			    DPF_ERR("Driver can't handle 4-factor ARGB scaling");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_NOALPHAHW;
			}
		    }
		}
		else if (ddargbScaleFactors.red != ddargbScaleFactors.alpha)
		{
		    /*
		     * Driver must be capable of doing 2-factor ARGB scaling.
		     */
		    if (!(caps.dwBothAlphaCaps & (DDALPHACAPS_BLTARGBSCALE2F |
						  DDALPHACAPS_BLTARGBSCALE4F)))
		    {
			GETFAILCODEBLT(caps.dwAlphaCaps,
				       caps.dwHELAlphaCaps,
				       sbi.halonly,
				       sbi.helonly,
				       DDALPHACAPS_BLTARGBSCALE2F |
						  DDALPHACAPS_BLTARGBSCALE4F);
			if (fail)
			{
			    // Neither the H/W driver nor HEL can handle it, so fail.
			    DPF_ERR("Driver can't handle 2-factor ARGB scaling");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_NOALPHAHW;
			}
		    }
		}
	    }
	}
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_BOTH_NOBUSY();
	return DDERR_INVALIDPARAMS;
    }

    DDASSERT(!(sbi.halonly && sbi.helonly));

    /*
     * Are we permitted to degrade the specified ARGB-scaling operation
     * to one the driver can handle?
     */
    if (dwFlags & DDABLT_DEGRADEARGBSCALING)
    {
	DWORD dwFXCaps, dwAlphaCaps;

        // Get the caps for the selected driver.
	dwFXCaps = (sbi.helonly) ? caps.dwHELFXCaps : caps.dwFXCaps;
	dwAlphaCaps = (sbi.helonly) ? caps.dwHELAlphaCaps : caps.dwAlphaCaps;

	if (!(dwFXCaps & DDFXCAPS_BLTALPHA))
	{
	    /*
	     * The driver should have done this anyway, but just in case...
	     */
	    dwAlphaCaps = 0;
	}

	/*
	 * Is this a blit or a fill operation?
	 */
	if (surf_src_lcl == NULL)
	{
	    /*
	     * This is a fill -- and possibly an alpha fill.
	     */
	    if (!(dwAlphaCaps & DDALPHACAPS_BLTALPHAFILL))
	    {
		/*
		 * The driver can't do an alpha fill, so we'll ask
		 * it to do just a simple color fill instead.
		 */
		ddargbScaleFactors.alpha = 255;
	    }
	}
	else
	{
	    /*
	     * This is a blit.  What are the driver's ARGB-scaling capabilities?
	     */
	    if (!(dwAlphaCaps & (DDALPHACAPS_BLTARGBSCALE1F |
				 DDALPHACAPS_BLTARGBSCALE2F |
				 DDALPHACAPS_BLTARGBSCALE4F)))
	    {
		/*
		 * Driver can't do any kind of ARGB scaling at all, so just
		 * disable ARGB scaling by setting all four factors to 255.
		 */
		*(LPDWORD)&ddargbScaleFactors = ~0UL;
	    }
	    else if (!(dwAlphaCaps & (DDALPHACAPS_BLTARGBSCALE2F |
				      DDALPHACAPS_BLTARGBSCALE4F)))
	    {
    		/*
		 * The driver can do only 1-factor ARGB scaling, so set the
		 * three color factors to the same value as the alpha factor.
		 */
                *(LPDWORD)&ddargbScaleFactors = 0x01010101UL*ddargbScaleFactors.alpha;
	    }
	    else if (!(dwAlphaCaps & DDALPHACAPS_BLTARGBSCALE4F))
	    {
    		/*
		 * Driver can do only 2-factor ARGB scaling, so make sure
		 * all three color factors are set to the same value.
		 */
		if (ddargbScaleFactors.red != ddargbScaleFactors.green ||
			ddargbScaleFactors.red != ddargbScaleFactors.blue)
		{
		    /*
		     * Set all three color factors to value F, which is the
		     * weighted average of their specified values (Fr,Fg,Fb):
		     *     F = .299*Fr + .587*Fg + .114*Fb
		     */
		    DWORD F = 19595UL*ddargbScaleFactors.red +
				38470UL*ddargbScaleFactors.green +
				7471UL*ddargbScaleFactors.blue;

		    ddargbScaleFactors.red =
			ddargbScaleFactors.green =
			ddargbScaleFactors.blue = (BYTE)(F >> 16);
		}
	    }
	    if (!(dwAlphaCaps & DDALPHACAPS_BLTALPHAANDARGBSCALING))
	    {
    		/*
		 * Driver can't handle both a source alpha channel and ARGB scaling
		 * factors in the same blit operation, so just turn off ARGB scaling.
		 */
		*(LPDWORD)&ddargbScaleFactors = ~0UL;
	    }
	}

	/*
	 * Can driver do saturated arithmetic for alpha blit or alpha fill?
	 */
	if (!(dwAlphaCaps & DDALPHACAPS_BLTSATURATE))
	{
	    /*
	     * Driver can't do saturated arithmetic, so make sure no
	     * no color factors exceed the value of the alpha factor.
	     */
	    if (ddargbScaleFactors.red > ddargbScaleFactors.alpha)
	    {
		ddargbScaleFactors.red = ddargbScaleFactors.alpha;
	    }
	    if (ddargbScaleFactors.green > ddargbScaleFactors.alpha)
	    {
		ddargbScaleFactors.green = ddargbScaleFactors.alpha;
	    }
	    if (ddargbScaleFactors.blue > ddargbScaleFactors.alpha)
	    {
		ddargbScaleFactors.blue = ddargbScaleFactors.alpha;
	    }
	}
    }

    /*
     * Tell the driver to do the blit.
     */
    TRY
    {
	/*
	 * Finish loading blit data for HAL callback.
	 */
        bd.lpDD = pdrv;
	bd.lpDDDestSurface = surf_dest_lcl;
	bd.lpDDSrcSurface = surf_src_lcl;
	bd.ddargbScaleFactors = ddargbScaleFactors;
        bd.bltFX.dwSize = sizeof( DDBLTFX );
	/*
	 * For the AlphaBlt callback, the rOrigDest and rOrigSrc members
	 * ALWAYS contain the original dest and source rects.
	 */
	bd.rOrigDest = bd.rDest;
	bd.rOrigSrc = bd.rSrc;
        /*
         * The only AlphaBlt API flags that are propagated to the
	 * driver are those that have no Blt API equivalents.
         */
	bd.dwAFlags = dwFlags & (DDABLT_FILTERENABLE | DDABLT_FILTERDISABLE |
				 DDABLT_FILTERTRANSPBORDER | DDABLT_NOBLEND);
        /*
         * This flag tells the driver that it's a source-over-dest operation.
         * This flag is never passed by the Blt API, so drivers which have a
         * unified DDI can distinguish who called them
         */
        bd.dwAFlags |= DDABLT_SRCOVERDEST;

	if (dwFlags & DDABLT_KEYSRC)   // source color key?
	{
	    bd.dwFlags |= DDBLT_KEYSRCOVERRIDE;
	    bd.bltFX.ddckSrcColorkey = surf_src_lcl->ddckCKSrcBlt;
	}

	if (dwFlags & (DDABLT_MIRRORLEFTRIGHT | DDABLT_MIRRORUPDOWN))
	{
	    bd.dwFlags |= DDBLT_DDFX;

	    if (dwFlags & DDABLT_MIRRORLEFTRIGHT)    //left-right mirroring?
	    {
		bd.bltFX.dwDDFX |= DDBLTFX_MIRRORLEFTRIGHT;
	    }
	    if (dwFlags & DDABLT_MIRRORUPDOWN)	     // up-down mirroring?
	    {
		bd.bltFX.dwDDFX |= DDBLTFX_MIRRORUPDOWN;
	    }
	}

	/*
	 * If the specified blit operation can be handled by the Blt HAL
	 * callback instead of by the AlphaBlt HAL callback, should it
	 * treat the blit as a color-fill or a source-copy operation?
	 */
	if (surf_src_lcl != NULL)
	{
	    //it's a srccopy. Set flags appropriately
	    bd.dwFlags |= DDBLT_ROP;
	    bd.bltFX.dwROP = SRCCOPY;
	    bd.dwROPFlags = ROP_HAS_SOURCE;  // 0x00000001
	}
	else
	{
            // This is a fill operation of some kind.
	    if (dwFlags & DDABLT_USEFILLVALUE)
	    {
    		HRESULT hres;

		// The client specified a fill value in the dest pixel format.
		bd.bltFX.dwFillColor = dwFillValue;
                bd.dwFlags |= DDBLT_COLORFILL;
	    }
	    else if ((bd.ddargbScaleFactors.alpha == 255) || (dwFlags & DDABLT_NOBLEND))
	    {
                // The client specified an alpha fill, but no alpha blending is
		// required, so we can replace it with a simple color fill.
		// convert the ARGB value to a physcolor:
		HRESULT hres = ConvertToPhysColor(
						  surf_dest_lcl,
						  &bd.ddargbScaleFactors,
						  &bd.bltFX.dwFillColor);

                // Make sure this is not a FOURCC or some other funny pixel format.
		if (hres == DD_OK)
		{
		    bd.dwFlags |= DDBLT_COLORFILL;
		}
	    }
	}

#ifdef WINNT
	// Did the mode change since ENTER_DDRAW?
	if (DdQueryDisplaySettingsUniqueness() != uDisplaySettingsUnique)
	{
	    // mode changed, don't do the blt
	    DPF_ERR("Mode changed between ENTER_DDRAW and HAL call");
	    LEAVE_BOTH_NOBUSY()
		return DDERR_SURFACELOST;
	}
#endif

#if defined(WIN95)
	/*
	 * Some drivers (like S3) do stuff in their BeginAccess call
	 * that screws up stuff that they did in their DDHAL Lock Call.
	 *
	 * Exclusion needs to happen BEFORE the lock call to prevent this.
	 *
	 */
	if (surf_dest_lcl->lpDDClipper != NULL)
	{
	    /*
	     * exclude the mouse cursor.
	     *
	     * we only need to do this for the windows display driver
	     *
	     * we only need to do this if we are blitting to or from the
	     * primary surface.
	     *
	     * we only do this in the clipping case, we figure if the
	     * app cares enough to not scribble all over other windows
	     * he also cares enough to not to wipe out the cursor.
	     *
	     * we only need to do this if the driver is using a
	     * software cursor.
	     *
	     * NOTE
	     *  we should check and only do this on the primary?
	     *  we should make sure the clipper is window based?
	     *  we should check for the source being the primary?
	     *
	     */
	    if ((pdrv->dwFlags & DDRAWI_DISPLAYDRV) && pdrv->dwPDevice &&
		!(*pdrv->lpwPDeviceFlags & HARDWARECURSOR) &&
                (surf_dest->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) )
	    {
		if (lpDDDestSurface == lpDDSrcSurface)
		{
		    RECTL rcl;
		    UnionRect((RECT*)&rcl, (RECT*)&bd.rDest, (RECT*)&bd.rSrc);
		    DD16_Exclude(pdrv->dwPDevice, &rcl);
		}
		else
		{
		    DD16_Exclude(pdrv->dwPDevice, &bd.rDest);
		}
	    }
	}
#endif

#ifdef WINNT
    get_clipping_info:
#endif
	/*
	 * Determine clipping region for destination surface.
	 */
	{
	    LPDIRECTDRAWCLIPPER pClipper;
	    RECT rcDestSurf;

	    pRgn = (LPRGNDATA)&myRgnBuffer;  // this buffer's probably big enough
	    pClipper = (LPDIRECTDRAWCLIPPER)surf_dest_lcl->lpSurfMore->lpDDIClipper;
	    SetRect(&rcDestSurf, 0, 0, surf_dest->wWidth, surf_dest->wHeight);

	    if (pClipper == NULL)
	    {
		/*
		 * The destination surface has no attached clipper.
		 * Set the clip region to a single rectangle the
		 * width and height of the primary surface.
		 */
		pRgn->rdh.nCount = 1;        // default = a single clip rect
		memcpy((LPRECT)&pRgn->Buffer, &rcDestSurf, sizeof(RECT));
                /*
                 * Add a rect to the region list if this is a managed surface
                 */
                if(IsD3DManaged(surf_dest_lcl))
                {
                    LPREGIONLIST lpRegionList = surf_dest_lcl->lpSurfMore->lpRegionList;
                    if(lpDestRect)
                    {
                        if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                        {
                            lpRegionList->rect[(lpRegionList->rdh.nCount)++] = bd.rDest;
                            lpRegionList->rdh.nRgnSize += sizeof(RECT);
                            if(bd.rDest.left < lpRegionList->rdh.rcBound.left)
                                lpRegionList->rdh.rcBound.left = bd.rDest.left;
                            if(bd.rDest.right > lpRegionList->rdh.rcBound.right)
                                lpRegionList->rdh.rcBound.right = bd.rDest.right;
                            if(bd.rDest.top < lpRegionList->rdh.rcBound.top)
                                lpRegionList->rdh.rcBound.top = bd.rDest.top;
                            if(bd.rDest.bottom > lpRegionList->rdh.rcBound.bottom)
                                lpRegionList->rdh.rcBound.bottom = bd.rDest.bottom;
                        }
                    }
                    else
                    {
                        /* Mark everything dirty */
                        lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                    }
                }
	    }
	    else
	    {
		DWORD rgnSize = 0;
		LPDDRAWI_DIRECTDRAW_GBL pdrv = surf_dest_lcl->lpGbl->lpDD;

		/*
		 * This surface has an attached clipper.  Get the clip list.
		 */
		ddrval = InternalGetClipList(pClipper,
					     &rcDestSurf,
					     NULL,  // we just want rgnSize
					     &rgnSize,
					     pdrv);
		if (ddrval != DD_OK)
		{
		    DPF_ERR("Couldn't get size of clip region");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_GENERIC;
		}
		if (rgnSize > sizeof(myRgnBuffer))
		{
		    /*
		     * Statically allocated region buffer isn't big enough.
		     * Need to dynamically allocate a bigger buffer.
		     */
		    pRgn = (LPRGNDATA)MemAlloc(rgnSize);
		    if (!pRgn)
		    {
			// couldn't allocate memory for clip region
			DPF_ERR("Can't allocate memory to buffer clip region");
			LEAVE_BOTH_NOBUSY();
			return DDERR_OUTOFMEMORY;
		    }
		}
		ddrval = InternalGetClipList(pClipper,
					     &rcDestSurf,
					     pRgn,
					     &rgnSize,
					     pdrv);
		if (ddrval != DD_OK)
		{
		    // can't get clip region
		    if (pRgn != (LPRGNDATA)&myRgnBuffer)
		    {
			MemFree(pRgn);
		    }
		    DPF_ERR("Can't get dest clip region");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_GENERIC;
		}

                if(IsD3DManaged(surf_dest_lcl))
                {
                    /* We don't want to deal with this mess, so mark everything dirty */
                    surf_dest_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                }
	    }
	    /*
	     * Load clipping info into data struct for HAL callback.
	     */
	    bd.dwRectCnt = pRgn->rdh.nCount;
	    bd.prDestRects = (LPRECT)&pRgn->Buffer;
	}

	/*
	 * Does the driver have to do any clipping?
	 */
	if (bd.dwRectCnt > 1)
	{
            // Yes, clipping is (probably) required.
	    bd.IsClipped = TRUE;
	}
	else if (bd.dwRectCnt == 0)
	{
	    // Window is completely obscured, so don't draw anything.
	    LEAVE_BOTH_NOBUSY();
	    return DD_OK;
	}
	else
	{
	    /*
	     * The visibility region consists of a single clip rect.
	     * Is any portion of the destination rectangle visible?
	     */
	    if (!IntersectRect((LPRECT)&bd.rDest, (LPRECT)&bd.rOrigDest,
				&bd.prDestRects[0]))
	    {
		// No portion of the destination rectangle is visible.
		LEAVE_BOTH_NOBUSY();
		return DD_OK;
	    }

	    /*
	     * Will the source rectangle have to be adjusted to
	     * compensate for the clipping of the dest rect?
	     */
	    if (surf_src_lcl != NULL &&
		    !EqualRect((LPRECT)&bd.rDest, (LPRECT)&bd.rOrigDest))
	    {
		// Yes, the source rect must be adjusted.
		if (sbi.dest_width != sbi.src_width ||
			sbi.dest_height != sbi.src_height)
		{
		    /*
		     * The driver must do the clipping for a stretched blit
		     * because bd.rSrc permits us to express the adjusted
		     * source rect only to the nearest integer coordinates.
		     */
		    bd.IsClipped = TRUE;
		}
		else
		{
    		    // We can do the clipping here for a nonstretched blit.
		    POINT p;

		    p.x = bd.rOrigSrc.left - bd.rOrigDest.left;
		    p.y = bd.rOrigSrc.top  - bd.rOrigDest.top;
		    CopyRect((LPRECT)&bd.rSrc, (LPRECT)&bd.rDest);
		    OffsetRect((LPRECT)&bd.rSrc, p.x, p.y);
		}
	    }
	}

        /*
	 * Older drivers may support the Blt callback, but not the AlphaBlt
	 * callback.  One of these drivers may be able to perform the specified
	 * blit operation as long as it doesn't use any AlphaBlt-specific
	 * features such as alpha blending, ARGB scaling, or filtering.
	 * In this case, we can use the Blt callback to perform the blit.
         * Decide which DDI to call. Start off assuming Alpha DDI
         */
	bltfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.AlphaBlt;
        bd.dwFlags |= DDBLT_AFLAGS;   // assume we'll use AlphaBlt callback

        /*
         * Check to see if we can pass this call to old blt DDI
         */
        if ( !((dwDDPFDestFlags | dwDDPFSrcFlags) & DDPF_ALPHAPIXELS) &&
		 !(dwFlags & DDABLT_FILTERENABLE) )
        {
            // There are no alpha pixels involved. Maybe we can use the Blt DDI
            if ( (bd.ddargbScaleFactors.alpha == 255) && (!sbi.helonly) )
            {
		LPDDPIXELFORMAT pDDPFDest = getPixelFormatPtr(surf_dest_lcl);
		LPDDPIXELFORMAT pDDPFSrc = getPixelFormatPtr(surf_src_lcl);

		// If this is a blit (and not a color fill), the source and dest pixel
		// formats must be identical and the scaling factors must all be 1.0.
		if ( (surf_src_lcl == NULL) ||
		     (!memcmp(pDDPFDest, pDDPFSrc, sizeof(DDPIXELFORMAT)) &&
		      (~0UL == *((LPDWORD)(&bd.ddargbScaleFactors)))) )
		{
		    // Make sure the driver doesn't have to do any clipping.  Also ensure
		    // that the driver does not require DDraw to pagelock sysmem surfaces.
		    if (!bd.IsClipped &&
    			(!caps.bHALSeesSysmem ||
                         pdrv->ddCaps.dwCaps2 & DDCAPS2_NOPAGELOCKREQUIRED))
		    {
			// Verify that the driver supports the Blt HAL callback.
			bltfn = (LPDDHAL_ALPHABLT) pdrv_lcl->lpDDCB->HALDDSurface.Blt;

			if (bltfn)
			{
			    bd.dwFlags &= ~DDBLT_AFLAGS;  // we'll use Blt callback
			    if (surf_src_lcl == NULL)
			    {
				DPF(4,"Calling Blt DDI for AlphaBlt color fill");
			    }
			    else
			    {
				DPF(4,"Calling Blt DDI for AlphaBlt copy");
			    }
			    /*
			     * The following thunk address is used by the Blt callback,
			     * but is ignored by the AlphaBlt callback.
			     */
			    bd.Blt = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Blt;
			}
		    }
		}
            }
        }

	/*
	 * Set up for a HAL or a HEL call?
	 */
	if (bltfn == NULL)
	{
            /*
             * Neither the alphablt nor blt ddi calls apply or aren't implemented
             */
	    sbi.helonly = TRUE;
	}
	if (sbi.helonly && sbi.halonly)
	{
	    DPF_ERR("AlphaBlt not supported in software or hardware");
	    if (pRgn != (LPRGNDATA)&myRgnBuffer)
	    {
		MemFree(pRgn);	 // this clip region was malloc'd
	    }
	    LEAVE_BOTH_NOBUSY();
	    return DDERR_NOBLTHW;
	}

	/*
	 * Can the hardware driver perform the blit?
	 */
	if (!sbi.helonly)
	{
	    /*
	     * Yes, we're going to do a hardware-accelerated blit.
	     */
	    DPF(4, "Hardware AlphaBlt");
            /*
             * The DDI was selected above
             */
	    //bd.AlphaBlt = NULL;  // 32-bit call, no thunk

	    /*
	     * Tell the hardware driver to perform the blit.  We may have to wait
	     * if the driver is still busy with a previous drawing operation.
	     */
	    do
	    {
		DOHALCALL_NOWIN16(AlphaBlt, bltfn, bd, rc, sbi.helonly);
                if (rc != DDHAL_DRIVER_HANDLED || bd.ddRVal != DDERR_WASSTILLDRAWING)
		{
		    break;    // driver's finished for better or worse...
		}
		DPF(4, "Waiting...");

	    } while (dwFlags & DDABLT_WAIT);

	    /*
	     * Was the hardware driver able to handle the blit?
	     */
	    if (rc == DDHAL_DRIVER_HANDLED)
	    {
#ifdef WINNT
                if (bd.ddRVal == DDERR_VISRGNCHANGED)
                {
                    if (pRgn != (LPRGNDATA)&myRgnBuffer)
                    {
                        MemFree(pRgn);
                    }
                    DPF(5,"Resetting VisRgn for surface %x", surf_dest_lcl);
                    DdResetVisrgn(surf_dest_lcl, (HWND)0);
                    goto get_clipping_info;
                }
#endif
		if (bd.ddRVal != DDERR_WASSTILLDRAWING)
		{
		    /*
		     * Yes, the blit was handled by the hardware driver.
		     * If source or dest surface is in system memory, tag it so
		     * we know it's involved in an ongoing hardware operation.
		     */
		    if (bd.ddRVal == DD_OK && caps.bHALSeesSysmem)
		    {
			DPF(5,B,"Tagging surface %08x", surf_dest);
			if (surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
			    surf_dest->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPDEST;
			if (surf_src)
			{
			    DPF(5,B,"Tagging surface %08x", surf_src);
			    if (surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
				surf_src->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
			}
		    }
		}
	    }
	    else
	    {
		DDASSERT(rc == DDHAL_DRIVER_NOTHANDLED);
		/*
		 * No, the hardware driver says it could not handle the blit.
		 * If sbi.halonly = FALSE, we'll let the HEL do the blit.
		 */
		sbi.helonly = TRUE;   // force fail-over to HEL
	    }
	}

	/*
	 * Do we need to ask the HEL to perform the blit?
	 */
	if (sbi.helonly && !sbi.halonly)
	{
	    /*
	     * Yes, we'll ask the HEL to do a software-emulated blit.
	     */
	    bltfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.AlphaBlt;
	    /*
	     * Is dest surface in system memory or video memory?
	     */
	    if (surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
	    {
		/*
		 * Destination surface is in system memory.
		 * If this surface was involved in a hardware op, we need to
		 * probe the driver to see if it's done.  NOTE: This assumes
		 * that only one driver can be responsible for a system-memory
		 * operation. See comment with WaitForHardwareOp.
		 */
		if (surf_dest->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED)
		{
		    WaitForHardwareOp(pdrv_lcl, surf_dest_lcl);
		}
		dest_lock_taken = FALSE;
	    }
	    else
	    {
		/*
		 * Wait loop:  Take write lock on dest surface in video memory.
		 */
		while(1)
		{
		    ddrval = InternalLock(surf_dest_lcl, &dest_bits, NULL, 0);
		    if (ddrval == DD_OK)
		    {
			GET_LPDDRAWSURFACE_GBL_MORE(surf_dest)->fpNTAlias = (FLATPTR)dest_bits;
			break;   // successfully locked dest surface
		    }
		    if (ddrval != DDERR_WASSTILLDRAWING)
		    {
			/*
			 * Can't lock dest surface.  Fail the call.
			 */
			if (pRgn != (LPRGNDATA)&myRgnBuffer)
			{
			    MemFree(pRgn);   // this clip region was malloc'd
			}
			DONE_EXCLUDE();
			DONE_BUSY();
			LEAVE_BOTH();
			return ddrval;
		    }
		}
		dest_lock_taken = TRUE;
	    }

	    if (surf_src && surf_src != surf_dest)
	    {
		/*
		 * Is source surface in system memory or video memory?
		 */
		if (surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
		{
		    /*
		     * Source surface is in system memory.
		     * If this surface was involved in a hardware op, we need to
		     * probe the driver to see if it's done.  NOTE: This assumes
		     * that only one driver can be responsible for a system-memory
		     * operation. See comment with WaitForHardwareOp.
		     */
		    if (surf_src &&
			surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY &&
			surf_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED)
		    {
			WaitForHardwareOp(pdrv_lcl, surf_src_lcl);
		    }
		    src_lock_taken = FALSE;
		}
		else
		{
		    /*
		     * Wait loop:  Take lock on source surface in video memory.
		     */
		    while(1)
		    {
			ddrval = InternalLock(surf_src_lcl, &src_bits, NULL, DDLOCK_READONLY);
			if (ddrval == DD_OK)
			{
			    GET_LPDDRAWSURFACE_GBL_MORE(surf_src)->fpNTAlias = (FLATPTR)src_bits;
			    break;   // successfully locked source surface
			}
			if (ddrval != DDERR_WASSTILLDRAWING)
			{
			    /*
			     * We can't lock the source surface.  Fail the call.
			     */
			    if (dest_lock_taken)
			    {
				InternalUnlock(surf_dest_lcl, NULL, NULL, 0);
			    }
			    if (pRgn != (LPRGNDATA)&myRgnBuffer)
			    {
				MemFree(pRgn);	 // this clip region was malloc'd
			    }
			    DONE_EXCLUDE();
			    DONE_BUSY();
			    LEAVE_BOTH();
			    return ddrval;
			}
		    }
		    src_lock_taken = TRUE;
		}
	    }

	    /*
	     * Tell the HEL to perform the blit.
	     */
#ifdef WINNT
    try_again:
#endif
            DOHALCALL_NOWIN16(AlphaBlt, bltfn, bd, rc, sbi.helonly);
#ifdef WINNT
	    if (rc == DDHAL_DRIVER_HANDLED && bd.ddRVal == DDERR_VISRGNCHANGED)
            {
                DPF(5,"Resetting VisRgn for surface %x", surf_dest_lcl);
                DdResetVisrgn(surf_dest_lcl, (HWND)0);
                goto try_again;
            }
#endif
	}

	/*
	 * If clip region was malloc'd, free it now.
	 */
	if (pRgn != (LPRGNDATA)&myRgnBuffer)
	{
	    MemFree(pRgn);
	}

        if(IsD3DManaged(surf_dest_lcl))
            MarkDirty(surf_dest_lcl);

	DONE_LOCKS();

	/*
	 * Exclusion needs to happen after unlock call
	 */
	DONE_EXCLUDE();
	DONE_BUSY();
	LEAVE_BOTH();
	return bd.ddRVal;
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
	DPF_ERR("Exception encountered doing alpha blt");
	DONE_LOCKS();
	DONE_EXCLUDE();
	DONE_BUSY();
	LEAVE_BOTH();
	return DDERR_EXCEPTION;
    }

} /* DD_Surface_AlphaBlt */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddagpnt.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagpnt.c
 *  Content:	Functions for dealing with AGP memory in DirectDraw on NT
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-jan-97	colinmc	initial implementation
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   07-may-97  colinmc Add support for AGP on OSR 2.1
 *   12-Feb-98  DrewB   Split into common, Win9x and NT sections.
 *
 ***************************************************************************/

#include "ddrawpr.h"

#ifndef WIN95

// Currently the hdev passed in is the DirectDraw global, so
// look up the AGP interface in it.
#define GET_AGPI(hdev) (&((EDD_DIRECTDRAW_GLOBAL *)hdev)->AgpInterface)

#define CHECK_GET_AGPI(hdev, pvai) \
    (pvai) = GET_AGPI(hdev); \
    ASSERTGDI((pvai)->Context != NULL, "No AGP context");

// Offset to use for biasing AGP heaps.
#define DDNLV_HEAP_BIAS PAGE_SIZE

/*
 * OsAGPReserve
 *
 * Reserve resources for use as an AGP aperture.
 */
BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                   FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                   PVOID *ppvReservation )
{
    AGP_INTERFACE *pai;
    BOOLEAN Cached;

    CHECK_GET_AGPI(hdev, pai);

    if (fIsUC)
    {
        Cached = FALSE;
    }
    else
    {
        Cached = TRUE;
    }

    // On NT heaps are kept with offsets rather than pointers so
    // always return a base offset as the starting address.  The
    // base offset is non-zero so that successful heap allocations
    // always have a non-zero value.
    *pfpLinStart = DDNLV_HEAP_BIAS;
    
    *pliDevStart = pai->AgpServices.
        AgpReservePhysical(pai->Context, dwNumPages,
                           Cached, ppvReservation);
    return *ppvReservation != NULL;
} /* OsAGPReserve */

/*
 * OsAGPCommit
 *
 * Commit memory to the given portion of a previously reserved range.
 */
BOOL OsAGPCommit( HANDLE hdev, PVOID pvReservation, DWORD dwPageOffset,
                  DWORD dwNumPages )
{
    AGP_INTERFACE *pai;

    CHECK_GET_AGPI(hdev, pai);

    return pai->AgpServices.AgpCommitPhysical(pai->Context,
                                              pvReservation,
                                              dwNumPages, dwPageOffset);
} /* OsAGPCommit */

/*
 * OsAGPDecommitAll
 *
 * Decommit everything in a reserved area.
 */
BOOL OsAGPDecommitAll( HANDLE hdev, PVOID pvReservation, DWORD dwNumPages )
{
    AGP_INTERFACE *pai;

    CHECK_GET_AGPI(hdev, pai);

    // Decommit memory.
    pai->AgpServices.AgpFreePhysical(pai->Context, pvReservation,
                                     dwNumPages, 0);
    return TRUE;
} /* OsAGPDecommitAll */

/*
 * OsAGPFree
 *
 * Free a previously reserved range.
 */
BOOL OsAGPFree( HANDLE hdev, PVOID pvReservation )
{
    AGP_INTERFACE *pai;
    
    CHECK_GET_AGPI(hdev, pai);

    pai->AgpServices.AgpReleasePhysical(pai->Context,
                                        pvReservation);
    return TRUE;
} /* OsAGPFree */

#endif // !WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddclip.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddclip.c
 *  Content:    DirectDraw clipper functions
 *
 *              NOTE:
 *              For functions that manipulate the winwatch list,
 *              we need to take the win16 lock after we take the directdraw
 *              lock.   The reason for this is that we can get an async
 *              call from the 16-bit side when a window is closed
 *              to release winwatch object.   Since the win16 lock is held
 *              when the callup occurs, this makes it safe to manipulate
 *              the structures.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   21-jun-95  craige  initial implementation
 *   23-jun-95  craige  connect with winwatch stuff
 *   25-jun-95  craige  minor bug fix; one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   02-jul-95  craige  commented out clipper notification stuff
 *   03-jul-95  craige  YEEHAW: new driver struct; SEH
 *   05-jul-95  craige  added Initialize
 *   11-jul-95  craige  fail aggregation calls
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock
 *   31-jul-95  craige  validate flags
 *   05-aug-95  craige  bug 260 - clip user defined rgn to screen
 *   09-dec-95  colinmc added execute buffer support
 *   15-dec-95  colinmc made clippers sharable across surfaces
 *   19-dec-95  kylej   added NT cliplist support
 *   02-jan-96  kylej   handle new interface structs.
 *   17-jan-96	kylej	fixed NT vis region bug
 *   22-feb-96  colinmc clippers no longer need to be associated with a
 *                      DirectDraw object - they can be created independently.
 *   03-mar-96  colinmc fixed problem with QueryInterface returning local
 *                      object rather than interface
 *   13-mar-96  colinmc added IID validation to QueryInterface.
 *   14-mar-96  colinmc added class factory support
 *   18-mar-96  colinmc Bug 13545: Independent clipper cleanup
 *   21-mar-96  colinmc Bug 13316: Unitialized interfaces
 *   09-apr-96  colinmc Bug 13991: Parameter validation on IsClipListChanged
 *   26-mar-96  jeffno  Watched HWNDs under NT
 *   20-sep-96	ketand  GetClipList optimization
 *   21-jan-96	ketand	Deleted unused WinWatch code. Fixed clipping for multi-mon.
 *   07-feb-96	ketand	bug5673: fix clipping when VisRgn is larger than ClientRect
 *   24-mar-97  jeffno  Optimized Surfaces
 *   05-nov-97 jvanaken Support for master sprite list in SetSpriteDisplayList
 *
 ***************************************************************************/

 #include "ddrawpr.h"

#ifdef WINNT
    #include "ddrawgdi.h"
#endif

// function in ddsprite.c to remove invalid clipper from master sprite list
extern void RemoveSpriteClipper(LPDDRAWI_DIRECTDRAW_GBL, LPDDRAWI_DDRAWCLIPPER_INT);

/*
 * GLOBAL NOTE: You will notice that these functions usually fetch the
 * DirectDraw global object pointer from the global clipper object during
 * parameter validation. You may wonder why this is given that clippers
 * are pretty much completely independent of drivers. Well, this is purely
 * for parameter validation purposes. We just want to ensure that we can
 * dereference the clipper global object - we could use any parameter.
 * So don't remove this code when you notice its not used. It serves
 * a purpose.
 * Probably should wrap this stuff up in a nice macro.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDraw::DD_UnInitedClipperQueryInterface"
/*
 * DD_UnInitedClipperQueryInterface
 */
HRESULT DDAPI DD_UnInitedClipperQueryInterface(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		REFIID riid,
		LPVOID FAR * ppvObj )
{
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_UnInitedClipperQueryInterface");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF( 1, "Invalid clipper pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
	this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * check guids
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawClipper) )
    {
	DD_Clipper_AddRef( lpDDClipper );
	*ppvObj = (LPVOID) this_int;
	LEAVE_DDRAW();
	return DD_OK;
    }
    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_UnInitedClipperQueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper::QueryInterface"

/*
 * DD_Clipper_QueryInterface
 */
HRESULT DDAPI DD_Clipper_QueryInterface(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		REFIID riid,
		LPVOID FAR * ppvObj )
{
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_QueryInterface");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF( 1, "Invalid clipper pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
	this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * check guids
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawClipper) )
    {
	DD_Clipper_AddRef( lpDDClipper );
	*ppvObj = (LPVOID) this_int;
	LEAVE_DDRAW();
	return DD_OK;
    }
    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_Clipper_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper::AddRef"

/*
 * DD_Clipper_AddRef
 */
DWORD DDAPI DD_Clipper_AddRef( LPDIRECTDRAWCLIPPER lpDDClipper )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    DWORD                       rcnt;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_AddRef");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;

	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * update clipper reference count
     */
    this->dwRefCnt++;
    this_lcl->dwLocalRefCnt++;
    this_int->dwIntRefCnt++;
    rcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;

    DPF( 5, "Clipper %08lx addrefed, refcnt = %ld", this, rcnt );

    LEAVE_DDRAW();
    return this_int->dwIntRefCnt;

} /* DD_Clipper_AddRef */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper::Release"

/*
 * RemoveClipperFromList
 *
 * Remove a clipper from its owning clipper list.
 *
 * The clipper can either be a member of a global clipper list
 * (if no DirectDraw object owns it) or the clipper list of its
 * owning DirectDraw driver object. If pdrv == NULL then the
 * clipper will be removed from the global clipper list. If
 * pdrv != NULL the clipper will be removed from the clipper
 * list of that driver object. It is an error if the clipper
 * is not on the appropriate clipper list.
 *
 * Returns TRUE if the clipper was succesfully removed
 * Returns FALSE if the clipper could not be found on the
 * appropriate clipper list
 */
static BOOL RemoveClipperFromList( LPDDRAWI_DIRECTDRAW_GBL pdrv,
			           LPDDRAWI_DDRAWCLIPPER_INT this_int )
{
    LPDDRAWI_DDRAWCLIPPER_INT curr_int;
    LPDDRAWI_DDRAWCLIPPER_INT last_int;

    curr_int = ( ( pdrv != NULL ) ? pdrv->clipperList : lpGlobalClipperList );
    last_int = NULL;
    while( curr_int != this_int )
    {
	last_int = curr_int;
	curr_int = curr_int->lpLink;
	if( curr_int == NULL )
	{
	    return FALSE;
	}
    }
    if( last_int == NULL )
    {
	if( pdrv != NULL )
	    pdrv->clipperList = pdrv->clipperList->lpLink;
	else
	    lpGlobalClipperList = lpGlobalClipperList->lpLink;
    }
    else
    {
	last_int->lpLink = curr_int->lpLink;
    }

    return TRUE;
}

/*
 * InternalClipperRelease
 *
 * Done with a clipper.   if no one else is using it, then we can free it.
 * Also called by ProcessClipperCleanup
 *
 * Assumes DirectDrawLock is taken
 */
ULONG DDAPI InternalClipperRelease( LPDDRAWI_DDRAWCLIPPER_INT this_int )
{
    DWORD			intrefcnt;
    DWORD                       lclrefcnt;
    DWORD                       gblrefcnt;
    LPDDRAWI_DDRAWCLIPPER_LCL	this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    BOOL                        root_object_deleted;
    BOOL                        do_free;
    IUnknown *                  pOwner = NULL;

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;
    pdrv = this->lpDD;

    /*
     * decrement reference count to this clipper.  If it hits zero,
     * cleanup
     */
    this->dwRefCnt--;
    this_lcl->dwLocalRefCnt--;
    this_int->dwIntRefCnt--;
    gblrefcnt = this->dwRefCnt;
    lclrefcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;
    intrefcnt = this_int->dwIntRefCnt;
    root_object_deleted = FALSE;
    DPF( 5, "Clipper %08lx released, refcnt = %ld", this, lclrefcnt );

    /*
     * interface object deleted?
     */
    if( intrefcnt == 0 )
    {
	RemoveClipperFromList( pdrv, this_int );
#ifdef POSTPONED2
	/*
	 * If clipper interface object is referenced in master sprite
	 * list, delete those references from the list.
	 */
	if (this->dwFlags & DDRAWICLIP_INMASTERSPRITELIST)
	{
    	    RemoveSpriteClipper(pdrv, this_int);
	}
#endif //POSTPONED2

	/*
	 * Invalidate the interface and free it
	 */
	this_int->lpVtbl = NULL;
	this_int->lpLcl = NULL;

	MemFree( this_int );
    }


    /*
     * local object deleted?
     */
    if( lclrefcnt == 0 )
    {

        /*
         * If the ddraw interface which created this clipper caused the surface to addref the ddraw
         * object, then we need to release that addref now.
         */
        pOwner = this_lcl->pAddrefedThisOwner;

	/*
	 * see if we are deleting the root object
	 */
	if( this_lcl->dwLocalRefCnt & OBJECT_ISROOT )
	{
	    root_object_deleted = TRUE;
	}
    }

    /*
     * did the object get globally deleted?
     */
    do_free = FALSE;
    if( gblrefcnt == 0 )
    {
	do_free = TRUE;

	// Need to free the static clip list
	MemFree( this->lpStaticClipList );
	this->lpStaticClipList = NULL;

	/*
	 * if this was the final delete, but this wasn't the root object,
	 * then we need to delete the dangling root object
	 */
	if( !root_object_deleted )
	{
	    LPDDRAWI_DDRAWCLIPPER_LCL   rootx;

	    rootx = (LPVOID) (((LPSTR) this) - sizeof( DDRAWI_DDRAWCLIPPER_LCL ) );
	    MemFree( rootx );
	}
    }
    else if( lclrefcnt == 0 )
    {
	/*
	 * only remove the object if it wasn't the root.   if it
	 * was the root, we must leave it dangling until the last
	 * object referencing it goes away.
	 */
	if( !root_object_deleted )
	{
	    do_free = TRUE;
	}
    }

    /*
     * free the object if needed
     */
    if( do_free )
    {
	/*
	 * just in case someone comes back in with this pointer, set
	 * an invalid vtbl & data ptr.
	 */
	this_lcl->lpGbl = NULL;

	MemFree( this_lcl );
    }

    /*
     * If the clipper took a ref count on the ddraw object that created it,
     * release that ref now as the very last thing
     * We don't want to do this on ddhelp's thread cuz it really mucks up the
     * process cleanup stuff. 
     */
    if (pOwner && (dwHelperPid != GetCurrentProcessId()) )
    {
        pOwner->lpVtbl->Release(pOwner);
    }

    return intrefcnt;

} /* InternalClipperRelease */

/*
 * DD_Clipper_Release
 */
ULONG DDAPI DD_Clipper_Release( LPDIRECTDRAWCLIPPER lpDDClipper )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    ULONG                       rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_Release");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALIDEX_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;

	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    rc = InternalClipperRelease( this_int );
    LEAVE_DDRAW();
    return rc;

} /* DD_Clipper_Release */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper::SetHwnd"
/*
 * DD_Clipper_SetHWnd
 */
HRESULT DDAPI DD_Clipper_SetHWnd(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		DWORD dwFlags,
		HWND hWnd )
{
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;


    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_SetHWnd");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( hWnd != NULL )
	{
	    if( !IsWindow( hWnd ) )
	    {
		DPF_ERR( "Invalid window handle" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    (HWND) this->hWnd = hWnd;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Clipper_SetHWnd */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper::GetHwnd"
/*
 * DD_Clipper_GetHWnd
 */
HRESULT DDAPI DD_Clipper_GetHWnd(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		HWND FAR *lphWnd )
{
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;

    /*
     * validate parms
     */
    TRY
    {
	ENTER_DDRAW();

	DPF(2,A,"ENTERAPI: DD_Clipper_GetHWnd");

	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_HWND_PTR( lphWnd ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
	*lphWnd = (HWND) this->hWnd;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Clipper_GetHWnd */

#define SIZE_OF_A_CLIPLIST(lpRgn) \
        (sizeof(RGNDATAHEADER)+sizeof(RECTL)*lpRgn->rdh.nCount)

HRESULT InternalGetClipList(
    		LPDIRECTDRAWCLIPPER lpDDClipper,
		LPRECT lpRect,
		LPRGNDATA lpClipList,
		LPDWORD lpdwSize,
		LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    HRESULT	    ddrval = DD_OK;
    DWORD	    cbRealSize;
    HDC             hdc;
    HRGN            hrgn;
    RECT	    rectT;
#ifndef WIN95
    DWORD           cbSaveSize;
#endif

    this = ((LPDDRAWI_DDRAWCLIPPER_INT)(lpDDClipper))->lpLcl->lpGbl;

    // if no hwnd specified, then it is just a static cliplist
    if( this->hWnd == 0 )
    {
	if( this->lpStaticClipList == NULL )
	{
	    return DDERR_NOCLIPLIST;
	}
	cbRealSize = SIZE_OF_A_CLIPLIST( this->lpStaticClipList );
	if( lpClipList == NULL )
	{
	    *lpdwSize = cbRealSize;
	    return DD_OK;
	}
	if( *lpdwSize < cbRealSize )
	{
	    DPF_ERR( "Region size too small" );
	    *lpdwSize = cbRealSize;
	    return DDERR_REGIONTOOSMALL;
	}

	memcpy( lpClipList, this->lpStaticClipList, cbRealSize );
	ClipRgnToRect( lpRect, lpClipList );
	return DD_OK;
    }

    // Use an hwnd for the clipping
    #ifdef WIN95
    {
	hdc = GetDCEx( (HWND)this->hWnd, NULL, DCX_USESTYLE | DCX_CACHE );
	if( hdc == NULL )
	{
	    DPF_ERR( "GetDCEx failed" );
	    return DDERR_GENERIC;
	}

	hrgn = DD16_InquireVisRgn( hdc );
	if( hrgn == NULL )
	{
	    DPF_ERR( "InquireVisRgn failed" );
	    ReleaseDC( (HWND)this->hWnd, hdc );
	    return DDERR_GENERIC;
	}
    }
    #else
    {
        int APIENTRY GetRandomRgn( HDC hdc, HRGN hrgn, int iNum );
        int rc;

	hdc = GetDC( (HWND) this->hWnd );
	if( hdc == NULL )
	{
	    DPF_ERR( "GetDC failed" );
	    return DDERR_GENERIC;
	}

	// Create the appropriate Region object
	hrgn = CreateRectRgn( 0, 0, 0, 0 );
	if( hrgn == NULL )
	{
	    DPF_ERR( "CreateRectRgn failed" );
	    ReleaseDC( (HWND) this->hWnd, hdc );
	    return DDERR_GENERIC;
	}

	// Set the Region to the DC
	rc = GetRandomRgn( hdc, hrgn, 4 );
	if( rc == -1 )
	{
	    DPF_ERR( "GetRandomRgn failed" );
	    ReleaseDC( (HWND) this->hWnd, hdc );
	    DeleteObject( hrgn );
	    return DDERR_GENERIC;
	}
    }
    #endif

    // Client only asking for a size?
    if( lpClipList == NULL )
    {
	// Get the size
	*lpdwSize = GetRegionData( hrgn, 0, NULL );

	// Release allocations
	ReleaseDC( (HWND) this->hWnd, hdc );
	DeleteObject( hrgn );

	// Check if GetRegionData failed
	if( *lpdwSize == 0 )
	    return DDERR_GENERIC;
	return DD_OK;
    }

#ifndef WIN95
    // Store the size passed in, because GetRegionData may trash it.
    cbSaveSize = *lpdwSize;
#endif

    // Get the window's region's REGIONDATA
    cbRealSize = GetRegionData( hrgn, *lpdwSize, lpClipList );

#ifndef WIN95
    if (cbRealSize == 0)
    {
        cbRealSize = GetRegionData(hrgn, 0, NULL);
        if (cbSaveSize < cbRealSize)
        {
            ReleaseDC( (HWND)this->hWnd, hdc );
            DeleteObject( hrgn );

            *lpdwSize = cbRealSize;
            DPF(4, "size of clip region too small");
            return DDERR_REGIONTOOSMALL;
        }
    }
#endif

    ReleaseDC( (HWND)this->hWnd, hdc );
    DeleteObject( hrgn );

    if( cbRealSize == 0 )
    {
        DPF_ERR( "GetRegionData failed" );
	return DDERR_GENERIC;
    }

#ifdef WIN95
    // GetRegionData may have failed because the buffer
    // was too small
    if( *lpdwSize < cbRealSize )
    {
	DPF( 4, "size of clip region too small" );
	*lpdwSize = cbRealSize;
	return DDERR_REGIONTOOSMALL;
    }
#endif

    // Before we do anything more, we need to make sure
    // to clip the Rgn to ClientRect of the Window. Normally
    // this is not necessary; but InquireVisRgn might
    // tell us the vis region of the parent window if the window
    // was a dialog or other wnd that used CS_PARENTDC
    GetClientRect( (HWND) this->hWnd, &rectT );
    ClientToScreen( (HWND) this->hWnd, (LPPOINT)&rectT );
    ClientToScreen( (HWND) this->hWnd, ((LPPOINT)&rectT)+1 );
    ClipRgnToRect( &rectT, lpClipList );

    // lpDD may be NULL if the clipper was created independently
    if(	pdrv &&
	(pdrv->cMonitors > 1) &&
	(pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
	// On multi-mon systems, the Desktop coordinates may be different
	// from the device coordinates. On the primary, they are the same however.
	// The lpRect passed in is in device coordinates; so we need to convert it
	// into desktop coordinates.
	UINT i;
	LPRECT prectClip;

	if( pdrv->rectDevice.top != 0 ||
	    pdrv->rectDevice.left != 0 )
	{
	    RECT rectT;
	    if( lpRect != NULL )
	    {
	        rectT.left = lpRect->left + pdrv->rectDevice.left;
	        rectT.right = lpRect->right + pdrv->rectDevice.left;
	        rectT.top = lpRect->top + pdrv->rectDevice.top;
	        rectT.bottom = lpRect->bottom + pdrv->rectDevice.top;
	    }
	    else
	    {
	        rectT = pdrv->rectDevice;
	    }

	    // Clip the cliplist to the target rect
	    ClipRgnToRect( &rectT, lpClipList );

	    // Clip the cliplist to the device's rect
	    ClipRgnToRect( &pdrv->rectDevice, lpClipList );

	    // Iterate over each rect in the region
	    for (   i = 0, prectClip = (LPRECT)lpClipList->Buffer;
		    i < lpClipList->rdh.nCount;
		    i++, prectClip++ )
	    {
		// Convert each Rect into Device coordinates
		prectClip->left -= pdrv->rectDevice.left;
		prectClip->right -= pdrv->rectDevice.left;
		prectClip->top -= pdrv->rectDevice.top;
		prectClip->bottom -= pdrv->rectDevice.top;
	    }
	}
	else
	{
	    // Clip the cliplist to the target rect
	    ClipRgnToRect( lpRect, lpClipList );

	    // Clip the cliplist to the device's rect
	    ClipRgnToRect( &pdrv->rectDesktop, lpClipList );
	}
    }
    else
    {
        ClipRgnToRect( lpRect, lpClipList );
    }

    return DD_OK;
}


/*
 * DD_Clipper_GetClipList
 */
HRESULT DDAPI DD_Clipper_GetClipList(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		LPRECT lpRect,
		LPRGNDATA lpClipList,
		LPDWORD lpdwSize )
{
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    DWORD                       size;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_GetClipList");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_DWORD_PTR( lpdwSize ) )
	{
	    DPF_ERR( "Invalid size ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( lpRect != NULL )
	{
	    if( !VALID_RECT_PTR( lpRect ) )
	    {
		DPF_ERR( "Invalid rectangle ptr" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    size = lpRect->left;
	}
	if( lpClipList != NULL )
	{
	    if( !VALID_RGNDATA_PTR( lpClipList, *lpdwSize ) )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDCLIPLIST;
	    }
	    // Touch the last address in the promised block to verify
	    // the memory is actually there.  Note that we are
	    // standing on our head here to prevent the optimizing
	    // compiler from helping us by removing this code.  This
	    // is done by the macro above, but we want it in the
	    // retail build, too.
	    {
		volatile BYTE *foo = ((BYTE*)lpClipList) + *lpdwSize - 1;
		BYTE bar = *foo;
	    }
	    lpClipList->rdh.nCount = 0;
	}

	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * go fetch the clip list
     */

    {
	HRESULT ddrval;

	#ifdef WIN16_SEPARATE
	    ENTER_WIN16LOCK();
	#endif

	ddrval = InternalGetClipList( lpDDClipper, lpRect, lpClipList, lpdwSize, pdrv );

	#ifdef WIN16_SEPARATE
	    LEAVE_WIN16LOCK();
	#endif

	LEAVE_DDRAW();
	return ddrval;
    }

} /* DD_Clipper_GetClipList */

/*
 * DD_Clipper_SetClipList
 */
HRESULT DDAPI DD_Clipper_SetClipList(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		LPRGNDATA lpClipList,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPRGNDATA                   prd;
    DWORD                       size;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_SetClipList");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;

	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( lpClipList != NULL )
	{
	    if( !VALID_RGNDATA_PTR( lpClipList, sizeof(RGNDATA) ) )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDCLIPLIST;
	    }

	    if( lpClipList->rdh.nCount <= 0 )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDCLIPLIST;
	    }

	    if( this_lcl->lpDD_int == NULL || this_lcl->lpDD_int->lpVtbl != &ddCallbacks )
	    {
		if( (lpClipList->rdh.dwSize < sizeof(RGNDATAHEADER)) ||
		    (lpClipList->rdh.iType != RDH_RECTANGLES ) ||
		    IsBadReadPtr(lpClipList, SIZE_OF_A_CLIPLIST(lpClipList)) )
		{
		    LEAVE_DDRAW();
		    return DDERR_INVALIDCLIPLIST;
		}
	    }
	}

	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * can't set a clip list if there is an hwnd
     */
    if( this->hWnd != 0 )
    {
	DPF_ERR( "Can't set a clip list: hwnd set" );
	LEAVE_DDRAW();
	return DDERR_CLIPPERISUSINGHWND;
    }

    /*
     * if NULL, just delete old cliplist
     */
    if( lpClipList == NULL )
    {
	MemFree( this->lpStaticClipList );
	this->lpStaticClipList = NULL;
	LEAVE_DDRAW();
	return DD_OK;
    }

    /*
     * duplicate the user's region data
     */
    size = SIZE_OF_A_CLIPLIST(lpClipList);
    prd = MemAlloc( size );
    if( prd == NULL )
    {
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }
    memcpy( prd, lpClipList, size );

    /*
     * save cliplist info
     */
    MemFree( this->lpStaticClipList );
    this->lpStaticClipList = prd;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Clipper_SetClipList */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper:IsClipListChanged"

/*
 * DD_Clipper_IsClipListChanged
 */
HRESULT DDAPI DD_Clipper_IsClipListChanged(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		BOOL FAR *lpbChanged )
{
    LPDDRAWI_DDRAWCLIPPER_INT	     this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL        this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL        this;
    volatile LPDDRAWI_DIRECTDRAW_GBL pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_IsClipListChanged");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
	*lpbChanged = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    #pragma message( REMIND( "Do we want to just fail non-watched IsClipListChanged?" ))
    *lpbChanged = TRUE;
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Clipper_IsClipListChanged */


#undef DPF_MODNAME
#define DPF_MODNAME "GetClipper"

/*
 * DD_Surface_GetClipper
 *
 * Surface function: get the clipper associated with surface
 */
HRESULT DDAPI DD_Surface_GetClipper(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAWCLIPPER FAR * lplpDDClipper)
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetClipper");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	if( !VALID_PTR_PTR( lplpDDClipper ) )
	{
	    DPF_ERR( "Invalid clipper pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*lplpDDClipper = NULL;
	pdrv = this->lpDD;

	if( this_lcl->lpSurfMore->lpDDIClipper == NULL )
	{
	    DPF_ERR( "No clipper associated with surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOCLIPPERATTACHED;
	}
        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    DD_Clipper_AddRef( (LPDIRECTDRAWCLIPPER) this_lcl->lpSurfMore->lpDDIClipper );
    *lplpDDClipper = (LPDIRECTDRAWCLIPPER) this_lcl->lpSurfMore->lpDDIClipper;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetClipper */

#undef DPF_MODNAME
#define DPF_MODNAME     "SetClipper"

/*
 * DD_Surface_SetClipper
 *
 * Surface function: set the clipper associated with surface
 */
HRESULT DDAPI DD_Surface_SetClipper(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAWCLIPPER lpDDClipper )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DDRAWCLIPPER_INT   this_clipper_int;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    BOOL                        detach;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetClipper");

    /*
     * validate parms
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER ||
            this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            /*
             * Can't attach a clipper to an execute buffer or an optimized
             * surface.
             */
            DPF_ERR( "Invalid surface type: can't attach clipper" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

        this_clipper_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
        if( this_clipper_int != NULL )
        {
            if( !VALID_DIRECTDRAWCLIPPER_PTR( this_clipper_int ) )
            {
                LEAVE_DDRAW();
                return DDERR_INVALIDOBJECT;
            }
        }
        pdrv = this->lpDD;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "Cannot set clipper to an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * NULL clipper, remove clipper from this surface
     */
    detach = FALSE;
    if( this_clipper_int == NULL )
    {
        detach = TRUE;
        this_clipper_int = this_lcl->lpSurfMore->lpDDIClipper;
        if( this_clipper_int == NULL )
        {
            DPF_ERR( "No attached clipper" );
            LEAVE_DDRAW();
            return DDERR_NOCLIPPERATTACHED;
        }
    }

    /*
     * removing the clipper from the surface?
     */
    if( detach )
    {
        this_lcl->lpDDClipper = NULL;
        this_lcl->lpSurfMore->lpDDIClipper = NULL;
        DD_Clipper_Release( (LPDIRECTDRAWCLIPPER) this_clipper_int );
        LEAVE_DDRAW();
        return DD_OK;
    }

    /*
     * Setting the clipper.
     * You can set the same clipper multiple times without bumping
     * the reference count. This is done for orthogonality with
     * palettes.
     */
    if( this_clipper_int != this_lcl->lpSurfMore->lpDDIClipper )
    {
        /*
         * If there was an existing clipper release it now.
         */
        if( this_lcl->lpSurfMore->lpDDIClipper != NULL)
            DD_Clipper_Release( (LPDIRECTDRAWCLIPPER) this_lcl->lpSurfMore->lpDDIClipper );

        this_lcl->lpSurfMore->lpDDIClipper = this_clipper_int;
        this_lcl->lpDDClipper = this_clipper_int->lpLcl;
        DD_Clipper_AddRef( (LPDIRECTDRAWCLIPPER) this_clipper_int );
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_SetClipper */

#undef DPF_MODNAME
#define DPF_MODNAME     "InternalCreateClipper"

/*
 * InternalCreateClipper
 *
 * Core clipper creation.
 *
 * NOTE: Assumes the caller has already entered the DirectDraw critical
 * section.
 */
HRESULT InternalCreateClipper(
		LPDDRAWI_DIRECTDRAW_GBL  lpDD,
		DWORD                    dwFlags,
		LPDIRECTDRAWCLIPPER FAR *lplpDDClipper,
		IUnknown FAR            *pUnkOuter,
		BOOL                     fInitialized,
		LPDDRAWI_DIRECTDRAW_LCL	lpDD_lcl,
		LPDDRAWI_DIRECTDRAW_INT lpDD_int )
{
    LPDDRAWI_DDRAWCLIPPER_INT	pclipper_int;
    LPDDRAWI_DDRAWCLIPPER_LCL   pclipper_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   pclipper;
    DWORD                       clipper_size;

    if( pUnkOuter != NULL )
    {
	return CLASS_E_NOAGGREGATION;
    }

    TRY
    {
	/*
	 * NOTE: We do not attempt to validate the DirectDraw
	 * object passed in. This will be NULL if we are creating
	 * a clipper not owned by any DirectDraw object.
	 * IDirectDraw_CreateClipper will validate this for us.
	 */

	if( !VALID_PTR_PTR( lplpDDClipper ) )
	{
	    DPF_ERR( "Invalid pointer to pointer to clipper" );
	    return DDERR_INVALIDPARAMS;
	}
	*lplpDDClipper = NULL;

	/*
	 * verify flags
	 */
	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * allocate the clipper object
     */
    clipper_size = sizeof( DDRAWI_DDRAWCLIPPER_GBL ) +
	       sizeof( DDRAWI_DDRAWCLIPPER_LCL );
    pclipper_lcl = (LPDDRAWI_DDRAWCLIPPER_LCL) MemAlloc( clipper_size );
    if( pclipper_lcl == NULL )
    {
	DPF_ERR( "Insufficient memory to allocate the clipper" );
	return DDERR_OUTOFMEMORY;
    }
    pclipper_lcl->lpGbl = (LPDDRAWI_DDRAWCLIPPER_GBL) (((LPSTR)pclipper_lcl) +
			sizeof( DDRAWI_DDRAWCLIPPER_LCL ) );
    pclipper = pclipper_lcl->lpGbl;
    pclipper_lcl->lpDD_lcl = lpDD_lcl;
    pclipper_lcl->lpDD_int = lpDD_int;


    pclipper_int = MemAlloc( sizeof( DDRAWI_DDRAWCLIPPER_INT ));
    if( NULL == pclipper_int)
    {
	DPF_ERR( "Insufficient memory to allocate the clipper" );
	MemFree( pclipper_lcl );
	return DDERR_OUTOFMEMORY;
    }

    /*
     * set up data
     */
    pclipper_int->lpLcl = pclipper_lcl;
    pclipper_int->dwIntRefCnt = 0;	// will be addrefed later

    /*
     * Link the clipper into the appropriate list (either the
     * given DirectDraw object's list or the global clipper
     * list dependening on whether it is being created off
     * a DirectDraw object or nor.
     */
    if( lpDD != NULL)
    {
	/*
	 * The DirectDraw object's list.
	 */
	pclipper_int->lpLink = lpDD->clipperList;
	lpDD->clipperList    = pclipper_int;
    }
    else
    {
	/*
	 * The global clipper list.
	 */
	pclipper_int->lpLink = lpGlobalClipperList;
	lpGlobalClipperList = pclipper_int;
    }

    /*
     * fill in misc stuff
     *
     * NOTE: The DirectDraw object pointer will be initialized by
     * IDirectDraw_CreateClipper. DirectDrawClipperCreate will
     * leave it NULL'd out.
     */
    pclipper->lpDD = lpDD;
    pclipper->dwFlags = 0UL;

    /*
     * bump reference count, return object
     */
    pclipper->dwProcessId = GetCurrentProcessId();
    pclipper_lcl->dwLocalRefCnt = OBJECT_ISROOT;

    if( fInitialized )
    {
	/*
	 * Initialized by default. Use the real vtable.
	 */
	pclipper->dwFlags |= DDRAWICLIP_ISINITIALIZED;
	pclipper_int->lpVtbl = (LPVOID) &ddClipperCallbacks;
    }
    else
    {
	/*
	 * Object is not initialized. Use the dummy vtable
	 * which only lets the caller call AddRef(), Release()
	 * and Initialize().
	 */
	pclipper_int->lpVtbl = (LPVOID) &ddUninitClipperCallbacks;
    }

    DD_Clipper_AddRef( (LPDIRECTDRAWCLIPPER) pclipper_int );

    *lplpDDClipper = (LPDIRECTDRAWCLIPPER) pclipper_int;

    /*
     * If this ddraw object generates independent child objects, then this clipper takes
     * a ref count on that ddraw object. First check lpDD_int, as this object may not
     * be owned by a DDraw object.
     */
    if (lpDD_int && CHILD_SHOULD_TAKE_REFCNT(lpDD_int))
    {
        IDirectDraw *pdd = (IDirectDraw*) lpDD_int;

        pdd->lpVtbl->AddRef(pdd);
        pclipper_lcl->pAddrefedThisOwner = (IUnknown *) pdd;
    }

    return DD_OK;
} /* InternalCreateClipper */

#undef DPF_MODNAME
#define DPF_MODNAME     "CreateClipper"

/*
 * DD_CreateClipper
 *
 * Driver function: create a clipper
 */
HRESULT DDAPI DD_CreateClipper(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPDIRECTDRAWCLIPPER FAR *lplpDDClipper,
		IUnknown FAR *pUnkOuter )
{
    HRESULT                     hRes;
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CreateClipper");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Actually create the clipper.
     */
    hRes = InternalCreateClipper( this, dwFlags, lplpDDClipper, pUnkOuter, TRUE, this_lcl, this_int );

    LEAVE_DDRAW();

    return hRes;
} /* DD_CreateClipper */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawCreateClipper"

/*
 * DirectDrawCreateClipper
 *
 * One of the three end-user API exported from DDRAW.DLL.
 * Creates a DIRECTDRAWCLIPPER object not owned by a
 * particular DirectDraw object.
 */
HRESULT WINAPI DirectDrawCreateClipper( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter )
{
    HRESULT hRes;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DirectDrawCreateClipper");	

    hRes = InternalCreateClipper( NULL, dwFlags, lplpDDClipper, pUnkOuter, TRUE, NULL, NULL );

    LEAVE_DDRAW();

    return hRes;
} /* DirectDrawCreateClipper */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper: Initialize"

/*
 * DD_Clipper_Initialize
 */
HRESULT DDAPI DD_Clipper_Initialize(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		LPDIRECTDRAW lpDD,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWCLIPPER_INT this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL this_gbl;
    LPDDRAWI_DIRECTDRAW_INT   pdrv_int;
    LPDDRAWI_DIRECTDRAW_GBL   pdrv_gbl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_Initialize");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid clipper interface pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this_lcl = this_int->lpLcl;
	this_gbl = this_lcl->lpGbl;

	pdrv_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( NULL != pdrv_int )
	{
	    if( !VALID_DIRECTDRAW_PTR( pdrv_int ) )
	    {
		DPF_ERR( "Invalid DirectDraw object" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    pdrv_gbl = pdrv_int->lpLcl->lpGbl;
	}
	else
	{
	    pdrv_gbl = NULL;
	}

	if( this_gbl->dwFlags & DDRAWICLIP_ISINITIALIZED )
	{
	    DPF_ERR( "Clipper already initialized" );
	    LEAVE_DDRAW();
	    return DDERR_ALREADYINITIALIZED;
	}

	/*
	 * Validate flags - no flags currently supported
	 */
	if( 0UL != dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * As we don't support any flags the only function of Initialize() is
     * to move the clipper from the global list to the list of the supplied
     * driver object. If no driver is supplied Initialized is a no-op.
     * CoCreateInstance() does all the initialization necessary.
     */
    if( NULL != pdrv_gbl )
    {
	RemoveClipperFromList( NULL, this_int );
	this_int->lpLink = pdrv_gbl->clipperList;
	pdrv_gbl->clipperList = this_int;
	this_gbl->lpDD = pdrv_gbl;
	this_lcl->lpDD_lcl = pdrv_int->lpLcl;
	this_lcl->lpDD_int = pdrv_int;
    }

    this_gbl->dwFlags |= DDRAWICLIP_ISINITIALIZED;

    /*
     * The real vtable can be used now.
     */
    this_int->lpVtbl = &ddClipperCallbacks;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Clipper_Initialize */

/*
 * ProcessClipperCleanup
 *
 * A process is done, clean up any clippers it may have created
 *
 * NOTE: we enter with a lock taken on the DIRECTDRAW object.
 */
void ProcessClipperCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDRAWCLIPPER_INT   pclipper_int;
    LPDDRAWI_DDRAWCLIPPER_INT   ppnext_int;
    DWORD                       rcnt;
    ULONG                       rc;

    /*
     * Cleaning up the clippers is now a two stage process. We need to
     * clean up all the clippers create via CreateClipper(), i.e., those
     * attached to a DirectDraw driver object. We also need to clean up
     * those clippers created by thise process with DirectDrawClipperCreate,
     * i.e., those not attached to a driver object.
     */

    /*
     * run through all clippers owned by the driver object, and find ones
     * that have been accessed by this process.  If the pdrv_lcl parameter is
     * non-null, only clean them up if they were created by that local object.
     */
    DPF( 4, "ProcessClipperCleanup" );

    if( NULL != pdrv )
    {
	DPF( 5, "Cleaning up clippers owned by driver object 0x%08x", pdrv );
	pclipper_int = pdrv->clipperList;
    }
    else
    {
	pclipper_int = NULL;
    }
    while( pclipper_int != NULL )
    {
	ppnext_int = pclipper_int->lpLink;

	/*
	 * All clippers in this list should have a valid back pointer to
	 * this driver object.
	 */
	DDASSERT( pclipper_int->lpLcl->lpGbl->lpDD == pdrv );

	rc = 1;
	if( (pclipper_int->lpLcl->lpGbl->dwProcessId == pid) &&
	    ( (pdrv_lcl == NULL) || (pdrv_lcl == pclipper_int->lpLcl->lpDD_lcl) ))
	{
	    /*
	     * release the references by this process
	     */
	    rcnt = pclipper_int->dwIntRefCnt;
	    DPF( 5, "Process %08lx had %ld accesses to clipper %08lx", pid, rcnt, pclipper_int );
	    while( rcnt >  0 )
	    {
		rc = InternalClipperRelease( pclipper_int );
		/* GEE: 0 is now an error code,
		 * errors weren't handled before anyway,
		 * does this matter.
		 */
		if( rc == 0 )
		{
		    break;
		}
		rcnt--;
	    }
	}
	else
	{
	    DPF( 5, "Process %08lx does not have access to clipper" );
	}
	pclipper_int = ppnext_int;
    }

    /*
     * Now clean up the global clipper list.
     * If the pdrv_lcl parameter is not NULL then we are only cleaning up clipper
     * objects created by a particular local driver object.  In this case we
     * do not want to free the global clippers.
     *
     * NOTE: The DirectDraw lock is taken so we can safely access this global object.
     */

    if( NULL != pdrv_lcl )
    {
	DPF( 4, "Not cleaning up clippers not owned by a driver object");
	return;
    }

    DPF( 4, "Cleaning up clippers not owned by a driver object" );

    pclipper_int = lpGlobalClipperList;
    while( pclipper_int != NULL )
    {
	ppnext_int = pclipper_int->lpLink;

	/*
	 * The clippers in this list should never have a back pointer to a driver
	 * object.
	 */
	DDASSERT( pclipper_int->lpLcl->lpGbl->lpDD == NULL );

	rc = 1;
	if( pclipper_int->lpLcl->lpGbl->dwProcessId == pid )
	{
	    /*
	     * release the references by this process
	     */
	    rcnt = pclipper_int->dwIntRefCnt;
	    while( rcnt >  0 )
	    {
		rc = InternalClipperRelease( pclipper_int );
		/* GEE: 0 is now an error code,
		 * errors weren't handled before anyway,
		 * does this matter.
		 */
		if( rc == 0 )
		{
		    break;
		}
		rcnt--;
	    }
	}
	pclipper_int = ppnext_int;
    }

    DPF( 4, "Done ProcessClipperCleanup" );

} /* ProcessClipperCleanup */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddcallbk.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcallbk.c
 *  Content:    Callback tables management code
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   23-jan-96  kylej   initial implementation
 *   03-feb-96  colinmc fixed DirectDraw QueryInterface bug
 *   24-feb-96  colinmc added a function to enable a client to determine if
 *                      the callback tables had already been initialized.
 *   13-mar-96  kylej   added DD_Surface_GetDDInterface
 *   21-mar-96  colinmc added special "unitialized" interfaces for the
 *                      driver and clipper objects
 *   13-jan-97 jvanaken basic support for IDirectDrawSurface3 interface
 *   29-jan-97  smac    Removed un-needed VPE functions
 *   03-mar-97  smac    Added kernel mode interface
 *   08-mar-97  colinmc New member to set surface memory pointer
 *   30-sep-97  jeffno  IDirectDraw4
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *
 ***************************************************************************/
#include "ddrawpr.h"

/*
 * Under Windows95 only one copy of a callback table exists and it is
 * shared among all processes using DirectDraw.  Under Windows NT, there
 * is a unique callback table for each process using DirectDraw.  This is
 * because the address of the member functions is guaranteed to be the
 * same from process to process under Windows 95 but may be different in
 * each process under Windows NT.  We initialize the callback tables in
 * a function rather than initializing them at compile time so that the
 * callback tables will not be shared under NT.
 */

DIRECTDRAWCALLBACKS     ddCallbacks;
DIRECTDRAWCALLBACKS     ddUninitCallbacks;
DIRECTDRAW2CALLBACKS        dd2UninitCallbacks;
DIRECTDRAW2CALLBACKS        dd2Callbacks;
DIRECTDRAW4CALLBACKS        dd4UninitCallbacks;
DIRECTDRAW4CALLBACKS        dd4Callbacks;
DIRECTDRAW7CALLBACKS        dd7UninitCallbacks;
DIRECTDRAW7CALLBACKS        dd7Callbacks;
DIRECTDRAWSURFACECALLBACKS  ddSurfaceCallbacks;
DIRECTDRAWSURFACE2CALLBACKS ddSurface2Callbacks;
DIRECTDRAWSURFACE3CALLBACKS ddSurface3Callbacks;
DIRECTDRAWSURFACE4CALLBACKS ddSurface4Callbacks;
DIRECTDRAWSURFACE7CALLBACKS ddSurface7Callbacks;
DIRECTDRAWPALETTECALLBACKS  ddPaletteCallbacks;
DIRECTDRAWCLIPPERCALLBACKS  ddClipperCallbacks;
DIRECTDRAWCLIPPERCALLBACKS  ddUninitClipperCallbacks;
DDVIDEOPORTCONTAINERCALLBACKS ddVideoPortContainerCallbacks;
DIRECTDRAWVIDEOPORTCALLBACKS ddVideoPortCallbacks;
DIRECTDRAWVIDEOPORTNOTIFYCALLBACKS ddVideoPortNotifyCallbacks;
DIRECTDRAWCOLORCONTROLCALLBACKS ddColorControlCallbacks;
DIRECTDRAWGAMMACONTROLCALLBACKS ddGammaControlCallbacks;
DIRECTDRAWKERNELCALLBACKS    ddKernelCallbacks;
DIRECTDRAWSURFACEKERNELCALLBACKS ddSurfaceKernelCallbacks;
DDVIDEOACCELERATORCONTAINERCALLBACKS ddMotionCompContainerCallbacks;
DIRECTDRAWVIDEOACCELERATORCALLBACKS ddMotionCompCallbacks;

#ifdef POSTPONED
DIRECTDRAWSURFACEPERSISTCALLBACKS   ddSurfacePersistCallbacks;
DIRECTDRAWSURFACEPERSISTSTREAMCALLBACKS  ddSurfacePersistStreamCallbacks;
DIRECTDRAWPALETTEPERSISTCALLBACKS   ddPalettePersistCallbacks;
DIRECTDRAWPALETTEPERSISTSTREAMCALLBACKS  ddPalettePersistStreamCallbacks;
DIRECTDRAWOPTSURFACECALLBACKS ddOptSurfaceCallbacks;
DDFACTORY2CALLBACKS         ddFactory2Callbacks;
DIRECTDRAWPALETTE2CALLBACKS ddPalette2Callbacks;
#endif

#ifdef POSTPONED
NONDELEGATINGUNKNOWNCALLBACKS  ddNonDelegatingUnknownCallbacks;
NONDELEGATINGUNKNOWNCALLBACKS  ddUninitNonDelegatingUnknownCallbacks;

/*
 * This is an interface which points to the nondelegating unknowns
 */
LPVOID NonDelegatingIUnknownInterface;
LPVOID UninitNonDelegatingIUnknownInterface;
#endif

#ifdef STREAMING
DIRECTDRAWSURFACESTREAMINGCALLBACKS ddSurfaceStreamingCallbacks;
#endif
#ifdef COMPOSITION
DIRECTDRAWSURFACECOMPOSITIONCALLBACKS ddSurfaceCompositionCallbacks;
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "Uninitialized"

/*
 * The horror, the horror...
 *
 * These are placeholder functions which sit in the interfaces of
 * uninitialized objects. They are there to prevent people calling
 * member functions before Initialize() is called.
 *
 * Now, you may well be wondering why there are five of them rather
 * than just one. Well, unfortunately, DDAPI expands out to __stdcall
 * which means that it is the callee's responsibility to clean up the
 * stack. Hence, if we have one, zero argument function say and it is
 * called through the vtable in place of a four argument function we
 * will leave four dwords on the stack when we exit. This is ugly
 * and potentially dangerous. Therefore, we have one stub function for
 * each number of arguments in the member interfaces (between 1 and 5).
 * This works because we are very regular in passing only DWORD/LPVOID
 * size parameters on the stack. Ugly but there it is.
 */

HRESULT DDAPI DD_Uninitialized1Arg( LPVOID arg1 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}

HRESULT DDAPI DD_Uninitialized2Arg( LPVOID arg1, LPVOID arg2 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}

HRESULT DDAPI DD_Uninitialized3Arg( LPVOID arg1, LPVOID arg2, LPVOID arg3 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}

HRESULT DDAPI DD_Uninitialized4Arg( LPVOID arg1, LPVOID arg2, LPVOID arg3, LPVOID arg4 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}

HRESULT DDAPI DD_Uninitialized5Arg( LPVOID arg1, LPVOID arg2, LPVOID arg3, LPVOID arg4, LPVOID arg5 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}

HRESULT DDAPI DD_Uninitialized6Arg( LPVOID arg1, LPVOID arg2, LPVOID arg3, LPVOID arg4, LPVOID arg5, LPVOID arg6 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CallbackTablesInitialized"

BOOL CallbackTablesInitialized( void )
{
    /*
     * Arbitrarily we check to see if ddCallbacks.QueryInterface
     * contains the correct value to determine whether the
     * callbacks are already initialized.
     */
    if( ddCallbacks.QueryInterface == DD_QueryInterface )
        return TRUE;
    else
        return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "InitCallbackTables"

void InitCallbackTables( void )
{
    /*
     * DirectDraw object methods Ver 1.0
     */
#ifdef POSTPONED
    ddCallbacks.QueryInterface = DD_DelegatingQueryInterface;
    ddCallbacks.AddRef = DD_DelegatingAddRef;
    ddCallbacks.Release = DD_DelegatingRelease;
#else
    ddCallbacks.QueryInterface = DD_QueryInterface;
    ddCallbacks.AddRef = DD_AddRef;
    ddCallbacks.Release = DD_Release;
#endif
    ddCallbacks.Compact = DD_Compact;
    ddCallbacks.CreateClipper = DD_CreateClipper;
    ddCallbacks.CreatePalette = DD_CreatePalette;
    ddCallbacks.CreateSurface = DD_CreateSurface;
    ddCallbacks.DuplicateSurface = DD_DuplicateSurface;
    ddCallbacks.EnumDisplayModes = DD_EnumDisplayModes;
    ddCallbacks.EnumSurfaces = DD_EnumSurfaces;
    ddCallbacks.FlipToGDISurface = DD_FlipToGDISurface;
    ddCallbacks.GetCaps = DD_GetCaps;
    ddCallbacks.GetDisplayMode = DD_GetDisplayMode;
    ddCallbacks.GetFourCCCodes = DD_GetFourCCCodes;
    ddCallbacks.GetGDISurface = DD_GetGDISurface;
    ddCallbacks.GetMonitorFrequency = DD_GetMonitorFrequency;
    ddCallbacks.GetScanLine = DD_GetScanLine;
    ddCallbacks.GetVerticalBlankStatus = DD_GetVerticalBlankStatus;
    ddCallbacks.Initialize = DD_Initialize;
    ddCallbacks.RestoreDisplayMode = DD_RestoreDisplayMode;
    ddCallbacks.SetCooperativeLevel = DD_SetCooperativeLevel;
    ddCallbacks.SetDisplayMode = DD_SetDisplayMode;
    ddCallbacks.WaitForVerticalBlank = DD_WaitForVerticalBlank;

#ifdef POSTPONED
    /*
     * Delegating Unknown Callbacks
     */
    ddNonDelegatingUnknownCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    ddNonDelegatingUnknownCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddNonDelegatingUnknownCallbacks.Release = (LPVOID)DD_Release;

    /*
     * Uninitialized Delegating Unknown Callbacks
     */
    ddUninitNonDelegatingUnknownCallbacks.QueryInterface = (LPVOID)DD_UnInitedQueryInterface;
    ddUninitNonDelegatingUnknownCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddUninitNonDelegatingUnknownCallbacks.Release = (LPVOID)DD_Release;

    /*
     * This is a special static interface whose vtable points to the nondelegating unknown
     */
    NonDelegatingIUnknownInterface = (LPVOID) &ddNonDelegatingUnknownCallbacks;
    UninitNonDelegatingIUnknownInterface = (LPVOID) &ddUninitNonDelegatingUnknownCallbacks;
#endif

    /*
     * DirectDraw "uninitialized" object methods Ver 1.0
     */
#ifdef POSTPONED
    ddUninitCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    ddUninitCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    ddUninitCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    ddUninitCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    ddUninitCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddUninitCallbacks.Release = (LPVOID)DD_Release;
#endif
    ddUninitCallbacks.Compact = (LPVOID)DD_Uninitialized1Arg;
    ddUninitCallbacks.CreateClipper = (LPVOID)DD_Uninitialized4Arg;
    ddUninitCallbacks.CreatePalette =   (LPVOID)DD_Uninitialized5Arg;
    ddUninitCallbacks.CreateSurface =   (LPVOID)DD_Uninitialized4Arg;
    ddUninitCallbacks.DuplicateSurface = (LPVOID)DD_Uninitialized3Arg;
    ddUninitCallbacks.EnumDisplayModes = (LPVOID)DD_Uninitialized5Arg;
    ddUninitCallbacks.EnumSurfaces = (LPVOID)DD_Uninitialized5Arg;
    ddUninitCallbacks.FlipToGDISurface = (LPVOID)DD_Uninitialized1Arg;
    ddUninitCallbacks.GetCaps = (LPVOID)DD_Uninitialized3Arg;
    ddUninitCallbacks.GetDisplayMode = (LPVOID)DD_Uninitialized2Arg;
    ddUninitCallbacks.GetFourCCCodes = (LPVOID)DD_Uninitialized3Arg;
    ddUninitCallbacks.GetGDISurface =   (LPVOID)DD_Uninitialized2Arg;
    ddUninitCallbacks.GetMonitorFrequency = (LPVOID)DD_Uninitialized2Arg;
    ddUninitCallbacks.GetScanLine = (LPVOID)DD_Uninitialized2Arg;
    ddUninitCallbacks.GetVerticalBlankStatus = (LPVOID)DD_Uninitialized2Arg;
    ddUninitCallbacks.Initialize = DD_Initialize;
    ddUninitCallbacks.RestoreDisplayMode = (LPVOID)DD_Uninitialized1Arg;
    ddUninitCallbacks.SetCooperativeLevel = (LPVOID)DD_Uninitialized3Arg;
    ddUninitCallbacks.SetDisplayMode = (LPVOID)DD_Uninitialized4Arg;
    ddUninitCallbacks.WaitForVerticalBlank = (LPVOID)DD_Uninitialized3Arg;

    /*
     * DirectDraw "uninitialized" object methods Ver 2.0
     */
#ifdef POSTPONED
    dd2UninitCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd2UninitCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd2UninitCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd2UninitCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd2UninitCallbacks.AddRef = (LPVOID)DD_AddRef;
    dd2UninitCallbacks.Release = (LPVOID)DD_Release;
#endif
    dd2UninitCallbacks.Compact = (LPVOID)DD_Uninitialized1Arg;
    dd2UninitCallbacks.CreateClipper = (LPVOID)DD_Uninitialized4Arg;
    dd2UninitCallbacks.CreatePalette =  (LPVOID)DD_Uninitialized5Arg;
    dd2UninitCallbacks.CreateSurface =  (LPVOID)DD_Uninitialized4Arg;
    dd2UninitCallbacks.DuplicateSurface = (LPVOID)DD_Uninitialized3Arg;
    dd2UninitCallbacks.EnumDisplayModes = (LPVOID)DD_Uninitialized5Arg;
    dd2UninitCallbacks.EnumSurfaces = (LPVOID)DD_Uninitialized5Arg;
    dd2UninitCallbacks.FlipToGDISurface = (LPVOID)DD_Uninitialized1Arg;
    dd2UninitCallbacks.GetCaps = (LPVOID)DD_Uninitialized3Arg;
    dd2UninitCallbacks.GetDisplayMode = (LPVOID)DD_Uninitialized2Arg;
    dd2UninitCallbacks.GetFourCCCodes = (LPVOID)DD_Uninitialized3Arg;
    dd2UninitCallbacks.GetGDISurface =  (LPVOID)DD_Uninitialized2Arg;
    dd2UninitCallbacks.GetMonitorFrequency = (LPVOID)DD_Uninitialized2Arg;
    dd2UninitCallbacks.GetScanLine = (LPVOID)DD_Uninitialized2Arg;
    dd2UninitCallbacks.GetVerticalBlankStatus = (LPVOID)DD_Uninitialized2Arg;
    dd2UninitCallbacks.Initialize = (LPVOID)DD_Initialize;
    dd2UninitCallbacks.RestoreDisplayMode = (LPVOID)DD_Uninitialized1Arg;
    dd2UninitCallbacks.SetCooperativeLevel = (LPVOID)DD_Uninitialized3Arg;
    dd2UninitCallbacks.SetDisplayMode = (LPVOID)DD_Uninitialized6Arg;
    dd2UninitCallbacks.WaitForVerticalBlank = (LPVOID)DD_Uninitialized3Arg;

    /*
     * DirectDraw "uninitialized" object methods Ver 4.0
     */
#ifdef POSTPONED
    dd4UninitCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd4UninitCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd4UninitCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd4UninitCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd4UninitCallbacks.AddRef = (LPVOID)DD_AddRef;
    dd4UninitCallbacks.Release = (LPVOID)DD_Release;
#endif
    dd4UninitCallbacks.Compact = (LPVOID)DD_Uninitialized1Arg;
    dd4UninitCallbacks.CreateClipper = (LPVOID)DD_Uninitialized4Arg;
    dd4UninitCallbacks.CreatePalette =  (LPVOID)DD_Uninitialized5Arg;
    dd4UninitCallbacks.CreateSurface =  (LPVOID)DD_Uninitialized4Arg;
    dd4UninitCallbacks.DuplicateSurface = (LPVOID)DD_Uninitialized3Arg;
    dd4UninitCallbacks.EnumDisplayModes = (LPVOID)DD_Uninitialized5Arg;
    dd4UninitCallbacks.EnumSurfaces = (LPVOID)DD_Uninitialized5Arg;
    dd4UninitCallbacks.FlipToGDISurface = (LPVOID)DD_Uninitialized1Arg;
    dd4UninitCallbacks.GetCaps = (LPVOID)DD_Uninitialized3Arg;
    dd4UninitCallbacks.GetDisplayMode = (LPVOID)DD_Uninitialized2Arg;
    dd4UninitCallbacks.GetFourCCCodes = (LPVOID)DD_Uninitialized3Arg;
    dd4UninitCallbacks.GetGDISurface =  (LPVOID)DD_Uninitialized2Arg;
    dd4UninitCallbacks.GetMonitorFrequency = (LPVOID)DD_Uninitialized2Arg;
    dd4UninitCallbacks.GetScanLine = (LPVOID)DD_Uninitialized2Arg;
    dd4UninitCallbacks.GetVerticalBlankStatus = (LPVOID)DD_Uninitialized2Arg;
    dd4UninitCallbacks.Initialize = (LPVOID)DD_Initialize;
    dd4UninitCallbacks.RestoreDisplayMode = (LPVOID)DD_Uninitialized1Arg;
    dd4UninitCallbacks.SetCooperativeLevel = (LPVOID)DD_Uninitialized3Arg;
    dd4UninitCallbacks.SetDisplayMode = (LPVOID)DD_Uninitialized6Arg;
    dd4UninitCallbacks.WaitForVerticalBlank = (LPVOID)DD_Uninitialized3Arg;
    dd4UninitCallbacks.GetSurfaceFromDC = (LPVOID) DD_Uninitialized3Arg;
    dd4UninitCallbacks.RestoreAllSurfaces = (LPVOID) DD_Uninitialized1Arg;
    dd4UninitCallbacks.TestCooperativeLevel = (LPVOID) DD_Uninitialized1Arg;
    dd4UninitCallbacks.GetDeviceIdentifier = (LPVOID) DD_Uninitialized2Arg;

    /*
     * DirectDraw "uninitialized" object methods Ver 5.0
     */
#ifdef POSTPONED
    dd7UninitCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd7UninitCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd7UninitCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd7UninitCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd7UninitCallbacks.AddRef = (LPVOID)DD_AddRef;
    dd7UninitCallbacks.Release = (LPVOID)DD_Release;
#endif
    dd7UninitCallbacks.Compact = (LPVOID)DD_Uninitialized1Arg;
    dd7UninitCallbacks.CreateClipper = (LPVOID)DD_Uninitialized4Arg;
    dd7UninitCallbacks.CreatePalette =  (LPVOID)DD_Uninitialized5Arg;
    dd7UninitCallbacks.CreateSurface =  (LPVOID)DD_Uninitialized4Arg;
    dd7UninitCallbacks.DuplicateSurface = (LPVOID)DD_Uninitialized3Arg;
    dd7UninitCallbacks.EnumDisplayModes = (LPVOID)DD_Uninitialized5Arg;
    dd7UninitCallbacks.EnumSurfaces = (LPVOID)DD_Uninitialized5Arg;
    dd7UninitCallbacks.FlipToGDISurface = (LPVOID)DD_Uninitialized1Arg;
    dd7UninitCallbacks.GetCaps = (LPVOID)DD_Uninitialized3Arg;
    dd7UninitCallbacks.GetDisplayMode = (LPVOID)DD_Uninitialized2Arg;
    dd7UninitCallbacks.GetFourCCCodes = (LPVOID)DD_Uninitialized3Arg;
    dd7UninitCallbacks.GetGDISurface =  (LPVOID)DD_Uninitialized2Arg;
    dd7UninitCallbacks.GetMonitorFrequency = (LPVOID)DD_Uninitialized2Arg;
    dd7UninitCallbacks.GetScanLine = (LPVOID)DD_Uninitialized2Arg;
    dd7UninitCallbacks.GetVerticalBlankStatus = (LPVOID)DD_Uninitialized2Arg;
    dd7UninitCallbacks.Initialize = (LPVOID)DD_Initialize;
    dd7UninitCallbacks.RestoreDisplayMode = (LPVOID)DD_Uninitialized1Arg;
    dd7UninitCallbacks.SetCooperativeLevel = (LPVOID)DD_Uninitialized3Arg;
    dd7UninitCallbacks.SetDisplayMode = (LPVOID)DD_Uninitialized6Arg;
    dd7UninitCallbacks.WaitForVerticalBlank = (LPVOID)DD_Uninitialized3Arg;
    dd7UninitCallbacks.GetSurfaceFromDC = (LPVOID) DD_Uninitialized3Arg;
    dd7UninitCallbacks.RestoreAllSurfaces = (LPVOID) DD_Uninitialized1Arg;
    dd7UninitCallbacks.TestCooperativeLevel = (LPVOID) DD_Uninitialized1Arg;
    dd7UninitCallbacks.GetDeviceIdentifier = (LPVOID) DD_Uninitialized2Arg;
#ifdef POSTPONED
    dd7UninitCallbacks.CreateSurfaceFromStream = (LPVOID) DD_Uninitialized5Arg;
    dd7UninitCallbacks.CreateSurfaceFromFile = (LPVOID) DD_Uninitialized5Arg;
#endif

    /*
     * DirectDraw object methods Ver 2.0
     */
#ifdef POSTPONED
    dd2Callbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd2Callbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd2Callbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd2Callbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd2Callbacks.AddRef = (LPVOID)DD_AddRef;
    dd2Callbacks.Release = (LPVOID)DD_Release;
#endif
    dd2Callbacks.Compact = (LPVOID)DD_Compact;
    dd2Callbacks.CreateClipper = (LPVOID)DD_CreateClipper;
    dd2Callbacks.CreatePalette = (LPVOID)DD_CreatePalette;
    dd2Callbacks.CreateSurface = (LPVOID)DD_CreateSurface;
    dd2Callbacks.DuplicateSurface = (LPVOID)DD_DuplicateSurface;
    dd2Callbacks.EnumDisplayModes = (LPVOID)DD_EnumDisplayModes;
    dd2Callbacks.EnumSurfaces = (LPVOID)DD_EnumSurfaces;
    dd2Callbacks.FlipToGDISurface = (LPVOID)DD_FlipToGDISurface;
    dd2Callbacks.GetAvailableVidMem = (LPVOID)DD_GetAvailableVidMem;
    dd2Callbacks.GetCaps = (LPVOID)DD_GetCaps;
    dd2Callbacks.GetDisplayMode = (LPVOID)DD_GetDisplayMode;
    dd2Callbacks.GetFourCCCodes = (LPVOID)DD_GetFourCCCodes;
    dd2Callbacks.GetGDISurface = (LPVOID)DD_GetGDISurface;
    dd2Callbacks.GetMonitorFrequency = (LPVOID)DD_GetMonitorFrequency;
    dd2Callbacks.GetScanLine = (LPVOID)DD_GetScanLine;
    dd2Callbacks.GetVerticalBlankStatus = (LPVOID)DD_GetVerticalBlankStatus;
    dd2Callbacks.Initialize = (LPVOID)DD_Initialize;
    dd2Callbacks.RestoreDisplayMode = (LPVOID)DD_RestoreDisplayMode;
    dd2Callbacks.SetCooperativeLevel = (LPVOID)DD_SetCooperativeLevel;
    dd2Callbacks.SetDisplayMode = (LPVOID)DD_SetDisplayMode2;
    dd2Callbacks.WaitForVerticalBlank = (LPVOID)DD_WaitForVerticalBlank;


    /*
     * DirectDraw object methods Ver 4.0
     */
#ifdef POSTPONED
    dd4Callbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd4Callbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd4Callbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd4Callbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd4Callbacks.AddRef = (LPVOID)DD_AddRef;
    dd4Callbacks.Release = (LPVOID)DD_Release;
#endif
    dd4Callbacks.Compact = (LPVOID)DD_Compact;
    dd4Callbacks.CreateClipper = (LPVOID)DD_CreateClipper;
    dd4Callbacks.CreatePalette = (LPVOID)DD_CreatePalette;
    dd4Callbacks.CreateSurface = (LPVOID)DD_CreateSurface4;
    dd4Callbacks.DuplicateSurface = (LPVOID)DD_DuplicateSurface;
    dd4Callbacks.EnumDisplayModes = (LPVOID)DD_EnumDisplayModes4;
    dd4Callbacks.EnumSurfaces = (LPVOID)DD_EnumSurfaces4;
    dd4Callbacks.FlipToGDISurface = (LPVOID)DD_FlipToGDISurface;
    dd4Callbacks.GetAvailableVidMem = (LPVOID)DD_GetAvailableVidMem4;
    dd4Callbacks.GetCaps = (LPVOID)DD_GetCaps;
    dd4Callbacks.GetDisplayMode = (LPVOID)DD_GetDisplayMode;
    dd4Callbacks.GetFourCCCodes = (LPVOID)DD_GetFourCCCodes;
    dd4Callbacks.GetGDISurface = (LPVOID)DD_GetGDISurface;
    dd4Callbacks.GetMonitorFrequency = (LPVOID)DD_GetMonitorFrequency;
    dd4Callbacks.GetScanLine = (LPVOID)DD_GetScanLine;
    dd4Callbacks.GetVerticalBlankStatus = (LPVOID)DD_GetVerticalBlankStatus;
    dd4Callbacks.Initialize = (LPVOID)DD_Initialize;
    dd4Callbacks.RestoreDisplayMode = (LPVOID)DD_RestoreDisplayMode;
    dd4Callbacks.SetCooperativeLevel = (LPVOID)DD_SetCooperativeLevel;
    dd4Callbacks.SetDisplayMode = (LPVOID)DD_SetDisplayMode2;
    dd4Callbacks.WaitForVerticalBlank = (LPVOID)DD_WaitForVerticalBlank;
    dd4Callbacks.GetSurfaceFromDC = (LPVOID) DD_GetSurfaceFromDC;
    dd4Callbacks.RestoreAllSurfaces = (LPVOID) DD_RestoreAllSurfaces;
    dd4Callbacks.TestCooperativeLevel = (LPVOID) DD_TestCooperativeLevel;
    dd4Callbacks.GetDeviceIdentifier = (LPVOID) DD_GetDeviceIdentifier;

    /*
     * DirectDraw object methods Ver 5.0
     */
#ifdef POSTPONED
    dd7Callbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd7Callbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd7Callbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd7Callbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd7Callbacks.AddRef = (LPVOID)DD_AddRef;
    dd7Callbacks.Release = (LPVOID)DD_Release;
#endif
    dd7Callbacks.Compact = (LPVOID)DD_Compact;
    dd7Callbacks.CreateClipper = (LPVOID)DD_CreateClipper;
    dd7Callbacks.CreatePalette = (LPVOID)DD_CreatePalette;
    dd7Callbacks.CreateSurface = (LPVOID)DD_CreateSurface4;
    dd7Callbacks.DuplicateSurface = (LPVOID)DD_DuplicateSurface;
    dd7Callbacks.EnumDisplayModes = (LPVOID)DD_EnumDisplayModes4;
    dd7Callbacks.EnumSurfaces = (LPVOID)DD_EnumSurfaces4;
    dd7Callbacks.FlipToGDISurface = (LPVOID)DD_FlipToGDISurface;
    dd7Callbacks.GetAvailableVidMem = (LPVOID)DD_GetAvailableVidMem4;
    dd7Callbacks.GetCaps = (LPVOID)DD_GetCaps;
    dd7Callbacks.GetDisplayMode = (LPVOID)DD_GetDisplayMode;
    dd7Callbacks.GetFourCCCodes = (LPVOID)DD_GetFourCCCodes;
    dd7Callbacks.GetGDISurface = (LPVOID)DD_GetGDISurface;
    dd7Callbacks.GetMonitorFrequency = (LPVOID)DD_GetMonitorFrequency;
    dd7Callbacks.GetScanLine = (LPVOID)DD_GetScanLine;
    dd7Callbacks.GetVerticalBlankStatus = (LPVOID)DD_GetVerticalBlankStatus;
    dd7Callbacks.Initialize = (LPVOID)DD_Initialize;
    dd7Callbacks.RestoreDisplayMode = (LPVOID)DD_RestoreDisplayMode;
    dd7Callbacks.SetCooperativeLevel = (LPVOID)DD_SetCooperativeLevel;
    dd7Callbacks.SetDisplayMode = (LPVOID)DD_SetDisplayMode2;
    dd7Callbacks.WaitForVerticalBlank = (LPVOID)DD_WaitForVerticalBlank;
    dd7Callbacks.GetSurfaceFromDC = (LPVOID) DD_GetSurfaceFromDC;
    dd7Callbacks.RestoreAllSurfaces = (LPVOID) DD_RestoreAllSurfaces;
    dd7Callbacks.TestCooperativeLevel = (LPVOID) DD_TestCooperativeLevel;
    dd7Callbacks.GetDeviceIdentifier = (LPVOID) DD_GetDeviceIdentifier7;
    dd7Callbacks.StartModeTest = (LPVOID) DD_StartModeTest;
    dd7Callbacks.EvaluateMode = (LPVOID) DD_EvaluateMode;
#ifdef POSTPONED
    dd7Callbacks.CreateSurfaceFromStream = (LPVOID) DD_CreateSurfaceFromStream;
    dd7Callbacks.CreateSurfaceFromFile = (LPVOID) DD_CreateSurfaceFromFile;
#endif

    /*
     * DirectDraw Surface object methods Ver 1.0
     */
    ddSurfaceCallbacks.QueryInterface = DD_Surface_QueryInterface;
    ddSurfaceCallbacks.AddRef = DD_Surface_AddRef;
    ddSurfaceCallbacks.Release = DD_Surface_Release;
    ddSurfaceCallbacks.AddAttachedSurface = DD_Surface_AddAttachedSurface;
    ddSurfaceCallbacks.AddOverlayDirtyRect = DD_Surface_AddOverlayDirtyRect;
    ddSurfaceCallbacks.Blt = DD_Surface_Blt;
    ddSurfaceCallbacks.BltBatch = DD_Surface_BltBatch;
    ddSurfaceCallbacks.BltFast = DD_Surface_BltFast;
    ddSurfaceCallbacks.DeleteAttachedSurface = DD_Surface_DeleteAttachedSurfaces;
    ddSurfaceCallbacks.EnumAttachedSurfaces = DD_Surface_EnumAttachedSurfaces;
    ddSurfaceCallbacks.EnumOverlayZOrders = DD_Surface_EnumOverlayZOrders;
    ddSurfaceCallbacks.Flip = DD_Surface_Flip;
    ddSurfaceCallbacks.GetAttachedSurface = DD_Surface_GetAttachedSurface;
    ddSurfaceCallbacks.GetBltStatus = DD_Surface_GetBltStatus;
    ddSurfaceCallbacks.GetCaps = DD_Surface_GetCaps;
    ddSurfaceCallbacks.GetClipper = DD_Surface_GetClipper;
    ddSurfaceCallbacks.GetColorKey = DD_Surface_GetColorKey;
    ddSurfaceCallbacks.GetDC = DD_Surface_GetDC;
    ddSurfaceCallbacks.GetFlipStatus = DD_Surface_GetFlipStatus;
    ddSurfaceCallbacks.GetOverlayPosition = DD_Surface_GetOverlayPosition;
    ddSurfaceCallbacks.GetPalette = DD_Surface_GetPalette;
    ddSurfaceCallbacks.GetPixelFormat = DD_Surface_GetPixelFormat;
    ddSurfaceCallbacks.GetSurfaceDesc = DD_Surface_GetSurfaceDesc;
    ddSurfaceCallbacks.Initialize = DD_Surface_Initialize;
    ddSurfaceCallbacks.IsLost = DD_Surface_IsLost;
    ddSurfaceCallbacks.Lock = DD_Surface_Lock;
    ddSurfaceCallbacks.ReleaseDC = DD_Surface_ReleaseDC;
    ddSurfaceCallbacks.Restore = DD_Surface_Restore;
    ddSurfaceCallbacks.SetClipper = DD_Surface_SetClipper;
    ddSurfaceCallbacks.SetColorKey = DD_Surface_SetColorKey;
    ddSurfaceCallbacks.SetOverlayPosition = DD_Surface_SetOverlayPosition;
    ddSurfaceCallbacks.SetPalette = DD_Surface_SetPalette;
    ddSurfaceCallbacks.Unlock = DD_Surface_Unlock;
    ddSurfaceCallbacks.UpdateOverlay = DD_Surface_UpdateOverlay;
    ddSurfaceCallbacks.UpdateOverlayDisplay = DD_Surface_UpdateOverlayDisplay;
    ddSurfaceCallbacks.UpdateOverlayZOrder = DD_Surface_UpdateOverlayZOrder;

    /*
     * DirectDraw Surface object methods Ver 2.0
     */
    ddSurface2Callbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddSurface2Callbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurface2Callbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurface2Callbacks.AddAttachedSurface = (LPVOID)DD_Surface_AddAttachedSurface;
    ddSurface2Callbacks.AddOverlayDirtyRect = (LPVOID)DD_Surface_AddOverlayDirtyRect;
    ddSurface2Callbacks.Blt = (LPVOID)DD_Surface_Blt;
    ddSurface2Callbacks.BltBatch = (LPVOID)DD_Surface_BltBatch;
    ddSurface2Callbacks.BltFast = (LPVOID)DD_Surface_BltFast;
    ddSurface2Callbacks.DeleteAttachedSurface = (LPVOID)DD_Surface_DeleteAttachedSurfaces;
    ddSurface2Callbacks.EnumAttachedSurfaces = (LPVOID)DD_Surface_EnumAttachedSurfaces;
    ddSurface2Callbacks.EnumOverlayZOrders = (LPVOID)DD_Surface_EnumOverlayZOrders;
    ddSurface2Callbacks.Flip = (LPVOID)DD_Surface_Flip;
    ddSurface2Callbacks.GetAttachedSurface = (LPVOID)DD_Surface_GetAttachedSurface;
    ddSurface2Callbacks.GetBltStatus = (LPVOID)DD_Surface_GetBltStatus;
    ddSurface2Callbacks.GetCaps = (LPVOID)DD_Surface_GetCaps;
    ddSurface2Callbacks.GetClipper = (LPVOID)DD_Surface_GetClipper;
    ddSurface2Callbacks.GetColorKey = (LPVOID)DD_Surface_GetColorKey;
    ddSurface2Callbacks.GetDC = (LPVOID)DD_Surface_GetDC;
    ddSurface2Callbacks.GetDDInterface = (LPVOID)DD_Surface_GetDDInterface;
    ddSurface2Callbacks.GetFlipStatus = (LPVOID)DD_Surface_GetFlipStatus;
    ddSurface2Callbacks.GetOverlayPosition = (LPVOID)DD_Surface_GetOverlayPosition;
    ddSurface2Callbacks.GetPalette = (LPVOID)DD_Surface_GetPalette;
    ddSurface2Callbacks.GetPixelFormat = (LPVOID)DD_Surface_GetPixelFormat;
    ddSurface2Callbacks.GetSurfaceDesc = (LPVOID)DD_Surface_GetSurfaceDesc;
    ddSurface2Callbacks.Initialize = (LPVOID)DD_Surface_Initialize;
    ddSurface2Callbacks.IsLost = (LPVOID)DD_Surface_IsLost;
    ddSurface2Callbacks.Lock = (LPVOID)DD_Surface_Lock;
    ddSurface2Callbacks.ReleaseDC = (LPVOID)DD_Surface_ReleaseDC;
    ddSurface2Callbacks.Restore = (LPVOID)DD_Surface_Restore;
    ddSurface2Callbacks.SetClipper = (LPVOID)DD_Surface_SetClipper;
    ddSurface2Callbacks.SetColorKey = (LPVOID)DD_Surface_SetColorKey;
    ddSurface2Callbacks.SetOverlayPosition = (LPVOID)DD_Surface_SetOverlayPosition;
    ddSurface2Callbacks.SetPalette = (LPVOID)DD_Surface_SetPalette;
    ddSurface2Callbacks.Unlock = (LPVOID)DD_Surface_Unlock;
    ddSurface2Callbacks.UpdateOverlay = (LPVOID)DD_Surface_UpdateOverlay;
    ddSurface2Callbacks.UpdateOverlayDisplay = (LPVOID)DD_Surface_UpdateOverlayDisplay;
    ddSurface2Callbacks.UpdateOverlayZOrder = (LPVOID)DD_Surface_UpdateOverlayZOrder;
    ddSurface2Callbacks.PageLock = (LPVOID)DD_Surface_PageLock;
    ddSurface2Callbacks.PageUnlock = (LPVOID)DD_Surface_PageUnlock;

    /*
     * DirectDraw Surface object methods Ver 3.0
     */
    ddSurface3Callbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddSurface3Callbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurface3Callbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurface3Callbacks.AddAttachedSurface = (LPVOID)DD_Surface_AddAttachedSurface;
    ddSurface3Callbacks.AddOverlayDirtyRect = (LPVOID)DD_Surface_AddOverlayDirtyRect;
    ddSurface3Callbacks.Blt = (LPVOID)DD_Surface_Blt;
    ddSurface3Callbacks.BltBatch = (LPVOID)DD_Surface_BltBatch;
    ddSurface3Callbacks.BltFast = (LPVOID)DD_Surface_BltFast;
    ddSurface3Callbacks.DeleteAttachedSurface = (LPVOID)DD_Surface_DeleteAttachedSurfaces;
    ddSurface3Callbacks.EnumAttachedSurfaces = (LPVOID)DD_Surface_EnumAttachedSurfaces;
    ddSurface3Callbacks.EnumOverlayZOrders = (LPVOID)DD_Surface_EnumOverlayZOrders;
    ddSurface3Callbacks.Flip = (LPVOID)DD_Surface_Flip;
    ddSurface3Callbacks.GetAttachedSurface = (LPVOID)DD_Surface_GetAttachedSurface;
    ddSurface3Callbacks.GetBltStatus = (LPVOID)DD_Surface_GetBltStatus;
    ddSurface3Callbacks.GetCaps = (LPVOID)DD_Surface_GetCaps;
    ddSurface3Callbacks.GetClipper = (LPVOID)DD_Surface_GetClipper;
    ddSurface3Callbacks.GetColorKey = (LPVOID)DD_Surface_GetColorKey;
    ddSurface3Callbacks.GetDC = (LPVOID)DD_Surface_GetDC;
    ddSurface3Callbacks.GetDDInterface = (LPVOID)DD_Surface_GetDDInterface;
    ddSurface3Callbacks.GetFlipStatus = (LPVOID)DD_Surface_GetFlipStatus;
    ddSurface3Callbacks.GetOverlayPosition = (LPVOID)DD_Surface_GetOverlayPosition;
    ddSurface3Callbacks.GetPalette = (LPVOID)DD_Surface_GetPalette;
    ddSurface3Callbacks.GetPixelFormat = (LPVOID)DD_Surface_GetPixelFormat;
    ddSurface3Callbacks.GetSurfaceDesc = (LPVOID)DD_Surface_GetSurfaceDesc;
    ddSurface3Callbacks.Initialize = (LPVOID)DD_Surface_Initialize;
    ddSurface3Callbacks.IsLost = (LPVOID)DD_Surface_IsLost;
    ddSurface3Callbacks.Lock = (LPVOID)DD_Surface_Lock;
    ddSurface3Callbacks.ReleaseDC = (LPVOID)DD_Surface_ReleaseDC;
    ddSurface3Callbacks.Restore = (LPVOID)DD_Surface_Restore;
    ddSurface3Callbacks.SetClipper = (LPVOID)DD_Surface_SetClipper;
    ddSurface3Callbacks.SetColorKey = (LPVOID)DD_Surface_SetColorKey;
    ddSurface3Callbacks.SetOverlayPosition = (LPVOID)DD_Surface_SetOverlayPosition;
    ddSurface3Callbacks.SetPalette = (LPVOID)DD_Surface_SetPalette;
    ddSurface3Callbacks.Unlock = (LPVOID)DD_Surface_Unlock;
    ddSurface3Callbacks.UpdateOverlay = (LPVOID)DD_Surface_UpdateOverlay;
    ddSurface3Callbacks.UpdateOverlayDisplay = (LPVOID)DD_Surface_UpdateOverlayDisplay;
    ddSurface3Callbacks.UpdateOverlayZOrder = (LPVOID)DD_Surface_UpdateOverlayZOrder;
    ddSurface3Callbacks.PageLock = (LPVOID)DD_Surface_PageLock;
    ddSurface3Callbacks.PageUnlock = (LPVOID)DD_Surface_PageUnlock;
    ddSurface3Callbacks.SetSurfaceDesc = (LPVOID)DD_Surface_SetSurfaceDesc;

    /*
     * DirectDraw Surface object methods Ver 4.0
     */
    ddSurface4Callbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddSurface4Callbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurface4Callbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurface4Callbacks.AddAttachedSurface = (LPVOID)DD_Surface_AddAttachedSurface;
    ddSurface4Callbacks.AddOverlayDirtyRect = (LPVOID)DD_Surface_AddOverlayDirtyRect;
    ddSurface4Callbacks.Blt = (LPVOID)DD_Surface_Blt;
    ddSurface4Callbacks.BltBatch = (LPVOID)DD_Surface_BltBatch;
    ddSurface4Callbacks.BltFast = (LPVOID)DD_Surface_BltFast;
    ddSurface4Callbacks.ChangeUniquenessValue = (LPVOID) DD_Surface_ChangeUniquenessValue;
    ddSurface4Callbacks.DeleteAttachedSurface = (LPVOID)DD_Surface_DeleteAttachedSurfaces;
    ddSurface4Callbacks.EnumAttachedSurfaces = (LPVOID)DD_Surface_EnumAttachedSurfaces;
    ddSurface4Callbacks.EnumOverlayZOrders = (LPVOID)DD_Surface_EnumOverlayZOrders;
    ddSurface4Callbacks.Flip = (LPVOID)DD_Surface_Flip;
    ddSurface4Callbacks.GetAttachedSurface = (LPVOID)DD_Surface_GetAttachedSurface4;
    ddSurface4Callbacks.GetBltStatus = (LPVOID)DD_Surface_GetBltStatus;
    ddSurface4Callbacks.GetCaps = (LPVOID)DD_Surface_GetCaps4;
    ddSurface4Callbacks.GetClipper = (LPVOID)DD_Surface_GetClipper;
    ddSurface4Callbacks.GetColorKey = (LPVOID)DD_Surface_GetColorKey;
    ddSurface4Callbacks.GetDC = (LPVOID)DD_Surface_GetDC;
    ddSurface4Callbacks.GetDDInterface = (LPVOID)DD_Surface_GetDDInterface;
    ddSurface4Callbacks.GetFlipStatus = (LPVOID)DD_Surface_GetFlipStatus;
    ddSurface4Callbacks.GetOverlayPosition = (LPVOID)DD_Surface_GetOverlayPosition;
    ddSurface4Callbacks.GetPalette = (LPVOID)DD_Surface_GetPalette;
    ddSurface4Callbacks.GetPixelFormat = (LPVOID)DD_Surface_GetPixelFormat;
    ddSurface4Callbacks.GetSurfaceDesc = (LPVOID)DD_Surface_GetSurfaceDesc4;
    ddSurface4Callbacks.GetUniquenessValue = (LPVOID)DD_Surface_GetUniquenessValue;
    ddSurface4Callbacks.Initialize = (LPVOID)DD_Surface_Initialize;
    ddSurface4Callbacks.IsLost = (LPVOID)DD_Surface_IsLost;
    ddSurface4Callbacks.Lock = (LPVOID)DD_Surface_Lock;
    ddSurface4Callbacks.ReleaseDC = (LPVOID)DD_Surface_ReleaseDC;
    ddSurface4Callbacks.Restore = (LPVOID)DD_Surface_Restore;
    ddSurface4Callbacks.SetClipper = (LPVOID)DD_Surface_SetClipper;
    ddSurface4Callbacks.SetColorKey = (LPVOID)DD_Surface_SetColorKey;
    ddSurface4Callbacks.SetOverlayPosition = (LPVOID)DD_Surface_SetOverlayPosition;
    ddSurface4Callbacks.SetPalette = (LPVOID)DD_Surface_SetPalette;
    ddSurface4Callbacks.Unlock = (LPVOID)DD_Surface_Unlock4;
    ddSurface4Callbacks.UpdateOverlay = (LPVOID)DD_Surface_UpdateOverlay;
    ddSurface4Callbacks.UpdateOverlayDisplay = (LPVOID)DD_Surface_UpdateOverlayDisplay;
    ddSurface4Callbacks.UpdateOverlayZOrder = (LPVOID)DD_Surface_UpdateOverlayZOrder;
    ddSurface4Callbacks.PageLock = (LPVOID)DD_Surface_PageLock;
    ddSurface4Callbacks.PageUnlock = (LPVOID)DD_Surface_PageUnlock;
    ddSurface4Callbacks.SetSurfaceDesc = (LPVOID)DD_Surface_SetSurfaceDesc4;
    ddSurface4Callbacks.SetPrivateData = (LPVOID)DD_Surface_SetPrivateData;
    ddSurface4Callbacks.GetPrivateData = (LPVOID)DD_Surface_GetPrivateData;
    ddSurface4Callbacks.FreePrivateData = (LPVOID)DD_Surface_FreePrivateData;

    /*
     * DirectDraw Surface object methods Ver 5.0
     */
    ddSurface7Callbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddSurface7Callbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurface7Callbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurface7Callbacks.AddAttachedSurface = (LPVOID)DD_Surface_AddAttachedSurface;
    ddSurface7Callbacks.AddOverlayDirtyRect = (LPVOID)DD_Surface_AddOverlayDirtyRect;
    ddSurface7Callbacks.Blt = (LPVOID)DD_Surface_Blt;
    ddSurface7Callbacks.BltBatch = (LPVOID)DD_Surface_BltBatch;
    ddSurface7Callbacks.BltFast = (LPVOID)DD_Surface_BltFast;
    ddSurface7Callbacks.ChangeUniquenessValue = (LPVOID) DD_Surface_ChangeUniquenessValue;
    ddSurface7Callbacks.DeleteAttachedSurface = (LPVOID)DD_Surface_DeleteAttachedSurfaces;
    ddSurface7Callbacks.EnumAttachedSurfaces = (LPVOID)DD_Surface_EnumAttachedSurfaces;
    ddSurface7Callbacks.EnumOverlayZOrders = (LPVOID)DD_Surface_EnumOverlayZOrders;
    ddSurface7Callbacks.Flip = (LPVOID)DD_Surface_Flip;
    ddSurface7Callbacks.GetAttachedSurface = (LPVOID)DD_Surface_GetAttachedSurface7;
    ddSurface7Callbacks.GetBltStatus = (LPVOID)DD_Surface_GetBltStatus;
    ddSurface7Callbacks.GetCaps = (LPVOID)DD_Surface_GetCaps4;
    ddSurface7Callbacks.GetClipper = (LPVOID)DD_Surface_GetClipper;
    ddSurface7Callbacks.GetColorKey = (LPVOID)DD_Surface_GetColorKey;
    ddSurface7Callbacks.GetDC = (LPVOID)DD_Surface_GetDC;
    ddSurface7Callbacks.GetDDInterface = (LPVOID)DD_Surface_GetDDInterface;
    ddSurface7Callbacks.GetFlipStatus = (LPVOID)DD_Surface_GetFlipStatus;
    ddSurface7Callbacks.GetOverlayPosition = (LPVOID)DD_Surface_GetOverlayPosition;
    ddSurface7Callbacks.GetPalette = (LPVOID)DD_Surface_GetPalette;
    ddSurface7Callbacks.GetPixelFormat = (LPVOID)DD_Surface_GetPixelFormat;
    ddSurface7Callbacks.GetSurfaceDesc = (LPVOID)DD_Surface_GetSurfaceDesc4;
    ddSurface7Callbacks.GetUniquenessValue = (LPVOID)DD_Surface_GetUniquenessValue;
    ddSurface7Callbacks.Initialize = (LPVOID)DD_Surface_Initialize;
    ddSurface7Callbacks.IsLost = (LPVOID)DD_Surface_IsLost;
    ddSurface7Callbacks.Lock = (LPVOID)DD_Surface_Lock;
    ddSurface7Callbacks.ReleaseDC = (LPVOID)DD_Surface_ReleaseDC;
    ddSurface7Callbacks.Restore = (LPVOID)DD_Surface_Restore;
    ddSurface7Callbacks.SetClipper = (LPVOID)DD_Surface_SetClipper;
    ddSurface7Callbacks.SetColorKey = (LPVOID)DD_Surface_SetColorKey;
    ddSurface7Callbacks.SetOverlayPosition = (LPVOID)DD_Surface_SetOverlayPosition;
    ddSurface7Callbacks.SetPalette = (LPVOID)DD_Surface_SetPalette;
    ddSurface7Callbacks.Unlock = (LPVOID)DD_Surface_Unlock4;
    ddSurface7Callbacks.UpdateOverlay = (LPVOID)DD_Surface_UpdateOverlay;
    ddSurface7Callbacks.UpdateOverlayDisplay = (LPVOID)DD_Surface_UpdateOverlayDisplay;
    ddSurface7Callbacks.UpdateOverlayZOrder = (LPVOID)DD_Surface_UpdateOverlayZOrder;
    ddSurface7Callbacks.PageLock = (LPVOID)DD_Surface_PageLock;
    ddSurface7Callbacks.PageUnlock = (LPVOID)DD_Surface_PageUnlock;
    ddSurface7Callbacks.SetSurfaceDesc = (LPVOID)DD_Surface_SetSurfaceDesc4;
    ddSurface7Callbacks.SetPrivateData = (LPVOID)DD_Surface_SetPrivateData;
    ddSurface7Callbacks.GetPrivateData = (LPVOID)DD_Surface_GetPrivateData;
    ddSurface7Callbacks.FreePrivateData = (LPVOID)DD_Surface_FreePrivateData;
#ifdef POSTPONED2
    ddSurface7Callbacks.AlphaBlt = (LPVOID)DD_Surface_AlphaBlt;
    ddSurface7Callbacks.SetSpriteDisplayList = (LPVOID)DD_Surface_SetSpriteDisplayList;
    ddSurface7Callbacks.Resize = (LPVOID)DD_Surface_Resize;
#endif //POSTPONED2
    ddSurface7Callbacks.SetPriority = (LPVOID)DD_Surface_SetPriority;
    ddSurface7Callbacks.GetPriority = (LPVOID)DD_Surface_GetPriority;
    ddSurface7Callbacks.SetLOD = (LPVOID)DD_Surface_SetLOD;
    ddSurface7Callbacks.GetLOD = (LPVOID)DD_Surface_GetLOD;

    /*
     * DirectDraw Palette object methods V1.0
     */
    ddPaletteCallbacks.QueryInterface = DD_Palette_QueryInterface;
    ddPaletteCallbacks.AddRef = DD_Palette_AddRef;
    ddPaletteCallbacks.Release = DD_Palette_Release;
    ddPaletteCallbacks.GetCaps = DD_Palette_GetCaps;
    ddPaletteCallbacks.GetEntries = DD_Palette_GetEntries;
    ddPaletteCallbacks.Initialize = DD_Palette_Initialize;
    ddPaletteCallbacks.SetEntries = DD_Palette_SetEntries;

    /*
     * DirectDraw Clipper object methods V1.0
     */
    ddClipperCallbacks.QueryInterface = DD_Clipper_QueryInterface;
    ddClipperCallbacks.AddRef = DD_Clipper_AddRef;
    ddClipperCallbacks.Release = DD_Clipper_Release;
    ddClipperCallbacks.GetClipList = DD_Clipper_GetClipList;
    ddClipperCallbacks.GetHWnd = DD_Clipper_GetHWnd;
    ddClipperCallbacks.Initialize = DD_Clipper_Initialize;
    ddClipperCallbacks.IsClipListChanged = DD_Clipper_IsClipListChanged;
    ddClipperCallbacks.SetClipList = DD_Clipper_SetClipList;
    ddClipperCallbacks.SetHWnd = DD_Clipper_SetHWnd;

    /*
     * DirectDraw "uninitialied" Clipper object methods V1.0
     */
#ifdef WINNT
    ddUninitClipperCallbacks.QueryInterface = (LPVOID)DD_UnInitedClipperQueryInterface;
#else
    ddUninitClipperCallbacks.QueryInterface = (LPVOID)DD_Uninitialized3Arg;
#endif
    ddUninitClipperCallbacks.AddRef = (LPVOID)DD_Clipper_AddRef;
    ddUninitClipperCallbacks.Release = (LPVOID)DD_Clipper_Release;
    ddUninitClipperCallbacks.GetClipList = (LPVOID)DD_Uninitialized4Arg;
    ddUninitClipperCallbacks.GetHWnd = (LPVOID)DD_Uninitialized2Arg;
    ddUninitClipperCallbacks.Initialize = DD_Clipper_Initialize;
    ddUninitClipperCallbacks.IsClipListChanged = (LPVOID)DD_Uninitialized2Arg;
    ddUninitClipperCallbacks.SetClipList = (LPVOID)DD_Uninitialized3Arg;
    ddUninitClipperCallbacks.SetHWnd = (LPVOID)DD_Uninitialized3Arg;

#ifdef STREAMING
    ddSurfaceStreamingCallbacks.QueryInterface = DD_Surface_QueryInterface;
    ddSurfaceStreamingCallbacks.AddRef = DD_Surface_AddRef;
    ddSurfaceStreamingCallbacks.Release = DD_Surface_Release;
    ddSurfaceStreamingCallbacks.Lock = DD_SurfaceStreaming_Lock;
    ddSurfaceStreamingCallbacks.SetNotificationCallback = DD_SurfaceStreaming_SetNotificationCallback;
    ddSurfaceStreamingCallbacks.Unlock = DD_SurfaceStreaming_Unlock;
#endif

#ifdef COMPOSITION
    ddSurfaceCompositionCallbacks.QueryInterface = DD_Surface_QueryInterface;
    ddSurfaceCompositionCallbacks.AddRef = DD_Surface_AddRef;
    ddSurfaceCompositionCallbacks.Release = DD_Surface_Release;
    ddSurfaceCompositionCallbacks.AddSurfaceDependency = DD_SurfaceComposition_AddSurfaceDependency;
    ddSurfaceCompositionCallbacks.Compose = DD_SurfaceComposition_Compose;
    ddSurfaceCompositionCallbacks.DeleteSurfaceDependency = DD_SurfaceComposition_DeleteSurfaceDependency;
    ddSurfaceCompositionCallbacks.DestLock = DD_SurfaceComposition_DestLock;
    ddSurfaceCompositionCallbacks.DestUnlock = DD_SurfaceComposition_DestUnlock;
    ddSurfaceCompositionCallbacks.EnumSurfaceDependencies = DD_SurfaceComposition_EnumSurfaceDependencies;
    ddSurfaceCompositionCallbacks.GetCompositionOrder = DD_SurfaceComposition_GetCompositionOrder;
    ddSurfaceCompositionCallbacks.SetCompositionOrder = DD_SurfaceComposition_SetCompositionOrder;
#endif

    /*
     * DirectDrawVideoPort object methods Ver 1.0
     */
#ifdef POSTPONED
    ddVideoPortContainerCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    ddVideoPortContainerCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    ddVideoPortContainerCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    ddVideoPortContainerCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    ddVideoPortContainerCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddVideoPortContainerCallbacks.Release = (LPVOID)DD_Release;
#endif
    ddVideoPortContainerCallbacks.CreateVideoPort = DDVPC_CreateVideoPort;
    ddVideoPortContainerCallbacks.EnumVideoPorts = DDVPC_EnumVideoPorts;
    ddVideoPortContainerCallbacks.GetVideoPortConnectInfo = DDVPC_GetVideoPortConnectInfo;
    ddVideoPortContainerCallbacks.QueryVideoPortStatus = DDVPC_QueryVideoPortStatus;

    /*
     * DirectDrawVideoPortStream object methods Ver 1.0
     */
    ddVideoPortCallbacks.QueryInterface = (LPVOID)DD_VP_QueryInterface;
    ddVideoPortCallbacks.AddRef = DD_VP_AddRef;
    ddVideoPortCallbacks.Release = DD_VP_Release;
    ddVideoPortCallbacks.SetTargetSurface = DD_VP_SetTargetSurface;
    ddVideoPortCallbacks.Flip = DD_VP_Flip;
    ddVideoPortCallbacks.GetBandwidthInfo = DD_VP_GetBandwidth;
    ddVideoPortCallbacks.GetColorControls = DD_VP_GetColorControls;
    ddVideoPortCallbacks.GetInputFormats = DD_VP_GetInputFormats;
    ddVideoPortCallbacks.GetOutputFormats = DD_VP_GetOutputFormats;
    ddVideoPortCallbacks.GetFieldPolarity = DD_VP_GetField;
    ddVideoPortCallbacks.GetVideoLine = DD_VP_GetLine;
    ddVideoPortCallbacks.GetVideoSignalStatus = DD_VP_GetSignalStatus;
    ddVideoPortCallbacks.StartVideo = DD_VP_StartVideo;
    ddVideoPortCallbacks.StopVideo = DD_VP_StopVideo;
    ddVideoPortCallbacks.UpdateVideo = DD_VP_UpdateVideo;
    ddVideoPortCallbacks.WaitForSync = DD_VP_WaitForSync;
    ddVideoPortCallbacks.SetColorControls = DD_VP_SetColorControls;

#ifdef WINNT
    /*
     * DirectDrawVideoPortNotify object methods Ver 1.0
     */
    ddVideoPortNotifyCallbacks.QueryInterface = (LPVOID)DD_VP_QueryInterface;
    ddVideoPortNotifyCallbacks.AddRef = (LPVOID)DD_VP_AddRef;
    ddVideoPortNotifyCallbacks.Release = (LPVOID)DD_VP_Release;
    ddVideoPortNotifyCallbacks.AcquireNotification = DD_VP_Notify_AcquireNotification;
    ddVideoPortNotifyCallbacks.ReleaseNotification = DD_VP_Notify_ReleaseNotification;
#endif

    /*
     * DirectDrawColorControl object methods Ver 1.0
     */
    ddColorControlCallbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddColorControlCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddColorControlCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddColorControlCallbacks.GetColorControls = DD_Color_GetColorControls;
    ddColorControlCallbacks.SetColorControls = DD_Color_SetColorControls;

    /*
     * DirectDrawKernel interface
     */
#ifdef POSTPONED
    ddKernelCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    ddKernelCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    ddKernelCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    ddKernelCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    ddKernelCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddKernelCallbacks.Release = (LPVOID)DD_Release;
#endif
    ddKernelCallbacks.GetCaps = DD_Kernel_GetCaps;
    ddKernelCallbacks.GetKernelHandle = DD_Kernel_GetKernelHandle;
    ddKernelCallbacks.ReleaseKernelHandle = DD_Kernel_ReleaseKernelHandle;

    /*
     * DirectDrawSurfaceKernel interface
     */
    ddSurfaceKernelCallbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddSurfaceKernelCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurfaceKernelCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurfaceKernelCallbacks.GetKernelHandle = DD_SurfaceKernel_GetKernelHandle;
    ddSurfaceKernelCallbacks.ReleaseKernelHandle = DD_SurfaceKernel_ReleaseKernelHandle;

#ifdef POSTPONED
    /*
     * DirectDraw Palette object methods V2.0
     */
    ddPalette2Callbacks.QueryInterface = (LPVOID) DD_Palette_QueryInterface;
    ddPalette2Callbacks.AddRef = (LPVOID) DD_Palette_AddRef;
    ddPalette2Callbacks.Release = (LPVOID) DD_Palette_Release;
    ddPalette2Callbacks.ChangeUniquenessValue = (LPVOID) DD_Palette_ChangeUniquenessValue;
    ddPalette2Callbacks.GetCaps = (LPVOID) DD_Palette_GetCaps;
    ddPalette2Callbacks.GetEntries = (LPVOID) DD_Palette_GetEntries;
    ddPalette2Callbacks.Initialize = (LPVOID) DD_Palette_Initialize;
    ddPalette2Callbacks.SetEntries = (LPVOID) DD_Palette_SetEntries;
    ddPalette2Callbacks.SetPrivateData = (LPVOID) DD_Palette_SetPrivateData;
    ddPalette2Callbacks.GetPrivateData = (LPVOID) DD_Palette_GetPrivateData;
    ddPalette2Callbacks.FreePrivateData = (LPVOID) DD_Palette_FreePrivateData;
    ddPalette2Callbacks.GetUniquenessValue = (LPVOID) DD_Palette_GetUniquenessValue;
    ddPalette2Callbacks.IsEqual = (LPVOID) DD_Palette_IsEqual;

    /*
     * DirectDrawFactory2 callbacks
     */
    ddFactory2Callbacks.QueryInterface = DDFac2_QueryInterface;
    ddFactory2Callbacks.AddRef = DDFac2_AddRef;
    ddFactory2Callbacks.Release = DDFac2_Release;
    ddFactory2Callbacks.CreateDirectDraw = (LPVOID)DDFac2_CreateDirectDraw;
    ddFactory2Callbacks.DirectDrawEnumerate = (LPVOID)DDFac2_DirectDrawEnumerate;

    /*
     * Surface IPersist interface
     */
    ddSurfacePersistCallbacks.QueryInterface = (LPVOID) DD_Surface_QueryInterface;
    ddSurfacePersistCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurfacePersistCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurfacePersistCallbacks.GetClassID = (LPVOID) DD_Surface_Persist_GetClassID;
    /*
     * Surface IPersistStream interface
     */
    ddSurfacePersistStreamCallbacks.QueryInterface = (LPVOID) DD_Surface_QueryInterface;
    ddSurfacePersistStreamCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurfacePersistStreamCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurfacePersistStreamCallbacks.GetClassID = (LPVOID) DD_Surface_Persist_GetClassID;
    ddSurfacePersistStreamCallbacks.IsDirty =  (LPVOID) DD_Surface_PStream_IsDirty;
    ddSurfacePersistStreamCallbacks.Load = (LPVOID) DD_Surface_PStream_Load;
    ddSurfacePersistStreamCallbacks.Save = (LPVOID) DD_Surface_PStream_Save;
    ddSurfacePersistStreamCallbacks.GetSizeMax = (LPVOID) DD_PStream_GetSizeMax;

    /*
     * Palette IPersist interface
     */
    ddPalettePersistCallbacks.QueryInterface = (LPVOID) DD_Palette_QueryInterface;
    ddPalettePersistCallbacks.AddRef = (LPVOID)DD_Palette_AddRef;
    ddPalettePersistCallbacks.Release = (LPVOID)DD_Palette_Release;
    ddPalettePersistCallbacks.GetClassID = (LPVOID) DD_Palette_Persist_GetClassID;
    /*
     * Palette IPersistStream interface
     */
    ddPalettePersistStreamCallbacks.QueryInterface = (LPVOID) DD_Palette_QueryInterface;
    ddPalettePersistStreamCallbacks.AddRef = (LPVOID)DD_Palette_AddRef;
    ddPalettePersistStreamCallbacks.Release = (LPVOID)DD_Palette_Release;
    ddPalettePersistStreamCallbacks.GetClassID = (LPVOID) DD_Palette_Persist_GetClassID;
    ddPalettePersistStreamCallbacks.IsDirty =  (LPVOID) DD_Palette_PStream_IsDirty;
    ddPalettePersistStreamCallbacks.Load = (LPVOID) DD_Palette_PStream_Load;
    ddPalettePersistStreamCallbacks.Save = (LPVOID) DD_Palette_PStream_Save;
    ddPalettePersistStreamCallbacks.GetSizeMax = (LPVOID) DD_PStream_GetSizeMax;

    /*
     * DirectDraw OptSurface object methods
     */
    ddOptSurfaceCallbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddOptSurfaceCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddOptSurfaceCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddOptSurfaceCallbacks.GetOptSurfaceDesc = (LPVOID)DD_OptSurface_GetOptSurfaceDesc;
    ddOptSurfaceCallbacks.LoadUnoptimizedSurf = (LPVOID)DD_OptSurface_LoadUnoptimizedSurf;
    ddOptSurfaceCallbacks.CopyOptimizedSurf = (LPVOID)DD_OptSurface_CopyOptimizedSurf;
    ddOptSurfaceCallbacks.Unoptimize = (LPVOID)DD_OptSurface_Unoptimize;
#endif //POSTPONED
    /*
     * DDMotionCompContainer object methods Ver 1.0
     */
    ddMotionCompContainerCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    ddMotionCompContainerCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddMotionCompContainerCallbacks.Release = (LPVOID)DD_Release;
    ddMotionCompContainerCallbacks.CreateVideoAccelerator = DDMCC_CreateMotionComp;
    ddMotionCompContainerCallbacks.GetCompBufferInfo = DDMCC_GetCompBuffInfo;
    ddMotionCompContainerCallbacks.GetInternalMemInfo = DDMCC_GetInternalMoCompInfo;
    ddMotionCompContainerCallbacks.GetUncompFormatsSupported = DDMCC_GetUncompressedFormats;
    ddMotionCompContainerCallbacks.GetVideoAcceleratorGUIDs = DDMCC_GetMotionCompGUIDs;

    /*
     * DirectDrawMotionComp object methods Ver 1.0
     */
    ddMotionCompCallbacks.QueryInterface = (LPVOID)DD_MC_QueryInterface;
    ddMotionCompCallbacks.AddRef = (LPVOID)DD_MC_AddRef;
    ddMotionCompCallbacks.Release = (LPVOID)DD_MC_Release;
    ddMotionCompCallbacks.BeginFrame = DD_MC_BeginFrame;
    ddMotionCompCallbacks.EndFrame = DD_MC_EndFrame;
    ddMotionCompCallbacks.QueryRenderStatus = DD_MC_QueryRenderStatus;
    ddMotionCompCallbacks.Execute = DD_MC_RenderMacroBlocks;

    /*
     * DirectDrawColorControl object methods Ver 1.0
     */
    ddGammaControlCallbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddGammaControlCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddGammaControlCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddGammaControlCallbacks.GetGammaRamp = DD_Gamma_GetGammaRamp;
    ddGammaControlCallbacks.SetGammaRamp = DD_Gamma_SetGammaRamp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddalias.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddalias.c
 *  Content:	DirectDraw support for allocating and mapping linear virtual
 *              memory aliased for video memory.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   05-jul-96	colinmc	initial implementation
 *   10-oct-96  colinmc Refinements of the Win16 locking stuff
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   25-jan-97  colinmc AGP work
 *   01-jun-97  colinmc Bug xxxx: Defensive video memory checking to catch
 *                      based video memory pointers passed by drivers
 *
 ***************************************************************************/

#include "ddrawpr.h"

#ifdef USE_ALIAS

#ifdef WINNT
    #include "ddrawgdi.h"
#endif

#pragma optimize("gle", off)
#define Not_VxD
#include <vmm.h>
#include <configmg.h>
#pragma optimize("", on)

/*
 * We define the page lock IOCTLs here so that we don't have to include ddvxd.h.
 * These must match the corresponding entries in ddvxd.h
 */
#define DDVXD_IOCTL_MEMRESERVEALIAS         23
#define DDVXD_IOCTL_MEMCOMMITALIAS          24
#define DDVXD_IOCTL_MEMREDIRECTALIAS        25
#define DDVXD_IOCTL_MEMDECOMMITALIAS        26
#define DDVXD_IOCTL_MEMFREEALIAS            27
#define DDVXD_IOCTL_MEMCOMMITPHYSALIAS      55
#define DDVXD_IOCTL_MEMREDIRECTPHYSALIAS    56
#define DDVXD_IOCTL_LINTOPHYS               69
#define GET_PIXELFORMAT( pdrv, psurf_lcl )                     \
    ( ( ( psurf_lcl )->dwFlags & DDRAWISURF_HASPIXELFORMAT ) ? \
	&( ( psurf_lcl )->lpGbl->ddpfSurface )               : \
	&( ( pdrv )->vmiData.ddpfDisplay ) )

#define WIDTH_TO_BYTES( bpp, w ) ( ( ( ( w ) * ( bpp ) ) + 7 ) >> 3 )

BOOL UnmapHeapAliases( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );

/*
 * Are the heaps mapped at all?
 */
#define HEAPALIASINFO_MAPPED ( HEAPALIASINFO_MAPPEDREAL | HEAPALIASINFO_MAPPEDDUMMY )

#define MAP_HEAP_ALIAS_TO_VID_MEM( hvxd, lpHeapAlias )      \
    vxdMapVMAliasToVidMem( (hvxd),                          \
	                   (lpHeapAlias)->lpAlias,          \
			   (lpHeapAlias)->dwAliasSize,      \
		           (LPVOID)(lpHeapAlias)->fpVidMem )

#define MAP_HEAP_ALIAS_TO_DUMMY_MEM( hvxd, lpHeapAlias )    \
    vxdMapVMAliasToDummyMem( (hvxd),                        \
	                     (lpHeapAlias)->lpAlias,        \
			     (lpHeapAlias)->dwAliasSize )

#define UNMAP_HEAP_ALIAS( hvxd, lpHeapAlias )               \
    vxdUnmapVMAlias( (hvxd),                                \
	             (lpHeapAlias)->lpAlias,                \
	             (lpHeapAlias)->dwAliasSize )

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdAllocVMAlias"

/*
 * vxdAllocVMAlias
 *
 * Allocate a virtual memory alias for a portion of video memory
 * starting with the given start address and size.
 */
static BOOL vxdAllocVMAlias( HANDLE hvxd, LPVOID lpVidMem, DWORD dwSize, LPVOID *lplpAlias )
{
    LPVOID lpAlias;
    DWORD  cbReturned;
    BOOL   rc;
    struct RAInput
    {
	LPBYTE lpVidMem;
	DWORD  dwSize;
    } raInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpVidMem );
    DDASSERT( 0UL                  != dwSize );
    DDASSERT( NULL                 != lplpAlias );

    raInput.lpVidMem = (LPBYTE) lpVidMem;
    raInput.dwSize   = dwSize;

    DPF( 5, "Trying to allocate alias starting at 0x%08x of size 0x%04x", lpVidMem, dwSize );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_MEMRESERVEALIAS,
			  &raInput,
			  sizeof( raInput ),
			  &lpAlias,
			  sizeof( lpAlias ),
			  &cbReturned,
			  NULL);

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(lpAlias) );

	*lplpAlias = lpAlias;
    }
    else
    {
	DPF( 0, "Could not allocate an alias for video memory starting at 0x%08x", lpVidMem );

	*lplpAlias = NULL;
    }

    return rc;
} /* vxdAllocVMAlias */

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdFreeVMAlias"

/*
 * vxdFreeVMAlias
 *
 * Free the virtual memory alias with the given start address and size.
 */
static BOOL vxdFreeVMAlias( HANDLE hvxd, LPVOID lpAlias, DWORD dwSize )
{
    BOOL  rc;
    BOOL  fSuccess;
    DWORD cbReturned;
    struct FAInput
    {
	LPBYTE pAlias;
	DWORD  cbBuffer;
    } faInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpAlias);
    DDASSERT( 0UL                  != dwSize );

    faInput.pAlias   = (LPBYTE) lpAlias;
    faInput.cbBuffer = dwSize;

    DPF( 5, "Trying to free an alias starting at 0x%08x of size 0x%04x", lpAlias, dwSize );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_MEMFREEALIAS,
			  &faInput,
			  sizeof( faInput ),
			  &fSuccess,
			  sizeof( fSuccess ),
			  &cbReturned,
			  NULL);

    if( !rc || !fSuccess )
    {
	DPF( 0, "Could not free an alias starting at 0x%08x (rc = %d fSuccess = %d)", lpAlias, rc, fSuccess );
	return FALSE;
    }

    return TRUE;
} /* vxdFreeVMAlias */

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdMapVMAliasToVidMem"

/*
 * vxdMapVMAliasToVidMem
 *
 * Map the the virtual memory alias with the given start address and size
 * to the porition of video memory with the given start address.
 */
static BOOL vxdMapVMAliasToVidMem( HANDLE hvxd, LPVOID lpAlias, DWORD dwSize, LPVOID lpVidMem )
{
    BOOL  rc;
    BOOL  fSuccess;
    DWORD cbReturned;
    struct CAInput
    {
	LPBYTE pAlias;
	LPBYTE pVidMem;
	DWORD  cbBuffer;
    } caInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpAlias );
    DDASSERT( 0UL                  != dwSize );
    DDASSERT( NULL                 != lpVidMem );

    caInput.pAlias   = (LPBYTE) lpAlias;
    caInput.pVidMem  = (LPBYTE) lpVidMem;
    caInput.cbBuffer = dwSize;

    DPF( 5, "Trying to map an alias starting at 0x%08x of size 0x%04x to video memory starting at 0x%08x", lpAlias, dwSize, lpVidMem );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_MEMCOMMITPHYSALIAS,
                          &caInput,
                          sizeof( caInput ),
                          &fSuccess,
                          sizeof( fSuccess ),
                          &cbReturned,
                          NULL);

    if( !rc || !fSuccess )
    {
        DPF( 0, "Could not map an alias starting at 0x%08x (rc = %d fSuccess = %d)", lpAlias, rc, fSuccess );
	return FALSE;
    }

    return TRUE;
} /* vxdMapVMAliasToVidMem */

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdMapVMAliasToDummyMem"

/*
 * vxdMapVMAliasToDummyMem
 *
 * Map the the virtual memory alias with the given start address and size
 * to a read / write dummy page.
 */
static BOOL vxdMapVMAliasToDummyMem( HANDLE hvxd, LPVOID lpAlias, DWORD dwSize )
{
    BOOL  rc;
    BOOL  fSuccess;
    DWORD cbReturned;
    struct RAInput
    {
	LPBYTE pAlias;
	DWORD  cbBuffer;
    } raInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpAlias);
    DDASSERT( 0UL                  != dwSize );

    raInput.pAlias   = (LPBYTE) lpAlias;
    raInput.cbBuffer = dwSize;

    DPF( 5, "Trying to map an alias starting at 0x%08x of size 0x%04x to dummy memory" , lpAlias, dwSize );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_MEMREDIRECTPHYSALIAS,
			  &raInput,
	                  sizeof( raInput ),
	                  &fSuccess,
	                  sizeof( fSuccess ),
	                  &cbReturned,
	                  NULL);

    if( !rc || !fSuccess )
    {
	DPF( 0, "Could not map an alias starting at 0x%08x to dummy memory (rc = %d fSuccess = %d)", lpAlias, rc, fSuccess );
	return FALSE;
    }

    return TRUE;
} /* vxdMapVMAliasToDummyMem */

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdUnmapVMAlias"

/*
 * vxdUnmapVMAlias
 *
 * Unmap the the virtual memory alias with the given start address and size.
 */
static BOOL vxdUnmapVMAlias( HANDLE hvxd, LPVOID lpAlias, DWORD dwSize )
{
    BOOL  rc;
    BOOL  fSuccess;
    DWORD cbReturned;
    struct DAInput
    {
	LPBYTE pAlias;
	DWORD  cbBuffer;
    } daInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpAlias);
    DDASSERT( 0UL                  != dwSize );

    daInput.pAlias   = (LPBYTE) lpAlias;
    daInput.cbBuffer = dwSize;

    DPF( 5, "Trying to unmap an alias starting at 0x%08x of size 0x%04x", lpAlias, dwSize );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_MEMDECOMMITALIAS,
			  &daInput,
			  sizeof( daInput ),
			  &fSuccess,
			  sizeof( fSuccess ),
			  &cbReturned,
			  NULL );

    if( !rc || !fSuccess )
    {
	DPF( 0, "Could not unmap an alias starting at 0x%08x (rc = %d fSuccess = %d)", lpAlias, rc, fSuccess );
	return FALSE;
    }

    return TRUE;
} /* vxdUnmapVMAlias */

static BOOL vxdLinToPhys( HANDLE hvxd, LPVOID lpLin, DWORD dwSize, LPVOID* lplpPhys )
{
    BOOL  rc;
    LPBYTE lpPhys;
    DWORD cbReturned;
    struct DAInput
    {
	LPBYTE pLin;
	DWORD  cbBuffer;
    } daInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpLin);
// There really is a bug here: 27001. But since it's MOSTLY inoccuous, I'll turn the spew off.
//    DDASSERT( 0UL                  != dwSize );

    daInput.pLin   = (LPBYTE) lpLin;
    daInput.cbBuffer = dwSize;

    DPF( 5, "Trying to map an linear address at 0x%08x of size 0x%04x to physical address", lpLin, dwSize );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_LINTOPHYS,
			  &daInput,
			  sizeof( daInput ),
			  &lpPhys,
			  sizeof( lpPhys ),
			  &cbReturned,
			  NULL );

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(lpPhys) );

	*lplpPhys = lpPhys;
    }
    else
    {
	DPF( 0, "Could not map linear address at 0x%08x to physical address", lpLin );

	*lplpPhys = NULL;
    }

    return rc;
} /* vxdUnmapVMAlias */

#undef DPF_MODNAME
#define DPF_MODNAME	"AllocHeapAlias"

/*
 * AllocHeapAlias
 *
 * Allocate a virtual memory alias for the given heap
 */
static BOOL AllocHeapAlias( HANDLE hvxd, FLATPTR fpStart, DWORD dwSize, LPHEAPALIAS lpHeapAlias )
{
    LPVOID lpAlias;
    BOOL   fSuccess;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( 0UL                  != fpStart ); /* This is a physical address pointer */
    DDASSERT( 0UL                  != dwSize );
    DDASSERT( NULL                 != lpHeapAlias );

    /*
     * Attempt to allocate an alias for this heap.
     */
    fSuccess = vxdAllocVMAlias( hvxd, (LPVOID) fpStart, dwSize, &lpAlias );
    if( fSuccess )
    {
	lpHeapAlias->fpVidMem    = fpStart;
	lpHeapAlias->lpAlias     = lpAlias;
	lpHeapAlias->dwAliasSize = dwSize;
    }
    else
    {
	lpHeapAlias->fpVidMem    = 0UL;
	lpHeapAlias->lpAlias     = NULL;
	lpHeapAlias->dwAliasSize = 0UL;
    }

    return fSuccess;
} /* AllocHeapAlias */

#undef DPF_MODNAME
#define DPF_MODNAME	"FreeHeapAlias"

/*
 * FreeHeapAlias
 *
 * Free the given virtual memory heap alias
 */
static BOOL FreeHeapAlias( HANDLE hvxd, LPHEAPALIAS lpHeapAlias )
{
    BOOL fSuccess;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpHeapAlias );

    if( NULL != lpHeapAlias->lpAlias )
    {
	fSuccess = vxdFreeVMAlias( hvxd, lpHeapAlias->lpAlias, lpHeapAlias->dwAliasSize );
	lpHeapAlias->fpVidMem    = 0UL;
	lpHeapAlias->lpAlias     = NULL;
	lpHeapAlias->dwAliasSize = 0UL;
    }

    return fSuccess;
} /* FreeHeapAliases */

#undef DPF_MODNAME
#define DPF_MODNAME	"CreateHeapAliases"

/*
 * CreateHeapAliases
 *
 * Create a new set of virtual memory heap aliases for the given global
 * object
 */
HRESULT CreateHeapAliases( HANDLE hvxd, LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPHEAPALIASINFO         phaiInfo;
    DWORD                   dwNumHeaps;
    DWORD                   dwSize;
    DWORD                   dwHeapNo;
    int                     i;
    int                     n;
    HRESULT                 hres;
    CMCONFIG	            config;
    LPVIDMEM                pvm;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != pdrv );
    DDASSERT( NULL                 == pdrv->phaiHeapAliases );

    DDASSERT( !( pdrv->dwFlags & DDRAWI_NOHARDWARE ) );
    DDASSERT( !( pdrv->dwFlags & DDRAWI_MODEX ) );
    DDASSERT( 0UL != pdrv->vmiData.fpPrimary );

    if (DD16_GetDeviceConfig(pdrv->cDriverName, &config, sizeof(config)) == 0)
    {
        DPF_ERR("Could not get display devices's address space ranges");
        return DDERR_GENERIC;
    }
    // First we count the cards local vid mem windows in the config space
    dwNumHeaps = config.wNumMemWindows;
    DPF(5, "Config Space windows = %d", dwNumHeaps);
    // Then we cycle through the AGP heaps that we need to alias
    for( i = 0; i < (int)pdrv->vmiData.dwNumHeaps; i++ )
    {
	if( ( pdrv->vmiData.pvmList[i].dwFlags & VIDMEM_ISNONLOCAL ) )
	{
            // Found AGP heap
            ++dwNumHeaps;
        }
    }
    DPF(5, "dwNumHeaps = %d", dwNumHeaps);

    /*
     * Allocate the heap alias info.
     */
    phaiInfo = MemAlloc( sizeof( HEAPALIASINFO ) );
    if( NULL == phaiInfo )
    {
	DPF_ERR( "Insufficient memory to map the heap alias info" );
	return DDERR_OUTOFMEMORY;
    }

    /*
     * Heaps are not yet mapped.
     */
    phaiInfo->dwFlags &= ~HEAPALIASINFO_MAPPED;

    /*
     * Allocate the array of heap aliases.
     */
    phaiInfo->lpAliases = MemAlloc( dwNumHeaps * sizeof( HEAPALIAS ) );
    if( NULL == phaiInfo->lpAliases )
    {
        DPF_ERR( "Insufficient memory to allocate heap alias array" );
	MemFree( phaiInfo );
        return DDERR_OUTOFMEMORY;
    }
    phaiInfo->dwNumHeaps = dwNumHeaps;

    /*
     * Allocate the aliases for each vid mem config space window.
     */
    for( i = 0; i < (int) config.wNumMemWindows; i++ )
    {
        DPF(5, "Window %d: wMemAttrib = %d", i, config.wMemAttrib[i]);
        DPF(5, "Window %d: dMemBase = 0x%08x", i, config.dMemBase[i]);
        DPF(5, "Window %d: dMemLength = 0x%08x", i, config.dMemLength[i]);
	if ((config.wMemAttrib[i] & fMD_MemoryType) == fMD_ROM)
        {
            DPF(5, "fMD_MemoryType == fMD_ROM, skipping...");
	    continue;
        }
	if( !AllocHeapAlias( hvxd, config.dMemBase[i], config.dMemLength[i], &phaiInfo->lpAliases[i] ) )
	{
	    DPF_ERR( "Insufficient memory to allocate virtual memory alias" );
	    /*
	     * Discard any aliases already allocated.
	     */
	    for( n = 0; n < i; n++)
		FreeHeapAlias( hvxd, &phaiInfo->lpAliases[n] );
	    MemFree( phaiInfo->lpAliases );
	    MemFree( phaiInfo );
	    return DDERR_OUTOFMEMORY;
	}
    }

    /*
     * Allocate the aliases for each AGP heap.
     */
    dwHeapNo = config.wNumMemWindows;
    for( i = 0; i < (int)pdrv->vmiData.dwNumHeaps; i++ )
    {
        pvm = &(pdrv->vmiData.pvmList[i]);
	if( ( pvm->dwFlags & VIDMEM_ISNONLOCAL ) )
        {
            DPF(5, "AGP Heap %d: fpGARTLin = 0x%08x", i, pvm->lpHeap->fpGARTLin);
            DPF(5, "AGP Heap %d: fpGARTDev = 0x%08x", i, pvm->lpHeap->fpGARTDev);
            DPF(5, "AGP Heap %d: dwTotalSize = 0x%08x", i, pvm->lpHeap->dwTotalSize);
	    if( !AllocHeapAlias( hvxd, pvm->lpHeap->fpGARTDev, pvm->lpHeap->dwTotalSize, &phaiInfo->lpAliases[dwHeapNo] ) )
	    {
	        DPF_ERR( "Insufficient memory to allocate virtual memory alias" );
	        /*
	         * Discard any aliases already allocated.
	         */
	        for( n = 0; n < (int)dwHeapNo; n++)
		    FreeHeapAlias( hvxd, &phaiInfo->lpAliases[n] );
	        MemFree( phaiInfo->lpAliases );
	        MemFree( phaiInfo );
	        return DDERR_OUTOFMEMORY;
	    }
            dwHeapNo++;
        }
    }

    /*
     * Now map all the aliases to video memory.
     */
    hres = MapHeapAliasesToVidMem( hvxd, phaiInfo );
    if( FAILED( hres ) )
    {
        for( i = 0; i < (int) dwNumHeaps; i++)
            FreeHeapAlias( hvxd, &phaiInfo->lpAliases[i] );
        MemFree( phaiInfo->lpAliases );
        MemFree( phaiInfo );
        return hres;
    }

    /*
     * The global object holds a single reference to the aliases
     */
    phaiInfo->dwRefCnt = 1UL;
    pdrv->phaiHeapAliases = phaiInfo;

    return DD_OK;
} /* CreateHeapAliases */

#undef DPF_MODNAME
#define DPF_MODNAME	"ReleaseHeapAliases"

/*
 * ReleaseHeapAliases
 *
 * Release the given heap aliases.
 */
BOOL ReleaseHeapAliases( HANDLE hvxd, LPHEAPALIASINFO phaiInfo )
{
    int i;

    DDASSERT( NULL != phaiInfo );
    DDASSERT( 0UL  != phaiInfo->dwRefCnt );

    phaiInfo->dwRefCnt--;
    if( 0UL == phaiInfo->dwRefCnt )
    {
	DDASSERT( INVALID_HANDLE_VALUE != hvxd );

	DPF( 4, "Heap aliases reference count is zero: discarding aliases" );

	/*
	 * If the heaps are currently mapped then unmap them before
	 * freeing them.
	 */
	DDASSERT( phaiInfo->dwFlags & HEAPALIASINFO_MAPPED );
	UnmapHeapAliases( hvxd, phaiInfo );

	/*
	 * Release all the virtual memory aliases.
	 */
	for( i = 0; i < (int) phaiInfo->dwNumHeaps; i++ )
	{
	    if( NULL != phaiInfo->lpAliases[i].lpAlias )
		FreeHeapAlias( hvxd, &phaiInfo->lpAliases[i] );
	}

	MemFree( phaiInfo->lpAliases );
	MemFree( phaiInfo );
    }

    return TRUE;
} /* ReleaseHeapAliases */

#undef DPF_MODNAME
#define DPF_MODNAME	"MapHeapAliasesToVidMem"

/*
 * MapHeapAliasesToVidMem
 *
 * Map all the heap aliases to video memory.
 */
HRESULT MapHeapAliasesToVidMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo )
{
    int i;

    DDASSERT( NULL != phaiInfo );

    if( phaiInfo->dwFlags & HEAPALIASINFO_MAPPEDREAL )
    {
        DPF( 4, "Heap aliases already mapped to real video memory" );
        return DD_OK;
    }

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );

    for( i = 0; i < (int) phaiInfo->dwNumHeaps; i++ )
    {
	/*
	 * NOTE: If any of the maps fail then we just discard the
	 * alias and continue. Memory allocated out of the failed
	 * heap will need the Win16 lock taken.
	 */
	if( NULL != phaiInfo->lpAliases[i].lpAlias )
	{
	    if( !MAP_HEAP_ALIAS_TO_VID_MEM( hvxd, &phaiInfo->lpAliases[i] ) )
	    {
		DPF( 0, "Heap %d failed to map. Discarding that alias", i );
		FreeHeapAlias( hvxd, &phaiInfo->lpAliases[i] );
	    }
	}
    }

    phaiInfo->dwFlags = ((phaiInfo->dwFlags & ~HEAPALIASINFO_MAPPEDDUMMY) | HEAPALIASINFO_MAPPEDREAL);

    return DD_OK;
} /* MapHeapAliasesToVidMem */

#undef DPF_MODNAME
#define DPF_MODNAME	"MapHeapAliasesToDummyMem"

/*
 * MapHeapAliasesToDummyMem
 *
 * Map all the heap aliases to the dummy read / write page.
 *
 * NOTE: The heap aliases must be mapped to real video memory before
 * calling this function.
 */
HRESULT MapHeapAliasesToDummyMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo )
{
    int     i;
    HRESULT hres;

    DDASSERT( NULL != phaiInfo );

    if( phaiInfo->dwFlags & HEAPALIASINFO_MAPPEDDUMMY )
    {
        DPF( 4, "Heap aliases already mapped to dummy memory" );
        return DD_OK;
    }

    DDASSERT( phaiInfo->dwFlags & HEAPALIASINFO_MAPPEDREAL );
    DDASSERT( INVALID_HANDLE_VALUE != hvxd );

    hres = DD_OK;
    for( i = 0; i < (int) phaiInfo->dwNumHeaps; i++ )
    {
	if( NULL != phaiInfo->lpAliases[i].lpAlias )
	{
	    if( !MAP_HEAP_ALIAS_TO_DUMMY_MEM( hvxd, &phaiInfo->lpAliases[i] ) )
	    {
		/*
		 * Keep going but flag the failure.
		 */
		DPF( 0, "Could not map the heap alias to dummy memory" );
		hres = DDERR_GENERIC;
	    }
	}
    }

    phaiInfo->dwFlags = ((phaiInfo->dwFlags & ~HEAPALIASINFO_MAPPEDREAL) | HEAPALIASINFO_MAPPEDDUMMY);

    return hres;
} /* MapHeapAliasesToDummyMem */

#undef DPF_MODNAME
#define DPF_MODNAME	"UnmapHeapAliases"

/*
 * UnmapHeapAliases
 *
 * Unmap all the heap aliases.
 */
BOOL UnmapHeapAliases( HANDLE hvxd, LPHEAPALIASINFO phaiInfo )
{
    int i;

    DDASSERT( NULL != phaiInfo );

    if( 0UL == ( phaiInfo->dwFlags & HEAPALIASINFO_MAPPED ) )
    {
        DPF( 4, "Heap aliases already unmapped" );
        return TRUE;
    }

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );

    for( i = 0; i < (int) phaiInfo->dwNumHeaps; i++ )
    {
	if( NULL != phaiInfo->lpAliases[i].lpAlias )
	{
	    /*
	     * Nothing we can do if the unmap fails.
	     */
	    UNMAP_HEAP_ALIAS( hvxd, &phaiInfo->lpAliases[i] );
	}
    }

    phaiInfo->dwFlags &= ~HEAPALIASINFO_MAPPED;

    return TRUE;
} /* UnmapHeapAliases */

/*
 * GetAliasedVidMem
 *
 * Get an alias for the given surface with the given video
 * memory pointer.
 */
FLATPTR GetAliasedVidMem( LPDDRAWI_DIRECTDRAW_LCL   pdrv_lcl,
			  LPDDRAWI_DDRAWSURFACE_LCL surf_lcl,
			  FLATPTR                   fpVidMem )
{
    LPDDRAWI_DDRAWSURFACE_GBL surf;
    LPDDRAWI_DIRECTDRAW_GBL   pdrv;
    LPDDPIXELFORMAT           lpddpf;
    DWORD                     dwVidMemSize;
    int                       n;
    LPHEAPALIAS               phaAlias;
    DWORD                     dwHeapOffset;
    FLATPTR                   fpAliasedVidMem;
    FLATPTR                   fpPhysVidMem;
    BOOL fSuccess;

    DDASSERT( NULL != pdrv_lcl );
    DDASSERT( NULL != surf_lcl );
    DDASSERT( 0UL  != fpVidMem );

    surf = surf_lcl->lpGbl;
    pdrv = pdrv_lcl->lpGbl;

    /*
     * If there are not heap aliases we can't really return one.
     */
    if( NULL == pdrv->phaiHeapAliases )
    {
	DPF( 3, "Driver has no heap aliases. Returning a NULL alias pointer" );
	return (FLATPTR)NULL;
    }

    /*
     * Compute the (inclusive) last byte in the surface. We need this
     * to ensure that a surface pointers lies exactly in an aliased
     * heap.
     */
    if (surf_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
        dwVidMemSize = surf->dwLinearSize;
    else
    {
        GET_PIXEL_FORMAT( surf_lcl, surf, lpddpf );
        dwVidMemSize = ( ( ( surf->wHeight - 1 ) * labs( surf->lPitch ) ) +
		       WIDTH_TO_BYTES( lpddpf->dwRGBBitCount, surf->wWidth ) );
    }
    DPF(5, "dwVidMemSize = 0x%08x", dwVidMemSize);
    fpAliasedVidMem = 0UL;
    fSuccess = vxdLinToPhys((HANDLE) pdrv_lcl->hDDVxd, (LPVOID)fpVidMem, dwVidMemSize, (LPVOID*)&fpPhysVidMem);
    if (fSuccess && (fpPhysVidMem != 0))
    {
        phaAlias = &pdrv->phaiHeapAliases->lpAliases[0];
        n = (int) pdrv->phaiHeapAliases->dwNumHeaps;
        while( n-- )
        {
	    DPF( 5, "Checking heap %d Heap start = 0x%08x Heap size = 0x%08x VidMem = 0x%08x",
	         n, phaAlias->fpVidMem, phaAlias->dwAliasSize , fpPhysVidMem );

	    if( ( NULL        != phaAlias->lpAlias  ) &&
	        ( fpPhysVidMem    >= phaAlias->fpVidMem ) &&
	        ( fpPhysVidMem + dwVidMemSize <= ( phaAlias->fpVidMem + phaAlias->dwAliasSize ) ) )
	    {
	        /*
	         * Compute the aliased pointer we are going to return.
	         */
	        dwHeapOffset = (DWORD) fpPhysVidMem - phaAlias->fpVidMem;
	        fpAliasedVidMem = (FLATPTR) ( ( (LPBYTE) phaAlias->lpAlias ) + dwHeapOffset );

	        DPF( 5, "Aliased pointer: 0x%08x - Offset: 0x%08x - Aliased heap: 0x%08x - VidMem heap: 0x%08x",
		     fpAliasedVidMem, dwHeapOffset, phaAlias->lpAlias, phaAlias->fpVidMem );
	        break;
	    }
	    phaAlias++;
        }
    }
    else
        DPF(4, "Could not find contiguous physical memory for linear mem pointer.");
    return fpAliasedVidMem;
}

#endif /* USE_ALIAS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddcsurf.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcsurf.c
 *  Content:    DirectDraw support for for create surface
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   08-jan-95  craige  initial implementation
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   21-jan-95  craige  made 32-bit + ongoing work
 *   31-jan-95  craige  and even more ongoing work...
 *   21-feb-95  craige  work work work
 *   27-feb-95  craige  new sync. macros
 *   02-mar-95  craige  use pitch (not stride)
 *   07-mar-95  craige  keep track of flippable surfaces
 *   08-mar-95  craige  new APIs
 *   12-mar-95  craige  clean up surfaces after process dies...
 *   15-mar-95  craige  more HEL work
 *   19-mar-95  craige  use HRESULTs
 *   20-mar-95  craige  new CSECT work
 *   23-mar-95  craige  attachment work
 *   29-mar-95  craige  use GETCURRPID; only call emulation if
 *                      DDRAWI_EMULATIONINITIALIZED is set
 *   31-mar-95  craige  allow setting of hwnd & ckey
 *   01-apr-95  craige  happy fun joy updated header file
 *   12-apr-95  craige  don't use GETCURRPID
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   15-apr-95  craige  added GetBltStatus
 *   06-may-95  craige  use driver-level csects only
 *   15-may-95  kylej   changed overlay functions in ddSurfaceCallbacks
 *   22-may-95  craige  use MemAlloc16 to get selectors & ptrs
 *   24-may-95  kylej   Added AddOverlayDirtyRect and UpdateOverlayDisplay
 *   24-may-95  craige  added Restore
 *   04-jun-95  craige  added IsLost
 *   11-jun-95  craige  check for some
 *   16-jun-95  craige  removed fpVidMemOrig
 *   17-jun-95  craige  new surface structure
 *   18-jun-95  craige  allow duplicate surfaces
 *   19-jun-95  craige  automatically assign pitch for rectangular surfaces
 *   20-jun-95  craige  use fpPrimaryOrig when allocating primary
 *   21-jun-95  craige  use OBJECT_ISROOT
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  added BltBatch; save display mode object was created in
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns; always assign
 *                      back buffer count to first surface in flipping chain
 *   30-jun-95  kylej   extensive changes to support multiple primary
 *                      surfaces.
 *   30-jun-95  craige  clean pixel formats; use DDRAWI_HASPIXELFORMAT/HASOVERLAYDATA
 *   01-jul-95  craige  fail creation of primary/flipping if not in excl. mode
 *                      alloc overlay space on primary; cmt out streaming;
 *                      bug 99
 *   04-jul-95  craige  YEEHAW: new driver struct; SEH
 *   05-jul-95  craige  added Initialize
 *   08-jul-95  craige  restrict surface width to pitch
 *   09-jul-95  craige  export ComputePitch
 *   11-jul-95  craige  fail aggregation calls
 *   13-jul-95  craige  allow flippable offscreen & textures
 *   18-jul-95  craige  removed Flush
 *   22-jul-95  craige  bug 230 - unsupported starting modes
 *   10-aug-95  craige  misc caps combo bugs
 *   21-aug-95  craige  mode x support
 *   22-aug-95  craige  bug 641
 *   02-sep-95  craige  bug 854: disable > 640x480 flippable primary for rel1
 *   16-sep-95  craige  bug 1117: all primary surfaces were marked as root,
 *                      instead of just first one
 *   19-sep-95  craige  bug 1185: allow any width for explicit sysmem
 *   09-nov-95  colinmc slightly more validation of palettized surfaces
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consistency with Direct3D
 *   06-dec-95  colinmc added mip-map support
 *   09-dec-95  colinmc added execute buffer support
 *   14-dec-95  colinmc added shared back and z-buffer support
 *   18-dec-95  colinmc additional caps. bit validity checking
 *   22-dec-95  colinmc Direct3D support no longer conditional
 *   02-jan-96  kylej   handle new interface structures
 *   10-jan-96  colinmc IUnknowns aggregated by a surface is now a list
 *   18-jan-96  jeffno  NT hardware support in CreateSurface.
 *   29-jan-96  colinmc Aggregated IUnknowns now stored in additional local
 *                      surface data structure
 *   09-feb-96  colinmc Surface lost flag moved from global to local object
 *   15-feb-96  colinmc Changed message output on surface creation to make
 *                      creation of surfaces with unspecified memory caps
 *                      less frightening
 *   17-feb-96  colinmc Fixed execute buffer size limitation problem
 *   13-mar-96  jeffno  Correctly examine flags when allocating NT kernel
 *                      -mode structures
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   26-mar-96  colinmc Bug 14470: Compressed surface support
 *   14-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   17-may-96  craige  Bug 23299: non-power of 2 alignments
 *   23-may-96  colinmc Bug 24190: Explicit system memory surface with
 *                      no pixel format can cause heap corruption if
 *                      another app. changes display depth
 *   26-may-96  colinmc Bug 24552: Heap trash on emulated cards
 *   30-may-96  colinmc Bug 24858: Creating explicit flipping surfaces with
 *                      pixel format fails.
 *   11-jul-96  scottm  Fixed bug in IsDifferentPixelFormat
 *   10-oct-96  ketand  Created DDRAWSURFACE_GBL_MORE (for Physical Page table)
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   08-dec-96  colinmc Initial AGP support
 *   12-jan-96  colinmc More Win16 work
 *   18-jan-97  colinmc AGP support
 *   29-jan-97  jeffno  Mode13 support
 *   30-jan-97  jeffno  Allow surfaces wider than the primary
 *   09-feb-97  colinmc Enabled OWNDC for explicit system memory surfaces
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   08-mar-97  colinmc Support for DMA style AGP parts
 *   10-mar-97  colinmc Bug 5981 Explicit system memory surfaces with
 *                      pixel formats which match the primary don't
 *                      store thier pixel format and hence mutate on a mode
 *                      switch.
 *   24-mar-97  jeffno  Optimized Surfaces
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   18-dec-97 jvanaken CreateSurface now takes client-alloc'd surface memory.
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"


#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#include "junction.h"
#include <limits.h>

/*
 * alignPitch - compute a new pitch that works with the requested alignment
 */
__inline DWORD alignPitch( DWORD pitch, DWORD align )
{
    DWORD       remain;

    /*
     * is it garbage we're getting?
     */
    if( align == 0 )
    {
	return pitch;
    }

    /*
     * is pitch already aligned properly?
     */
    remain = pitch % align;
    if( remain == 0 )
    {
	return pitch;
    }

    /*
     * align pitch to next boundary
     */
    return (pitch + (align - remain));

} /* alignPitch */

#define DPF_MODNAME     "CreateSurface"

/*
 * pixel formats we know we can work with...
 *
 * currently we don't included DDPF_PALETTEINDEXED1, DDPF_PALETTEINDEXED2 and
 * DDPF_PALETTEINDEXED4 in this list so if you want to use one of these you
 * must specify a valid pixel format and have a HEL/HAL that will accept such
 * surfaces.
 */

#define UNDERSTOOD_PF (                \
    DDPF_RGB               |           \
    DDPF_PALETTEINDEXED8   |           \
    DDPF_ALPHAPIXELS       |           \
    DDPF_ZBUFFER           |           \
    DDPF_LUMINANCE         |           \
    DDPF_BUMPDUDV          |           \
    DDPF_BUMPLUMINANCE     |           \
    DDPF_ALPHA             |           \
    DDPF_ZPIXELS)

#define DRIVER_SUPPORTS_DX6_ZBUFFERS(LPDDrawI_DDraw_GBL) ((LPDDrawI_DDraw_GBL)->dwNumZPixelFormats!=0)

// DP2 should always exist in a DX6 D3D driver
#define IS_DX6_D3DDRIVER(pDdGbl) (((pDdGbl)->lpD3DHALCallbacks3!=NULL) &&           \
				  ((pDdGbl)->lpD3DHALCallbacks3->DrawPrimitives2!=NULL))

typedef struct
{
    LPDDRAWI_DDRAWSURFACE_INT   *slist_int;
    LPDDRAWI_DDRAWSURFACE_LCL   *slist_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   *slist;
    BOOL                        listsize;
    BOOL                        listcnt;
    BOOL                        freelist;
    BOOL                        needlink;
} CSINFO;

/*
 * isPowerOf2
 *
 * if the input (dw) is a whole power of 2 returns TRUE and
 * *pPower is set to the exponent.
 * if the input (dw) is not a whole power of 2 returns FALSE and
 * *pPower is undefined.
 * NOTE: the caller can pass NULL for pPower.
 */
BOOL isPowerOf2(DWORD dw, int* pPower)
{
    int   n;
    int   nBits;
    DWORD dwMask;

    nBits = 0;
    dwMask = 0x00000001UL;
    for (n = 0; n < 32; n++)
    {
	if (dw & dwMask)
	{
	    if (pPower != NULL)
		*pPower = n;
	    nBits++;
	    if (nBits > 1)
		break;
	}
	dwMask <<= 1;
    }
    return (nBits == 1);
}

/*
 * freeSurfaceList
 *
 * free all surfaces in an associated surface list, and destroys any
 * resources associated with the surface struct.  This function is only called
 * before the surfaces have been linked into the global surface list and
 * before they have been AddRefed.
 */
static void freeSurfaceList( LPDDRAWI_DDRAWSURFACE_INT *slist_int,
			     int cnt )
{
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    int                         i;

    if( slist_int == NULL )
    {
	return;
    }

    for( i=0;i<cnt;i++ )
    {
	psurf_int = slist_int[i];
	psurf_lcl = psurf_int->lpLcl;
	/*
	 * if fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE then we didn't actually allocate any
	 * video memory.  We still need to call the driver's DestroySurface but we don't want
	 * it to free any video memory because we haven't allocated any.  So we set the
	 * video memory pointer and the heap to NULL.
	 */
	if( (psurf_lcl->lpGbl->fpVidMem == DDHAL_PLEASEALLOC_BLOCKSIZE) ||
            //for the 3dfx driver which fails with fpVidMem correct and blocksizes setup..
            //blocksize is unioned with lpVidMemHeap so we crash in vidmemfree:
            ((psurf_lcl->lpGbl->dwBlockSizeY == (DWORD)psurf_lcl->lpGbl->wHeight) &&
             (psurf_lcl->lpGbl->dwBlockSizeX == (DWORD)psurf_lcl->lpGbl->wWidth)) )
	{
	    psurf_lcl->lpGbl->lpVidMemHeap = NULL;
	    psurf_lcl->lpGbl->fpVidMem = 0;
	}

	DestroySurface( psurf_lcl );

	DeleteAttachedSurfaceLists( psurf_lcl );

        if(IsD3DManaged(psurf_lcl))
        {
            if(psurf_lcl->lpSurfMore->lpRegionList)
            {
                MemFree( psurf_lcl->lpSurfMore->lpRegionList );
            }
        }
	/*
	 * NOTE: We DO NOT explicitly free the DDRAWI_DDRAWSURFACE_MORE
	 * structure pointed to by lpSurfMore as this is allocated in
	 * a single MemAlloc with the local surface structure.
	 */
	MemFree( psurf_lcl );
	MemFree( psurf_int );
    }

} /* freeSurfaceList */

/*
 * GetBytesFromPixels
 */
DWORD GetBytesFromPixels( DWORD pixels, UINT bpp )
{
    DWORD       bytes;

    bytes = pixels;
    switch( bpp ) {
    case 1:
	bytes = (bytes+7)/8;
	break;
    case 2:
	bytes = (bytes+3)/4;
	break;
    case 4:
	bytes = (bytes+1)/2;
	break;
    case 8:
	break;
    case 16:
	bytes *= 2;
	break;
    case 24:
	bytes *= 3;
	break;
    case 32:
	bytes *= 4;
	break;
    default:
	bytes = 0;
    }
    DPF( 5, "GetBytesFromPixels( %ld, %d ) = %d", pixels, bpp, bytes );

    return bytes;

} /* GetBytesFromPixels */

/*
 * getPixelsFromBytes
 */
static DWORD getPixelsFromBytes( DWORD bytes, UINT bpp )
{
    DWORD       pixels;

    pixels = bytes;
    switch( bpp ) {
    case 1:
	pixels *= 8L;
	break;
    case 2:
	pixels *= 4L;
	break;
    case 4:
	pixels *= 2L;
	break;
    case 8:
	break;
    case 16:
	pixels /= 2L;
	break;
    case 24:
	pixels /= 3L;
	break;
    case 32:
	pixels /= 4L;
	break;
    default:
	pixels = 0;
    }
    DPF( 5, "getPixelsFromBytes( %ld, %d ) = %d", bytes, bpp, pixels );
    return pixels;

} /* getPixelsFromBytes */

DWORD
GetSurfaceHandle(LPDWLIST lpSurfaceHandleList, LPDDRAWI_DDRAWSURFACE_LCL lpSurface)
{
    DWORD   handle=lpSurfaceHandleList->dwFreeList;
    if (0==handle)
    {
        // need to grow the dwList
        LPDDSURFACELISTENTRY  newList;
        DWORD   newsize;
        DWORD   index;
        if (NULL != lpSurfaceHandleList->dwList)
        {
            // old size(current dwFreeList) must not be zero
            DDASSERT(0 != lpSurfaceHandleList->dwList[0].nextentry);
            // new dwFreeList is always gonna be the old dwList[0].nextentry
            newsize = lpSurfaceHandleList->dwList[0].nextentry + LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
	        DPF_ERR( "MemAlloc failure in GetSurfaceHandle()" );
                return  0;
            }
            lpSurfaceHandleList->dwFreeList=lpSurfaceHandleList->dwList[0].nextentry;
            memcpy((LPVOID)newList,(LPVOID)lpSurfaceHandleList->dwList,
                lpSurfaceHandleList->dwList[0].nextentry*sizeof(DDSURFACELISTENTRY));
            MemFree(lpSurfaceHandleList->dwList);
        }
        else
        {
            newsize = LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
	        DPF_ERR( "MemAlloc failure in GetSurfaceHandle()" );
                return  0;
            }
            // start from one as we don't want 0 as a valid handle
            lpSurfaceHandleList->dwFreeList = 1;
        }
        lpSurfaceHandleList->dwList=newList;
        lpSurfaceHandleList->dwList[0].nextentry=newsize;

        for(index=lpSurfaceHandleList->dwFreeList;index<newsize-1;index++)
        {
            newList[index].nextentry=index+1;
        }
        // indicate end of new FreeList
        newList[newsize-1].nextentry=0;
        // now pop up one and assign it to handle
        handle=lpSurfaceHandleList->dwFreeList;
    }
    // handle slot is avialable so just remove it from freeList
    lpSurfaceHandleList->dwFreeList=lpSurfaceHandleList->dwList[handle].nextentry;
#if DBG
    lpSurfaceHandleList->dwList[handle].nextentry=0xDEADBEEF;
#endif
    lpSurfaceHandleList->dwList[handle].dwFlags=0;  //mark it's new
    lpSurfaceHandleList->dwList[handle].lpSurface=lpSurface;
    DDASSERT ( handle > 0);
    DDASSERT ( handle < lpSurfaceHandleList->dwList[0].nextentry);
    return handle;
}

void
ReleaseSurfaceHandle(LPDWLIST   lpSurfaceHandleList,DWORD handle)
{
    DDASSERT ( handle > 0);
    DDASSERT ( NULL != lpSurfaceHandleList->dwList);
    DDASSERT ( handle < lpSurfaceHandleList->dwList[0].nextentry);
#if DBG
    DDASSERT ( 0xDEADBEEF == lpSurfaceHandleList->dwList[handle].nextentry);
#endif
    lpSurfaceHandleList->dwList[handle].nextentry = lpSurfaceHandleList->dwFreeList;
    lpSurfaceHandleList->dwFreeList = handle;
}

LPDDRAWI_DDRAWSURFACE_LCL
WINAPI GetDDSurfaceLocal(LPDDRAWI_DIRECTDRAW_LCL this_lcl, DWORD handle, BOOL* isnew)
{
    DDASSERT ( NULL != this_lcl);
    DDASSERT ( NULL != SURFACEHANDLELIST(this_lcl).dwList);
    DDASSERT ( handle > 0);
    DDASSERT ( handle < SURFACEHANDLELIST(this_lcl).dwList[0].nextentry);
#if DBG
    DDASSERT ( 0xDEADBEEF == SURFACEHANDLELIST(this_lcl).dwList[handle].nextentry);
#endif
    if (FALSE == *isnew)
    {
        // only change flag if we are called from Reference Raterizer
        *isnew=(SURFACEHANDLELIST(this_lcl).dwList[handle].dwFlags==0);
        SURFACEHANDLELIST(this_lcl).dwList[handle].dwFlags=1;   //mark it's not new anymore
    }
    return SURFACEHANDLELIST(this_lcl).dwList[handle].lpSurface;
}
/*
 * AllocSurfaceMem
 *
 * Allocate the memory for all surfaces that need it...
 */
HRESULT AllocSurfaceMem(
		LPDDRAWI_DIRECTDRAW_LCL     this_lcl,
		LPDDRAWI_DDRAWSURFACE_LCL * slist_lcl,
		int                         nsurf)
{
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       vm_width;
    DWORD                       vm_height;
    int                         scnt;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf;
    DWORD                       caps;
    FLATPTR                     pvidmem;
    LPVIDMEM                    pheap;
    BOOL                        do_alloc;
    LONG                        newpitch;
    BOOL                        save_pitch;
    DWORD                       newcaps;
    DWORD                       forcemem = 0;
    BOOL                        anytype;

    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );

    /*
     * allocate any remaining video memory needed
     */
    for( scnt=0;scnt<nsurf;scnt++ )
    {
	/*
	 * Stores new capabilities which are introduced depending on the memory
	 * heap allocated from.
	 */
	newcaps = 0UL;
	newpitch = 0;
	DPF( 5,V, "*** Alloc Surface %d ***", scnt );

	/*
	 * get preset video memory pointer
	 */
	pheap = NULL;
	psurf_lcl = slist_lcl[scnt];
	psurf = psurf_lcl->lpGbl;
	do_alloc = TRUE;
	pvidmem = psurf->fpVidMem;  //If this is a Restore, this will be non-null only if it's the gdi surface...
				    //that's the only surface that doesn't have its vram deallocated
				    //by DestroySurface. (assumption of jeffno 960122)
	DPF( 5,V, "pvidmem = %08lx", pvidmem );
	save_pitch = FALSE;
	if( pvidmem != (FLATPTR) NULL )
	{
	    if( pvidmem != (FLATPTR) DDHAL_PLEASEALLOC_BLOCKSIZE )
	    {
		do_alloc = FALSE;

#ifdef SHAREDZ
		/*
		 * NOTE: Previously if we did not do the alloc we
		 * overwrote the heap pointer with NULL. This broke
		 * the shared surfaces stuff. So now we assume that
		 * if the heap pointer is non-NULL we will preserve
		 * that value.
		 *
		 * !!! NOTE: Will this break stuff. Need to check this
		 * out.
		 */
		if( psurf->lpVidMemHeap )
		    pheap = psurf->lpVidMemHeap;
#endif
	    }
	    save_pitch = TRUE;
	}
	caps = psurf_lcl->ddsCaps.dwCaps;

	/*
	 * are we creating a primary surface?
	 */
	if( psurf->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) //caps & DDSCAPS_PRIMARYSURFACE )
	{
	    DPF(5,V,"allocing for primary (do_alloc==%d)",do_alloc);
	    if( do_alloc )
	    {
		pvidmem = this->fpPrimaryOrig;
	    }

	/*
	 * must be an offscreen surface of some kind
	 */
	}
	else
	{
            /*
             * NT handles all memory management issues in the kernel....
             */
#ifndef WINNT
	    /*
	     * get a video memory pointer if no other ptr specified
	     */
	    if( do_alloc )
	    {
		/*
		 * get area of surface
		 */
		if( pvidmem == (FLATPTR) DDHAL_PLEASEALLOC_BLOCKSIZE )
		{
		    vm_width = psurf->dwBlockSizeX;
		    vm_height = psurf->dwBlockSizeY;
		    DPF( 5,V, "Driver requested width=%ld, height%ld", vm_width, vm_height );
		}
		else
		{
		    if( caps & DDSCAPS_EXECUTEBUFFER )
		    {
			/*
			 * Execute buffers are long, thin surfaces for the purposes
			 * of VM allocation.
			 */
			vm_width  = psurf->dwLinearSize;
			vm_height = 1UL;
		    }
		    else
		    {
			/*
			 * This lPitch may have been expanded by ComputePitch
			 * to cover global alignment restrictions.
			 */
			vm_width  = (DWORD) labs( psurf->lPitch );
			vm_height = (DWORD) psurf->wHeight;
		    }
		    DPF( 5,V, "width = %ld, height = %ld", vm_width, vm_height );
		}

		/*
		 * try to allocate memory
		 */
		if( caps & DDSCAPS_SYSTEMMEMORY )
		{
		    pvidmem = 0;
		    pheap = NULL;
		}
		else
		{
                    DWORD dwFlags = 0;
                    HANDLE hvxd = GETDDVXDHANDLE( this_lcl );

                    if (psurf->dwGlobalFlags &
                        DDRAWISURFGBL_LATEALLOCATELINEAR)
                    {
                        dwFlags |= DDHA_SKIPRECTANGULARHEAPS;
                    }

		    if (this_lcl->lpGbl->ddCaps.dwCaps2 &
			DDCAPS2_NONLOCALVIDMEMCAPS)
		    {
			dwFlags |= DDHA_ALLOWNONLOCALMEMORY;
		    }

		    if (this_lcl->lpGbl->lpD3DGlobalDriverData != 0 &&
			(this_lcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps &
			D3DDEVCAPS_TEXTURENONLOCALVIDMEM))
		    {
			dwFlags |= DDHA_ALLOWNONLOCALTEXTURES;
		    }

                    if (forcemem)
                    {
                        // Force allocations to the same memory type as the first 
                        psurf_lcl->ddsCaps.dwCaps &= ~(DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                        psurf_lcl->ddsCaps.dwCaps |= forcemem;
                    }

		    pvidmem = DdHeapAlloc( this->vmiData.dwNumHeaps,
					   this->vmiData.pvmList,
					   hvxd, &this->vmiData,
					   vm_width, vm_height, psurf_lcl,
					   dwFlags, &pheap,
					   &newpitch, &newcaps, NULL );
		    if( pvidmem == (FLATPTR) NULL )
		    {
			pvidmem = DdHeapAlloc( this->vmiData.dwNumHeaps,
					       this->vmiData.pvmList,
					       hvxd, &this->vmiData,
					       vm_width, vm_height, psurf_lcl,
					       dwFlags | DDHA_USEALTCAPS,
                                               &pheap, &newpitch, &newcaps, NULL );
		    }
                    
                    if (forcemem == 0)
                    {
                        // All surfaces must be of the same type as the first so we force 
                        // that type - newcaps contains either DDSCAPS_LOCALVIDMEM or 
                        // DDSCAPS_NONLOCALVIDMEM
                        forcemem = newcaps;
                        
                        // determines whether the memory type was explicit or not, so we know
                        // if we can change it if an allocation fails
                        anytype  = !(psurf_lcl->ddsCaps.dwCaps & (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM));
                    }
                    else if (!pvidmem && anytype)
                    {
                        // Memory type was not explicity specified, so we're going to try the 
                        // other memory type

                        int i;
                        for (i=0; i<scnt; i++)
                        {
                            LPDDRAWI_DDRAWSURFACE_GBL tsurf = slist_lcl[i]->lpGbl;
                            DDASSERT(tsurf->lpVidMemHeap != NULL);
                            DDASSERT(tsurf->fpVidMem != (FLATPTR)NULL);
                            VidMemFree(tsurf->lpVidMemHeap, tsurf->fpVidMem);
                            tsurf->fpVidMem = (FLATPTR)NULL;
                        }

                        // Back up to the first surface
                        scnt = -1;

                        // Force the other memory type
                        forcemem = (forcemem & DDSCAPS_LOCALVIDMEM) ? DDSCAPS_NONLOCALVIDMEM : DDSCAPS_LOCALVIDMEM;
                        
                        // Can no longer change memory type
                        anytype  = FALSE;
                        
                        DPF(4,"Not all surfaces in chain fit into 1 memory type, trying another");
                        continue;
                    }
		}
	    }
#endif //!WINNT
	}

	/*
	 * zero out overloaded fields
	 */
	psurf->dwBlockSizeX = 0;
        if (!(psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME))
        {
            // Don't zero this for volumes because it contains the slice pitch.
            // We will zero it later.
	    psurf->dwBlockSizeY = 0;
        }

	/*
	 * if no video memory found, fail
	 */
	if( pvidmem == (FLATPTR) NULL   && !(psurf->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) )//(caps & DDSCAPS_PRIMARYSURFACE) )
	{
#ifndef WINNT
	    DPF( 1, "Out of Video Memory. requested block: (%ld,%ld) (%ld bytes)",
		vm_width, vm_height, vm_height * vm_width );
	    // set the heap to null so we don't mistakenly try to free the memory in DestroySurface
#endif //not WINNT
	    psurf->lpVidMemHeap = NULL;
	    return DDERR_OUTOFVIDEOMEMORY;
	}

	/*
	 * save pointer to video memory that we are using
	 */
        if (pheap)
	    psurf->lpVidMemHeap = pheap->lpHeap;
        else
	    psurf->lpVidMemHeap = 0;

	psurf->fpVidMem = pvidmem;
	if( newpitch != 0 && !save_pitch && !( caps & DDSCAPS_EXECUTEBUFFER ) )
	{
	    /*
	     * The stride is not relevant for an execute buffer so we don't
	     * override it.
	     */
	    psurf->lPitch = newpitch;
	}

	/*
	 * Need to ensure that all video memory surfaces are tagged with
	 * either DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM even if
	 * the driver allocated them.
	 */
	psurf_lcl->ddsCaps.dwCaps |= newcaps;
	if( psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
	{
	    if( !( psurf_lcl->ddsCaps.dwCaps & ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) ) )
	    {
		/*
		 * Neither of local or non-local video memory have been set. In the
		 * case of a driver which is not AGP aware then just turn local
		 * video memory on. We also turn it on in the case of the primary
		 * (which we know is in local video memory).
		 *
		 * NOTE: AGP aware devices should set the appropriate caps bit if
		 * they take over surface allocation. However, we assume that if
		 * they haven't then its local video memory (taking over non-local
		 * allocation is hard). This is a very dodgy assumption and we should
		 * revist it.
		 */
                psurf_lcl->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
		#ifdef DEBUG
		    #pragma message(REMIND("Fail creation by drivers that don't set vid mem qualifiers?"))
		    if( this_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM )
		    {
			DDASSERT( psurf_lcl->ddsCaps.dwCaps & ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) );
			DPF( 1, "AGP aware driver failed to set DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM" );
		    }
		#endif /* DEBUG */
	    }

            #ifndef WINNT
                if (forcemem == 0)
                {
                    // Make sure we allocate all subsequent memory from the same source as the primary
                    forcemem = psurf_lcl->ddsCaps.dwCaps & (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                    anytype  = FALSE;
                }
            #endif
	}

	/*
	 * If the surface has ended up in non-local video memory then we need to
	 * compute the physical memory pointer of the surface and store this away
	 * for driver usage.
	 */
	if( psurf_lcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM )
	{
	    /*
	     * Computing the offset is simple but it requires that we have a
	     * heap pointer. If we don't have one we assume that the driver
	     * has filled the physical pointer in for us (as it has taken
	     * over surface creation from us).
	     */
	    if( NULL != psurf->lpVidMemHeap )
	    {
		DWORD   dwOffset;
		FLATPTR fpPhysicalVidMem;

		DDASSERT( 0UL != psurf->fpVidMem );
		DDASSERT( 0UL != psurf->lpVidMemHeap->fpGARTLin );

		dwOffset = (DWORD)( psurf->fpVidMem - psurf->lpVidMemHeap->fpGARTLin );
		fpPhysicalVidMem = psurf->lpVidMemHeap->fpGARTDev + dwOffset;

		GET_LPDDRAWSURFACE_GBL_MORE( psurf )->fpPhysicalVidMem = fpPhysicalVidMem;

		DPF( 5, "Non-local surface: fpVidmem = 0x%08x fpPhysicalVidMem = 0x%08x",
		     psurf->fpVidMem, fpPhysicalVidMem );
	    }
	}
    }
    return DD_OK;

} /* AllocSurfaceMem */


/*
 * checkCaps
 *
 * check to make sure various caps combinations are valid
 */
static HRESULT checkCaps( DWORD caps, LPDDRAWI_DIRECTDRAW_INT pdrv_int, LPDDSCAPSEX lpCapsEx )
{
    DDASSERT(lpCapsEx);

    /*
     * check for no caps at all!
     */
    if( caps == 0 )
    {
	DPF_ERR( "no caps specified" );
	return DDERR_INVALIDCAPS;
    }

    /*
     * check for bogus caps.
     */
    if( caps & ~DDSCAPS_VALID )
    {
	DPF_ERR( "Create surface: invalid caps specified" );
	return DDERR_INVALIDCAPS;
    }

    if (lpCapsEx->dwCaps2 & ~DDSCAPS2_VALID)
    {
	DPF_ERR( "Create surface: invalid caps2 specified" );
	return DDERR_INVALIDCAPS;
    }

    if (lpCapsEx->dwCaps3 & ~DDSCAPS3_VALID)
    {
	DPF_ERR( "Create surface: invalid caps3 specified" );
	return DDERR_INVALIDCAPS;
    }

    if (!(lpCapsEx->dwCaps2 & DDSCAPS2_VOLUME))
    {
        if (lpCapsEx->dwCaps4 & ~DDSCAPS4_VALID)
        {
	    DPF_ERR( "Create surface: invalid caps4 specified" );
	    return DDERR_INVALIDCAPS;
        }
    }

    /*
     * check for "read-only" caps
     */
    if( caps & (DDSCAPS_PALETTE|
		DDSCAPS_VISIBLE) )
    {
	DPF_ERR( "read-only cap specified" );
	return DDERR_INVALIDCAPS;
    }
    if ((caps & DDSCAPS_WRITEONLY) && !(caps & DDSCAPS_EXECUTEBUFFER) && !(lpCapsEx->dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE)))
    {
	DPF_ERR( "read-only cap specified" );
	return DDERR_INVALIDCAPS;
    }

    // Make sure that DONOTPERSIST is used only in texture managed surfaces
    if ( lpCapsEx->dwCaps2 & DDSCAPS2_DONOTPERSIST )
    {
        if ( !(lpCapsEx->dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE)) )
        {
            DPF_ERR( "DDSCAPS2_DONOTPERSIST can only be used with managed surfaces" );
            return DDERR_INVALIDCAPS;
        }
    }

    // Check for correct usage of texturemanage caps
    if ( lpCapsEx->dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE) )
    {
	if (0 == (caps & DDSCAPS_TEXTURE) && !(pdrv_int->lpLcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8))
	{
	    DPF_ERR("Managed surfaces must be textures");
	    return DDERR_INVALIDCAPS;
	}
    }
    if( !(~lpCapsEx->dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE)) )
    {
	DPF_ERR( "DDSCAPS2 flags DDSCAPS2_TEXTUREMANAGE and DDSCAPS2_D3DTEXTUREMANAGE are mutually exclusive" );
	return DDERR_INVALIDCAPS;
    }

    // Check if DDSCAPS2_HINTDYNAMIC, DDSCAPS2_HINTSTATIC, and DDSCAPS2_OPAQUE have
    // been correctly specified
    if (!(pdrv_int->lpLcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8))
    {
        if( (lpCapsEx->dwCaps2 & (DDSCAPS2_HINTDYNAMIC | DDSCAPS2_HINTSTATIC | DDSCAPS2_OPAQUE)) &&
	    !(caps & DDSCAPS_TEXTURE) )
        {
	    DPF_ERR( "DDSCAPS2 flags HINTDYNAMIC, HINTSTATIC and OPAQUE can only be used with textures" );
	    return DDERR_INVALIDCAPS;
        }
    }
    if( !(~lpCapsEx->dwCaps2 & (DDSCAPS2_HINTDYNAMIC | DDSCAPS2_HINTSTATIC)) )
    {
	DPF_ERR( "DDSCAPS2 flags HINTDYNAMIC and HINTSTATIC are mutually exclusive" );
	return DDERR_INVALIDCAPS;
    }
    else if( !(~lpCapsEx->dwCaps2 & (DDSCAPS2_HINTDYNAMIC | DDSCAPS2_OPAQUE)) )
    {
	DPF_ERR( "DDSCAPS2 flags HINTDYNAMIC and OPAQUE are mutually exclusive" );
	return DDERR_INVALIDCAPS;
    }
    else if( !(~lpCapsEx->dwCaps2 & (DDSCAPS2_HINTSTATIC | DDSCAPS2_OPAQUE)) )
    {
	DPF_ERR( "DDSCAPS2 flags HINTSTATIC and OPAQUE are mutually exclusive" );
	return DDERR_INVALIDCAPS;
    }

    /*
     * Valid optimized surface caps?
     */
    if( caps & DDSCAPS_OPTIMIZED )
    {
	// ATTENTION: Potential Apps-Compat problem!!
	DPF_ERR("Optimized surfaces cannot be created by create-surface");
	return DDERR_INVALIDCAPS;
#if 0 //Old code
	if( !(caps & DDSCAPS_TEXTURE) )
	{
	    DPF_ERR("Optimized surfaces can only be textures");
	    return DDERR_INVALIDCAPS;
	}
	if (caps & (DDSCAPS_OWNDC|DDSCAPS_3DDEVICE|DDSCAPS_ALLOCONLOAD))
	{
	    DPF_ERR("Invalid caps used in conjunction with DDSCAPS_OPTIMIZED");
	    return DDERR_INVALIDCAPS;
	}
	if ( (caps & (DDSCAPS_SYSTEMMEMORY|DDSCAPS_VIDEOMEMORY)) == 0)
	{
	    DPF_ERR("Optimized surfaces must be explicitly system or video memory");
	    return DDERR_INVALIDCAPS;
	}
#endif //0
    }

    /*
     * Check for memory type qualifiers
     */
    if( caps & ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) )
    {
	/*
	 * Neither flag is allowed with system memory.
	 */
	if( caps & DDSCAPS_SYSTEMMEMORY )
	{
	    DPF_ERR( "Cannot specify local or non-local video memory with DDSCAPS_SYSTEMMEMORY" );
	    return DDERR_INVALIDCAPS;
	}

	/*
	 * One of the other of LOCALVIDMEM or NONLOCALVIDMEM but NOT both.
	 */
	if( ( caps & ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) ) ==
	    ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) )
	{
	    DPF_ERR( "Cannot specify both DDSCAPS_LOCALVIDMEM and DDSCAPS_NONLOCALVIDMEM" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * For non-v1 interfaces, FRONTBUFFER and BACKBUFFER are read-only
     */
    if( pdrv_int->lpVtbl != &ddCallbacks )
    {
	if( caps & (DDSCAPS_FRONTBUFFER | DDSCAPS_BACKBUFFER) )
	{
	    DPF_ERR( "can't specify FRONTBUFFER or BACKBUFFER");
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * Rather than having lots of little checks for execute buffers
     * we simply check for what can mix with execute buffers right
     * up front - its not a lot - system and video memory only.
     */
    if( caps & DDSCAPS_EXECUTEBUFFER )
    {
	if( caps & ~( DDSCAPS_EXECUTEBUFFER |
		      DDSCAPS_SYSTEMMEMORY  |
		      DDSCAPS_VIDEOMEMORY |
                      DDSCAPS_WRITEONLY ) )
	{
	    DPF_ERR( "invalid caps specified with execute buffer" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check for caps that don't mix with complex
     */
    if( caps & DDSCAPS_COMPLEX )
    {
	if( caps & ( DDSCAPS_FRONTBUFFER) )
	{
	    DPF_ERR( "DDSCAPS_FRONTBUFFER flag is with DDSCAPS_COMPLEX" );
	    return DDERR_INVALIDCAPS;
	}
	if( caps & DDSCAPS_BACKBUFFER )
	{
	    if( !(caps & DDSCAPS_ALPHA) && !(caps & DDSCAPS_ZBUFFER))
	    {
		DPF_ERR( "invalid CAPS flags: complex & backbuffer, but no alpha or zbuffer" );
		return DDERR_INVALIDCAPS;
	    }
	    if( (caps & DDSCAPS_FLIP))
	    {
		DPF_ERR( "invalid CAPS flags: complex & backbuffer & flip" );
		return DDERR_INVALIDCAPS;
	    }
	}
	if( !(caps & (DDSCAPS_BACKBUFFER|
		     DDSCAPS_OFFSCREENPLAIN|
		     DDSCAPS_OVERLAY|
		     DDSCAPS_TEXTURE|
		     DDSCAPS_PRIMARYSURFACE)) )
	{
	    DPF_ERR( "invalid CAPS flags: DDSCAPS_COMPLEX requires at least one of DDSCAPS_BACKBUFFER/DDSCAPS_OFFSCREENPLAIN/DDSCAPS_OVERLAY/DDSCAPS_TEXTURE/DDSCAPS_PRIMARYSURFACE to be set");
	    return DDERR_INVALIDCAPS;
	}
	if( !(caps & (DDSCAPS_FLIP|DDSCAPS_ALPHA|DDSCAPS_MIPMAP|DDSCAPS_ZBUFFER) ) &&
            !(lpCapsEx->dwCaps2 & DDSCAPS2_CUBEMAP) )
	{
	    DPF_ERR( "invalid CAPS flags: must specify at least one of FLIP, ALPHA, ZBUFFER, 2_CUBEMAP or MIPMAP with COMPLEX" );
	    return DDERR_INVALIDCAPS;
	}
    /*
     * flags that can't be used if not complex
     */
    }
    else
    {
//      if( caps & DDSCAPS_BACKBUFFER  ) {
//          DPF_ERR( "invalid flags: backbuffer specfied for non-complex surface" );
//          return DDERR_INVALIDCAPS;
//      }
    }

    /*
     * check for caps that don't mix with backbuffer
     */
    if( caps & DDSCAPS_BACKBUFFER )
    {
	if( caps & (DDSCAPS_ALPHA |
		    DDSCAPS_FRONTBUFFER ) )
	{
	    DPF_ERR( "Invalid flags with backbuffer" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check for flags that don't mix with a flipping surface
     */
    if( caps & DDSCAPS_FLIP )
    {
	if( !(caps & DDSCAPS_COMPLEX) )
	{
	    DPF_ERR( "invalid flags - flip but not complex" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check for flags that don't mix with a primary surface
     */
    if( caps & DDSCAPS_PRIMARYSURFACE )
    {
	if( caps & (DDSCAPS_BACKBUFFER     |
		    DDSCAPS_OFFSCREENPLAIN |
		    DDSCAPS_OVERLAY        |
		    DDSCAPS_TEXTURE ) )
	{
	    DPF_ERR( "invalid flags with primary" );
	    return DDERR_INVALIDCAPS;
	}
	/* GEE: can't allow complex attachments to the primary surface
	 * because of our attachment code.  The user is allowed to build
	 * these manually.
	 */
	#ifdef USE_ALPHA
	if( (caps & DDSCAPS_ALPHA) && !(caps & DDSCAPS_FLIP) )
	{
	    DPF_ERR( "invalid flags with primary - alpha but not flippable" );
	    return DDERR_INVALIDCAPS;
	}
	#endif
	if( (caps & DDSCAPS_ZBUFFER) && !(caps & DDSCAPS_FLIP) )
	{
	    DPF_ERR( "invalid flags with primary - z but not flippable" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * flags that don't mix with a plain offscreen surface
     */
    if( caps & DDSCAPS_OFFSCREENPLAIN )
    {
	/*
	 * I see no reason not to allow offscreen plains to be created
	 * with alpha's and z-buffers. So they have been enabled.
	 */
	if( caps & (DDSCAPS_BACKBUFFER |
		    DDSCAPS_OVERLAY    |
		    DDSCAPS_TEXTURE ) )
	{
	    DPF_ERR( "invalid flags with offscreenplain" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check for flags that don't mix with asking for an overlay
     */
    if( caps & DDSCAPS_OVERLAY )
    {
	/* GEE: should remove BACKBUFFER here for 3D stuff */
	if( caps & (DDSCAPS_BACKBUFFER     |
		    DDSCAPS_OFFSCREENPLAIN |
		    DDSCAPS_TEXTURE ) )
	{
	    DPF_ERR( "invalid flags with overlay" );
	    return DDERR_INVALIDCAPS;
	}
	if( (caps & DDSCAPS_ZBUFFER) && !(caps & DDSCAPS_FLIP) )
	{
	    DPF_ERR( "invalid flags with overlay - zbuffer but not flippable" );
	    return DDERR_INVALIDCAPS;
	}
	#ifdef USE_ALPHA
	if( (caps & DDSCAPS_ALPHA) && !(caps & DDSCAPS_FLIP) )
	{
	    DPF_ERR( "invalid flags with overlay - alpha but not flippable" );
	    return DDERR_INVALIDCAPS;
	}
	#endif
    }

    /*
     * check for flags that don't mix with asking for an texture
     */
    if( caps & DDSCAPS_TEXTURE )
    {
    }

    /*
     * validate MIPMAP
     */
    if( caps & DDSCAPS_MIPMAP )
    {
	/*
	 * Must be used in conjunction with TEXTURE.
	 */
	if( !( caps & DDSCAPS_TEXTURE ) )
	{
	    DPF_ERR( "invalid flags, mip-map specified but not texture" );
	    return DDERR_INVALIDCAPS;
	}

	/*
	 * Can't specify Z-buffer and mip-map.
	 */
	if( caps & DDSCAPS_ZBUFFER )
	{
	    DPF_ERR( "invalid flags, can't specify z-buffer with mip-map" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check for flags that don't mix with asking for a z-buffer
     */
    if( caps & DDSCAPS_ZBUFFER )
    {
	#ifdef USE_ALPHA
	if( caps & DDSCAPS_ALPHA )
	{
	    if( !(caps & DDSCAPS_COMPLEX) )
	    {
		DPF_ERR( "invalid flags, alpha and Z specified, but not complex" );
	    }
	}
	#endif

	if( ( caps & DDSCAPS_BACKBUFFER ) && !( caps & DDSCAPS_COMPLEX ) )
	{
	    /*
	     * Can't specify z-buffer and back-buffer unless you also specify
	     * complex.
	     */
	    DPF_ERR( "invalid flags, z-buffer and back-buffer specified but not complex" );
	    return DDERR_INVALIDCAPS;
	}
    }

#ifdef SHAREDZ
    /*
     * Validate SHAREDZBUFFER
     */
    if( caps & DDSCAPS_SHAREDZBUFFER )
    {
	if( !( caps & DDSCAPS_ZBUFFER ) )
	{
	    DPF_ERR( "invalid flags, shared z-buffer specified, but not z-buffer" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * Validate SHAREDBACKBUFFER
     */
    if( caps & DDSCAPS_SHAREDBACKBUFFER )
    {
	/*
	 * Either BACKBUFFER must be specified explicitly or we must be part of
	 * a complex flippable chain.
	 */
	if( !( ( caps & DDSCAPS_BACKBUFFER ) ||
	       ( ( caps & ( DDSCAPS_COMPLEX | DDSCAPS_FLIP ) ) ==
			  ( DDSCAPS_COMPLEX | DDSCAPS_FLIP ) ) ) )
	{
	    DPF_ERR("invalid flags, shared back-buffer specified but not back-buffer or flippable chain" );
	    return DDERR_INVALIDCAPS;
	}
    }
#endif

    /*
     * check for flags that don't mix with asking for an alpha surface
     */
    #ifdef USE_ALPHA
    if( caps & DDSCAPS_ALPHA )
    {
    }
    #endif

    /*
     * check for flags that don't mix with asking for an alloc-on-load surface
     */
    if( caps & DDSCAPS_ALLOCONLOAD )
    {
	/*
	 * Must be texture map currently.
	 */
	if( !( caps & DDSCAPS_TEXTURE ) )
	{
	    DPF_ERR( "invalid flags, allocate-on-load surfaces must be texture maps" );
	    return DDERR_INVALIDCAPS;
	}
    }

    if (lpCapsEx->dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES)
    {
        if (0 == (lpCapsEx->dwCaps2 & DDSCAPS2_CUBEMAP) )
        {
            DPF_ERR("You must specify DDSCAPS2_CUBEMAP if you specify any of DDSCAPS2_CUBEMAP_*");
            return DDERR_INVALIDCAPS;
        }
    }

    /*
     * What doesn't mix with cubemaps
     */
    if (lpCapsEx->dwCaps2 & DDSCAPS2_CUBEMAP)
    {
        if (
           (caps & ~(
            DDSCAPS_SYSTEMMEMORY |
            DDSCAPS_VIDEOMEMORY |
            DDSCAPS_NONLOCALVIDMEM |
            DDSCAPS_LOCALVIDMEM |
            DDSCAPS_TEXTURE |
            DDSCAPS_3DDEVICE |
            DDSCAPS_MIPMAP |
            DDSCAPS_COMPLEX |
            DDSCAPS_OWNDC |
            DDSCAPS_ALLOCONLOAD |
            DDSCAPS_WRITEONLY |
            DDSCAPS_VIDEOPORT ) )
            ||
           (lpCapsEx->dwCaps2 & ~(
            DDSCAPS2_PERSISTENTCONTENTS |
            DDSCAPS2_RESERVED4 |
            DDSCAPS2_HINTDYNAMIC |
            DDSCAPS2_HINTSTATIC |
            DDSCAPS2_TEXTUREMANAGE |
            DDSCAPS2_D3DTEXTUREMANAGE |
            DDSCAPS2_OPAQUE |
            DDSCAPS2_CUBEMAP |
            DDSCAPS2_CUBEMAP_ALLFACES |
            DDSCAPS2_DONOTPERSIST |
            DDSCAPS2_HINTANTIALIASING |
            DDSCAPS2_DONOTCREATED3DTEXOBJECT |
            DDSCAPS2_NOTUSERLOCKABLE |
            DDSCAPS2_DEINTERLACE ) )
            ||
            lpCapsEx->dwCaps3
            ||
            lpCapsEx->dwCaps4
            )
        {
            DPF_ERR("Invalid surface caps with DDSCAPS2_CUBEMAP");
            DPF_ERR("   Valid additional surface caps are:");
            DPF_ERR("   DDSCAPS_SYSTEMMEMORY ");
            DPF_ERR("   DDSCAPS_VIDEOMEMORY ");
            DPF_ERR("   DDSCAPS_NONLOCALVIDMEM ");
            DPF_ERR("   DDSCAPS_LOCALVIDMEM ");
            DPF_ERR("   DDSCAPS_TEXTURE ");
            DPF_ERR("   DDSCAPS_3DDEVICE ");
            DPF_ERR("   DDSCAPS_MIPMAP ");
            DPF_ERR("   DDSCAPS_COMPLEX ");
            DPF_ERR("   DDSCAPS_OWNDC ");
            DPF_ERR("   DDSCAPS_ALLOCONLOAD ");
            DPF_ERR("   DDSCAPS_WRITEONLY ");
            DPF_ERR("   DDSCAPS_VIDEOPORT");
            DPF_ERR("   DDSCAPS2_PERSISTENTCONTENTS ");
            DPF_ERR("   DDSCAPS2_CUBEMAP_* ");
            DPF_ERR("   DDSCAPS2_HINTDYNAMIC ");
            DPF_ERR("   DDSCAPS2_HINTSTATIC ");
            DPF_ERR("   DDSCAPS2_TEXTUREMANAGE ");
            DPF_ERR("   DDSCAPS2_D3DTEXTUREMANAGE ");
            DPF_ERR("   DDSCAPS2_OPAQUE ");
            DPF_ERR("   DDSCAPS2_HINTANTIALIASING");
            DPF_ERR("   DDSCAPS2_DONOTPERSIST");
            DPF_ERR("   DDSCAPS2_DEINTERLACE");
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Must be either a texture or a render target
         */
        if ( (caps & (DDSCAPS_3DDEVICE|DDSCAPS_TEXTURE)) == 0)
        {
            DPF_ERR("DDSCAPS2_CUBEMAP requires DDSCAPS_3DDEVICE and/or DDSCAPS_TEXTURE");
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Must be complex
         */
        if ( (caps & DDSCAPS_COMPLEX) == 0)
        {
            DPF_ERR("DDSCAPS2_CUBEMAP requires DDSCAPS_COMPLEX");
            return DDERR_DDSCAPSCOMPLEXREQUIRED;
        }

        /*
         * Must specify at least one face
         */
        if ( (lpCapsEx->dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES) == 0)
        {
            DPF_ERR("DDSCAPS2_CUBEMAP requires at least one face (i.e. at least one DDSCAPS2_CUBEMAP_POSITIVE/NEGATIVE");
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Device must support the caps. Note down here, we never see neither
         * memory type. We are guaranteed video or system
         */
        {
            DWORD dwCaps2 = 0;
            if ( caps & DDSCAPS_VIDEOMEMORY )
            {
                dwCaps2 = pdrv_int->lpLcl->lpGbl->ddsCapsMore.dwCaps2;
            }
            else if ( caps & DDSCAPS_SYSTEMMEMORY )
            {
                dwCaps2 = pdrv_int->lpLcl->lpGbl->ddsHELCapsMore.dwCaps2;
            }
            else
            {
                DDASSERT(!"Neither video nor system caps set on cubemap");
            }
            if ( ( dwCaps2 & DDSCAPS2_CUBEMAP ) == 0 )
            {
                DPF(0,"CubeMaps not supported in %s memory", (caps & DDSCAPS_VIDEOMEMORY) ? "video":"system");
                return DDERR_UNSUPPORTED;
            }
        }
    }
	// DX7Stereo
	if (lpCapsEx->dwCaps2 & DDSCAPS2_STEREOSURFACELEFT)
	{
		if ((caps & DDSCAPS_PRIMARYSURFACE)==0 ||
			(caps & DDSCAPS_FLIP)==0 ||
			(caps & DDSCAPS_COMPLEX)==0 ||
                        (caps & DDSCAPS_VIDEOMEMORY)==0)
		{
			DPF(0,"DDSCAPS2_STEREOSURFACELEFT only supported with: ");
                        DPF(0,"  DDSCAPS_PRIMARYSURFACE & DDSCAPS_FLIP & DDSCAPS_COMPLEX & DDSCAPS_VIDEOMEMORY");
			return DDERR_UNSUPPORTED;
		}
	}
    return DD_OK;
} /* checkCaps */

#ifdef SHAREDZ
/*
 * For this initial version of shared back and z support the shared back and
 * z-buffers can only be full screen. We don't allow a specification of size.
 */
#define CAPS_NOHEIGHT_REQUIRED ( DDSCAPS_PRIMARYSURFACE | DDSCAPS_EXECUTEBUFFER | DDSCAPS_SHAREDZBUFFER | DDSCAPS_SHAREDBACKBUFFER )
#define CAPS_NOWIDTH_REQUIRED  ( DDSCAPS_PRIMARYSURFACE | DDSCAPS_SHAREDZBUFFER | DDSCAPS_SHAREDBACKBUFFER )
#else
#define CAPS_NOHEIGHT_REQUIRED ( DDSCAPS_PRIMARYSURFACE | DDSCAPS_EXECUTEBUFFER )
#define CAPS_NOWIDTH_REQUIRED  ( DDSCAPS_PRIMARYSURFACE | DDSCAPS_EXECUTEBUFFER )
#endif

/*
 * checkSurfaceDesc
 *
 * make sure a provided surface description is OK
 */
HRESULT checkSurfaceDesc(
		LPDDSURFACEDESC2 lpsd,
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		DWORD FAR *psflags,
		BOOL emulation,
		BOOL real_sysmem,
		LPDDRAWI_DIRECTDRAW_INT pdrv_int )
{
    DWORD       sdflags;
    DWORD       pfflags;
    DWORD       caps;
    DDSCAPSEX   capsEx;
    HRESULT     ddrval;
    DWORD       bpp;
    BOOL        halonly;
    BOOL        helonly;
    int         wPower;
    int         hPower;

    if( emulation )
    {
	helonly = TRUE;
	halonly = FALSE;
    } else {
	helonly = FALSE;
	halonly = TRUE;
    }


    /*
     * we assume caps always - DDSD_CAPS is default
     */
    sdflags = lpsd->dwFlags;
    caps = lpsd->ddsCaps.dwCaps;
    capsEx = lpsd->ddsCaps.ddsCapsEx;

    /*
     * check complex
     */
    if( !(caps & DDSCAPS_COMPLEX) )
    {
	if( sdflags & DDSD_BACKBUFFERCOUNT )
	{
	    DPF_ERR( "backbuff count on non-complex surface" );
	    return DDERR_INVALIDCAPS;
	}
	if( sdflags & DDSD_MIPMAPCOUNT )
	{
	    DPF_ERR( "mip-map count on non-complex surface" );
	    return DDERR_INVALIDCAPS;
	}
    }
    else
    {
	if( ( sdflags & DDSD_BACKBUFFERCOUNT ) && ( sdflags & DDSD_MIPMAPCOUNT ) )
	{
	    DPF_ERR( "Currently can't specify both a back buffer and mip-map count" );
	    return DDERR_INVALIDPARAMS;
	}

    }

    /*
     * check flip
     */
    if( caps & DDSCAPS_FLIP )
    {
	if( !(caps & DDSCAPS_COMPLEX) )
	{
	    DPF_ERR( "flip specified without complex" );
	    return DDERR_INVALIDCAPS;
	}
	if( !(sdflags & DDSD_BACKBUFFERCOUNT) || (lpsd->dwBackBufferCount == 0) )
	{
	    DPF_ERR( "flip specified without any backbuffers" );
	    return DDERR_INVALIDCAPS;
	}
	/*
	 * Currently we don't allow the creating of flippable mip-map
	 * chains with a single call to CreateSurface(). They must be
	 * built manually. This will be implmented but is not in place
	 * as yet. Hence, for now we fail the attempt with a
	 * DDERR_UNSUPPORTED.
	 */
	if( sdflags & DDSD_MIPMAPCOUNT )
	{
	    DPF_ERR( "Creating flippable mip-map chains with a single call is not yet implemented" );
	    return DDERR_UNSUPPORTED;
	}
    }

    /*
     * Check hardware deinterlacing
     */
    if( capsEx.dwCaps2 & DDSCAPS2_RESERVED4 )
    {
	if( !( caps & DDSCAPS_VIDEOPORT ) || !( caps & DDSCAPS_OVERLAY ) )
	{
	    DPF_ERR( "DDSCAPS2_RESERVED4 specified w/o video port or overlay" );
	    return DDERR_INVALIDCAPS;
	}
	if( ( pdrv->lpDDVideoPortCaps == NULL ) ||
	    !( pdrv->lpDDVideoPortCaps->dwCaps & DDVPCAPS_HARDWAREDEINTERLACE ) )
	{
	    DPF_ERR( "No hardware support for DDSCAPS_RESERVED4" );
	    return DDERR_INVALIDCAPS;
	}
	if( caps & DDSCAPS_COMPLEX )
	{
	    DPF_ERR( "DDSCAPS2_RESERVERD4 not valid w/ a complex surface" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check various caps combinations
     */
    ddrval = checkCaps( caps, pdrv_int , &capsEx);
    if( ddrval != DD_OK )
    {
	return ddrval;
    }

    /*
     * check alpha
     */
    if( (caps & DDSCAPS_ALPHA) )
    {
	#pragma message( REMIND( "Alpha not supported in Rev 1" ))
	DPF_ERR( "Alpha not supported this release" );
	return DDERR_INVALIDPARAMS;
	#ifdef USE_ALPHA
	if( !(sdflags & DDSD_ALPHABITDEPTH) )
	{
	    DPF_ERR( "AlphaBitDepth required in SurfaceDesc" );
	    return DDERR_INVALIDPARAMS;
	}
	if( (lpsd->dwAlphaBitDepth > 8) ||
		GetBytesFromPixels( 1, lpsd->dwAlphaBitDepth ) == 0 )
	{
	    DPF_ERR( "Invalid AlphaBitDepth specified in SurfaceDesc" );
	    return DDERR_INVALIDPARAMS;
	}
	#endif
    }
    else if( sdflags & DDSD_ALPHABITDEPTH )
    {
	DPF_ERR( "AlphaBitDepth only valid for alpha surfaces" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * check z buffer
     */
    if( (caps & DDSCAPS_ZBUFFER) )
    {
       DDSURFACEDESC *pOldSD=(DDSURFACEDESC *)lpsd;
       DWORD zbitdepth;

       if(lpsd->dwSize==sizeof(DDSURFACEDESC)) {

	   // allow old way to request Z, using DDSD_ZBUFFERBITDEPTH field
	   // also allow z to be requested through pixfmt

	   if(sdflags & DDSD_PIXELFORMAT) {

	      if(lpsd->ddpfPixelFormat.dwSize!=sizeof(DDPIXELFORMAT)) {
		   DPF_ERR("Hey, you didn't set DDSURFACEDESC.ddpfPixelFormat.dwSize to sizeof(DDPIXELFORMAT)! Do that.");
		   return DDERR_INVALIDPARAMS;
	      }

	      if(pOldSD->ddpfPixelFormat.dwFlags & DDPF_STENCILBUFFER) {
		  DPF_ERR("Stencil ZBuffers can only be created using a SURFACEDESC2 passed to IDirectDraw4's CreateSurface");
		  return DDERR_INVALIDPARAMS;
	      }

	      if(pOldSD->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER) {
	       // pixfmt overrides ddsd zbufferbitdepth.
	       // copy zbitdepth back to SD field because old drivers require it there
	       pOldSD->dwZBufferBitDepth=pOldSD->ddpfPixelFormat.dwZBufferBitDepth;
	       pOldSD->dwFlags|=DDSD_ZBUFFERBITDEPTH;
	       sdflags|=DDSD_ZBUFFERBITDEPTH;

	      } else {
		  DPF_ERR("If DDSD_PIXELFORMAT specified, DDPF_ZBUFFER flag must be too");
		  return DDERR_INVALIDPARAMS;
	      }
	   } else if(sdflags & DDSD_ZBUFFERBITDEPTH) {
		if(!(caps & DDSCAPS_COMPLEX)) {
		    // setup valid zpixfmt

		    memset(&pOldSD->ddpfPixelFormat,0,sizeof(DDPIXELFORMAT));

		    pOldSD->ddpfPixelFormat.dwSize=sizeof(DDPIXELFORMAT);
		    pOldSD->ddpfPixelFormat.dwZBufferBitDepth=pOldSD->dwZBufferBitDepth;
		    pOldSD->ddpfPixelFormat.dwFlags|=DDPF_ZBUFFER;
		    pOldSD->dwFlags|=DDSD_PIXELFORMAT;
		    sdflags|=DDSD_PIXELFORMAT;
		}
		// for complex surfaces, cannot write zbuffer pixfmt because that would overwrite
		// the main surface pixfmt

	      } else {
		  DPF_ERR("Neither DDSD_ZBUFFERBITDEPTH nor a ZBuffer ddpfPixelFormat was specified");
		  return DDERR_INVALIDPARAMS;
	      }

	       // fill in ZBitMask for them, so future pixfmt will be completely valid
	       if(!(caps & DDSCAPS_COMPLEX)) {
		   if(pOldSD->ddpfPixelFormat.dwZBufferBitDepth==32)
		     pOldSD->ddpfPixelFormat.dwZBitMask = 0xffffffff;
		   else pOldSD->ddpfPixelFormat.dwZBitMask = (1<<pOldSD->ddpfPixelFormat.dwZBufferBitDepth)-1;
	       }
	   } else {  // SURFACEDESC2 was used (IDDraw4:CreateSurface)

	       if(caps & DDSCAPS_COMPLEX) {
		   DPF_ERR( "As of IDirectDraw4, Complex Surface Creations can no longer contain ZBuffers, must create ZBuffer separately and attach");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(sdflags & DDSD_ZBUFFERBITDEPTH) {
		   DPF_ERR("DDSD_ZBUFFERBITDEPTH flag obsolete for DDSURFACEDESC2, specify ZBuffer format in ddpfPixelFormat instead");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(!(sdflags & DDSD_PIXELFORMAT)) {
		   DPF_ERR("DDSD_PIXELFORMAT flag not set. For DDSURFACEDESC2, ZBuffer format must be specified in ddpfPixelFormat");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(lpsd->ddpfPixelFormat.dwSize!=sizeof(DDPIXELFORMAT)) {
		   DPF_ERR("Hey, you didn't set DDSURFACEDESC2.ddpfPixelFormat.dwSize to sizeof(DDPIXELFORMAT)! Do that.");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(!(lpsd->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER)) {
		   DPF_ERR("DDPF_ZBUFFER flag must be set in pixfmt flags");
		   return DDERR_INVALIDPARAMS;
	       }

	       // not requiring this for legacy DDSURFACEDESC creations
	       if(lpsd->ddpfPixelFormat.dwZBitMask==0x0) {
		   DPF_ERR("Error: dwZBitMask must be non-0 (just copy it from the EnumZBufferFormats pixfmt)");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(lpsd->ddpfPixelFormat.dwFlags & DDPF_STENCILBUFFER) {
		 // probably can't trust old drivers' CanCreateSurface to fail stencil request,
		 // so just fail it ourselves right here.

		 // if driver doesn't support EnumZBufferFormats, it can't support stencil.
		 // this is indicated by the 0 in pdrv->dwNumZPixelFormats
		 if((!emulation) && !DRIVER_SUPPORTS_DX6_ZBUFFERS(pdrv)) {
		     DPF_ERR("Driver doesn't support Stencil ZBuffers");
		     return DDERR_UNSUPPORTED;
		 }
	       } else {
	       // NOTE: Old drivers require the DDSURFACEDESC.dwZBufferBitDepth to be set for
	       // CanCreateSurface and CreateSurface.  So if user asks for z-only surface, go
	       // ahead and set this field so creating z-only zbuffers with IDDraw4 will work with
	       // old drivers.  I'm leaving DDSD_ZBUFFERBITDEPTH flag unset because
	       // I dont want to confuse driver writers into still using that field and every driver
	       // I've looked at keys off of DDSCAPS_ZBUFFER (which is set) and not DDSD_ZBUFFERBITDEPTH.
	       // Any driver that allows stenciling is a DX6 driver and should ignore the SD zbufferbitdepth,
	       // so no need to do this copy for them

		   pOldSD->dwZBufferBitDepth=lpsd->ddpfPixelFormat.dwZBufferBitDepth;
	       }
	   }

	   if(caps & DDSCAPS_COMPLEX)
	       zbitdepth=((DDSURFACEDESC*)lpsd)->dwZBufferBitDepth;
	    else zbitdepth=lpsd->ddpfPixelFormat.dwZBufferBitDepth;

	   if(zbitdepth<8) {
	       DPF_ERR("Invalid dwZBufferBitDepth, must be >=8 bits");
	       return DDERR_INVALIDPARAMS;
	   }

	   // side note for stencils:  If stencils are present, dwZBufferBitDepth represents
	   // the total bit depth including both z and stencil bits, so z-only bits are
	   // dwZBufferBitDepth-dwStencilBufferBitDepth.  This was done because we're afraid
	   // ddraw code makes too many assumptions that the total bitdepth of a surface is always
	   // found in the pixfmt (dwRGBBitCount/dwZBufferBitDepth) union when it does pixel computations.

	   if(lpsd->ddpfPixelFormat.dwFlags & DDPF_STENCILBUFFER) {
	       if(lpsd->ddpfPixelFormat.dwStencilBitDepth==0) {
		   DPF_ERR("Invalid SurfaceDesc StencilBufferBitDepth, must be non-0");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(lpsd->ddpfPixelFormat.dwStencilBitMask==0x0) {
		   DPF_ERR("Error: dwStencilBitMask must be non-0 (just copy it from the EnumZBufferFormats pixfmt)");
		   return DDERR_INVALIDPARAMS;
	       }
	   }
    } else if((sdflags & DDSD_ZBUFFERBITDEPTH) ||
	      ((sdflags & DDSD_PIXELFORMAT) && ((lpsd->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER) ||
						(lpsd->ddpfPixelFormat.dwFlags & DDPF_STENCILBUFFER)))) {
	    DPF_ERR("DDSD_ZBUFFERBITDEPTH, DDPF_ZBUFFER, and DDPF_STENCILBUFFER flags only valid with DDSCAPS_ZBUFFER set");
	    return DDERR_INVALIDPARAMS;
	}

    /*
     * Validate height/width
     */
    if( sdflags & DDSD_HEIGHT )
    {
	if( (caps & DDSCAPS_PRIMARYSURFACE) )
	{
	    DPF_ERR( "Height can't be specified for primary surface" );
	    return DDERR_INVALIDPARAMS;
	}
#ifdef SHAREDZ
	if( caps & ( DDSCAPS_SHAREDZBUFFER | DDSCAPS_SHAREDBACKBUFFER ) )
	{
	    DPF_ERR( "Height can't be specified for shared back or z-buffers" );
	    return DDERR_INVALIDPARAMS;
	}
#endif
	if( lpsd->dwHeight < 1 )
	{
	    DPF_ERR( "Invalid height specified" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    else
    {
	if( !(caps & CAPS_NOHEIGHT_REQUIRED) )
	{
	    DPF_ERR( "Height must be specified for surface" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    if( sdflags & DDSD_WIDTH )
    {
	DWORD   maxwidth;

	if( (caps & DDSCAPS_PRIMARYSURFACE) )
	{
	    DPF_ERR( "Width can't be specified for primary surface" );
	    return DDERR_INVALIDPARAMS;
	}
#ifdef SHAREDZ
	if( caps & ( DDSCAPS_SHAREDZBUFFER | DDSCAPS_SHAREDBACKBUFFER ) )
	{
	    DPF_ERR( "Width can't be specified for shared back or z-buffers" );
	    return DDERR_INVALIDPARAMS;
	}
#endif
	if( lpsd->dwWidth < 1 )
	{
	    DPF_ERR( "Invalid width specified" );
	    return DDERR_INVALIDPARAMS;
	}

	if( ( !real_sysmem ) && !( caps & DDSCAPS_EXECUTEBUFFER ) &&
	    !( caps & DDSCAPS_VIDEOPORT ) )
	{
	    if ( (dwRegFlags & DDRAW_REGFLAGS_DISABLEWIDESURF) ||
		( !(pdrv->ddCaps.dwCaps2 & DDCAPS2_WIDESURFACES)) )
	    {
		maxwidth = getPixelsFromBytes( pdrv->vmiData.lDisplayPitch,
					    pdrv->vmiData.ddpfDisplay.dwRGBBitCount );

		if( lpsd->dwWidth > maxwidth )
		{
		    DPF( 0, "Width too big: %ld reqested, max is %ld", lpsd->dwWidth, maxwidth );
		    return DDERR_INVALIDPARAMS;
		}
	    }
	}
    }
    else
    {
	if( !(caps & CAPS_NOWIDTH_REQUIRED) )
	{
	    DPF_ERR( "Width must be specified for surface" );
	    return DDERR_INVALIDPARAMS;
	}
    }

    /*
     * Extra validation for mip-map width and height (must be a whole power of 2)
     * and number of levels.
     */
    if( caps & DDSCAPS_MIPMAP )
    {
	if( sdflags & DDSD_MIPMAPCOUNT )
	{
	    if( lpsd->dwMipMapCount == 0 )
	    {
		DPF_ERR( "Invalid number of mip-map levels (0) specified" );
		return DDERR_INVALIDPARAMS;
	    }
	}

	if( sdflags & DDSD_HEIGHT )
	{
	    if( !isPowerOf2( lpsd->dwHeight, &hPower ) )
	    {
		DPF_ERR( "Invalid height: height of a mip-map must be whole power of 2" );
		return DDERR_INVALIDPARAMS;
	    }
	}
	if( sdflags & DDSD_WIDTH )
	{
	    if( !isPowerOf2( lpsd->dwWidth, &wPower ) )
	    {
		DPF_ERR( "Invalid width: width of a mip-map must be whole power of 2" );
		return DDERR_INVALIDPARAMS;
	    }
	}

        if (sdflags & (DDSD_WIDTH|DDSD_HEIGHT) )
        {
            /*
             * For deep mipmaps, we need to ensure that the supplied mipmapcount is no larger
             * than the largest of the supplied dimensions. This restriction is slightly weaker
             * than the DX2->DX6 restriction that the mipmapcount is no larger than either dimension.
             */
            int power = max ( hPower , wPower );
	    if( sdflags & DDSD_MIPMAPCOUNT )
	    {
		if (lpsd->dwMipMapCount > (DWORD) ( power + 1 ))
		{
		    DPF( 0, "Invalid number of mip-map levels (%ld) specified", lpsd->dwMipMapCount );
		    return DDERR_INVALIDPARAMS;
		}
	    }
        }
    }

    /*
     * validate pixel format
     */
    if( sdflags & DDSD_PIXELFORMAT )
    {
	if( caps & DDSCAPS_PRIMARYSURFACE )
	{
	    DPF_ERR( "Pixel format cannot be specified for primary surface" );
	    return DDERR_INVALIDPARAMS;
	}
	if(caps & DDSCAPS_ALPHA)
	{
	    DPF_ERR( "Can't specify alpha cap with pixel format" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
	pfflags = lpsd->ddpfPixelFormat.dwFlags;

	if( pfflags & UNDERSTOOD_PF )
	{
	    // Get the number of bits per pixel (dwRGBBitCount is in a union
	    // of fields that all mean the same thing.)
	    bpp = lpsd->ddpfPixelFormat.dwRGBBitCount;
	    if( GetBytesFromPixels( 1, bpp ) == 0 )
	    {
		DPF_ERR( "Invalid BPP specified in pixel format" );
		return DDERR_INVALIDPIXELFORMAT;
	    }
	    if( pfflags & DDPF_RGB )
	    {
		if( pfflags & (DDPF_YUV) )
		{
		    DPF_ERR( "Invalid flags specified in pixel format" );
		    return DDERR_INVALIDPIXELFORMAT;
		}
	    }
            if ( pfflags & DDPF_ALPHA )
            {
                //Pretty much everything else must be off
                if ( pfflags & (DDPF_ALPHAPIXELS |
                                DDPF_FOURCC |
                                DDPF_PALETTEINDEXED1 |
                                DDPF_PALETTEINDEXED2 |
                                DDPF_PALETTEINDEXED4 |
                                DDPF_PALETTEINDEXED8 |
                                DDPF_RGB |
                                DDPF_YUV |
                                DDPF_ZBUFFER |
                                DDPF_ZPIXELS |
                                DDPF_STENCILBUFFER |
                                DDPF_LUMINANCE) )
                {
                    DPF_ERR("DDPF_ALPHA is valid only by itself");
                    return DDERR_INVALIDPARAMS;
                }
            }
	    if (pfflags & DDPF_LUMINANCE )
	    {
		if ( pfflags & ( ~ ( DDPF_LUMINANCE | DDPF_ALPHAPIXELS ) ) )
		{
		    DPF_ERR( "DDPF_LUMINANCE set in pixel format, compatible only with DDPF_ALPHAPIXELS" );
		    return DDERR_INVALIDPIXELFORMAT;
		}

		// we don't trust pre-dx6 drivers' CanCreateSurface callback to correctly reject
		// DX6 luminance/bump DDPIXELFORMATs, so reject them here
		if(!IS_DX6_D3DDRIVER(pdrv) && !emulation) {
		    DPF_ERR("Error: Driver doesn't support Luminance surfaces");
		    return DDERR_UNSUPPORTED;
		}

	    }
	    if (pfflags & DDPF_BUMPDUDV )
	    {
		if (pfflags & ( ~ (DDPF_BUMPDUDV | DDPF_BUMPLUMINANCE)))
		{
		    DPF_ERR( "DDPF_BUMPDUDV set in pixel format, compatible only with DDPF_BUMPLUMINANCE");
		    return DDERR_INVALIDPIXELFORMAT;
		}

		if(!IS_DX6_D3DDRIVER(pdrv) && !emulation) {
		    DPF_ERR("Error: Driver doesn't support Bump Map surfaces");
		    return DDERR_UNSUPPORTED;
		}

	    }
	    if( pfflags & DDPF_PALETTEINDEXED8 )
	    {
		if( pfflags & (DDPF_PALETTEINDEXED1 |
			       DDPF_PALETTEINDEXED2 |
			       DDPF_PALETTEINDEXED4 |
			       DDPF_PALETTEINDEXEDTO8 ) )
		{
		    DPF_ERR( "Invalid flags specified in pixel format" );
		    return DDERR_INVALIDPIXELFORMAT;
		}

		/*
		 * ensure that we have zero for masks
		 */
		lpsd->ddpfPixelFormat.dwRBitMask = 0;
		lpsd->ddpfPixelFormat.dwGBitMask = 0;
		lpsd->ddpfPixelFormat.dwBBitMask = 0;
		if( !(pfflags & (DDPF_ZPIXELS|DDPF_ALPHAPIXELS) ) )
		    lpsd->ddpfPixelFormat.dwRGBZBitMask = 0;
	    }
	    lpsd->ddpfPixelFormat.dwFourCC = 0;

	    // Validate ZPixels
	    if( pfflags & DDPF_ZPIXELS )
	    {
		if( lpsd->ddpfPixelFormat.dwRGBZBitMask == 0 )
		{
		    DPF_ERR( "DDPF_ZPIXELS must have a dwRGBZBitMask" );
		    return DDERR_INVALIDPIXELFORMAT;
		}
		if( pfflags & (DDPF_ALPHAPIXELS | DDPF_ALPHA | DDPF_ZBUFFER) )
		{
		    DPF_ERR( "DDPF_ZPIXELS not compatible with ALPHAPIXELS or ALPHA or ZBUFFER" );
		    return DDERR_INVALIDPIXELFORMAT;
		}
	    }
	}
	else if (pfflags & DDPF_FOURCC)
	{
	    DWORD width, height;

	    /*
	     * We require the width and height of DirectX compressed-texture
	     * surfaces (FOURCC = DXT*) to be multiples of four.
	     */
	    switch ((int)lpsd->ddpfPixelFormat.dwFourCC)
	    {
	    case MAKEFOURCC('D','X','T','1'):
	    case MAKEFOURCC('D','X','T','2'):
	    case MAKEFOURCC('D','X','T','3'):
	    case MAKEFOURCC('D','X','T','4'):
	    case MAKEFOURCC('D','X','T','5'):
    		width  = (sdflags & DDSD_WIDTH)  ? lpsd->dwWidth  : pdrv->vmiData.dwDisplayWidth;
    		height = (sdflags & DDSD_HEIGHT) ? lpsd->dwHeight : pdrv->vmiData.dwDisplayHeight;
		if ((height | width) & 3)
		{
    		    DPF_ERR("Width, height of FOURCC=DXT* surface must be multiples of 4");
		    return DDERR_INVALIDPARAMS;
		}
		break;
	    default:
		break;
	    }
	}
    }

    // ACKACK: should caps be filled in in surface desc as well as sdflags?

    /*
     * validate dest overlay color key
     */
    if( sdflags & DDSD_CKDESTOVERLAY )
    {
	ddrval = CheckColorKey( DDCKEY_DESTOVERLAY, pdrv,
					&lpsd->ddckCKDestOverlay, psflags,
					halonly, helonly );
	if( ddrval != DD_OK )
	{
	    return ddrval;
	}
    }

    /*
     * validate dest blt color key
     */
    if( sdflags & DDSD_CKDESTBLT )
    {
	ddrval = CheckColorKey( DDCKEY_DESTBLT, pdrv,
					&lpsd->ddckCKDestBlt, psflags,
					halonly, helonly );
	if( ddrval != DD_OK )
	{
	    return ddrval;
	}
    }

    /*
     * validate src overlay color key
     */
    if( sdflags & DDSD_CKSRCOVERLAY )
    {
	ddrval = CheckColorKey( DDCKEY_SRCOVERLAY, pdrv,
					&lpsd->ddckCKSrcOverlay, psflags,
					halonly, helonly );
	if( ddrval != DD_OK )
	{
	    return ddrval;
	}
    }

    /*
     * validate src blt color key
     */
    if( sdflags & DDSD_CKSRCBLT )
    {
	ddrval = CheckColorKey( DDCKEY_SRCBLT, pdrv,
					&lpsd->ddckCKSrcBlt, psflags,
					halonly, helonly );
	if( ddrval != DD_OK )
	{
	    return ddrval;
	}
    }

    /*
     * cube maps
     */
    if ( capsEx.dwCaps2 & DDSCAPS2_CUBEMAP )
    {
        if (LOWERTHANDDRAW7(pdrv_int))
        {
            DPF_ERR("DDSCAPS2_CUBEMAP is not allowed for lower than IDirectDraw7 interfaces.");
            return DDERR_INVALIDPARAMS;
        }

        if ( (lpsd->dwFlags & (DDSD_WIDTH|DDSD_HEIGHT)) == 0)
        {
            DPF_ERR("dwWidth and dwHeight must be specified for a DDSCAPS2_CUBEMAP surface");
            return DDERR_INVALIDPARAMS;
        }
        if (lpsd->dwHeight != lpsd->dwWidth)
        {
            DPF_ERR("dwWidth and dwHeight must be equal for a DDSCAPS2_CUBEMAP surface");
            return DDERR_INVALIDPARAMS;
        }
        if (! isPowerOf2(lpsd->dwHeight,NULL) )
        {
            DPF_ERR("dwWidth and dwHeight must be a whole power of two");
            return DDERR_INVALIDPARAMS;
        }
        if (lpsd->dwFlags & DDSD_BACKBUFFERCOUNT)
        {
            DPF_ERR("Cubemaps cannot have backbuffers!");
            return DDERR_INVALIDPARAMS;
        }
    }

    return DD_OK;

} /* checkSurfaceDesc */



/*
 * ComputePitch
 *
 * compute the pitch for a given width
 */
DWORD ComputePitch(
		LPDDRAWI_DIRECTDRAW_GBL this,
		DWORD caps,
		DWORD width,
		UINT bpp )
{
    DWORD       vm_align;
    DWORD       vm_pitch;

    /*
     * adjust area for bpp
     */
    vm_pitch = GetBytesFromPixels( width, bpp );
    if( vm_pitch == 0 )
    {
	return vm_pitch;
    }

    /*
     * Increase the pitch of the surface so that it is a
     * multiple of the alignment requirement.  This
     * guarantees each scanline will start properly aligned.
     * The alignment is no longer required to be a power of
     * two but it must be divisible by 4 because of the
     * BLOCK_BOUNDARY requirement in the heap management
     * code.
     * The alignments are all verified to be non-zero during
     * driver initialization except for dwAlphaAlign.
     */

    /*
     * system memory?
     */
    if( caps & DDSCAPS_SYSTEMMEMORY )
    {
	vm_align = sizeof( DWORD);
	vm_pitch = alignPitch( vm_pitch, vm_align );
	return vm_pitch;
    }

    /*
     * If the driver exposed extended alignment, then we will simply set
     * pitch=width*bpp/8 and allow that to filter down to the heap alloc
     * routines which know how to align surfaces
     * Note this implies that extended alignment for any heap means
     * ddraw will IGNORE the legacy alignment values for all heaps.
     */
    if ( this->dwFlags & DDRAWI_EXTENDEDALIGNMENT )
    {
	return vm_pitch;
    }

    /*
     * overlay memory
     */
    if( caps & DDSCAPS_OVERLAY )
    {
	vm_align = this->vmiData.dwOverlayAlign;
	vm_pitch = alignPitch( vm_pitch, vm_align );
    /*
     * texture memory
     */
    }
    else if( caps & DDSCAPS_TEXTURE )
    {
	vm_align = this->vmiData.dwTextureAlign;
	vm_pitch = alignPitch( vm_pitch, vm_align );
    /*
     * z buffer memory
     */
    }
    else if( caps & DDSCAPS_ZBUFFER )
    {
	vm_align = this->vmiData.dwZBufferAlign;
	vm_pitch = alignPitch( vm_pitch, vm_align );
    /*
     * alpha memory
     */
    }
    else if( caps & DDSCAPS_ALPHA )
    {
	vm_align = this->vmiData.dwAlphaAlign;
	vm_pitch = alignPitch( vm_pitch, vm_align );
    /*
     * regular video memory
     */
    }
    else
    {
	vm_align = this->vmiData.dwOffscreenAlign;
	vm_pitch = alignPitch( vm_pitch, vm_align );
    }
    return vm_pitch;

} /* ComputePitch */

#define FIX_SLIST_CNT   16      // number of surfaces before malloc reqd

/*
 * initMipMapDim
 *
 * If we have a mip-map description then we can fill in some
 * fields for the caller. This function needs to be invoked
 * before the checkSurfaceDesc is called as it may put in
 * place some fields checked by that function.
 *
 * NOTE: This function may modify the surface description.
 */
static HRESULT initMipMapDim( LPDDSURFACEDESC2 lpsd, BOOL bDeepMipmaps )
{
    DWORD sdflags;
    DWORD caps;
    int   heightPower;
    int   widthPower;

    DDASSERT( lpsd != NULL );
    DDASSERT( lpsd->ddsCaps.dwCaps & DDSCAPS_MIPMAP );

    sdflags = lpsd->dwFlags;
    caps    = lpsd->ddsCaps.dwCaps;

    /*
     * This stuff is only relevant for complex, non-flipable
     * mip-maps.
     */
    if( ( caps & DDSCAPS_COMPLEX ) && !( caps & DDSCAPS_FLIP ) )
    {
	if( ( ( sdflags & DDSD_HEIGHT ) && ( sdflags & DDSD_WIDTH ) ) &&
	   !( sdflags & DDSD_MIPMAPCOUNT ) )
	{
	    /*
	     * Width and height but no number of levels so compute the
	     * maximum number of mip-map levels supported by the given
	     * width and height.
	     */
	    if( !isPowerOf2( lpsd->dwHeight, &heightPower ) )
	    {
		DPF_ERR( "Invalid height: height of a mip-map must be whole power of 2" );
		return DDERR_INVALIDPARAMS;
	    }
	    if( !isPowerOf2( lpsd->dwWidth, &widthPower ) )
	    {
		DPF_ERR( "Invalid width:  width of a mip-map must be whole powers of 2" );
		return DDERR_INVALIDPARAMS;
	    }

            /*
             * Deep mipmaps are those that clamp their smaller dimension at 1 as
             * the larger dimension ramps down to 1
             */
            if ( bDeepMipmaps )
	        lpsd->dwMipMapCount = (DWORD)(max(heightPower, widthPower) + 1);
            else
	        lpsd->dwMipMapCount = (DWORD)(min(heightPower, widthPower) + 1);
	    lpsd->dwFlags |= DDSD_MIPMAPCOUNT;
	}
	else if( ( sdflags & DDSD_MIPMAPCOUNT ) &&
		!( ( sdflags & DDSD_WIDTH ) || ( sdflags & DDSD_HEIGHT ) ) )
	{
	    /*
	     * We have been given a mip-map count but no width
	     * and height so compute the width and height assuming
	     * the smallest map is 1x1.
	     * NOTE: We don't help out if they supply a width or height but
	     * not both.
	     */
	    if( lpsd->dwMipMapCount == 0 )
	    {
		DPF_ERR( "Invalid number of mip-map levels (0) specified" );
		return DDERR_INVALIDPARAMS;
	    }
	    else
	    {
		lpsd->dwWidth = lpsd->dwHeight = 1 << (lpsd->dwMipMapCount - 1);
		lpsd->dwFlags |= (DDSD_HEIGHT | DDSD_WIDTH);
	    }
	}
    }

    return DD_OK;
}


HRESULT createsurfaceEx( LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl )
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDDLcl=lpSurfLcl->lpSurfMore->lpDD_lcl;
    if (
        (0 != lpSurfLcl->lpSurfMore->dwSurfaceHandle)
        && (NULL != lpDDLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx) 
       )
   {
        DDHAL_CREATESURFACEEXDATA   csdex;
        DWORD   rc;
        csdex.ddRVal = DDERR_GENERIC;
        csdex.dwFlags = 0;
        csdex.lpDDLcl = lpDDLcl;
        csdex.lpDDSLcl = lpSurfLcl;
        rc = lpDDLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx(&csdex);
	if( DDHAL_DRIVER_HANDLED == rc )
        {
            if( ( DD_OK != csdex.ddRVal ) &&
                !( lpSurfLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
            {
                DPF_ERR("Driver failed CreateSurfaceEx callback in createSurface");
                return csdex.ddRVal;
            }
        }
        else
        {
            DPF_ERR("Driver failed to handle CreateSurfaceEx callback in createSurface");
            return DDERR_GENERIC;
        }
    } 
    return  DD_OK;   
}
#ifdef WINNT
LPDDRAWI_DDRAWSURFACE_LCL GetTopLevel(LPDDRAWI_DDRAWSURFACE_LCL lpLcl);
BOOL WINAPI CompleteCreateSysmemSurface( LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl )
{
    DDASSERT(lpSurfLcl 
        && (DDSCAPS_SYSTEMMEMORY & lpSurfLcl->ddsCaps.dwCaps) 
        && (0 == lpSurfLcl->hDDSurface));
 
    if (lpSurfLcl->lpSurfMore->lpDD_lcl->lpGbl->hDD)
    {
        BOOL    bRet;
        int     scnt;
        int     nsurf;
        LPDDRAWI_DDRAWSURFACE_LCL   *slist;
        lpSurfLcl = GetTopLevel(lpSurfLcl);
        slist=lpSurfLcl->lpSurfMore->slist;
        if (slist)
        {
            DWORD   caps=lpSurfLcl->ddsCaps.dwCaps;
            DWORD   caps2=lpSurfLcl->lpSurfMore->ddsCapsEx.dwCaps2;
            nsurf=lpSurfLcl->lpSurfMore->cSurfaces;
            DDASSERT(nsurf);
            if (DDSCAPS2_CUBEMAP & caps2)
            {
                int dwCubeMapFaceCount;
                int surf_from;
                int perfacecnt;
                DDASSERT(lpSurfLcl->lpSurfMore->pCreatedDDSurfaceDesc2);
                // to calculate dwCubeMapFaceCount we must use this caps2
                caps2 = lpSurfLcl->lpSurfMore->pCreatedDDSurfaceDesc2->ddsCaps.dwCaps2;
                dwCubeMapFaceCount =
                    (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ? 1 : 0 )+
                    (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ? 1 : 0 )+
                    (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ? 1 : 0 )+
                    (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ? 1 : 0 )+
                    (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ? 1 : 0 )+
                    (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) ? 1 : 0 );
                DDASSERT(dwCubeMapFaceCount);
                DDASSERT(nsurf >= dwCubeMapFaceCount);
                DDASSERT(0 == (nsurf % dwCubeMapFaceCount));
                perfacecnt = nsurf/ dwCubeMapFaceCount;
                DDASSERT(perfacecnt == 1 || ((perfacecnt>1) && (caps & DDSCAPS_MIPMAP)) ); 

                /*
                 * Every (perfacecnt)th surface needs to be linked to the very first
                 * Otherwise, it's a mip level that needs linking to its parent
                 */
                for (scnt = 1; scnt < nsurf; scnt++)
                {
                    if ( (scnt % perfacecnt) == 0 )
                        surf_from = 0;
                    else
                        surf_from = scnt - 1;
                    if ( !DdAttachSurface(slist[surf_from], slist[scnt]) )
                        DPF(0,"DdAttachSurface CUBEMAP %d from %d failed!",surf_from,scnt);
                }            
            }
            else if (DDSCAPS_MIPMAP & caps)
            {
                for (scnt = 1; scnt < nsurf; scnt++)
                {
                    if ( !DdAttachSurface(slist[scnt-1], slist[scnt]) )
                        DPF(0,"DdAttachSurface MIPMAP %d failed!",scnt);
                }            
            }
        }
        else
        {
            slist=&lpSurfLcl;
            nsurf = 1;
        }
        for (scnt = 0; scnt < nsurf; scnt++)
        {
            bRet = DdCreateSurfaceObject(slist[scnt], FALSE);
            if (!bRet)
            {
                // cleanup is needed as hDDSurface could be created partially
                // by DdAttachSurface, 
                for (scnt = 0; scnt < nsurf; scnt++)
                {
                    if (slist[scnt]->hDDSurface)
                    {
                        if (!DdDeleteSurfaceObject(slist[scnt]))
                            DPF(5,"DdDeleteSurfaceObject failed");
                    }
                }
                break;
            }
        }            
        // we only allow system surface being created w/o succeeding Kernel side
        if (bRet)
        {
            DDASSERT(lpSurfLcl->hDDSurface);
            createsurfaceEx(lpSurfLcl);
        }
        else
        {
            DPF_ERR("Fail to complete SYSTEM surface w/ Kernel Object");
            return FALSE;
        }
    }
    return  TRUE;
}
#endif
/*
 * createSurface
 *
 * Create a surface, without linking it into the chain.
 * We could potentially create multiple surfaces here, if we get a
 * request to create a page flipped surface and/or attached alpha or
 * z buffer surfaces
 */
static HRESULT createSurface( LPDDRAWI_DIRECTDRAW_LCL this_lcl,
			      LPDDSURFACEDESC2 lpDDSurfaceDesc,
			      CSINFO *pcsinfo,
			      BOOL emulation,
			      BOOL real_sysmem,
			      BOOL probe_driver,
			      LPDDRAWI_DIRECTDRAW_INT this_int,
                              LPDDSURFACEINFO pSysMemInfo,
                              DWORD DX8Flags)
{

    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf;
    DWORD                       caps;
    int                         surf_size;
    int                         surf_size_lcl;
    int                         surf_size_lcl_more;
    HRESULT                     ddrval;
    int                         bbcnt;
    int                         scnt;
    int                         nsurf;
    BOOL                        do_abuffer;
    DWORD                       abuff_depth;
    BOOL                        do_zbuffer;
    BOOL                        firstbbuff;
    LPDDRAWI_DDRAWSURFACE_INT   *slist_int;
    LPDDRAWI_DDRAWSURFACE_LCL   *slist_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   *slist;
    int                         bbuffoff;
    int                         zbuffoff;
    DWORD                       rc;
    DDPIXELFORMAT               ddpf;
    LPDDPIXELFORMAT             pddpf;
    BOOL                        is_primary_chain;
    UINT                        bpp = 0;
    LONG                        vm_pitch;
    BOOL                        is_flip;
    BOOL                        is_diff;
    BOOL                        is_mipmap;
    DDHAL_CREATESURFACEDATA     csd;
    DDHAL_CANCREATESURFACEDATA  ccsd;
    DWORD                       sflags;
    BOOL                        is_curr_diff;
    BOOL                        understood_pf;
    DWORD                       nsflags;
    LPDDSCAPS                   pdrv_ddscaps;
    LPDDHAL_CANCREATESURFACE    ccsfn;
    LPDDHAL_CREATESURFACE       csfn;
    LPDDHAL_CANCREATESURFACE    ccshalfn;
    LPDDHAL_CREATESURFACE       cshalfn;
    BOOL                        is_excl;
    BOOL                        excl_exists;
    DWORD                       sdflags;
    #ifdef WIN95
	DWORD                   ptr16;
    #endif
    DWORD                       pid;
    LPDDRAWI_DDRAWSURFACE_GBL   lpGlobalSurface;
    DDSURFACEDESC2              sd;
    BOOL                        existing_global;
    DWORD                       caps2;
    BOOL                        is_cubemap;
	BOOL						is_stereo;
#ifdef SHAREDZ
    BOOL                        do_shared_z;
    BOOL                        do_shared_back;
#endif

    this = this_lcl->lpGbl;
    #ifdef WINNT
	// Update DDraw handle in driver GBL object.
	this->hDD = this_lcl->hDD;
    #endif //WINNT

    /*
     * validate surface description
     */
    nsflags = 0;
    sd = *lpDDSurfaceDesc;
    lpDDSurfaceDesc = &sd;

    /*
     * This new (DX7) caps bit is added to mipmap sublevels. Squish it in case old apps do the
     * GetSurfaceDesc, CreateSurface thing.
     */
    sd.ddsCaps.dwCaps2 &= ~DDSCAPS2_MIPMAPSUBLEVEL;

    /*
     * If we have a mip-map then we potentially can fill in some
     * blanks for the caller.
     */
    if( lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
    {
         /*
          * We allow deep mipmaps only for ddraw7 and above interfaces
          * and for DX7 and above class drivers.
          */
	ddrval = initMipMapDim( lpDDSurfaceDesc , !LOWERTHANDDRAW7(this_int) && this->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState != NULL );
	if( ddrval != DD_OK )
	    return ddrval;
    }

    // Volume textures can only be created using the DX8 interfaces
    if ((lpDDSurfaceDesc->ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) &&
        !(DX8Flags & DX8SFLAG_DX8))
    {
        DPF_ERR("Volume textures cannot be created using the ddraw interfaces");
        return DDERR_INVALIDCAPS;
    }

    // Image surfaces can be in Z formats that CheckSurfaceDesc will fail since
    // the surface isn't a Z buffer.  Also, all image surface descs are filled in
    // the thunk layer, so we shouldn't have to check them anyway.
    if (!(DX8Flags & DX8SFLAG_IMAGESURF))
    {
        ddrval = checkSurfaceDesc( lpDDSurfaceDesc, this, &nsflags, emulation, real_sysmem, this_int );
        if( ddrval != DD_OK )
        {
	    return ddrval;
        }
    }

    sdflags = lpDDSurfaceDesc->dwFlags;
    pid     = GetCurrentProcessId();
    caps    = lpDDSurfaceDesc->ddsCaps.dwCaps;
    caps2   = lpDDSurfaceDesc->ddsCaps.dwCaps2;

    /*
     * set up for emulation vs driver
     *
     * NOTE: There are different HAL entry points for creating execute buffers
     * and conventional surfaces (to keep the driver writing simpler and because,
     * potentially, there may be different semantics for creating execute buffers
     * and conventional surfaces) so we need to set up the HAL call differently
     * here.
     */
    if( emulation )
    {
	pdrv_ddscaps = &this->ddHELCaps.ddsCaps;
	if( caps & DDSCAPS_EXECUTEBUFFER )
	{
	    ccsfn = this_lcl->lpDDCB->HELDDExeBuf.CanCreateExecuteBuffer;
	    csfn = this_lcl->lpDDCB->HELDDExeBuf.CreateExecuteBuffer;
	}
	else
	{
	    ccsfn = this_lcl->lpDDCB->HELDD.CanCreateSurface;
	    csfn = this_lcl->lpDDCB->HELDD.CreateSurface;
	}
	ccshalfn = ccsfn;
	cshalfn = csfn;
    }
    else
    {
	pdrv_ddscaps = &this->ddCaps.ddsCaps;
	if( caps & DDSCAPS_EXECUTEBUFFER )
	{
	    ccsfn = this_lcl->lpDDCB->HALDDExeBuf.CanCreateExecuteBuffer;
	    csfn = this_lcl->lpDDCB->HALDDExeBuf.CreateExecuteBuffer;
	    ccshalfn = this_lcl->lpDDCB->cbDDExeBufCallbacks.CanCreateExecuteBuffer;
	    cshalfn = this_lcl->lpDDCB->cbDDExeBufCallbacks.CreateExecuteBuffer;
            if ( DDSCAPS2_COMMANDBUFFER & caps2 )
            {
                // Asheron's Call(a DX6 app) will fail if we allow Video Command buffer
                // it's not interesting anyway, let's fail it
                DPF(4,"Command buffer is not supported in video-memory.");
                return DDERR_OUTOFVIDEOMEMORY;
            }
	}
	else
	{
	    ccsfn = this_lcl->lpDDCB->HALDD.CanCreateSurface;
	    csfn = this_lcl->lpDDCB->HALDD.CreateSurface;
	    ccshalfn = this_lcl->lpDDCB->cbDDCallbacks.CanCreateSurface;
	    cshalfn = this_lcl->lpDDCB->cbDDCallbacks.CreateSurface;
	}
    }

    /*
     * get some frequently used fields
     */
    if( sdflags & DDSD_BACKBUFFERCOUNT )
    {
	bbcnt = (int) lpDDSurfaceDesc->dwBackBufferCount;
	if( bbcnt < 0 )
	{
	    DPF( 0, "Invalid back buffer count %ld", bbcnt );
	    return DDERR_INVALIDPARAMS;
	}
    }
    else if( sdflags & DDSD_MIPMAPCOUNT )
    {
	/*
	 * Unlike the back-buffer count which can be 0
	 * the mip-map level count must be at least one
	 * if specified.
	 */
	bbcnt = (int) lpDDSurfaceDesc->dwMipMapCount - 1;
	if( bbcnt < 0 )
	{
	    DPF( 0, "Invalid mip-map count %ld", bbcnt + 1);
	    return DDERR_INVALIDPARAMS;
	}
    }
    else
    {
	bbcnt = 0;
    }

    /*
     * make sure the driver supports these caps
     */
    if( (caps & DDSCAPS_ALPHA) && !(pdrv_ddscaps->dwCaps & DDSCAPS_ALPHA) )
    {
	if( probe_driver )
	    DPF( 2, "Alpha not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Alpha not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOALPHAHW;
    }

    // DX7Stereo
	if (caps2 & DDSCAPS2_STEREOSURFACELEFT) 
        {   
            DPF(4,"validating driver caps for stereo flipping chain");
            DPF(5,"driver stereo caps dwCaps2: %08lx",this->ddCaps.dwCaps2); 
            DPF(5,"                   dwSVCaps:%08lx",this->ddCaps.dwSVCaps);
            DPF(5,"       ddsCapsMore.dwCaps2: %08lx",this->ddsCapsMore.dwCaps2);

            if (!(this->ddCaps.dwCaps2 & DDCAPS2_STEREO))
	        {
	            DPF(0,"DDSCAPS2_STEREOSURFACELEFT invalid, hardware does not support DDCAPS2_STEREO");
		        return DDERR_NOSTEREOHARDWARE;
	        }

            if (!(this->ddCaps.dwSVCaps & (DDSVCAPS_STEREOSEQUENTIAL)))
	        {
	            DPF(0,"DDSCAPS2_STEREOSURFACELEFT invalid, hardware must support DDSVCAPS_STEREOSEQUENTIAL");
		        return DDERR_NOSTEREOHARDWARE;
	        }


            if (!(this->ddsCapsMore.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT))
	        {
		        DPF(0,"DDSCAPS2_STEREOSURFACELEFT invalid, hardware does not support DDSCAPS2_STEREOSURFACELEFT");
		        return DDERR_NOSURFACELEFT;
	        }


    }

    #if 0
    if( (caps & DDSCAPS_FLIP) && !(pdrv_ddscaps->dwCaps & DDSCAPS_FLIP))
    {
	if( probe_driver )
	    DPF( 2, "Flip not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Flip not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOFLIPHW;
    }
    #endif
    if((caps & DDSCAPS_ZBUFFER) && !(pdrv_ddscaps->dwCaps & DDSCAPS_ZBUFFER))
    {
	if( probe_driver )
	    DPF( 2, "Z Buffer not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Z Buffer not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOZBUFFERHW;
    }
    if((caps & DDSCAPS_TEXTURE) && !(pdrv_ddscaps->dwCaps & DDSCAPS_TEXTURE))
    {
	if( probe_driver )
	    DPF( 2, "Textures not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Textures not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOTEXTUREHW;
    }
    if((caps & DDSCAPS_MIPMAP) && !(pdrv_ddscaps->dwCaps & DDSCAPS_MIPMAP))
    {
	if( probe_driver )
	    DPF( 2, "Mip-maps not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Mip-maps not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOMIPMAPHW;
    }
    if((caps & DDSCAPS_EXECUTEBUFFER) && !(pdrv_ddscaps->dwCaps & DDSCAPS_EXECUTEBUFFER))
    {
	if( probe_driver )
	    DPF( 2, "Execute buffers not supported in hardware. Trying emulation..." );
	else
	    DPF( 2, "Execute buffers not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOEXECUTEBUFFERHW;
    }
#ifdef SHAREDZ
    if((caps & DDSCAPS_SHAREDZBUFFER) && !(pdrv_ddscaps->dwCaps & DDSCAPS_SHAREDZBUFFER))
    {
	if( probe_driver )
	    DPF( 2, "Shared Z-buffer not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Shared Z-buffer not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOSHAREDZBUFFERHW;
    }
    if((caps & DDSCAPS_SHAREDBACKBUFFER) && !(pdrv_ddscaps->dwCaps & DDSCAPS_SHAREDBACKBUFFER))
    {
	if( probe_driver )
	    DPF( 2, "Shared back-buffer not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Shared back-buffer not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOSHAREDBACKBUFFERHW;
    }
#endif
    if(caps & DDSCAPS_OVERLAY)
    {
	if( emulation )
	{
	    if( 0 == (this->ddHELCaps.dwCaps & DDCAPS_OVERLAY) )
	    {
		DPF_ERR( "No overlay hardware emulation" );
		return DDERR_NOOVERLAYHW;
	    }
	}
	else
	{
	    if( 0 == (this->ddCaps.dwCaps & DDCAPS_OVERLAY) )
	    {
		if( probe_driver )
		    DPF( 2, "No overlay hardware. Trying emulation..." );
		else
		    DPF_ERR( "No overlay hardware" );
		return DDERR_NOOVERLAYHW;
	    }
	}
    }
    if(caps2 & DDSCAPS2_DEINTERLACE)
    {
	if( emulation )
	{
            DPF_ERR( "No deinterlacing hardware emulation" );
            return DDERR_INVALIDPARAMS;
	}
	else
	{
	    if( 0 == (this->ddsCapsMore.dwCaps2 & DDSCAPS2_DEINTERLACE) )
	    {
		if( probe_driver )
		    DPF( 2, "No deinterlace hardware. Trying emulation..." );
		else
		    DPF_ERR( "No deinterlace hardware" );
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
#ifdef DEBUG
    if( (caps & DDSCAPS_FLIP) && !emulation && GetProfileInt("DirectDraw","nohwflip",0))
    {
	DPF(1,"pretending flip not supported in HW (due to nohwflip in [DirectDraw] of win.ini" );
	return DDERR_NOFLIPHW;
    }
#endif

    /*
     * fail requests for non-local video memory allocations if the driver does not
     * support non-local video memory.
     *
     * NOTE: Should we really do this or just let the allocation fail from natural
     * causes?
     *
     * ALSO NOTE: Don't have to worry about emulation as no emulated surface should
     * ever get this far with DDSCAPS_NONLOCALVIDMEM set.
     *
     * ALSO ALSO NOTE: Should we also fail DDSCAPS_LOCALVIDMEM if the driver does
     * not support DDSCAPS_NONLOCALVIDMEM. My feeling is that we should allow.
     * DDSCAPS_LOCALVIDMEM is legal with a non AGP driver - redundant but legal.
     */
    if( caps & DDSCAPS_NONLOCALVIDMEM )
    {
	if( !( this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM ) )
	{
	    DPF_ERR( "Driver does not support non-local video memory" );
	    return DDERR_NONONLOCALVIDMEM;
	}
    }

#if 0 //Old code
    //ATTENTION: Potential Apps compat problem!!
    /*
     * Optimized surfaces in video memory are only allowed if the HAL supports
     * them. We won't send a legacy driver create surface HAL calls for optimized
     * surfaces.
     */
    if( caps & DDSCAPS_OPTIMIZED )
    {
	if( caps & DDSCAPS_VIDEOMEMORY )
	{
	    if ( !(this->ddCaps.ddsCaps.dwCaps & DDSCAPS_OPTIMIZED) )
	    {
		DPF_ERR("Can't specify video memory optimized surface... Driver doesn't support optimized surfaces");
		return DDERR_NOOPTIMIZEHW;
	    }
	}
	if( caps & DDSCAPS_SYSTEMMEMORY )
	{
	    if ( !(this->ddHELCaps.ddsCaps.dwCaps & DDSCAPS_OPTIMIZED) )
	    {
		DPF_ERR("Can't specify system memory optimized surface... HEL doesn't support optimized surfaces");
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
#endif //0

    CheckExclusiveMode(this_lcl, &excl_exists, &is_excl, FALSE, NULL, FALSE);

    if (!is_excl ||  !(this->dwFlags & DDRAWI_FULLSCREEN) )
    {
	if( (caps & DDSCAPS_FLIP) && (caps & DDSCAPS_PRIMARYSURFACE) )
	{
	    DPF_ERR( "Must be in full-screen exclusive mode to create a flipping primary surface" );
	    return DDERR_NOEXCLUSIVEMODE;
	}
    }

    /*
     * see if we are creating the primary surface; if we are, see if
     * we can allow its creation
     */
    if( (caps & DDSCAPS_PRIMARYSURFACE) )
    {
	LPDDRAWI_DDRAWSURFACE_INT       pprim_int;

	pprim_int = this_lcl->lpPrimary;
	if( pprim_int )
	{
	    DPF_ERR( "Can't create primary, already created by this process" );
	    return DDERR_PRIMARYSURFACEALREADYEXISTS;
	}

	if( (excl_exists) && (is_excl) )
	{
	    /*
	     * we are the exclusive mode process invalidate everyone 
             * else's primary surfaces and create our own
	     */
            InvalidateAllPrimarySurfaces( this );
	}
	else if( excl_exists )
	{
	    /*
	     * we are not the exclusive mode process but someone else is
	     */
	    DPF(1, "Can't create primary, exclusive mode not owned" );
	    return DDERR_NOEXCLUSIVEMODE;
	}
	else
	{
	    /*
	     * no one has exclusive mode
	     */
	    if( !MatchPrimary( this, lpDDSurfaceDesc ) )
	    {
		DPF_ERR( "Can't create primary, incompatible with current primary" );
		return DDERR_INCOMPATIBLEPRIMARY;
	    }
	    /*
	     * otherwise, it is possible to create a primary surface
	     */
	}
    }

#ifdef SHAREDZ
    if( caps & DDSCAPS_SHAREDZBUFFER )
    {
	if( this_lcl->lpSharedZ != NULL )
	{
	    DPF_ERR( "Can't create shared Z, already created by this process" );
	    return DDERR_SHAREDZBUFFERALREADYEXISTS;
	}
	if( !MatchSharedZBuffer( this, lpDDSurfaceDesc ) )
	{
	    DPF_ERR( "Can't create shared Z buffer, incompatible with existing Z buffer" );
	    return DDERR_INCOMPATIBLESHAREDZBUFFER;
	}
    }
    if( caps & DDSCAPS_SHAREDBACKBUFFER )
    {
	if( this_lcl->lpSharedBack != NULL )
	{
	    DPF_ERR( "Can't create shared back-buffer, already created by this process" );
	    return DDERR_SHAREDBACKBUFFERALREADYEXISTS;
	}
	if( !MatchSharedBackBuffer( this, lpDDSurfaceDesc ) )
	{
	    DPF_ERR( "Can't create shared back buffer, incompatible with existing back buffer" );
	    return DDERR_INCOMPATIBLESHAREDBACKBUFFER;
	}
    }
#endif

    /*
     * make sure the driver wants this to happen...
     */

    if(caps & DDSCAPS_ZBUFFER) {
       //NOTE: In DX5, DDSD_PIXELFORMAT was never set for ZBuffers (except maybe for complex surfs)
       //      so drivers came to expect ccsd.bIsDifferentPixelFormat to be FALSE for ZBuffers,
       //      even though it should really be TRUE by definition and the spec.  Changing it to TRUE
       //      breaks CanCreateSurface in these old drivers (they return DRIVER_HANDLED+DDERR_INVALIDPIXELFORMAT)
       //      Sooo, I'm forcing it to be false for zbuffers, except for if zpixelformats is non-zero, which
       //      implies a DX6 driver which should be written to handle that field correctly.

       if(DRIVER_SUPPORTS_DX6_ZBUFFERS(this)) {
           // See manbug 27011.
           // Setting is_diff TRUE here makes it TRUE for typical DX5 primary creates.
           // This causes us to fault later on because we assume is_diff => pddpf is non-null.
           // is_diff == TRUE in this case also causes the nv4, nv10 drivers to fail cancreate.
           // The solution is to set is_diff false if it's a complex DX5 chain with Z
           //
	   //DDASSERT((caps & DDSCAPS_COMPLEX)==0);  // shouldve already forbidden complex surf creation w/stencil

            if ( caps & DDSCAPS_COMPLEX ) 
            {
	        is_diff=FALSE;
            }
            else
            {
	        is_diff=TRUE;
            }

       } else is_diff=FALSE;

    } else if( sdflags & DDSD_PIXELFORMAT )
    {
	is_diff = IsDifferentPixelFormat( &this->vmiData.ddpfDisplay, &lpDDSurfaceDesc->ddpfPixelFormat );
    }
    else
    {
	is_diff = FALSE;
    }
    DPF( 5, "is_diff = %d", is_diff );
    rc = DDHAL_DRIVER_NOTHANDLED;

    if( ccshalfn != NULL )
    {
	DPF(4,"Calling HAL for create surface, emulation == %d",emulation);

	ccsd.CanCreateSurface = ccshalfn;
	ccsd.lpDD = this;
	ccsd.lpDDSurfaceDesc = (LPDDSURFACEDESC)lpDDSurfaceDesc;
	ccsd.bIsDifferentPixelFormat = is_diff;
	
/*
 * This hack breaks Sundown (passing a pointer in an HRESULT).
 * No longer necessary following a change to ddhel.c (in myCanCreateSurface).
 * If that change gets backed out, we'll need a real fix here.
	
	if(emulation) {
	    // slight hack: need to sneak this ptr to HEL's myCanCreateSurface because it might
	    // need to LoadLib d3dim.dll and set this_lcl->hD3DInstance, if a Zbuffer is created

	    ccsd.ddRVal=(LONG_PTR) this_lcl; // **** needs to be fixed.
	}
*/

	/*
	 * !!! NOTE: Currently we don't support 16-bit versions of the HAL
	 * execute buffer members. If this is so do we need to use DOHALCALL?
	 */
	if( caps & DDSCAPS_EXECUTEBUFFER )
	{
	    DOHALCALL( CanCreateExecuteBuffer, ccsfn, ccsd, rc, emulation );
	}
	else
	{
	    DOHALCALL( CanCreateSurface, ccsfn, ccsd, rc, emulation );
	}
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( ccsd.ddRVal != DD_OK )
	    {
		DPF(2, "Driver says surface can't be created" );
		return ccsd.ddRVal;
	    }
	}
    }

    /*
     * if the driver didn't handle it, then fail any requests to create a
     * surface that differs in format from the primary surface, except for
     * z buffer and alpha
     */

    if( rc == DDHAL_DRIVER_NOTHANDLED )
    {
	if( is_diff && !(caps & (DDSCAPS_ZBUFFER|DDSCAPS_ALPHA)) )
	{
	    return DDERR_INVALIDPIXELFORMAT;
	}
    }

    /*
     * is this a primary surface chain?
     */
    if( caps & DDSCAPS_PRIMARYSURFACE )
    {
	is_primary_chain = TRUE;
    }
    else
    {
	is_primary_chain = FALSE;
    }

#ifdef SHAREDZ
    do_shared_z    = FALSE;
    do_shared_back = FALSE;
#endif

    /*
     * see if we are looking for a z-buffer with our surface
     */
    if( (caps & DDSCAPS_ZBUFFER) )
    {
	do_zbuffer = TRUE;
#ifdef SHAREDZ
	if( caps & DDSCAPS_SHAREDZBUFFER )
	    do_shared_z = TRUE;
#endif
	if( (caps & DDSCAPS_COMPLEX) )
	{
	    caps &= ~DDSCAPS_ZBUFFER;
#ifdef SHAREDZ
	    caps &= ~DDSCAPS_SHAREDZBUFFER;
#endif
	}
    }
    else
    {
	do_zbuffer = FALSE;
    }

    /*
     * see if we are looking for an alpha buffer with our surface
     */
    if( (caps & DDSCAPS_ALPHA) )
    {
	do_abuffer = TRUE;
	abuff_depth = lpDDSurfaceDesc->dwAlphaBitDepth;
	if( (caps & DDSCAPS_COMPLEX) )
	{
	    caps &= ~DDSCAPS_ALPHA;
	}
    }
    else
    {
	do_abuffer = FALSE;
	abuff_depth = 0;
    }

#ifdef SHAREDZ
    /*
     * See if we looking for a shared back-buffer with our surface
     */
    if( caps & DDSCAPS_SHAREDBACKBUFFER )
	do_shared_back = TRUE;
#endif

    /*
     * number of surfaces we need
     */
    nsurf = 1 + bbcnt;	
    // DX7stereo
    is_stereo = (BOOL)(caps2 & DDSCAPS2_STEREOSURFACELEFT);
    if ( is_stereo )
	{
		nsurf *= 2;
		nsflags |= DDRAWISURF_STEREOSURFACELEFT;
		caps2 &= ~DDSCAPS2_STEREOSURFACELEFT;
		DPF( 3, "doubling surfaces for stereo support" );
	}
    if( do_zbuffer && (caps & DDSCAPS_COMPLEX) )
    {
	nsurf++;
	DPF( 3, "adding one for zbuffer" );
    }
    if( do_abuffer && (caps & DDSCAPS_COMPLEX) )
    {
	nsurf++;
	DPF( 3, "adding one for alpha" );
    }
    is_cubemap = (BOOL)(caps2 & DDSCAPS2_CUBEMAP);
    if ( is_cubemap )
    {
        //Count the number of real surfaces we're making for the cube map
        DWORD dwCubeMapFaceCount =
            (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ? 1 : 0 )+
            (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ? 1 : 0 )+
            (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ? 1 : 0 )+
            (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ? 1 : 0 )+
            (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ? 1 : 0 )+
            (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) ? 1 : 0 );
        /*
         * If it's a mipmap, then we add the back buffer count
         * to each face in the cube
         * If no mipmap, then bbcnt==0
         */
        DDASSERT(bbcnt == 0 || (bbcnt && (caps & DDSCAPS_MIPMAP)) ); //If we have nonzero backbuffercount, then it has to be mipmaps
        DDASSERT(!do_zbuffer);
        DDASSERT(!do_abuffer);
        nsurf = dwCubeMapFaceCount * (bbcnt+1);
        DPF( 5, "I count %d cubemap faces",dwCubeMapFaceCount);
    }
    DPF( 5, "bbcnt=%d,nsurf=%d", bbcnt, nsurf );
    DPF( 5, "do_abuffer=%d,do_zbuffer=%d,is_stereo=%d", do_abuffer, do_zbuffer, is_stereo );

    /*
     * Compute offsets into the surface list of the various distinguished
     * surface types.
     */

    /*
     * are we creating a non-flipping complex surface?
     */
    if( nsurf > 1 )
    {
	if( (caps & DDSCAPS_COMPLEX) && !(caps & DDSCAPS_FLIP) )
	{
	    bbuffoff = 0;
	}
	else
	{
	    bbuffoff = 1;
	}
	if( do_zbuffer )
	{
	    if( do_abuffer )
		zbuffoff = (nsurf - 2);
	    else
		zbuffoff = (nsurf - 1);
	}
    }
    else
    {
	bbuffoff = 0;
	if( do_zbuffer )
	    zbuffoff = 0;
    }

    /*
     * is this a flipping surface?
     */
    if( caps & DDSCAPS_FLIP )
    {
	is_flip = TRUE;
    }
    else
    {
	is_flip = FALSE;
    }

    /*
     * Are we creating a mip-map chain?
     */
    if( ( ( caps & ( DDSCAPS_COMPLEX | DDSCAPS_MIPMAP ) ) ==
	  ( DDSCAPS_COMPLEX | DDSCAPS_MIPMAP ) ) &&
	( sdflags & DDSD_MIPMAPCOUNT ) )
    {
	is_mipmap = TRUE;
    }
    else
    {
	is_mipmap = FALSE;
    }

    /*
     * The creation of flipping optimized mipmaps has a different semantic from that of
     * non-optimized mipmap chains.
     * Since a single optimized mipmap represents the entire mipmap chain, a request to create
     * a complex optimized mipmap must be interpreted as meaning "please create me n mipmap chains
     * each represented by a single optimized surface."
     * In this case we need to turn off the is_mipmap flag to prevent the sizes of the subsequent
     * backbuffers from being cut in half (as would happen for a non-optimized mipmap).
     */
#if 0 //Old code
    if (caps & DDSCAPS_OPTIMIZED)
    {
	is_mipmap = FALSE;
    }
#endif //0

    /*
     * set up the list array
     */
    if( nsurf <= pcsinfo->listsize )
    {
	slist_int = pcsinfo->slist_int;
	slist_lcl = pcsinfo->slist_lcl;
	slist = pcsinfo->slist;
    }
    else
    {
	slist_int = MemAlloc( nsurf * sizeof( LPDDRAWI_DDRAWSURFACE_INT ) );
	if( NULL == slist_int )
	{
	    return DDERR_OUTOFMEMORY;
	}
	slist_lcl = MemAlloc( nsurf * sizeof( LPDDRAWI_DDRAWSURFACE_LCL ) );
	if( slist_lcl == NULL )
	{
	    MemFree(slist_int);
            return DDERR_OUTOFMEMORY;
	}
	slist = MemAlloc( nsurf * sizeof( LPDDRAWI_DDRAWSURFACE_GBL ) );
	if( slist == NULL )
	{
	    MemFree(slist_int);
            MemFree(slist_lcl);
	    return DDERR_OUTOFMEMORY;
	}
	pcsinfo->slist_int = slist_int;
	pcsinfo->slist_lcl = slist_lcl;
	pcsinfo->slist = slist;
	pcsinfo->listsize = nsurf;
    }
    pcsinfo->listcnt = nsurf;

    /*
     * Create all needed surface structures.
     *
     * The callback fns, caps, and other misc things are filled in.
     * Memory for the surface is allocated later.
     */
    pcsinfo->needlink = TRUE;
    firstbbuff = TRUE;
    if( is_primary_chain )
    {
	nsflags |= DDRAWISURF_PARTOFPRIMARYCHAIN;
	if( this->dwFlags & DDRAWI_MODEX )
	{
	    if( this->dwFlags & DDRAWI_STANDARDVGA )
	    {
		caps |= DDSCAPS_STANDARDVGAMODE;
	    }
	    else
	    {
		caps |= DDSCAPS_MODEX;
	    }
	}
    }
    for( scnt=0;scnt<nsurf;scnt++ )
    {
	DPF( 4, "*** Structs Surface %d ***", scnt );

	is_curr_diff = is_diff;
	understood_pf = FALSE;
	sflags = nsflags;
	pddpf = NULL;

	/*
	 * get the base pixel format
	 */
	if( is_primary_chain || !(sdflags & DDSD_PIXELFORMAT) )
	{
	    #ifdef USE_ALPHA
		if( (caps & DDSCAPS_ALPHA) && !(caps & DDSCAPS_COMPLEX) )
		{
		    memset( &ddpf, 0, sizeof( ddpf ) );
		    ddpf.dwSize = sizeof( ddpf );
		    pddpf = &ddpf;
		    pddpf->dwAlphaBitDepth = lpDDSurfaceDesc->dwAlphaBitDepth;
		    pddpf->dwFlags = DDPF_ALPHAPIXELS;
		    is_curr_diff = TRUE;
		    understood_pf = TRUE;
		}
		else
	    #endif
	    {
		/*
		 * If this surface has been explicitly requested in system
		 * memory then we will force the allocation of a pixel
		 * format. Why? because explicit system memory surfaces
		 * don't get lost when a mode switches. This is a problem
		 * if the surface has no pixel format as we will pick up
		 * the pixel format of the current mode instead. Trouble
		 * is that the surface was not created in that mode so
		 * we end up with a bad bit depth - very dangerous. Heap
		 * corruption follows.
		 */
		if( real_sysmem && !( caps & DDSCAPS_EXECUTEBUFFER ) )
		{
		    DPF( 3, "Forcing pixel format for explicit system memory surface" );
		    ddpf = this->vmiData.ddpfDisplay;
		    pddpf = &ddpf;
		    is_curr_diff = TRUE;
		}

		/*
		 * If no pixel format is specified then we use the pixel format
		 * of the primary. So if we understand the pixel format of the
		 * primary then we understand the pixel format of this surface.
		 * With one notable exception. We always understand the pixel
		 * format of an execute buffer - it hasn't got one.
		 */
		if( ( this->vmiData.ddpfDisplay.dwFlags & UNDERSTOOD_PF ) ||
		    ( caps & DDSCAPS_EXECUTEBUFFER ) )
		{
		    understood_pf = TRUE;
		}
	    }
	}
	else
	{
	    /*
	     * If we have an explicit system memory surface with a pixel format
	     * I don't care whether the specifed pixel format is the same as the
	     * primary. We are going to store it anyway. This is vital as
	     * explicit system memory surfaces survive mode switches so they must
	     * carry their pixel format with them.
	     */
	    if( real_sysmem && !( caps & DDSCAPS_EXECUTEBUFFER ) )
	    {
		DPF( 3, "Forcing pixel format for explicit system memory surface" );
		is_curr_diff = TRUE;
	    }

	    if( is_curr_diff )
	    {
		pddpf = &ddpf;
		ddpf = lpDDSurfaceDesc->ddpfPixelFormat;
		if( pddpf->dwFlags & UNDERSTOOD_PF )
		{
		    understood_pf = TRUE;
		}
	    }
	    else
	    {

		if( this->vmiData.ddpfDisplay.dwFlags & UNDERSTOOD_PF )
		{
		    understood_pf = TRUE;
		}
	    }
	}

	if((caps & DDSCAPS_ZBUFFER) && !(caps & DDSCAPS_COMPLEX)) {

	  DDASSERT(nsurf==1);

	  understood_pf = is_curr_diff = TRUE;
	  pddpf = &ddpf;

	  // proper pixfmt will have been set in checkSurfaceDesc
	  ddpf=lpDDSurfaceDesc->ddpfPixelFormat;

	}

	/*
	 * set up caps for each surface
	 */
	if( scnt > 0 )
	{
	    /*
	     * mark implicitly created surfaces as such
	     */
	    sflags |= DDRAWISURF_IMPLICITCREATE;

	    /*
	     * eliminated unwanted caps.
	     * NOTE: If we are creating a flipping chain for a mip-mapped
	     * texture then we don't propagate the MIPMAP cap to the back
	     * buffers, only the front buffer is tagged as a mip-map.
	     */
	    caps &= ~(DDSCAPS_PRIMARYSURFACE |
		      DDSCAPS_FRONTBUFFER | DDSCAPS_VISIBLE |
		      DDSCAPS_ALPHA | DDSCAPS_ZBUFFER |
		      DDSCAPS_BACKBUFFER );
            caps2 &= ~DDSCAPS2_STEREOSURFACELEFT;
#ifdef SHAREDZ
	    caps &= ~(DDSCAPS_SHAREDZBUFFER | DDSCAPS_SHAREDBACKBUFFER);
#endif
	    /*
	     * Complex optimized mipmaps actually keep the mipmap tags on their back buffers
	     * since each surface represents a whole chain of mipmaps
	     */
#if 0 //Old code
	    if ((caps & DDSCAPS_OPTIMIZED) == 0)
	    {
		if( is_flip )
		    caps &= ~DDSCAPS_MIPMAP;
	    }
#endif //0
	    #ifdef USE_ALPHA

	    /*
	     * caps for an alpha buffer
	     */
	    if( (do_abuffer && do_zbuffer && (scnt == nsurf-1) ) ||
		(do_abuffer && (scnt == nsurf-1)) )
	    {
		DPF( 4, "TRY ALPHA" );
		caps &= ~(DDSCAPS_TEXTURE | DDSCAPS_FLIP | DDSCAPS_OVERLAY | DDSCAPS_OFFSCREENPLAIN);
		caps |= DDSCAPS_ALPHA;
		memset( &ddpf, 0, sizeof( ddpf ) );
		ddpf.dwSize = sizeof( ddpf );
		pddpf = &ddpf;
		pddpf->dwAlphaBitDepth = lpDDSurfaceDesc->dwAlphaBitDepth;
		pddpf->dwFlags = DDPF_ALPHA;
		understood_pf = TRUE;
		is_curr_diff = TRUE;
	    /*
	     * caps for a z buffer
	     */
	    }
	    else
	    #endif
	    if( do_zbuffer && ( scnt == zbuffoff ) )
	    {
		caps &= ~(DDSCAPS_TEXTURE | DDSCAPS_FLIP | DDSCAPS_OVERLAY | DDSCAPS_OFFSCREENPLAIN | DDSCAPS_3DDEVICE);
		caps |= DDSCAPS_ZBUFFER;


#ifdef SHAREDZ
		if( do_shared_z )
		    caps |= DDSCAPS_SHAREDZBUFFER;
#endif
		pddpf = &ddpf;

		DDASSERT(caps & DDSCAPS_COMPLEX);  // scnt>0, so this must be true

		// must construct a valid z pixfmt in ddpf since DDSurfaceDesc one is being used
		// be primary surface.  note complex surfdescs will never be able to create stencil zbufs
		memset(&ddpf, 0, sizeof(DDPIXELFORMAT));
		ddpf.dwSize=sizeof(DDPIXELFORMAT);
		ddpf.dwFlags|=DDPF_ZBUFFER;
		ddpf.dwZBufferBitDepth = ((DDSURFACEDESC *)lpDDSurfaceDesc)->dwZBufferBitDepth;
		ddpf.dwZBitMask = (1 << ((DDSURFACEDESC *)lpDDSurfaceDesc)->dwZBufferBitDepth)-1;


		is_curr_diff = TRUE;
		understood_pf = TRUE;

	    /*
	     * set up for offscreen surfaces
	     */
	    }
	    else
	    {
		if( (!is_mipmap) && (!is_cubemap) )
		{
		    /*
		     * Flip and back buffer don't apply to mip-map chains or cubemaps.
		     */
			// DX7Stereo spec case for stereo
			// mark odd backbuffers only as surfaceleft
			if (is_stereo && ((scnt & 1)!=0))
			{
			caps2 |= DDSCAPS2_STEREOSURFACELEFT;
			} else 
			{
		    caps |= DDSCAPS_FLIP;
		    if( firstbbuff )
		    {
			caps |= DDSCAPS_BACKBUFFER;
			sflags |= DDRAWISURF_BACKBUFFER;
#ifdef SHAREDZ
			if( do_shared_back )
			    caps |= DDSCAPS_SHAREDBACKBUFFER;
#endif
			firstbbuff = FALSE;
		    }
			}
		}
	    }
	/*
	 * the first surface...
	 */
	}
	else
	{
	    if( caps & DDSCAPS_PRIMARYSURFACE )
	    {
		caps |= DDSCAPS_VISIBLE;
	    }
	    if( caps & DDSCAPS_FLIP )
	    {
		caps |= DDSCAPS_FRONTBUFFER;
		sflags |= DDRAWISURF_FRONTBUFFER;
	    }
	    if( nsurf > 1 )
	    {
		sflags |= DDRAWISURF_IMPLICITROOT;
	    }
	    if( caps & DDSCAPS_BACKBUFFER )
	    {
		sflags |= DDRAWISURF_BACKBUFFER;
	    }
	}

	/*
	 * if it isn't a pixel format we grok, then it is different...
	 */
	if( !understood_pf )
	{
	    is_curr_diff = TRUE;
	}

	/*
	 * pick size of structure we need to allocate...
	 */
	if( (caps & DDSCAPS_OVERLAY) ||
	    ((caps & DDSCAPS_PRIMARYSURFACE) &&
	     ((this->ddCaps.dwCaps & DDCAPS_OVERLAY) ||
	      (this->ddHELCaps.dwCaps & DDCAPS_OVERLAY))) )
	{
	    sflags |= DDRAWISURF_HASOVERLAYDATA;
	}
	/*
	 * Execute buffers should NEVER have pixel formats.
	 */
	if( is_curr_diff && !( caps & DDSCAPS_EXECUTEBUFFER ) )
	{
	    sflags |= DDRAWISURF_HASPIXELFORMAT;
	}

	/*
	 * allocate the surface struct, allowing for overlay and pixel
	 * format data
	 *
	 * NOTE: This single allocation can allocate space for local surface
	 * structure (DDRAWI_DDRAWSURFACE_LCL), the additional local surface
	 * structure (DDRAWI_DDRAWSURFACE_MORE) and the global surface structure
	 * (DDRAWI_DDRAWSURFACE_GBL). (And now the global surface more structure too
	 * (DDRAWI_DDRAWSURFACE_GBL_MORE). As both the local and global objects
	 * can be variable sized this can get pretty complex. Additionally, we have
	 * 4 bytes just before the surface_gbl that points to the surface_gbl_more.
	 *
	 * CAVEAT: All future surfaces that share this global all point to this
	 * allocation. The last surface's release has to free it. During
	 * InternalSurfaceRelease (in ddsiunk.c) a calculation is made to determine
	 * the start of this memory allocation. If the surface being released is
	 * the first one, then freeing "this_lcl" will free the whole thing. If
	 * not, then "this_lcl->lpGbl - (Surface_lcl + surface_more + more_ptr)"
	 * is computed. Keep this layout in synch with code in ddsiunk.c.
	 *
	 *  The layout of the various objects in the allocation is as follows:
	 *
	 * +-----------------+---------------+----+------------+-----------------+
	 * | SURFACE_LCL     | SURFACE_MORE  |More| SURFACE_GBL| SURFACE_GBL_MORE|
	 * | (variable)      |               |Ptr | (variable) |                 |
	 * +-----------------+---------------+----+------------+-----------------+
	 * <- surf_size_lcl ->               |                                   |
	 * <- surf_size_lcl_more ------------>                                   |
	 * <- surf_size --------------------------------------------------------->
	 *
	 */

	if( sflags & DDRAWISURF_HASOVERLAYDATA )
	{
	    surf_size_lcl = sizeof( DDRAWI_DDRAWSURFACE_LCL );
	    DPF( 5, "OVERLAY DATA SPACE" );
	}
	else
	{
	    surf_size_lcl = offsetof( DDRAWI_DDRAWSURFACE_LCL, ddckCKSrcOverlay );
	}

	surf_size_lcl_more = surf_size_lcl + sizeof( DDRAWI_DDRAWSURFACE_MORE );

	if( ( sflags & DDRAWISURF_HASPIXELFORMAT ) || ( caps & DDSCAPS_PRIMARYSURFACE ) )
	{
	    DPF( 5, "PIXEL FORMAT SPACE" );
	    surf_size = surf_size_lcl_more + sizeof( DDRAWI_DDRAWSURFACE_GBL );
	}
	else
	{
	    surf_size = surf_size_lcl_more +
			    offsetof( DDRAWI_DDRAWSURFACE_GBL, ddpfSurface );
	}

	// Need to allocate a pointer just before the SURFACE_GBL to
	// point to the beginning of the GBL_MORE.
	surf_size += sizeof( LPDDRAWI_DDRAWSURFACE_GBL_MORE );

	// Need to allocate a SURFACE_GBL_MORE too
	surf_size += sizeof( DDRAWI_DDRAWSURFACE_GBL_MORE );

	DPF( 5, "Allocating struct (%ld)", surf_size );
	existing_global = FALSE;
	if( caps & DDSCAPS_PRIMARYSURFACE )
	{
	    // attempt to find existing global primary surface
	    lpGlobalSurface = FindGlobalPrimary( this );
	}
#ifdef SHAREDZ
	else if( caps & DDSCAPS_SHAREDZBUFFER )
	{
	    DPF( 4, "Searching for shared Z-buffer" );
	    lpGlobalSurface = FindGlobalZBuffer( this );
	}
	else if( caps & DDSCAPS_SHAREDBACKBUFFER )
	{
	    DPF( 4, "Searching for shared back-buffer" );
	    lpGlobalSurface = FindGlobalBackBuffer( this );
	}
#endif
	else
	{
	    lpGlobalSurface = NULL;
	}
	if( lpGlobalSurface )
	{
	    DPF( 4, "Using shared global surface" );
	    #ifdef WIN95
		psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc16( surf_size_lcl_more, &ptr16 );
	    #else
		psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc( surf_size_lcl_more );
	    #endif
	    if( psurf_lcl != NULL )
	    {
		psurf_lcl->lpGbl = lpGlobalSurface;
	    }
	    existing_global = TRUE;
	}
	else
	{
	    #ifdef WIN95
		psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc16( surf_size, &ptr16 );
	    #else
		psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc( surf_size );
	    #endif
	    if( psurf_lcl != NULL )
	    {
		LPVOID *ppsurf_gbl_more;

		// Initialize SURFACE_GBL pointer
		// skipping 4 bytes for a pointer to the GBL_MORE
		psurf_lcl->lpGbl = (LPVOID) (((LPSTR) psurf_lcl) +
			surf_size_lcl_more + sizeof( LPVOID ) );

		// Initialize GBL_MORE pointer
		ppsurf_gbl_more = (LPVOID *)((LPBYTE)psurf_lcl->lpGbl - sizeof( LPVOID ));
		*ppsurf_gbl_more = (LPVOID)
			((LPBYTE)psurf_lcl + surf_size
			- sizeof( DDRAWI_DDRAWSURFACE_GBL_MORE ));

		// Sanity Check
		DDASSERT( *ppsurf_gbl_more == (LPVOID)GET_LPDDRAWSURFACE_GBL_MORE( psurf_lcl->lpGbl ) );

		// Initialize GBL_MORE structure
		GET_LPDDRAWSURFACE_GBL_MORE( psurf_lcl->lpGbl )->dwSize = sizeof( DDRAWI_DDRAWSURFACE_GBL_MORE );
		/*
		 * Init the contents stamp to 0 means the surface's contents can change at
		 * any time.
		 */
		if ( caps & (DDSCAPS_VIDEOPORT|DDSCAPS_OWNDC) )
		{
		    GET_LPDDRAWSURFACE_GBL_MORE( psurf_lcl->lpGbl )->dwContentsStamp = 0;
		}
		else
		{
		    GET_LPDDRAWSURFACE_GBL_MORE( psurf_lcl->lpGbl )->dwContentsStamp = 1;
		}
	    }
	}
	if( psurf_lcl == NULL )
	{
	    freeSurfaceList( slist_int, scnt );
	    return DDERR_OUTOFMEMORY;
	}
	psurf = psurf_lcl->lpGbl;

	/*
	 * allocate surface interface
	 */
	psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) MemAlloc( sizeof( DDRAWI_DDRAWSURFACE_INT ));
	if( NULL == psurf_int )
	{
	    freeSurfaceList( slist_int, scnt );
	    MemFree( psurf_lcl );
	    return DDERR_OUTOFMEMORY;
	}

	/*
	 * fill surface specific stuff
	 */
	psurf_int->lpLcl = psurf_lcl;
	if (LOWERTHANDDRAW4(this_int))
	{
	    psurf_int->lpVtbl = &ddSurfaceCallbacks;
	}
	else if (this_int->lpVtbl == &dd4Callbacks)
	{
	    psurf_int->lpVtbl = &ddSurface4Callbacks;
	}
	else
	{
	    psurf_int->lpVtbl = &ddSurface7Callbacks;
	}

	if( existing_global )
	{
	    psurf_lcl->dwLocalRefCnt = 0;
	}
	else
	{
	    psurf_lcl->dwLocalRefCnt = OBJECT_ISROOT;
	}
	psurf_lcl->dwProcessId = pid;

	slist_int[scnt] = psurf_int;
	slist_lcl[scnt] = psurf_lcl;
	slist[scnt] = psurf;

	/*
	 * fill in misc stuff
	 */
	psurf->lpDD = this;
	psurf_lcl->dwFlags = sflags;

	/*
	 * initialize extended fields if necessary
	 */
	if( sflags & DDRAWISURF_HASOVERLAYDATA )
	{
	    psurf_lcl->lpSurfaceOverlaying = NULL;
	}

	/*
	 * Initialize the additional local surface data structure
	 */
	psurf_lcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE) (((LPSTR) psurf_lcl) + surf_size_lcl );
	psurf_lcl->lpSurfMore->dwSize = sizeof( DDRAWI_DDRAWSURFACE_MORE );
	psurf_lcl->lpSurfMore->lpIUnknowns = NULL;
	psurf_lcl->lpSurfMore->lpDD_lcl = this_lcl;
	psurf_lcl->lpSurfMore->lpDD_int = this_int;
	psurf_lcl->lpSurfMore->dwMipMapCount = 0UL;
	psurf_lcl->lpSurfMore->lpddOverlayFX = NULL;
	psurf_lcl->lpSurfMore->lpD3DDevIList = NULL;
	psurf_lcl->lpSurfMore->dwPFIndex = PFINDEX_UNINITIALIZED;

#ifdef WIN95
        psurf_lcl->dwModeCreatedIn = this->dwModeIndex;
#else
        psurf_lcl->lpSurfMore->dmiCreated = this->dmiCurrent;
#endif
	/*
	 * fill in the current caps
	 */
	psurf_lcl->lpSurfMore->ddsCapsEx = sd.ddsCaps.ddsCapsEx;
	if (DDSD_TEXTURESTAGE & sd.dwFlags) //hack here to pass the flag too as dwTextureStage is [0,7]
	    psurf_lcl->lpSurfMore->dwTextureStage = sd.dwTextureStage | DDSD_TEXTURESTAGE;
	psurf_lcl->ddsCaps.dwCaps = caps;
	psurf_lcl->lpSurfMore->lpbDirty=NULL;    //initialized
 	psurf_lcl->lpSurfMore->dwSurfaceHandle=0;    //initialized
        psurf_lcl->lpSurfMore->qwBatch.QuadPart=0;
        if (sd.dwFlags & DDSD_FVF)
            psurf_lcl->lpSurfMore->dwFVF = sd.dwFVF;    //just stuff it in no matter what the surface type
        else
            psurf_lcl->lpSurfMore->dwFVF = 0;

        /* 
         * Mark surface as driver managed if the surface is marked with
         * DDSCAPS2_TEXTUREMANAGE *and* if the driver claims it can manage textures
         */
        if((psurf_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7) &&
            !(psurf_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) &&
            (psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE) && 
            (psurf_lcl->lpSurfMore->lpDD_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANMANAGETEXTURE))
        {
            psurf_lcl->dwFlags |= DDRAWISURF_DRIVERMANAGED;
        }
        else if((psurf_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) &&
                (psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
        {
            DDASSERT((psurf_lcl->lpSurfMore->lpDD_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANMANAGERESOURCE));
            psurf_lcl->dwFlags |= DDRAWISURF_DRIVERMANAGED;
        }

        /*
         * If it's a cubemap, then we need to mark up the surface's caps accordingly
         *
         * Cubemaps are laid out in the surface list such that the 0th and every subsequent
         * (bbcnt+1)th surface are the top levels of the mipmap. Surfaces in between these
         * are the mip levels. All surfaces in the map are tagged with their face cap.
         */
        if (is_cubemap)
        {
            int i;
            DWORD dwOrderedFaces[6] = {
                                       DDSCAPS2_CUBEMAP_POSITIVEX,
                                       DDSCAPS2_CUBEMAP_NEGATIVEX,
                                       DDSCAPS2_CUBEMAP_POSITIVEY,
                                       DDSCAPS2_CUBEMAP_NEGATIVEY,
                                       DDSCAPS2_CUBEMAP_POSITIVEZ,
                                       DDSCAPS2_CUBEMAP_NEGATIVEZ
            };
            int n;
            /*
             * Now we find the nth cubemap face in our ordered list.
             * This is the ordering, but some may be missing from the surfacedesc:
             *   DDSCAPS2_CUBEMAP_POSITIVEX
             *   DDSCAPS2_CUBEMAP_NEGATIVEX
             *   DDSCAPS2_CUBEMAP_POSITIVEY
             *   DDSCAPS2_CUBEMAP_NEGATIVEY
             *   DDSCAPS2_CUBEMAP_POSITIVEZ
             *   DDSCAPS2_CUBEMAP_NEGATIVEZ
             */
            n = (int) (scnt/(bbcnt+1));
            DDASSERT(n<=5);
            i=0;
            do
            {
                if (dwOrderedFaces[i] & sd.ddsCaps.dwCaps2)
                    n--;
            }
            while (n>=0 && i++<6);
            psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~DDSCAPS2_CUBEMAP_ALLFACES;
            psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 |= dwOrderedFaces[i];
            /*
             * Every top-level face is marked as a cubemap
             */
            psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_CUBEMAP;
        }

        if (is_stereo)
        {
            psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 = caps2;
        } 

        /*
         * Allocate memory to hold region list for D3D texture management
         */
        if(IsD3DManaged(psurf_lcl))
        {
            LPREGIONLIST lpRegionList;
            lpRegionList = (LPREGIONLIST)MemAlloc(sizeof(REGIONLIST));
            if(lpRegionList == NULL)
            {
                DPF_ERR("Out of memory allocating region list");
                freeSurfaceList( slist_int, scnt );
                psurf_lcl->lpSurfMore->lpRegionList = 0;
	        MemFree( psurf_lcl );
	        MemFree( psurf_int );
	        return DDERR_OUTOFMEMORY;
            }
            lpRegionList->rdh.dwSize = sizeof(RGNDATAHEADER);
            lpRegionList->rdh.iType = RDH_RECTANGLES;
            lpRegionList->rdh.nCount = 0;
            lpRegionList->rdh.nRgnSize = 0;
            lpRegionList->rdh.rcBound.left = LONG_MAX;
            lpRegionList->rdh.rcBound.right = 0;
            lpRegionList->rdh.rcBound.top = LONG_MAX;
            lpRegionList->rdh.rcBound.bottom = 0;
            psurf_lcl->lpSurfMore->lpRegionList = lpRegionList;
        }
        else
        {
            psurf_lcl->lpSurfMore->lpRegionList = 0;            
        }

	/*
	 * set up format info
	 *
	 * are we creating a primary surface?
	 */
	if( caps & DDSCAPS_PRIMARYSURFACE )
	{
	    /*
	     * NOTE: Previously we set ISGDISURFACE for all primary surfaces
	     * We now set it only for primarys hanging off display drivers.
	     * This is to better support drivers which are not GDI display
	     * drivers.
	     */
	    if( this->dwFlags & DDRAWI_DISPLAYDRV )
		psurf->dwGlobalFlags |= DDRAWISURFGBL_ISGDISURFACE;
	    psurf->wHeight = (WORD) this->vmiData.dwDisplayHeight;
	    psurf->wWidth = (WORD) this->vmiData.dwDisplayWidth;
	    psurf->lPitch = this->vmiData.lDisplayPitch;
	    DPF(5,"Primary Surface get's display size:%dx%d",psurf->wWidth,psurf->wHeight);
	    if( !understood_pf && (pddpf == NULL) )
	    {
		ddpf = this->vmiData.ddpfDisplay;
		pddpf = &ddpf;
	    }
	    bpp = this->vmiData.ddpfDisplay.dwRGBBitCount;
	}
	else
	{
	    /*
	     * process a plain ol' non-primary surface
	     */

	    /*
	     * set up surface attributes
	     */
	    if( scnt > 0 )
	    {
		/*
		 * NOTE: Don't have to worry about execute buffers here as
		 * execute buffers can never be created as part of a complex
		 * surface and hence scnt will never be > 0 for an execute
		 * buffer.
		 */
		DDASSERT( !( caps & DDSCAPS_EXECUTEBUFFER ) );

		/*
		 * If we are doing a mip-map chain then the width and height
		 * of each surface is half that of the preceeding surface.
                 * If we are doing cubemaps, then we need to reset every
                 * (bbcnt+1)th surface to the supplied size
		 */
		if( !is_mipmap || (is_cubemap && ((scnt%(bbcnt+1))==0) ) )
		{
		    psurf->wWidth  = slist[0]->wWidth;
		    psurf->wHeight = slist[0]->wHeight;
		}
		else
		{
		    psurf->wWidth  = max ( slist[scnt - 1]->wWidth  / 2 , 1);
		    psurf->wHeight = max ( slist[scnt - 1]->wHeight / 2 , 1);
		}
	    }
	    else
	    {
		if( caps & DDSCAPS_EXECUTEBUFFER )
		{
		    /*
		     * NOTE: Execute buffers are a special case. They are
		     * linear and not rectangular. We therefore store zero
		     * for width and height, they have no pitch and store
		     * their linear size in dwLinerSize (in union with lPitch).
		     * The linear size is given by the width of the surface
		     * description (the width MUST be specified - the height
		     * MUST NOT be).
		     */
		    DDASSERT(    lpDDSurfaceDesc->dwFlags & DDSD_WIDTH    );
		    DDASSERT( !( lpDDSurfaceDesc->dwFlags & DDSD_HEIGHT ) );

		    psurf->wWidth       = 0;
		    psurf->wHeight      = 0;
		    psurf->dwLinearSize = lpDDSurfaceDesc->dwWidth;
		}
		else
		{
		    if( sdflags & DDSD_HEIGHT )
		    {
			psurf->wHeight = (WORD) lpDDSurfaceDesc->dwHeight;
		    }
		    else
		    {
			psurf->wHeight = (WORD) this->vmiData.dwDisplayHeight;
		    }
		    if( sdflags & DDSD_WIDTH )
		    {
			psurf->wWidth = (WORD) lpDDSurfaceDesc->dwWidth;
		    }
		    else
		    {
			psurf->wWidth = (WORD) this->vmiData.dwDisplayWidth;
		    }
		}
	    }

	    /*
	     * set pixel format and pitch for surfaces we understand
	     */
	    if( lpDDSurfaceDesc->dwFlags & DDSD_PITCH )
	    {
		/*
		 * Client has alloc'd surface memory and specified its pitch.
		 */
		psurf->lPitch = lpDDSurfaceDesc->lPitch;
	    }
	    else if( caps & DDSCAPS_EXECUTEBUFFER )
	    {
		/*
		 * Execute buffers need to be handled differently from
		 * other surfaces. They never have pixel formats and
		 * BPP is a bit meaningless. You might wonder why we call
		 * ComputePitch at all for execute buffers. Well, they
		 * may also have alignment requirements and so it we
		 * need to give ComputePitch a chance to enlarge the
		 * size of the execute buffer.
		 *
		 * NOTE: For the purposes of this calculation. Execute
		 * buffers are 8-bits per pixel.
		 */
		psurf->dwLinearSize = ComputePitch( this, caps, psurf->dwLinearSize, 8U );
		if( psurf->dwLinearSize == 0UL )
		{
		    DPF_ERR( "Computed linear size of execute buffer as zero" );
                    MemFree(psurf_lcl->lpSurfMore->lpRegionList);
		    MemFree( psurf_lcl );
		    MemFree( psurf_int ); //oops, someone forgot these (jeffno 960118)
		    freeSurfaceList( slist_int, scnt );
		    return DDERR_INVALIDPARAMS;
		}
	    }
	    else
	    {
		if( understood_pf )
		{
		    LPDDPIXELFORMAT     pcurr_ddpf;

		    pcurr_ddpf = NULL;
		    if( is_curr_diff )
		    {
			if( (caps & DDSCAPS_FLIP) && scnt > 0 )
			{
			    GET_PIXEL_FORMAT( slist_lcl[0], slist[0], pcurr_ddpf );
			    pddpf->dwRGBBitCount = pcurr_ddpf->dwRGBBitCount;
			    bpp = pddpf->dwRGBBitCount;
			}
			else
			{
			    if(pddpf->dwFlags & DDPF_ZBUFFER) {
		   // note dwZBufferBitDepth includes any stencil bits too
			       bpp = (UINT)pddpf->dwZBufferBitDepth;
		} else {
		    bpp = (UINT) pddpf->dwRGBBitCount;
		}

			    if( bpp == 0 )
			    {
				bpp = (UINT) this->vmiData.ddpfDisplay.dwRGBBitCount;
				pddpf->dwRGBBitCount = (DWORD) bpp;
			    }
			}
		    }
		    else
		    {
			bpp = (UINT) this->vmiData.ddpfDisplay.dwRGBBitCount;
		    }
		    vm_pitch = (LONG) ComputePitch( this, caps,
					(DWORD) psurf->wWidth, bpp );
		    if( vm_pitch == 0 )
		    {
			DPF_ERR( "Computed pitch of 0" );
                        MemFree(psurf_lcl->lpSurfMore->lpRegionList);
			MemFree( psurf_lcl );
			MemFree( psurf_int ); //oops, someone forgot these (jeffno 960118)
			freeSurfaceList( slist_int, scnt );
			return DDERR_INVALIDPARAMS;
		    }
		}
		else
		{
		    vm_pitch = -1;
		}
		psurf->lPitch = vm_pitch;
	    }
	}

        /*
         * If this is a sysmem surface used for DX8, we need to use the memory 
         * that has already been allocated for this surface
         */
         if( (DX8Flags & DX8SFLAG_DX8) && real_sysmem && pSysMemInfo != NULL )
         {
            psurf->dwGlobalFlags |= DDRAWISURFGBL_DX8SURFACE;
            psurf->lPitch = pSysMemInfo[scnt].iPitch;
            psurf->fpVidMem = (ULONG_PTR) pSysMemInfo[scnt].pbPixels;
         }

         /*
          * If it's a volume texture, set that up
          */
         if ((DX8Flags & DX8SFLAG_DX8) && (lpDDSurfaceDesc->ddsCaps.dwCaps2 & DDSCAPS2_VOLUME))
         {
             if (scnt > 0)
             {
                 psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
             }
             psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps4 = 
                 MAKELONG((WORD)(pSysMemInfo[scnt].cpDepth),0);
             psurf->lSlicePitch = pSysMemInfo[scnt].iSlicePitch;
         }

	/*
	 *  Figure out what Blitting tables to use
	 */

	/*
	 * Initialize junctions if necessary
	 */
	if( g_rgjunc8 == NULL )
	{
	    HRESULT hr = InitializeJunctions( dwRegFlags & DDRAW_REGFLAGS_DISABLEMMX );
	    if( FAILED( hr ) )
	    {
		DPF_ERR( "InitializeJunctions failed" );
		return hr;
	    }
	}
	/*
	 *      Figure out what blitting table to use
	 */
	switch( bpp )
	{
	case 8:
	    psurf_lcl->lpSurfMore->rgjunc = (VOID *) g_rgjunc8;
	    break;
	case 16:
	    psurf_lcl->lpSurfMore->rgjunc = (VOID *) g_rgjunc565;
	    break;
	case 24:
	    psurf_lcl->lpSurfMore->rgjunc = (VOID *) g_rgjunc24;
	    break;
	case 32:
	    psurf_lcl->lpSurfMore->rgjunc = (VOID *) g_rgjunc32;
	    break;
        case 0:
            // DX7: Handle YUY2 and UYVY FourCC as just being 16bpp for the
            // purposes of bltting
            if (pddpf &&
                (pddpf->dwFlags & DDPF_FOURCC) &&
                ((pddpf->dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2')) ||
                 (pddpf->dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y'))))
            {
	        psurf_lcl->lpSurfMore->rgjunc = (VOID *) g_rgjunc565;
            }
            else
            {
                // No junction table support for other FOURCCs
	        psurf_lcl->lpSurfMore->rgjunc = (VOID *) NULL;
            }
            break;

	default:
	    // No table? Must be something weird like 1, 2, or 4 bits
	    psurf_lcl->lpSurfMore->rgjunc = (VOID *) NULL;
	    break;
	}

	/*
	 * first surface in flippable chain gets a back buffer count
	 */
	if( (scnt == 0) && (caps & DDSCAPS_FLIP) )
	{
	    psurf_lcl->dwBackBufferCount = lpDDSurfaceDesc->dwBackBufferCount;
	}
	else
	{
	    psurf_lcl->dwBackBufferCount = 0;
	}

	/*
	 * Each surface in the mip-map chain gets the number of levels
	 * in the map (including this level).
	 */
	if( caps & DDSCAPS_MIPMAP )
	{
	    if( is_mipmap )
	    {
		/*
		 * Part of complex mip-map chain.
                 * If it's a cube map, then its mip level is how far we are into the list
                 * away from the last top-level face. Top level faces are every bbcnt+1.
		 */
                if (is_cubemap)
                {
		    psurf_lcl->lpSurfMore->dwMipMapCount = ((nsurf - scnt -1) % (bbcnt+1) ) + 1;
                }
                else
                {
		    psurf_lcl->lpSurfMore->dwMipMapCount = (nsurf - scnt);
                }

                /*
                 * Set sublevel cap for any non-top-level (if we are not at a (bbcnt+1)th level)
                 */
                psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~DDSCAPS2_MIPMAPSUBLEVEL;
                if ( scnt%(bbcnt+1) )
                    psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;

		DPF( 5, "Assigning mip-map level %d to mip-map %d", psurf_lcl->lpSurfMore->dwMipMapCount, scnt );
	    }
	    else
	    {
		/*
		 * Single level map - not part of a chain.
		 */
		DPF( 5, "Assign mip-map level of 1 to single level mip-map" );
		psurf_lcl->lpSurfMore->dwMipMapCount = 1UL;
	    }
	}

	/*
	 * assign pixel format...
	 */
	if( is_curr_diff )
	{
	    /*
	     * Execute buffers should NEVER have a pixel format.
	     */
	    DDASSERT( !( caps & DDSCAPS_EXECUTEBUFFER ) );

	    psurf->ddpfSurface=*pddpf;

	    if( understood_pf )
	    {
		DPF( 5, "pitch=%ld, bpp = %d, (%hu,%hu)", psurf->lPitch,
					(UINT) psurf->ddpfSurface.dwRGBBitCount,
					psurf->wWidth, psurf->wHeight );
	    }
	}
	else
	{
	    if( !( caps & DDSCAPS_EXECUTEBUFFER ) )
	    {
		/*
		 * Somewhat misleading message for an execute buffer.
		 */
		DPF( 5, "pitch=%ld, WAS THE SAME PIXEL FORMAT AS PRIMARY", psurf->lPitch  );
	    }
	}

	/*
	 * FINALLY: set up attached surfaces: back buffers + alpha + Z
	 *
	 * NOTE:  Z & alpha get attached to the back buffer
	 */
	if( nsurf > 1 )
	{
	    #ifdef USE_ALPHA
	    if( do_zbuffer && do_abuffer && (scnt == nsurf-1) )
	    {
		DPF( 5, "linking alpha buffer to back buffer" );
		AddAttachedSurface( slist_lcl[bbuffoff], psurf_lcl, TRUE );
	    }
	    else if( do_zbuffer && do_abuffer && (scnt == nsurf-2) )
	    {
		DPF( 5, "linking Z buffer to back buffer" );
		AddAttachedSurface( slist_lcl[bbuffoff], psurf_lcl, TRUE );
	    }
	    else if( do_abuffer && (scnt == nsurf-1) )
	    {
		DPF( 5, "linking alpha buffer to back buffer" );
		AddAttachedSurface( slist_lcl[bbuffoff], psurf_lcl, TRUE );
	    }
	    else
	    #endif
	    if( do_zbuffer && (scnt == nsurf-1) )//DX7Stereo: adjust this for stereo
	    {
		DPF( 5, "linking Z buffer to back buffer" );
		AddAttachedSurface( slist_int[bbuffoff], psurf_int, TRUE );
	    }
	    // DX7Stereo: for stereo, exclude this case and handle it later
	    else if(!is_stereo && (is_flip && ((scnt == nsurf-1) ||
	    #ifndef USE_ALPHA
		       (do_zbuffer && do_abuffer && (scnt == nsurf-3)) ||
		       (do_abuffer && (scnt == nsurf-2)) ||
	    #endif
		       (do_zbuffer && (scnt == nsurf-2)))) )
	    {
		/*
		 * NOTE: For mip-maps we don't chain the last surface back
		 * to the first.
		 */


		DPF( 5, "linking buffer %d to buffer %d", scnt-1, scnt );
		AddAttachedSurface( slist_int[scnt-1], psurf_int, TRUE );
		/*
		 * link last surface to front buffer
		 */
		DPF( 5, "linking last buffer (%d) to front buffer", scnt );
		AddAttachedSurface( slist_int[scnt], slist_int[0], TRUE );
	    }
            else if( is_cubemap)
            {
                /*
                 * Every (bbcnt+1)th surface needs to be linked to the very first
                 * Otherwise, it's a mip level that needs linking to its parent
                 */
                if ( scnt>0 )
                {
                    if ( (scnt % (bbcnt+1)) == 0 )
                    {
                        DPF( 5, "linking cubemap surface #%d to root", scnt );
		        AddAttachedSurface( slist_int[0], psurf_int, TRUE );
                    }
                    else
                    {
                        DPF( 5, "linking cubemap mip surface #%d to buffer #%d", scnt-1, scnt );
		        AddAttachedSurface( slist_int[scnt-1], psurf_int, TRUE );
                    }
                }
            }
	    else if( ( is_flip || is_mipmap ) && (scnt > 0) )
	    {
			if (!is_stereo)	// DX7Stereo
			{
				DPF( 5, "linking buffer %d to buffer %d", scnt-1, scnt );
				AddAttachedSurface( slist_int[scnt-1], psurf_int, TRUE );
			} else
			{
				if (scnt & 1)
				{
					DPF( 5, "linking left buffer %d to buffer %d", scnt-1, scnt );
					AddAttachedSurface( slist_int[scnt-1], psurf_int, TRUE );
				} else
				{
					DPF( 5, "linking back buffer %d to buffer %d", scnt-2, scnt );
					AddAttachedSurface( slist_int[scnt-2], psurf_int, TRUE );
				}
				if (scnt==nsurf-1)
				{
					DPF( 5, "linking last back buffer %d to primary buffer", scnt-1);
					AddAttachedSurface( slist_int[scnt-1], slist_int[0], TRUE );
				}
			}
	    }
	    DPF( 4, "after addattached" );
	}

    } //end for(surfaces)
    DPF( 4, "**************************" );

    if ((caps & 
             (DDSCAPS_TEXTURE       | 
              DDSCAPS_EXECUTEBUFFER | 
              DDSCAPS_3DDEVICE      | 
              DDSCAPS_ZBUFFER)) &&
         !(DX8Flags & DX8SFLAG_IMAGESURF)
       )
    {
        int i;
        for (i=0; i < nsurf; i++)
        {
            slist_lcl[i]->lpSurfMore->dwSurfaceHandle=
            GetSurfaceHandle(&SURFACEHANDLELIST(this_lcl),slist_lcl[i]);
            //DPF(0,"Got slist_lcl[0]->lpSurfMore->dwSurfaceHandle=%08lx",slist_lcl[0]->lpSurfMore->dwSurfaceHandle);
        }
    }
    /*
     * OK, now create the physical surface(s)
     *
     * First, see if the driver wants to do it.
     */
    if( cshalfn != NULL )
    {
	DPF(4,"Calling driver to see if it wants to say something about create surface");
	csd.CreateSurface = cshalfn;
	csd.lpDD = this;
	csd.lpDDSurfaceDesc = (LPDDSURFACEDESC)lpDDSurfaceDesc;
	csd.lplpSList = slist_lcl;
	csd.dwSCnt = nsurf;

        //
        // record the creation stuff for dx7 drivers so we can do an atomic restore
        // with exactly the same parameters
        //
        if (NULL != this->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx && 
            (nsurf > 1))
        {
            DDASSERT(slist_lcl[0]->lpSurfMore->cSurfaces == 0);
            DDASSERT(slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2 == 0);
            DDASSERT(slist_lcl[0]->lpSurfMore->slist == 0);

            
            slist_lcl[0]->lpSurfMore->slist = MemAlloc( sizeof(slist_lcl[0]) * nsurf );

            if( slist_lcl[0]->lpSurfMore->slist )
            {
                slist_lcl[0]->lpSurfMore->cSurfaces = nsurf;
                memcpy(slist_lcl[0]->lpSurfMore->slist , slist_lcl, sizeof(slist_lcl[0]) * nsurf ); 

                //
                // we don't need to waste all this goo on mipmaps
                //
                if ((0 == (slist_lcl[0]->ddsCaps.dwCaps & DDSCAPS_MIPMAP)) ||
                    (slist_lcl[0]->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) )
                {
                    slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2 = MemAlloc(sizeof(*lpDDSurfaceDesc));
                    if ( slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2 )
                    {
                        memcpy(slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2, lpDDSurfaceDesc, sizeof(*lpDDSurfaceDesc) ); 
                    }
                    else
                    {
                        MemFree(slist_lcl[0]->lpSurfMore->slist);
                        slist_lcl[0]->lpSurfMore->slist=0;
                    }
                }
            }
        }

        /*
	 * NOTE: Different HAL entry points for execute buffers and
	 * conventional surfaces.
	 */
	if( caps & DDSCAPS_EXECUTEBUFFER )
	{
	    DOHALCALL( CreateExecuteBuffer, csfn, csd, rc, emulation );\
        }
        else
        {
            #ifdef    WIN95
                /* Copy the VXD handle from the per process local structure to global.
                 * This handle will be used by DDHAL32_VidMemAlloc(), rather than creating
                 * a new one using GetDXVxdHandle(). The assumptions here are:
                 * 1) Only one process can enter createSurface(), 2) Deferred calls to
                 * DDHAL32_VidMemAlloc() will result in the slow path, ie getting
                 * the VXD handle using GetDXVxdHandle().
                 * (snene 2/23/98)
                 */
                this->hDDVxd = this_lcl->hDDVxd;
            #endif /* WIN95 */

            DOHALCALL( CreateSurface, csfn, csd, rc, emulation );

            #ifdef    WIN95
                /* Restore the handle to INVALID_HANDLE_VALUE so that non-createSurface()
                 * calls using DDHAL32_VidMemAlloc() or deferred calls (possibly from other
                 * processes) will correctly recreate the handle using GetDXVxdHandle().
                 * (snene 2/23/98)
                 */
                this->hDDVxd = (DWORD)INVALID_HANDLE_VALUE;
            #endif /* WIN95 */
        }
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( csd.ddRVal != DD_OK )
	    {
                int i;
		#ifdef DEBUG
		    if( emulation )
		    {
			DPF( 1, "Emulation won't let surface be created, rc=%08lx (%ld)",
				    csd.ddRVal, LOWORD( csd.ddRVal ) );
		    }
		    else
		    {
			DPF( 1, "Driver won't let surface be created, rc=%08lx (%ld)",
				    csd.ddRVal, LOWORD( csd.ddRVal ) );
		    }
		#endif
                for (i=0; i < nsurf; i++)
                {
                    if (slist_lcl[i]->lpSurfMore->dwSurfaceHandle)
                        ReleaseSurfaceHandle(&SURFACEHANDLELIST(this_lcl),
                            slist_lcl[i]->lpSurfMore->dwSurfaceHandle);
                }
                if (slist_lcl[0]->lpSurfMore->slist)
                {   
                    MemFree(slist_lcl[0]->lpSurfMore->slist);
                }
                if (slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2)
                {
                    MemFree(slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2);
                }
		freeSurfaceList( slist_int, nsurf );

                //
                // If this routine returns either of these error values, then the calling routine
                // (createandlinksurfaces) will assume that something was wrong with the ddsurfacedesc
                // and return the error code to the app. This messes up the case where the app didn't
                // specify a memory type (sys/vid), since if the driver returns one of these codes on
                // the vidmem attempt, we will bail to the app and not try the sysmem attempt.
                //
                if ((csd.ddRVal == DDERR_INVALIDPARAMS || csd.ddRVal == DDERR_INVALIDCAPS) && 
                    (caps & DDSCAPS_VIDEOMEMORY) )
                {
                    csd.ddRVal = DDERR_INVALIDPIXELFORMAT;
                    DPF( 2, "Mutating driver's DDERR_INVALIDPARAMS/INVALIDCAPS into DDERR_INVALIDPIXELFORMAT!");
                }

		return csd.ddRVal;
	    }
	}
    }

#if 0 //Old code
    if ( (slist_lcl[0]->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)!= 0)
    {
	for( scnt=0;scnt<nsurf;scnt++ )
	{
	    /*
	     * Optimized surfaces get neither memory nor aliases at creation time.
	     * (In fact they'll never be aliased because they can't be locked.)
	     */

	    /*
	     * Optimized surfaces are born free!
	     */
	    if (slist_lcl[scnt]->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
	    {
		//HEL should have done this
		DDASSERT(slist_lcl[scnt]->lpGbl->dwGlobalFlags & DDRAWISURFGBL_MEMFREE);
	    }
	    slist_lcl[scnt]->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_MEMFREE;
	}
    }
    else //else not optimized surface
    {
#endif //0
	/*
	 * now, allocate any unallocated surfaces
	 */
	ddrval = AllocSurfaceMem( this_lcl, slist_lcl, nsurf );
	if( ddrval != DD_OK )
	{
            int i;
            for (i=0; i < nsurf; i++)
            {
                if (slist_lcl[i]->lpSurfMore->dwSurfaceHandle)
                    ReleaseSurfaceHandle(&SURFACEHANDLELIST(this_lcl),
                        slist_lcl[i]->lpSurfMore->dwSurfaceHandle);
            }
            if (slist_lcl[0]->lpSurfMore->slist)
            {   
                MemFree(slist_lcl[0]->lpSurfMore->slist);
            }
            if (slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2)
            {
                MemFree(slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2);
            }
	    freeSurfaceList( slist_int, nsurf );
	    return ddrval;
	}

	#ifdef USE_ALIAS
	    /*
	     * If this device has heap aliases then precompute the pointer
	     * alias for the video memory returned at creation time. This
	     * is by far the most likely pointer we are going to be handing
	     * out at lock time so we are going to make lock a lot faster
	     * by precomputing this then at lock time all we need to do is
	     * compare the pointer we got from the driver with fpVidMem. If
	     * they are equal then we can just return this cached pointer.
	     */
	    for( scnt=0;scnt<nsurf;scnt++ )
	    {
		LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

		lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE( slist_lcl[scnt]->lpGbl );
		if( slist_lcl[scnt]->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
                {
		    lpGblMore->fpAliasedVidMem = GetAliasedVidMem( this_lcl, slist_lcl[scnt],
								   slist_lcl[scnt]->lpGbl->fpVidMem );
                    // If we succeeded in getting an alias, cache it for future use. Also store the original
                    // fpVidMem to compare with before using the cached pointer to make sure the cached value
                    // is still valid
                    if (lpGblMore->fpAliasedVidMem)
                        lpGblMore->fpAliasOfVidMem = slist_lcl[scnt]->lpGbl->fpVidMem;
                    else
                        lpGblMore->fpAliasOfVidMem = 0;
                }
		else
                {
		    lpGblMore->fpAliasedVidMem = 0UL;
                    lpGblMore->fpAliasOfVidMem = 0UL;
                }
	    }
	#endif /* USE_ALIAS */
#if 0 //Old code
    } //if optimized surface
#endif //0

    /*
     * remember the primary surface...
     */
    if( lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
    {
	this_lcl->lpPrimary = slist_int[0];
    }

#ifdef SHAREDZ
    /*
     * remember the shared back and z-buffers (if any).
     */
    if( lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_SHAREDZBUFFER )
    {
	this_lcl->lpSharedZ = slist_int[zbuffoff];

	/*
	 * It is possible that the an existing shared z-buffer we found
	 * was lost. If it was then the creation process we went through
	 * above has rendered it "found" so clear the lost surface flags.
	 */
	this_lcl->lpSharedZ->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
    }
    if( lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_SHAREDBACKBUFFER )
    {
	this_lcl->lpSharedBack = slist_int[bbuffoff];

	/*
	 * It is possible that the an existing shared back-buffer we found
	 * was lost. If it was then the creation process we went through
	 * above has rendered it "found" so clear the lost surface flags.
	 */
	this_lcl->lpSharedBack->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
    }
#endif

    if (
#ifdef  WINNT
        // on NT side, we still call CreateSurfaceEx if HW driver isn't called
        emulation && slist_lcl[0]->hDDSurface &&
#endif  //WINNT
        !(DX8Flags & DX8SFLAG_ISLOST)
       )
    {
        DDASSERT(this_lcl == slist_lcl[0]->lpSurfMore->lpDD_lcl);
        return createsurfaceEx(slist_lcl[0]);
    }
    return DD_OK;

} /* createSurface */

/*
 * createAndLinkSurfaces
 *
 * Really create the surface.   Also used by EnumSurfaces
 * Assumes the lock on the driver object has been taken.
 */
HRESULT createAndLinkSurfaces(
	LPDDRAWI_DIRECTDRAW_LCL this_lcl,
	LPDDSURFACEDESC2 lpDDSurfaceDesc,
	BOOL emulation,
	LPDIRECTDRAWSURFACE FAR *lplpDDSurface,
	BOOL real_sysmem,
	BOOL probe_driver,
	LPDDRAWI_DIRECTDRAW_INT this_int,
        LPDDSURFACEINFO pSysMemInfo,
        DWORD DX8Flags)
{
    LPDDRAWI_DDRAWSURFACE_INT   curr_int;
    LPDDRAWI_DDRAWSURFACE_LCL   curr_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   curr;
    HRESULT                     ddrval;
    CSINFO                      csinfo;
    LPDDRAWI_DDRAWSURFACE_INT   fix_slist_int[FIX_SLIST_CNT];
    LPDDRAWI_DDRAWSURFACE_LCL   fix_slist_lcl[FIX_SLIST_CNT];
    LPDDRAWI_DDRAWSURFACE_GBL   fix_slist[FIX_SLIST_CNT];
    int                         i;
    LPDDRAWI_DIRECTDRAW_GBL     this;

    this = this_lcl->lpGbl;

    /*
     * try to create the surface
     */
    csinfo.needlink = FALSE;
    csinfo.slist_int = fix_slist_int;
    csinfo.slist_lcl = fix_slist_lcl;
    csinfo.slist = fix_slist;
    csinfo.listsize = FIX_SLIST_CNT;
    ddrval = createSurface( this_lcl, lpDDSurfaceDesc, &csinfo, emulation, real_sysmem, probe_driver, this_int, pSysMemInfo, DX8Flags );

    /*
     * if it worked, update the structures
     */
    if( ddrval == DD_OK )
    {
	/*
	 * link surface(s) into chain, increment refcnt
	 */
	for( i=0;i<csinfo.listcnt; i++ )
	{
	    curr_int = csinfo.slist_int[i];
	    curr_lcl = csinfo.slist_lcl[i];
	    curr = curr_lcl->lpGbl;

	    if( real_sysmem )
	    {
		curr->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMREQUESTED;
	    }
	    if( csinfo.needlink )
	    {
		if( curr_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
		{
		    // This surface is an overlay.  Insert it into the overlay
		    // Z order list.  By inserting this node into the head of
		    // the list, it is the highest priority overlay,
		    // obscuring all others.
		    // The Z order list is implemented as a doubly linked list.
		    // The node for each surface exists in its
		    // DDRAWI_DDRAWSURFACE_GBL structure.  The root node
		    // exists in the direct draw object.  The next pointer of
		    // the root node points to the top-most overlay.  The prev
		    // pointer points to the bottom-most overlay.  The list
		    // may be traversed from back to front by following the
		    // prev pointers.  It may be traversed from front to back
		    // by following the next pointers.

		    curr_lcl->dbnOverlayNode.next =
			this->dbnOverlayRoot.next;
		    curr_lcl->dbnOverlayNode.prev =
			(LPVOID)(&(this->dbnOverlayRoot));
		    this->dbnOverlayRoot.next =
			(LPVOID)(&(curr_lcl->dbnOverlayNode));
		    curr_lcl->dbnOverlayNode.next->prev =
			(LPVOID)(&(curr_lcl->dbnOverlayNode));
		    curr_lcl->dbnOverlayNode.object_int = curr_int;
		    curr_lcl->dbnOverlayNode.object = curr_lcl;
		}
		/*
		 * link into list of all surfaces
		 */
                if (!(DX8Flags & DX8SFLAG_DX8) ||
                    (curr_lcl->dwFlags & DDRAWISURF_PARTOFPRIMARYCHAIN))
                {
		    curr_int->lpLink = this->dsList;
		    this->dsList = curr_int;
                }
	    }
	    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) curr_int );
	}
	*lplpDDSurface = (LPDIRECTDRAWSURFACE) csinfo.slist_int[0];
    }


    /*
     * free allocated list if needed
     */
    if( csinfo.listsize > FIX_SLIST_CNT )
    {
	MemFree( csinfo.slist_int );
	MemFree( csinfo.slist_lcl );
	MemFree( csinfo.slist );
    }

    return ddrval;

} /* createAndLinkSurfaces */

/*
 * InternalCreateSurface
 *
 * Create the surface.
 * This is the internal way of doing this; used by EnumSurfaces.
 * Assumes the directdraw lock has been taken.
 */
HRESULT InternalCreateSurface(
    LPDDRAWI_DIRECTDRAW_LCL this_lcl,
    LPDDSURFACEDESC2 lpDDSurfaceDesc,
    LPDIRECTDRAWSURFACE FAR *lplpDDSurface,
    LPDDRAWI_DIRECTDRAW_INT this_int,
    LPDDSURFACEINFO pSysMemInfo,
    DWORD DX8Flags)
{
    DDSCAPS2                    caps;
    HRESULT         ddrval;
    LPDDRAWI_DIRECTDRAW_GBL this;

    this = this_lcl->lpGbl;

    /*
     * valid memory caps?
     */
    caps = lpDDSurfaceDesc->ddsCaps;

    if( (caps.dwCaps & DDSCAPS_SYSTEMMEMORY) && (caps.dwCaps & DDSCAPS_VIDEOMEMORY) )
    {
	DPF_ERR( "Can't specify SYSTEMMEMORY and VIDEOMEMORY" );
	return DDERR_INVALIDCAPS;
    }

    if (LOWERTHANDDRAW4(this_int))
    {
        lpDDSurfaceDesc->dwFlags &= ~(DDSD_PITCH | DDSD_LINEARSIZE);   // clear DDSD_LPSURFACE too?
    }

    // Has the client already allocated the surface memory?
    if( lpDDSurfaceDesc->dwFlags & DDSD_LPSURFACE )
    {
	LPDDPIXELFORMAT pddpf;

	/*
	 * The client has allocated the memory for this surface.  This is
	 * legal only if the surface's storage is explicitly specified to
	 * be in system memory.
	 */
	if( !(caps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag valid only with DDSCAPS_SYSTEMMEMORY flag" );
	    return DDERR_INVALIDCAPS;
	}

	if( !VALIDEX_PTR(lpDDSurfaceDesc->lpSurface,sizeof(DWORD)) )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag requires valid lpSurface ptr" );
	    return DDERR_INVALIDPARAMS;
	}

	if( caps.dwCaps & DDSCAPS_OPTIMIZED )   // what about DDSCAPS_ALLOCONLOAD?
	{
	    DPF_ERR( "DDSD_LPSURFACE flag illegal with optimized surface" );
	    return DDERR_INVALIDCAPS;
	}

	if( caps.dwCaps & DDSCAPS_COMPLEX )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag illegal with complex surface" );
	    return DDERR_INVALIDCAPS;
	}

	if( caps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag illegal with execute-buffer surface" );
	    return DDERR_INVALIDCAPS;
	}

	if( caps.dwCaps & (DDSCAPS_PRIMARYSURFACE | DDSCAPS_PRIMARYSURFACELEFT | DDSCAPS_OVERLAY) )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag illegal with primary surface or overlay surface" );
	    return DDERR_INVALIDCAPS;
	}

	if( caps.dwCaps & DDSCAPS_VIDEOPORT )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag illegal with video-port surface" );
	    return DDERR_INVALIDCAPS;
	}

	if( ~lpDDSurfaceDesc->dwFlags & (DDSD_HEIGHT | DDSD_WIDTH) )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag requires valid height and width" );
	    return DDERR_INVALIDPARAMS;
	}

	if ((ULONG_PTR)lpDDSurfaceDesc->lpSurface & 3)
	{
            if (this_int->lpVtbl != &dd4Callbacks)
	    {
		DPF_ERR( "Surface memory must be aligned to DWORD boundary" );
		return DDERR_INVALIDPARAMS;
	    }
	    // Avoid regression error with DX6 IDD4 interface.
            DPF(1, "Client-allocated surface memory is not DWORD-aligned" );
	}

	// Get a pointer to the pixel format for this surface.
	if( lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT )
	{
	    // The pixel format is specified in the DDSURFACEDESC2 structure.
	    pddpf = &lpDDSurfaceDesc->ddpfPixelFormat;
	}
	else
	{
	    // The pixel format is the same as the primary surface's.
	    pddpf = &this->vmiData.ddpfDisplay;
	}

	// Validate specified pitch or linear size.
	if (!(pddpf->dwFlags & DDPF_FOURCC))
	{
    	    long minpitch;
	    /*
	     * Verify that the pitch is an even multiple of 4 and that the pitch
	     * is large enough to accommodate the surface width.
	     */
	    if (!(lpDDSurfaceDesc->dwFlags & DDSD_PITCH))
	    {
		DPF_ERR( "DDSD_LPSURFACE flag requires valid pitch" );
		return DDERR_INVALIDPARAMS;
	    }
	    minpitch = (lpDDSurfaceDesc->dwWidth*pddpf->dwRGBBitCount + 7) >> 3;

	    if( lpDDSurfaceDesc->lPitch < minpitch || lpDDSurfaceDesc->lPitch & 3 )
	    {
		DPF_ERR( "Bad value specified for surface pitch" );
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
    	    DWORD blksize;
    	    DWORD dx, dy;
	    /*
	     * The client allocated memory for a surface with a FOURCC format.
	     * The only FOURCC formats we support in system memory are the
	     * DXT formats.
	     */
	    blksize = GetDxtBlkSize(pddpf->dwFourCC);   // returns 0 if not DXT

	    if (!blksize)
	    {
		DPF_ERR( "Specified FOURCC format is not supported in system memory" );
		return DDERR_UNSUPPORTED;
	    }
	    dx = (lpDDSurfaceDesc->dwWidth  + 3) >> 2;	 // surface width in blocks
	    dy = (lpDDSurfaceDesc->dwHeight + 3) >> 2;	 // surface height in blocks

	    if (lpDDSurfaceDesc->dwFlags & DDSD_PITCH)
	    {
		if (this_int->lpVtbl != &dd4Callbacks)
		{
		    DPF_ERR( "DXT surface requires DDSD_LINEARSIZE, not DDSD_PITCH" );
		    return DDERR_INVALIDPARAMS;
		}
		// Avoid regression error with DX6 IDD4 interface.
                DPF(1, "DXT surface requires DDSD_LINEARSIZE, not DDSD_PITCH" );
		lpDDSurfaceDesc->dwFlags &= ~DDSD_PITCH;
		lpDDSurfaceDesc->dwFlags |= DDSD_LINEARSIZE;
		lpDDSurfaceDesc->dwLinearSize = dx*dy*blksize;
	    }
    	    /*
    	     * The surface does have a DXT format.  Verify that the specified linear
	     * size is large enough to accommodate the specified width and height.
	     */
	    if (!(lpDDSurfaceDesc->dwFlags & DDSD_LINEARSIZE))
	    {
		DPF_ERR( "DDSD_LPSURFACE flag requires valid linear size for DXT surface" );
		return DDERR_INVALIDPARAMS;
	    }
	
	    if (lpDDSurfaceDesc->dwLinearSize < dx*dy*blksize)
	    {
		DPF_ERR( "Bad value specified for linear size" );
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
    else if (lpDDSurfaceDesc->dwFlags & (DDSD_PITCH | DDSD_LINEARSIZE))
    {
	// Avoid regression error with DX6 IDD4 interface.
	DPF(1, "DDSD_PITCH and DDSD_LINEARSIZE flags ignored if DDSD_LPSURFACE=0" );
	lpDDSurfaceDesc->dwFlags &= ~(DDSD_PITCH | DDSD_LINEARSIZE);
    }

#if 0 // DDSCAPS2_LOCALALLOC, DDSCAPS2_COTASKMEM and DDRAWISURFGBL_DDFREESCLIENTMEM are gone
    // Will DirectDraw be responsible for freeing client-allocated surface memory?
    if( caps.dwCaps2 & (DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM) )
    {
	if( !(lpDDSurfaceDesc->dwFlags & DDSD_LPSURFACE) )
	{
	    DPF_ERR( "DDSCAPS2 flags LOCALALLOC and COTASKMEM require DDSD_LPSURFACE flag" );
	    return DDERR_INVALIDCAPS;
	}

	if( !(~caps.dwCaps2 & (DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM)) )
	{
	    DPF_ERR( "DDSCAPS2 flags LOCALALLOC and COTASKMEM are mutually exclusive" );
	    return DDERR_INVALIDCAPS;
	}
    }
#endif // 0

    //
    // Check persistent-content caps
    //

    if (caps.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS)
    {
#ifdef WIN95
	//
	// Primary surface contents can only persist if exclusive mode.
	//

	if ((caps.dwCaps & DDSCAPS_PRIMARYSURFACE) &&
	    !(this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE))
	{
	    DPF_ERR("Non-exclusive primary surface contents cannot persist");
	    return DDERR_NOEXCLUSIVEMODE;
	}

	//
	// DDSCAPS_OWNDC and DDSCAPS_VIDEOPORT imply volatile surfaces.
	// Also, optimized surfaces are a special case which will be handled
	// later by deferring memory allocation.
	//

	// ATTENTION: Optimized surfaces can only be Persistent ?
	if ((caps.dwCaps & (DDSCAPS_OWNDC | DDSCAPS_VIDEOPORT | DDSCAPS_OPTIMIZED)))
	{
	    DPF_ERR("Surface is volatile, contents cannot persist");
	    return DDERR_INVALIDCAPS;
	}

	//
	// We don't have enough information to backup FourCC surface contents.
	//

	if (lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
	{
	    if (lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
	    {
		DPF_ERR("FourCC video memory surface contents cannot persist");
		return DDERR_INVALIDCAPS;
	    }
	}
#else
	DPF_ERR("Persistent content surfaces not implemented");
	return DDERR_INVALIDCAPS;
#endif
    }

    /*
     * If DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM are specified
     * then DDSCAPS_VIDOEMEMORY must be explicity specified. Note, we
     * can't dely this check until checkCaps() as by that time the heap
     * scanning software may well have turned on DDSCAPS_VIDOEMEMORY.
     */
    if( ( caps.dwCaps & ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) ) &&
	!( caps.dwCaps & DDSCAPS_VIDEOMEMORY ) )
    {
	DPF_ERR( "DDSCAPS_VIDEOMEMORY must be specified with DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM" );
	return DDERR_INVALIDCAPS;
    }

    /*
     * valid memory caps?
     */
    if( caps.dwCaps & DDSCAPS_OWNDC )
    {
	if( !( caps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
	{
	    DPF_ERR( "OWNDC only support for explicit system memory surfaces" );
	    return DDERR_UNSUPPORTED;
	}
    }

    /*
     * managed texture?
     */
    if( caps.dwCaps2 & DDSCAPS2_D3DTEXTUREMANAGE )
    {
        if ( caps.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM) )
        {
            DPF_ERR("Memory type can't be specified upon creation of managed surfaces ");
            return DDERR_INVALIDCAPS;
        }
        if ( (caps.dwCaps2 & DDSCAPS2_DONOTPERSIST) && (caps.dwCaps & DDSCAPS_WRITEONLY) && 
            (this_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7) && (this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM) && 
            !(this->dwFlags & DDRAWI_NOHARDWARE) && 
            ((this->ddCaps.dwCaps2 & DDCAPS2_TEXMANINNONLOCALVIDMEM) || (dwRegFlags & DDRAW_REGFLAGS_USENONLOCALVIDMEM)) )
        {
            lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
            lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
            lpDDSurfaceDesc->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
            DPF(2, "Creating managed surface in non-local vidmem");
            ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, FALSE,
                                            lplpDDSurface, FALSE, FALSE, this_int,
                                            pSysMemInfo, DX8Flags);
            lpDDSurfaceDesc->ddsCaps = caps;
            if(ddrval == DDERR_OUTOFVIDEOMEMORY)
            {
                if( this->dwFlags & DDRAWI_NOEMULATION )
                {
                    DPF_ERR( "No emulation support" );
                    return DDERR_NOEMULATION;
                }
                DPF(1, "Surface creation failed (out of memory). Now creating in system memory");
                lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
                lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
                lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
		        			lplpDDSurface, TRUE, FALSE, this_int,
                                                pSysMemInfo, DX8Flags);
                lpDDSurfaceDesc->ddsCaps = caps;
            }
        }
        else
        {
            if( this->dwFlags & DDRAWI_NOEMULATION )
            {
                DPF_ERR( "No emulation support" );
                return DDERR_NOEMULATION;
            }
            lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
            lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
            lpDDSurfaceDesc->ddsCaps.dwCaps  |= DDSCAPS_SYSTEMMEMORY;
            ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
					    lplpDDSurface, TRUE, FALSE, this_int,
                                            pSysMemInfo, DX8Flags);
            lpDDSurfaceDesc->ddsCaps = caps;
        }
    }
    else if( (caps.dwCaps2 & DDSCAPS2_TEXTUREMANAGE) && !(this_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) )
    {
        if ( caps.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM) )
        {
            DPF_ERR("Memory type can't be specified upon creation of managed surfaces ");
            return DDERR_INVALIDCAPS;
        }
        if( (this_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANMANAGETEXTURE) 
            && (this_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7) )
        {
            if( this->dwFlags & DDRAWI_NOHARDWARE )
            {
                DPF_ERR( "No hardware support" );
                return DDERR_NODIRECTDRAWHW;
            }
            lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
            ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, FALSE,
                                            lplpDDSurface, FALSE, FALSE, this_int,
                                            pSysMemInfo, DX8Flags);
            lpDDSurfaceDesc->ddsCaps = caps;
        }
        else
        {	    
            if ( (caps.dwCaps2 & DDSCAPS2_DONOTPERSIST) && (caps.dwCaps & DDSCAPS_WRITEONLY) && 
                (this_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7) && (this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM) &&
                !(this->dwFlags & DDRAWI_NOHARDWARE) &&
                ((this->ddCaps.dwCaps2 & DDCAPS2_TEXMANINNONLOCALVIDMEM) || (dwRegFlags & DDRAW_REGFLAGS_USENONLOCALVIDMEM)) )
            {
                lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
                lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
                lpDDSurfaceDesc->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                DPF(2, "Creating managed surface in non-local vidmem");
                ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, FALSE,
                                                lplpDDSurface, FALSE, FALSE, this_int,
                                                pSysMemInfo, DX8Flags);
                lpDDSurfaceDesc->ddsCaps = caps;
                if(ddrval == DDERR_OUTOFVIDEOMEMORY)
                {
                    if( this->dwFlags & DDRAWI_NOEMULATION )
                    {
                        DPF_ERR( "No emulation support" );
                        return DDERR_NOEMULATION;
                    }
                    DPF(2, "CreateSurface failed (out of memory). Now creating in system memory");
                    lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
                    lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
                    lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                    ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
                                                    lplpDDSurface, TRUE, FALSE, this_int,
                                                    pSysMemInfo, DX8Flags);
                    lpDDSurfaceDesc->ddsCaps = caps;
                }
            }
            else
            {
                if( this->dwFlags & DDRAWI_NOEMULATION )
                {
                    DPF_ERR( "No emulation support" );
                    return DDERR_NOEMULATION;
                }
                lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
                lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
                lpDDSurfaceDesc->ddsCaps.dwCaps  |= DDSCAPS_SYSTEMMEMORY;
	        ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
					        lplpDDSurface, TRUE, FALSE, this_int,
                                                pSysMemInfo, DX8Flags);
                lpDDSurfaceDesc->ddsCaps = caps;
            }
        }
        /*
         * want in video memory only?
         */
    }
    else if( caps.dwCaps & DDSCAPS_VIDEOMEMORY )
    {
	if( this->dwFlags & DDRAWI_NOHARDWARE )
	{
	    DPF_ERR( "No hardware support" );
	    return DDERR_NODIRECTDRAWHW;
	}

	ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, FALSE,
					lplpDDSurface, FALSE, FALSE, this_int,
                                        pSysMemInfo, DX8Flags);
	/*
	 * want in system memory only?
	 */
    }
    else if( caps.dwCaps & DDSCAPS_SYSTEMMEMORY )
    {
	if( this->dwFlags & DDRAWI_NOEMULATION )
	{
	    DPF_ERR( "No emulation support" );
	    return DDERR_NOEMULATION;
	}
	ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
					lplpDDSurface, TRUE, FALSE, this_int,
                                        pSysMemInfo, DX8Flags);
	/*
	 * don't care where it goes?  Try video memory first...
	 */
    }
    else
    {
	if( !(this->dwFlags & DDRAWI_NOHARDWARE) )
	{
	    lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
	    ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, FALSE,
					    lplpDDSurface, FALSE, TRUE, this_int,
                                            pSysMemInfo, DX8Flags);
	    lpDDSurfaceDesc->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
	}
	else
	{
	    ddrval = DDERR_NOEMULATION;
	}
	if( ddrval != DD_OK && ddrval != DDERR_INVALIDCAPS &&
	    ddrval != DDERR_INVALIDPARAMS )
	{
	    if( !(this->dwFlags & DDRAWI_NOEMULATION) &&
		(this->dwFlags & DDRAWI_EMULATIONINITIALIZED) )
	    {
		lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
		ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
						lplpDDSurface, FALSE, FALSE, this_int,
                                                pSysMemInfo, DX8Flags);
		lpDDSurfaceDesc->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
	    }
	    else
	    {
		DPF_ERR( "Couldn't allocate a surface at all" );
	    }
	}
    }

    // any color keys specified?
    if( (ddrval == DD_OK) &&
	(lpDDSurfaceDesc->dwFlags & (DDSD_CKSRCOVERLAY|DDSD_CKDESTOVERLAY|
				     DDSD_CKSRCBLT|DDSD_CKDESTBLT) ) )
    {
	/*
	 * Attempt to set the specified color keys
	 */
	if( lpDDSurfaceDesc->dwFlags & DDSD_CKSRCBLT )
	    ddrval = DD_Surface_SetColorKey((LPDIRECTDRAWSURFACE)*lplpDDSurface,
					    DDCKEY_SRCBLT, &(lpDDSurfaceDesc->ddckCKSrcBlt) );
	if(ddrval == DD_OK)
	{
	    if( lpDDSurfaceDesc->dwFlags & DDSD_CKDESTBLT )
		ddrval = DD_Surface_SetColorKey((LPDIRECTDRAWSURFACE)*lplpDDSurface,
						DDCKEY_DESTBLT, &(lpDDSurfaceDesc->ddckCKDestBlt) );
	    if(ddrval == DD_OK)
	    {
		if( lpDDSurfaceDesc->dwFlags & DDSD_CKSRCOVERLAY )
		    ddrval = DD_Surface_SetColorKey((LPDIRECTDRAWSURFACE)*lplpDDSurface,
						    DDCKEY_SRCOVERLAY, &(lpDDSurfaceDesc->ddckCKSrcOverlay) );
		if(ddrval == DD_OK)
		{
		    if( lpDDSurfaceDesc->dwFlags & DDSD_CKDESTOVERLAY )
			ddrval = DD_Surface_SetColorKey((LPDIRECTDRAWSURFACE)*lplpDDSurface,
							DDCKEY_DESTOVERLAY, &(lpDDSurfaceDesc->ddckCKDestOverlay) );
		}
	    }
	}
	if( ddrval != DD_OK )
	{
	    DPF_ERR("Surface Creation failed because color key set failed.");
	    DD_Surface_Release((LPDIRECTDRAWSURFACE)*lplpDDSurface);
	    *lplpDDSurface = NULL;
	}
    }

#ifdef WIN95
    //
    // Allocate persistent-content surface memory, if specified
    //

    if (SUCCEEDED(ddrval) && (lpDDSurfaceDesc->ddsCaps.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS))
    {
	if (FAILED(AllocSurfaceContents(((LPDDRAWI_DDRAWSURFACE_INT) *lplpDDSurface)->lpLcl)))
	{
	    DD_Surface_Release((LPDIRECTDRAWSURFACE) *lplpDDSurface);
	    *lplpDDSurface = NULL;
	    ddrval = DDERR_OUTOFMEMORY;
	}
    }
#endif

    return ddrval;

} /* InternalCreateSurface */

void CopyDDSurfDescToDDSurfDesc2(DDSURFACEDESC2* ddsd2, DDSURFACEDESC* ddsd)
{
    memcpy(ddsd2, ddsd, sizeof(*ddsd));
    ddsd2->ddsCaps.dwCaps2 = 0;
    ddsd2->ddsCaps.dwCaps3 = 0;
    ddsd2->ddsCaps.dwCaps4 = 0;
    ddsd2->dwTextureStage = 0;
}

HRESULT DDAPI DD_CreateSurface4_Main(LPDIRECTDRAW lpDD,LPDDSURFACEDESC2 lpDDSurfaceDesc,
	LPDIRECTDRAWSURFACE FAR *lplpDDSurface,IUnknown FAR *pUnkOuter,BOOL bDoSurfaceDescCheck,
        LPDDSURFACEINFO pSysMemInfo, DWORD DX8Flags);

/*
 * DD_CreateSurface
 *
 * Create a surface.
 * This is the method visible to the outside world.
 */
#undef DPF_MODNAME
#define DPF_MODNAME     "CreateSurface"

HRESULT DDAPI DD_CreateSurface(
	LPDIRECTDRAW lpDD,
	LPDDSURFACEDESC lpDDSurfaceDesc,
	LPDIRECTDRAWSURFACE FAR *lplpDDSurface,
	IUnknown FAR *pUnkOuter )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DDSURFACEDESC2              ddsd2;
    HRESULT                     hr = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CreateSurface");

    ZeroMemory(&ddsd2,sizeof(ddsd2));

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            DPF_ERR( "Invalid driver object passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        /*
         * verify that cooperative level is set
         */
        if( !(this_lcl->dwLocalFlags & DDRAWILCL_SETCOOPCALLED) )
        {
            DPF_ERR( "Must call SetCooperativeLevel before calling Create functions" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_NOCOOPERATIVELEVELSET);
            return DDERR_NOCOOPERATIVELEVELSET;
        }

	if( !VALID_DDSURFACEDESC_PTR( lpDDSurfaceDesc ) )
	{
	    DPF_ERR( "Invalid DDSURFACEDESC. Did you set the dwSize member?" );
	    DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

        if( (this->dwModeIndex == DDUNSUPPORTEDMODE)
#ifdef  WINNT
            && !(DDSCAPS_SYSTEMMEMORY & lpDDSurfaceDesc->ddsCaps.dwCaps)
#endif
          )
	{
	    DPF_ERR( "Driver is in an unsupported mode" );
	    LEAVE_DDRAW();
	    DPF_APIRETURNS(DDERR_UNSUPPORTEDMODE);
	    return DDERR_UNSUPPORTEDMODE;
	}

        CopyDDSurfDescToDDSurfDesc2(&ddsd2, lpDDSurfaceDesc);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters: Bad LPDDSURFACEDESC" );
	DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

//  must leave dwSize intact so checkSurfaceDesc can distinguish DDSURFACEDESC from DDSURFACEDESC2,
//  ddsd2.dwSize = sizeof(ddsd2);

    hr = DD_CreateSurface4_Main(lpDD,&ddsd2,lplpDDSurface,pUnkOuter,FALSE, NULL, 0);

    LEAVE_DDRAW();

    return hr;
}

HRESULT DDAPI DD_CreateSurface4(
	LPDIRECTDRAW lpDD,
	LPDDSURFACEDESC2 lpDDSurfaceDesc,
	LPDIRECTDRAWSURFACE FAR *lplpDDSurface,
	IUnknown FAR *pUnkOuter ) {

   DPF(2,A,"ENTERAPI: DD_CreateSurface4");
   return DD_CreateSurface4_Main(lpDD,lpDDSurfaceDesc,lplpDDSurface,pUnkOuter,TRUE, NULL, 0);
}

HRESULT DDAPI DD_CreateSurface4_Main(
	LPDIRECTDRAW lpDD,
	LPDDSURFACEDESC2 lpDDSurfaceDesc,
	LPDIRECTDRAWSURFACE FAR *lplpDDSurface,
	IUnknown FAR *pUnkOuter,
	BOOL bDoSurfaceDescCheck,
        LPDDSURFACEINFO pSysMemInfo,
        DWORD DX8Flags)
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    HRESULT                     ddrval;

    if( pUnkOuter != NULL )
    {
	return CLASS_E_NOAGGREGATION;
    }

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CreateSurface4_Main");

    /* DPF_ENTERAPI(lpDD); */

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            DPF_ERR( "Invalid driver object passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        /*
         * verify that cooperative level is set
         */
        if( !(this_lcl->dwLocalFlags & DDRAWILCL_SETCOOPCALLED) )
        {
            DPF_ERR( "Must call SetCooperativeLevel before calling Create functions" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_NOCOOPERATIVELEVELSET);
            return DDERR_NOCOOPERATIVELEVELSET;
        }

        if( bDoSurfaceDescCheck && !VALID_DDSURFACEDESC2_PTR( lpDDSurfaceDesc ) )
        {
            DPF(0, "Invalid DDSURFACEDESC2. Did you set the dwSize member? (%d should be %d)", lpDDSurfaceDesc->dwSize, sizeof(DDSURFACEDESC2) );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }

        if( (this->dwModeIndex == DDUNSUPPORTEDMODE)
#ifdef  WINNT
            && !(DDSCAPS_SYSTEMMEMORY & lpDDSurfaceDesc->ddsCaps.dwCaps)
#endif
          )
	{
	    DPF_ERR( "Driver is in an unsupported mode" );
	    LEAVE_DDRAW();
	    DPF_APIRETURNS(DDERR_UNSUPPORTEDMODE);
	    return DDERR_UNSUPPORTEDMODE;
	}

	*lplpDDSurface = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	return DDERR_INVALIDPARAMS;
    }

    if( this_lcl->dwProcessId != GetCurrentProcessId() )
    {
	DPF_ERR( "Process does not have access to object" );
	LEAVE_DDRAW();
	DPF_APIRETURNS(DDERR_INVALIDOBJECT);
	return DDERR_INVALIDOBJECT;
    }

    ddrval = InternalCreateSurface( this_lcl, lpDDSurfaceDesc,
				    lplpDDSurface, this_int, pSysMemInfo, DX8Flags );
    if( ddrval == DD_OK )
    {
        /*
         * If this is DX7, then we need to create a D3D texture object
         * if the surface is marked with DDSCAPS_TEXTURE. If the
         * createsurface is call is before creating a Direct3D7 object,
         * then we will create a Direct3D7 ourselves.
         */
        if( ( this_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7 ) && !(DX8Flags & DX8SFLAG_DX8))
        {
            LPDDRAWI_DDRAWSURFACE_INT pInt = (LPDDRAWI_DDRAWSURFACE_INT) (*lplpDDSurface);
            if((pInt->lpLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) && 
                !(pInt->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTCREATED3DTEXOBJECT))
            {
                if( !D3D_INITIALIZED( this_lcl ) )
                {
                    /*
                     * No Direct3D interface yet so try and create one.
                     */
                    DPF(3, "No Direct3D interface yet, creating one");
                    ddrval = InitD3D( this_int );
                    if( FAILED( ddrval ) )
                    {
                        DPF_APIRETURNS(ddrval);
                        LEAVE_DDRAW();
                        return ddrval;
                    }
                }
                DDASSERT( D3D_INITIALIZED( this_lcl ) );
                DPF(4, "Calling D3D to create texture");
                ddrval = this_lcl->pD3DCreateTexture((LPDIRECTDRAWSURFACE7)pInt);
                if(ddrval != DD_OK)
                {
                    DPF_APIRETURNS(ddrval);
                    LEAVE_DDRAW();
                    return ddrval;
                }
            }
        }
        else
        {
            ((LPDDRAWI_DDRAWSURFACE_INT)(*lplpDDSurface))->lpLcl->lpSurfMore->lpTex = NULL;
        }
	/*
	 * If this ddraw object generates independent child objects, then this surface takes
	 * a ref count on that ddraw object.
	 * Note how we don't take an addref of the ddraw object for implicitly created
	 * surfaces.
	 */
	if (CHILD_SHOULD_TAKE_REFCNT(this_int))
	{
            LPDDRAWI_DDRAWSURFACE_INT pInt = (LPDDRAWI_DDRAWSURFACE_INT) (*lplpDDSurface);

	    lpDD->lpVtbl->AddRef(lpDD);
	    pInt->lpLcl->lpSurfMore->pAddrefedThisOwner = (IUnknown*) lpDD;
	}

//      FillDDSurfaceDesc( (LPDDRAWI_DDRAWSURFACE_LCL) *lplpDDSurface, lpDDSurfaceDesc );
    }

    DPF_APIRETURNS(ddrval);
    LEAVE_DDRAW();

    return ddrval;

} /* DD_CreateSurface4_Main */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddcreate.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcreate.c
 *  Content:    DirectDraw create object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   31-dec-94  craige  initial implementation
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   21-jan-95  craige  made 32-bit + ongoing work
 *   13-feb-94  craige  allow 32-bit callbacks
 *   21-feb-95  craige  disconnect anyone who forgot to do it themselves
 *   27-feb-95  craige  new sync. macros
 *   06-mar-95  craige  HEL integration
 *   08-mar-95  craige  new APIs
 *   11-mar-95  craige  palette stuff
 *   15-mar-95  craige  more HEL integration
 *   19-mar-95  craige  use HRESULTs, process termination cleanup fixes
 *   27-mar-95  craige  linear or rectangular vidmem
 *   28-mar-95  craige  removed Get/SetColorKey, added FlipToGDISurface
 *   29-mar-95  craige  reorg to only call driver once per creation, and
 *                      to allow driver to load us first
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  fill in free video memory
 *   09-apr-95  craige  fixed deadlock situation with a process having a lock
 *                      on the primary surface while another process starts
 *   12-apr-95  craige  bug when driver object freed (extra leave csect)
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   15-apr-95  craige  fail load if no DD components present
 *   06-may-95  craige  use driver-level csects only
 *   09-may-95  craige  escape call to get 32-bit DLL
 *   12-may-95  craige  added DirectDrawEnumerate; use GUIDs in DirectDrawCreate
 *   14-may-95  craige  call DoneExclusiveMode during CurrentProcessCleanup
 *   15-may-95  craige  restore display mode on a per-process basis
 *   19-may-95  craige  memory leak on mode change
 *   23-may-95  craige  added Flush, GetBatchLimit, SetBatchLimit
 *   24-may-95  craige  plugged another memory leak; allow fourcc codes &
 *                      number of vmem heaps to change
 *   26-may-95  craige  some idiot freed the vmem heaps and then tried to
 *                      free the surfaces!
 *   28-may-95  craige  unicode support; make sure blt means at least srccopy
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   06-jun-95  craige  call RestoreDisplayMode
 *   07-jun-95  craige  removed DCLIST
 *   12-jun-95  craige  new process list stuff
 *   16-jun-95  craige  new surface structure
 *   18-jun-95  craige  specify pitch for rectangular memory; deadlock
 *                      with MemAlloc16 if we don't take the DLL lock
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  replaced batch limit/flush stuff with BltBatch
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   02-jul-95  craige  new registry format
 *   03-jul-95  craige  YEEHAW: new driver struct; SEH
 *   06-jul-95  craige  RemoveFromDriverList was screwing up links
 *   07-jul-95  craige  added pdevice stuff
 *   08-jul-95  craige  call InvalidateAllSurfaces
 *   10-jul-95  craige  support SetOverlayPosition
 *   11-jul-95  craige  validate pdevice is from a dibeng mini driver;
 *                      fail aggregation calls; one ddraw object/process
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock; need to
 *                      leave Win16 lock while doing ExtEscape calls
 *   14-jul-95  craige  allow driver to specify heap is already allocated
 *   15-jul-95  craige  invalid HDC set in emulation only
 *   18-jul-95  craige  need to initialize dwPreferredMode
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   20-jul-95  toddla  zero DDHALINFO before thunking in case nobody home.
 *   22-jul-95  craige  emulation only needs to initialize correctly
 *   29-jul-95  toddla  added DEBUG code to clear driver caps
 *   31-jul-95  toddla  added DD_HAL_VERSION
 *   31-jul-95  craige  set DDCAPS_BANKSWITCHED
 *   01-aug-95  toddla  added dwPDevice to DDRAWI_DIRECTDRAW_GBL
 *   10-aug-95  craige  validate alignment fields
 *   13-aug-95  craige  check DD_HAL_VERSION & set DDCAPS2_CERTIFIED
 *   21-aug-95  craige  mode X support
 *   27-aug-95  craige  bug 738: use GUID instead of IID
 *   05-sep-95  craige  bug 814
 *   08-sep-95  craige  bug 845: reset driver callbacks every time
 *   09-sep-95  craige  bug 949: don't allow ddraw to run in 4bpp
 *                      bug 951: NULL out fn tables at reset
 *   10-sep-95  toddla  dont allow DirectDrawCreate to work for < 8bpp mode.
 *   10-sep-95  toddla  added Message box when DirectDrawCreate fails
 *   20-sep-95  craige  made primary display desc. a string resource
 *   21-sep-95  craige  bug 1215: let ddraw16 know about certified for modex
 *   21-nov-95  colinmc made Direct3D a queryable interface off DirectDraw
 *   27-nov-95  colinmc new member to return available vram of a given type
 *                      (defined by DDSCAPS)
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consitency with Direct3D
 *   09-dec-95  colinmc execute buffer support
 *   15-dec-95  colinmc fixed bug setting HAL up for execute buffers
 *   25-dec-95  craige  added InternalDirectDrawCreate for ClassFactory work
 *   31-dec-95  craige  more ClassFactory work
 *   04-jan-96  kylej   add driver interface structures
 *   22-jan-96  jeffno  NT driver conversation in createSurface.
 *                      Since vidmem ptrs can legally be 0 for kernel, added
 *                      DDRAWISURFACEGBL_ISGDISURFACE and use that to find gdi
 *   02-feb-96  kylej   Move HAL function pointers to local object
 *   28-feb-96  kylej   Change DDHALINFO structure
 *   02-mar-96  colinmc Repulsive hack to support interim drivers
 *   06-mar-96  kylej   init HEL even with non-display drivers
 *   13-mar-96  craige  Bug 7528: hw that doesn't have modex
 *   13-mar-96  jeffno  Dynamic mode switch support for NT
 *                      Register process IDs with NT kernel stuff
 *   16-mar-96  colinmc Callback tables now initialized in dllmain
 *   18-mar-96  colinmc Bug 13545: Independent clippers cleanup
 *   22-mar-96  colinmc Bug 13316: uninitialized interfaces
 *   23-mar-96  colinmc Bug 12252: Direct3D not cleaned up properly on crash
 *   14-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   16-apr-96  colinmc Bug 17921: Remove interim driver support
 *   19-apr-96  colinmc Bug 18059: New caps bit to indicate that driver
 *                      can't interleave 2D and 3D operations during scene
 *                      rendering
 *   11-may-96  colinmc Bug 22293: Now validate GUID passed to DirectDraw
 *                      Create in retail as well as debug
 *   16-may-96  colinmc Bug 23215: Not checking for a mode index of -1
 *                      on driver initialization
 *   27-may-96  kylej   Bug 24595: Set Certified bit after call to
 *                      FakeDDCreateDriverObject.
 *   26-jun-96  colinmc Bug 2041: DirectDraw needs time bomb
 *   22-jul-96  colinmc Work Item: Minimal stackable driver support
 *   23-aug-96  craige  registry entries for sw only and modex only
 *   31-aug-96  colinmc Removed erroneous time bomb
 *   03-sep-96  craige  App compatibilty stuff
 *   01-oct-96  ketand  added GetAvailVidMem entrypoint for driver callbacks
 *   05-sep-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   10-oct-96  colinmc Refinements of the Win16 locking stuff
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   15-oct-96  toddla  support multimonitor
 *   09-nov-96  colinmc Fixed problem with old and new drivers not working
 *                      with DirectDraw
 *   17-nov-96  colinmc Added ability to use PrintScrn key to snapshot
 *                      DirectDraw applications.
 *   08-dec-96  colinmc Initial AGP support
 *   21-jan-97  ketand  Added a rectMonitor to lpDD_gbl to allow for correct clipping
 *                      on multi-monitor systems.
 *   25-jan-97  nwilt   Instance GUID in GetDriverInfo struct
 *                      Query for D3DCallbacks2 w/no deps on D3D
 *   27-jan-97  colinmc Fixed problem with multi-mon on emulated displays
 *   27-jan-97  ketand  Multi-mon. Remove bad globals; pass them explicitly. Fix ATTENTIONs.
 *   29-jan-97  smac    Removed old ring 0 code
 *   30-jan-97  colinmc Work item 4125: Add time bomb for beta
 *   30-jan-97  jeffno  Allow surfaces wider than the primary
 *   30-jan-97  ketand  Only enumerate secondaries for multi-mon systems.
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   07-feb-97  ketand  Zero DisplayDevice struct between calls to EnumDisplayDevices.
 *                      Fix memory leak w.r.t. GetAndValidateNewHalInfo
 *   24-feb-97  ketand  Update Rects whenever a display change occurs.
 *   24-feb-97  ketand  Add a dwContext to GetDriverInfoData
 *   03-mar-97  smac    Added kernel mode interface
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   08-mar-97  colinmc Added support for DMA style AGP usage
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   11-mar-97  nwilt   Fail driver create if driver exports some DrawPrimitive
 *                      exports without exporting all of them.
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   20-mar-97  nwilt   #6625 and D3D extended caps
 *   24-mar-97  jeffno  Optimized Surfaces
 *   13-may-97  colinmc AGP support on OSR 2.1 systems
 *   26-may-97  nwilt   Fail driver create if driver sets D3DDEVCAPS_DRAWPRIMTLVERTEX
 *                      without exporting the callbacks.
 *   31-jul-97 jvanaken Bug 7093:  Ensure unique HDC for each process/driver pair
 *                      in a multimonitor system.
 *   16-sep-97  jeffno  DirectDrawEnumerateEx
 *   30-sep-97  jeffno  IDirectDraw4
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   05-nov-97 jvanaken Support for master sprite list in SetSpriteDisplayList
 *   24-may-00  RichGr  IA64: Remove casts from pointer assignment, effectively
 *                      changing assignment from DWORD(32-bit only) to
 *                      ULONG_PTR(32/64-bit).  Change debug output to use %p
 *                      format specifier instead of %x for 32/64-bit pointers.
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"

#include "apphack.h"
#ifdef WINNT
    #include <ddrawint.h>
    #include "ddrawgdi.h"
    #define BUILD_DDDDK
    #include "d3dhal.h"
#endif

#ifdef WIN95
#include "d3dhal.h"
#endif

#ifdef DEBUG
    #define static
#endif
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"
#define DPF_MODNAME     "DirectDrawObjectCreate"

#define DISPLAY_STR     "display"

HMONITOR GetMonitorFromDeviceName(LPSTR szName);

#ifdef WINNT
DWORD    GetNumberOfMonitorAttachedToDesktop(VOID);
DWORD APIENTRY GetDriverInfo2(LPDDRAWI_DIRECTDRAW_GBL lpGbl,DWORD* pdwDrvRet,DWORD dwType,DWORD dwSize,void* pBuffer);
#endif

char g_szPrimaryDisplay[MAX_DRIVER_NAME] = "";

void getPrimaryDisplayName(void);

void    convertV1DDHALINFO( LPDDHALINFO lpDDHALInfo );

DWORD   dwRegFlags;             // registry flags
// ATTENTION: Does this work for Multi-Mon??
WORD    dwFakeFlags = 0;        // Magic flags for the PDevice??

#ifdef WIN95
    /*
     * DDHELP's handle for communicating with the DirectSound VXD. We need this
     * when we are executing DDRAW code with one of DDHELP's threads.
     */
    HANDLE hHelperDDVxd = INVALID_HANDLE_VALUE;
    #define CLOSEVXD( hvxd ) CloseHandle( hvxd )

#else /* WIN95 */

    #define CLOSEVXD( hvxd )

#endif /* WIN95 */


//#ifdef WIN95

/*
 * initial HAL callbacks
 */

#ifndef WINNT //don't want these just yet

static DDHAL_DDCALLBACKS ddHALDD =
{
    sizeof( DDHAL_DDCALLBACKS ),
    0,
    _DDHAL_DestroyDriver,
    _DDHAL_CreateSurface,
    NULL,                       // _DDHAL_DrvSetColorKey
    _DDHAL_SetMode,
    _DDHAL_WaitForVerticalBlank,
    _DDHAL_CanCreateSurface,
    _DDHAL_CreatePalette,
    _DDHAL_GetScanLine,
    _DDHAL_SetExclusiveMode,
    _DDHAL_FlipToGDISurface
};

static DDHAL_DDSURFACECALLBACKS ddHALDDSurface =
{
    sizeof( DDHAL_DDSURFACECALLBACKS ),
    0,
    _DDHAL_DestroySurface,
    _DDHAL_Flip,
    _DDHAL_SetClipList,
    _DDHAL_Lock,
    _DDHAL_Unlock,
    _DDHAL_Blt,
    _DDHAL_SetColorKey,
    _DDHAL_AddAttachedSurface,
    _DDHAL_GetBltStatus,
    _DDHAL_GetFlipStatus,
    _DDHAL_UpdateOverlay,
    _DDHAL_SetOverlayPosition,
    NULL,
    _DDHAL_SetPalette
};

static DDHAL_DDPALETTECALLBACKS ddHALDDPalette =
{
    sizeof( DDHAL_DDPALETTECALLBACKS ),
    0,
    _DDHAL_DestroyPalette,
    _DDHAL_SetEntries
};

/*
 * NOTE: Currently don't support thunking for these babies. If
 * a driver does the execute buffer thing it must explicitly
 * export 32-bit functions to handle these calls.
 * !!! NOTE: Need to determine whether we will ever need to
 * support thunking for this HAL.
 */
static DDHAL_DDEXEBUFCALLBACKS ddHALDDExeBuf =
{
    sizeof( DDHAL_DDEXEBUFCALLBACKS ),
    0,
    NULL, /* CanCreateExecuteBuffer */
    NULL, /* CreateExecuteBuffer    */
    NULL, /* DestroyExecuteBuffer   */
    NULL, /* LockExecuteBuffer      */
    NULL  /* UnlockExecuteBuffer    */
};

/*
 * NOTE: Currently don't support thunking for these babies. If
 * a driver does the video port thing it must explicitly
 * export 32-bit functions to handle these calls.
 * !!! NOTE: Need to determine whether we will ever need to
 * support thunking for this HAL.
 */
static DDHAL_DDVIDEOPORTCALLBACKS ddHALDDVideoPort =
{
    sizeof( DDHAL_DDVIDEOPORTCALLBACKS ),
    0,
    NULL,       // CanCreateVideoPort
    NULL,       // CreateVideoPort
    NULL,       // FlipVideoPort
    NULL,       // GetVideoPortBandwidthInfo
    NULL,       // GetVideoPortInputFormats
    NULL,       // GetVideoPortOutputFormats
    NULL,       // GetCurrentAutoflipSurface
    NULL,       // GetVideoPortField
    NULL,       // GetVideoPortLine
    NULL,       // GetVideoPortConnectInfo
    NULL,       // DestroyVideoPort
    NULL,       // GetVideoPortFlipStatus
    NULL,       // UpdateVideoPort
    NULL,       // WaitForVideoPortSync
    NULL,       // GetVideoSignalStatus
    NULL        // ColorControl
};

/*
 * NOTE: Currently don't support thunking for these babies. If
 * a driver has a kernel mode interface it must explicitly
 * export 32-bit functions to handle these calls.
 */
static DDHAL_DDKERNELCALLBACKS ddHALDDKernel =
{
    sizeof( DDHAL_DDKERNELCALLBACKS ),
    0,
    NULL,       // SyncSurfaceData
    NULL        // SyncVideoPortData
};

static DDHAL_DDCOLORCONTROLCALLBACKS    ddHALDDColorControl =
{
    sizeof( DDHAL_DDSURFACECALLBACKS ),
    0,
    _DDHAL_ColorControl
};
#endif //not defined winnt

//#endif //defined(WIN95)

#ifndef WIN16_SEPARATE
    #ifdef WIN95
	CRITICAL_SECTION ddcCS = {0};
	#define ENTER_CSDDC() EnterCriticalSection( &ddcCS )
	#define LEAVE_CSDDC() LeaveCriticalSection( &ddcCS )
    #else
	#define ENTER_CSDDC()
	#define LEAVE_CSDDC()
    #endif
#else
    #define ENTER_CSDDC()
    #define LEAVE_CSDDC()
#endif

// DisplayGUID - GUID used to enumerate secondary displays.
//
// {67685559-3106-11d0-B971-00AA00342F9F}
//
// we use this GUID and the next 32 for enumerating devices
// returned via EnumDisplayDevices
//
static const GUID DisplayGUID =
    {0x67685559,0x3106,0x11d0,{0xb9,0x71,0x0,0xaa,0x0,0x34,0x2f,0x9f}};

/*
 * DISPLAY_DEVICEA
 *
 * define a local copy of the structures and constants needed
 * to call EnumDisplayDevices
 *
 */
#ifndef DISPLAY_DEVICE_ATTACHED_TO_DESKTOP
#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001
#define DISPLAY_DEVICE_MULTI_DRIVER        0x00000002
#define DISPLAY_DEVICE_PRIMARY_DEVICE      0x00000004
#define DISPLAY_DEVICE_MIRRORING_DRIVER    0x00000008
#define DISPLAY_DEVICE_VGA                 0x00000010
typedef struct {
    DWORD  cb;
    CHAR   DeviceName[MAX_DRIVER_NAME];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
} DISPLAY_DEVICEA;
#endif

/*
 * xxxEnumDisplayDevices
 *
 * wrapper around the new Win32 API EnumDisplayDevices
 * uses GetProcAddress() so we run on Win95.
 *
 * this function exists in NT 4.0 and Win97 (Memphis) but not Win95
 *
 */
BOOL xxxEnumDisplayDevicesA(LPVOID lpUnused, DWORD iDevice, DISPLAY_DEVICEA *pdd, DWORD dwFlags)
{
    HANDLE h = GetModuleHandle("USER32");
    BOOL (WINAPI *pfnEnumDisplayDevices)(LPVOID, DWORD, DISPLAY_DEVICEA *, DWORD);

    (FARPROC)pfnEnumDisplayDevices = GetProcAddress(h,"EnumDisplayDevicesA");

    //
    // NT 4.0 had a EnumDisplayDevicesA but it does not have the same
    // number of params, so ignore it unless a GetMonitorInfoA exists too.
    //
    if (GetProcAddress(h,"GetMonitorInfoA") == NULL)
	pfnEnumDisplayDevices = NULL;

    if (pfnEnumDisplayDevices)
    {
	return (*pfnEnumDisplayDevices)(lpUnused, iDevice, pdd, dwFlags);
    }

    return FALSE;
}

/*
 * xxxChangeDisplaySettingsEx
 *
 * wrapper around the new Win32 API ChangeDisplaySettingsEx
 * uses GetProcAddress() so we run on Win95.
 *
 * this function exists in NT 4.0 and Win97 (Memphis) but not Win95
 *
 */
LONG xxxChangeDisplaySettingsExA(LPCSTR szDevice, LPDEVMODEA pdm, HWND hwnd, DWORD dwFlags,LPVOID lParam)
{
    // We don't use ChangeDisplaySettingsEx on WIN95 because there is a magic
    // bit in DDraw16 that needs to be set/unset for us to correctly distinguish
    // between our own mode sets and external mode sets. (We need to know because
    // of RestoreMode state.)
#ifdef WINNT
    HANDLE h = GetModuleHandle("USER32");
    LONG (WINAPI *pfnChangeDisplaySettingsExA)(LPCSTR,LPDEVMODEA,HWND,DWORD,LPVOID);

    (FARPROC)pfnChangeDisplaySettingsExA = GetProcAddress(h,"ChangeDisplaySettingsExA");

    if (pfnChangeDisplaySettingsExA)
    {
        LONG lRet;
        NotifyDriverToDeferFrees();
	lRet = (*pfnChangeDisplaySettingsExA)(szDevice, pdm, hwnd, dwFlags, lParam);
        if (lRet != DISP_CHANGE_SUCCESSFUL)
        {
            NotifyDriverOfFreeAliasedLocks();
        }
        return lRet;
    }
    else
#endif
    if (szDevice == NULL)
    {
	return DD16_ChangeDisplaySettings(pdm, dwFlags);
    }
#ifdef WIN95
    else
    {
	// This method works on Win95 for mode-setting other
	// devices. We're not yet sure whether the equivalent would
	// work for NT; so we'd rather call the 'approved' API (ChangeDisplaySettingsExA above.)
        if (pdm != NULL)
        {
	    lstrcpy(pdm->dmDeviceName,szDevice);
        }
	return DD16_ChangeDisplaySettings(pdm, dwFlags);
    }
#else
    else
    {
        return DISP_CHANGE_FAILED;
    }
#endif
}
// Multi-monitor defines; these are wrong in the TRANGO tree;
// so I need to define them here explicitly. When we move to
// something that matches Memphis/NT5 then we can remove these
#undef SM_XVIRTUALSCREEN
#undef SM_YVIRTUALSCREEN
#undef SM_CXVIRTUALSCREEN
#undef SM_CYVIRTUALSCREEN
#undef SM_CMONITORS
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80

#ifndef ENUM_CURRENT_SETTINGS
#define ENUM_CURRENT_SETTINGS       ((DWORD)-1)
#endif

// This function walks through all GBLs and calls update rect on them
// This is called by DDHELP when it receives a message regarding WM_DISPLAYCHANGE
void UpdateAllDeviceRects( void )
{
    LPDDRAWI_DIRECTDRAW_LCL     tmp_lcl;
    ENTER_DDRAW();

    DPF( 1, W, "WM_DISPLAYCHANGE being processed by DDraw" );
    tmp_lcl = lpDriverLocalList;
    while( tmp_lcl )
    {
	// This interface may be "uninitialized" in which case
	// it doesn't point to a global object yet.
	if( tmp_lcl->lpGbl )
	{
	    DPF( 4, W, "Updating rect for %s", tmp_lcl->lpGbl->cDriverName );
	    UpdateRectFromDevice( tmp_lcl->lpGbl );
	}
	tmp_lcl = tmp_lcl->lpLink;
    }

    LEAVE_DDRAW();
    return;
}

#ifdef WINNT
// This function gets the device rect by calling GetMonitorInfo.
// On Win98, we got this by calling EnumDisplaySettings, but this
// doesn't work on NT5 and reading the documentation, it never
// indicates that it should work, so we'll just do it the documented
// way.
HRESULT GetNTDeviceRect( LPSTR pDriverName, LPRECT lpRect )
{
    MONITORINFO MonInfo;
    HMONITOR hMon;

    MonInfo.cbSize = sizeof( MONITORINFO );
    if( _stricmp( pDriverName, DISPLAY_STR ) == 0 )
    {
        hMon = GetMonitorFromDeviceName( g_szPrimaryDisplay );
    }
    else
    {
        hMon = GetMonitorFromDeviceName( pDriverName );
    }
    if( hMon != NULL )
    {
        if( GetMonitorInfo( hMon, &MonInfo ) != 0 )
        {
      	    CopyMemory( lpRect, &MonInfo.rcMonitor, sizeof(RECT) );
            return DD_OK;
        }
    }
    return DDERR_GENERIC;
}
#endif

// This function updates our GBL with topology information
// relevant to the device in question.
void UpdateRectFromDevice(
	LPDDRAWI_DIRECTDRAW_GBL    pdrv )
{
    DEVMODE dm;

    // Sanity Check
    DDASSERT( pdrv );

    pdrv->cMonitors = GetSystemMetrics( SM_CMONITORS );
    if( pdrv->cMonitors > 1 )
    {
	#ifdef WIN95
	    /*
	     * First, get the device rectangle
	     */
	    ZeroMemory( &dm, sizeof(dm) );
	    dm.dmSize = sizeof(dm);

	    // Get the DevMode for current settings
	    if( _stricmp( pdrv->cDriverName, DISPLAY_STR ) == 0 )
	    {
	        // Don't need g_szPrimaryDisplay here, just use NULL!!!
	        EnumDisplaySettings( g_szPrimaryDisplay, ENUM_CURRENT_SETTINGS, &dm );
	    }
	    else
	    {
	        EnumDisplaySettings( pdrv->cDriverName, ENUM_CURRENT_SETTINGS, &dm );
	    }

	    //
	    // the position of the device is in the dmPosition field
	    // which happens to be unioned with dmOrientation. dmPosition isn't defined
	    // in our current header
	    //
	    // BUG-BUG:  After reading the definition of the DEVMODE struct in
	    // wingdi.h, I'm amazed that the entire dest rectangle should be
	    // stored at &dm.dmOrientation.  But the code below obviously works,
	    // so I'm reluctant to change it until I know what's going on.

	    CopyMemory( &pdrv->rectDevice, &dm.dmOrientation, sizeof(RECT) );
	#else
            if( GetNTDeviceRect( pdrv->cDriverName, &pdrv->rectDevice ) != DD_OK )
            {
        	pdrv->rectDevice.left =  0;
        	pdrv->rectDevice.top = 0;
        	pdrv->rectDevice.right = pdrv->vmiData.dwDisplayWidth;
        	pdrv->rectDevice.bottom = pdrv->vmiData.dwDisplayHeight;
            }
	#endif
    }
    if( ( pdrv->cMonitors <= 1 ) || IsRectEmpty( &pdrv->rectDevice ) )
    {
	pdrv->rectDevice.left =  0;
	pdrv->rectDevice.top = 0;
	pdrv->rectDevice.right = pdrv->vmiData.dwDisplayWidth;
	pdrv->rectDevice.bottom = pdrv->vmiData.dwDisplayHeight;
    }

    DPF( 1, W, "Device's rect is %d, %d, %d, %d", pdrv->rectDevice.left, pdrv->rectDevice.top, pdrv->rectDevice.right, pdrv->rectDevice.bottom );

    /*
     * Now get the desktop rect.  If we are in virtual desktop mode,
     * we will get the whole dektop; otherwise, we will use the device
     * rectangle.
     */
    // BUG-BUG:  The VIRTUALDESKTOP and ATTACHEDTODESKTOP flags referred to
    // below are never set if we reach this point when we're creating a new
    // surface.  That means that in a multimon system, pdrv->rectDesktop
    // gets set to pdrv->rectDevice instead of to the full desktop.
    if( ( pdrv->dwFlags & DDRAWI_VIRTUALDESKTOP ) &&
	( pdrv->dwFlags & DDRAWI_ATTACHEDTODESKTOP ) )
    {
	int x, y;
	x = GetSystemMetrics( SM_XVIRTUALSCREEN );  // left
	y = GetSystemMetrics( SM_YVIRTUALSCREEN );  // right

	SetRect(    &pdrv->rectDesktop,
		    x,  // left
		    y,  // top
		    x + GetSystemMetrics( SM_CXVIRTUALSCREEN ), // right
		    y + GetSystemMetrics( SM_CYVIRTUALSCREEN ) // bottom
		    );

    }
    else
    {
	memcpy( &pdrv->rectDesktop, &pdrv->rectDevice, sizeof( RECT ) );
    }

    DPF( 1, W, "Desktop's rect is %d, %d, %d, %d", pdrv->rectDesktop.left, pdrv->rectDesktop.top, pdrv->rectDesktop.right, pdrv->rectDesktop.bottom );

    return;
}

/*
 * IsVGADevice()
 *
 * determine if the passed device name is a VGA
 *
 */
BOOL IsVGADevice(LPSTR szDevice)
{
    //
    //  assume "DISPLAY" and "DISPLAY1" are VGA devices
    //
    if (_stricmp(szDevice, DISPLAY_STR) == 0)
	return TRUE;

    return FALSE;
}

/*
 * number of callbacks in a CALLBACK struct
 */
#define NUM_CALLBACKS( ptr ) ((ptr->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID ))

#if defined( WIN95 )
/*
 * loadSecondaryDriver
 *
 * Determine if a secondary DirectDraw driver key is present in the registry.
 * If it is extract the DLL name and (optional) entry point to invoke. Load
 * the DLL in DDHELP's address space, get the validation entry point and
 * invoke it. If it returns TRUE and gives us back a GUID we have certified
 * as a secondary driver, call its HAL patching function.
 *
 * If any of this stuff fails we simply ignore the error. No secondary driver
 * - no problem.
 *
 * Returns TRUE if a secondary is successfully loaded.
 */
static BOOL loadSecondaryDriver( LPDDHALINFO lpDDHALInfo )
{
    HKEY                     hKey;
    DWORD                    dwType;
    DWORD                    dwSize;
    LPSECONDARY_VALIDATE     fpValidate;
    LPSECONDARY_PATCHHALINFO fpPatchHALInfo;
    char                     szDriverName[MAX_SECONDARY_DRIVERNAME];
    char                     szEntryPoint[MAX_SECONDARY_ENTRYPOINTNAME];
    GUID                     guid;
    BOOL                     bLoaded = FALSE;

    /*
     * Any secondary driver information in the registry at all?
     */
    if( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE,
				     REGSTR_PATH_SECONDARY,
				     &hKey ) )
    {
	/*
	 * Extract the entry point of the secondary driver. If no entry
	 * point is specified we will use the default instead.
	 */
	dwSize = sizeof( szEntryPoint ) - 1;
	if( ERROR_SUCCESS == RegQueryValueEx( hKey,
					      REGSTR_VALUE_SECONDARY_ENTRYPOINTNAME,
					      NULL,
					      &dwType,
					      szEntryPoint,
					      &dwSize ) )
	{
	    if( REG_SZ != dwType )
	    {
		/*
		 * Key is not a string. Bail.
		 */
		RegCloseKey( hKey );
		return FALSE;
	    }
	}
	else
	{
	    /*
	     * No entry point sepecified. Use the default.
	     */
	    lstrcpy( szEntryPoint, DEFAULT_SECONDARY_ENTRYPOINTNAME );
	}

	/*
	 * Extract the name of the secondary driver's DLL.
	 */
	dwSize = sizeof( szDriverName ) - 1;
	if( ERROR_SUCCESS == RegQueryValueEx( hKey,
					      REGSTR_VALUE_SECONDARY_DRIVERNAME,
					      NULL,
					      &dwType,
					      szDriverName,
					      &dwSize ) )
	{
	    if( REG_SZ == dwType )
	    {
		/*
		 * Now ask DDHELP to load this DLL and invoke the entry point specified.
		 * The value returned by DDHELP will be the address of the secondary
		 * driver's validation function if all went well.
		 */
		#if defined(WIN95)
		    LEAVE_WIN16LOCK();
		#endif
		fpValidate = (LPSECONDARY_VALIDATE)HelperLoadDLL( szDriverName, szEntryPoint, 0UL );
		#if defined(WIN95)
		    ENTER_WIN16LOCK();
		#endif
		if( NULL != fpValidate )
		{
		    /*
		     * Now we need to invoke the validate entry point to ensure that
		     * the secondary driver has been certified by us (and that it actually
		     * wants to run).
		     */
		    fpPatchHALInfo = (fpValidate)( &guid );
		    if( NULL != fpPatchHALInfo )
		    {
			/*
			 * Got returned a non-NULL HAL patching function so the secondary
			 * driver wishes to run. However, we need to verify that the driver
			 * is one we have certified as being OK to run. Check the guid.
			 */
			if( IsEqualIID( &guid, &guidCertifiedSecondaryDriver ) )
			{
                            LPVOID  pFlipRoutine = (LPVOID) lpDDHALInfo->lpDDSurfaceCallbacks->Flip;

			    /*
			     * Its a certified secondary driver so invoke its HAL patching
			     * function with the given HAL info and callback thunks.
			     * The rule is if this function failes the DDHALINFO must be
			     * unmodified so we can carry on regardless.
			     */
			    (*fpPatchHALInfo)(lpDDHALInfo, &ddHALDD, &ddHALDDSurface, &ddHALDDPalette, &ddHALDDExeBuf);

                            //
                            // Only say we loaded it if the HALInfo was changed, specifically if the PVR took
                            // over the surface flip routine. This is an absolute must for the PVR.
                            // If the PVR is turned off via the control panel, then this fn pointer will be unchanged,
                            // and we can know later not to enumerate the PVR via GetDeviceIdentifier.
                            //
                            if (pFlipRoutine != (LPVOID) lpDDHALInfo->lpDDSurfaceCallbacks->Flip) 
                            {
                                bLoaded = TRUE;
                            }
			}
		    }
		}
	    }
	}
	RegCloseKey( hKey );
    }

    return bLoaded;
}
#endif /* WIN95 */

/*
 * mergeHELCaps
 *
 * merge HEL caps with default caps
 */
static void mergeHELCaps( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    int i;

    if( pdrv->dwFlags & DDRAWI_EMULATIONINITIALIZED )
    {
	pdrv->ddBothCaps.dwCaps &= pdrv->ddHELCaps.dwCaps;
	pdrv->ddBothCaps.dwCaps2 &= pdrv->ddHELCaps.dwCaps2;
	pdrv->ddBothCaps.dwCKeyCaps &= pdrv->ddHELCaps.dwCKeyCaps;
	pdrv->ddBothCaps.dwFXCaps &= pdrv->ddHELCaps.dwFXCaps;
	pdrv->lpddBothMoreCaps->dwAlphaCaps &= pdrv->lpddHELMoreCaps->dwAlphaCaps;
	pdrv->lpddBothMoreCaps->dwFilterCaps &= pdrv->lpddHELMoreCaps->dwFilterCaps;
#ifdef POSTPONED2
	pdrv->lpddBothMoreCaps->dwTransformCaps &= pdrv->lpddHELMoreCaps->dwTransformCaps;
#endif //POSTPONED2

	pdrv->ddBothCaps.dwSVBCaps &= pdrv->ddHELCaps.dwSVBCaps;
	pdrv->ddBothCaps.dwSVBCKeyCaps &= pdrv->ddHELCaps.dwSVBCKeyCaps;
	pdrv->ddBothCaps.dwSVBFXCaps &= pdrv->ddHELCaps.dwSVBFXCaps;
	pdrv->lpddBothMoreCaps->dwSVBAlphaCaps &= pdrv->lpddHELMoreCaps->dwSVBAlphaCaps;
	pdrv->lpddBothMoreCaps->dwSVBFilterCaps &= pdrv->lpddHELMoreCaps->dwSVBFilterCaps;
#ifdef POSTPONED2
	pdrv->lpddBothMoreCaps->dwSVBTransformCaps &= pdrv->lpddHELMoreCaps->dwSVBTransformCaps;
#endif //POSTPONED2

	pdrv->ddBothCaps.dwVSBCaps &= pdrv->ddHELCaps.dwVSBCaps;
	pdrv->ddBothCaps.dwVSBCKeyCaps &= pdrv->ddHELCaps.dwVSBCKeyCaps;
	pdrv->ddBothCaps.dwVSBFXCaps &= pdrv->ddHELCaps.dwVSBFXCaps;
	pdrv->lpddBothMoreCaps->dwVSBAlphaCaps &= pdrv->lpddHELMoreCaps->dwVSBAlphaCaps;
	pdrv->lpddBothMoreCaps->dwVSBFilterCaps &= pdrv->lpddHELMoreCaps->dwVSBFilterCaps;
#ifdef POSTPONED2
	pdrv->lpddBothMoreCaps->dwVSBTransformCaps &= pdrv->lpddHELMoreCaps->dwVSBTransformCaps;
#endif //POSTPONED2

	pdrv->ddBothCaps.dwSSBCaps &= pdrv->ddHELCaps.dwSSBCaps;
	pdrv->ddBothCaps.dwSSBCKeyCaps &= pdrv->ddHELCaps.dwSSBCKeyCaps;
	pdrv->ddBothCaps.dwSSBFXCaps &= pdrv->ddHELCaps.dwSSBFXCaps;
	pdrv->lpddBothMoreCaps->dwSSBAlphaCaps &= pdrv->lpddHELMoreCaps->dwSSBAlphaCaps;
	pdrv->lpddBothMoreCaps->dwSSBFilterCaps &= pdrv->lpddHELMoreCaps->dwSSBFilterCaps;
#ifdef POSTPONED2
	pdrv->lpddBothMoreCaps->dwSSBTransformCaps &= pdrv->lpddHELMoreCaps->dwSSBTransformCaps;
#endif //POSTPONED2

	for( i=0;i<DD_ROP_SPACE;i++ )
	{
	    pdrv->ddBothCaps.dwRops[i] &= pdrv->ddHELCaps.dwRops[i];
	    pdrv->ddBothCaps.dwSVBRops[i] &= pdrv->ddHELCaps.dwSVBRops[i];
	    pdrv->ddBothCaps.dwVSBRops[i] &= pdrv->ddHELCaps.dwVSBRops[i];
	    pdrv->ddBothCaps.dwSSBRops[i] &= pdrv->ddHELCaps.dwSSBRops[i];
	}
	pdrv->ddBothCaps.ddsCaps.dwCaps &= pdrv->ddHELCaps.ddsCaps.dwCaps;

	if( NULL != pdrv->lpddNLVBothCaps )
	{
	    DDASSERT( NULL != pdrv->lpddNLVHELCaps );

	    pdrv->lpddNLVBothCaps->dwNLVBCaps     &= pdrv->lpddNLVHELCaps->dwNLVBCaps;
	    pdrv->lpddNLVBothCaps->dwNLVBCaps2    &= pdrv->lpddNLVHELCaps->dwNLVBCaps2;
	    pdrv->lpddNLVBothCaps->dwNLVBCKeyCaps &= pdrv->lpddNLVHELCaps->dwNLVBCKeyCaps;
	    pdrv->lpddNLVBothCaps->dwNLVBFXCaps   &= pdrv->lpddNLVHELCaps->dwNLVBFXCaps;
	    for( i = 0; i < DD_ROP_SPACE; i++ )
		pdrv->lpddNLVBothCaps->dwNLVBRops[i] &= pdrv->lpddNLVHELCaps->dwNLVBRops[i];
	}

	if( pdrv->lpddBothMoreCaps != NULL )
	{
	    DDASSERT( pdrv->lpddHELMoreCaps != NULL );

	    pdrv->lpddBothMoreCaps->dwAlphaCaps    &= pdrv->lpddHELMoreCaps->dwAlphaCaps;
	    pdrv->lpddBothMoreCaps->dwSVBAlphaCaps &= pdrv->lpddHELMoreCaps->dwSVBAlphaCaps;
	    pdrv->lpddBothMoreCaps->dwVSBAlphaCaps &= pdrv->lpddHELMoreCaps->dwVSBAlphaCaps;
	    pdrv->lpddBothMoreCaps->dwSSBAlphaCaps &= pdrv->lpddHELMoreCaps->dwSSBAlphaCaps;

	    pdrv->lpddBothMoreCaps->dwFilterCaps    &= pdrv->lpddHELMoreCaps->dwFilterCaps;
	    pdrv->lpddBothMoreCaps->dwSVBFilterCaps &= pdrv->lpddHELMoreCaps->dwSVBFilterCaps;
	    pdrv->lpddBothMoreCaps->dwVSBFilterCaps &= pdrv->lpddHELMoreCaps->dwVSBFilterCaps;
	    pdrv->lpddBothMoreCaps->dwSSBFilterCaps &= pdrv->lpddHELMoreCaps->dwSSBFilterCaps;

#ifdef POSTPONED2
	    pdrv->lpddBothMoreCaps->dwTransformCaps    &= pdrv->lpddHELMoreCaps->dwTransformCaps;
	    pdrv->lpddBothMoreCaps->dwSVBTransformCaps &= pdrv->lpddHELMoreCaps->dwSVBTransformCaps;
	    pdrv->lpddBothMoreCaps->dwVSBTransformCaps &= pdrv->lpddHELMoreCaps->dwVSBTransformCaps;
	    pdrv->lpddBothMoreCaps->dwSSBTransformCaps &= pdrv->lpddHELMoreCaps->dwSSBTransformCaps;
#endif //POSTPONED2
	}
    }
} /* mergeHELCaps */

// This variable is a shared instance and has been moved to dllmain.c: BOOL     bReloadReg;

/*
 * capsInit
 *
 * initialize shared caps
 */
static void capsInit( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    #ifdef DEBUG
	if( GetProfileInt("DirectDraw","nohwblt",0) )
	{
	    pdrv->ddCaps.dwCaps &= ~DDCAPS_BLT;
	    DPF( 2, "Turning off blt <<<<<<<<<<<<<<<<<<<<<<<<<<" );
	}
	if( GetProfileInt("DirectDraw","nohwtrans",0) )
	{
	    pdrv->ddCaps.dwCKeyCaps &= ~(DDCKEYCAPS_DESTBLT|DDCKEYCAPS_SRCBLT);
	    DPF( 2, "Turning off hardware transparency <<<<<<<<<<<<<<<<<<<<<<<<<<" );
	}
	if( GetProfileInt("DirectDraw","nohwfill",0) )
	{
	    pdrv->ddCaps.dwCaps &= ~(DDCAPS_BLTCOLORFILL);
	    DPF( 2, "Turning off color fill <<<<<<<<<<<<<<<<<<<<<<<<<<" );
	}
    #endif

    // initialize the BothCaps structure
    pdrv->ddBothCaps = pdrv->ddCaps;
    if( NULL != pdrv->lpddNLVCaps )
    {
	DDASSERT( NULL != pdrv->lpddNLVBothCaps );

	memcpy( pdrv->lpddNLVBothCaps, pdrv->lpddNLVCaps, sizeof( DDNONLOCALVIDMEMCAPS ) );
    }
    else if ( pdrv->lpddNLVBothCaps != NULL)
    {
        ZeroMemory( pdrv->lpddNLVBothCaps, sizeof( DDNONLOCALVIDMEMCAPS ) );
        pdrv->lpddNLVBothCaps->dwSize = sizeof( DDNONLOCALVIDMEMCAPS );
    }

    if( pdrv->lpddBothMoreCaps != NULL )
    {
	DDASSERT( pdrv->lpddMoreCaps != NULL );

	memcpy(pdrv->lpddBothMoreCaps, pdrv->lpddMoreCaps, sizeof(DDMORECAPS));
    }
} /* capsInit */

#ifdef WINNT
//
// pdd_gbl may be null (if coming from the create code path) or non null (from the reset code path).
// We assert that if pdd_gbl==NULL, then we can't be in an emulated ModeX mode, because the
// only way to get there is to use a ddraw object to set such a mode. So we only have to check
// for fake modex mode if pdd_gbl is non-null.
//
BOOL GetCurrentMode(LPDDRAWI_DIRECTDRAW_GBL pdd_gbl, LPDDHALINFO lpHalInfo, char *szDrvName)
{
    LPDDHALMODEINFO pmi;
    DEVMODE dm;
    HDC hdc;
    LPCTSTR pszDevice;

    pmi = MemAlloc(sizeof (DDHALMODEINFO));

    if (pmi)
    {
        pszDevice = _stricmp(szDrvName, DISPLAY_STR) ? szDrvName : NULL;

        ZeroMemory(&dm, sizeof dm);
        dm.dmSize = sizeof dm;

        if ( pdd_gbl && pdd_gbl->dwFlags & DDRAWI_MODEX )
        {
            // If the current mode is modex, then we could only have gotten here if
            // it's the current mode.
            pmi->dwWidth = pdd_gbl->dmiCurrent.wWidth;
            pmi->dwHeight = pdd_gbl->dmiCurrent.wHeight;
            pmi->dwBPP = pdd_gbl->dmiCurrent.wBPP;
            pmi->wRefreshRate = pdd_gbl->dmiCurrent.wRefreshRate;
            pmi->lPitch = pmi->dwWidth;
            pmi->dwRBitMask = 0;
            pmi->dwGBitMask = 0;
            pmi->dwBBitMask = 0;
            pmi->dwAlphaBitMask = 0;
        }
        else if (EnumDisplaySettings(pszDevice, ENUM_CURRENT_SETTINGS, &dm))
        {
            pmi->dwWidth = dm.dmPelsWidth;
            pmi->dwHeight = dm.dmPelsHeight;
            pmi->dwBPP = dm.dmBitsPerPel;
            pmi->wRefreshRate = (WORD) dm.dmDisplayFrequency;
            pmi->lPitch = (pmi->dwWidth * pmi->dwBPP) >> 3;

            if (pmi->dwBPP > 8)
            {
                void FillBitMasks(LPDDPIXELFORMAT pddpf, HDC hdc);
                DDPIXELFORMAT ddpf;

                hdc = DD_CreateDC(szDrvName);
                if (hdc)
                {
                    FillBitMasks(&ddpf, hdc);
                    DD_DoneDC(hdc);
                }

                if (pmi->dwBPP == 15)
                {
                    pmi->dwBPP = 16;
                    pmi->wFlags = DDMODEINFO_555MODE;
                }

                pmi->dwRBitMask = ddpf.dwRBitMask;
                pmi->dwGBitMask = ddpf.dwGBitMask;
                pmi->dwBBitMask = ddpf.dwBBitMask;
                pmi->dwAlphaBitMask = ddpf.dwRGBAlphaBitMask;
            }
            else
            {
                pmi->wFlags = DDMODEINFO_PALETTIZED;
            }

            lpHalInfo->dwNumModes = 1;
            lpHalInfo->dwMonitorFrequency = pmi->wRefreshRate;
        }
        else
        {
            MemFree(pmi);
            pmi = NULL;
        }
    }

    lpHalInfo->lpModeInfo = pmi;
    return pmi != NULL;
}
#endif

static HRESULT
GetDriverInfo(LPDDHAL_GETDRIVERINFO lpGetDriverInfo,
	      LPDDHAL_GETDRIVERINFODATA lpGDInfo,
	      LPVOID lpDriverInfo, 
              DWORD dwSize, 
              const GUID *lpGUID, 
              LPDDRAWI_DIRECTDRAW_GBL lpDD,
              BOOL bInOut)  // Indicates whether the data passed is in/out or just out
{
    int i;

    // 1K temp buffer to pull driver info into
    static DWORD dwDriverInfoBuffer[256];

    if (bInOut)
    {
        DDASSERT((dwSize & 3) == 0);

        // Copy over the data from our source
	memcpy(dwDriverInfoBuffer, lpDriverInfo, dwSize);

        // Only dead-beef the unused part of the buffer
        i = dwSize>>2;
    }
    else
    {
        i = 0;
    }

    for (i; i < 256; i += 1)
	dwDriverInfoBuffer[i] = 0xdeadbeef;

#ifdef DEBUG
    if(dwSize>255*sizeof(DWORD)) {  // 0xdeadbeef overwrite test wont work unless dwSize>>2 <= 255
       DPF_ERR("****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Internal DDraw Error:  GetDriverInfo() dwSize parameter > 1020");
       return DDERR_NODIRECTDRAWSUPPORT;
    }
#endif

    memset(lpGDInfo, 0, sizeof(*lpGDInfo) );
    lpGDInfo->dwSize = sizeof(*lpGDInfo);
    lpGDInfo->dwFlags = 0;
    memcpy(&lpGDInfo->guidInfo, lpGUID, sizeof(*lpGUID) );
    lpGDInfo->dwExpectedSize = dwSize;
    lpGDInfo->lpvData = dwDriverInfoBuffer;
    lpGDInfo->ddRVal = DDERR_GENERIC;

    // Pass a context variable so that the driver
    // knows which instance of itself to use
    // w.r.t. this function. These are different
    // values on Win95 and NT.
#ifdef WIN95
    lpGDInfo->dwContext = lpDD->dwReserved3;
#else
    lpGDInfo->dwContext = lpDD->hDD;
#endif

    if ( lpGetDriverInfo(lpGDInfo) == DDHAL_DRIVER_HANDLED && lpGDInfo->ddRVal == DD_OK )
    {
	// Fail if the driver wrote more bytes than the expected size
	if (dwDriverInfoBuffer[dwSize>>2] != 0xdeadbeef)
	{
	    return DDERR_NODIRECTDRAWSUPPORT;
	}
	memcpy(lpDriverInfo, dwDriverInfoBuffer, min(dwSize, lpGDInfo->dwActualSize));
    }
    return lpGDInfo->ddRVal;
}

static BOOL
ValidateCallbacks(LPVOID lpCallbacks)
{
    int N = ((((DWORD FAR *) lpCallbacks)[0] >> 2) - 2) / (sizeof(DWORD_PTR) / sizeof(DWORD));
    if (N > 0)
    {
	    DWORD dwFlags = ((DWORD FAR *) lpCallbacks)[1];
	    DWORD bit = 1;
	    int i;
        LPVOID *pcbrtn = (LPVOID *) &(((DWORD FAR *) lpCallbacks)[2]);
	    for (i = 0; i < N; i += 1)
	    {
            LPVOID cbrtn;
	        cbrtn = *pcbrtn++;

	        // If a function is non-NULL and they failed to set the
	        // 32-bit flag, fail.  We might support 16-bit callbacks
	        // in future but not for now.
	        if ( (cbrtn != NULL) && ( 0 == (dwFlags & bit) ) )
		        return FALSE;

	        if (dwFlags & bit)
	        {
#if defined(NT_FIX) || defined(WIN95)   // check this some other way            // If the bit is set, validate the callback.
		        if (! VALIDEX_CODE_PTR(cbrtn) )
		        {
		            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid 32-bit callback");
		            return FALSE;
		        }
#endif
	        }
	        bit <<= 1;
	    }
    }
    return TRUE;
}

/*
 * Validate the core HAL information the driver passed to us.
 */
BOOL
ValidateCoreHALInfo( LPDDHALINFO lpDDHALInfo )
{
    int                             i;
    LPVIDMEM                        pvm;
    int                             numcb;
    LPDDHAL_DDCALLBACKS             drvcb;
    LPDDHAL_DDSURFACECALLBACKS      surfcb;
    LPDDHAL_DDPALETTECALLBACKS      palcb;
    LPDDHAL_DDEXEBUFCALLBACKS       exebufcb;
    DWORD                           bit;
    LPVOID                          cbrtn;

    TRY
    {
	/*
	 * Valid HAL info
	 */
	if( !VALIDEX_DDHALINFO_PTR( lpDDHALInfo ) )
	{
            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF(0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid DDHALINFO provided: 0x%p",lpDDHALInfo );
	    if( lpDDHALInfo != NULL )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: size = was %d, expecting %d or %d", lpDDHALInfo->dwSize, sizeof( DDHALINFO ), sizeof( DDHALINFO_V1) );
	    }
	    return FALSE;
	}
	if( lpDDHALInfo->dwSize == sizeof( DDHALINFO_V1 ) )
	{
	    /*
	     * The DDHALINFO structure returned by the driver is in the DDHALINFO_V1
	     * format.  Convert it to the new DDHALINFO structure.
	     */
	    convertV1DDHALINFO( lpDDHALInfo );
	}

	/*
	 * validate video memory heaps
	 */
	for( i=0;i<(int)lpDDHALInfo->vmiData.dwNumHeaps;i++ )
	{
	    pvm = &lpDDHALInfo->vmiData.pvmList[i];
	    if( pvm->dwFlags & VIDMEM_ISNONLOCAL )
	    {
		/*
		 * NOTE: It is entirely legal to pass a NULL fpStart for a non-local
		 * heap. The start address is meaningless for non-local heaps.
		 */

		/*
		 * If the heap is non-local then the driver must have specified
		 * the DDCAPS2_NONLOCALVIDMEM. If it hasn't we fail the initialization.
		 */
		if( !( lpDDHALInfo->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM ) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Non-local video memory heap passed but DDCAPS2_NONLOCALVIDMEM not specified" );
		    return FALSE;
		}
	    }
	    else
	    {
		if( (pvm->fpStart == (FLATPTR) NULL) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid video memory fpStart pointer passed" );
		    return FALSE;
		}

		/*
		 * This is not a local video memory heap and WC is specified. Currently
		 * this is not legal.
		 */
		#pragma message( REMIND( "Look into enabling WC on local vid mem" ) )
		if( pvm->dwFlags & VIDMEM_ISWC )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Driver can't specify write combining with a local video memory heap" );
		    return FALSE;
		}
	    }
	}

	/*
	 * validate pixel format
	 *
	 * NOTE:  The dwSize check below may seem redundant since the DDPIXELFORMAT
	 * struct is embedded in a DDHAL struct whose size has already been validated.
	 * But removing this test caused stress failures with drivers that do not
	 * support DDraw.  The drivers were running "accelerated" but with virtually
	 * no caps.  So we'll keep this test until the problem is better understood.
	 */
	if( lpDDHALInfo->vmiData.ddpfDisplay.dwSize != sizeof( DDPIXELFORMAT ) )
	{
            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid DDPIXELFORMAT in DDHALINFO.vmiData: bad size" );
	    return FALSE;
	}
	/*
	 * DX4; Validate it some more.
	 */
	if ( (lpDDHALInfo->vmiData.ddpfDisplay.dwFlags & DDPF_PALETTEINDEXED8) &&
		(lpDDHALInfo->vmiData.ddpfDisplay.dwRGBBitCount != 8) )
	{
            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid DDPIXELFORMAT in DDHALINFO.vmiData: palettized mode must be 8bpp" );
	    return FALSE;
	}

	/*
	 * validate driver callback
	 */
	drvcb = lpDDHALInfo->lpDDCallbacks;
	if( drvcb != NULL )
	{
	    if( !VALID_PTR_PTR( drvcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid driver callback ptr" );
		return FALSE;
	    }
	    if( !VALIDEX_DDCALLBACKSSIZE( drvcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid size field in lpDriverCallbacks" );
		return FALSE;
	    }

	    numcb = NUM_CALLBACKS( drvcb );
	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( drvcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    cbrtn = (LPVOID) (&drvcb->DestroyDriver)[i];
		    if( cbrtn != NULL )
		    {
			#if defined(NT_FIX) || defined(WIN95)   // check this some other way
			    if( !VALIDEX_CODE_PTR( cbrtn ) )
			    {
				DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid 32-bit callback in lpDriverCallbacks" );
				return FALSE;
			    }
			#endif
		    }
		}
		bit <<= 1;
	    }
	}

	/*
	 * Turn off optimized surfaces just for now
	 */
	if (lpDDHALInfo->ddCaps.ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
	{
	    DPF_ERR("****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Driver tried to set DDSCAPS_OPTIMIZED. Not allowed for this release");
	    return FALSE;
	}

	/*
	 * We used to ensure that no driver ever set dwCaps2. However,
	 * we have now run out of bits in ddCaps.dwCaps so we need to
	 * allow drivers to set bits in dwCaps2. Hence all we do now
	 * is ensure that drivers don't try and impersonate certified
	 * drivers by returning DDCAPS2_CERTIFIED. This is something
	 * we turn on - they can't set it.
	 */
	if( lpDDHALInfo->ddCaps.dwCaps2 & DDCAPS2_CERTIFIED )
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Driver tried to set the DDCAPS2_CERTIFIED" );
	    return FALSE;
	}

	/*
	 * validate surface callbacks
	 */
	surfcb = lpDDHALInfo->lpDDSurfaceCallbacks;
	if( surfcb != NULL )
	{
	    if( !VALID_PTR_PTR( surfcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid surface callback ptr" );
		return FALSE;
	    }
	    if( !VALIDEX_DDSURFACECALLBACKSSIZE( surfcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid size field in lpSurfaceCallbacks" );
		return FALSE;
	    }
	    numcb = NUM_CALLBACKS( surfcb );
	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( surfcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    cbrtn = (LPVOID) (&surfcb->DestroySurface)[i];
		    if( cbrtn != NULL )
		    {
			#if defined(NT_FIX) || defined(WIN95) //check some other way
			    if( !VALIDEX_CODE_PTR( cbrtn ) )
			    {
				DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid 32/64-bit callback in lpSurfaceCallbacks" );
                                // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
				DPF( 0, "Callback = 0x%p, i = %d, bit = 0x%08lx", cbrtn, i, bit );
				return FALSE;
			    }
			#endif
		    }
		}
		bit <<= 1;
	    }
	}

	/*
	 * validate palette callbacks
	 */
	palcb = lpDDHALInfo->lpDDPaletteCallbacks;
	if( palcb != NULL )
	{
	    if( !VALID_PTR_PTR( palcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid palette callback ptr" );
		return FALSE;
	    }
	    if( !VALIDEX_DDPALETTECALLBACKSSIZE( palcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid size field in lpPaletteCallbacks" );
		return FALSE;
	    }
	    numcb = NUM_CALLBACKS( palcb );
	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( palcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    cbrtn = (LPVOID) (&palcb->DestroyPalette)[i];
		    if( cbrtn != NULL )
		    {
			#if defined(NT_FIX) || defined(WIN95)
			    if( !VALIDEX_CODE_PTR( cbrtn ) )
			    {
				DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid 32-bit callback in lpPaletteCallbacks" );
				return FALSE;
			    }
			#endif
		    }
		}
		bit <<= 1;
	    }
	}

	/*
	 * validate execute buffer callbacks - but only (and I mean ONLY) if
	 * its a V2 driver and it knows about execute buffers.
	 */
	if( lpDDHALInfo->dwSize >= DDHALINFOSIZE_V2 )
	{
	    exebufcb = lpDDHALInfo->lpDDExeBufCallbacks;
	    if( exebufcb != NULL )
	    {
		if( !VALID_PTR_PTR( exebufcb ) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid execute buffer callback ptr" );
		    return FALSE;
		}
		if( !VALIDEX_DDEXEBUFCALLBACKSSIZE( exebufcb ) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid size field in lpExeBufCallbacks" );
		    return FALSE;
		}
		numcb = NUM_CALLBACKS( exebufcb );
		bit = 1;
		for( i=0;i<numcb;i++ )
		{
		    if( exebufcb->dwFlags & bit )
		    {
                        // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
			cbrtn = (LPVOID) (&exebufcb->CanCreateExecuteBuffer)[i];
			if( cbrtn != NULL )
			{
			    #if defined(NT_FIX) || defined(WIN95)
				if( !VALIDEX_CODE_PTR( cbrtn ) )
				{
				    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid 32-bit callback in lpExeBufCallbacks" );
				    return FALSE;
				}
			    #endif
			}
		    }
		    bit <<= 1;
		}
	    }
	}

	/*
	 * Make sure a mode table was specified
	 */
	if( ( lpDDHALInfo->dwNumModes > 0 ) &&
	    ( lpDDHALInfo->lpModeInfo == NULL ) )
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Driver says modes are supported, but DDHALINFO.lpModeInfo = NULL" );
	    return FALSE;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Exception encountered validating driver HAL information" );
	DEBUG_BREAK();
	return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the new HAL information from a driver (if any) and validate it.
 */
static BOOL
GetAndValidateNewHALInfo( LPDDRAWI_DIRECTDRAW_GBL pddd,
			  LPDDHALINFO             lpDDHALInfo )
{
    pddd->lpD3DHALCallbacks2 = 0;
    pddd->lpD3DHALCallbacks3 = 0;
    pddd->lpZPixelFormats = NULL;
    pddd->pGetDriverInfo = NULL;
#ifdef POSTPONED
    pddd->lpDDUmodeDrvInfo = NULL;
    pddd->lpDDOptSurfaceInfo = NULL;
#endif

    TRY
    {
	memset(&pddd->lpDDCBtmp->HALDDMiscellaneous, 0, sizeof(pddd->lpDDCBtmp->HALDDMiscellaneous) );
	memset(&pddd->lpDDCBtmp->HALDDMiscellaneous2, 0, sizeof(pddd->lpDDCBtmp->HALDDMiscellaneous2) );
#ifndef WIN95
        memset(&pddd->lpDDCBtmp->HALDDNT, 0, sizeof(pddd->lpDDCBtmp->HALDDNT) );
#endif
	memset(&pddd->lpDDCBtmp->HALDDVideoPort, 0, sizeof(pddd->lpDDCBtmp->HALDDVideoPort) );
	memset(&pddd->lpDDCBtmp->HALDDColorControl, 0, sizeof(pddd->lpDDCBtmp->HALDDColorControl) );
	memset(&pddd->lpDDCBtmp->HALDDKernel, 0, sizeof(pddd->lpDDCBtmp->HALDDKernel) );

	    /*
	     * Allocate memory for D3D DDI interfaces queried from GetDriverInfo
	     * (the freeing of this memory for failed driver init needs work)
	     */
	pddd->lpD3DHALCallbacks2 = MemAlloc( D3DHAL_CALLBACKS2SIZE );
	if (! pddd->lpD3DHALCallbacks2)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Out of memory querying D3DCallbacks2" );
	    goto failed;
	}
	pddd->lpD3DHALCallbacks3 = MemAlloc( D3DHAL_CALLBACKS3SIZE );
	if (! pddd->lpD3DHALCallbacks3)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Out of memory querying D3DCallbacks3" );
	    goto failed;
	}

#ifdef POSTPONED
	pddd->lpDDUmodeDrvInfo =
	    (LPDDUMODEDRVINFO) MemAlloc (sizeof (DDUMODEDRVINFO));
	if (! pddd->lpDDUmodeDrvInfo)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Out of memory querying UserModeDriverInfo" );
	    goto failed;
	}
#endif

	if ( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET )
	{
	    HRESULT ret;
	    DDHAL_GETDRIVERINFODATA gdidata;
	    D3DHAL_CALLBACKS2 D3DCallbacks2;
	    D3DHAL_CALLBACKS3 D3DCallbacks3;

	    if (! VALIDEX_CODE_PTR (lpDDHALInfo->GetDriverInfo) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: GetDriverInfo callback bit set, but not valid" );
		goto failed;
	    }

        // use fact that code pointer was validated before...
        pddd->pGetDriverInfo=lpDDHALInfo->GetDriverInfo;

	    /*
	     * Probe the driver with a GUID of bogusness. If it claims to
	     * understand this one, then fail driver create.
	     */
	    {
		DWORD dwFakeGUID[4];
		DWORD dwTemp[10];

		memcpy(dwFakeGUID, &CLSID_DirectDraw, sizeof(dwFakeGUID));
		dwFakeGUID[3] += GetCurrentProcessId();

		ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				    dwTemp,
				    sizeof(dwTemp),
				    (const GUID *) dwFakeGUID, pddd,
                                    FALSE /* bInOut */);
		if ( ret == DD_OK )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Driver claimed support via GetDriverInfo for bogus GUID!" );
		    goto failed;
		}
	    }

            /*
             * Notify driver about DXVERSION on NT
             */
#ifndef WIN95
            if (lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFO2)
            {
                // This buffer is used to pass information down to the driver and get
                // information back from the driver. The GetDriverInfo2 header and
                // any additional information to pass to the driver is copied into this
                // buffer prior to calling GetDriverInfo2. After the call the information
                // returned by the driver is contained in this buffer. All information
                // passed to and from the driver must fit within a buffer of this size.

                // The buffer used by GetDriverInfo2 is constrained to the maximum size
                // specified below by restrictions in the Win2K kernel. It is vital that
                // all data passed to the driver and received from the driver via
                // GetDriverInfo2 fit within a buffer of this number of DWORDS.
                // This size has to be less than 1K to let the kernel do its own buffer
                // overwrite testing.
                #define MAX_GDI2_BUFFER_DWORD_SIZE (249)

                DWORD                  buffer[MAX_GDI2_BUFFER_DWORD_SIZE];
                DD_DXVERSION*          pDXVersion;
        
                // Set up the DXVersion call
                memset(&buffer, 0, sizeof(buffer));
                pDXVersion = (DD_DXVERSION *)buffer;

                // Before we do anything else, we notify the
                // driver about the DX version information. We ignore
                // errors here.
                pDXVersion->gdi2.dwReserved     = sizeof(DD_STEREOMODE);
                pDXVersion->gdi2.dwMagic        = D3DGDI2_MAGIC;
                pDXVersion->gdi2.dwType         = D3DGDI2_TYPE_DXVERSION;
                pDXVersion->gdi2.dwExpectedSize = sizeof(DD_DXVERSION);
                pDXVersion->dwDXVersion         = DD_RUNTIME_VERSION;

                // We assert the sizes are the same because we need to
                // persuade the kernel into accepting this call.
                DDASSERT(sizeof(DD_STEREOMODE) == sizeof(DD_DXVERSION));

	        ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				    buffer,
				    sizeof(DD_STEREOMODE),
				    &GUID_GetDriverInfo2, pddd,
                                    TRUE /* bInOut */);

                // Errors are ignored here
                ret = 0;

                // Also notify the driver that we have the AGP aliasing
                // work-around in place.
                {
                    DD_DEFERRED_AGP_AWARE_DATA  aad;
                    DWORD                       dwDrvRet;

                    GetDriverInfo2(pddd,
                                   &dwDrvRet,
                                   D3DGDI2_TYPE_DEFERRED_AGP_AWARE,
                                   sizeof(aad), &aad);
                }
            }
#endif // !WIN95

	    memset(&pddd->lpDDCBtmp->HALDDMiscellaneous, 0, sizeof(DDHAL_DDMISCELLANEOUSCALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&pddd->lpDDCBtmp->HALDDMiscellaneous,
				sizeof(DDHAL_DDMISCELLANEOUSCALLBACKS),
				&GUID_MiscellaneousCallbacks, pddd,
                                FALSE /* bInOut */ );
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_DDMISCELLANEOUSCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDMiscellaneous ) ||
		    ( gdidata.dwActualSize < sizeof(DDHAL_DDMISCELLANEOUSCALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDMiscellaneous) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous): flags set incorrectly" );
		    goto failed;
		}

	    }

	    // Get HALDDMiscellaneous2 interface.
	    memset(&pddd->lpDDCBtmp->HALDDMiscellaneous2, 0, sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&pddd->lpDDCBtmp->HALDDMiscellaneous2,
				sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS),
				&GUID_Miscellaneous2Callbacks, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous2): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_DDMISCELLANEOUS2CALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDMiscellaneous2 ) ||
		    ( gdidata.dwActualSize < sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous2): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDMiscellaneous2) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous2): flags set incorrectly" );
		    goto failed;
		}

                if (lpDDHALInfo->lpD3DGlobalDriverData &&
                    (lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & 
                     (D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWTRANSFORMANDLIGHT) )
                   )
                {
                    // If a driver responds to the Misc2 GUID, then it better return
                    // a non-null GetDriverState callback.
		    if (0 == pddd->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState)
		    {
		        DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (HALDDMiscellaneous2): no GetDriverState support" );
		        goto failed;
		    }
#ifdef WIN95
                    // On Win95 the CreateSurfaceEx should be non-NULL
		    if (0 == pddd->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx)
		    {
		        DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (HALDDMiscellaneous2): CreateSurfaceEx must be reported with D3DDEVCAPS_DRAWPRIMITIVES2EX" );
		        goto failed;
		    }
#else //WIN95
                    // DX7 drivers should export GetDriverState always, if they 
                    // didnt, then most likely they are the transition drivers that 
                    // are still DX6 and will need to be updated. For now dont 
                    // validate the presence of this callback. Simply use its 
                    // presence or absence to spoof the legacy texture callbacks.
                    DDASSERT( lpDDHALInfo->lpD3DHALCallbacks->TextureCreate  == NULL);
                    DDASSERT( lpDDHALInfo->lpD3DHALCallbacks->TextureDestroy == NULL);
                    DDASSERT( lpDDHALInfo->lpD3DHALCallbacks->TextureSwap    == NULL);
                    DDASSERT( lpDDHALInfo->lpD3DHALCallbacks->TextureGetSurf == NULL);
#endif //WIN95
                }
	    }

#ifdef WIN95
	    if (0 != pddd->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx)
	    {
                if (lpDDHALInfo->lpD3DGlobalDriverData)
                {
                    if (!(lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & 
                        D3DDEVCAPS_DRAWPRIMITIVES2EX))
                    {
                        if(lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & 
                            D3DPRASTERCAPS_ZBUFFERLESSHSR)
                        //legacy powerVR stackable driver would actually forward new callbacks
                        //if the primary driver supports the new callbacks
                        {
                            pddd->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx=0;
                            pddd->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState=0;
                            pddd->lpDDCBtmp->HALDDMiscellaneous2.DestroyDDLocal=0;
                        }
                        else
                        {
                    
		            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (HALDDMiscellaneous2): CreateSurfaceEx must be reported with D3DDEVCAPS_DRAWPRIMITIVES2EX" );
		            goto failed;
                        }
                    }
                }
	    }
#else   //WIN95
            memset(&pddd->lpDDCBtmp->HALDDNT, 0, sizeof(DDHAL_DDNTCALLBACKS) );
            /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
            ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
                                &pddd->lpDDCBtmp->HALDDNT,
                                sizeof(DDHAL_DDNTCALLBACKS),
                                &GUID_NTCallbacks, pddd,
                                FALSE /* bInOut */);
            // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
            // overwrote its buffer.

            if ( ret == DDERR_NODIRECTDRAWSUPPORT )
            {
                DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (NT): Driver overwrote callbacks buffer" );
                goto failed;
            }

            if ( ret == DD_OK )
            {
                // Fail create if driver already failed validation or
                // claims support but it's not valid.

                if (! VALIDEX_DDNTCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDNT ) ||
                    ( gdidata.dwActualSize < sizeof(DDHAL_DDNTCALLBACKS ) ) )

                {
                    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (NT): size not valid" );
                    goto failed;
                }

                if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDNT) )
                {
                    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (NT): flags set incorrectly" );
                    goto failed;
                }
            }

            memset(&pddd->lpDDCBtmp->HALDDVPE2, 0, sizeof(DDHAL_DDVPE2CALLBACKS) );
            /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
            ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
                                &pddd->lpDDCBtmp->HALDDVPE2,
                                sizeof(DDHAL_DDVPE2CALLBACKS),
                                &GUID_VPE2Callbacks, pddd,
                                FALSE /* bInOut */);
            // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
            // overwrote its buffer.

            if ( ret == DDERR_NODIRECTDRAWSUPPORT )
            {
                DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VPE2): Driver overwrote callbacks buffer" );
                goto failed;
            }

            if ( ret == DD_OK )
            {
                // Fail create if driver already failed validation or
                // claims support but it's not valid.

                if (! VALIDEX_DDVPE2CALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDVPE2 ) ||
                    ( gdidata.dwActualSize < sizeof(DDHAL_DDVPE2CALLBACKS ) ) )

                {
                    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VPE2): size not valid" );
                    goto failed;
                }

                if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDVPE2) )
                {
                    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VPE2): flags set incorrectly" );
                    goto failed;
                }
            }
#endif

	    memset(&pddd->lpDDCBtmp->HALDDVideoPort, 0, sizeof(DDHAL_DDVIDEOPORTCALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&pddd->lpDDCBtmp->HALDDVideoPort,
				sizeof(DDHAL_DDVIDEOPORTCALLBACKS),
				&GUID_VideoPortCallbacks, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.
	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VideoPort): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_DDVIDEOPORTCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDVideoPort ) ||
		    ( gdidata.dwActualSize < sizeof(DDHAL_DDVIDEOPORTCALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VideoPort): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDVideoPort) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VideoPort): flags set incorrectly" );
		    goto failed;
		}
	    }

            memset(&pddd->lpDDCBtmp->HALDDMotionComp, 0, sizeof(DDHAL_DDMOTIONCOMPCALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
                                &pddd->lpDDCBtmp->HALDDMotionComp,
                                sizeof(DDHAL_DDMOTIONCOMPCALLBACKS),
                                &GUID_MotionCompCallbacks, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.
	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (MotionComp): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

                if (! VALIDEX_DDMOTIONCOMPCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDMotionComp ) ||
                    ( gdidata.dwActualSize < sizeof(DDHAL_DDMOTIONCOMPCALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (MotionComp): size not valid" );
		    goto failed;
		}

                if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDMotionComp) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (MotionComp): flags set incorrectly" );
		    goto failed;
		}
	    }

	    memset(&pddd->lpDDCBtmp->HALDDColorControl, 0, sizeof(DDHAL_DDCOLORCONTROLCALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&pddd->lpDDCBtmp->HALDDColorControl,
				sizeof(DDHAL_DDCOLORCONTROLCALLBACKS),
				&GUID_ColorControlCallbacks, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (ColorControl): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_DDCOLORCONTROLCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDColorControl ) ||
		    ( gdidata.dwActualSize < sizeof(DDHAL_DDCOLORCONTROLCALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (ColorControl): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDColorControl) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (ColorControl): flags set incorrectly" );
		    goto failed;
		}
	    }

	    /*
	     *  Probe and validate D3DCallbacks2 support
	     */
	    // memset assures Clear2 will be NULL for DX5 drivers
	    memset(&D3DCallbacks2, 0, D3DHAL_CALLBACKS2SIZE );

	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&D3DCallbacks2, D3DHAL_CALLBACKS2SIZE,
				&GUID_D3DCallbacks2, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_D3DCALLBACKS2SIZE (&D3DCallbacks2 ))
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&D3DCallbacks2) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): flags set incorrectly" );
		    goto failed;
		}

		if  ( (D3DCallbacks2.DrawOnePrimitive ||
		       D3DCallbacks2.DrawOneIndexedPrimitive ||
		       D3DCallbacks2.DrawPrimitives) &&
		      (! (D3DCallbacks2.DrawOnePrimitive &&
			  D3DCallbacks2.DrawOneIndexedPrimitive &&
			  D3DCallbacks2.DrawPrimitives) ) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): must export all or none of DrawPrimitive callbacks" );
		    goto failed;
		}

#if 0
		if ( D3DCallbacks2.DrawOnePrimitive )
		{
		    // If they export DrawPrimitive driver entry points but did
		    // not set D3DDEVCAPS_DRAWPRIMTLVERTEX, fail driver create.
		    if (! (lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_DRAWPRIMTLVERTEX) )
		    {
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): DrawPrimitive entry points exported" );
			DPF_ERR( "from driver but D3DDEVCAPS_DRAWPRIMTLVERTEX not set" );
			goto failed;
		    }

		}
		else
		{
		    // If they set the caps but don't export the entry points,
		    // fail driver create.
		    if (lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_DRAWPRIMTLVERTEX )
		    {
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): D3DDEVCAPS_DRAWPRIMTLVERTEX set" );
			DPF_ERR( "but no DrawPrimitive entry points exported" );
			goto failed;
		    }

		}
#endif

		memcpy((LPVOID) pddd->lpD3DHALCallbacks2, &D3DCallbacks2, D3DHAL_CALLBACKS2SIZE);

	    }
	    else{
		memset((LPVOID) pddd->lpD3DHALCallbacks2, 0, D3DHAL_CALLBACKS2SIZE );
	    }

	    /*
	     *  Probe and validate D3DCallbacks3 support
	     */
	    memset(&D3DCallbacks3, 0, D3DHAL_CALLBACKS3SIZE );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&D3DCallbacks3, D3DHAL_CALLBACKS3SIZE,
				&GUID_D3DCallbacks3, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3): Driver overwrote callbacks buffer" );
            goto failed;
        }

	    if ( ret == DD_OK
#ifdef WIN95    // currently enforced in win95 to only make PowerVR DX5 driver work
		&& (lpDDHALInfo->lpD3DGlobalDriverData &&
                (lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2) )
#endif  //WIN95
	       )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_D3DCALLBACKS3SIZE (&D3DCallbacks3 ) ||
		    ( gdidata.dwActualSize < D3DHAL_CALLBACKS3SIZE ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&D3DCallbacks3) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3): flags set incorrectly" );
		    goto failed;
		}

		// DrawPrimitives2, ValidateTextureStageState and are the compulsory
        // DDI in Callbacks3 DX6+ drivers support TextureStages, hence it is
        // reasonable to require them to support ValidateTextureStageState
		if (0 == D3DCallbacks3.DrawPrimitives2)
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3): no DrawPrimitives2 support" );
		    goto failed;
		}
		if (0 == D3DCallbacks3.ValidateTextureStageState)
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3): no ValidateTextureStageState support" );
		    goto failed;
		}
#ifdef WIN95
		// Now pass the driver the callback pointer to parse unknown
		// execute-buffer commands.
		// If this call fails then fail creating the driver. We need
		// to be this harsh so that the IHVs are forced to
		// implement this callback!
		memset(&gdidata, 0, sizeof(gdidata) );
		gdidata.dwSize = sizeof(gdidata);
		gdidata.dwFlags = 0;
		gdidata.dwContext = pddd->dwReserved3;
		memcpy(&gdidata.guidInfo, &GUID_D3DParseUnknownCommandCallback, sizeof(GUID_D3DParseUnknownCommandCallback) );
		gdidata.dwExpectedSize = 0;
		gdidata.lpvData = &D3DParseUnknownCommand; // We pass the pointer to function
		gdidata.ddRVal = DDERR_GENERIC;
		ret = lpDDHALInfo->GetDriverInfo(&gdidata);
		if (ret != DDHAL_DRIVER_HANDLED || gdidata.ddRVal != DD_OK)
		{
		    // Fail driver creation!
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3) GUID_D3DParseUnknownCommandCallback not recognized, fail driver creation" );
		    goto failed;
		}
#endif
		memcpy((LPVOID) pddd->lpD3DHALCallbacks3, &D3DCallbacks3, D3DHAL_CALLBACKS3SIZE);

	    }
	    else{
                if (lpDDHALInfo->lpD3DGlobalDriverData)
                    lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps &= ~D3DDEVCAPS_DRAWPRIMITIVES2;
		memset((LPVOID) pddd->lpD3DHALCallbacks3, 0, D3DHAL_CALLBACKS3SIZE );
	    }

#if WIN95
	    memset(&pddd->lpDDCBtmp->HALDDKernel, 0, sizeof(DDHAL_DDKERNELCALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&pddd->lpDDCBtmp->HALDDKernel,
				sizeof(DDHAL_DDKERNELCALLBACKS),
				&GUID_KernelCallbacks, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Kernel): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_DDKERNELCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDKernel ) ||
		    ( gdidata.dwActualSize < sizeof(DDHAL_DDKERNELCALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Kernel): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDKernel) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Kernel): flags set incorrectly" );
		    goto failed;
		}
	    }
#endif

	    /*
	     * Get Z Pixel Formats, if driver supports this call.
	     * Ideally I'd like to handle this the same as TextureFormats, but
	     * D3DHAL_GLOBALDRIVERDATA is unexpandable if old drivers are to work,
	     * so must create new guid and graft this query onto callback validation
	     */
	    {
		DWORD tempbuf[249];  // make this <1K bytes or GetDriverInfo() fails cuz it cant do its "expected size overwrite" test within its own 1K tempbuffer

		// variable size field--delay mallocing space until we know how much is needed.
		// have GetDriverInfo stick results in tempbuf

		ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo,
				    &gdidata,
				    tempbuf,
				    sizeof(tempbuf),  // "expected" bytesize is 249*4, this allows for 31 DDPIXELFORMATs which should be enough
				    &GUID_ZPixelFormats, pddd,
                                    FALSE /* bInOut */);
		if(ret!=DD_OK)
		{
		    // A DX6+ driver (until we radically revamp our DDI) is
		    // one that responds to Callbacks3 (with DP2 support)
		    // This is a non-issue on NT, since the only DX6+ is
		    // available on it.

		    // DX6+ drivers have to field this GUID, if they
		    // report Clear2 (the DDI for stencil clear). No excuses!!
		    if (pddd->lpD3DHALCallbacks3->Clear2)
		    {
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: A DX6+ driver should report its ZPixelFormats");
			goto failed;
		    }
		    else
		    {
			DPF(2,"GetDriverInfo: ZPixelFormats not supported by driver");  // driver is pre-dx6
			pddd->dwNumZPixelFormats=0;   pddd->lpZPixelFormats=NULL;
		    }
		}
		else
		{

		    // verify returned buffer is of an expected size
		    if((gdidata.dwActualSize-sizeof(DWORD)) % sizeof(DDPIXELFORMAT) != 0) {
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Error in driver's ZPixelFormats query: driver returned bad-sized buffer");
			goto failed;
		    }

		    if((tempbuf[0]*sizeof(DDPIXELFORMAT)+sizeof(DWORD))>sizeof(tempbuf)) {
			DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Error: driver returned bogus number of Z Formats: %u",pddd->dwNumZPixelFormats );
			goto failed;
		    }

		    pddd->dwNumZPixelFormats=tempbuf[0];

		    pddd->lpZPixelFormats = MemAlloc(pddd->dwNumZPixelFormats*sizeof(DDPIXELFORMAT));

		    if (!pddd->lpZPixelFormats) {
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Out of memory querying Z Pixel Formats" );
			goto failed;
		    }

		    memcpy(pddd->lpZPixelFormats,&tempbuf[1],pddd->dwNumZPixelFormats*sizeof(DDPIXELFORMAT));

#ifdef DEBUG
		    // simple validation of pixel format fields
		    {
			DWORD ii;

			DPF(5,E,"Number of Z Pixel Formats: %u",pddd->dwNumZPixelFormats);
			for(ii=0;ii<pddd->dwNumZPixelFormats;ii++) {
			    DPF(5,E,"DDPF_ZBUFFER: %u, DDPF_STENCILBUFFER: %u",0!=(pddd->lpZPixelFormats[ii].dwFlags&DDPF_ZBUFFER),0!=(pddd->lpZPixelFormats[ii].dwFlags&DDPF_STENCILBUFFER));
			    DPF(5,E,"zbits %d, stencilbits %d, zbitmask %X, stencilbitmask %X",pddd->lpZPixelFormats[ii].dwZBufferBitDepth,
				pddd->lpZPixelFormats[ii].dwStencilBitDepth,pddd->lpZPixelFormats[ii].dwZBitMask,pddd->lpZPixelFormats[ii].dwStencilBitMask);
			    if(!(pddd->lpZPixelFormats[ii].dwFlags&DDPF_ZBUFFER)) {
				DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Error in driver's returned ZPixelFormats: ZBUFFER flag not set");
				goto failed;
			    }
			}
		    }
#endif //DEBUG
		}
	    }


	    DPF(4,E, "Done querying driver for callbacks");

	} // if ( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERCALLBACKSSET )
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Exception encountered validating driver HAL information" );
	DEBUG_BREAK();
	goto failed;
    }

    return TRUE;
failed:
    MemFree((LPVOID) pddd->lpZPixelFormats);
    pddd->lpZPixelFormats = 0;
    MemFree((LPVOID) pddd->lpD3DHALCallbacks2);
    pddd->lpD3DHALCallbacks2 = 0;
    MemFree((LPVOID) pddd->lpD3DHALCallbacks3);
    pddd->lpD3DHALCallbacks3 = 0;
#ifdef POSTPONED
    MemFree ((LPVOID) pddd->lpDDUmodeDrvInfo);
    pddd->lpDDUmodeDrvInfo = 0;
    MemFree ((LPVOID) pddd->lpDDOptSurfaceInfo);
    pddd->lpDDOptSurfaceInfo = 0;
#endif

    return FALSE;
}

/*
 * GetExtendedHeapAlignment
 * Call the driver to see if it requires alignment for the given heap.
 * Return a pointer to the filled-in alignment data within the block passed in
 * or NULL if failure or no alignment required.
 */
LPHEAPALIGNMENT GetExtendedHeapAlignment( LPDDRAWI_DIRECTDRAW_GBL pddd, LPDDHAL_GETHEAPALIGNMENTDATA pghad, int iHeap)
{
    HRESULT rc;
    LPDDHAL_GETHEAPALIGNMENT ghafn =
	pddd->lpDDCBtmp->HALDDMiscellaneous.GetHeapAlignment;

    DDASSERT(pghad);
    ZeroMemory((LPVOID)pghad,sizeof(*pghad));

    if( ghafn != NULL )
    {
	#ifdef WIN95
	    pghad->dwInstance = pddd->dwReserved3;
	#else
	    pghad->dwInstance = pddd->hDD;
	#endif
	pghad->dwHeap = (DWORD)iHeap;
	pghad->ddRVal = DDERR_GENERIC;
	pghad->Alignment.dwSize = sizeof(HEAPALIGNMENT);

	DOHALCALL_NOWIN16( GetHeapAlignment , ghafn, (*pghad), rc, FALSE );
	if ( (rc == DDHAL_DRIVER_HANDLED) && (pghad->ddRVal == DD_OK) )
	{
	    /*
	     * Validate alignment
	     */
	    if ( pghad->Alignment.ddsCaps.dwCaps & ~DDHAL_ALIGNVALIDCAPS )
	    {
		DPF(0,"****DirectDraw driver error****:Invalid alignment caps (at most %08x expected, %08x received) in heap %d",DDHAL_ALIGNVALIDCAPS, pghad->Alignment.ddsCaps.dwCaps,iHeap);
		return NULL;
	    }
	    /*
	     * Turning on this flag means that ComputePitch will ignore the
	     * legacy alignment fields in VIDMEMINFO for all heaps, not just
	     * iHeap.
	     */
	    DPF(5,V,"Driver reports extended alignment for heap %d",iHeap);
	    pddd->dwFlags |= DDRAWI_EXTENDEDALIGNMENT;
	    return & pghad->Alignment;
	}
    }
    return NULL;
}

/*
 * Get the non-local video memory blitting capabilities.
 */
BOOL GetNonLocalVidMemCaps( LPDDHALINFO lpDDHALInfo, LPDDRAWI_DIRECTDRAW_GBL pddd )
{
    DDASSERT( NULL != lpDDHALInfo );
    DDASSERT( NULL != pddd );
    DDASSERT( NULL == pddd->lpddNLVCaps );

    /*
     * We are forced to treat NLVHELCaps and NLVBothCaps differently. Originally, we were destroying
     * them here and letting a subsequent HELInit intiialize the HELCaps, and initcaps/mergeHELCaps
     * rebuild them. Trouble is, there's no HELInit along the reset code path (resetting a driver
     * object after a mode change). This means we were freeing the hel caps and never refilling them
     * after a mode switch. Since the HEL caps are mode-independent, we can get away with not releasing
     * the NLVHELCaps every mode switch. Now we will simply trust that once allocated, they are always valid.
     * After this routine is called, a subsequent initcaps/mergeHELCaps will regenerate the NLVBothCaps
     * from the driver caps (which may have changed- but we rebuilt them anyway) and the unchanging
     * HEL caps.
     *
     * I am leaving this code here commented out as documentation.
     *
     * if( NULL != pddd->lpddNLVHELCaps )
     * {
     *  MemFree( pddd->lpddNLVHELCaps );
     *  pddd->lpddNLVHELCaps = NULL;
     * }
     * if( NULL != pddd->lpddNLVBothCaps )
     * {
     *  MemFree( pddd->lpddNLVBothCaps );
     *  pddd->lpddNLVBothCaps = NULL;
     * }
     */

    if( lpDDHALInfo->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM )
    {
	DDNONLOCALVIDMEMCAPS ddNLVCaps;

	ZeroMemory( &ddNLVCaps, sizeof( ddNLVCaps ) );
	if( lpDDHALInfo->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS )
	{
	    HRESULT hres;

	    /*
	     * The driver has different capabilities for non-local video memory
	     * to local video memory blitting. If the driver has a GetDriverInfo
	     * entry point defined then query it. If the driver doesn't want to
	     * handle the query then just assume it has no non-local video memory
	     * capabilities.
	     */
	    hres = DDERR_GENERIC;
	    if( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET )
	    {
		DDHAL_GETDRIVERINFODATA gdiData;

		hres = GetDriverInfo( lpDDHALInfo->GetDriverInfo,
				      &gdiData,
				      &ddNLVCaps,
				      sizeof( DDNONLOCALVIDMEMCAPS ),
				      &GUID_NonLocalVidMemCaps,
				      pddd,
                                      FALSE /* bInOut */ );
		if( DD_OK == hres )
		{
		    /*
		     * We should never get back more data than we asked for.
		     */
		    DDASSERT( gdiData.dwActualSize <= sizeof( DDNONLOCALVIDMEMCAPS ) );

		    /*
		     * The driver thinks it worked. Check it has done something sensible.
		     */
		    if( ( ddNLVCaps.dwSize     < ( 2UL * sizeof( DWORD ) ) ) ||
			( gdiData.dwActualSize < ( 2UL * sizeof( DWORD ) ) ) )
		    {
			/*
			 * Invalid size returned by the driver. Fail initialization.
			 */
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not initialization. Invalid non-local vidmem caps returned by driver" );
			return FALSE;
		    }

		    /*
		     * We zeroed the structure before passing it to the driver so
		     * everything is cool if we got less data than we asked for.
		     * Just bump the size up to the expected size.
		     */
		    ddNLVCaps.dwSize = sizeof( DDNONLOCALVIDMEMCAPS );
		}
		else if ( DDERR_GENERIC != hres )
		{
		    /*
		     * If we failed for any other reason than generic (which means
		     * driver not handled in this scenario) then fail initialization.
		     * Things have gone badly wrong.
		     */
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Fatal error when querying for non-local video memory caps" );
		    return FALSE;
		}
	    }
	    if( DDERR_GENERIC == hres )
	    {
		/*
		 * Driver doesn't have a GetDriverInfo entry point or it does but doesn't
		 * want to handle GUID_GetNonLocalVidMemCaps. Assume this means no caps
		 * at all. The structure is already zeroed so just set the size.
		 */
		ddNLVCaps.dwSize = sizeof( DDNONLOCALVIDMEMCAPS );
	    }
	}
	else
	{
	    int i;

	    /*
	     * The driver does not have non-local video memory capabilities which
	     * are different from the video ones so just make the non-local case
	     * identical to the video memory ones.
	     */
	    ddNLVCaps.dwSize = sizeof( DDNONLOCALVIDMEMCAPS );

	    ddNLVCaps.dwNLVBCaps = lpDDHALInfo->ddCaps.dwCaps;
	    ddNLVCaps.dwNLVBCaps2 = lpDDHALInfo->ddCaps.dwCaps2;
	    ddNLVCaps.dwNLVBCKeyCaps = lpDDHALInfo->ddCaps.dwCKeyCaps;
	    ddNLVCaps.dwNLVBFXCaps = lpDDHALInfo->ddCaps.dwFXCaps;
	    for( i = 0; i < DD_ROP_SPACE; i++ )
		ddNLVCaps.dwNLVBRops[i] = lpDDHALInfo->ddCaps.dwRops[i];
	}
#ifndef WINNT
	/*
	 * Memphis: Max AGP is sysmem-12megs, same as VGARTD,
	 */
	if ( (dwRegFlags & DDRAW_REGFLAGS_AGPPOLICYMAXBYTES) == 0)
	{
	    /*
	     * If there's nothing in the registry, figure our own out
	     */
	    MEMORYSTATUS s = {sizeof(s)};

	    GlobalMemoryStatus(&s);
	    if (s.dwTotalPhys > 0xc00000)
		dwAGPPolicyMaxBytes = (DWORD)(s.dwTotalPhys - 0xc00000);
	    else
		dwAGPPolicyMaxBytes = 0;
	    DPF(1,"Max AGP size set to %08x (total phys is %08x)",dwAGPPolicyMaxBytes,s.dwTotalPhys);
	}
	else
	{
	    DPF(1,"Max AGP size set to registry value of %08x",dwAGPPolicyMaxBytes);
	}
#endif
	/*
	 * If we got this far we have some valid non-local video memory capabilities so
	 * allocate the storage in the driver object to hold them.
	 */
	pddd->lpddNLVCaps = (LPDDNONLOCALVIDMEMCAPS)MemAlloc( sizeof( DDNONLOCALVIDMEMCAPS ) );
	if( NULL == pddd->lpddNLVCaps)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate non-local video memory capabilities" );
	    return FALSE;
	}


	/*
	 * If the NLVHELcaps pointer is null, we'll allocate it here.
	 */
	if( NULL == pddd->lpddNLVHELCaps)
	    pddd->lpddNLVHELCaps = (LPDDNONLOCALVIDMEMCAPS)MemAlloc( sizeof( DDNONLOCALVIDMEMCAPS ) );
	if( NULL == pddd->lpddNLVHELCaps)
	{
	    MemFree( pddd->lpddNLVCaps );
	    pddd->lpddNLVCaps = NULL;
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate non-local video memory capabilities" );
	    return FALSE;
	}

	/*
	 * If the NLVBothCaps pointer is null, we'll allocate it here.
	 */
	if( NULL == pddd->lpddNLVBothCaps)
	    pddd->lpddNLVBothCaps = (LPDDNONLOCALVIDMEMCAPS)MemAlloc( sizeof( DDNONLOCALVIDMEMCAPS ) );
	if( NULL == pddd->lpddNLVBothCaps)
	{
	    MemFree( pddd->lpddNLVCaps );
	    pddd->lpddNLVCaps = NULL;
	    MemFree( pddd->lpddNLVHELCaps );
	    pddd->lpddNLVHELCaps = NULL;
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate non-local video memory capabilities" );
	    return FALSE;
	}

	/*
	 * This code is structure so by this point the size of the temporary buffer should
	 * be sizeof( DDNONLOCALVIDMEMCAPS )
	 */
	DDASSERT( sizeof( DDNONLOCALVIDMEMCAPS ) == ddNLVCaps.dwSize );
	CopyMemory(pddd->lpddNLVCaps, &ddNLVCaps, sizeof( DDNONLOCALVIDMEMCAPS ) );

	/*
	 * The HEL caps and the merged caps are zero to start with (they are initialized later).
	 * (actually they may not be zero in the reset case: we don't destroy the hel caps
	 * on mode changes anymore.)
	 */
	pddd->lpddNLVHELCaps->dwSize  = sizeof( DDNONLOCALVIDMEMCAPS );
	pddd->lpddNLVBothCaps->dwSize = sizeof( DDNONLOCALVIDMEMCAPS );
    }

    return TRUE;
} /* GetNonLocalVidMemCaps */


/*
 * This function is currently only used in NT
 */

#ifdef WINNT

BOOL GetDDStereoMode( LPDDRAWI_DIRECTDRAW_GBL pdrv,
                      DWORD dwWidth,
                      DWORD dwHeight,
                      DWORD dwBpp,
                      DWORD dwRefreshRate)
{
    DDHAL_GETDRIVERINFODATA     gdidata;
    HRESULT                     hres;
    DDSTEREOMODE                ddStereoMode;
    
    DDASSERT( pdrv != NULL );

    /*
     * If driver does not support GetDriverInfo callback, it also
     * has no extended capabilities to report, so we're done.
     */
    if( !VALIDEX_CODE_PTR (pdrv->pGetDriverInfo) )
    {
        return FALSE;
    }

    /*
     * The mode can't be stereo if the driver doesn't support it...
     */
    if (0 == (pdrv->ddCaps.dwCaps2 & DDCAPS2_STEREO))
    {
        return FALSE;
    }

    ZeroMemory( &ddStereoMode, sizeof(DDSTEREOMODE));

    ddStereoMode.dwSize=sizeof(DDSTEREOMODE);
    ddStereoMode.dwWidth=dwWidth;
    ddStereoMode.dwHeight=dwHeight;
    ddStereoMode.dwBpp=dwBpp;
    ddStereoMode.dwRefreshRate=dwRefreshRate;

    ddStereoMode.bSupported = TRUE;

    /*
     * Get the actual driver data
     */
    memset(&gdidata, 0, sizeof(gdidata) );
    gdidata.dwSize = sizeof(gdidata);
    gdidata.dwFlags = 0;
    gdidata.guidInfo = GUID_DDStereoMode; 
    gdidata.dwExpectedSize = sizeof(DDSTEREOMODE);
    gdidata.lpvData = &ddStereoMode;
    gdidata.ddRVal = DDERR_GENERIC;

    // Pass a context variable so that the driver
    // knows which instance of itself to use
    // w.r.t. this function. These are different
    // values on Win95 and NT.
#ifdef WIN95
    gdidata.dwContext = pdrv->dwReserved3;
#else
    gdidata.dwContext = pdrv->hDD;
#endif

    if ( pdrv->pGetDriverInfo(&gdidata) == DDHAL_DRIVER_HANDLED)
    {
        // GUID_DDStereoMode is a way to turn OFF stereo per-mode, since
        // it is expected that a driver that can do stereo can do stereo in
        // any mode.

        if( gdidata.ddRVal == DD_OK )
        {
            return ddStereoMode.bSupported;
        }
    }

    return TRUE;

} /* GetDDStereoMode */

#endif //WINNT


BOOL GetDDMoreSurfaceCaps( LPDDHALINFO lpDDHALInfo, LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    DDHAL_GETDRIVERINFODATA     gdiData;
    HRESULT                     hres;
    DWORD                       dwSize;
    LPDDMORESURFACECAPS         lpddMoreSurfaceCaps=NULL;
    BOOL                        retval=TRUE;
    DWORD                       heap;

    DDASSERT( lpDDHALInfo != NULL );
    DDASSERT( pdrv != NULL );

    /*
     * If driver does not support GetDriverInfo callback, it also
     * has no extended capabilities to report, so we're done.
     */
    if( !(lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET) )
    {
	goto Succeeded;
    }

    /*
     * The size of DDMORESURFACECAPS is variable.
     * We have to do this calculation signed, since dwNumHeaps might be zero, in which case we need
     * to subtract some from sizeof DDMORESURFACECAPS.
     */
    dwSize = (DWORD) (sizeof(DDMORESURFACECAPS) + (((signed int)pdrv->vmiData.dwNumHeaps)-1) * sizeof(DDSCAPSEX)*2 );

    /*
     * Allocate some temporary space.
     * The caps bits will go into the pdrv, and the extended heap restrictions will go into
     * the VMEMHEAP structs off of pdrv->vmiData->pvmList->lpHeap
     */
    lpddMoreSurfaceCaps = (LPDDMORESURFACECAPS)MemAlloc( dwSize );
    if (lpddMoreSurfaceCaps == NULL)
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate extended surface capabilities" );
	goto Failed;
    }
    ZeroMemory( lpddMoreSurfaceCaps , dwSize);

    /*
     * Get the actual driver data
     */
    hres = GetDriverInfo( lpDDHALInfo->GetDriverInfo,
			  &gdiData,
			  lpddMoreSurfaceCaps,
			  dwSize,
			  &GUID_DDMoreSurfaceCaps,
			  pdrv,
                          FALSE /* bInOut */ );

    if( hres != DD_OK )
    {
        goto Succeeded;
    }


    /*
     * We should never get back more data than we asked for.  If we
     * do, that probably means the driver version is newer than the
     * DirectDraw runtime version.  In that case, we just fail.
     */
    if( gdiData.dwActualSize > dwSize )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Driver gives too big a size for DDMORESURFACECAPS. Check the dwSize calculation." );
	goto Failed;
    }

    /*
     * The surface caps go into the pdrv:
     */
    pdrv->ddsCapsMore = lpddMoreSurfaceCaps->ddsCapsMore;

    if (pdrv->vmiData.dwNumHeaps == 0)
    {
	/*
	 * No heaps means we are done
	 */
	goto Succeeded;
    }
    DDASSERT(NULL != pdrv->vmiData.pvmList);

    for (heap = 0; heap < pdrv->vmiData.dwNumHeaps; heap ++ )
    {
	LPVMEMHEAP lpHeap = pdrv->vmiData.pvmList[heap].lpHeap;
	/*
	 * A quick sanity check. If we have nonzero dwNumHeaps, then we better have
	 * a heap descriptor pointer. This also saves us if someone rearranges the caller of this
	 * routine so that the vidmeminit calls have not yet been made.
	 */
	if (!lpHeap)
	{
	    DPF_ERR("****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Rearrange this call to GetDDMoreSurfaceCaps so it comes after vidmeminit");
	    goto Failed;
	}
	lpHeap->ddsCapsEx = lpddMoreSurfaceCaps->ddsExtendedHeapRestrictions[heap].ddsCapsEx;
	lpHeap->ddsCapsExAlt = lpddMoreSurfaceCaps->ddsExtendedHeapRestrictions[heap].ddsCapsExAlt;
    }

Succeeded:
    retval = TRUE;
    goto Exit;
Failed:
    retval = FALSE;
Exit:
    MemFree(lpddMoreSurfaceCaps);
    return retval;
} /* GetDDMoreSurfaceCaps */


/*
 * Interrogate the driver to get more driver capabilities, as specified in
 * the DDMORECAPS structure.  These caps augment those specified by the
 * driver in the DDHALINFO structure.  Return TRUE if the call succeeds,
 * or FALSE if an error condition is detected.  If the call succeeds, the
 * function ensures that storage is allocated for all of the DirectDraw
 * object's additional caps.
 */
BOOL GetDDMoreCaps( LPDDHALINFO lpDDHALInfo, LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    DDMORECAPS ddMoreCaps;
    DDHAL_GETDRIVERINFODATA gdiData;
    HRESULT hres;

    DDASSERT( lpDDHALInfo != NULL );
    DDASSERT( pdrv != NULL );

    /*
     * Make sure memory is allocated and initialized for the driver's
     * lpddMoreCaps, lpddHELMoreCaps, and lpddBothMoreCaps pointers.
     */
    if (pdrv->lpddMoreCaps == NULL)    // hardware caps
    {
	pdrv->lpddMoreCaps = (LPDDMORECAPS)MemAlloc( sizeof( DDMORECAPS ) );
	if (pdrv->lpddMoreCaps == NULL)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate extended capabilities" );
	    return FALSE;
	}
    }
    ZeroMemory( pdrv->lpddMoreCaps, sizeof(DDMORECAPS) );
    pdrv->lpddMoreCaps->dwSize = sizeof( DDMORECAPS );

    if (pdrv->lpddHELMoreCaps == NULL)    // HEL caps
    {
	pdrv->lpddHELMoreCaps = (LPDDMORECAPS)MemAlloc( sizeof( DDMORECAPS ) );
	if (pdrv->lpddHELMoreCaps == NULL)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate extended capabilities" );
	    return FALSE;
	}
	ZeroMemory( pdrv->lpddHELMoreCaps, sizeof(DDMORECAPS) );
	pdrv->lpddHELMoreCaps->dwSize = sizeof( DDMORECAPS );
    }

    if (pdrv->lpddBothMoreCaps == NULL)    // bitwise AND of hardware and HEL caps
    {
	pdrv->lpddBothMoreCaps = (LPDDMORECAPS)MemAlloc( sizeof( DDMORECAPS ) );
	if (pdrv->lpddBothMoreCaps == NULL)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate extended capabilities" );
	    return FALSE;
	}
    }
    ZeroMemory( pdrv->lpddBothMoreCaps, sizeof(DDMORECAPS) );
    pdrv->lpddBothMoreCaps->dwSize = sizeof( DDMORECAPS );

    /*
     * If driver does not support GetDriverInfo callback, it also
     * has no extended capabilities to report, so we're done.
     */
    if( !(lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET) )
    {
	return TRUE;    // no extended capabilities to report
    }

#if 0
    /*
     * Get the extended capabilities from the driver.
     */
    ZeroMemory( &ddMoreCaps, sizeof( DDMORECAPS ) );

    hres = GetDriverInfo( lpDDHALInfo->GetDriverInfo,
			  &gdiData,
			  &ddMoreCaps,
			  sizeof( DDMORECAPS ),
			  &GUID_DDMoreCaps,
			  pdrv );

    if( hres != DD_OK )
    {
	return TRUE;    // no extended capabilities to report
    }

    /*
     * We should never get back more data than we asked for.  If we
     * do, that probably means the driver version is newer than the
     * DirectDraw runtime version.  In that case, we just fail.
     */
    if( gdiData.dwActualSize > sizeof( DDMORECAPS ) )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Driver gives too big a size for DDMORECAPS" );
	return FALSE;    // error
    }

    /*
     * We zeroed the structure before passing it to the driver so
     * everything is cool if we got less data than we asked for.
     * Just bump the size up to the expected size.
     */
    ddMoreCaps.dwSize = sizeof( DDMORECAPS );

    /*
     * Store the hardware driver's extended caps in the global DirectDraw object.
     */
    CopyMemory(pdrv->lpddMoreCaps, &ddMoreCaps, sizeof( DDMORECAPS ) );
#endif
    return TRUE;

} /* GetDDMoreCaps */

/*
 * DirectDrawObjectCreate
 *
 * Create a DIRECTDRAW object.
 */
LPDDRAWI_DIRECTDRAW_GBL DirectDrawObjectCreate(
		LPDDHALINFO lpDDHALInfo,
		BOOL reset,
		LPDDRAWI_DIRECTDRAW_GBL oldpdd,
		HANDLE hDDVxd,
		char *szDrvName,
		DWORD dwDriverContext, 
                DWORD dwLocalFlags )
{
    LPDDRAWI_DIRECTDRAW_GBL     pddd=NULL;
    int                         drv_size;
    int                         drv_callbacks_size;
    int                         size;
    LPVIDMEM                    pvm;
    int                         i;
    int                         j;
    int                         devheapno;
    int                         numcb;
    LPDDHAL_DDCALLBACKS         drvcb;
    LPDDHAL_DDSURFACECALLBACKS  surfcb;
    LPDDHAL_DDPALETTECALLBACKS  palcb;
    LPDDHAL_DDEXEBUFCALLBACKS   exebufcb;
    DWORD                       bit;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    DWORD                       freevm;
    BOOL                        isagpaware;
    #ifdef WIN95
	DWORD                   ptr16;
    #endif

    #ifdef WINNT
	/*
	 * Need somewhere to put the callback fn ptrs given to us by the NT driver...
	 */
    DDHAL_DDCALLBACKS               ddNTHALDD;
    DDHAL_DDSURFACECALLBACKS        ddNTHALDDSurface;
    DDHAL_DDPALETTECALLBACKS        ddNTHALDDPalette;
    D3DHAL_CALLBACKS                d3dNTHALCallbacks;
    D3DHAL_CALLBACKS               *pd3dNTHALCallbacks=0;
    D3DHAL_GLOBALDRIVERDATA         d3dNTHALDriverData;
    D3DHAL_GLOBALDRIVERDATA        *pd3dNTHALDriverData;
    LPDDSURFACEDESC                 pddsdD3dTextureFormats;
    DDHAL_DDEXEBUFCALLBACKS         ddNTHALBufferCallbacks;
    LPDDHAL_DDEXEBUFCALLBACKS       pddNTHALBufferCallbacks;
    BOOL                            ismemalloced=FALSE;
    #endif

    ENTER_DDRAW();

    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 4, "DirectDrawObjectCreate: oldpdd == 0x%p, reset = %d", oldpdd, reset );

    DDASSERT( (oldpdd == NULL) == (reset==FALSE) );

    /*
     * make sure the driver isn't trying to lie to us about the old object
     * This check should always be made at the top of this routine, since it's
     * possible in stress scenarios for ddhelp's modeset thread to wake up
     * just before it's killed at the end of DD_Release (since the code to kill
     * the mode set thread is executed AFTER the last LEAVE_DDRAW in DD_Release).
     */
    DPF( 5, "DIRECTDRAW object passed in = 0x%p", oldpdd );
    if( oldpdd != NULL )
    {
	pdrv_lcl = lpDriverLocalList;
	while( pdrv_lcl != NULL )
	{
	    if( pdrv_lcl->lpGbl == oldpdd )
	    {
		break;
	    }
	    pdrv_lcl = pdrv_lcl->lpLink;
	}
	if( pdrv_lcl == NULL )
	{
	    DPF_ERR( "REUSED DRIVER OBJECT SPECIFIED, BUT NOT IN LIST" );
	    DDASSERT(FALSE);
	    goto ErrorExit;
	}
    }

    // If a null driver name is passed in then use the one
    // in the oldpdd passed in. We need one or the other!
    if( szDrvName == NULL )
    {
	if( oldpdd == NULL )
	{
	    DPF_ERR( "DDrawObjectCreate: oldpdd == NULL && szDrvName == NULL" );
	    DDASSERT( 0 );
	    goto ErrorExit;
	}
	szDrvName = oldpdd->cDriverName;
    }

    #ifdef USE_ALIAS
	if( NULL != oldpdd )
	{
	    /*
	     * The absolutely first thing we want to do is to check to see if there are
	     * any outstanding video memory locks and if there are we need to remap
	     * the aliased to dummy memory to ensure we don't write over memory we don't
	     * own or to memory that does not exist.
	     */
	    if( ( NULL != oldpdd->phaiHeapAliases ) && ( oldpdd->phaiHeapAliases->dwRefCnt > 1UL ) )
	    {
		DDASSERT( INVALID_HANDLE_VALUE != hDDVxd );
		if( FAILED( MapHeapAliasesToDummyMem( hDDVxd, oldpdd->phaiHeapAliases ) ) )
		{
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not map existing video memory aliases to dummy memory" );
		    goto ErrorExit;
		}
	    }
	}
    #endif /* USE_ALIAS */

    /*
     * Is this OS AGP aware?
     *
     * NOTE: VXD handle is only necessary on Win95. On NT, hDDVxd will simply
     * be NULL and be unused by this function.
     */
#ifdef WINNT
    isagpaware = TRUE;
#else
    isagpaware = OSIsAGPAware( hDDVxd );
    if( !isagpaware )
    {
	if( dwRegFlags & DDRAW_REGFLAGS_FORCEAGPSUPPORT )
	{
	    /*
	     * Pretend the OS is AGP aware for debugging purposes.
	     */
	    DPF( 1, "Force enabling AGP support for debugging purposes" );
	    isagpaware = TRUE;
	}
    }
#endif //not WINNT
    if( dwRegFlags & DDRAW_REGFLAGS_DISABLEAGPSUPPORT )
    {
	/*
	 * Pretend the OS is not AGP aware.
	 */
	DPF( 1, "Disabling APG support for debugging purposes" );
	isagpaware = FALSE;
    }

    /*
     * Under NT, we're forced to create a direct draw global object before we can
     * query the driver for its ddhalinfo.
     * Consequently, we validate the incoming ddhalinfo pointer first in its very
     * own try-except block, then allocate the global structure, then (on NT only)
     * call the driver to register the global object and get its halinfo.
     * (Under win95, the halinfo will have been filled in by the caller) jeffno 960116
     */

    /*
     * initialize a new driver object if we don't have one already
     */
    if( (oldpdd == NULL) || reset )
    {
        // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF( 4, "oldpdd == 0x%p, reset = %d", oldpdd, reset );
	/*
	 * Allocate memory for the global object.
	 * We also allocate a DDHAL_CALLBACKS structure with the global
	 * object.  This structure is used to hold the single copy of
	 * the HAL function table under Win95 and it is used as
	 * temporary storage of the function table under NT
	 */
	drv_size = sizeof( DDRAWI_DIRECTDRAW_GBL );
	drv_callbacks_size = drv_size + sizeof( DDHAL_CALLBACKS );
	#ifdef WIN95
	    pddd = (LPDDRAWI_DIRECTDRAW_GBL) MemAlloc16( drv_callbacks_size, &ptr16 );
	#else
	    pddd = (LPDDRAWI_DIRECTDRAW_GBL) MemAlloc( drv_callbacks_size );
	#endif
	DPF( 5,"Driver Object: %ld base bytes", drv_callbacks_size );
	if( pddd == NULL )
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not allocate space for driver object" );
	    goto ErrorExit;
	}

	#ifdef WIN95
	// Store the value returned by the 32-bit driver
	// into the pdrv; this allows the 32-bit driver to remember
	// any state it needs to for all future calls to it. This
	// was added for multi-monitor support. <kd>
	if( oldpdd )
	    pddd->dwReserved3= oldpdd->dwReserved3;
	else
	    pddd->dwReserved3 = dwDriverContext;
	DPF( 5, "dwReserved3 of DDrawGbl is set to 0x%x", pddd->dwReserved3 );

	// Initialize value of global DDRAW.VXD handle to INVALID_HANDLE_VALUE.
	// This should always normally be INVALID_HANDLE_VALUE, unless if we
	// are in the middle of a createSurface() call.
	pddd->hDDVxd = (DWORD) INVALID_HANDLE_VALUE;
	DPF( 6, "hDDVxd of DDrawGbl is set to INVALID_HANDLE_VALUE - 0x%p", pddd->hDDVxd );
        #else
            /*
             * In the reset code path, this per-process hDD will have been stuffed into
             * the oldpdd by FetchDirectDrawData.
             */
            if (reset)
            {
                DDASSERT(oldpdd);
                pddd->hDD = oldpdd->hDD;
            }
	#endif WIN95

	pddd->lpDDCBtmp = (LPDDHAL_CALLBACKS)(((LPSTR) pddd) + drv_size );

#ifdef WINNT
        pddd->SurfaceHandleList.dwList=NULL;
        pddd->SurfaceHandleList.dwFreeList=0;
	if (lpDDHALInfo && !(lpDDHALInfo->ddCaps.dwCaps & DDCAPS_NOHARDWARE))
	{
	    HDC hDC;
	    BOOL bNewMode;
	    BOOL bRetVal;
	    /*
	     * Now that we have a ddraw GBL structure available, we can tell
	     * the driver about it...
	     */
	    DPF(5,K,"WinNT driver conversation started");

            if (!reset)
            {
	        hDC = DD_CreateDC( szDrvName );   // create temporary DC
	        if (!hDC)
	        {
    		    DPF(0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Unable to create temporary DC for driver");
		    goto ErrorExit;
	        }
                bRetVal = DdCreateDirectDrawObject(pddd, hDC);
                DD_DoneDC(hDC);   // delete temporary DC
                if (!bRetVal)
	        {
		    /*
		     * this means we're in emulation
		     */
		    DPF(0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:NT Kernel mode would not create driver object... Failing over to emulation");
		    goto ErrorExit;
	        }
            }

	    /*
	     * Now we can get the driver info...
	     * The first call to this routine lets us know how much space to
	     * reserve for the fourcc and vidmem lists
	     */
	    if (!DdReenableDirectDrawObject(pddd,&bNewMode) ||
		!DdQueryDirectDrawObject(pddd,
					 lpDDHALInfo,
					 &ddNTHALDD,
					 &ddNTHALDDSurface,
					 &ddNTHALDDPalette,
					 &d3dNTHALCallbacks,
					 &d3dNTHALDriverData,
					 &ddNTHALBufferCallbacks,
					 NULL,
					 NULL,
					 NULL))
	    {
		DPF(1, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:First call to DdQueryDirectDrawObject failed!");
		goto ErrorExit;
	    }
	    /*
	     * The second call allows the driver to fill in the fourcc and
	     * vidmem lists. First we make space for them.
	     */
	    lpDDHALInfo->vmiData.pvmList = MemAlloc(lpDDHALInfo->vmiData.dwNumHeaps * sizeof(VIDMEM));
	    if (NULL == lpDDHALInfo->vmiData.pvmList)
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:No RAM for pvmList");
		goto ErrorExit;
	    }
	    lpDDHALInfo->lpdwFourCC = MemAlloc(lpDDHALInfo->ddCaps.dwNumFourCCCodes * sizeof(DWORD));
	    if (NULL == lpDDHALInfo->lpdwFourCC)
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:No RAM for FourCC List");
		goto ErrorExit;
	    }
            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF(5, K, "numheaps = %d, numfourcc = %d", lpDDHALInfo->vmiData.dwNumHeaps, lpDDHALInfo->ddCaps.dwNumFourCCCodes);
	    DPF(5, K, "ptrs: 0x%p, 0x%p", lpDDHALInfo->lpdwFourCC, lpDDHALInfo->vmiData.pvmList);

	    // If Direct3D information was returned, allocate space for
	    // the real information to be stored in and for the
	    // appropriate number of texture formats
	    if (d3dNTHALCallbacks.dwSize > 0 &&
		d3dNTHALDriverData.dwSize > 0)
	    {
                // We need to allocate space for the d3dhalcallbacks etc. only once,
                // since d3d caches them across mode changes.
                // We are allowed to reallocate the texture format list, since d3d only
                // caches a pointer to D3DHAL_GLOBALDRIVERDATA, which is where the pointer
                // to the texture formats is kept.

                if ( NULL == oldpdd || NULL == oldpdd->lpD3DHALCallbacks )
                {
		    pddd->lpD3DHALCallbacks = pd3dNTHALCallbacks =
                        (LPD3DHAL_CALLBACKS) MemAlloc(sizeof(D3DHAL_CALLBACKS)+
					          sizeof(D3DHAL_GLOBALDRIVERDATA)+
					          sizeof(DDHAL_DDEXEBUFCALLBACKS));

                    // Mark memory allocated in this path (not get from old one)
                    // so that we can free this memory if error occur later.

                    ismemalloced = TRUE;
                }
                else
                    pddd->lpD3DHALCallbacks = pd3dNTHALCallbacks = oldpdd->lpD3DHALCallbacks;

		if (pd3dNTHALCallbacks == NULL)
		{
		    DPF_ERR("****DirectDraw/Direct3D DRIVER DISABLING ERROR****:D3D memory allocation failed!");
		    goto ErrorExit;
		}

		pd3dNTHALDriverData = (LPD3DHAL_GLOBALDRIVERDATA)
		    (pd3dNTHALCallbacks+1);
		pddNTHALBufferCallbacks = (LPDDHAL_DDEXEBUFCALLBACKS)
		    (pd3dNTHALDriverData+1);

                // free old texture list and allocate a new one.
                MemFree(pd3dNTHALDriverData->lpTextureFormats);
                pddsdD3dTextureFormats = pd3dNTHALDriverData->lpTextureFormats =
                    MemAlloc(sizeof(DDSURFACEDESC) * d3dNTHALDriverData.dwNumTextureFormats);
	    }
	    else
	    {
		pd3dNTHALCallbacks = NULL;
		pd3dNTHALDriverData = NULL;
		pddNTHALBufferCallbacks = NULL;
                pddsdD3dTextureFormats = NULL;
	    }

	    if (!DdQueryDirectDrawObject(pddd,
					 lpDDHALInfo,
					 &ddNTHALDD,
					 &ddNTHALDDSurface,
					 &ddNTHALDDPalette,
					 pd3dNTHALCallbacks,
					 pd3dNTHALDriverData,
					 pddNTHALBufferCallbacks,
					 pddsdD3dTextureFormats,
					 lpDDHALInfo->lpdwFourCC,
					 lpDDHALInfo->vmiData.pvmList))
	    {
		DPF(1, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Third call to DdQueryDirectDrawObject failed!");
		goto ErrorExit;
	    }
	    #ifdef DEBUG
	    {
		int i;
		DPF(5,K,"NT driver video ram data as reported by driver:");
		DPF(5,K,"   VIDMEMINFO.fpPrimary        =%08x",lpDDHALInfo->vmiData.fpPrimary);
		DPF(5,K,"   VIDMEMINFO.dwFlags          =%08x",lpDDHALInfo->vmiData.dwFlags);
		DPF(5,K,"   VIDMEMINFO.dwDisplayWidth   =%08x",lpDDHALInfo->vmiData.dwDisplayWidth);
		DPF(5,K,"   VIDMEMINFO.dwDisplayHeight  =%08x",lpDDHALInfo->vmiData.dwDisplayHeight);
		DPF(5,K,"   VIDMEMINFO.lDisplayPitch    =%08x",lpDDHALInfo->vmiData.lDisplayPitch);
		DPF(5,K,"   VIDMEMINFO.dwOffscreenAlign =%08x",lpDDHALInfo->vmiData.dwOffscreenAlign);
		DPF(5,K,"   VIDMEMINFO.dwOverlayAlign   =%08x",lpDDHALInfo->vmiData.dwOverlayAlign);
		DPF(5,K,"   VIDMEMINFO.dwTextureAlign   =%08x",lpDDHALInfo->vmiData.dwTextureAlign);
		DPF(5,K,"   VIDMEMINFO.dwZBufferAlign   =%08x",lpDDHALInfo->vmiData.dwZBufferAlign);
		DPF(5,K,"   VIDMEMINFO.dwAlphaAlign     =%08x",lpDDHALInfo->vmiData.dwAlphaAlign);
		DPF(5,K,"   VIDMEMINFO.dwNumHeaps       =%08x",lpDDHALInfo->vmiData.dwNumHeaps);

		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwSize            =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwSize);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwFlags           =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwFlags);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwFourCC          =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwFourCC);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwRGBBitCount     =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwRGBBitCount);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwRBitMask        =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwRBitMask);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwGBitMask        =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwGBitMask);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwBBitMask        =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwBBitMask);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwRGBAlphaBitMask =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwRGBAlphaBitMask);

                // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		DPF(5, K, "   Vidmem list ptr is 0x%p", lpDDHALInfo->vmiData.pvmList);
		for (i=0;i<(int) lpDDHALInfo->vmiData.dwNumHeaps;i++)
		{
		    DPF(5, K, "        heap flags: %03x", lpDDHALInfo->vmiData.pvmList[i].dwFlags);
		    DPF(5, K, "    Start of chunk: 0x%p", lpDDHALInfo->vmiData.pvmList[i].fpStart);
		    DPF(5, K, "      End of chunk: 0x%p", lpDDHALInfo->vmiData.pvmList[i].fpEnd);
		}
	    }
	    #endif


	    lpDDHALInfo->lpDDCallbacks = &ddNTHALDD;
	    lpDDHALInfo->lpDDSurfaceCallbacks = &ddNTHALDDSurface;
	    lpDDHALInfo->lpDDPaletteCallbacks = &ddNTHALDDPalette;

	    ddNTHALBufferCallbacks.dwSize =sizeof ddNTHALBufferCallbacks; //since kernel is busted
            ddNTHALBufferCallbacks.dwFlags = 
                    DDHAL_EXEBUFCB32_CANCREATEEXEBUF|
                    DDHAL_EXEBUFCB32_CREATEEXEBUF   |
                    DDHAL_EXEBUFCB32_DESTROYEXEBUF  |
                    DDHAL_EXEBUFCB32_LOCKEXEBUF     |
                    DDHAL_EXEBUFCB32_UNLOCKEXEBUF   ;
	    lpDDHALInfo->lpDDExeBufCallbacks = &ddNTHALBufferCallbacks;

            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF(5, K, "Surface callback as reported by Kernel is 0x%p", lpDDHALInfo->lpDDCallbacks->CreateSurface);
	}
	else
	{
	    /*
	     * Normally, we specify a null DC handle to register our fake 
             * DDraw driver, but with secondary monitors we need to specify
             * a device DC or else things fall apart.
	     */
            HDC hdcTemp = NULL;

            if( ( _stricmp( szDrvName, DISPLAY_STR ) != 0 ) &&
	        ( _stricmp( szDrvName, g_szPrimaryDisplay ) != 0 ) &&
                IsMultiMonitor() &&
                ( ( szDrvName[0] == '\\' ) && 
                  ( szDrvName[1] == '\\' ) && 
                  ( szDrvName[2] == '.') ) )
            {
                hdcTemp = DD_CreateDC( szDrvName );   // create temporary DC
            }

            if (!DdCreateDirectDrawObject(pddd, hdcTemp))
	    {
		DPF(1, "NT Kernel mode would not create fake DD driver object");
		goto ErrorExit;
	    }
            if( hdcTemp != NULL )
            {
                DD_DoneDC(hdcTemp);   // delete temporary DC
            }
	}
        if (!GetCurrentMode(oldpdd, lpDDHALInfo, szDrvName))
        {
            DPF(0, "Could not get current mode information");
            goto ErrorExit;
        }
        if (oldpdd && oldpdd->lpModeInfo)
        {
            DDASSERT(oldpdd->lpModeInfo == &oldpdd->ModeInfo);
            memcpy(&oldpdd->ModeInfo, lpDDHALInfo->lpModeInfo, sizeof (DDHALMODEINFO));
        }

#endif //WINNT


    } //end if oldpdd==NULL || reset

    if( !ValidateCoreHALInfo( lpDDHALInfo ) )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Exception encountered validating driver parameters" );
	goto ErrorExit;
    }

    // We only want to get new HALInfo if we haven't already
    // done this. The oldpdd == NULL check implies that we are
    // building a driver from scratch.
    if( (oldpdd == NULL) && pddd && !GetAndValidateNewHALInfo( pddd, lpDDHALInfo ) )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Exception encountered querying for optional driver parameters" );
	goto ErrorExit;
    }

    /*
     * reset specified without a driver object existing is just a create
     */
    if( reset && (oldpdd == NULL) )
    {
	reset = FALSE;
    }

    /*
     * initialize a new driver object if we don't have one already
     */
    if( (oldpdd == NULL) || reset )
    {
	DPF(4,"oldpdd == NULL || reset");
	/*
	 * validate blt stuff
	 */
	if( lpDDHALInfo->ddCaps.dwCaps & DDCAPS_BLT )
	{
	    if( lpDDHALInfo->lpDDSurfaceCallbacks->Blt == NULL )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:No Blt Fn, but BLT specified" );
		goto ErrorExit;
	    }
	    if( !(lpDDHALInfo->ddCaps.dwRops[ (SRCCOPY>>16)/32 ] &
		(1<<((SRCCOPY>>16) % 32)) ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:BLT specified, but SRCCOPY not supported!" );
		goto ErrorExit;
	    }
	}
	else
	{
	    DPF( 2, "Driver can't blt" );
	}

	/*
	 * validate align fields
	 */
	if( lpDDHALInfo->ddCaps.ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN )
	{
	    if( !VALID_ALIGNMENT( lpDDHALInfo->vmiData.dwOffscreenAlign ) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid dwOffscreenAlign (%d) with DDSCAPS_OFFSCREENPLAIN specified",
			lpDDHALInfo->vmiData.dwOffscreenAlign );
		goto ErrorExit;
	    }
	}
	if( lpDDHALInfo->ddCaps.ddsCaps.dwCaps & DDSCAPS_OVERLAY )
	{
	    if( !VALID_ALIGNMENT( lpDDHALInfo->vmiData.dwOverlayAlign ) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid dwOverlayAlign (%d) with DDSCAPS_OVERLAY specified",
			lpDDHALInfo->vmiData.dwOverlayAlign );
		goto ErrorExit;
	    }
	}
	if( lpDDHALInfo->ddCaps.ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
	{
	    if( !VALID_ALIGNMENT( lpDDHALInfo->vmiData.dwZBufferAlign ) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid dwZBufferAlign (%d) with DDSCAPS_ZBUFFER specified",
			lpDDHALInfo->vmiData.dwZBufferAlign );
		goto ErrorExit;
	    }
	}
	if( lpDDHALInfo->ddCaps.ddsCaps.dwCaps & DDSCAPS_TEXTURE )
	{
	    if( !VALID_ALIGNMENT( lpDDHALInfo->vmiData.dwTextureAlign ) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid dwTextureAlign (%d) with DDSCAPS_TEXTURE specified",
			lpDDHALInfo->vmiData.dwTextureAlign );
		goto ErrorExit;
	    }
	}

#ifndef WINNT
	/*
	 * NT only reports one display mode if we are in the Ctrl-Alt-Del screen
	 * so don't fail if NT changes the number of display modes.
	 */

	/*
	 * make sure display driver doesn't try to change the number of
	 * modes supported after a mode change
	 */
	if( reset )
	{
	    if( lpDDHALInfo->dwNumModes != 0 )
	    {
		if( lpDDHALInfo->dwNumModes != oldpdd->dwSaveNumModes )
		{
		    DPF(0, "*******************************************************");
		    DPF(0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Reset attempted to change number of modes from %d to %d",oldpdd->dwSaveNumModes,lpDDHALInfo->dwNumModes );
		    DPF(0, "*******************************************************");
		    goto ErrorExit;
		}
	    }
	}
#endif

	/* memory for pddd was allocated at the top of this routine */

	/*
	 * If this is the first time through, initialize a bunch of stuff.
	 * There are a number of fields that we only need to fill in when
	 * the driver object is created.
	 */
	if( !reset )
	{
	    #ifdef WIN95
		/*
		 * set up a 16-bit pointer for use by the driver
		 */
		pddd->lp16DD = (LPVOID) ptr16;
		DPF( 5, "pddd->lp16DD = %08lx", pddd->lp16DD );
	    #endif

	    /*
	     * fill in misc. values
	     */
	    pddd->lpDriverHandle = pddd;
	    pddd->hInstance = lpDDHALInfo->hInstance;

	    // init doubly-linked overlay zorder list
	    pddd->dbnOverlayRoot.next = &(pddd->dbnOverlayRoot);
	    pddd->dbnOverlayRoot.prev = pddd->dbnOverlayRoot.next;
	    pddd->dbnOverlayRoot.object = NULL;
	    pddd->dbnOverlayRoot.object_int = NULL;

	    /*
	     * modes...
	     */
	    pddd->dwNumModes = lpDDHALInfo->dwNumModes;
	    pddd->dwSaveNumModes = lpDDHALInfo->dwNumModes;
	    if( pddd->dwNumModes > 0 )
	    {
		size = pddd->dwNumModes * sizeof( DDHALMODEINFO );
#ifdef WIN95
		pddd->lpModeInfo = MemAlloc( size );
		if( pddd->lpModeInfo == NULL )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate mode info!" );
		    goto ErrorExit;
		}
#else
		pddd->lpModeInfo = &pddd->ModeInfo;
                DDASSERT( 1 == pddd->dwNumModes );
#endif
		memcpy( pddd->lpModeInfo, lpDDHALInfo->lpModeInfo, size );
		#ifdef WIN95
		    /*
		     * Check if we can add Mode X
		     */
		    do
		    {
			if (lpDDHALInfo->dwFlags & DDHALINFO_MODEXILLEGAL)
			{
			    break;
			}
			/*
			 * ModeX not allowed for PC98
			 * Check OS's locale.
			 */
			if ( GetSystemDefaultLCID() == 0x0411 )
			{
			    /*
			     * System is Windows 95 J
			     * Now retrieve keyboard ID to check PC98
			     */
			    DWORD dwSubType = GetKeyboardType(1);
			    if (HIBYTE(dwSubType) == 0x0D)
			    {
				/* NEC PC98 series */
				break;
			    }
			}
			/* NOT NEC PC98 series */
			if (IsVGADevice( szDrvName ))
			{
			    AddModeXModes( pddd );

			    /*
			     * OR in modex and/or standard VGA caps, so the app knows if
			     * it can pass the standard vga flag to enum modes.
			     */
			    lpDDHALInfo->ddCaps.ddsCaps.dwCaps |= (DDSCAPS_STANDARDVGAMODE|DDSCAPS_MODEX);
			    /*
			     * Do the HEL caps just for rationality
			     */
			    pddd->ddHELCaps.ddsCaps.dwCaps |= (DDSCAPS_STANDARDVGAMODE|DDSCAPS_MODEX);
			}
			break;
		    } while(0);
                    ExpandModeTable( pddd );
                    MassageModeTable( pddd );
		#endif
	    }
	    else
	    {
		pddd->lpModeInfo = NULL;
	    }

	    /*
	     * driver naming..  This is a special case for when we are
	     * invoked by the display driver directly, and not through
	     * the DirectDrawCreate path. Basically, everything except
	     * special 'secondary devices' like the 3DFx are DISPLAYDRV.
	     *
	     * If the driver says it's primary; ok. Else if it is "DISPLAY"
	     * or if the name is like "\\.\display4" then it is a Memphis/NT5
	     * multi-mon display device.
	     */
	    if( (lpDDHALInfo->dwFlags & DDHALINFO_ISPRIMARYDISPLAY) ||
		_stricmp( szDrvName, DISPLAY_STR ) == 0 ||
		(szDrvName[0] == '\\' && szDrvName[1] == '\\' && szDrvName[2] == '.') )
	    {
		pddd->dwFlags |= DDRAWI_DISPLAYDRV;
		pddd->dwFlags |= DDRAWI_GDIDRV;
		lstrcpy( pddd->cDriverName, szDrvName );
	    }

	    /*
	     * modex modes are illegal on some hardware.  specifically
	     * NEC machines in japan.  this allows the driver to specify
	     * that its hardware does not support modex.  modex modes are
	     * then turned off everywhere as a result.
	     */
	    if( lpDDHALInfo->dwFlags & DDHALINFO_MODEXILLEGAL )
	    {
		pddd->dwFlags |= DDRAWI_MODEXILLEGAL;
	    }
	}
	/*
	 * resetting
	 */
	else
	{
	    /*
	     * copy old struct onto new one (before we start updating)
	     * preserve the lpDDCB pointer
	     */
	    {
		LPDDHAL_CALLBACKS   save_ptr=pddd->lpDDCBtmp;
		memcpy( pddd, oldpdd, drv_callbacks_size );
		pddd->lpDDCBtmp = save_ptr;
	    }

	    /*
	     * mark all existing surfaces as gone. Note, we don't rebuild
	     * the aliases at this point as they are going to be rebuilt
	     * below anyway.
	     */
	    InvalidateAllSurfaces( oldpdd, hDDVxd, FALSE );

	    #ifdef USE_ALIAS
		/*
		 * The video memory heaps are about to go so release the
		 * aliases to those heaps that the local objects maintain.
		 *
		 * NOTE: If any surfaces are currently locked and using
		 * those aliases then the aliases will not actually be
		 * discarded until the last lock is released. In which
		 * case these aliases will be mapped to the dummy page
		 * by this point.
		 */
		if( NULL != oldpdd->phaiHeapAliases )
		{
		    DDASSERT( INVALID_HANDLE_VALUE != hDDVxd );
		    ReleaseHeapAliases( hDDVxd, oldpdd->phaiHeapAliases );
		    /*
		     * NOTE: Need to NULL out the heap alias pointer in the
		     * new driver object also as we just copied them above.
		     */
		    oldpdd->phaiHeapAliases = NULL;
		    pddd->phaiHeapAliases = NULL;
		}
	    #endif /* USE_ALIAS */

#ifndef WINNT
	    /*
	     * discard old vidmem heaps
	     */
	    for( i=0;i<(int)oldpdd->vmiData.dwNumHeaps;i++ )
	    {
		pvm = &(oldpdd->vmiData.pvmList[i]);
		if( pvm->lpHeap != NULL )
		{
		    HeapVidMemFini( pvm, hDDVxd );
		}
	    }
#endif //not WINNT
	}

	/*
	 * fill in misc data
	 */
	pddd->ddCaps = lpDDHALInfo->ddCaps;

	pddd->vmiData.fpPrimary = lpDDHALInfo->vmiData.fpPrimary;
	pddd->vmiData.dwFlags = lpDDHALInfo->vmiData.dwFlags;
	pddd->vmiData.dwDisplayWidth = lpDDHALInfo->vmiData.dwDisplayWidth;
	pddd->vmiData.dwDisplayHeight = lpDDHALInfo->vmiData.dwDisplayHeight;
	pddd->vmiData.lDisplayPitch = lpDDHALInfo->vmiData.lDisplayPitch;
	pddd->vmiData.ddpfDisplay = lpDDHALInfo->vmiData.ddpfDisplay;
	pddd->vmiData.dwOffscreenAlign = lpDDHALInfo->vmiData.dwOffscreenAlign;
	pddd->vmiData.dwOverlayAlign = lpDDHALInfo->vmiData.dwOverlayAlign;
	pddd->vmiData.dwTextureAlign = lpDDHALInfo->vmiData.dwTextureAlign;
	pddd->vmiData.dwZBufferAlign = lpDDHALInfo->vmiData.dwZBufferAlign;
	pddd->vmiData.dwAlphaAlign = lpDDHALInfo->vmiData.dwAlphaAlign;

#ifdef WIN95
	/*
	 * We need to compute the number of heaps that are actually usable.
	 * The number of usable heaps may be different from the number of
	 * heap descriptors passed to us by the driver due to AGP. If the
	 * driver attempts to pass AGP heaps to use and the OS we are running
	 * under doesn't have AGP support we can't use those heaps so we
	 * ignore them.
	 */
	pddd->vmiData.dwNumHeaps = lpDDHALInfo->vmiData.dwNumHeaps;
	for( i=0;i<(int)lpDDHALInfo->vmiData.dwNumHeaps;i++ )
	{
	    if( ( lpDDHALInfo->vmiData.pvmList[i].dwFlags & VIDMEM_ISNONLOCAL ) && !isagpaware )
	    {
		DPF(3, "Discarding AGP heap %d", i);
		pddd->vmiData.dwNumHeaps--;
	    }
	}

	/*
	 * NOTE: Its not illegal to end up with no video memory heaps at this point.
	 * Under the current AGP implementation the primary is always in local
	 * video memory so we always end up with a valid primary if nothing else.
	 * Therefore, we stay in non-emulated mode.
	 */
        #ifdef WIN95
	    #ifdef DEBUG
	        if( 0UL == pddd->vmiData.dwNumHeaps )
	        {
		    DPF( 2, "All video memory heaps have been disabled." );
	        }
	    #endif /* DEBUG */
        #endif //WIN95
#endif
	/*
	 * fpPrimaryOrig has no user-mode meaning under NT... primary's surface may have different address
	 * across processes.
	 * There is a new flag (DDRAWISURFGBL_ISGDISURFACE) which identifies a surface gbl object
	 * as representing the surface which GDI believes is the front buffer. jeffno 960122
	 */
	pddd->fpPrimaryOrig = lpDDHALInfo->vmiData.fpPrimary;
        // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(5,"Primary video ram pointer is 0x%p", lpDDHALInfo->vmiData.fpPrimary);
#ifdef WIN95
	pddd->dwMonitorFrequency = lpDDHALInfo->dwMonitorFrequency;
	if( ( pddd->dwMonitorFrequency == 0 ) &&
	    ( lpDDHALInfo->dwModeIndex != (DWORD) -1 ) &&
	    ( lpDDHALInfo->lpModeInfo != NULL ) &&
	    ( lpDDHALInfo->lpModeInfo[lpDDHALInfo->dwModeIndex].wRefreshRate != 0 ) &&
            !( lpDDHALInfo->lpModeInfo[lpDDHALInfo->dwModeIndex].wFlags & DDMODEINFO_MAXREFRESH ))
	{
	    pddd->dwMonitorFrequency = lpDDHALInfo->lpModeInfo[lpDDHALInfo->dwModeIndex].wRefreshRate;
	}
	pddd->dwModeIndexOrig = lpDDHALInfo->dwModeIndex;
        pddd->dwModeIndex = lpDDHALInfo->dwModeIndex;
	DPF( 5, "Current and Original Mode = %d", pddd->dwModeIndex );
	DPF( 5, "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ MODE INDEX = %ld", pddd->dwModeIndex );
#else
        pddd->dmiCurrent.wWidth = (WORD) lpDDHALInfo->lpModeInfo->dwWidth;
        pddd->dmiCurrent.wHeight = (WORD) lpDDHALInfo->lpModeInfo->dwHeight;
        if (lpDDHALInfo->lpModeInfo->dwBPP == 16)
        {
            pddd->dmiCurrent.wBPP = (lpDDHALInfo->lpModeInfo->wFlags & DDMODEINFO_555MODE) ? 15 : 16;
        }
        else
        {
            pddd->dmiCurrent.wBPP = (BYTE) lpDDHALInfo->lpModeInfo->dwBPP;
        }
        pddd->dmiCurrent.wRefreshRate = lpDDHALInfo->lpModeInfo->wRefreshRate;
        pddd->dwMonitorFrequency = lpDDHALInfo->lpModeInfo->wRefreshRate;
        pddd->dmiCurrent.wMonitorsAttachedToDesktop = (BYTE) GetNumberOfMonitorAttachedToDesktop();
#endif

	/*
	 * pdevice info
	 */
	#ifdef WIN95
	    if( lpDDHALInfo->lpPDevice != NULL )
	    {
		LPDIBENGINE     pde;

		pde = MapSLFix( (DWORD) lpDDHALInfo->lpPDevice );
		if( (pde->deType != 0x5250) || !(pde->deFlags & MINIDRIVER))
		{
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Not a DIBEngine mini driver" );
		    goto ErrorExit;
		}
		pddd->dwPDevice = (DWORD)lpDDHALInfo->lpPDevice;
		pddd->lpwPDeviceFlags = &pde->deFlags;
                // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		DPF( 5, "lpPDevice = 0x%p", pde );
		if(pde->deBitsPixel == 16)
		{
		    if(pde->deFlags & FIVE6FIVE)
		    {
			pddd->vmiData.ddpfDisplay.dwRBitMask = 0xf800;
			pddd->vmiData.ddpfDisplay.dwGBitMask = 0x07e0;
			pddd->vmiData.ddpfDisplay.dwBBitMask = 0x001f;
		    }
		    else
		    {
			pddd->vmiData.ddpfDisplay.dwRBitMask = 0x7c00;
			pddd->vmiData.ddpfDisplay.dwGBitMask = 0x03e0;
			pddd->vmiData.ddpfDisplay.dwBBitMask = 0x001f;
		    }
		    // Update the current mode to reflect the correct bitmasks
		    // NOTE: The driver can return a dwModeIndex of -1 if in
		    // a currently unsupported mode. Therefore, we must not
		    // initialize these masks if such an index has been
		    // returned.
		    if( 0xFFFFFFFFUL != pddd->dwModeIndex )
		    {
			pddd->lpModeInfo[ pddd->dwModeIndex ].dwRBitMask = pddd->vmiData.ddpfDisplay.dwRBitMask;
			pddd->lpModeInfo[ pddd->dwModeIndex ].dwGBitMask = pddd->vmiData.ddpfDisplay.dwGBitMask;
			pddd->lpModeInfo[ pddd->dwModeIndex ].dwBBitMask = pddd->vmiData.ddpfDisplay.dwBBitMask;
		    }
		    DPF(5, "Setting the bitmasks for the driver (R:%04lx G:%04lx B:%04lx)",
			pddd->vmiData.ddpfDisplay.dwRBitMask,
			pddd->vmiData.ddpfDisplay.dwGBitMask,
			pddd->vmiData.ddpfDisplay.dwBBitMask);
		}
	    }
	    else
	#else
	    /*
	     * Grab masks from NT driver
	     */
	    pddd->vmiData.ddpfDisplay.dwRBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwRBitMask;
	    pddd->vmiData.ddpfDisplay.dwGBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwGBitMask;
	    pddd->vmiData.ddpfDisplay.dwBBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwBBitMask;
	    if( 0xFFFFFFFFUL != pddd->dwModeIndex )
	    {
		pddd->lpModeInfo[ pddd->dwModeIndex ].dwRBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwRBitMask;
		pddd->lpModeInfo[ pddd->dwModeIndex ].dwGBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwGBitMask;
		pddd->lpModeInfo[ pddd->dwModeIndex ].dwBBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwBBitMask;
	    }
	    DPF(5, "Setting the bitmasks for the driver (R:%04lx G:%04lx B:%04lx)",
		pddd->vmiData.ddpfDisplay.dwRBitMask,
		pddd->vmiData.ddpfDisplay.dwGBitMask,
		pddd->vmiData.ddpfDisplay.dwBBitMask);
	#endif
	    {
		if( !reset )
		{
		    pddd->dwPDevice = 0;
		    pddd->lpwPDeviceFlags = (WORD *)&dwFakeFlags;
		}
	    }

	/*
	 * fourcc codes...
	 */
        MemFree( pddd->lpdwFourCC );
        pddd->lpdwFourCC = NULL;
        if (oldpdd != NULL)
        {
            oldpdd->lpdwFourCC = NULL;
        }
	pddd->ddCaps.dwNumFourCCCodes = lpDDHALInfo->ddCaps.dwNumFourCCCodes;
	pddd->dwNumFourCC = pddd->ddCaps.dwNumFourCCCodes;
	if( pddd->ddCaps.dwNumFourCCCodes > 0 )
	{
	    size = pddd->ddCaps.dwNumFourCCCodes * sizeof( DWORD );
	    pddd->lpdwFourCC = MemAlloc( size );
	    if( pddd->lpdwFourCC == NULL )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate FOURCC data!" );
		goto ErrorExit;
	    }
	    memcpy( pddd->lpdwFourCC, lpDDHALInfo->lpdwFourCC, size );
	}

    /*
     * Extended 3D caps structure
     *
     */
    if ( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET )
    {
        HRESULT ret;
        DDHAL_GETDRIVERINFODATA gdidata;

        if (oldpdd != NULL)
        {
            oldpdd->lpD3DExtendedCaps = 0;
        }

        if (! pddd->lpD3DExtendedCaps)
        {
            pddd->lpD3DExtendedCaps = MemAlloc( D3DHAL_D3DEXTENDEDCAPSSIZE );
        }
        if (! pddd->lpD3DExtendedCaps)
        {
            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not allocate D3D extended caps structure" );
        }
        else
        {
            memset( (LPVOID) pddd->lpD3DExtendedCaps, 0, D3DHAL_D3DEXTENDEDCAPSSIZE );
            ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo,
                      &gdidata,
                      (LPVOID) pddd->lpD3DExtendedCaps,
                      D3DHAL_D3DEXTENDEDCAPSSIZE,
                      &GUID_D3DExtendedCaps, 
                      pddd,
                      FALSE /* bInOut */);

            if (ret != DD_OK)
            {
                DPF ( 2,"D3D Extended Caps query failed" );
                MemFree( (LPVOID) pddd->lpD3DExtendedCaps );
                pddd->lpD3DExtendedCaps = 0;
            }
        }

        // Extended caps was not compulsory for pre-DX6 drivers.
        // Extended caps is compulsory for DX6+ drivers since it contains
        // information about the driver's multitexture capabilities, FVF
        // support and stencil support.
        if (pddd->lpD3DHALCallbacks3->DrawPrimitives2)
        {
            if (pddd->lpD3DExtendedCaps == NULL)
            {
                DPF_ERR ( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:DX6+ drivers should report D3D Extended Caps, failing driver creation" );
                goto ErrorExit;
            }
            else if (gdidata.dwActualSize != pddd->lpD3DExtendedCaps->dwSize)
            {
                DPF_ERR ( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Actual size reported is not equal to dwSize field in the Extended caps structure" );
                goto ErrorExit;
            }
            else if (pddd->lpD3DExtendedCaps->dwSize < D3DHAL_D3DDX6EXTENDEDCAPSSIZE)
            {
                DPF_ERR ( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Driver reported insufficient D3D Extended Caps, failing driver creation" );
                goto ErrorExit;
            }

            // If stencil capabilities are reported the driver should have
            // exported Clear2
            if (pddd->lpD3DExtendedCaps->dwStencilCaps != 0)
            {
                if ((pddd->lpD3DHALCallbacks3->Clear2 == NULL) &&
                    (0 == pddd->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState)
                   )
                {
                    DPF_ERR ( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Pre DX7 Driver should report clear2 if any stencilcaps are set, failing driver creation" );
                    goto ErrorExit;
                }
            }
        }
    }
    else    // Driver doesn't have DDHALINFO_GETDRIVERINFOSET
    {
        if (pddd->lpD3DExtendedCaps)
        {
            memset( (LPVOID) pddd->lpD3DExtendedCaps, 0, D3DHAL_D3DEXTENDEDCAPSSIZE );
            if (oldpdd)
            {
                oldpdd->lpD3DExtendedCaps = NULL;
            }
        }
    }

        if (lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFO2)
        {
            pddd->dwFlags |= DDRAWI_DRIVERINFO2;
        }

	/*
	 * video port descriptions
	 */
	if ( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET )
	{
	    MemFree( pddd->lpDDVideoPortCaps );
	    pddd->lpDDVideoPortCaps = NULL;
            if (oldpdd != NULL)
            {
	        oldpdd->lpDDVideoPortCaps = NULL;
            }
	    pddd->ddCaps.dwMaxVideoPorts = lpDDHALInfo->ddCaps.dwMaxVideoPorts;
	    if( pddd->ddCaps.dwMaxVideoPorts > 0 )
	    {
		HRESULT ret;
		DDHAL_GETDRIVERINFODATA gdidata;

		size = pddd->ddCaps.dwMaxVideoPorts * sizeof( DDVIDEOPORTCAPS );
		pddd->lpDDVideoPortCaps = MemAlloc( size );
		if( pddd->lpDDVideoPortCaps == NULL )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate video port caps!" );
		    goto ErrorExit;
		}
		memset( pddd->lpDDVideoPortCaps, 0, size );

		ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo,
				    &gdidata,
				    pddd->lpDDVideoPortCaps,
				    size,
				    &GUID_VideoPortCaps, pddd,
                                    FALSE /* bInOut */);

		if (ret != DD_OK)
		{
		    DPF ( 2,"VideoPortCaps query failed" );
		    MemFree(pddd->lpDDVideoPortCaps);
		    pddd->lpDDVideoPortCaps = NULL;
		}
	    }
	}

	/*
	 * Kernel mode capabilities
	 *
	 * We only get these once we munge them when creating the driver
	 * object and we don't want to munge them everytime.  We do need
	 * to munge the video port caps, however, to reflect the autoflip
	 * capabilities.
	 */
	if ( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET )
	{
	    if (pddd->lpDDKernelCaps == NULL)
	    {
		HRESULT ret;
		DDHAL_GETDRIVERINFODATA gdidata;

		size = sizeof( DDKERNELCAPS );
		pddd->lpDDKernelCaps = MemAlloc( size );
		if( pddd->lpDDKernelCaps == NULL )
		{
		   DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate kernel caps!" );
		   goto ErrorExit;
		}
		memset( pddd->lpDDKernelCaps, 0, size );

		ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo,
				    &gdidata,
				    pddd->lpDDKernelCaps,
				    size,
				    &GUID_KernelCaps, pddd,
                                    FALSE /* bInOut */);
		#ifdef WIN95
		    if( !IsWindows98() )
		    {
			ret = DDERR_GENERIC;
		    }
		#endif

		if (ret != DD_OK)
		{
		    DPF ( 2, "KernelCaps query failed" );
		    MemFree(pddd->lpDDKernelCaps);
		    pddd->lpDDKernelCaps = NULL;
		    }
	    }
#ifdef WIN95
	    else
	    {
		MungeAutoflipCaps(pddd);
	    }
#endif
	}

	/*
	 * fill in rops
	 */
	if( lpDDHALInfo->ddCaps.dwCaps & DDCAPS_BLT )
	{
	    for( i=0;i<DD_ROP_SPACE;i++ )
	    {
		pddd->ddCaps.dwRops[i] = lpDDHALInfo->ddCaps.dwRops[i];
	    }
	}

	/*
	 * get (or generate) the non-local video memory caps.
	 */
	MemFree( pddd->lpddNLVCaps );
	pddd->lpddNLVCaps = NULL;
        if (oldpdd != NULL)
        {
            oldpdd->lpddNLVCaps = NULL;
        }
	if( !GetNonLocalVidMemCaps( lpDDHALInfo, pddd ) )
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not initialize non-local video memory caps" );
	    goto ErrorExit;
	}

	/*
	 * Get the driver's extended capabilities.
	 */
	if( !GetDDMoreCaps( lpDDHALInfo, pddd ) )
	{
	    // An error occurred during GetDDMoreCaps() call above.
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not initialize extended caps" );
	    goto ErrorExit;
	}

	/*
	 * Direct3D data structures
	 */
//#ifdef WINNT
//	MemFree((void *)pddd->lpD3DHALCallbacks);
//#endif
	if( lpDDHALInfo->dwSize >= DDHALINFOSIZE_V2 )
	{
	    // Direct3D data is present
	    pddd->lpD3DGlobalDriverData = lpDDHALInfo->lpD3DGlobalDriverData;
	    pddd->lpD3DHALCallbacks = lpDDHALInfo->lpD3DHALCallbacks;
            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF( 5, "DDHALInfo contains D3D pointers: 0x%p 0x%p", pddd->lpD3DGlobalDriverData, pddd->lpD3DHALCallbacks);
	}
	else
	{
	    // No Direct3D data present in DDHALInfo
	    pddd->lpD3DGlobalDriverData = 0;
	    pddd->lpD3DHALCallbacks = 0;
	    DPF( 1, "No Direct3D Support in driver");
	}

	freevm = 0;
#ifndef WINNT
        /*
         * NT kernel does the memory management now
         */
	MemFree( pddd->vmiData.pvmList );
        pddd->vmiData.pvmList = NULL;
        if (oldpdd != NULL)
        {
            oldpdd->vmiData.pvmList = NULL;
        }
	if( pddd->vmiData.dwNumHeaps > 0 )
	{
	    size = sizeof( VIDMEM ) * pddd->vmiData.dwNumHeaps;
	    pddd->vmiData.pvmList = MemAlloc( size );
	    if( pddd->vmiData.pvmList == NULL )
	    {
	       DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate heap info!" );
	       goto ErrorExit;
	    }
	}

	devheapno = 0;
	for( i=0;i<(int)lpDDHALInfo->vmiData.dwNumHeaps;i++ )
	{
	    /*
	     * Ask driver for any additional heap alignment requirements
	     */
	    DDHAL_GETHEAPALIGNMENTDATA ghad;
	    LPHEAPALIGNMENT pghad=0;
	    /*
	     * pghad will be null if no alignment
	     */
	    pghad = GetExtendedHeapAlignment(pddd, &ghad, i );

	    if( !( lpDDHALInfo->vmiData.pvmList[i].dwFlags & VIDMEM_ISNONLOCAL ) || isagpaware )
	    {
		DWORD dwHeapFlags;

		pvm = &(pddd->vmiData.pvmList[devheapno]);
		*pvm = lpDDHALInfo->vmiData.pvmList[i];

		dwHeapFlags = 0UL;

		/*
		 * if a heap is specified, then we don't need to allocate
		 * one ourselves (for shared media devices)
		 */
		if( !(pvm->dwFlags & VIDMEM_ISHEAP) )
		{
		    #ifdef DEBUG
			if( pvm->dwFlags & VIDMEM_ISLINEAR )
			{
			    int vram = GetProfileInt("DirectDraw", "vram", -1);

			    if (vram > 0 && (pvm->fpStart + vram*1024L-1) < pvm->fpEnd)
			    {
                                // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
				DPF( 1, "pretending display card has only %dk VRAM", vram);
				DPF( 1, "pvm->fpStart = 0x%p, pvm->fpEnd = 0x%p", pvm->fpStart, pvm->fpEnd );
				pvm->fpEnd = pvm->fpStart + vram*1024L-1;
			    }
			}
		    #endif
		    DPF(5,V,"Heap #%d is 0x%08x x 0x%08x",devheapno,pvm->dwWidth,pvm->dwHeight);
		    if ( ! HeapVidMemInit( pvm, pddd->vmiData.lDisplayPitch, hDDVxd , pghad ) )
		    {
			pvm->lpHeap = NULL;

                        /*
                         * If this is an AGP heap, we probably failed because we couldn't reserve
                         * any AGP memory.  This this case, we simply want to remove the heap
                         * rather than fail to emulation.  We do not want to remove the AGP
                         * caps, however, since some drivers (e.g. nVidia) can allocate it
                         * without using our heap.
                         */
                        if( pvm->dwFlags & VIDMEM_ISNONLOCAL )
                        {
                            /*
                             * At this time, dwNumHeaps should always be greater than 0,
                             * but I added the check anyway in case something changes later.
                             */
                            if( pddd->vmiData.dwNumHeaps > 0 )
                            {
                                if( --pddd->vmiData.dwNumHeaps == 0 )
                                {
                                    MemFree( pddd->vmiData.pvmList );
                                    pddd->vmiData.pvmList = NULL;
                                }
                            }
                            continue;
                        }
		    }
		}

		if( pvm->lpHeap == NULL )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not create video memory heap!" );
		    for( j=0;j<devheapno;j++ )
		    {
			pvm = &(pddd->vmiData.pvmList[j]);
			HeapVidMemFini( pvm, hDDVxd );
	    }
		    goto ErrorExit;
		}

		freevm += VidMemAmountFree( pvm->lpHeap );

		devheapno++;
	    }
	    else
	    {
		/*
		 * This is an AGP memory heap but the operating system
		 * does not have the necessary AGP extensions. Discard
		 * this heap descriptor.
		 */
		DPF( 1, "Discarding AGP heap %d. OS does not have AGP support", i );
	    }
        }
#endif //not WINNT
	pddd->ddCaps.dwVidMemTotal = freevm;

	/*
	 * Grab any extended surface caps and heap restrictions from the driver
	 */
	if( !GetDDMoreSurfaceCaps( lpDDHALInfo, pddd ) )
	{
	    // An error occurred during GetDDMoreCaps() call above.
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not initialize extended surface caps" );
	    goto ErrorExit;
	}

	/*
	 * Differences between win95 and NT HAL setup.
	 * On Win95, the 32bit entry points (DDHALCALLBACKS.DDHAL...) are reset to point to the
	 * helper functions inside w95hal.c, and only overwritten (with what comes in in the
	 * DDHALINFO structure from the driver) if the corresponding bit is set in the DDHALINFO's
	 * lpDD*...dwFlags coming in from the driver.
	 * On NT, there's no thunking, so the only use for the pointers stored in the
	 * DDHALCALLBACKS.cb... entries is deciding if there's a HAL function pointer before
	 * doing a HALCALL. Since the 32 bit callbacks are not initialized to point
	 * to the w95hal.c stubs, we zero them out before copying the individual driver callbacks
	 * one by one.
	 */

	/*
	 * set up driver HAL
	 */
	#ifdef WIN95
	    //Initialise HAL to 32-bit stubs in w95hal.c:
	    pddd->lpDDCBtmp->HALDD = ddHALDD;
	#else
	    memset(&pddd->lpDDCBtmp->HALDD,0,sizeof(pddd->lpDDCBtmp->HALDD));
	#endif
	drvcb = lpDDHALInfo->lpDDCallbacks;
	if( drvcb != NULL )
	{
	    numcb = NUM_CALLBACKS( drvcb );
            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF(5,"DDHal callback flags:%08x",drvcb->dwFlags);
	    for (i=0;i<numcb;i++) DPF(5,"   0x%p",(&drvcb->DestroyDriver)[i]);

	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( drvcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    (&pddd->lpDDCBtmp->HALDD.DestroyDriver)[i] = (&drvcb->DestroyDriver)[i];
		}
		bit <<= 1;
	    }
	}

	/*
	 * set up surface HAL
	 */
	#ifdef WIN95
	    pddd->lpDDCBtmp->HALDDSurface = ddHALDDSurface;
	#else
	    memset(&pddd->lpDDCBtmp->HALDDSurface,0,sizeof(pddd->lpDDCBtmp->HALDDSurface));
	#endif
	surfcb = lpDDHALInfo->lpDDSurfaceCallbacks;
	if( surfcb != NULL )
	{
	    numcb = NUM_CALLBACKS( surfcb );
	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( surfcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    (&pddd->lpDDCBtmp->HALDDSurface.DestroySurface)[i] = (&surfcb->DestroySurface)[i];
		}
		bit <<= 1;
	    }
	}

	/*
	 * set up palette callbacks
	 */
	#ifdef WIN95
	    pddd->lpDDCBtmp->HALDDPalette = ddHALDDPalette;
	#else
	    memset (&pddd->lpDDCBtmp->HALDDPalette,0,sizeof(pddd->lpDDCBtmp->HALDDPalette));
	#endif
	palcb = lpDDHALInfo->lpDDPaletteCallbacks;
	if( palcb != NULL )
	{
	    numcb = NUM_CALLBACKS( palcb );
	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( palcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    (&pddd->lpDDCBtmp->HALDDPalette.DestroyPalette)[i] = (&palcb->DestroyPalette)[i];
		}
		bit <<= 1;
	    }
	}

	/*
	 * set up execute buffer callbacks
	 * NOTE: Need explicit check for V2 driver as V1 driver knows nothing
	 * about these. For an old driver the default HAL callback table will
	 * be used unmodified.
	 */
	#ifdef WIN95
	    pddd->lpDDCBtmp->HALDDExeBuf = ddHALDDExeBuf;
	#endif
	if( lpDDHALInfo->dwSize >= DDHALINFOSIZE_V2 )
	{
	    exebufcb = lpDDHALInfo->lpDDExeBufCallbacks;
	    if( exebufcb != NULL )
	    {
		numcb = NUM_CALLBACKS( exebufcb );
		bit = 1;
		for( i=0;i<numcb;i++ )
		{
		    if( exebufcb->dwFlags & bit )
		    {
                        // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
			(&pddd->lpDDCBtmp->HALDDExeBuf.CanCreateExecuteBuffer)[i] = (&exebufcb->CanCreateExecuteBuffer)[i];
		    }
		    bit <<= 1;
		}
	    }
	}

	/*
	 * make sure we wipe out old callbacks!
	 */
	memset( &pddd->lpDDCBtmp->cbDDCallbacks, 0, sizeof( pddd->lpDDCBtmp->cbDDCallbacks ) );
	memset( &pddd->lpDDCBtmp->cbDDSurfaceCallbacks, 0, sizeof( pddd->lpDDCBtmp->cbDDSurfaceCallbacks ) );
	memset( &pddd->lpDDCBtmp->cbDDPaletteCallbacks, 0, sizeof( pddd->lpDDCBtmp->cbDDPaletteCallbacks ) );
	memset( &pddd->lpDDCBtmp->cbDDExeBufCallbacks,  0, sizeof( pddd->lpDDCBtmp->cbDDExeBufCallbacks ) );

	/*
	 * copy callback routines
	 */
	if( lpDDHALInfo->lpDDCallbacks != NULL )
	{
	    memcpy( &pddd->lpDDCBtmp->cbDDCallbacks, lpDDHALInfo->lpDDCallbacks,
		    (UINT) lpDDHALInfo->lpDDCallbacks->dwSize );
	}
	if( lpDDHALInfo->lpDDSurfaceCallbacks != NULL )
	{
	    memcpy( &pddd->lpDDCBtmp->cbDDSurfaceCallbacks, lpDDHALInfo->lpDDSurfaceCallbacks,
		    (UINT) lpDDHALInfo->lpDDSurfaceCallbacks->dwSize );
	}
	if( lpDDHALInfo->lpDDPaletteCallbacks != NULL )
	{
	    memcpy( &pddd->lpDDCBtmp->cbDDPaletteCallbacks, lpDDHALInfo->lpDDPaletteCallbacks,
		    (UINT) lpDDHALInfo->lpDDPaletteCallbacks->dwSize );
	}
	if( ( lpDDHALInfo->dwSize >= DDHALINFOSIZE_V2  ) &&
	    ( lpDDHALInfo->lpDDExeBufCallbacks != NULL ) )
	{
	    memcpy( &pddd->lpDDCBtmp->cbDDExeBufCallbacks, lpDDHALInfo->lpDDExeBufCallbacks,
		    (UINT) lpDDHALInfo->lpDDExeBufCallbacks->dwSize );
	}

#ifndef WIN95
        if (pddd->lpDDCBtmp->HALDDNT.SetExclusiveMode)
        {
            pddd->lpDDCBtmp->HALDD.SetExclusiveMode =
                pddd->lpDDCBtmp->cbDDCallbacks.SetExclusiveMode =
                    pddd->lpDDCBtmp->HALDDNT.SetExclusiveMode;
        }
        if (pddd->lpDDCBtmp->HALDDNT.FlipToGDISurface)
        {
            pddd->lpDDCBtmp->HALDD.FlipToGDISurface =
                pddd->lpDDCBtmp->cbDDCallbacks.FlipToGDISurface =
                   pddd->lpDDCBtmp->HALDDNT.FlipToGDISurface;
        }
#endif

	/*
	 * init shared caps
	 */
	capsInit( pddd );
        mergeHELCaps( pddd );

	/*
	 * if we were asked to reset, keep the new data
	 */
	if( reset )
	{
	    /*
	     * copy new structure onto original one
	     * being careful to preserve lpDDCB
	     */
	    {
		LPDDHAL_CALLBACKS save_ptr = oldpdd->lpDDCBtmp;
		memcpy( oldpdd, pddd, drv_callbacks_size );
		oldpdd->lpDDCBtmp = save_ptr;
	    }
	    MemFree( pddd );
	    pddd = oldpdd;
	}
    }
    else
    {
	DPF( 4, "Driver object already exists" );
	#ifdef DEBUG
	    /*
	     * pddd is now allocated at the top of the routine, before the if that goes
	     * with the preceding else... jeffno 960115
	     */
	    if (pddd)
	    {
		DPF(4,"Allocated space for a driver object when it wasn't necessary!");
	    }
	#endif
	MemFree(pddd);  //should be NULL, just in case...
	pddd = oldpdd;
    }

    /*
     * set bank switched
     */
    if( pddd->dwFlags & DDRAWI_DISPLAYDRV )
    {
	HDC     hdc;
	hdc = DD_CreateDC( szDrvName );
	if( DCIIsBanked( hdc ) ) //NT_FIX??
	{
	    pddd->ddCaps.dwCaps |= DDCAPS_BANKSWITCHED;
	    DPF( 2, "Setting DDCAPS_BANKSWITCHED" );
	}
	else
	{
	    pddd->ddCaps.dwCaps &= ~DDCAPS_BANKSWITCHED;
	    DPF( 2, "NOT Setting DDCAPS_BANKSWITCHED" );
	}
	DD_DoneDC( hdc );

        /*
         * Display drivers can all render windowed
         */
        //BEGIN VOODOO2 HACK
        if ( (0 == (dwRegFlags & DDRAW_REGFLAGS_ENUMERATEATTACHEDSECONDARIES)) ||
             (IsVGADevice( szDrvName )) )
        //END VOODOO2 HACK
        {
            pddd->ddCaps.dwCaps2 |= DDCAPS2_CANRENDERWINDOWED;
        }
    }
    InitGamma( pddd, szDrvName );

    /*
     * Disable non-local video memory if the operating system
     * is not AGP aware.
     */
    if( ( pddd->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM ) && !isagpaware )
    {
	DPF( 2, "OS is not AGP aware. Disabling DDCAPS2_NONLOCALVIDMEM" );
	pddd->ddCaps.dwCaps2 &= ~DDCAPS2_NONLOCALVIDMEM;
    }

    if( !( pddd->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM ))
    {
	if (lpDDHALInfo->lpD3DGlobalDriverData && (lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURENONLOCALVIDMEM))
	{   //some drivers(Riva128 on PCI) incorrectly sets D3DDEVCAPS_TEXTURENONLOCALVIDMEM
            DPF( 1, "driver set D3DDEVCAPS_TEXTURENONLOCALVIDMEM w/o DDCAPS2_NONLOCALVIDMEM:turning off D3DDEVCAPS_TEXTURENONLOCALVIDMEM" );
	    lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps &= ~D3DDEVCAPS_TEXTURENONLOCALVIDMEM;
	}
    }

    #ifdef USE_ALIAS
	/*
	 * Can we use VRAM aliasing and PDEVICE modification to avoid taking
	 * the Win16 lock when locking a VRAM surface? Can't if the device is
	 * bankswitched or if the DIB Engine is not a version we recognize.
	 */
	if (!(lpDDHALInfo->ddCaps.dwCaps & DDCAPS_NOHARDWARE))
	{
	    if( ( pddd->dwFlags & DDRAWI_DISPLAYDRV )           &&
		( ( pddd->ddCaps.dwCaps & DDCAPS_BANKSWITCHED ) || ( !DD16_FixupDIBEngine() ) ) )
	    {
		pddd->dwFlags |= DDRAWI_NEEDSWIN16FORVRAMLOCK;
		DPF( 2, "Win16 lock must be taken for VRAM locks" );
	    }
	    else
	    {
		pddd->dwFlags &= ~DDRAWI_NEEDSWIN16FORVRAMLOCK;
		DPF( 2, "Taking the Win16 lock may not be necessary for VRAM locks" );
	    }

	    /*
	     * Create the virtual memory heap aliases for this global object
	     */
	    if(  ( pddd->dwFlags & DDRAWI_DISPLAYDRV ) &&
		!( pddd->dwFlags & DDRAWI_NEEDSWIN16FORVRAMLOCK ) )
	    {
		DDASSERT( INVALID_HANDLE_VALUE != hDDVxd );
		if( FAILED( CreateHeapAliases( hDDVxd, pddd ) ) )
		{
                    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not create the heap aliases for driver object 0x%p", pddd );
		    goto ErrorExit;
		}
	    }
	}
    #endif /* USE_ALIAS */

#ifdef WIN95
    /*
     * If we have a driver which has AGP support and which has provided us with a
     * notification callback so that we can tell it the GART linear and physical
     * addresses of the heaps it provided to us then invoke that callback now
     * for the non-local heaps we initialized.
     */
    if( (NULL != pddd) && (pddd->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM) )
    {
	LPDDHAL_UPDATENONLOCALHEAP   unlhfn;
	DDHAL_UPDATENONLOCALHEAPDATA unlhd;
	LPVIDMEM                     lpHeap;
	DWORD                        rc;

	unlhfn = pddd->lpDDCBtmp->HALDDMiscellaneous.UpdateNonLocalHeap;
	if( NULL != unlhfn )
	{
	    unlhd.lpDD               = pddd;
            unlhd.ulPolicyMaxBytes   = dwAGPPolicyMaxBytes;
	    unlhd.ddRVal             = DDERR_GENERIC; /* Force the driver to return something sensible */
	    unlhd.UpdateNonLocalHeap = NULL;
	    for( i = 0; i < (int)pddd->vmiData.dwNumHeaps; i++ )
	    {
		lpHeap = &pddd->vmiData.pvmList[i];
		if( lpHeap->dwFlags & VIDMEM_ISNONLOCAL )
		{
		    DPF( 4, "Notifying driver of update to non-local heap %d", i );
		    unlhd.dwHeap    = i;
		    unlhd.fpGARTLin = lpHeap->lpHeap->fpGARTLin;
		    unlhd.fpGARTDev = lpHeap->lpHeap->fpGARTDev;
		    DOHALCALL( UpdateNonLocalHeap, unlhfn, unlhd, rc, FALSE );

		    /*
		     * Currently this callback is pure notification. The driver
		     * cannot fail it.
		     */
		    DDASSERT( DDHAL_DRIVER_HANDLED == rc );
		    DDASSERT( DD_OK == unlhd.ddRVal );
		}
	    }
	}
    }
#endif

    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 5, "DirectDrawObjectCreate: Returning global object 0x%p", pddd );

    #ifdef WINNT
	MemFree(lpDDHALInfo->lpdwFourCC);
	MemFree(lpDDHALInfo->vmiData.pvmList);
    #endif

    LEAVE_DDRAW();
    return pddd;

ErrorExit:
    // We must not free memory in the reset path, since the oldpdd will survive this
    // call to DirectDrawObjectCreate, and be freed by IDD::Release sometime later.
    // We will not NULL out all these ptrs either, since that would invite a bazillion
    // stress failures elsewhere in the code. We will leave the ptrs valid, but set
    // DDUNSUPPORTEDMODE in the mode index, both to throttle further usage of this ddraw
    // global (which now is full of caps etc. from the wrong mode) and as an indicator 
    // that this is what happened in future stress investigations.
    // We are also going to wimp out and change only the NT path.

    if (pddd
#ifdef WINNT
        && !reset
#endif
        )
    {
	MemFree( pddd->lpDDVideoPortCaps );
	MemFree( pddd->lpddNLVCaps );
	MemFree( pddd->lpddNLVHELCaps );
	MemFree( pddd->lpddNLVBothCaps );
	MemFree( pddd->lpD3DHALCallbacks2 );
	MemFree( pddd->lpD3DHALCallbacks3 );
	MemFree( pddd->lpZPixelFormats );
	MemFree( pddd->lpddMoreCaps );
	MemFree( pddd->lpddHELMoreCaps );
	MemFree( pddd->lpddBothMoreCaps );
    #ifdef POSTPONED
	MemFree( pddd->lpDDOptSurfaceInfo );
	MemFree( pddd->lpDDUmodeDrvInfo );
    #endif //POSTPONED
    #ifdef WINNT
    	if (pddd->hDD != 0)
	{
            // Delete the object if not resetting. If we were just resetting
            // we should not delete it as it may work later; the call to
            // enable or query the DirectDraw object may have failed because
            // the system is displaying the logon desktop, or is in 4 bpp or
            // another unsupported mode.
            if (!reset)
            {
                DdDeleteDirectDrawObject(pddd);
            }
	}
    #endif //WINNT
	MemFree( pddd );
    }
#ifdef WINNT
    if (reset && pddd)
    {
        pddd->dwModeIndex = DDUNSUPPORTEDMODE;
    }

    MemFree(lpDDHALInfo->lpdwFourCC);
    MemFree(lpDDHALInfo->vmiData.pvmList);
    if (ismemalloced && !reset)
    {
        MemFree(pd3dNTHALCallbacks);
    }
#endif
    LEAVE_DDRAW();
    return NULL;

} /* DirectDrawObjectCreate */

#pragma message( REMIND( "I'm drowning in a sea of ancient unfixed pragma reminders" ) )

/*
 * CleanUpD3DHAL
 *
 * Notify the Direct3D driver using the ContextDestroyAll callbacks
 * that the given process has died so that it may cleanup any context
 * associated with that process.
 *
 * NOTE: This function is only invoked if we have Direct3D
 * support in the DirectDraw driver and if the process
 * terminates without cleaning up normally.
 *
 * I would call the ContextDestroyAll callback directly from here
 * instead of through this convoluted exported fn, but d3dhal.h
 * can't be included here because of the dependencies.
 */

void CleanUpD3DHAL(LPD3DHAL_CALLBACKS lpD3DHALCallbacks, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl)
{
    D3DHALCleanUpProc lpD3DHALCleanUpProc;
    HINSTANCE   hD3DInstance;
    if (DDRAWILCL_DIRECTDRAW7 & pdrv_lcl->dwLocalFlags)
    {
         hD3DInstance = LoadLibrary( D3DDX7_DLLNAME );
	 DPF(4,"Calling %s in %s",D3DHALCLEANUP_PROCNAME,D3DDX7_DLLNAME);
    }
    else
    {
         hD3DInstance = LoadLibrary( D3D_DLLNAME );
	 DPF(4,"Calling %s in %s",D3DHALCLEANUP_PROCNAME,D3D_DLLNAME);
    }

    // Attempt to locate the cleanup entry point.
    if (0 != hD3DInstance)
    {
        lpD3DHALCleanUpProc = (D3DHALCleanUpProc)GetProcAddress( hD3DInstance,
							         D3DHALCLEANUP_PROCNAME );
        if( NULL == lpD3DHALCleanUpProc )
        {
	    // this is really either an internal error, or d3dim.dll is suddenly missing
	    DPF(0,"Error: can't find cleanup entry point %s in %s, driver's 3D resources won't be freed",D3DHALCLEANUP_PROCNAME,D3D_DLLNAME);
        }
        else
        {
            (*lpD3DHALCleanUpProc)( lpD3DHALCallbacks, pid );
        }
        FreeLibrary(hD3DInstance);
    }
}

#ifdef WIN95

/*
 * CurrentProcessCleanup
 *
 * make sure terminating process cleans up after itself...
 */
BOOL CurrentProcessCleanup( BOOL was_term )
{
    DWORD                       pid;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_link_int;
    BOOL                        rc;
    BOOL                        fD3DCleanedUp;

    ENTER_DDRAW();

    pid = GETCURRPID();
    pdrv_int = lpDriverObjectList;
    rc = FALSE;
    fD3DCleanedUp = FALSE;

    /*
     * run through each driver, looking for the current process handle
     * Delete all local objects created by this process.
     */
    while( pdrv_int != NULL )
    {
	pdrv_link_int = pdrv_int->lpLink;
	/*
	 * if we find the process, release it and remove it from list
	 */
	pdrv_lcl = pdrv_int->lpLcl;
	if( pdrv_lcl->dwProcessId == pid )
	{
	    DWORD       refcnt;

	    pdrv = pdrv_lcl->lpGbl;

            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF( 4, "Process %08lx still attached to driver 0x%p", pid, pdrv_int );
	    DPF( 5, "    Refcnt = %ld", pdrv_int->dwIntRefCnt );
	    if( pdrv != NULL )
	    {
		DPF( 5, "    DRV Refcnt = %ld", pdrv->dwRefCnt );
	    }

            // Clean up DX8
            #ifdef WIN95
                CleanupD3D8( pdrv, TRUE, pid);
            #endif

	    rc = TRUE;

	    /*
	     * D3D uses a bogus DDraw interface to create surfaces, which
	     * means that we AddRef the LCL and GBL, but since the INT is
	     * not in the lpDriverObjectList, we never release them.  The
	     * result is that LCL/GBLs are never released and this causes
	     * lots of problems (for example, we don't call DonExclusiveMode
	     * to turn off the 3DFX pass through).  If the process cleans up
	     * correctly, so does D3D, but if we cleanup on DDHELPs thread,
	     * D3D has already been unloaded.  The work-around is to
	     * determine if this is the last INT referncing the LCL and if
	     * the ref counts don't match, make the INT re count match the LCL.
	     */
	    if( dwHelperPid == GetCurrentProcessId() )
	    {
		LPDDRAWI_DIRECTDRAW_INT     pTemp_int;

		pTemp_int = lpDriverObjectList;
		while( pTemp_int != NULL )
		{
		    if( ( pTemp_int != pdrv_int ) &&
			( pTemp_int->lpLcl == pdrv_lcl ) )
		    {
			break;
		    }
		    pTemp_int = pTemp_int->lpLink;
		}
		if( pTemp_int == NULL )
		{
		    pdrv_int->dwIntRefCnt = pdrv_lcl->dwLocalRefCnt;
		}
	    }

	    /*
	     * punt process from any surfaces and palettes
	     */
	    if( pdrv != NULL )
	    {
#ifdef POSTPONED2
		ProcessSpriteCleanup( pdrv, pid );   // master sprite list
#endif //POSTPONED2
		ProcessSurfaceCleanup( pdrv, pid, NULL );
		ProcessPaletteCleanup( pdrv, pid, NULL );
		ProcessClipperCleanup( pdrv, pid, NULL );
		ProcessVideoPortCleanup( pdrv, pid, NULL );
	    }

	    /*
	     * Has the process terminated and a Direct3D driver
	     * object been queried off this driver object?
	     */
	    if( was_term && ( pdrv_lcl->pD3DIUnknown != NULL ) )
	    {
		/*
		 * Yes... so we need to do two things:
		 *
		 * 1) Simply discard the IUnknown interface pointer
		 *    for the Direct3D object as that object is now
		 *    gone (it was allocated by a local DLL in a
		 *    local heap of a process that is now gone).
		 *
		 * 2) If we have hardware 3D support and we have not
		 *    yet notified the driver of the death of this
		 *    process tell it now.
		 */
		DPF( 4, "Discarding Direct3D interface - process terminated" );
		pdrv_lcl->pD3DIUnknown = NULL;

		if( ( pdrv->lpD3DHALCallbacks != NULL ) && !fD3DCleanedUp )
		{
		    DPF( 4, "Notifying Direct3D driver of process termination" );
		    CleanUpD3DHAL( pdrv->lpD3DHALCallbacks, pid, pdrv_lcl);
		    fD3DCleanedUp = TRUE;
		}
	    }

	    /*
	     * now release the driver object
	     * If exclusive mode was held by this process, it will
	     * be relinquished when the local object is deleted.
	     */
	    refcnt = pdrv_int->dwIntRefCnt;
	    while( refcnt > 0 )
	    {
		DD_Release( (LPDIRECTDRAW) pdrv_int );
		refcnt--;
	    }
	}

	/*
	 * go to the next driver
	 */
	pdrv_int = pdrv_link_int;
    }

    /*
     * Release driver independent clippers owned by this process.
     */
    ProcessClipperCleanup( NULL, pid, NULL );

    /*
     * Remove any process entries from the window list.  They could be left
     * around if the window was subclassed.
     */
    CleanupWindowList( pid );

    LEAVE_DDRAW();
    DPF( 4, "Done with CurrentProcessCleanup, rc = %d", rc);
    return rc;

} /* CurrentProcessCleanup */

#endif //WIN95
/*
 * RemoveDriverFromList
 *
 * remove driver object from linked list of driver objects.
 * assumes DirectDraw lock is taken.
 */
void RemoveDriverFromList( LPDDRAWI_DIRECTDRAW_INT lpDD_int, BOOL final )
{
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int;
    LPDDRAWI_DIRECTDRAW_INT     pdlast_int;

    ENTER_DRIVERLISTCSECT();
    pdrv_int = lpDriverObjectList;
    pdlast_int = NULL;
    while( pdrv_int != NULL )
    {
	if( pdrv_int == lpDD_int )
	{
	    if( pdlast_int == NULL )
	    {
		lpDriverObjectList = pdrv_int->lpLink;
	    }
	    else
	    {
		pdlast_int->lpLink = pdrv_int->lpLink;
	    }
	    break;
	}
	pdlast_int = pdrv_int;
	pdrv_int = pdrv_int->lpLink;
    }
    #ifdef DEBUG
	if( pdrv_int == NULL )
	{
	    DPF( 3, "ERROR!! Could not find driver in global object list" );
	}
    #endif
    LEAVE_DRIVERLISTCSECT();

} /* RemoveDriverFromList */

/*
 * RemoveLocalFromList
 *
 * remove local object from linked list of local objects.
 * assumes DirectDraw lock is taken.
 */
void RemoveLocalFromList( LPDDRAWI_DIRECTDRAW_LCL this_lcl )
{
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdlast_lcl;

    ENTER_DRIVERLISTCSECT();
    pdrv_lcl = lpDriverLocalList;
    pdlast_lcl = NULL;
    while( pdrv_lcl != NULL )
    {
	if( pdrv_lcl == this_lcl )
	{
	    if( pdlast_lcl == NULL )
	    {
		lpDriverLocalList = pdrv_lcl->lpLink;
	    }
	    else
	    {
		pdlast_lcl->lpLink = pdrv_lcl->lpLink;
	    }
	    break;
	}
	pdlast_lcl = pdrv_lcl;
	pdrv_lcl = pdrv_lcl->lpLink;
    }
    #ifdef DEBUG
	if( pdrv_lcl == NULL )
	{
	    DPF( 3, "ERROR!! Could not find driver local in global list" );
	}
    #endif
    LEAVE_DRIVERLISTCSECT();

} /* RemoveLocalFromList */

/*
 * doneDC
 */
void DD_DoneDC( HDC hdc_dd )
{
    if( hdc_dd != NULL )
    {
        // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF( 5, "DeleteDC 0x%p", hdc_dd );
	DeleteDC( hdc_dd );
	hdc_dd = NULL;
    }

} /* doneDC */

#undef DPF_MODNAME
#define DPF_MODNAME     "DirectDrawCreate"

// prototype for helinit
BOOL HELInit( LPDDRAWI_DIRECTDRAW_GBL pdrv, BOOL helonly );

/*
 * helInit
 */
BOOL helInit( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD dwFlags, BOOL hel_only )
{

    if( (dwFlags & DDCREATE_HARDWAREONLY) )
    {
	return TRUE;
    }
    /*
     * get the HEL to fill in details:
     *
     * - dwHELDriverCaps
     * - dwHELStretchDriverCaps
     * - dwHELRopsSupported
     * - ddsHELCaps
     * - HELDD
     * - HELDDSurface
     * - HELDDPalette
     * - HELDDExeBuf
     */
    if( HELInit( pdrv, hel_only ) )
    {
	/*
	 * find the intersection of the driver and the HEL caps...
	 */
	pdrv->dwFlags |= DDRAWI_EMULATIONINITIALIZED;
	mergeHELCaps( pdrv );
    }
    else
    {
	DPF( 3, "HELInit failed" );
	pdrv->dwFlags |= DDRAWI_NOEMULATION;
    }

    return TRUE;

} /* helInit */

/*
 * createDC
 *
 * create a new DC given a device name.
 * doneDC() should be called to free DC
 *
 * the following are valid for device names:
 *
 *      DISPLAY      - the main display device via CreateDC("DISPLAY", ...)
 *                     this is the normal case.
 *
 *      foobar       - the foobar.drv via CreateDC("foobar", ...)
 *                     used for secondary displays listed in the registry
 *
 *      \\.\DisplayX - display device X via CreateDC(NULL,"\\.\DisplayX",...)
 *                     used on Memphis and NT5 for secondary displays
 *
 */
HDC DD_CreateDC( LPSTR pdrvname )
{
    HDC         hdc;
    UINT        u;

    DDASSERT( pdrvname != NULL );

#ifdef DEBUG
    if (pdrvname[0] == 0)
    {
	DPF( 3, "createDC() empty string!!!" );
	DebugBreak();
	return NULL;
    }
#endif

    #if defined(NT_FIX) || defined(WIN95)
	u = SetErrorMode( SEM_NOOPENFILEERRORBOX );
    #endif
    #ifdef WINNT
    	/*
	 * Note that DirectDraw refers to the driver for the primary monitor
	 * in a multimon system as "display", but NT uses "display" to refer
	 * to the desktop as a whole.  To handle this mismatch, we store
	 * NT's name for the primary monitor's driver in g_szPrimaryDisplay
	 * and substitute this name in place of "display" in our calls to NT.
	 */
        if ( GetSystemMetrics( SM_CMONITORS ) > 1 )
        {
	    if ( (_stricmp(pdrvname, DISPLAY_STR) == 0) )
	    {
	        if (g_szPrimaryDisplay[0] == '\0')
	        {
		    getPrimaryDisplayName();
	        }
	        pdrvname = g_szPrimaryDisplay;
	    }
        }
    #endif //WINNT

    DPF( 5, "createDC(%s)", pdrvname );

    if (pdrvname[0] == '\\' && pdrvname[1] == '\\' && pdrvname[2] == '.')
	hdc = CreateDC( NULL, pdrvname, NULL, NULL);
    else
	hdc = CreateDC( pdrvname, NULL, NULL, NULL);

    #if defined(NT_FIX) || defined(WIN95) //fix this error mode stuff
	SetErrorMode( u );
    #endif

    if (hdc == NULL)
    {
	DPF( 3, "createDC(%s) FAILED!", pdrvname );
    }

    return hdc;

} /* createDC */

/*
 * CreateFirstDC
 *
 * same as DD_CreateDC, except DDHELP is notified of the new driver.
 * used only durring
 */
static HDC DD_CreateFirstDC( LPSTR pdrvname )
{
    #ifdef WIN95
    if (pdrvname != NULL)
    {
	#ifndef WIN16_SEPARATE
	    LEAVE_DDRAW();
	#endif
	SignalNewDriver( pdrvname, TRUE );
	#ifndef WIN16_SEPARATE
	    ENTER_DDRAW();
	#endif
    }
    #endif

    return DD_CreateDC(pdrvname);

} /* createDC */


/*
 * strToGUID
 *
 * converts a string in the form xxxxxxxx-xxxx-xxxx-xx-xx-xx-xx-xx-xx-xx-xx
 * into a guid
 */
static BOOL strToGUID( LPSTR str, GUID * pguid )
{
    int         idx;
    LPSTR       ptr;
    LPSTR       next;
    DWORD       data;
    DWORD       mul;
    BYTE        ch;
    BOOL        done;

    idx = 0;
    done = FALSE;
    while( !done )
    {
	/*
	 * find the end of the current run of digits
	 */
	ptr = str;
	while( (*str) != '-' && (*str) != 0 )
	{
	    str++;
	}
	if( *str == 0 )
	{
	    done = TRUE;
	}
	else
	{
	    next = str+1;
	}

	/*
	 * scan backwards from the end of the string to the beginning,
	 * converting characters from hex chars to numbers as we go
	 */
	str--;
	mul = 1;
	data = 0;
	while( str >= ptr )
	{
	    ch = *str;
	    if( ch >= 'A' && ch <= 'F' )
	    {
		data += mul * (DWORD) (ch-'A'+10);
	    }
	    else if( ch >= 'a' && ch <= 'f' )
	    {
		data += mul * (DWORD) (ch-'a'+10);
	    }
	    else if( ch >= '0' && ch <= '9' )
	    {
		data += mul * (DWORD) (ch-'0');
	    }
	    else
	    {
		return FALSE;
	    }
	    mul *= 16;
	    str--;
	}

	/*
	 * stuff the current number into the guid
	 */
	switch( idx )
	{
	case 0:
	    pguid->Data1 = data;
	    break;
	case 1:
	    pguid->Data2 = (WORD) data;
	    break;
	case 2:
	    pguid->Data3 = (WORD) data;
	    break;
	default:
	    pguid->Data4[ idx-3 ] = (BYTE) data;
	    break;
	}

	/*
	 * did we find all 11 numbers?
	 */
	idx++;
	if( idx == 11 )
	{
	    if( done )
	    {
		return TRUE;
	    }
	    else
	    {
		return FALSE;
	    }
	}
	str = next;
    }
    return FALSE;

} /* strToGUID */

/*
 * getDriverNameFromGUID
 *
 * look up the name of a driver based on the interface id
 */
BOOL getDriverNameFromGUID( GUID *pguid, LPSTR pdrvname, BOOL *pisdisp, BOOL *pisprimary )
{
    DWORD       keyidx;
    HKEY        hkey;
    HKEY        hsubkey;
    char        keyname[256];
    DWORD       cb;
    DWORD       type;
    GUID        guid;

    *pisdisp = FALSE;
    *pdrvname = 0;

    /*
     * first check for a driver guid returned via EnumDisplayDevices.
     */
    if (pguid->Data1 >= DisplayGUID.Data1 &&
	pguid->Data1 <= DisplayGUID.Data1 + 32 &&
	memcmp(&pguid->Data2,&DisplayGUID.Data2,sizeof(GUID)-sizeof(DWORD))==0)
    {
	DISPLAY_DEVICEA dd;

	ZeroMemory(&dd, sizeof(dd));
	dd.cb = sizeof(dd);

	if (xxxEnumDisplayDevicesA(NULL, pguid->Data1 - DisplayGUID.Data1, &dd, 0)
        #ifdef WINNT
            && (dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)
        #endif
            )
	{
	    lstrcpy(pdrvname, dd.DeviceName);
	    if( dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE )
	    {
		*pisprimary = TRUE;
	    }
	    *pisdisp = TRUE;
	    return TRUE;
	}

	return FALSE;
    }

    if( RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDHW, &hkey ) )
    {
	DPF( 3, "No registry information for any drivers" );
	return FALSE;
    }
    keyidx = 0;

    /*
     * enumerate all subkeys under HKEY_LOCALMACHINE\Hardware\DirectDrawDrivers
     */
    while( !RegEnumKey( hkey, keyidx, keyname, sizeof( keyname ) ) )
    {
	if( strToGUID( keyname, &guid ) )
	{
	    if( !RegOpenKey( hkey, keyname, &hsubkey ) )
	    {
		if( IsEqualGUID( pguid, &guid ) )
		{
		    cb = MAX_PATH-1;
		    if( !RegQueryValueEx( hsubkey, REGSTR_KEY_DDHW_DRIVERNAME, NULL, &type,
				(CONST LPBYTE)pdrvname, &cb ) )
		    {
			if( type == REG_SZ )
			{
			    DPF( 5, "Found driver \"%s\"\n", pdrvname );
			    RegCloseKey( hsubkey );
			    RegCloseKey( hkey );
			    return TRUE;
			}
		    }
		    DPF_ERR( "Could not get driver name!" );
		    RegCloseKey( hsubkey );
		    RegCloseKey( hkey );
		    return FALSE;
		}
		RegCloseKey( hsubkey );
	    }
	}
	keyidx++;
    }
    RegCloseKey( hkey );
    return FALSE;

} /* getDriverNameFromGUID */

/*
 * NewDriverInterface
 *
 * contruct a new interface to an existing driver object
 */
LPVOID NewDriverInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPVOID lpvtbl )
{
    LPDDRAWI_DIRECTDRAW_INT     pnew_int;
    LPDDRAWI_DIRECTDRAW_LCL     pnew_lcl;
    DWORD                       size;

    if( (lpvtbl == &ddCallbacks)       ||
	(lpvtbl == &ddUninitCallbacks) ||
	(lpvtbl == &dd2UninitCallbacks) ||
	(lpvtbl == &dd2Callbacks) ||
	(lpvtbl == &dd4UninitCallbacks) ||
//      (lpvtbl == &ddUninitNonDelegatingUnknownCallbacks) ||
	(lpvtbl == &dd4Callbacks) ||
	(lpvtbl == &dd7UninitCallbacks) ||
	(lpvtbl == &dd7Callbacks) )
    {
	size = sizeof( DDRAWI_DIRECTDRAW_LCL );
    }
    else
    {
	return NULL;
    }

    pnew_lcl = MemAlloc( size );
    if( NULL == pnew_lcl )
    {
	return NULL;
    }
    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 5, "***New local allocated 0x%p for global pdrv 0x%p", pnew_lcl, pdrv );

    pnew_int = MemAlloc( sizeof( DDRAWI_DIRECTDRAW_INT ) );
    if( NULL == pnew_int )
    {
	MemFree( pnew_lcl );
	return NULL;
    }
    /*
     * set up data
     */
    ENTER_DRIVERLISTCSECT();
    pnew_int->lpVtbl = lpvtbl;
    pnew_int->lpLcl = pnew_lcl;
    pnew_int->dwIntRefCnt = 1;
    pnew_int->lpLink = lpDriverObjectList;
    lpDriverObjectList = pnew_int;

    pnew_lcl->lpGbl = pdrv;
    pnew_lcl->dwLocalRefCnt = 1;
    pnew_lcl->dwProcessId = GetCurrentProcessId();
    pnew_lcl->hGammaCalibrator = (ULONG_PTR) INVALID_HANDLE_VALUE;
    pnew_lcl->lpGammaCalibrator = NULL;
#ifdef WIN95
    pnew_lcl->SurfaceHandleList.dwList=NULL;
    pnew_lcl->SurfaceHandleList.dwFreeList=0;
#endif  //WIN95
    pnew_lcl->lpLink = lpDriverLocalList;
    lpDriverLocalList = pnew_lcl;
    if( pdrv != NULL )
    {
	pnew_lcl->lpDDCB = pdrv->lpDDCBtmp;
	pnew_lcl->lpGbl->dwRefCnt++;
#ifdef WIN95
        pnew_lcl->dwPreferredMode = pdrv->dwModeIndex;
#else
        pnew_lcl->dmiPreferred = pdrv->dmiCurrent;
#endif
    }

    #ifdef WIN95
	/*
	 * NOTE: We no longer get the DirectSound VXD handle at this point.
	 * We not get initialize it in InternalDirectDrawCreate(). This works
	 * well as the only two places this code currently gets invoked are
	 * the class factory stuff and DirectDrawCreate(). In the case of the
	 * class factory stuff this means there will be no VXD handle until
	 * initialize is called. This is not a problem, however, as there
	 * is nothing you can do with the VXD handle until Initialize() is
	 * called.
	 */
	pnew_lcl->hDDVxd = (DWORD) INVALID_HANDLE_VALUE;
    #endif /* WIN95 */

    /*
     * We lazily evaluate the Direct3D interface. Also note that
     * the Direct3D IUnknown goes into the local DirectDraw object
     * rather than the global one as the Direct3D DLL is not shared.
     * Everyone gets their own copy.
     */
    pnew_lcl->hD3DInstance = NULL;
    pnew_lcl->pD3DIUnknown = NULL;
    LEAVE_DRIVERLISTCSECT();

    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 5, "New driver object created, interface ptr = 0x%p", pnew_int );
    return pnew_int;

} /* NewDriverInterface */


/*
 * FetchDirectDrawData
 *
 * Go get new HAL info...
 */
LPDDRAWI_DIRECTDRAW_GBL FetchDirectDrawData(
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		BOOL reset,
		DWORD hInstance,
		HANDLE hDDVxd,
		char * szDrvName,
		DWORD dwDriverContext,
                LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{

	DWORD                           dw16BitVidmemInfo;
	DWORD                           dw32BitVidmemInfo;
	DDHALINFO                       ddhi;
	LPDDRAWI_DIRECTDRAW_GBL         newpdrv;
        BOOL                            bLoadedSecondary=FALSE;

	if( szDrvName == NULL )
	{
	    if ( pdrv == NULL )
	    {
		// This shouldn't happen
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:FetchDirectDrawData: Driver and Driver Name is NULL");
		DDASSERT( 0 );
		return 0;
	    }
	    szDrvName = pdrv->cDriverName;
	}
	if( pdrv != NULL && (pdrv->dwFlags & DDRAWI_NOHARDWARE) )
	{
	    HDC hdc;
	    // ATTENTION: why do this? Can't we just say pdrv->hdc instead of creating a dc??
	    hdc = DD_CreateDC( pdrv->cDriverName );
	    newpdrv = FakeDDCreateDriverObject( hdc, pdrv->cDriverName, pdrv, TRUE, hDDVxd );
	    if (newpdrv)
	    {
	       newpdrv->ddCaps.dwCaps2 |= DDCAPS2_CERTIFIED;
	       UpdateRectFromDevice( newpdrv );
	    }
	    DD_DoneDC( hdc );
	    return newpdrv;
	}
	else
	{
	    ZeroMemory(&ddhi, sizeof(ddhi));

	    if( pdrv != NULL )
	    {
		ddhi.hInstance = pdrv->hInstance;
	    }
	    else
	    {
		ddhi.hInstance = hInstance;
	    }

#if defined(WIN95)

	    ENTER_WIN16LOCK();
	    DD16_GetHALInfo( &ddhi );

	    if( ddhi.lpDDCallbacks != NULL )
	    {
		ddhi.lpDDCallbacks = MapSLFix( (DWORD) ddhi.lpDDCallbacks );
	    }
	    if( ddhi.lpDDSurfaceCallbacks != NULL )
	    {
		ddhi.lpDDSurfaceCallbacks = MapSLFix( (DWORD) ddhi.lpDDSurfaceCallbacks );
	    }
	    if( ddhi.lpDDPaletteCallbacks != NULL )
	    {
		ddhi.lpDDPaletteCallbacks = MapSLFix( (DWORD) ddhi.lpDDPaletteCallbacks );
	    }
	    if( ( ddhi.dwSize >= DDHALINFOSIZE_V2 ) && ( ddhi.lpDDExeBufCallbacks != NULL ) )
	    {
		ddhi.lpDDExeBufCallbacks = MapSLFix( (DWORD) ddhi.lpDDExeBufCallbacks );
	    }
	    if( ddhi.lpdwFourCC != NULL )
	    {
		ddhi.lpdwFourCC = MapSLFix( (DWORD) ddhi.lpdwFourCC );
	    }
	    if( ddhi.lpModeInfo != NULL )
	    {
		ddhi.lpModeInfo = MapSLFix( (DWORD) ddhi.lpModeInfo );
	    }
	    if( ddhi.vmiData.pvmList != NULL )
	    {
		dw16BitVidmemInfo = (DWORD) ddhi.vmiData.pvmList;
		ddhi.vmiData.pvmList = MapSLFix( (DWORD)dw16BitVidmemInfo );
		dw32BitVidmemInfo = (DWORD) ddhi.vmiData.pvmList;
	    }

            if ( ddhi.lpD3DGlobalDriverData && 	
                (ddhi.dwFlags & DDHALINFO_GETDRIVERINFOSET) && !reset)
            {
	        // this is a hack to Enforce D3DDEVCAPS_DRAWPRIMITIVES2 only on satackable drivers
	        // but not on Primary drivers as we are reluctant to force DDI revised
	        ddhi.lpD3DGlobalDriverData->hwCaps.dwDevCaps |= D3DDEVCAPS_DRAWPRIMITIVES2;
            }

	    /*
	     * Give a secondary driver (if any) a chance.
	     */
	    if (IsVGADevice(szDrvName))
	    {
		/*
		 * Only allow secondaries to hijack primary device
		 */
		bLoadedSecondary = loadSecondaryDriver( &ddhi );
	    }

#endif
            #ifdef WINNT
                /*
                 * This is necessary to make GetDriverInfo function on NT. The handle in pdrv-hDD is per-process,
                 * so we need to fetch it from the local object. If this is a create call, then pdrv and pdrv_lcl
                 * will be null, and DirectDrawObjectCreate will create the hDD for this driver/process pair.
                 * If this is not a create call then it's a reset call, and we can stuff the already created hDD
                 * into the global so that it can be passed into GetDriverInfo. (Yes, a hack).
                 */
                if (pdrv_lcl && pdrv)
                {
                    DDASSERT(reset == TRUE);
                    pdrv->hDD = pdrv_lcl->hDD;
                }
            #endif

            newpdrv = DirectDrawObjectCreate( &ddhi, reset, pdrv, hDDVxd, szDrvName, dwDriverContext, 
                pdrv_lcl ? pdrv_lcl->dwLocalFlags : 0);

	    if( newpdrv )
	    {
		// Is this a
		// Figure out the RECT for the device
		UpdateRectFromDevice( newpdrv );

                //Record if a secondary (PowerVR) was loaded
                if ( bLoadedSecondary )
                {
                    newpdrv->dwFlags |= DDRAWI_SECONDARYDRIVERLOADED;
                }
	    }
            #ifdef WINNT
                /*
                 * On NT, they can switch to and from 4bpp modes where DDraw
                 * can't be used.  If DirectDrawObjectCreate fails,
                 * set the mode index and clear out the caps and set
                 * dwModeIndex to unsupported so that it can't create or
                 * restore surfaces.
                 */
                if( pdrv != NULL)
                {
                    if( newpdrv )
                    {
                        pdrv->dwModeIndex = 0;
                    }
                    else
                    {
                        pdrv->dwModeIndex = DDUNSUPPORTEDMODE;
                        memset( &( pdrv->ddCaps ), 0, sizeof( DDCORECAPS ) );
                        pdrv->ddCaps.dwSize = sizeof( DDCORECAPS );
                        pdrv->ddCaps.dwCaps = DDCAPS_NOHARDWARE;
                    }
                }
            #endif

	    /*
	     * Tell the HEL a mode has changed (possibly externally)
	     */
	    ResetBITMAPINFO(newpdrv);
	    #ifdef WINNT
		//GetCurrentMode will have allocated mem for this. If it's null, it hasn't.
		MemFree( ddhi.lpModeInfo );
	    #endif

	    #if defined(WIN95)
		LEAVE_WIN16LOCK();
	    #endif
	}
    return newpdrv;

} /* FetchDirectDrawData */

/*
 * DirectDrawSupported
 */
BOOL DirectDrawSupported( BOOL bDisplayMessage )
{
    HDC         hdc;
    unsigned    u;

    hdc = GetDC( NULL );
    u = GetDeviceCaps( hdc, BITSPIXEL ) * GetDeviceCaps( hdc, PLANES );
    ReleaseDC( NULL, hdc );

    if(( u < 8 ) && bDisplayMessage)
    {
	DPF( 0, "DirectDraw does not work in less than 8bpp modes" );
        #ifdef WIN95
	    DirectDrawMsg(MAKEINTRESOURCE(IDS_DONTWORK_BPP));
        #endif
	return FALSE;
    }
    return TRUE;

} /* DirectDrawSupported */

/*
 * DirectDrawCreate
 *
 * One of the two end-user API exported from DDRAW.DLL.
 * Creates the DIRECTDRAW object.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawCreate"

HRESULT WINAPI DirectDrawCreate(
		GUID FAR * lpGUID,
		LPDIRECTDRAW FAR *lplpDD,
		IUnknown FAR *pUnkOuter )
{
    HRESULT hr;
    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF(2,A,"ENTERAPI: DirectDrawCreate");
    DPF(3,A,"   GUID *: 0x%p, LPLPDD: 0x%p, pUnkOuter: 0x%p", lpGUID, lplpDD, pUnkOuter);

    if (pUnkOuter )
    {
	return CLASS_E_NOAGGREGATION;
    }

    bReloadReg = FALSE;
    if( GetProfileInt("DirectDraw","reloadreg",0) )
    {
	bReloadReg = TRUE;
	DPF( 3, "Reload registry each time" );
    }
    hr = InternalDirectDrawCreate( lpGUID, lplpDD, NULL, 0UL, NULL );

#ifdef POSTPONED
    /*
     * Fix up the owning unknown for this object
     */
    if (hr == DD_OK && *lplpDD)
    {
	LPDDRAWI_DIRECTDRAW_INT this_int = (LPDDRAWI_DIRECTDRAW_INT)*lplpDD;
	if (pUnkOuter)
	{
	    this_int->lpLcl->pUnkOuter = pUnkOuter;
	}
	else
	{
	    this_int->lpLcl->pUnkOuter = (IUnknown*) &NonDelegatingIUnknownInterface;
	}
    }
#endif

#ifdef DEBUG
    if (hr == DD_OK)
	/*
	 * DD_OK implies lplpDD must be a valid pointer, so can't AV.
	 */
        // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(3,A,"   DirectDrawCreate succeeds, and returns ddraw pointer 0x%p", *lplpDD);
    else
	DPF_APIRETURNS(hr);
#endif //debug

    return hr;

} /* DirectDrawCreate */

/*
 * DirectDrawCreateEx
 *
 * One of the two end-user API exported from DDRAW.DLL.
 * Creates the DIRECTDRAW object.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawCreateEx"

HRESULT WINAPI DirectDrawCreateEx(
		LPGUID rGuid,
		LPVOID  *lplpDD,
                REFIID  iid,
		IUnknown FAR *pUnkOuter )
{
    HRESULT hr;
    LPDIRECTDRAW    lpDD1;
    DPF(2,A,"ENTERAPI: DirectDrawCreateEx");
    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF(3,A,"rGuid: 0x%p, LPLPDD: 0x%p, pUnkOuter: 0x%p", rGuid, lplpDD, pUnkOuter);

    if (pUnkOuter )
    {
	return CLASS_E_NOAGGREGATION;
    }
    if ( rGuid != NULL )
    {
        if ( !VALID_IID_PTR( rGuid ) )
        {
            DPF_ERR( "GUID reference is invalid" );
            return DDERR_INVALIDPARAMS;
        }
    }
    if (!IsEqualIID(iid, &IID_IDirectDraw7 ) )
    {
	DPF_ERR( "only IID_IDirectDraw7 is supported" );
	return DDERR_INVALIDPARAMS;
    }

    bReloadReg = FALSE;
    if( GetProfileInt("DirectDraw","reloadreg",0) )
    {
	bReloadReg = TRUE;
	DPF( 3, "Reload registry each time" );
    }
    hr = InternalDirectDrawCreate((GUID FAR *)rGuid,&lpDD1, NULL, DDRAWILCL_DIRECTDRAW7, NULL );

#ifdef POSTPONED
    /*
     * Fix up the owning unknown for this object
     */
    if (hr == DD_OK && lpDD1)
    {
	LPDDRAWI_DIRECTDRAW_INT this_int = (LPDDRAWI_DIRECTDRAW_INT)lpDD1;
	if (pUnkOuter)
	{
	    this_int->lpLcl->pUnkOuter = pUnkOuter;
	}
	else
	{
	    this_int->lpLcl->pUnkOuter = (IUnknown*) &NonDelegatingIUnknownInterface;
	}
    }
#endif
    if (DD_OK != hr)
    {
        *lplpDD=NULL;
    }
    if (hr == DD_OK)
    {
	/*
	 * DD_OK implies lpDD1 must be a valid pointer, so can't AV.
	 */
        // Now QI for the IDirectDraw7 interface
        hr=lpDD1->lpVtbl->QueryInterface(lpDD1,&IID_IDirectDraw7,lplpDD);
        lpDD1->lpVtbl->Release(lpDD1);
#ifdef DEBUG
        if (lpDD1)
        {
            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF(3,A,"   DirectDrawCreateEx succeeds, and returns ddraw pointer 0x%p", *lplpDD);
        }
#endif //debug
    }
    else
    {
	DPF_APIRETURNS(hr);
    }

    return hr;

} /* DirectDrawCreateEx */

/*
 * getDriverInterface
 */
static LPDDRAWI_DIRECTDRAW_INT getDriverInterface(
		LPDDRAWI_DIRECTDRAW_INT pnew_int,
		LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;

    if( pnew_int != NULL )
    {
	/*
	 * an interface was already created, so just assign the
	 * global data pointer and initialize a few things
	 */
	DPF( 4, "Interface pointer already exists!" );
	pdrv_lcl = pnew_int->lpLcl;
	pdrv_lcl->lpGbl = pdrv;
	pdrv_lcl->lpDDCB = pdrv->lpDDCBtmp;
#ifdef WIN95
        pdrv_lcl->dwPreferredMode = pdrv->dwModeIndex;
#else
        pdrv_lcl->dmiPreferred = pdrv->dmiCurrent;
#endif
	pdrv->dwRefCnt += pdrv_lcl->dwLocalRefCnt;
    }
    else
    {
	pnew_int = NewDriverInterface( pdrv, &ddCallbacks );
    }
    return pnew_int;

} /* getDriverInterface */


// Utility function that tells us if there is more than
// one display device in the system.  (We count all devices,
// regardless of whether they are attached to the desktop.)
BOOL IsMultiMonitor(void)
{
    int i, n;

    // Each loop below enumerates one display device.
    for (i = 0, n = 0; ; i++)
    {
	DISPLAY_DEVICEA dd;

	// Zero the memory of the DISPLAY_DEVICE struct between calls to
	// EnumDisplayDevices
	ZeroMemory(&dd, sizeof(dd));
	dd.cb = sizeof(dd);
	if (!xxxEnumDisplayDevicesA(NULL, i, &dd, 0))
	{
    	    break;   // no more devices to enumerate
	}
	if (dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
	{
    	    continue;	// not a real hardware display driver
	}
	// We're just trying to count the number of display devices in the
	// system and see if there is more than one.
	if (++n > 1)
	{
	    return TRUE;   // multiple display devices
	}
    }

    return FALSE;  // single display device
}


extern DWORD HackMeBaby( void );

BOOL fDoesGDI(HDC hdc)
{
    //
    // the 3Dfx driver always return 1 to every thing
    // verify GetNearest()  color works.
    //
    BOOL b = GetNearestColor(hdc, 0x000000) == 0x000000 &&
	     GetNearestColor(hdc, 0xFFFFFF) == 0xFFFFFF;
    if(b)
    {
	DPF(3,"Driver is a GDI driver");
    }

    return b;
}

/*
 * IsAttachedToDesktop
 *
 * DCI is hardwired to the primary display which means it can't
 * be used on a multi-mon system.  Usually GDI disables it for
 * us, but it does not when there are two monitors and only one
 * of them uses the desktop.  We'd still like to use DCI for
 * the desktop in this case, but we can't use it if the monitor
 * is not attached to the desktop.  That is why this function exists.
 */
BOOL IsAttachedToDesktop( LPGUID lpGuid )
{
    DWORD       n;
    GUID        guid;
    DISPLAY_DEVICEA dd;

    if( !IsMultiMonitor() )
    {
	return TRUE;
    }

    /*
     * Assume that the primary is always attached
     */
    if( (lpGuid == (GUID *) DDCREATE_EMULATIONONLY) ||
	(lpGuid == (GUID *) DDCREATE_HARDWAREONLY) ||
	(lpGuid == NULL) ||
	(IsEqualGUID( lpGuid, &GUID_NULL) ) )
    {
	return TRUE;
    }

    ZeroMemory(&dd, sizeof(dd));
    dd.cb = sizeof(dd);
    for( n=0; xxxEnumDisplayDevicesA( NULL, n, &dd, 0 ); n++ )
    {
	guid = DisplayGUID;
	guid.Data1 += n;

	if( IsEqualIID( lpGuid, &guid) )
	{
	    if( dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP )
	    {
		return TRUE;
	    }
	    else
	    {
		return FALSE;
	    }
	}
	ZeroMemory( &dd, sizeof(dd) );
	dd.cb = sizeof(dd);
    }

    return TRUE;

} /* IsAttachedToDesktop */

/*
 * Functions to dynamically link against exports we need in user32 on
 * older OSes
 */
//These statics will be per-process, cuz it's outside the shared section
typedef BOOL (WINAPI * LPENUMMONITORS) (HDC, LPRECT, MONITORENUMPROC, LPARAM);
typedef BOOL (WINAPI * LPGETMONINFO) (HMONITOR, MONITORINFO *);
typedef BOOL (WINAPI * LPISDEBUG) (void);
static LPISDEBUG pIsDebuggerPresent = 0;
static LPENUMMONITORS pEnumMonitors = 0;
static LPGETMONINFO pGetMonitorInfo = 0;
static BOOL bTriedToGetProcAlready = FALSE;

BOOL DynamicLinkToOS(void)
{
    if (1) //!pEnumMonitors)
    {
	HMODULE hUser32;
	HMODULE hKernel32;

	if (0) //bTriedToGetProcAlready)
	    return FALSE;

	bTriedToGetProcAlready = TRUE;

	hUser32 = GetModuleHandle(TEXT("USER32"));
	pEnumMonitors = (LPENUMMONITORS) GetProcAddress(hUser32,"EnumDisplayMonitors");
	pGetMonitorInfo = (LPGETMONINFO) GetProcAddress(hUser32,"GetMonitorInfoA");

	hKernel32 = GetModuleHandle(TEXT("KERNEL32"));
	pIsDebuggerPresent = (LPISDEBUG) GetProcAddress(hKernel32,"IsDebuggerPresent");

	if (!pEnumMonitors || !pGetMonitorInfo || !pIsDebuggerPresent)
	{
	    DPF(3,"Failed to get proc addresses");
	    return FALSE;
	}
    }

    DDASSERT(pEnumMonitors);
    DDASSERT(pGetMonitorInfo);
    DDASSERT(pEnumMonitors);

    return TRUE;
}

BOOL InternalGetMonitorInfo(HMONITOR hMon, MONITORINFO *lpInfo)
{
    DynamicLinkToOS();

    if (!pGetMonitorInfo)
	return FALSE;

    return pGetMonitorInfo(hMon, lpInfo);
}

typedef struct
{
    LPSTR       pName;
    HMONITOR    hMon;
} CALLBACKSTRUCT, * LPCALLBACKSTRUCT;


BOOL InternalEnumMonitors(MONITORENUMPROC proc, LPCALLBACKSTRUCT lp)
{
    DynamicLinkToOS();

    if (!pEnumMonitors)
	return FALSE;

    pEnumMonitors(NULL,NULL,proc,(LPARAM)lp);

    return TRUE;
}
/*
 * InternalIsDebuggerPresent
 * A little helper so that this runtime runs against older OSes
 */
BOOL InternalIsDebuggerPresent(void)
{
    DynamicLinkToOS();

    if (!pIsDebuggerPresent)
	return FALSE;

    return pIsDebuggerPresent();
}

//
// getPrimaryDisplayName
//

void getPrimaryDisplayName(void)
{
	DISPLAY_DEVICE dd;
	int i;

	ZeroMemory(&dd, sizeof dd);
	dd.cb = sizeof dd;

	for (i = 0; xxxEnumDisplayDevicesA(NULL, i, &dd, 0); ++i)
	{
		if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
		{
			lstrcpyn(g_szPrimaryDisplay, dd.DeviceName, sizeof g_szPrimaryDisplay);
			return;
		}
	}

	lstrcpy(g_szPrimaryDisplay, DISPLAY_STR);
}

/*
 * InternalDirectDrawCreate
 */
HRESULT InternalDirectDrawCreate(
		GUID * lpGUID,
		LPDIRECTDRAW *lplpDD,
		LPDDRAWI_DIRECTDRAW_INT pnew_int,
		DWORD dwCallFlags,
                char * pDeviceName)
{
    DCICMD                      cmd;
    UINT                        u;
    int                         rc;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int;
    LPSTR                       pdrvname;
    HDC                         hdc_dd;
    BOOL                        isdispdrv;
    BOOL                        hel_only;
    DWORD                       dwFlags;
    char                        drvname[MAX_PATH];
    DWORD                       pid;
    HKEY                        hkey;
    DWORD                       hackflags;
#ifdef WIN95
    int                         halver;
#endif
    HANDLE                      hDDVxd;
    BOOL                        bIsPrimary;
    BOOL                        bExplicitMonitor = FALSE;
    ULONG_PTR                	hDD;

    #ifndef DX_FINAL_RELEASE
	#pragma message( REMIND( "Remove time bomb for final!" ))
	{
	    SYSTEMTIME  st;
		TCHAR	tstrText[MAX_PATH];
		TCHAR	tstrTitle[MAX_PATH];

	    GetSystemTime( &st );

	    if( ( st.wYear > DX_EXPIRE_YEAR ) ||
		( ( st.wYear == DX_EXPIRE_YEAR ) &&
		  ( ( st.wMonth > DX_EXPIRE_MONTH ) || ( ( st.wMonth == DX_EXPIRE_MONTH ) && ( st.wDay >= DX_EXPIRE_DAY ) ) ) ) )
	    {
		
		LoadString( hModule, IDS_TIME_BOMB, tstrText, MAX_PATH);
		LoadString( hModule, IDS_TIME_BOMB_TITLE, tstrTitle, MAX_PATH);

		if( 0 == MessageBox( NULL, tstrText, tstrTitle, MB_OK) )
		{
		    DPF( 0, "DirectDraw Beta Expired. Please Update" );
		    *lplpDD = (LPDIRECTDRAW) NULL;
		    return DDERR_GENERIC;
		}
	    }
	}
    #endif //DX_FINAL_RELEASE

    /*
     * validate parameters
     */
    if( !VALIDEX_PTR_PTR( lplpDD ) )
    {
	DPF_ERR( "Invalid lplpDD" );
	return DDERR_INVALIDPARAMS;
    }
    *lplpDD = (LPDIRECTDRAW) NULL;

    /*
     * check for < 8 bpp and disallow.
     */
    if( !DirectDrawSupported(!(dwCallFlags & DDRAWILCL_DIRECTDRAW8)) )
    {
	return DDERR_NODIRECTDRAWSUPPORT;
    }



    ENTER_CSDDC();
    ENTER_DDRAW();

    hackflags = HackMeBaby();

    DPF( 5, "DirectDrawCreate: pid = %08lx", GETCURRPID() );

    /*
     * pull in registry values
     */
    DPF( 4, "Reading Registry" );
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDRAW, &hkey ) )
    {
	DWORD   type;
	DWORD   value;
	DWORD   cb;
	cb = sizeof( value );
	dwRegFlags &= ~(DDRAW_REGFLAGS_MODEXONLY       |
			DDRAW_REGFLAGS_EMULATIONONLY   |
			DDRAW_REGFLAGS_SHOWFRAMERATE   |
			DDRAW_REGFLAGS_ENABLEPRINTSCRN |
			DDRAW_REGFLAGS_DISABLEWIDESURF |
			DDRAW_REGFLAGS_NODDSCAPSINDDSD |
			DDRAW_REGFLAGS_DISABLEMMX      |
                        DDRAW_REGFLAGS_FORCEREFRESHRATE |
			DDRAW_REGFLAGS_DISABLEAGPSUPPORT);
	dwRegFlags &= ~DDRAW_REGFLAGS_AGPPOLICYMAXBYTES;
#ifndef WINNT
	#ifdef DEBUG
	    dwAGPPolicyCommitDelta = DEFAULT_AGP_COMMIT_DELTA;
	#endif /* DEBUG */
#endif
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_MODEXONLY, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    ModeXOnly: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_MODEXONLY;
	    }
	}
	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_EMULATIONONLY, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    EmulationOnly: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_EMULATIONONLY;
	    }
	}
	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_SHOWFRAMERATE, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    ShowFrameRate: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_SHOWFRAMERATE;
	    }
	}
	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_ENABLEPRINTSCRN, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    EnablePrintScreen: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_ENABLEPRINTSCRN;
	    }
	}
	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_FORCEAGPSUPPORT, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    ForceAGPSupport: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_FORCEAGPSUPPORT;
	    }
	}
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLEAGPSUPPORT, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    DisableAGPSupport: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_DISABLEAGPSUPPORT;
	    }
	}
	cb = sizeof( value );
#ifdef WIN95
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_AGPPOLICYMAXPAGES, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    AGPPolicyMaxPages: %d", value );
	    dwRegFlags |= DDRAW_REGFLAGS_AGPPOLICYMAXBYTES;
	    dwAGPPolicyMaxBytes = value * 4096;
	}
	#ifdef DEBUG
	    cb = sizeof( value );
	    if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_AGPPOLICYCOMMITDELTA, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	    {
		DPF( 2, "    AGPPolicyCommitDelta: %d", value );
		dwAGPPolicyCommitDelta = value;
	    }
	#endif /* DEBUG */
#endif

	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLEMMX, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    DisableMMX: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_DISABLEMMX;
	    }
	}

	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_NODDSCAPSINDDSD, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    Disable ddscaps in DDSURFACEDESC: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_NODDSCAPSINDDSD;
	    }
	}

	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLEWIDERSURFACES, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    DisableWiderSurfaces:%d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_DISABLEWIDESURF;
	    }
	}

        cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_D3D_USENONLOCALVIDMEM, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    UseNonLocalVidmem:%d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_USENONLOCALVIDMEM;
	    }
	}

	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_FORCEREFRESHRATE, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    ForceRefreshRate:%d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_FORCEREFRESHRATE;
                dwForceRefreshRate = value;
	    }
	}

	#ifdef DEBUG
	    /*
	     * NOSYSLOCK (No Win16 locking) control flags. DEBUG only.
	     */
	    dwRegFlags &= ~(DDRAW_REGFLAGS_DISABLENOSYSLOCK | DDRAW_REGFLAGS_FORCENOSYSLOCK | DDRAW_REGFLAGS_DISABLEINACTIVATE);

	    cb = sizeof( value );
	    if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLENOSYSLOCK, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	    {
		DPF( 2, "    DisableNoSysLock:%d", value );
		if( value )
		{
		    dwRegFlags |= DDRAW_REGFLAGS_DISABLENOSYSLOCK;
		}
	    }

	    cb = sizeof( value );
	    if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_FORCENOSYSLOCK, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	    {
		DPF( 2, "    ForceNoSysLock:%d", value );
		if( value )
		{
		    dwRegFlags |= DDRAW_REGFLAGS_FORCENOSYSLOCK;
		}
	    }
	    if( ( dwRegFlags & DDRAW_REGFLAGS_DISABLENOSYSLOCK ) &&
		( dwRegFlags & DDRAW_REGFLAGS_FORCENOSYSLOCK ) )
	    {
		DPF( 0, "Attempt to both disable and force NOSYSLOCK on locks. Ignoring both" );
		dwRegFlags &= ~(DDRAW_REGFLAGS_DISABLENOSYSLOCK | DDRAW_REGFLAGS_FORCENOSYSLOCK);
	    }

	    /*
	     * Hack to allow multi-mon debugging w/o minimizing the exclusive
	     * mode app when it gets a WM_ACTIVATEAPP msg.  We only do this
	     * in the debug version.
	     */
	    cb = sizeof( value );
	    if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLEINACTIVATE, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	    {
		DPF( 2, "    DisableInactivate:%d", value );
		if( value && InternalIsDebuggerPresent() )
		{
		    dwRegFlags |= DDRAW_REGFLAGS_DISABLEINACTIVATE;
		}
	    }

	#endif /* DEBUG */
	RegCloseKey(hkey);
    }
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, RESPATH_D3D, &hkey ) )
    {
	DWORD   type;
	DWORD   value;
	DWORD   cb;
	cb = sizeof( value );
	dwRegFlags &= ~DDRAW_REGFLAGS_FLIPNONVSYNC;
	if( !RegQueryValueEx( hkey, REGSTR_VAL_D3D_FLIPNOVSYNC, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, REGSTR_VAL_D3D_FLIPNOVSYNC" :%d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_FLIPNONVSYNC;
	    }
	}
	RegCloseKey(hkey);
    }
    hdc_dd = NULL;
    hDD = 0;
    dwFlags = 0;

    //
    // Get the primary display name, which will usually be something like
    // \\.\Display1 and in some cases may be \\.\Display1\Unit0. We only
    // do this one time, and store it globally. On Win98, the global name
    // will be shared between all processes, and on NT5, each process will
    // have its own copy. Also, note that the primary device name may change
    // on NT5; we need to look into this.
    //

    if (g_szPrimaryDisplay[0] == '\0')
    {
	    getPrimaryDisplayName();
    }

    /*
     * any special cases?
     */
    bIsPrimary = FALSE;
    isdispdrv = FALSE;
    if( dwRegFlags & DDRAW_REGFLAGS_EMULATIONONLY )
    {
        DWORD cMonitors = GetSystemMetrics( SM_CMONITORS );

	dwFlags |= DDCREATE_EMULATIONONLY;
	if( cMonitors <= 1 )
	{
	    // For compatibility with pre-multimon versions of DDraw
	    bIsPrimary = TRUE;
	}
    }
    if( pDeviceName == NULL)
    {
        if( lpGUID == (GUID *) DDCREATE_EMULATIONONLY )
        {
	    dwFlags |= DDCREATE_EMULATIONONLY;
	    bIsPrimary = TRUE;
        }
        else if( lpGUID == NULL )
        {
	    bIsPrimary = TRUE;
        }
        else if( lpGUID == (GUID *) DDCREATE_HARDWAREONLY )
        {
	    dwFlags |= DDCREATE_HARDWAREONLY;
	    bIsPrimary = TRUE;
        }
        if (bIsPrimary)
        {
	    lpGUID = (GUID *) &GUID_NULL;   // primary monitor
        }
        else if( !VALIDEX_GUID_PTR( lpGUID ) )
        {
	    DPF_ERR( "Invalid GUID passed in" );
	    LEAVE_DDRAW();
	    LEAVE_CSDDC();
	    return DDERR_INVALIDPARAMS;
        }
        if( IsEqualGUID( lpGUID, &GUID_NULL ) )
        {
	    pdrvname = DISPLAY_STR;	    // "display"
	    isdispdrv = TRUE;
	    bIsPrimary = TRUE;
        }
        else
        {
	    if( !getDriverNameFromGUID( lpGUID, drvname, &isdispdrv, &bIsPrimary ) )
	    {
	        DPF_ERR( "Invalid GUID for driver" );
	        LEAVE_DDRAW();
	        LEAVE_CSDDC();
	        return DDERR_INVALIDDIRECTDRAWGUID;
	    }
	    pdrvname = drvname;
        }
    }
    else
    {
        pdrvname = pDeviceName;
    }

    if ((ULONG_PTR)pdrvname != (ULONG_PTR)DISPLAY_STR)
    {
	bExplicitMonitor = TRUE;

	if (_stricmp(pdrvname, g_szPrimaryDisplay) == 0)
	{
	    pdrvname = DISPLAY_STR;
	}
    }

    pid = GETCURRPID();

    #ifdef WIN95
	/*
	 * We need to ensure that DDHELP has a handle to the DirectX VXD
	 * that it can use when creating, freeing or mapping virtual memory
	 * aliases or AGP heaps on mode switches or cleanups.
	 */
	if( INVALID_HANDLE_VALUE == hHelperDDVxd )
	{
	    hHelperDDVxd = HelperGetDDVxd();
	    if( INVALID_HANDLE_VALUE == hHelperDDVxd )
	    {
		DPF_ERR( "DDHELP could not load the DirectX VXD" );
		LEAVE_DDRAW();
		LEAVE_CSDDC();
		return DDERR_GENERIC;
	    }
	}

	/*
	 * Create a handle for VXD communication. We will use this for
	 * alias construction in this function and we will later store
	 * this in the local object for later alias manipulation and
	 * page locking purposes.
	 */
	hDDVxd = GetDXVxdHandle();
	if( INVALID_HANDLE_VALUE == hDDVxd )
	{
	    DPF_ERR( "Unable to open the DirectX VXD" );
	    LEAVE_DDRAW();
	    LEAVE_CSDDC();
	    return DDERR_GENERIC;
	}
    #else /* WIN95 */
	hDDVxd = INVALID_HANDLE_VALUE;
    #endif /* WIN95 */

    /*
     * run the driver list, looking for one that already exists.  We used to run
     * the interface list, but thanks to D3D it is possible for all locals to exist
     * w/o anything in the interface list.
     */
    pdrv_lcl = lpDriverLocalList;
    while( pdrv_lcl != NULL )
    {
	pdrv = pdrv_lcl->lpGbl;
	if( pdrv != NULL )
	{
	    if( !_stricmp( pdrv->cDriverName, pdrvname ) )
	    {
		// If they asked for hardware; then don't accept the
		// emulated driver
		if( !(dwFlags & DDCREATE_EMULATIONONLY) &&
		    !(pdrv->dwFlags & DDRAWI_NOHARDWARE) )
		{
		    DPF( 2, "Driver \"%s\" found for hardware", pdrvname );
		    break;
		}
		// If they asked for emulation; then don't accept the
		// hardware driver
		if( (dwFlags & DDCREATE_EMULATIONONLY) &&
		    (pdrv->dwFlags & DDRAWI_NOHARDWARE) )
		{
		    DPF( 2, "Driver \"%s\" found for emulation", pdrvname );
		    break;
		}
		// Compatibility: on single monitor systems take whatever
		// we got. (This is what we did in DX3)
		if( pdrv->cMonitors <= 1 )
		{
		    DPF( 2, "Driver \"%s\" found", pdrvname );
		    break;
		}
	    }
	}
	pdrv_lcl = pdrv_lcl->lpLink;
    }

    /*
     * if driver object already exists, get emulation layer if needed,
     * create a new interface to it and return
     */
    if( pdrv_lcl != NULL )
    {
	LPDDRAWI_DIRECTDRAW_LCL tmp_lcl;

	// This is the hdc we need to release if something
	// goes wrong; since we are sometimes
	// sharing an HDC with an existing LCL, we must
	// be careful not to release it while it is still
	// in use.
	HDC hdcCleanup = NULL;
	/*
	 * see if the current process has attached to this driver before...
	 */
	tmp_lcl = lpDriverLocalList;
	while( tmp_lcl != NULL )
	{
	    if( tmp_lcl->dwProcessId == pid &&
		    tmp_lcl->lpGbl == pdrv)
	    {
		break;
	    }
	    tmp_lcl = tmp_lcl->lpLink;
	}
	if( tmp_lcl == NULL )
	{
	    hdc_dd = NULL;
	}
	else
	{
	    // We found the process/driver pair we were looking for.
	    hdc_dd = (HDC) tmp_lcl->hDC;
	    DDASSERT(hdc_dd != 0);
	    hDD = tmp_lcl->hDD;
	}

	/*
	 * we need a new DC if this is a new process/driver pair...
	 */
	if( hdc_dd == NULL )
	{
	    DWORD       flags;
	    flags = pdrv->dwFlags;
	    hdc_dd = DD_CreateFirstDC( pdrvname );
	    if( hdc_dd == NULL )
	    {
		DPF_ERR( "Could not get a DC for the driver" );
		CLOSEVXD( hDDVxd );
		LEAVE_DDRAW();
		LEAVE_CSDDC();
		/* GEE: decided this error was rare enough to be left generic */
		return DDERR_GENERIC;
	    }

	    if (!(pdrv->dwFlags & DDRAWI_DISPLAYDRV))
	    {
		if (fDoesGDI(hdc_dd))
		{
		    pdrv->dwFlags |= DDRAWI_GDIDRV;
		}
		else
		{
		    pdrv->dwFlags &= ~DDRAWI_GDIDRV;
		}
	    }

	    // We need to free it if something goes wrong
	    hdcCleanup = hdc_dd;
	}

	/*
	 * Set up emulation for display and non-display drivers
	 */
	if( dwFlags & DDCREATE_EMULATIONONLY )
	{
	    if( !(pdrv->dwFlags & DDRAWI_NOHARDWARE) )
	    {
		DD_DoneDC(hdcCleanup);
		DPF_ERR( "EMULATIONONLY requested, but driver exists and has hardware" );
		CLOSEVXD( hDDVxd );
		LEAVE_DDRAW();
		LEAVE_CSDDC();
		/* GEE: Why do we fail emulation only calls just because we have a driver? */
		return DDERR_GENERIC;
	    }
	}

	/*
	 * we will need to load the emulation layer...
	 */
	if( !(pdrv->dwFlags & DDRAWI_NOEMULATION) &&
	    !(pdrv->dwFlags & DDRAWI_EMULATIONINITIALIZED ) )
	{
	    capsInit( pdrv );
	    hel_only = ((dwFlags & DDCREATE_EMULATIONONLY) != 0);
	    if( !helInit( pdrv, dwFlags, hel_only ) )
	    {
		DD_DoneDC(hdcCleanup);
		DPF_ERR( "HEL initialization failed" );
		CLOSEVXD( hDDVxd );
		LEAVE_DDRAW();
		LEAVE_CSDDC();
		/* GEE: HEL can only fail in v1 for lack of memory */
		return DDERR_GENERIC;
	    }
	}

	pdrv_int = getDriverInterface( pnew_int, pdrv );
	if( pdrv_int == NULL )
	{
	    DD_DoneDC(hdcCleanup);
	    DPF_ERR( "No memory for driver callbacks." );
	    CLOSEVXD( hDDVxd );
	    LEAVE_DDRAW();
	    LEAVE_CSDDC();
	    return DDERR_OUTOFMEMORY;
	}
	pdrv_lcl = pdrv_int->lpLcl;

	pdrv_lcl->dwAppHackFlags = hackflags;
	#ifdef DEBUG
	    if( dwRegFlags & DDRAW_REGFLAGS_DISABLEINACTIVATE )
	    {
		pdrv_lcl->dwLocalFlags |= DDRAWILCL_DISABLEINACTIVATE;
	    }
	#endif
	if( IsAttachedToDesktop( lpGUID ) )
	{
	    pdrv->dwFlags |= DDRAWI_ATTACHEDTODESKTOP;
	}
	if (bExplicitMonitor)
	{
		pdrv_lcl->dwLocalFlags |= DDRAWILCL_EXPLICITMONITOR;
	}

        pdrv_lcl->dwLocalFlags |= dwCallFlags;

	pdrv_lcl->hDDVxd = (ULONG_PTR) hDDVxd;

	#ifdef WIN95
	    if( hdcCleanup )
	    {
		// If we had to create a DC from
		// scratch then we need to mark it
		// private so that it will be never
		// be deleted out from under us
		DDASSERT( hdcCleanup == hdc_dd );
		DD16_MakeObjectPrivate( hdc_dd, TRUE );
	    }
	#endif
	#ifdef WINNT
	    if( hdcCleanup )
	    {
    		BOOL bRetVal;

		// We had to create a DC from scratch for this process/driver pair.
		DDASSERT(hdcCleanup == hdc_dd);
		// GDI creates a DirectDraw handle for each unique process/driver pair.
                if( pdrv->dwFlags & DDRAWI_NOHARDWARE )
		{
		    // A fake DDraw driver that lets the HEL do everything.
		    bRetVal = DdCreateDirectDrawObject(pdrv, (HDC)0);
		}
		else
		{
		    // A real DDraw driver with hardware acceleration.
		    bRetVal = DdCreateDirectDrawObject(pdrv, hdc_dd);
		}
		if (!bRetVal)
		{
		    DPF_ERR( "Call to DdCreateDirectDrawObject failed!");
		    DD_DoneDC(hdc_dd);
		    LEAVE_DDRAW();
		    LEAVE_CSDDC();
		    return DDERR_NODIRECTDRAWHW;
		}
		// The DdCreateDirectDrawObject() call above loaded a DD handle into a
		// into a temp location in the driver GBL object, but we must now save
		// the handle in the driver LCL object so it won't be overwritten if
		// another process calls DdCreateDirectDrawObject() on the same driver.
		hDD = pdrv->hDD;
	    }
	    pdrv_lcl->hDD = hDD;
	#endif //WINNT

	(HDC) pdrv_lcl->hDC = hdc_dd;

	*lplpDD = (LPDIRECTDRAW) pdrv_int;

	LEAVE_DDRAW();
	LEAVE_CSDDC();
	return DD_OK;
    }

    /*
     * if no match among the existing drivers, then we have to go off
     * and create one
     */
    hdc_dd = DD_CreateFirstDC( pdrvname );
    if( hdc_dd == NULL )
    {
	DPF_ERR( "Could not create driver, CreateDC failed!" );
	CLOSEVXD( hDDVxd );
	LEAVE_DDRAW();
	LEAVE_CSDDC();
	return DDERR_CANTCREATEDC;
    }

    #ifdef WIN95
        /*
         * HACK-O-RAMA TIME!  We need to do something smart if the VGA is
         * powered down or if we're in a DOS box.  We don't have the pDevice
         * yet, so we'll hack around w/ the DC we just created.
         */
        if( DD16_IsDeviceBusy( hdc_dd ) )
        {
            /*
             * Something is happenning, but we don't know what.  If it's
             * a DOS box, creating a simple POPUP should make it go away.
             */
            WNDCLASS cls;
            HWND     hWnd;
            cls.lpszClassName  = "DDrawHackWindow";
            cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
            cls.hInstance      = hModule;
            cls.hIcon          = NULL;
            cls.hCursor        = NULL;
            cls.lpszMenuName   = NULL;
            cls.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
            cls.lpfnWndProc    = (WNDPROC)DefWindowProc;
            cls.cbWndExtra     = 0;
            cls.cbClsExtra     = 0;
            RegisterClass(&cls);
            hWnd = CreateWindowEx(WS_EX_TOPMOST|WS_EX_TOOLWINDOW,
                "DDrawHackWindow", "DDrawHackWindow",
                WS_OVERLAPPED|WS_POPUP|WS_VISIBLE, 0, 0, 2, 2,
                NULL, NULL, hModule, NULL);
            if( hWnd != NULL )
            {
                DestroyWindow( hWnd );
                UnregisterClass( "DDrawHackWindow", hModule );
            }

            /*
             * Check again, and if we're still busy, that probably means
             * that the device is powered down.  In that case, forcing
             * emulaiton is probably the right thing to do.
             */
            if( DD16_IsDeviceBusy( hdc_dd ) )
            {
                dwFlags |= DDCREATE_EMULATIONONLY;
            }
        }
    #endif

    if( dwFlags & DDCREATE_EMULATIONONLY )
    {
	hel_only = TRUE;
    }
    else
    {
	hel_only = FALSE;
	/*
	 * "That's the chicago way..."
	 * Win95 drivers are talked to through the ExtEscape DCI extensions.
	 * Under NT we get at our drivers through the gdi32p dll.
	 * Consequently all this dci stuff goes away for NT. You'll find the
	 * equivalent stuff done at the top of DirectDrawObjectCreate
	 */
	#ifdef WIN95

		/*
		 * see if the DCICOMMAND escape is supported
		 */
		u = DCICOMMAND;
		halver = ExtEscape( hdc_dd, QUERYESCSUPPORT, sizeof(u),
			    (LPCSTR)&u, 0, NULL );
		if( (halver != DD_HAL_VERSION) && (halver != DD_HAL_VERSION_EXTERNAL) )
		{
		    if( halver <= 0 )
		    {
                        DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:No DIRECTDRAW escape support" );
		    }
		    else
		    {
                        if (halver == 0x5250)
                        {
                            DPF(0,"****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Acceleration slider is set to NONE");
                        }
                        else
                        {
			    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:DIRECTDRAW driver is wrong version, got 0x%04lx, expected 0x%04lx",
				halver, DD_HAL_VERSION_EXTERNAL );
                        }
		    }

		    // We don't release the DC anymore becuase it always becomes part
		    // of the DDRAW_GBL object in all DisplayDrv cases.
		    hel_only = TRUE;
		}

	#endif //win95
    }

    if( hel_only && (dwFlags & DDCREATE_HARDWAREONLY))
    {
	DPF_ERR( "Only emulation available, but HARDWAREONLY requested" );
	CLOSEVXD( hDDVxd );
	LEAVE_DDRAW();
	LEAVE_CSDDC();
	DD_DoneDC(hdc_dd);
	return DDERR_NODIRECTDRAWHW;
    }

#ifdef WIN95
    // On non-multi-mon systems, we do this because
    // we did it in DX3. We set TRUE for multi-mon systems
    // because that will prevent us from using Death/Resurrection
    // which is Dangerous if some future DDraw object ever is
    // created for the secondary device. We can't wait until
    // the second device is created; because it's possible that
    // primary device is already in the middle of a death/resurrection
    // sequence and it is bad bad karma to change the flag between
    // the beginning of modex and the end of modex. (Specifically,
    // we'll see either a resurrection not being called when it should
    // have been or a resurrection called when it shouldn't have been.)
    if( IsMultiMonitor() )
	DD16_SetCertified( TRUE );
    else
	DD16_SetCertified( FALSE );
#endif

    /*
     * go try to create the driver object
     */

    if( !hel_only )
    {
	DWORD           hInstance = 0;
	DWORD           dwDriverData32 = 0;
	DWORD           p16;
	DDHALDDRAWFNS   ddhddfns;
	BOOL            bFailedWhackoVersion = FALSE;
	BOOL            bPassDriverInit = TRUE;

	/*
	 * "That's the chicago way..."
	 * Win95 drivers are talked to through the ExtEscape DCI extensions.
	 * Under NT we get at our drivers through the gdi32p dll.
	 * Consequently all this dci stuff goes away for NT. You'll find the
	 * equivalent stuff done at the top of DirectDrawObjectCreate
	 */
	#ifdef WIN95
	    DD32BITDRIVERDATA   data;
	    DDVERSIONDATA       verdata;

	    /*
	     * Notify the driver of the DirectDraw version.
	     *
	     * Why this is neccesary:  After DX3 it became a requirement for
	     * newer DDraws to work w/ older HALs and visa versa.  DD_VERSION
	     * was set at 0x200 in DX3 and all of the drivers hardcoded it.
	     * Therefore, setting dwVersion to anything other than 0x200 would
	     * cause DX3 HALs to fail. The other option was to put the real
	     * version in dwParam1 of the DDGET32BITDRIVERNAME call, but this
	     * option seems a little cleaner.  Since the information could be
	     * useful in the future, we also ask the HAL to tell us what
	     * version of DirectDraw they were designed for.
	     */
	    DPF( 4, "DDVERSIONINFO" );

	    /*
	     * On debug builds, probe the driver with a totally whacko ddraw version
	     * This ensures we can increment this version in the future i.e. that
	     * any existing drivers which catch this escape don't hard code for
	     * whatever version of the DDK they use
	     * We fail the driver if they give out on some large random ddraw version but
	     * pass on 0x500
	     */

	    cmd.dwCommand = (DWORD) DDVERSIONINFO;
	    cmd.dwParam1 = (GetCurrentProcessId() & 0xfff) + 0x501; //always > 0x500
	    cmd.dwParam2 = 0;
	    cmd.dwReserved = 0;
	    cmd.dwVersion = DD_VERSION;         // So older HALs won't fail

	    verdata.dwHALVersion = 0;
	    verdata.dwReserved1 = 0;
	    verdata.dwReserved2 = 0;
	    rc = ExtEscape( hdc_dd, DCICOMMAND, sizeof( cmd ),
			(LPCSTR)&cmd, sizeof( verdata ), (LPSTR) &verdata );
	    if (rc <= 0)
	    {
		//Removed this DPF: It's misleading
		//DPF(1,"Driver failed random future DDraw version");
		bFailedWhackoVersion = TRUE;
	    }

	    cmd.dwCommand = (DWORD) DDVERSIONINFO;
	    cmd.dwParam1 = DD_RUNTIME_VERSION;
	    cmd.dwParam2 = 0;
	    cmd.dwReserved = 0;
	    cmd.dwVersion = DD_VERSION;         // So older HALs won't fail

	    verdata.dwHALVersion = 0;
	    verdata.dwReserved1 = 0;
	    verdata.dwReserved2 = 0;
	    rc = ExtEscape( hdc_dd, DCICOMMAND, sizeof( cmd ),
			(LPCSTR)&cmd, sizeof( verdata ), (LPSTR) &verdata );
	    DPF( 5, "HAL version: %X", verdata.dwHALVersion );

	    /*
	     * If the driver failed the whacko version, but passed for 0x500 (DX5),
	     * then fail the driver.
	     */
	    if( rc > 0 && verdata.dwHALVersion >= 0x500 && bFailedWhackoVersion )
	    {
		DPF_ERR("****DirectDraw/Direct3D DRIVER DISABLING ERROR****Driver Failed a DDVERSIONINFO for a random future ddraw version but passed for DX5.");
		bPassDriverInit = FALSE;
		isdispdrv = FALSE;
		pdrv = NULL;
		hel_only = TRUE;
	    }

	    /*
	     * load up the 32-bit display driver DLL
	     */
	    DPF( 4, "DDGET32BITDRIVERNAME" );
	    cmd.dwCommand = (DWORD) DDGET32BITDRIVERNAME;
	    cmd.dwParam1 = 0;

	    cmd.dwVersion = DD_VERSION;
	    rc = ExtEscape( hdc_dd, DCICOMMAND, sizeof( cmd ),
			(LPCSTR)&cmd, sizeof( data ), (LPSTR) &data );
	    if( rc > 0 )
	    {
		#ifndef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#endif
		dwDriverData32 = HelperLoadDLL( data.szName, data.szEntryPoint, data.dwContext );

		DPF( 5, "DriverInit returned 0x%x", dwDriverData32 );
		#ifndef WIN16_SEPARATE
		    ENTER_DDRAW();
		#endif
	    }

	    /*
	     * get the 16-bit callbacks
	     */
	    DD16_GetDriverFns( &ddhddfns );

	    DPF( 4, "DDNEWCALLBACKFNS" );
	    cmd.dwCommand = (DWORD) DDNEWCALLBACKFNS;
	    #ifdef WIN95
		p16 = MapLS( &ddhddfns );
		cmd.dwParam1 = p16;
		cmd.dwParam2 = 0;
	    #else
		cmd.dwParam1 = (UINT) &ddhddfns;
		cmd.dwParam2 = 0;
	    #endif

	    cmd.dwVersion = DD_VERSION;
	    cmd.dwReserved = 0;

	    ExtEscape( hdc_dd, DCICOMMAND, sizeof( cmd ),
			(LPCSTR)&cmd, 0, NULL );
	    UnMapLS( p16 );

	    /*
	     * try to create the driver object now
	     */
	    DPF( 4, "DDCREATEDRIVEROBJECT" );
	    cmd.dwCommand = (DWORD) DDCREATEDRIVEROBJECT;
	    cmd.dwParam1 = dwDriverData32;
	    cmd.dwParam2 = 0;

	    cmd.dwVersion = DD_VERSION;
	    cmd.dwReserved = 0;

	    rc = ExtEscape( hdc_dd, DCICOMMAND, sizeof( cmd ),
			(LPCSTR)&cmd, sizeof( DWORD ), (LPVOID) &hInstance );
	    DPF( 5, "hInstance = %08lx", hInstance );

	    if( rc <= 0 )
	    {
		DPF( 0, "ExtEscape rc=%ld, GetLastError=%ld", rc, GetLastError() );
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:No DDCREATEDRIVEROBJECT support in driver" );
		isdispdrv = FALSE;
		pdrv = NULL;
		hel_only = TRUE;
	    }

            DPF(5,"bPassDriverInit:%d, rc:%d",bPassDriverInit,rc);

	    if ( (bPassDriverInit) && (rc > 0) )
	#endif //WIN95
	{
	    /*
	     * create our driver object
	     */
	    #ifdef WINNT
		uDisplaySettingsUnique=DdQueryDisplaySettingsUniqueness();
	    #endif
	    pdrv = FetchDirectDrawData( NULL, FALSE, hInstance, hDDVxd, pdrvname, dwDriverData32 , NULL);
	    if( pdrv )
	    {
		#ifdef WIN95
		    pdrv->dwInternal1 = verdata.dwHALVersion;
                    //Record 32-bit driver data so we can get its version info later
                    pdrv->dd32BitDriverData = data;
		#else
		    /*
		     * NT gets the same driver version as ddraw. Kernel
		     * has to filter ddraw.dll's ravings for the driver
		     */
		    pdrv->dwInternal1 = DD_RUNTIME_VERSION;
		#endif
		strcpy( pdrv->cDriverName, pdrvname );

#ifdef WIN95
                //
                // If we have to run in emulation only, then we better make sure we are
                // on a minidriver. If not, then emulation is unreliable so we'll bail
                // This is done to work around some messed up "remote control" programs
                // that turn off C1_DIBENGINE and make us fail (IsWin95MiniDriver used
                // to be called from IsDirectDrawSupported). The thinking is that if there's ddraw
                // support, then it is pretty much guaranteed to be a minidriver. If there's
                // no support, then we can trust the absence of C1_DIBENGINE and thus fail ddraw init
                //
                if( (pdrv->ddCaps.dwCaps & DDCAPS_NOHARDWARE) && !DD16_IsWin95MiniDriver() )
                {
	            DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:DirectDraw requires a Windows95 display driver" );
	            DirectDrawMsg(MAKEINTRESOURCE(IDS_DONTWORK_DRV));
	            CLOSEVXD( hDDVxd );
	            LEAVE_DDRAW();
	            LEAVE_CSDDC();
	            DD_DoneDC(hdc_dd);
	            return DDERR_GENERIC;
                }
#endif
	    }

            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF( 5, "pdrv = 0x%p", pdrv );
	    if( pdrv == NULL )
	    {
		DPF( 3, "Got returned NULL pdrv!" );
		isdispdrv = FALSE;
		hel_only = TRUE;
	    }
	    #ifdef WIN95
	    else
	    {
		/*
		 * The only certified drivers are ones that we produced.
		 * DD_HAL_VERSION is different for internal vs external.
		 * We use this difference pick out ours.
		 */
		if( halver == DD_HAL_VERSION )
		{
		    pdrv->ddCaps.dwCaps2 |= DDCAPS2_CERTIFIED;
		    DD16_SetCertified( TRUE );
		}
	    }
	    #endif
	}
    }

    /*
     * no driver object found, so fake one up for the HEL (only do this
     * for generic display drivers)
     */
    if( pdrv == NULL || hel_only )
    {
	hel_only = TRUE;
	pdrv = FakeDDCreateDriverObject( hdc_dd, pdrvname, NULL, FALSE, hDDVxd );
	if( pdrv == NULL )
	{
	    DPF_ERR( "Could not create HEL object" );
	    CLOSEVXD( hDDVxd );
	    LEAVE_DDRAW();
	    LEAVE_CSDDC();
	    DD_DoneDC(hdc_dd);
	    return DDERR_GENERIC;
	}

	/*
	 * the HEL is certified
	 */
	pdrv->ddCaps.dwCaps2 |= DDCAPS2_CERTIFIED;
	strcpy( pdrv->cDriverName, pdrvname );

	// Initialize Rect information for this pdrv
	UpdateRectFromDevice( pdrv );
    }

    /*
     * Even if it's not a display driver, it may still be a GDI driver
     */
    if( hdc_dd != NULL )
    {
	if( !(pdrv->dwFlags & DDRAWI_DISPLAYDRV))
	{
	    if (fDoesGDI(hdc_dd))
	    {
		pdrv->dwFlags |= DDRAWI_GDIDRV;
	    }
	    else
	    {
		pdrv->dwFlags &= ~DDRAWI_GDIDRV;
	    }
	}
    }
    /*
     * initialize for HEL usage
     */
    capsInit( pdrv );
    if( !helInit( pdrv, dwFlags, hel_only ) )
    {
	DPF_ERR( "helInit FAILED" );
	CLOSEVXD( hDDVxd );
	LEAVE_DDRAW();
	LEAVE_CSDDC();
	/* GEE: HEL can only fail in v1 for lack of memory */
	DD_DoneDC(hdc_dd);
	return DDERR_GENERIC;
    }

    /*
     * create a new interface, and update the driver object with
     * random bits o' data.
     */
    pdrv_int = getDriverInterface( pnew_int, pdrv );
    if( pdrv_int == NULL )
    {
	DPF_ERR( "No memory for driver callbacks." );
	CLOSEVXD( hDDVxd );
	LEAVE_DDRAW();
	LEAVE_CSDDC();
	DD_DoneDC(hdc_dd);
	return DDERR_OUTOFMEMORY;
    }
    pdrv_lcl = pdrv_int->lpLcl;
    pdrv_lcl->dwAppHackFlags = hackflags;

    #ifdef DEBUG
	if( dwRegFlags & DDRAW_REGFLAGS_DISABLEINACTIVATE )
	{
	    pdrv_lcl->dwLocalFlags |= DDRAWILCL_DISABLEINACTIVATE;
	}
    #endif
    if( IsAttachedToDesktop( lpGUID ) )
    {
	pdrv->dwFlags |= DDRAWI_ATTACHEDTODESKTOP;
    }
    if (bExplicitMonitor)
    {
	    pdrv_lcl->dwLocalFlags |= DDRAWILCL_EXPLICITMONITOR;
    }
    pdrv_lcl->dwLocalFlags |= dwCallFlags;
    /*
     * Will be initialized to NULL on NT.
     */
    pdrv_lcl->hDDVxd = (ULONG_PTR) hDDVxd;

    if( hdc_dd != NULL )
    {
    #ifdef WIN95
	    // Make sure it doesn't get released by mistake
	    DD16_MakeObjectPrivate(hdc_dd, TRUE);
    #endif
	(HDC) pdrv_lcl->hDC = hdc_dd;
    }
    strcpy( pdrv->cDriverName, pdrvname );

    #ifdef WINNT
	/*
	 * The FetchDirectDrawData() call above loaded a DD handle into a
	 * into a temp location in the driver GBL object; we must now save
	 * the handle in the driver LCL object so it won't be overwritten.
	 */
	pdrv_lcl->hDD = pdrv->hDD;
    #endif //WINNT

    // Initialize cObsolete just in case some driver references the
    // field. It will always be initialized to "DISPLAY".

    lstrcpy(pdrv->cObsolete, DISPLAY_STR);

    /*
     * Initialize the kernel interface
     */
    if( isdispdrv && !hel_only )
    {
	InitKernelInterface( pdrv_lcl );
    }

    LEAVE_DDRAW();
    #ifdef WIN95
	if( !hel_only )
	{
	    extern DWORD WINAPI OpenVxDHandle( HANDLE hWin32Obj );
	    DWORD       event16;
	    HANDLE      h;
	    HelperCreateModeSetThread( DDNotifyModeSet, &h, pdrv_lcl->lpGbl,
					pdrv->hInstance );
	    if( h != NULL )
	    {
		event16 = OpenVxDHandle( h );
		DPF( 4, "16-bit event handle=%08lx", event16 );
		DD16_SetEventHandle( pdrv->hInstance, event16 );
		pdrv->dwEvent16 = event16;
		CloseHandle( h );
	    }
	}

	/*
	 * Create thread that will notify us when we are returning from
	 * a DOS box so we can invalidate the surfaces.
	 */
	if( !hel_only && bIsPrimary && IsWindows98() )
	{
	    DWORD       event16;
	    HANDLE      h;
	    HelperCreateDOSBoxThread( DDNotifyDOSBox, &h, pdrv_lcl->lpGbl,
					pdrv->hInstance );
	    if( h != NULL )
	    {
		event16 = OpenVxDHandle( h );
		DPF( 4, "DOS Box event handle=%08lx", event16 );
		pdrv->dwDOSBoxEvent = event16;
		SetKernelDOSBoxEvent( pdrv_lcl );
		CloseHandle( h );
	    }
	}

    #endif

    LEAVE_CSDDC();
    *lplpDD = (LPDIRECTDRAW) pdrv_int;
    return DD_OK;

} /* InternalDirectDrawCreate */

BOOL CALLBACK MonitorEnumProc(HMONITOR hMon, HDC hdc, LPRECT lpr, LPARAM lParam)
{
    MONITORINFOEX       mix;
    MONITORINFO         mi;
    LPCALLBACKSTRUCT    lpcb = (LPCALLBACKSTRUCT) lParam;

    mi.cbSize = sizeof(mi);
    if (!InternalGetMonitorInfo(hMon,&mi))
	return FALSE;

    mix.cbSize = sizeof(mix);
    if (!InternalGetMonitorInfo(hMon,(MONITORINFO*) &mix))
	return FALSE;

    if (!strcmp(lpcb->pName,(LPSTR)mix.szDevice))
    {
	//Found it!!
	lpcb->hMon = hMon;
	return FALSE;
    }
    return TRUE;
}

/*
 * GetMonitorFromDeviceName
 */
HMONITOR GetMonitorFromDeviceName(LPSTR szName)
{
    CALLBACKSTRUCT cbs;
    cbs.pName = szName;
    cbs.hMon = NULL;

    if (!InternalEnumMonitors(MonitorEnumProc, &cbs))
	return NULL;

    return cbs.hMon;
}


/*
 * These callbacks are used to munge DirectDrawEnumerateEx's callback into the old
 * style callback.
 */
typedef struct
{
    LPDDENUMCALLBACKA   lpCallback;
    LPVOID              lpContext;
} ENUMCALLBACKTRANSLATORA, * LPENUMCALLBACKTRANSLATORA;

BOOL FAR PASCAL TranslateCallbackA(GUID FAR *lpGUID, LPSTR pName , LPSTR pDesc , LPVOID pContext, HMONITOR hm)
{
    LPENUMCALLBACKTRANSLATORA pTrans = (LPENUMCALLBACKTRANSLATORA) pContext;

    return (pTrans->lpCallback) (lpGUID,pName,pDesc,pTrans->lpContext);
}

typedef struct
{
    LPDDENUMCALLBACKW   lpCallback;
    LPVOID              lpContext;
} ENUMCALLBACKTRANSLATORW, * LPENUMCALLBACKTRANSLATORW;

BOOL FAR PASCAL TranslateCallbackW(GUID FAR *lpGUID, LPWSTR pName , LPWSTR pDesc , LPVOID pContext, HMONITOR hm)
{
    LPENUMCALLBACKTRANSLATORW pTrans = (LPENUMCALLBACKTRANSLATORW) pContext;

    return (pTrans->lpCallback) (lpGUID,pName,pDesc,pTrans->lpContext);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawEnumerateA"

/*
 * DirectDrawEnumerateA
 */
HRESULT WINAPI DirectDrawEnumerateA(
		LPDDENUMCALLBACKA lpCallback,
		LPVOID lpContext )
{
    ENUMCALLBACKTRANSLATORA Translate;
    Translate.lpCallback = lpCallback;
    Translate.lpContext = lpContext;

    DPF(2,A,"ENTERAPI: DirectDrawEnumerateA");

    if( !VALIDEX_CODE_PTR( lpCallback ) )
    {
	DPF( 0, "Invalid callback routine" );
	return DDERR_INVALIDPARAMS;
    }

#ifdef DEBUG
    if (IsMultiMonitor())
    {
	DPF(0,"***********************************************");
	DPF(0,"* Use DirectDrawEnumerateEx to enumerate      *");
	DPF(0,"* multiple monitors                           *");
	DPF(0,"***********************************************");
    }
#endif

    return DirectDrawEnumerateExA(TranslateCallbackA, (LPVOID) & Translate, DDENUM_NONDISPLAYDEVICES);
} /* DirectDrawEnumerateA */



#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawEnumerateW"

/*
 * DirectDrawEnumerateW
 */
HRESULT WINAPI DirectDrawEnumerateW(
		LPDDENUMCALLBACKW lpCallback,
		LPVOID lpContext )
{
    ENUMCALLBACKTRANSLATORW Translate;
    Translate.lpCallback = lpCallback;
    Translate.lpContext = lpContext;

    DPF(2,A,"ENTERAPI: DirectDrawEnumerateW");

    if( !VALIDEX_CODE_PTR( lpCallback ) )
    {
	DPF( 0, "Invalid callback routine" );
	return DDERR_INVALIDPARAMS;
    }

#ifdef DEBUG
    if (IsMultiMonitor())
    {
	DPF(0,"***********************************************");
	DPF(0,"* Use DirectDrawEnumerateEx to enumerate      *");
	DPF(0,"* multiple monitors                           *");
	DPF(0,"***********************************************");
    }
#endif

    return DirectDrawEnumerateExW(TranslateCallbackW, (LPVOID) & Translate, DDENUM_NONDISPLAYDEVICES);
} /* DirectDrawEnumerateW */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawEnumerateA"

/*
 * DirectDrawEnumerateA
 */
HRESULT WINAPI DirectDrawEnumerateExA(
		LPDDENUMCALLBACKEXA lpCallback,
		LPVOID lpContext,
		DWORD dwFlags )
{
    DWORD       rc;
    DWORD       keyidx;
    HKEY        hkey;
    HKEY        hsubkey;
    char        keyname[256];
    char        desc[256];
    char        drvname[MAX_PATH];
    DWORD       cb;
    DWORD       n;
    DWORD       type;
    GUID        guid;
    HDC         hdc;
    DISPLAY_DEVICEA dd;
    BOOL        bEnumerateSecondariesLike3dfx=FALSE;

    DPF(2,A,"ENTERAPI: DirectDrawEnumerateExA");

    //BEGIN VOODOO2 HACK
    {
        HKEY hkey;

	dwRegFlags &= ~DDRAW_REGFLAGS_ENUMERATEATTACHEDSECONDARIES;

        if( !RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDRAW, &hkey ) )
        {
            DWORD cb;
            DWORD value;
	    cb = sizeof( value );
	    if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_ENUMSECONDARY, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	    {
                DPF( 2, "    EnumerateAttachedSecondaries: %d", value );
	        if( value )
	        {
                    bEnumerateSecondariesLike3dfx = TRUE;
	            dwRegFlags |= DDRAW_REGFLAGS_ENUMERATEATTACHEDSECONDARIES;
	        }
	    }
	    RegCloseKey(hkey);
        }
    }
    //END VOODOO2 HACK

#ifdef WIN95
    /*
     * Did DDHELP fail to initialize properly?
     */
    if( dwHelperPid == 0 )
    {
        return DDERR_NODIRECTDRAWSUPPORT;
    }
#endif

    if( !VALIDEX_CODE_PTR( lpCallback ) )
    {
	DPF( 0, "Invalid callback routine" );
	return DDERR_INVALIDPARAMS;
    }

    if( dwFlags & ~DDENUM_VALID)
    {
	DPF_ERR("Invalid flags for DirectDrawEnumerateEx");
	return DDERR_INVALIDPARAMS;
    }

#ifdef WINNT
    // We do not support detached devices on NT so silently ignore the flag:
    dwFlags &= ~DDENUM_DETACHEDSECONDARYDEVICES;
#endif
    
    LoadString( hModule, IDS_PRIMARYDISPLAY, desc, sizeof(desc) );

    TRY
    {
	rc = lpCallback( NULL, desc, DISPLAY_STR, lpContext, NULL );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception occurred during DirectDrawEnumerateEx callback" );
	return DDERR_INVALIDPARAMS;
    }
    if( !rc )
    {
	return DD_OK;
    }

    if (dwFlags & DDENUM_NONDISPLAYDEVICES)
    {
	if( RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDHW, &hkey ) == 0 )
	{
	    /*
	     * enumerate all subkeys under HKEY_LOCALMACHINE\Hardware\DirectDrawDrivers
	     */
	    keyidx = 0;
	    while( !RegEnumKey( hkey, keyidx, keyname, sizeof( keyname ) ) )
	    {
		if( strToGUID( keyname, &guid ) )
		{
		    if( !RegOpenKey( hkey, keyname, &hsubkey ) )
		    {
			cb = sizeof( desc ) - 1;
			if( !RegQueryValueEx( hsubkey, REGSTR_KEY_DDHW_DESCRIPTION, NULL, &type,
				    (CONST LPBYTE)desc, &cb ) )
			{
			    if( type == REG_SZ )
			    {
				desc[cb] = 0;
				cb = sizeof( drvname ) - 1;
				if( !RegQueryValueEx( hsubkey, REGSTR_KEY_DDHW_DRIVERNAME, NULL, &type,
					    (CONST LPBYTE)drvname, &cb ) )
				{
				    /*
				     * It is possible that the registry is out
				     * of date, so we will try to create a DC.
				     * The problem is that the Voodoo 1 driver
                                     * will suceed on a Voodoo 2, Banshee, or
                                     * Voodoo 3 (and hang later), so we need to
                                     * hack around it.
				     */
				    drvname[cb] = 0;
                                    if( Voodoo1GoodToGo( &guid ) )
                                    {
                                        hdc = DD_CreateDC( drvname );
                                    }
                                    else
                                    {
                                        hdc = NULL;
                                    }
				    if( ( type == REG_SZ ) &&
					( hdc != NULL ) )
				    {
					drvname[cb] = 0;
					DPF( 5, "Enumerating GUID "
						    "%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x",
						    guid.Data1,
						    guid.Data2,
						    guid.Data3,
						    guid.Data4[ 0 ],
						    guid.Data4[ 1 ],
						    guid.Data4[ 2 ],
						    guid.Data4[ 3 ],
						    guid.Data4[ 4 ],
						    guid.Data4[ 5 ],
						    guid.Data4[ 6 ],
						    guid.Data4[ 7 ] );
					DPF( 5, "    Driver Name = %s", drvname );
					DPF( 5, "    Description = %s", desc );
					rc = lpCallback( &guid, desc, drvname, lpContext , NULL);
					if( !rc )
					{
					    DD_DoneDC( hdc );
                                            RegCloseKey( hsubkey );
					    RegCloseKey( hkey );
					    return DD_OK;
					}
				    }
				    if( hdc != NULL )
				    {
					DD_DoneDC( hdc );
				    }
				}
			    }
			}
			RegCloseKey( hsubkey );
		    }
		}
		keyidx++;
	    }
	    RegCloseKey( hkey );
	}
    }
    else
    {
	DPF( 3, "No registry information for any drivers" );
    }

    /*
     * now enumerate all devices returned by EnumDisplayDevices
     * We do this after the secondary drivers to hopefully not confuse people
     * who are looking for 3DFx and have written bad code. Putting these
     * after the 3DFx seems the safest thing to do..
     */

    /* If there is only one device in the system then we don't
     * enumerate it because it already is implicitly the primary
     * This will improve behavior for badly written (i.e. our samples)
     * D3D apps that are searching for a 3DFx device.
     */
    if( !IsMultiMonitor() )
    {
	// If there is only one device; then just stop here.
	DPF( 3, "Only one Display device in the current system." );
	return DD_OK;
    }

    DPF( 3, "More than one display device in the current system." );

    // Zero the memory of the DisplayDevice struct between calls to
    // EnumDisplayDevices
    ZeroMemory(&dd, sizeof(dd));
    dd.cb = sizeof(dd);

    for( n=0; xxxEnumDisplayDevicesA( NULL, n, &dd, 0 ); n++ )
    {
	GUID guid;

	//
	// skip drivers that are not hardware devices
	//
	if( dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER )
	    continue;

	guid = DisplayGUID;
	guid.Data1 += n;

	if ( (dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) ?
	    ((dwFlags & DDENUM_ATTACHEDSECONDARYDEVICES) ||
//BEGIN VOODOO2 HACK
                    (bEnumerateSecondariesLike3dfx && !(dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)) ):
//END VOODOO2 HACK
            (dwFlags & DDENUM_DETACHEDSECONDARYDEVICES) )
	{
	    HMONITOR hMonitor;

	    DPF( 5, "Enumerating GUID "
			"%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x",
			guid.Data1,
			guid.Data2,
			guid.Data3,
			guid.Data4[ 0 ],
			guid.Data4[ 1 ],
			guid.Data4[ 2 ],
			guid.Data4[ 3 ],
			guid.Data4[ 4 ],
			guid.Data4[ 5 ],
			guid.Data4[ 6 ],
			guid.Data4[ 7 ] );
	    DPF( 5, "    Driver Name = %s", dd.DeviceName );
	    DPF( 5, "    Description = %s", dd.DeviceString );
	    hMonitor = GetMonitorFromDeviceName(dd.DeviceName);
	    rc = lpCallback( &guid, dd.DeviceString, dd.DeviceName, lpContext, hMonitor);

	    if( !rc )
	    {
		return DD_OK;
	    }
	}

	// Zero the memory of the DisplayDevice struct between calls to
	// EnumDisplayDevices
	ZeroMemory( &dd, sizeof(dd) );
	dd.cb = sizeof(dd);
    }

    return DD_OK;

} /* DirectDrawEnumerateExA */



#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawEnumerateExW"

/*
 * DirectDrawEnumerateExW
 */
HRESULT WINAPI DirectDrawEnumerateExW(
		LPDDENUMCALLBACKEXW lpCallback,
		LPVOID lpContext,
		DWORD dwFlags)
{
    DPF(2,A,"ENTERAPI: DirectDrawEnumerateExW");	
    DPF_ERR( "DirectDrawEnumerateEx for unicode is not created" );
    return DDERR_UNSUPPORTED;

} /* DirectDrawEnumerateExW */


/*
 * these are exported... temp. hack for non-Win95
 */
#ifndef WIN95
void DDAPI thk3216_ThunkData32( void )
{
}
void DDAPI thk1632_ThunkData32( void )
{
}

DWORD DDAPI DDGetPID( void )
{
    return 0;
}

int DDAPI DDGetRequest( void )
{
    return 0;
}

BOOL DDAPI DDGetDCInfo( LPSTR fname )
{
    return 0;
}

void DDAPI DDHAL32_VidMemFree(
		LPVOID this,
		int heap,
		FLATPTR ptr )
{
}

FLATPTR DDAPI DDHAL32_VidMemAlloc(
		LPVOID this,
		int heap,
		DWORD dwWidth,
		DWORD dwHeight )
{
    return 0;
}

#ifdef POSTPONED
BOOL DDAPI DD32_HandleExternalModeChange(LPDEVMODE pModeInfo)
{
    return FALSE;
}
#endif
#endif

/*
 * _DirectDrawMsg
 */
DWORD WINAPI _DirectDrawMsg(LPVOID msg)
{
    char                title[80];
    char                ach[512];
    MSGBOXPARAMS        mb;

    LoadString( hModule, IDS_TITLE, title, sizeof(title) );

    if( HIWORD((ULONG_PTR)msg) )
    {
	lstrcpy( ach, (LPSTR)msg );
    }
    else
    {
	LoadString( hModule, (int)((ULONG_PTR)msg), ach, sizeof(ach) );
    }

    mb.cbSize               = sizeof(mb);
    mb.hwndOwner            = NULL;
    mb.hInstance            = hModule;
    mb.lpszText             = ach;
    mb.lpszCaption          = title;
    mb.dwStyle              = MB_OK|MB_SETFOREGROUND|MB_TOPMOST|MB_ICONSTOP;
    mb.lpszIcon             = 0;
    mb.dwContextHelpId      = 0;
    mb.lpfnMsgBoxCallback   = NULL;
    mb.dwLanguageId         = 0;

    return MessageBoxIndirect(&mb);

} /* _DirectDrawMsg */

/*
 * DirectDrawMsg
 *
 * display an error message to the user, bring the message box up
 * in another thread so the caller does not get reentered.
 */
DWORD DirectDrawMsg( LPSTR msg )
{
    HANDLE h;
    DWORD  dw;
    HKEY   hkey;

    //
    // get the current error mode, dont show a message box if the app
    // does not want us too.
    //
    dw = SetErrorMode(0);
    SetErrorMode(dw);

    if( dw & SEM_FAILCRITICALERRORS )
    {
	return 0;
    }

    /*
     * If the registry says no dialogs, then no dialogs.
     */
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDRAW, &hkey ) )
    {
	DWORD   type;
	DWORD   value;
	DWORD   cb;

	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLEDIALOGS, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    if (value)
	    {
		RegCloseKey( hkey );
		return 0;
	    }
	}
	RegCloseKey( hkey );
    }


    if( h = CreateThread(NULL, 0, _DirectDrawMsg, (LPVOID)msg, 0, &dw) )
    {
	WaitForSingleObject( h, INFINITE );
	GetExitCodeThread( h, &dw );
	CloseHandle( h );
    }
    else
    {
	dw = 0;
    }

    return dw;

} /* DirectDrawMsg */

/*
 * convertV1DDHALINFO
 *
 * Convert an obsolete DDHALINFO structure to the latest and greatest structure.
 * This function takes a pointer to an LPDDHALINFO structure which has the same size as
 * the new structure but has been filled in as if it is the V1 structure.  Information is moved
 * around in the structure and the new fields are cleared.
 */
void convertV1DDHALINFO( LPDDHALINFO lpDDHALInfo )
{
    DDHALINFO   ddNew;
    LPDDHALINFO_V1 lpddOld = (LPVOID)lpDDHALInfo;
    int         i;

    ddNew.dwSize = sizeof( DDHALINFO );
    ddNew.lpDDCallbacks = lpddOld->lpDDCallbacks;
    ddNew.lpDDSurfaceCallbacks = lpddOld->lpDDSurfaceCallbacks;
    ddNew.lpDDPaletteCallbacks = lpddOld->lpDDPaletteCallbacks;
    ddNew.vmiData = lpddOld->vmiData;

    // ddCaps
    ddNew.ddCaps.dwSize = lpddOld->ddCaps.dwSize;
    ddNew.ddCaps.dwCaps = lpddOld->ddCaps.dwCaps;
    ddNew.ddCaps.dwCaps2 = lpddOld->ddCaps.dwCaps2;
    ddNew.ddCaps.dwCKeyCaps = lpddOld->ddCaps.dwCKeyCaps;
    ddNew.ddCaps.dwFXCaps = lpddOld->ddCaps.dwFXCaps;
    ddNew.ddCaps.dwFXAlphaCaps = lpddOld->ddCaps.dwFXAlphaCaps;
    ddNew.ddCaps.dwPalCaps = lpddOld->ddCaps.dwPalCaps;
    ddNew.ddCaps.dwSVCaps = lpddOld->ddCaps.dwSVCaps;
    ddNew.ddCaps.dwAlphaBltConstBitDepths = lpddOld->ddCaps.dwAlphaBltConstBitDepths;
    ddNew.ddCaps.dwAlphaBltPixelBitDepths = lpddOld->ddCaps.dwAlphaBltPixelBitDepths;
    ddNew.ddCaps.dwAlphaBltSurfaceBitDepths = lpddOld->ddCaps.dwAlphaBltSurfaceBitDepths;
    ddNew.ddCaps.dwAlphaOverlayConstBitDepths = lpddOld->ddCaps.dwAlphaOverlayConstBitDepths;
    ddNew.ddCaps.dwAlphaOverlayPixelBitDepths = lpddOld->ddCaps.dwAlphaOverlayPixelBitDepths;
    ddNew.ddCaps.dwAlphaOverlaySurfaceBitDepths = lpddOld->ddCaps.dwAlphaOverlaySurfaceBitDepths;
    ddNew.ddCaps.dwZBufferBitDepths = lpddOld->ddCaps.dwZBufferBitDepths;
    ddNew.ddCaps.dwVidMemTotal = lpddOld->ddCaps.dwVidMemTotal;
    ddNew.ddCaps.dwVidMemFree = lpddOld->ddCaps.dwVidMemFree;
    ddNew.ddCaps.dwMaxVisibleOverlays = lpddOld->ddCaps.dwMaxVisibleOverlays;
    ddNew.ddCaps.dwCurrVisibleOverlays = lpddOld->ddCaps.dwCurrVisibleOverlays;
    ddNew.ddCaps.dwNumFourCCCodes = lpddOld->ddCaps.dwNumFourCCCodes;
    ddNew.ddCaps.dwAlignBoundarySrc = lpddOld->ddCaps.dwAlignBoundarySrc;
    ddNew.ddCaps.dwAlignSizeSrc = lpddOld->ddCaps.dwAlignSizeSrc;
    ddNew.ddCaps.dwAlignBoundaryDest = lpddOld->ddCaps.dwAlignBoundaryDest;
    ddNew.ddCaps.dwAlignSizeDest = lpddOld->ddCaps.dwAlignSizeDest;
    ddNew.ddCaps.dwAlignStrideAlign = lpddOld->ddCaps.dwAlignStrideAlign;
    ddNew.ddCaps.ddsCaps = lpddOld->ddCaps.ddsCaps;
    ddNew.ddCaps.dwMinOverlayStretch = lpddOld->ddCaps.dwMinOverlayStretch;
    ddNew.ddCaps.dwMaxOverlayStretch = lpddOld->ddCaps.dwMaxOverlayStretch;
    ddNew.ddCaps.dwMinLiveVideoStretch = lpddOld->ddCaps.dwMinLiveVideoStretch;
    ddNew.ddCaps.dwMaxLiveVideoStretch = lpddOld->ddCaps.dwMaxLiveVideoStretch;
    ddNew.ddCaps.dwMinHwCodecStretch = lpddOld->ddCaps.dwMinHwCodecStretch;
    ddNew.ddCaps.dwMaxHwCodecStretch = lpddOld->ddCaps.dwMaxHwCodecStretch;
    ddNew.ddCaps.dwSVBCaps = 0;
    ddNew.ddCaps.dwSVBCKeyCaps = 0;
    ddNew.ddCaps.dwSVBFXCaps = 0;
    ddNew.ddCaps.dwVSBCaps = 0;
    ddNew.ddCaps.dwVSBCKeyCaps = 0;
    ddNew.ddCaps.dwVSBFXCaps = 0;
    ddNew.ddCaps.dwSSBCaps = 0;
    ddNew.ddCaps.dwSSBCKeyCaps = 0;
    ddNew.ddCaps.dwSSBFXCaps = 0;
    ddNew.ddCaps.dwMaxVideoPorts = 0;
    ddNew.ddCaps.dwCurrVideoPorts = 0;
    ddNew.ddCaps.dwReserved1 = lpddOld->ddCaps.dwReserved1;
    ddNew.ddCaps.dwReserved2 = lpddOld->ddCaps.dwReserved2;
    ddNew.ddCaps.dwReserved3 = lpddOld->ddCaps.dwReserved3;
    ddNew.ddCaps.dwSVBCaps2 = 0;
    for(i=0; i<DD_ROP_SPACE; i++)
    {
	ddNew.ddCaps.dwRops[i] = lpddOld->ddCaps.dwRops[i];
	ddNew.ddCaps.dwSVBRops[i] = 0;
	ddNew.ddCaps.dwVSBRops[i] = 0;
	ddNew.ddCaps.dwSSBRops[i] = 0;
    }

    ddNew.dwMonitorFrequency = lpddOld->dwMonitorFrequency;
    ddNew.GetDriverInfo = NULL; // was unused hWndListBox in v1
    ddNew.dwModeIndex = lpddOld->dwModeIndex;
    ddNew.lpdwFourCC = lpddOld->lpdwFourCC;
    ddNew.dwNumModes = lpddOld->dwNumModes;
    ddNew.lpModeInfo = lpddOld->lpModeInfo;
    ddNew.dwFlags = lpddOld->dwFlags;
    ddNew.lpPDevice = lpddOld->lpPDevice;
    ddNew.hInstance = lpddOld->hInstance;

    ddNew.lpD3DGlobalDriverData = 0;
    ddNew.lpD3DHALCallbacks = 0;
    ddNew.lpDDExeBufCallbacks = NULL;

    *lpDDHALInfo = ddNew;
}

// The callback used by Win9x drivers and the software rasterizers to help them
// parse execute buffers.
HRESULT CALLBACK D3DParseUnknownCommand (LPVOID lpvCommands,
					 LPVOID *lplpvReturnedCommand)
{
    LPD3DINSTRUCTION lpInstr = (LPD3DINSTRUCTION) lpvCommands;

    // Initialize the return address to the command's address
    *lplpvReturnedCommand = lpvCommands;

    switch (lpInstr->bOpcode)
    {
    case D3DOP_PROCESSVERTICES:
        // cannot do D3DOP_PROCESSVERTICES here even for in-place copy because we
        // generally don't pass the execute buffer's vertex buffer as the DP2 vertex buffer
        return D3DERR_COMMAND_UNPARSED;
    case D3DOP_SPAN:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof (D3DINSTRUCTION) +
                                          lpInstr->wCount *
                                          lpInstr->bSize);
        return DD_OK;
    case D3DDP2OP_VIEWPORTINFO:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof(D3DHAL_DP2COMMAND) +
                                          lpInstr->wCount *
                                          sizeof(D3DHAL_DP2VIEWPORTINFO));
        return DD_OK;
    case D3DDP2OP_WINFO:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof(D3DHAL_DP2COMMAND) +
                                          lpInstr->wCount *
                                          sizeof(D3DHAL_DP2WINFO));
        return DD_OK;
    case D3DOP_MATRIXLOAD:
    case D3DOP_MATRIXMULTIPLY:
    case D3DOP_STATETRANSFORM:
    case D3DOP_STATELIGHT:
    case D3DOP_TEXTURELOAD:
    case D3DOP_BRANCHFORWARD:
    case D3DOP_SETSTATUS:
    case D3DOP_EXIT:
        return D3DERR_COMMAND_UNPARSED;
    default:
        return DDERR_GENERIC;
    }
}

/*
 * fetchModeXData
 */
LPDDRAWI_DIRECTDRAW_GBL fetchModeXData(
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		LPDDHALMODEINFO pmi,
                HANDLE hDDVxd )
{
    DDHALINFO                   ddhi;
    LPDDRAWI_DIRECTDRAW_GBL     new_pdrv;
    DDPIXELFORMAT               dpf;
#ifdef WINNT
    DDHALMODEINFO               dmi;
#endif

    /*
     * initialize the DDHALINFO struct
     */
    memset( &ddhi, 0, sizeof( ddhi ) );
    ddhi.dwSize = sizeof( ddhi );

    /*
     * capabilities supported (none)
     */
    ddhi.ddCaps.dwCaps = 0;
    ddhi.ddCaps.dwFXCaps = 0;
    ddhi.ddCaps.dwCKeyCaps = 0;
    ddhi.ddCaps.ddsCaps.dwCaps = 0;

    /*
     * pointer to primary surface.
     */
    if ( pmi->wFlags & DDMODEINFO_STANDARDVGA )
    {
        ddhi.vmiData.fpPrimary = 0xa0000;
    }
    else
    {
        //This needs to be SCREEN_PTR or the HEL won't realize it's a bad address
        //(since when restoring display modes, restoreSurface for the primary will
        //call into AllocSurfaceMem which will triviallt allocate the primary surface
        //by setting fpVidMem == fpPrimaryOrig which will have been set to whatever
        //we set here.
        ddhi.vmiData.fpPrimary = 0xffbadbad;
    }

    /*
     * build mode and pixel format info
     */
    ddhi.vmiData.dwDisplayHeight = pmi->dwHeight;
    ddhi.vmiData.dwDisplayWidth = pmi->dwWidth;
    ddhi.vmiData.lDisplayPitch = pmi->lPitch;
    BuildPixelFormat( NULL, pmi, &dpf );
    ddhi.vmiData.ddpfDisplay = dpf;

    /*
     * fourcc code information
     */
    ddhi.ddCaps.dwNumFourCCCodes = 0;
    ddhi.lpdwFourCC = NULL;

    /*
     * Fill in heap info
     */
    ddhi.vmiData.dwNumHeaps = 0;
    ddhi.vmiData.pvmList = NULL;

    /*
     * required alignments of the scanlines of each kind of memory
     * (DWORD is the MINIMUM)
     */
    ddhi.vmiData.dwOffscreenAlign = sizeof( DWORD );
    ddhi.vmiData.dwTextureAlign = sizeof( DWORD );
    ddhi.vmiData.dwZBufferAlign = sizeof( DWORD );

    /*
     * callback functions
     */
    ddhi.lpDDCallbacks = NULL;
    ddhi.lpDDSurfaceCallbacks = NULL;
    ddhi.lpDDPaletteCallbacks = NULL;

    /*
     * create the driver object
     */
#ifdef WINNT
    //We can only get into modex if the ddraw object has already been created:
    DDASSERT(pdrv);
    //Don't fetch the driver's caps
    ddhi.ddCaps.dwCaps = DDCAPS_NOHARDWARE;
    //Force the modex data into the pdd. This causes GetCurrentMode to be a noop.
    //pdrv->dwFlags |= DDRAWI_NOHARDWARE;
    pdrv->dmiCurrent.wWidth         =(WORD)pmi->dwWidth;
    pdrv->dmiCurrent.wHeight        =(WORD)pmi->dwHeight;
    pdrv->dmiCurrent.wBPP           =(BYTE)pmi->dwBPP;
    pdrv->dmiCurrent.wRefreshRate   =pmi->wRefreshRate;
    pdrv->dmiCurrent.wMonitorsAttachedToDesktop=(BYTE)GetNumberOfMonitorAttachedToDesktop();
#endif
    new_pdrv = DirectDrawObjectCreate( &ddhi, TRUE, pdrv, hDDVxd, NULL, 0 , 0 /* ATTENTION: No local flags for modex driver */ );
    DPF(5,"MODEX driver object's display is %dx%d, pitch is %d", ddhi.vmiData.dwDisplayHeight,ddhi.vmiData.dwDisplayWidth,ddhi.vmiData.lDisplayPitch);

    if( new_pdrv != NULL )
    {
	new_pdrv->dwFlags |= DDRAWI_MODEX;

        if ( pmi->wFlags & DDMODEINFO_STANDARDVGA )
        {
	    new_pdrv->dwFlags |= DDRAWI_STANDARDVGA;
        }
#ifdef WIN95
	if( new_pdrv->dwPDevice != 0 )
	{
	    new_pdrv->dwPDevice = 0;
	    new_pdrv->lpwPDeviceFlags = (WORD *)&dwFakeFlags;
	}
#endif //WIN95
    }
    DPF( 5, "ModeX DirectDraw object created (Standard VGA flag:%d)", (new_pdrv->dwFlags & DDRAWI_STANDARDVGA) ? 1 : 0 );
    DPF( 5, "	width=%ld, height=%ld, %ld bpp",
			new_pdrv->vmiData.dwDisplayWidth,
			new_pdrv->vmiData.dwDisplayHeight,
			new_pdrv->vmiData.ddpfDisplay.dwRGBBitCount );
    DPF( 5, "   lDisplayPitch = %ld", new_pdrv->vmiData.lDisplayPitch );

    return new_pdrv;

} /* fetchModeXData */

#ifdef WINNT
/*
 * GetDriverInfo2
 */
DWORD APIENTRY GetDriverInfo2(LPDDRAWI_DIRECTDRAW_GBL lpGbl,
                              DWORD* pdwDrvRet, 
                              DWORD dwType,
                              DWORD dwSize,
                              void* pBuffer)
{
    DD_GETDRIVERINFO2DATA*          pGDI2Data;
    DWORD                           ret;
    DDHAL_GETDRIVERINFODATA         gdidata;

    // We cannot do anything if the driver doesn't support GetDriverInfo2
    if ((lpGbl == NULL) || (!(lpGbl->dwFlags & DDRAWI_DRIVERINFO2)))
    {
        return 0;
    }
       
    // Setup GetDriverInfo2 call
    pGDI2Data = (DD_GETDRIVERINFO2DATA*) pBuffer;

    memset(pGDI2Data, 0, sizeof(*pGDI2Data));
    pGDI2Data->dwReserved       = sizeof(DD_STEREOMODE);
    pGDI2Data->dwMagic          = D3DGDI2_MAGIC;
    pGDI2Data->dwType           = dwType;
    pGDI2Data->dwExpectedSize   = dwSize;

    ret = GetDriverInfo(lpGbl->pGetDriverInfo, 
                        &gdidata,
                        pBuffer,
                        sizeof(DD_STEREOMODE),
                        &GUID_GetDriverInfo2, 
                        lpGbl,
                        TRUE /* bInOut */);

    *pdwDrvRet = gdidata.ddRVal;
    return ret;
}

/*
 * NotifyDriverOfFreeAliasedLocks
 *
 *  This notifies the driver that we have unlocked all outstanding aliased
 *  locks on the device.  It is possible to have multiple GBLs using the same
 *  physical device, so we need to handle that.
 */
void NotifyDriverOfFreeAliasedLocks()
{
    DD_FREE_DEFERRED_AGP_DATA   fad;
    DWORD                       dwDrvRet;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_temp;
    BOOL                        bSkipThisOne;

    if (dwNumLockedWhenModeSwitched == 0)
    {
        // Notify each device that all outstanding syslocks are gone
        fad.dwProcessId = GetCurrentProcessId();
        pdd_lcl = lpDriverLocalList;
        while (pdd_lcl != NULL)
        {
            bSkipThisOne = FALSE;
            pdd_temp = lpDriverLocalList;
            while ((pdd_temp != NULL) &&
                   (pdd_temp != pdd_lcl))
            {
                if (pdd_temp->lpGbl == pdd_lcl->lpGbl)
                {
                    bSkipThisOne = TRUE;
                    break;
                }
                pdd_temp = pdd_temp->lpLink;
            }

            if (!bSkipThisOne)
            {
                GetDriverInfo2(pdd_lcl->lpGbl, &dwDrvRet, 
                               D3DGDI2_TYPE_FREE_DEFERRED_AGP,
                               sizeof(fad), &fad);
            }
            pdd_lcl = pdd_lcl->lpLink;
        }
    }
}

/*
 * NotifyDriverToDeferFrees
 *
 *  This notifies the driver that we are doing a mode change and they
 *  should start defering AGP free if they need to.
 */
void NotifyDriverToDeferFrees()
{
    DD_FREE_DEFERRED_AGP_DATA   fad;
    DWORD                       dwDrvRet;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_temp;
    BOOL                        bSkipThisOne;

    // Notify each device that all outstanding syslocks are gone
    fad.dwProcessId = GetCurrentProcessId();
    pdd_lcl = lpDriverLocalList;
    while (pdd_lcl != NULL)
    {
        bSkipThisOne = FALSE;
        pdd_temp = lpDriverLocalList;
        while ((pdd_temp != NULL) &&
               (pdd_temp != pdd_lcl))
        {
            if (pdd_temp->lpGbl == pdd_lcl->lpGbl)
            {
                bSkipThisOne = TRUE;
                break;
            }
            pdd_temp = pdd_temp->lpLink;
        }

        if (!bSkipThisOne)
        {
            GetDriverInfo2(pdd_lcl->lpGbl, &dwDrvRet, 
                           D3DGDI2_TYPE_DEFER_AGP_FREES,
                           sizeof(fad), &fad);
        }
        pdd_lcl = pdd_lcl->lpLink;
    }
}

/*
 * CheckAliasedLocksOnModeChange
 *
 *  On NT we have to tell the driver when we are done using all surfaces that were 
 *  locked with NOSYSLOCK so they can properly handle the case when they manage 
 *  their own AGP heaps.
 */
void CheckAliasedLocksOnModeChange()
{
    DWORD                       dwGDI2Ret;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_temp;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    BOOL                        bSkipThisOne;

    // For each device, figure out how many surfs are holding aliased locks and
    // mark the surfaces. 
    dwNumLockedWhenModeSwitched = 0;
    pdd_lcl = lpDriverLocalList;
    while (pdd_lcl != NULL)
    {
        // if we have already processed this GBL, don't do it again!
        bSkipThisOne = FALSE;
        pdd_temp = lpDriverLocalList;
        while ((pdd_temp != NULL) &&
               (pdd_temp != pdd_lcl))
        {
            if (pdd_temp->lpGbl == pdd_lcl->lpGbl)
            {
                bSkipThisOne = TRUE;
                break;
            }
            pdd_temp = pdd_temp->lpLink;
        }
        
        if (!bSkipThisOne &&
            (pdd_lcl->lpGbl != NULL))
        {
            // We need to start fresh with each device, so clear all flags we
            // have outstanding as to whether the surface has an outstanding
            // NOSYSLOCK lock.  
            psurf_int = pdd_lcl->lpGbl->dsList;
            while (psurf_int != NULL)
            {
                if (psurf_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED)
                {
                    psurf_int->lpLcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
                }
                psurf_int = psurf_int->lpLink;
            }

            // Now we go back through them and re-mark them.
            psurf_int = pdd_lcl->lpGbl->dsList;
            while (psurf_int != NULL)
            {
                if ((psurf_int->lpLcl->lpGbl->dwUsageCount > 0) &&
                    !(psurf_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED))
                {
                    // The code below relies on the fact that the NT kernel
                    // cannot handle multiple locks to the same surface if any
                    // one of them is a NOSYSLOCK.  If this ever changes, this
                    // code needs to be changed.
                    if (psurf_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK)
                    {
                        psurf_int->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
                        dwNumLockedWhenModeSwitched++;
                    }
                    else if ((psurf_int->lpLcl->lpGbl->lpRectList != NULL) &&
                             (psurf_int->lpLcl->lpGbl->lpRectList->dwFlags & ACCESSRECT_NOTHOLDINGWIN16LOCK))
                    {
                        psurf_int->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
                        dwNumLockedWhenModeSwitched++;
                    }
                }
                psurf_int = psurf_int->lpLink;
            }
       }
       pdd_lcl = pdd_lcl->lpLink;
    }

    // Now see if we can notify the drivers to free the surfaces or not.
    if ((dwNumLockedWhenModeSwitched == 0) &&
        (lpDriverLocalList != NULL))
    {
        // For DX9, add logic here to handle bad PDEVs
        NotifyDriverOfFreeAliasedLocks();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\dddefwp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddefwp.c
 *  Content:    DirectDraw processing of Window messages
 *              Takes care of palette changes, mode setting
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   26-mar-95  craige  initial implementation
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-may-95  craige  use driver-level csects only
 *   02-jun-95  craige  flesh it out
 *   06-jun-95  craige  added SetAppHWnd
 *   07-jun-95  craige  more fleshing...
 *   12-jun-95  craige  new process list stuff
 *   16-jun-95  craige  new surface structure
 *   25-jun-95  craige  one ddraw mutex
 *   30-jun-95  kylej   use GetProcessPrimary instead of lpPrimarySurface
 *                      invalidate all primary surfaces upon focus lost
 *                      or regained.
 *   30-jun-95  craige  minimze window for CAD, ALT-TAB, ALT-ESC or CTRL-ESC
 *   04-jul-95  craige  YEEHAW: new driver struct
 *   06-jul-95  craige  prevent reentry
 *   08-jul-95  craige  allow dsound to share
 *   08-jul-95  kylej   remove call to ResetSysPalette
 *   11-jul-95  craige  DSoundHelp & internalSetAppHWnd needs to take a pid
 *   13-jul-95  craige  first step in mode set fix; made it work.
 *   15-jul-95  craige  unhook at WM_DESTROY; don't escape on ALT; do a
 *                      SetActiveWindow( NULL ) to stop tray from showing
 *                      our button as depressed
 *   17-jul-95  craige  don't process hot key messages & activation messages
 *                      for non-excl mode apps; SetActiveWindow is bogus,
 *                      get bottom window in Z order and make it foreground
 *   18-jul-95  craige  use flags instead of refcnt to track WININFO
 *   29-jul-95  toddla  make ALT+TAB and CTRL+ESC work.
 *   31-jul-95  toddla  make ALT+TAB and CTRL+ESC work better.
 *   09-aug-95  craige  bug 424 - allow switching to/from apps without primary
 *                      surfaces to work
 *   09-aug-95  craige  bug 404 - don't pass WM_ACTIVATEAPP messages to dsound
 *                      if app iconic
 *   10-aug-95  toddla  check WININFO_DSOUNDHOOKED before calling DSound
 *   10-aug-95  toddla  handle unhooking after/during WM_DESTROY right.
 *   13-aug-95  toddla  added WININFO_ACTIVELIE
 *   23-aug-95  craige  bug 388,610
 *   25-aug-95  craige  bug 709
 *   27-aug-95  craige  bug 735: call SetPaletteAlways
 *   04-sep-95  craige  bug 894: force mode set when activating
 *   09-sep-95  toddla  dont send nested WM_ACTIVATEAPP messages
 *   26-sep-95  craige  bug 1364: use new csect to avoid dsound deadlock
 *   09-jan-96  kylej   new interface structures
 *   13-apr-96  colinmc Bug 17736: No notification to driver of flip to GDI
 *   20-apr-96  kylej   Bug 16747: Make exclusive window visible if it is not.
 *   23-apr-96  kylej   Bug 14680: Make sure exclusive window is not maximized.
 *   16-may-96  kylej   Bug 23013: pass the correct flags to StartExclusiveMode
 *   17-may-96  colinmc Bug 23029: Alt-tabbing straight back to a full screen
 *                      does not send the app an WM_ACTIVATEAPP
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   16-oct-96  colinmc Added PrintScreen support to allow screen grabbing
 *   05-feb-96  ketand  Bug 1749: Alt-Tab from fullscreen app would cause cycling when
 *                      the only other window running is the Start::Run window.
 *   03-mar-97  jeffno  Structure name change to avoid conflict w/ ActiveAccessibility
 *   24-mar-97  colinmc Bug 6913: Enable ModeX PRINTSCREEN
 *
 ***************************************************************************/
#include "ddrawpr.h"

#define TOPMOST_ID      0x4242
#define TOPMOST_TIMEOUT 1500

#define USESHOWWINDOW

#ifdef WIN95
    extern CRITICAL_SECTION     csWindowList;
    #define ENTERWINDOWLISTCSECT    EnterCriticalSection( &csWindowList );
    #define LEAVEWINDOWLISTCSECT    LeaveCriticalSection( &csWindowList );
#elif defined(WINNT)
    extern HANDLE hWindowListMutex;
    #define ENTERWINDOWLISTCSECT    WaitForSingleObject(hWindowListMutex,INFINITE);
    #define LEAVEWINDOWLISTCSECT    ReleaseMutex(hWindowListMutex);
#else
    #error "Win95 or winnt- make up your mind!"
#endif

#ifndef ENUM_CURRENT_SETTINGS
#define ENUM_CURRENT_SETTINGS       ((DWORD)-1)
#endif


/*
 * DD_GetDeviceRect
 *
 * get the rect in screen space for this device.
 * on a single monitor system this is (0,0) - (SM_CXSCREEN,SM_CYSCREEN)
 */
BOOL DD_GetDeviceRect(LPDDRAWI_DIRECTDRAW_GBL pdrv, RECT *prc)
{
    //
    // this is a non-DISPLAY device for compatibility with DDRAW 3.x
    // we should use the size of the primary display.
    //
    if (!(pdrv->dwFlags & DDRAWI_DISPLAYDRV))
    {
        DPF( 4, "DD_GetDeviceRect: not a display driver, using screen rect.");
        SetRect(prc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
        return TRUE;
    }

    if (_stricmp(pdrv->cDriverName, "DISPLAY") == 0)
    {
        SetRect(prc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
    }
    else
    {
        #ifdef WIN95
            DEVMODE dm;
            ZeroMemory(&dm, sizeof(dm));
            dm.dmSize = sizeof(dm);

            EnumDisplaySettings(pdrv->cDriverName, ENUM_CURRENT_SETTINGS, &dm);

            //
            // the position of the device is in the dmPosition field
            //
            CopyMemory(prc, &dm.dmOrientation, sizeof(RECT));

            if (IsRectEmpty(prc))
            {
                //
                // this device is not attached to the desktop
                // what should we do?
                //
                //      make the window the size of the primary?
                //
                //      put the window out in space?
                //
                //      dont move the window?
                //
                DPF( 4, "DD_GetDeviceRect: device is not attached to desktop.");

                // put window on primary
                SetRect(prc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));

                // put window off in space.
                //SetRect(prc,10000,10000,10000+dm.dmPelsWidth,10000+dm.dmPelsHeight);

                // dont move window
                // return FALSE
            }
        #else
            if( GetNTDeviceRect( pdrv->cDriverName, prc ) != DD_OK )
            {
                DPF( 4, "DD_GetDeviceRect: device is not attached to desktop.");
                SetRect(prc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
            }
        #endif
    }

    DPF( 5, "DD_GetDeviceRect: %s [%d %d %d %d]",pdrv->cDriverName, prc->left, prc->top, prc->right, prc->bottom);
    return TRUE;
}


#ifdef GDIDDPAL
/*
 * getPalette
 *
 * Get a pointer to a palette object.
 * Takes a lock on the driver object and the palette object.
 */
LPDDRAWI_DDRAWPALETTE_LCL getPalette( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDRAWPALETTE_LCL   ppal_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;

    if( pdrv_lcl->lpGbl->dwFlags & DDRAWI_HASGDIPALETTE )
    {
        psurf_lcl = pdrv_lcl->lpPrimary;
        if( psurf_lcl != NULL )
        {
            ppal_lcl = psurf_lcl->lpDDPalette;
            return ppal_lcl;
        }
    }

    return NULL;

} /* getPalette */
#endif

static LONG     bHelperStarting=0;
static BOOL     bStartHelper=0;
static BYTE     sys_key=0;
static DWORD    sys_state=0;


/*
 * IsTaskWindow
 */
BOOL IsTaskWindow(HWND hwnd)
{
    DWORD dwStyleEx = GetWindowLong(hwnd, GWL_EXSTYLE);

    // Following windows do not qualify to be shown in task list:
    //   Switch  Window, Hidden windows (unless they are the active
    //   window), Disabled windows, Kanji Conv windows.
    //   Ignore windows that are actually child windows.
    return(((dwStyleEx & WS_EX_APPWINDOW) ||
           !(dwStyleEx & WS_EX_TOOLWINDOW)) &&
            IsWindowVisible(hwnd) &&
            IsWindowEnabled(hwnd) &&
            GetParent(hwnd) == NULL);
}

/*
 * CountTaskWindows
 */
int CountTaskWindows()
{
    HWND hwnd;
    int n;

    for (n=0,
        hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
        hwnd!= NULL;
        hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        if (IsTaskWindow(hwnd))
            n++;
    }

    return n;
}

/*
 * ClipTheCursor
 *
 * A DINPUT app keeps track of movement based on the delta from the last
 * movement.  On a multi-mon system, the delta can be larger than the
 * app's window, but a fullscreen non-multimon aware app might count on
 * windows clipping the mouse to the primary so it could totally break
 * (e.g. Dungeon Keeper).  This hack will clip/unclip the cursor movement
 * to the monitor if the app is not multi-mon aware.
 */
void ClipTheCursor( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPRECT lpRect )
{
    /*
     * Only unclip if it was previously clipped
     */
    if( lpRect == NULL )
    {
        if( pdrv_lcl->dwLocalFlags & DDRAWILCL_CURSORCLIPPED )
        {
            pdrv_lcl->dwLocalFlags &= ~DDRAWILCL_CURSORCLIPPED;
            ClipCursor( NULL );
        }
    }

    /*
     * Only clip them if they are not multi-mon aware and they own
     * exclusive mode
     */
    else if( !( pdrv_lcl->dwLocalFlags & DDRAWILCL_EXPLICITMONITOR ) &&
        ( pdrv_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE ) &&
        ( pdrv_lcl->dwLocalFlags & DDRAWILCL_ACTIVEYES ) )
    {
        /*
         * Hack to allow user to use debugger
         */
        #ifdef DEBUG
            if( !( pdrv_lcl->dwLocalFlags & DDRAWILCL_DISABLEINACTIVATE ) )
            {
        #endif
                pdrv_lcl->dwLocalFlags |= DDRAWILCL_CURSORCLIPPED;
                ClipCursor( lpRect );
        #ifdef DEBUG
            }
        #endif
    }
}

//
// make the passed window fullscreen and topmost and set a timer
// to make the window topmost again, what a hack.
//
void MakeFullscreen(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, HWND hwnd)
{
    RECT rc;

    if (DD_GetDeviceRect(pdrv_lcl->lpGbl, &rc))
    {
        SetWindowPos(hwnd, NULL, rc.left, rc.top,
            rc.right - rc.left,rc.bottom - rc.top,
            SWP_NOZORDER | SWP_NOACTIVATE);

        ClipTheCursor( pdrv_lcl, &rc );
    }

    if (GetForegroundWindow() == (HWND)pdrv_lcl->hFocusWnd)
    {
        // If the exclusive mode window is not visible, make it so.
        if(!IsWindowVisible( hwnd ) )
        {
            ShowWindow(hwnd, SW_SHOW);
        }

        SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        // If the exclusive mode window is maximized, restore it.
        if( IsZoomed( hwnd ) )
        {
            ShowWindow(hwnd, SW_RESTORE);
        }
    }
    if( giTopmostCnt < MAX_TIMER_HWNDS )
    {
        ghwndTopmostList[giTopmostCnt++] = hwnd;
    }
    SetTimer( (HWND)pdrv_lcl->hFocusWnd, TOPMOST_ID, TOPMOST_TIMEOUT, NULL);
}

//
// Same as MakeFullscreen only it does it for every DirectDraw object that
// thinks it has hooked the window
//
void MakeAllFullscreen(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, HWND hwnd)
{
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;

    /*
     * We need to maintain old behavior in the non-multimon case
     */
    giTopmostCnt = 0;
    MakeFullscreen( pdrv_lcl, (HWND) pdrv_lcl->hWnd );

    /*
     * Don't do this on multimon when de-activating.
     * Hack to minimize singlemon code impact - this function gets called
     * by the WM_DISPLAYCHANGE message, which gets called on a
     * RestoreDisplayMode when leaving exclusive mode on a deactivate.
     * Consider not calling MakeAllFullScreen when DDRAWILCL_ACTIVENO is set
     */
    if (!IsMultiMonitor() ||
        !(pdrv_lcl->dwLocalFlags & DDRAWILCL_ACTIVENO))
    {
        /*
         * Don't enter normal critical section because this is called
         * during WM_DISPLAYCHANGE which could cause problems.
         */
        ENTER_DRIVERLISTCSECT();
        this_lcl = lpDriverLocalList;
        while( this_lcl != NULL )
        {
            if( ( this_lcl != pdrv_lcl ) &&
                ( this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE ) &&
                ( this_lcl->hFocusWnd == (ULONG_PTR) hwnd ) &&
                ( this_lcl->dwLocalFlags & DDRAWILCL_HOOKEDHWND ) &&
                ( this_lcl->hWnd != pdrv_lcl->hWnd ) )
            {
                MakeFullscreen( this_lcl, (HWND)this_lcl->hWnd );
            }
            this_lcl = this_lcl->lpLink;
        }
        LEAVE_DRIVERLISTCSECT();
    }
}

void InternalSetForegroundWindow(HWND hWnd)
{
    DWORD dwTimeout;
    SystemParametersInfo( SPI_GETFOREGROUNDLOCKTIMEOUT, 0, (LPVOID) &dwTimeout, 0 );
    SystemParametersInfo( SPI_SETFOREGROUNDLOCKTIMEOUT, 0, NULL, 0 );
#ifdef WINNT
    //
    // This works around a focus bug. If an app does createwindow,destroywindow,createwindow,
    // then it may not get focus on the second create because some other window stole it in
    // the meantime.
    //
    mouse_event(MOUSEEVENTF_WHEEL,0,0,0,0);
#endif
    SetForegroundWindow(hWnd);
    SystemParametersInfo( SPI_SETFOREGROUNDLOCKTIMEOUT, 0, (LPVOID) ULongToPtr(dwTimeout), 0 );
}
/*
 * handleActivateApp
 */
void handleActivateApp(
        LPDDRAWI_DIRECTDRAW_LCL this_lcl,
        LPDDWINDOWINFO pwinfo,
        BOOL is_active,
        BOOL bFirst )
{
    LPDDRAWI_DDRAWPALETTE_INT   ppal_int;
    LPDDRAWI_DDRAWPALETTE_LCL   ppal_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf;
    DWORD                       pid;
    HRESULT                     ddrval;
    BOOL                        has_excl;
    BOOL                        excl_exists;
    BOOL                        bMinimize = TRUE;

    this = this_lcl->lpGbl;
    pid = GetCurrentProcessId();

    psurf_int = this_lcl->lpPrimary;
    if( psurf_int != NULL )
    {
        psurf_lcl = psurf_int->lpLcl;
        psurf = psurf_lcl->lpGbl;
        ppal_int = psurf_lcl->lpDDPalette;
        if( NULL != ppal_int )
        {
            ppal_lcl = ppal_int->lpLcl;
        }
        else
        {
            ppal_lcl = NULL;
        }
    }
    else
    {
        psurf_lcl = NULL;
        ppal_lcl = NULL;
    }

    /*
     * An app could take exclusive mode just as another app is being activated by alt-tab.
     * Should we do anything about this remote chance?
     */

    CheckExclusiveMode(this_lcl, &excl_exists, &has_excl, TRUE, NULL, FALSE);

    /*
     * stuff to do before the mode set if deactivating
     */
    if( !is_active )
    {
        /*
         * flip back to GDI if deactivating
         */
        if( (psurf_lcl != NULL) && has_excl )
        {
            FlipToGDISurface( this_lcl, psurf_int); //, this->fpPrimaryOrig );
        }

        if( has_excl )
        {
            /*
             * Exclusive mode app losing or gaining focus.
             * If gaining focus, invalidate all non-exclusive mode primary
             * surfaces.  If losing focus, invalidate the exclusive-mode
             * primary surface so that non-exclusive apps can restore
             * their primaries.
             *
             * NOTE: This call MUST come after FlipToGDISurface, or
             * else FlipToGDISurface will fail. craige 7/4/95
             *
             * NOTE: if we are coming in or out of exclusive mode,
             * we need to invalidate all surfaces so that resources are
             * available. craige 7/9/94
             *
             */
            InvalidateAllSurfaces( this, (HANDLE) this_lcl->hDDVxd, TRUE );
        }
    }
    /*
     * stuff to do before mode set if activating
     */
    else
    {
        /*
         * restore exclusive mode. Here we don't release the ref we took on the exclusive mode mutex,
         * since we want to keep the exclusive mode mutex.
         */
        if( this_lcl->dwLocalFlags & DDRAWILCL_ISFULLSCREEN )
        {
            this->dwFlags |= DDRAWI_FULLSCREEN;
        }
        StartExclusiveMode( this_lcl, pwinfo->DDInfo.dwDDFlags, pid );
        has_excl = TRUE;
    }

    /*
     * NOTE: We used to invalidate here but that was strange as it would
     * mean doing the invalidate twice as StartExclusiveMode() always
     * invalidates. So now we only explicitly invalidate if an exlcusive
     * mode app is being deactivated. StartExclusiveMode() handles the
     * other case.
     */

    /*
     * restore hwnd if we are about to be activated
     */
    if ( (pwinfo->DDInfo.dwDDFlags & DDSCL_FULLSCREEN) &&
        !(pwinfo->DDInfo.dwDDFlags & DDSCL_NOWINDOWCHANGES) &&
        IsWindowVisible(pwinfo->hWnd))
    {
        if (is_active)
        {
            pwinfo->dwFlags |= WININFO_SELFSIZE;

            #ifdef USESHOWWINDOW
                ShowWindow(pwinfo->hWnd, SW_SHOWNOACTIVATE);
            #else
            {
                RECT rc;

                if (DD_GetDeviceRect(this, &rc))
                {
                    SetWindowPos(pwinfo->hWnd, NULL,rc.left, rc.top,
                        rc.right  - rc.left,rc.bottom - rc.top,
                        SWP_NOZORDER | SWP_NOACTIVATE);
                }
            }
            #endif

            pwinfo->dwFlags &= ~WININFO_SELFSIZE;
        }
    }

    /*
     * restore the mode
     */
    if( !is_active )
    {
        if( (!excl_exists) || has_excl )
        {
            DPF( 4, "INACTIVE: %08lx: Restoring original mode (%ld)", GetCurrentProcessId(), this->dwModeIndexOrig );
            if( RestoreDisplayMode( this_lcl, TRUE ) == DDERR_UNSUPPORTED )
            {
                #ifdef WINNT
                    /*
                     * If RestoreDisplayMode failed, we are probably on a different desktop.  In this case,
                     * we should not minimize the window or else things won't work right when we switch
                     * back to the original desktop.
                     */
                    HDESK hDesktop;
                    static BYTE szName1[256];
                    static BYTE szName2[256];
                    DWORD dwTemp;

                    // Get the name of the current desktop
                    hDesktop = OpenInputDesktop( 0, FALSE, DESKTOP_READOBJECTS );
                    GetUserObjectInformation( hDesktop, UOI_NAME, szName1, sizeof( szName1 ), &dwTemp );
                    CloseDesktop( hDesktop );

                    // Get the name of the apps' desktop
                    hDesktop = GetThreadDesktop( GetCurrentThreadId() );
                    GetUserObjectInformation( hDesktop, UOI_NAME, szName2, sizeof( szName2 ), &dwTemp );
                    if( lstrcmp( szName1, szName2 ) )
                    {
                        bMinimize = FALSE;
                    }
                #endif
            }
        }
    }
    else
    {
        DPF( 4, "ACTIVE: %08lx: Setting app's preferred mode (%ld)", GetCurrentProcessId(), this_lcl->dwPreferredMode );
        SetDisplayMode( this_lcl, this_lcl->dwPreferredMode, TRUE, TRUE );
    }

    /*
     * stuff to do after the mode set if activating
     */
    if( is_active )
    {
        /*
         * restore the palette
         */
        if( ppal_lcl != NULL )
        {
            ddrval = SetPaletteAlways( psurf_int, (LPDIRECTDRAWPALETTE) ppal_int );
            DPF( 5, "SetPalette, ddrval = %08lx (%ld)", ddrval, LOWORD( ddrval ) );
        }
    }
    /*
     * stuff to do after the mode set if deactivating
     */
    else
    {
        if( has_excl )
        {
            /*
             * ...and this will finally release the exclusive mode mutex
             */
            DoneExclusiveMode( this_lcl );
        }
    }

    /*
     * minimize window if deactivating
     */
    if ( (pwinfo->DDInfo.dwDDFlags & DDSCL_FULLSCREEN) &&
        !(pwinfo->DDInfo.dwDDFlags & DDSCL_NOWINDOWCHANGES) &&
        IsWindowVisible(pwinfo->hWnd))
    {
        pwinfo->dwFlags |= WININFO_SELFSIZE;

        if( is_active )
        {
            MakeFullscreen(this_lcl, (HWND)this_lcl->hWnd);
        }
        else if( bMinimize )
        {
            // get the last active popup
            this_lcl->hWndPopup = (ULONG_PTR) GetLastActivePopup(pwinfo->hWnd);
            if ((HWND) this_lcl->hWndPopup == pwinfo->hWnd)
            {
                this_lcl->hWndPopup = 0;
            }

            #ifdef USESHOWWINDOW
                ShowWindow(pwinfo->hWnd, SW_SHOWMINNOACTIVE);
            #else
                SetWindowPos(pwinfo->hWnd, NULL, 0, 0, 0, 0,
                    SWP_NOZORDER | SWP_NOACTIVATE);
            #endif
        }

        pwinfo->dwFlags &= ~WININFO_SELFSIZE;
    }

    /*
     * We only want to do the following stuff once
     */
    if( !bFirst )
    {
        return;
    }

#ifdef WIN95
    /*
     * if we got deactivated because of a syskey
     * then send that key to user now.
     * This is unnecessary for NT.
     *
     * NOTE because we disabled all the task-switching
     * hot keys the system did not see the hot key that
     * caused us to deactivate.
     *
     * if there is only one window to activate, activate the
     * desktop (shell window)
     */
    if( has_excl && sys_key && !is_active )
    {
        if (CountTaskWindows() <= 1)
        {
            DPF( 4, "activating the desktop" );

            /*
             * Calling SetforegroundWindow will cause WM_ACTIVATEAPP messages
             * to be sent, but if we get here, we are already processing a
             * WM_ACTIVATEAPP message and are holding the critical section.
             * If we don't LEAVE_DDRAW now, this will cause us to call the
             * apps WindProc w/ the critical section held, which results in
             * a deadlock situation for at least one app (Ashes to Ashes).
             * Leaving and re-entering does mean that we can't rely on the
             * DDraw state to be the same, but we are done using the
             * structures for now anyway.
             * smac 3/20/97
             */
            LEAVE_DDRAW();
            InternalSetForegroundWindow(GetWindow(pwinfo->hWnd, GW_HWNDLAST));
            ENTER_DDRAW();

            // we just activated the desktop, so we *dont* want
            // to force a ALT+ESC or ALT+TAB, we do want to force
            // a CTRL+ESC.

            if (sys_key != VK_ESCAPE || (sys_state & 0x20000000))
                sys_key = 0;
        }

        if (sys_key)
        {
            BYTE state_key;
            BOOL state_key_down;

            DPF( 4, "sending sys key to USER key=%04x state=%08x",sys_key,sys_state);

            if (sys_state & 0x20000000)
                state_key = VK_MENU;
            else
                state_key = VK_CONTROL;

            state_key_down = GetAsyncKeyState(state_key) < 0;

            if (!state_key_down)
                keybd_event(state_key, 0, 0, 0);

            keybd_event(sys_key, 0, 0, 0);
            keybd_event(sys_key, 0, KEYEVENTF_KEYUP, 0);

            if (!state_key_down)
                keybd_event(state_key, 0, KEYEVENTF_KEYUP, 0);
        }
    }
#endif

    sys_key = 0;

} /* handleActivateApp */

static DWORD    dwTime2=0;
/*
 * tryHotKey
 */
static void tryHotKey( WORD flags )
{
    static int          iState=0;
    static DWORD        dwTime=0;
    #define TOGGLE1     0xe02a
    #define TOGGLE2     0xe036

    if( !bHelperStarting )
    {
        if( iState == 0 )
        {
            if( flags == TOGGLE1 )
            {
                dwTime = GetTickCount();
                iState++;
            }
        }
        else
        {
            if( iState == 5 )
            {
                iState = 0;
                if( flags == TOGGLE2 )
                {
                    if( (GetTickCount() - dwTime) < 2500 )
                    {
                        if( InterlockedExchange( &bHelperStarting, TRUE ) )
                        {
                            return;
                        }
                        dwTime2 = GetTickCount();
                        DPF( 5, "********** GET READY FOR A SURPRISE **********" );
                        return;
                    }
                }
            }
            else
            {
                if( !(iState & 1) )
                {
                    iState = (flags == TOGGLE1) ? iState+1 : 0;
                }
                else
                {
                    iState = (flags == TOGGLE2) ? iState+1 : 0;
                }
            }
        }
    }
    else
    {
        if( !bStartHelper )
        {
            bHelperStarting = FALSE;
            dwTime2 = 0;
        }
    }
    return;

} /* tryHotKey */

static LPDDWINDOWINFO GetDDrawWindowInfo( HWND hwnd )
{
    LPDDWINDOWINFO    lpwi=lpWindowInfo;

    while( NULL != lpwi )
    {
        if( lpwi->hWnd == hwnd )
        {
            return lpwi;
        }
        lpwi = lpwi->lpLink;
    }
    return NULL;
}

static void delete_wininfo( LPDDWINDOWINFO curr )
{
    LPDDWINDOWINFO    prev;

    if( NULL == curr )
        return;

    // curr is at the head of the list, delete it and return
    if( curr == lpWindowInfo )
    {
        lpWindowInfo = curr->lpLink;
        MemFree( curr );
        return;
    }
    if( NULL == lpWindowInfo )
        return;

    // find curr in the list, delete it and return
    for(prev=lpWindowInfo; NULL != prev->lpLink; prev = prev->lpLink)
    {
        if( curr == prev->lpLink )
        {
            break;
        }
    }
    if( NULL == prev->lpLink )
    {
        // couldn't find it
        return;
    }

    prev->lpLink = curr->lpLink;
    MemFree( curr );
}

/*
 * Copy the contents of the given surface to the clipboard
 */
static HRESULT copySurfaceToClipboard( HWND hwnd,
                                       LPDDRAWI_DDRAWSURFACE_INT lpSurface,
                                       LPDDRAWI_DDRAWPALETTE_INT lpOverridePalette )
{
    HRESULT                   hres;
    LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl;
    LPDDRAWI_DDRAWSURFACE_GBL lpSurfGbl;
    LPDDPIXELFORMAT           lpddpf;
    DDSURFACEDESC             ddsd;
    DWORD                     dwBitDepth;
    DWORD                     dwRBitMask;
    DWORD                     dwGBitMask;
    DWORD                     dwBBitMask;
    DWORD                     dwSize;
    DWORD                     dwDIBPitch;
    HANDLE                    hDIB;
    BITMAPINFO*               lpDIB;
    HDC                       hdc;
    LPDDRAWI_DDRAWPALETTE_INT lpPalette;
    DWORD                     dwCompression;
    DWORD                     dwColorTableSize;
    RGBQUAD                   rgbColorTable[256];
    LPPALETTEENTRY            lppeColorTable;
    PALETTEENTRY              peColorTable[256];
    LPBYTE                    lpBits;
    int                       i;
    DWORD                     y;
    LPBYTE                    lpDstScan;
    LPBYTE                    lpSrcScan;

    DDASSERT( NULL != lpSurface );
    lpSurfLcl = lpSurface->lpLcl;
    DDASSERT( NULL != lpSurfLcl );
    lpSurfGbl = lpSurfLcl->lpGbl;
    DDASSERT( NULL != lpSurfGbl );

    if( lpSurfLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
        lpddpf = &lpSurfGbl->ddpfSurface;
    else
        lpddpf = &lpSurfLcl->lpSurfMore->lpDD_lcl->lpGbl->vmiData.ddpfDisplay;

    dwBitDepth = lpddpf->dwRGBBitCount;
    dwRBitMask = lpddpf->dwRBitMask;
    dwGBitMask = lpddpf->dwGBitMask;
    dwBBitMask = lpddpf->dwBBitMask;

    switch (dwBitDepth)
    {
        case 8UL:
            if(! ( lpddpf->dwFlags & DDPF_PALETTEINDEXED8 ) )
            {
                DPF( 0, "Non-palettized 8-bit surfaces are not supported" );
                return DDERR_INVALIDPIXELFORMAT;
            }
            dwColorTableSize = 256UL;
            if( NULL != lpOverridePalette )
                lpPalette = lpOverridePalette;
            else
                lpPalette = lpSurfLcl->lpDDPalette;
            if( NULL == lpPalette )
            {
                hdc = (HDC) lpSurfLcl->lpSurfMore->lpDD_lcl->hDC;
                if( NULL == hdc )
                {
                    DPF( 2, "No palette attached. Non-display driver. Using gray scale." );
                    for( i = 0; i < 256; i++ )
                    {
                        peColorTable[i].peRed    = (BYTE)i;
                        peColorTable[i].peGreen  = (BYTE)i;
                        peColorTable[i].peBlue   = (BYTE)i;
                        peColorTable[i].peFlags  = 0;
                    }
                }
                else
                {
                    DPF( 2, "No palette attached. Using system palette entries" );
                    GetSystemPaletteEntries( hdc, 0, 256, peColorTable );
                }
                lppeColorTable = peColorTable;
            }
            else
            {
                DDASSERT( NULL != lpPalette->lpLcl );
                DDASSERT( NULL != lpPalette->lpLcl->lpGbl );
                if( !( lpPalette->lpLcl->lpGbl->dwFlags & DDRAWIPAL_256 ) )
                {
                    DPF( 0, "Palette is not an 8-bit palette" );
                    return DDERR_INVALIDPIXELFORMAT;
                }
                lppeColorTable = lpPalette->lpLcl->lpGbl->lpColorTable;
                DDASSERT( NULL != lppeColorTable );
            }
            for (i = 0; i < 256; i++)
            {
                rgbColorTable[i].rgbBlue     = lppeColorTable->peBlue;
                rgbColorTable[i].rgbGreen    = lppeColorTable->peGreen;
                rgbColorTable[i].rgbRed      = lppeColorTable->peRed;
                rgbColorTable[i].rgbReserved = 0;
                lppeColorTable++;
            }
            dwCompression = BI_RGB;
            break;
        case 16UL:
            if( ( 0x7C00UL == dwRBitMask ) &&
                ( 0x03E0UL == dwGBitMask ) &&
                ( 0x001FUL == dwBBitMask ) )
            {
                dwColorTableSize = 0UL;
                dwCompression = BI_RGB;
            }
            else if( ( 0xF800UL == dwRBitMask ) &&
                     ( 0x07E0UL == dwGBitMask ) &&
                     ( 0x001FUL == dwBBitMask ) )
            {
                dwColorTableSize = 3UL;
                rgbColorTable[0] = *( (RGBQUAD*) &dwRBitMask );
                rgbColorTable[1] = *( (RGBQUAD*) &dwGBitMask );
                rgbColorTable[2] = *( (RGBQUAD*) &dwBBitMask );
                dwCompression = BI_BITFIELDS;
            }
            else
            {
                DPF( 0, "Unsupported 16-bit pixel format" );
                return DDERR_INVALIDPIXELFORMAT;
            }
            break;
        case 24UL:
            if( ( 0x000000FFUL == dwBBitMask ) &&
                ( 0x0000FF00UL == dwGBitMask ) &&
                ( 0x00FF0000UL == dwRBitMask ) )
            {
                dwColorTableSize = 0UL;
                dwCompression = BI_RGB;
            }
            else
            {
                DPF( 0, "Unsupported 24-bit pixel format" );
                return DDERR_INVALIDPIXELFORMAT;
            }
            break;
        case 32UL:
            if( ( 0x000000FFUL == dwRBitMask ) &&
                ( 0x0000FF00UL == dwGBitMask ) &&
                ( 0x00FF0000UL == dwBBitMask ) )
            {
                dwColorTableSize = 0UL;
                dwCompression = BI_RGB;
            }
            else if( ( 0x00FF0000UL == dwRBitMask ) &&
                     ( 0x0000FF00UL == dwGBitMask ) &&
                     ( 0x000000FFUL == dwBBitMask ) )
            {
                dwColorTableSize = 3UL;
                rgbColorTable[0] = *( (RGBQUAD*) &dwRBitMask );
                rgbColorTable[1] = *( (RGBQUAD*) &dwGBitMask );
                rgbColorTable[2] = *( (RGBQUAD*) &dwBBitMask );
                dwCompression = BI_BITFIELDS;
            }
            else
            {
                DPF( 0, "Unsupported 32-bit pixel format" );
                return DDERR_INVALIDPIXELFORMAT;
            }
            break;
        default:
            DPF( 0, "Unsupported pixel depth" );
            return DDERR_INVALIDPIXELFORMAT;
    };

    dwDIBPitch = ( ( ( ( lpSurfGbl->wWidth * dwBitDepth ) + 31 ) >> 3 ) & ~0x03UL );
    dwSize = sizeof( BITMAPINFOHEADER ) +
                 ( dwColorTableSize * sizeof( RGBQUAD ) ) +
                 ( lpSurfGbl->wHeight * dwDIBPitch );

    hDIB = GlobalAlloc( GHND | GMEM_DDESHARE, dwSize );
    if( 0UL == hDIB )
    {
        DPF( 0, "Unsufficient memory for DIB" );
        return DDERR_OUTOFMEMORY;
    }
    lpDIB = (BITMAPINFO*) GlobalLock( hDIB );
    if( NULL == lpDIB )
    {
        DPF( 0, "Unsufficient memory for DIB" );
        GlobalFree( hDIB );
        return DDERR_OUTOFMEMORY;
    }

    lpBits = ( (LPBYTE) lpDIB ) + sizeof( BITMAPINFOHEADER ) + ( dwColorTableSize * sizeof( RGBQUAD ) );

    lpDIB->bmiHeader.biSize          = sizeof( BITMAPINFOHEADER );
    lpDIB->bmiHeader.biWidth         = (LONG) lpSurfGbl->wWidth;
    lpDIB->bmiHeader.biHeight        = (LONG) lpSurfGbl->wHeight;
    lpDIB->bmiHeader.biPlanes        = 1;
    lpDIB->bmiHeader.biBitCount      = (WORD) dwBitDepth;
    lpDIB->bmiHeader.biCompression   = dwCompression;
    lpDIB->bmiHeader.biXPelsPerMeter = 1L;
    lpDIB->bmiHeader.biYPelsPerMeter = 1L;
    if( 8UL == dwBitDepth )
    {
        lpDIB->bmiHeader.biClrUsed      = 256UL;
        lpDIB->bmiHeader.biClrImportant = 256UL;
    }
    else
    {
        lpDIB->bmiHeader.biClrUsed      = 0UL;
        lpDIB->bmiHeader.biClrImportant = 0UL;
    }
    if( 0UL != dwColorTableSize )
        CopyMemory( &lpDIB->bmiColors[0], rgbColorTable, dwColorTableSize * sizeof( RGBQUAD ) );

    ZeroMemory( &ddsd, sizeof( ddsd ) );
    ddsd.dwSize = sizeof( ddsd );
    hres = DD_Surface_Lock( (LPDIRECTDRAWSURFACE) lpSurface,
                            NULL,
                            &ddsd,
                            DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT,
                            0UL );
    if( FAILED( hres ) )
    {
        DPF( 0, "Could not lock the surface" );
        GlobalUnlock( hDIB );
        GlobalFree( hDIB );
        return hres;
    }

    for( y = 0; y < ddsd.dwHeight; y++ )
    {
        lpDstScan = lpBits + ( y * dwDIBPitch );
        lpSrcScan = ( (LPBYTE) ddsd.lpSurface ) + ( ( ( ddsd.dwHeight - 1UL ) - y ) * ddsd.lPitch );
        CopyMemory( lpDstScan, lpSrcScan, dwDIBPitch );
    }

    hres = DD_Surface_Unlock( (LPDIRECTDRAWSURFACE) lpSurface, NULL );
    if( FAILED( hres ) )
    {
        DPF( 0, "Could not unlock the surface" );
        GlobalUnlock( hDIB );
        GlobalFree( hDIB );
        return hres;
    }

    GlobalUnlock( hDIB );

    if( OpenClipboard( hwnd ) )
    {
        EmptyClipboard();
        if( NULL == SetClipboardData( CF_DIB, hDIB ) )
        {
            DPF( 0, "Could not copy the bitmap to the clipboard" );
            return DDERR_GENERIC;
        }
        CloseClipboard();
    }
    else
    {
        DPF( 0, "Clipboard open by another application" );
        DDERR_GENERIC;
    }

    return DD_OK;
} /* copySurfaceToClipboard */

/*
 * HandleTimer
 *
 * This function exists because it requires some local variables and if
 * we always push them on the stack each time the WindowProc is called, we
 * see cases where the stack crashes.  By putting them in a sperate function,
 * they only get pushed when a timer message occurs.
 */
void HandleTimer( LPDDWINDOWINFO curr )
{
    HWND hwndTopmostList[MAX_TIMER_HWNDS];
    BOOL bFound;
    int iCnt;
    int i;
    int j;

    DPF(4, "Bringing window to top");

    /*
     * Save the hwnds locally since the list can change
     * out from under us.
     */
    iCnt = 0;
    while( iCnt < giTopmostCnt )
    {
        hwndTopmostList[iCnt] = ghwndTopmostList[iCnt++];
    }
    giTopmostCnt = 0;

    for( i = 0; i < iCnt; i++ )
    {
        /*
         * There may be duplicates in the list, so make sure
         * to call SetWindowPos only once per hwnd.
         */
        bFound = FALSE;
        for( j = 0; (j < i) && !bFound; j++ )
        {
            if( hwndTopmostList[i] == hwndTopmostList[j] )
            {
                bFound = TRUE;
            }
        }
        if( !bFound )
        {
            curr->dwFlags |= WININFO_SELFSIZE;
            SetWindowPos( hwndTopmostList[i], HWND_TOPMOST,
                0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
            curr->dwFlags &= ~WININFO_SELFSIZE;
        }
    }
}

/*
 * This function exists for the same reason as HandleTimer
 */

void CopyPrimaryToClipBoard(HWND hWnd, LPDDWINDOWINFO curr)
{
    LPDDRAWI_DIRECTDRAW_GBL   this;
    LPDDRAWI_DIRECTDRAW_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT lpPrimary;
    ENTER_DDRAW();

    this_lcl = curr->DDInfo.lpDD_lcl;
    DDASSERT( NULL != this_lcl );
    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );
    lpPrimary = this_lcl->lpPrimary;
    if( NULL != lpPrimary)
    {
        if( this->dwFlags & DDRAWI_MODEX )
        {
            LPDIRECTDRAWSURFACE       lpSurface;
            LPDIRECTDRAWSURFACE       lpBackBuffer;
            LPDDRAWI_DDRAWSURFACE_INT lpBackBufferInt;
            LPDDRAWI_DDRAWPALETTE_INT lpPalette;
            DDSCAPS                   ddscaps;
            HRESULT                   hres;

            DPF( 4, "Copying ModeX backbuffer to the clipboard" );

            lpSurface = (LPDIRECTDRAWSURFACE) this_lcl->lpPrimary;
            ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
            hres = lpSurface->lpVtbl->GetAttachedSurface( lpSurface, &ddscaps, &lpBackBuffer );
            if( !FAILED( hres ) )
            {
                DDASSERT( NULL != lpBackBuffer );

                lpBackBufferInt = (LPDDRAWI_DDRAWSURFACE_INT) lpBackBuffer;

                if( NULL == lpBackBufferInt->lpLcl->lpDDPalette )
                {
                    DPF( 2, "Using ModeX primary palette for PRINTSCREEN" );
                    DDASSERT( NULL != lpPrimary->lpLcl );
                    lpPalette = lpPrimary->lpLcl->lpDDPalette;
                }
                else
                {
                    DPF( 2, "Using ModeX backbuffer palette for PRINTSCREEN" );
                    DDASSERT( NULL != lpBackBufferInt->lpLcl );
                    lpPalette = lpBackBufferInt->lpLcl->lpDDPalette;
                }

                copySurfaceToClipboard( hWnd, lpBackBufferInt, lpPalette );
                lpBackBuffer->lpVtbl->Release( lpBackBuffer );
            }
            else
            {
                DPF( 0, "Could not PRINTSCREEN - ModeX primary has no attached backbuffer" );
            }
        }
        else
        {
            DPF( 4, "Copying linear primary surface to the clipboard" );
            copySurfaceToClipboard( hWnd, lpPrimary, NULL );
        }
    }
    else
    {
        DPF( 0, "Could not PRINTSCREEN - no primary" );
    }

    LEAVE_DDRAW();
}

/*
 * WindowProc
 */
LRESULT WINAPI WindowProc(
                HWND hWnd,
                UINT uMsg,
                WPARAM wParam,
                LPARAM lParam )
{
    #ifdef GDIDDPAL
        LPDDRAWI_DDRAWPALETTE_LCL       ppal_lcl;
    #endif
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    BOOL                        is_active;
    LPDDWINDOWINFO              curr;
    WNDPROC                     proc;
    BOOL                        get_away;
    LRESULT                     rc;
    BOOL                        is_hot;
    BOOL                        is_excl;

    /*
     * find the hwnd
     */
    curr = GetDDrawWindowInfo(hWnd);
    if( curr == NULL || curr->dwSmag != WININFO_MAGIC )
    {
        DPF( 0, "FATAL ERROR! Window Proc Called for hWnd %08lx, but not in list!", hWnd );
        DEBUG_BREAK();
        return DefWindowProc( hWnd, uMsg, wParam, lParam );
    }

    /*
     * unhook at destroy (or if the WININFO_UNHOOK bit is set)
     */
    proc = curr->lpWndProc;

    if( uMsg == WM_NCDESTROY )
    {
        DPF (4, "*** WM_NCDESTROY unhooking window ***" );
        curr->dwFlags |= WININFO_UNHOOK;
    }

    if( curr->dwFlags & WININFO_UNHOOK )
    {
        DPF (4, "*** Unhooking window proc" );

        if (curr->dwFlags & WININFO_ZOMBIE)
        {
            DPF (4, "*** Freeing ZOMBIE WININFO ***" );
            delete_wininfo( curr );
        }

        KillTimer(hWnd,TOPMOST_ID);
        SetWindowLongPtr( hWnd, GWLP_WNDPROC, (INT_PTR) proc );

        rc = CallWindowProc( proc, hWnd, uMsg, wParam, lParam );
        return rc;
    }

    /*
     * Code to defer app activation of minimized app until it is restored.
     */
    switch( uMsg )
    {
    #ifdef WIN95
    case WM_POWERBROADCAST:
        if( (wParam == PBT_APMSUSPEND) || (wParam == PBT_APMSTANDBY) )
    #else
    //winnt doesn't know about standby vs suspend
    case WM_POWER:
        if( wParam == PWR_SUSPENDREQUEST)
    #endif
        {
            DPF( 4, "WM_POWERBROADCAST: deactivating application" );
            SendMessage( hWnd, WM_ACTIVATEAPP, 0, GetCurrentThreadId() );
        }
        break;
    case WM_SIZE:
        DPF( 4, "WM_SIZE hWnd=%X wp=%04X, lp=%08X", hWnd, wParam, lParam);

        if( !(curr->dwFlags & WININFO_INACTIVATEAPP)
            && ((wParam == SIZE_RESTORED) || (wParam == SIZE_MAXIMIZED))
            && !(curr->dwFlags & WININFO_SELFSIZE)
            && (GetForegroundWindow() == hWnd) )
        {
#ifdef WINNT
            //
            // Wouldncha know it, but NT's messaging order is HUGELY different when alt-tabbing
            // between two exclusive mode apps. The first WM_SIZE sent to the activating app is
            // sent BEFORE the deactivating app loses FSE. This WM_SIZE is totally necessary to
            // reactivate the activating app, but it has to wait until the app loses FSE.
            // So, we simply wait on the exclusive mode mutex. This seems to work!
            //
            {
                DWORD dwWaitResult;
                dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, INFINITE);
                switch (dwWaitResult)
                {
                case WAIT_OBJECT_0:
                case WAIT_ABANDONED:
                    ReleaseMutex( hExclusiveModeMutex );
                    break;
                case WAIT_TIMEOUT:
                default:
                    DDASSERT(!"Unexpected return value from WaitForSingleObject");
                }

            }
#endif
            DPF( 4, "WM_SIZE: Window restored, sending WM_ACTIVATEAPP" );
            PostMessage( hWnd, WM_ACTIVATEAPP, 1, GetCurrentThreadId() );
        }
        else
        {
            DPF( 4, "WM_SIZE: Window restored, NOT sending WM_ACTIVATEAPP" );
        }
        break;

    case WM_ACTIVATEAPP:
        if( IsIconic( hWnd ) && wParam )
        {
            DPF( 4, "WM_ACTIVATEAPP: Ignoring while minimized" );
            return 0;
        }
        else
        {
            curr->dwFlags |= WININFO_INACTIVATEAPP;
        }
        break;
    case WM_KEYUP:
        if( ( VK_SNAPSHOT == wParam ) && ( dwRegFlags & DDRAW_REGFLAGS_ENABLEPRINTSCRN ) )
        {
        CopyPrimaryToClipBoard(hWnd, curr);
        }
        break;
    }

    /*
     * direct sound need to be called?
     */
    if ( curr->dwFlags & WININFO_DSOUNDHOOKED )
    {
        if( curr->lpDSoundCallback != NULL )
        {
            curr->lpDSoundCallback( hWnd, uMsg, wParam, lParam );
        }
    }

    /*
     * is directdraw involved here?
     */
    if( !(curr->dwFlags & WININFO_DDRAWHOOKED) )
    {
        rc = CallWindowProc( proc, hWnd, uMsg, wParam, lParam );

        // clear the WININFO_INACTIVATEAPP bit, but make sure to make sure
        // we are still hooked!
        if (uMsg == WM_ACTIVATEAPP && (GetDDrawWindowInfo(hWnd) != NULL))
        {
            curr->dwFlags &= ~WININFO_INACTIVATEAPP;
        }
        return rc;
    }

#ifdef DEBUG
    if ( (curr->DDInfo.dwDDFlags & DDSCL_FULLSCREEN) &&
        !(curr->DDInfo.dwDDFlags & DDSCL_NOWINDOWCHANGES) &&
        !IsIconic(hWnd) )
    {
        if (GetForegroundWindow() == hWnd)
        {
            HWND hwndT;
            RECT rc,rcT;

            GetWindowRect(hWnd, &rc);

            for (hwndT = GetWindow(hWnd, GW_HWNDFIRST);
                hwndT && hwndT != hWnd;
                hwndT = GetWindow(hwndT, GW_HWNDNEXT))
            {
                if (IsWindowVisible(hwndT))
                {
                    GetWindowRect(hwndT, &rcT);
                    if (IntersectRect(&rcT, &rcT, &rc))
                    {
                        DPF(4, "Window %08x is on top of us!!", hwndT);
                    }
                }
            }
        }
    }
#endif

    /*
     * NOTE: we don't take the DLL csect here.   By not doing this, we can
     * up the performance here.   However, this means that the application
     * could have a separate thread kill exclusive mode while window
     * messages were being processed.   This could cause our death.
     * Is this OK?
     */

    this_lcl = curr->DDInfo.lpDD_lcl;
    switch( uMsg )
    {
    /*
     * WM_SYSKEYUP
     *
     * watch for system keys of app trying to switch away from us...
     *
     * we only need to do this on Win95 because we have disabled all
     * the task-switching hot keys.  on NT we will get switched
     * away from normaly by the system.
     */
//#ifdef WIN95
    case WM_SYSKEYUP:
        DPF( 4, "WM_SYSKEYUP: wParam=%08lx lParam=%08lx", wParam, lParam );
        get_away = FALSE;
        is_hot = FALSE;
        if( wParam == VK_TAB )
        {
            if( lParam & 0x20000000l )
            {
                if( curr->dwFlags & WININFO_IGNORENEXTALTTAB )
                {
                    DPF( 5, "AHHHHHHHHHHHH Ignoring AltTab" );
                }
                else
                {
                    get_away = TRUE;
                }
            }
        }
        else if( wParam == VK_ESCAPE )
        {
            get_away = TRUE;
        }
#ifdef WIN95
        else if( wParam == VK_SHIFT )
        {
            if( HIBYTE( HIWORD( lParam ) ) == 0xe0 )
            {
                tryHotKey( HIWORD( lParam ) );
            }
        }
#endif

        is_excl = ((this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE) != 0);

#ifdef WIN95
        if( get_away && dwTime2 != 0 )
        {
            if( GetTickCount() - dwTime2 < 2500 )
            {
                DPF( 4, "********** WANT TO SEE SOMETHING _REALLY_ SCARY? *************" );
                bStartHelper = TRUE;
                is_hot = TRUE;
            }
            else
            {
                bHelperStarting = FALSE;
                dwTime2 = 0;
            }
        }
        else
        {
            bHelperStarting = FALSE;
        }
#endif

        curr->dwFlags &= ~WININFO_IGNORENEXTALTTAB;

        if( (get_away && is_excl) || is_hot )
        {
            DPF( 4, "Hot key pressed, switching away from app" );
            if( is_hot && !is_excl )
            {
                PostMessage( hWnd, WM_USER+0x1234, 0xFFBADADD, 0xFFADDBAD );
            }
            else
            {
                sys_key = (BYTE)wParam;
                sys_state = (DWORD)lParam;
                PostMessage( hWnd, WM_ACTIVATEAPP, 0, GetCurrentThreadId() );
            }
        }
        break;
//#endif

    /*
     * WM_SYSCOMMAND
     *
     * watch for screen savers, and don't allow them!
     *
     */
    case WM_SYSCOMMAND:
        is_excl = ((this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE) != 0);
        if( is_excl )
        {
            switch( wParam )
            {
            case SC_SCREENSAVE:
                DPF( 3, "Ignoring screen saver!" );
                return 1;
#ifndef WINNT
            case SC_MONITORPOWER:
                /*
                 * Allow screen savers to power down but not apps.
                 * This is because windows doesn't see joystick events
                 * so will power down a game even though they have been
                 * using the joystick.
                 */
                if( this_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER )
                {
                    /*
                     * However, we don't want the screen saver to call the
                     * hardware because things can go wrong, so we will simply
                     * invalidate all of the surfaces and not allowed them
                     * to be restored until we are powered back up.
                     */
                    this_lcl->dwLocalFlags |= DDRAWILCL_POWEREDDOWN;
                    InvalidateAllSurfaces( this_lcl->lpGbl,
                        (HANDLE) this_lcl->hDDVxd, TRUE );
                }
                else
                {
                    DPF( 3, "Ignoring monitor power command!" );
                    return 1;
                }
                break;
#endif
            // allow window to be restored even if it has popup(s)
            case SC_RESTORE:
                if (this_lcl->hWndPopup)
                {
                    ShowWindow(hWnd, SW_RESTORE);
                }
                break;
            }
        }
        break;

    case WM_TIMER:
        if (wParam == TOPMOST_ID )
        {
            if ( GetForegroundWindow() == hWnd && !IsIconic(hWnd) )
            {
                HandleTimer(curr);
            }

            KillTimer(hWnd, wParam);
            return 0;
        }
        break;

#ifdef USESHOWWINDOW
    case WM_DISPLAYCHANGE:
        DPF( 4, "WM_DISPLAYCHANGE: %dx%dx%d", LOWORD(lParam), HIWORD(lParam), wParam );

        //
        //  WM_DISPLAYCHANGE is *sent* to the thread that called
        //  change display settings, we will most likely have the
        //  direct draw lock, make sure we set the WININFO_SELFSIZE
        //  bit while calling down the chain to prevent deadlock
        //
        if ( (DDSCL_DX8APP & curr->DDInfo.dwDDFlags) &&
            !(DDRAWI_FULLSCREEN & this_lcl->lpGbl->dwFlags ))
        {
            // this is caused by DoneExclusiveMode() to restore original desktop
            return 0L;   // don't send to app, it's caused by MakeFullScreen
        }
        curr->dwFlags |= WININFO_SELFSIZE;

        if ( (curr->DDInfo.dwDDFlags & DDSCL_FULLSCREEN) &&
            !(curr->DDInfo.dwDDFlags & DDSCL_NOWINDOWCHANGES) )
        {
            MakeAllFullscreen(this_lcl, hWnd);
        }

        rc = CallWindowProc( proc, hWnd, uMsg, wParam, lParam );

        // clear the WININFO_SELFSIZE bit, but make sure to make sure
        // we are still hooked!
        if (GetDDrawWindowInfo(hWnd) != NULL)
        {
            curr->dwFlags &= ~WININFO_SELFSIZE;
        }
        return rc;
#endif

    /*
     * WM_ACTIVATEAPP
     *
     * the application has been reactivated.   In this case, we need to
     * reset the mode
     *
     */
    case WM_ACTIVATEAPP:
        is_excl = ((this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE) != 0);

        if( is_excl )
        {
            is_active = (BOOL)wParam && GetForegroundWindow() == hWnd && !IsIconic(hWnd);

            #ifdef DEBUG
                /*
                 * Hack to allow debugging on multi-mon systems w/o minimizing
                 * the app all of the time.
                 */
                if( this_lcl->dwLocalFlags & DDRAWILCL_DISABLEINACTIVATE )
                {
                    wParam = is_active = TRUE;
                }
            #endif

            if (!is_active && wParam != 0)
            {
                DPF( 3, "WM_ACTIVATEAPP: setting wParam to 0, not realy active");
                wParam = 0;
            }

            if( is_active )
            {
                DPF( 5, "WM_ACTIVATEAPP: BEGIN Activating app pid=%08lx, tid=%08lx",
                                        GetCurrentProcessId(), GetCurrentThreadId() );
            }
            else
            {
                DPF( 5, "WM_ACTIVATEAPP: BEGIN Deactivating app pid=%08lx, tid=%08lx",
                                        GetCurrentProcessId(), GetCurrentThreadId() );
            }
            ENTER_DDRAW();
            if( is_active && (this_lcl->dwLocalFlags & DDRAWILCL_ACTIVEYES) )
            {
                DPF( 4, "*** Already activated" );
            }
            else
            if( !is_active && (this_lcl->dwLocalFlags & DDRAWILCL_ACTIVENO) )
            {
                DPF( 4, "*** Already deactivated" );
            }
            else
            {
                DPF( 4, "*** Active state changing" );
                if( is_active )
                {
                    if (GetAsyncKeyState( VK_MENU ) < 0)
                        DPF(4, "ALT key is DOWN");

                    if (GetKeyState( VK_MENU ) < 0)
                        DPF(4, "we think the ALT key is DOWN");

                    if( GetAsyncKeyState( VK_MENU ) < 0 )
                    {
                        curr->dwFlags |= WININFO_IGNORENEXTALTTAB;
                        DPF( 4, "AHHHHHHH Setting to ignore next alt tab" );
                    }
                    else
                    {
                        curr->dwFlags &= ~WININFO_IGNORENEXTALTTAB;
                    }
                }

                /*
                 * In the multi-mon scenario, it's possible that multiple
                 * devices are using this same window, so we need to do
                 * the following for each device.
                 */
                this_lcl->dwLocalFlags &= ~(DDRAWILCL_ACTIVEYES|DDRAWILCL_ACTIVENO);
                if( is_active )
                {
                    this_lcl->dwLocalFlags |= DDRAWILCL_ACTIVEYES;
                }
                else
                {
                    this_lcl->dwLocalFlags |= DDRAWILCL_ACTIVENO;
                }
                handleActivateApp( this_lcl, curr, is_active, TRUE );

                pdrv_lcl = lpDriverLocalList;
                while( pdrv_lcl != NULL )
                {
                    if( ( this_lcl->lpGbl != pdrv_lcl->lpGbl ) &&
                        ( pdrv_lcl->hFocusWnd == (ULONG_PTR) hWnd ) &&
                        ( pdrv_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE ) &&
                        ( pdrv_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV ) &&
                        ( this_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV ) )
                    {
                        pdrv_lcl->dwLocalFlags &= ~(DDRAWILCL_ACTIVEYES|DDRAWILCL_ACTIVENO);
                        if( is_active )
                        {
                            pdrv_lcl->dwLocalFlags |= DDRAWILCL_ACTIVEYES;
                        }
                        else
                        {
                            pdrv_lcl->dwLocalFlags |= DDRAWILCL_ACTIVENO;
                        }
                        handleActivateApp( pdrv_lcl, curr, is_active, FALSE );
                    }
                    pdrv_lcl = pdrv_lcl->lpLink;
                }
            }
            #ifdef DEBUG
                if( is_active )
                {
                    DPF( 4, "WM_ACTIVATEAPP: DONE Activating app pid=%08lx, tid=%08lx",
                                            GetCurrentProcessId(), GetCurrentThreadId() );
                }
                else
                {
                    DPF( 4, "WM_ACTIVATEAPP: DONE Deactivating app pid=%08lx, tid=%08lx",
                                            GetCurrentProcessId(), GetCurrentThreadId() );
                }
            #endif

            // set focus to last active popup
            if (is_active && this_lcl->hWndPopup)
            {
                if (IsWindow((HWND) this_lcl->hWndPopup))
                {
                    SetFocus((HWND) this_lcl->hWndPopup);
                }
                this_lcl->hWndPopup = 0;
            }

            LEAVE_DDRAW();
            HIDESHOW_IME();     //Show/hide the IME OUTSIDE of the ddraw critsect.
            if( !is_active && bStartHelper )
            {
                PostMessage( hWnd, WM_USER+0x1234, 0xFFBADADD, 0xFFADDBAD );
            }
        }

        rc = CallWindowProc( proc, hWnd, uMsg, wParam, lParam );

        // clear the WININFO_INACTIVATEAPP bit, but make sure to make sure
        // we are still hooked!
        if (GetDDrawWindowInfo(hWnd) != NULL)
        {
            curr->dwFlags &= ~WININFO_INACTIVATEAPP;
        }
        return rc;

        break;

#ifdef WIN95
    case WM_USER+0x1234:
        if( wParam == 0xFFBADADD && lParam == 0xFFADDBAD )
        {
            if( bStartHelper )
            {
                //HelperCreateThread();
            }
            bHelperStarting = FALSE;
            bStartHelper = FALSE;
            dwTime2 = 0;
            return 0;
        }
        break;
#endif

    #ifdef GDIDDPAL
        case WM_PALETTECHANGED:
            if( (HWND) wParam == hWnd )
            {
                break;
            }
            // fall through
        case WM_QUERYNEWPALETTE:
            ENTER_DDRAW();
            ppal_lcl = getPalette( this_lcl );
            if( ppal_lcl != NULL )
            {
            }
            LEAVE_DDRAW();
            break;
        case WM_PAINT:
            ENTER_DDRAW();
            ppal_lcl = getPalette( this_lcl );
            if( ppal_lcl != NULL )
            {
            }
            LEAVE_DDRAW();
            break;
    #endif
    }
    if ((curr->dwFlags & WININFO_SELFSIZE) &&
        (curr->DDInfo.dwDDFlags & DDSCL_DX8APP))
    {
        return 0L;   // don't send to app, it's caused by MakeFullScreen
    }
    rc = CallWindowProc( proc, hWnd, uMsg, wParam, lParam );
    return rc;

} /* WindowProc */

#undef DPF_MODNAME
#define DPF_MODNAME     "SetCooperativeLevel"

/*
 * DeviceWindowProc
 *
 * This is the Window Proc when the app asks us to create the device window.
 */
LRESULT WINAPI DeviceWindowProc(
                HWND hWnd,
                UINT uMsg,
                WPARAM wParam,
                LPARAM lParam )
{
    HWND hParent;
    LPCREATESTRUCT lpCreate;

    switch( uMsg )
    {
    case WM_CREATE:
        lpCreate = (LPCREATESTRUCT) lParam;
        SetWindowLongPtr( hWnd, 0, (INT_PTR) lpCreate->lpCreateParams );
        break;

    case WM_SETFOCUS:
        hParent = (HWND) GetWindowLongPtr( hWnd, 0 );
        if( IsWindow( hParent ) )
        {
            SetFocus( hParent );
        }
        break;

    case WM_SETCURSOR:
        SetCursor(NULL);
        break;
    }

    return DefWindowProc( hWnd, uMsg, wParam, lParam );

} /* WindowProc */

/*
 * CleanupWindowList
 *
 * This function is called by the helper thread after termination and
 * it's purpose is to remove any entries in the window list that could
 * be left around due to subclassing, etc.
 */
VOID CleanupWindowList( DWORD pid )
{
    LPDDWINDOWINFO        curr;

    /*
     * find the window list item associated with this process
     */
    curr = lpWindowInfo;
    while( curr != NULL )
    {
        if( curr->dwPid == pid )
        {
            break;
        }
        curr = curr->lpLink;
    }

    if( curr != NULL )
    {
        delete_wininfo( curr );
    }
} /* CleanupWindowList */


/*
 * internalSetAppHWnd
 *
 * Set the WindowList struct up with the app's hwnd info
 * Must be called with DLL & driver locks taken.
 */
HRESULT internalSetAppHWnd(
                LPDDRAWI_DIRECTDRAW_LCL this_lcl,
                HWND hWnd,
                DWORD dwFlags,
                BOOL is_ddraw,
                WNDPROC lpDSoundWndProc,
                DWORD pid )
{
    LPDDWINDOWINFO        curr;
    LPDDWINDOWINFO        prev;

    /*
     * find the window list item associated with this process
     */
    curr = lpWindowInfo;
    prev = NULL;
    while( curr != NULL )
    {
        if( curr->dwPid == pid )
        {
            break;
        }
        prev = curr;
        curr = curr->lpLink;
    }

    /*
     * check if this is OK
     */
    if( curr == NULL )
    {
        if( hWnd == NULL )
        {
            DPF( 1, "HWnd must be specified" );
            return DDERR_NOHWND;
        }
    }
    else
    {
        if( hWnd != NULL )
        {
            if( curr->hWnd != hWnd )
            {
                DPF( 1, "Hwnd %08lx no good: Different Hwnd (%08lx) already set for process",
                                    hWnd, curr->hWnd );
                return DDERR_HWNDALREADYSET;
            }
        }
    }

    /*
     * are we shutting an HWND down?
     */
    if( hWnd == NULL )
    {
        if( is_ddraw )
        {
            curr->dwFlags &= ~WININFO_DDRAWHOOKED;
        }
        else
        {
            curr->dwFlags &= ~WININFO_DSOUNDHOOKED;
        }

        if( (curr->dwFlags & (WININFO_DSOUNDHOOKED|WININFO_DDRAWHOOKED)) == 0 )
        {
            if( IsWindow(curr->hWnd) )
            {
                WNDPROC proc;

                proc = (WNDPROC) GetWindowLongPtr( curr->hWnd, GWLP_WNDPROC );

                if( proc != (WNDPROC) WindowProc &&
                    proc != (WNDPROC) curr->lpWndProc )
                {
                    DPF( 3, "Window has been subclassed; cannot restore!" );
                    curr->dwFlags |= WININFO_ZOMBIE;
                }
                else if (GetWindowThreadProcessId(curr->hWnd, NULL) !=
                         GetCurrentThreadId())
                {
                    DPF( 3, "intra-thread window unhook, letting window proc do it" );
                    curr->dwFlags |= WININFO_UNHOOK;
                    curr->dwFlags |= WININFO_ZOMBIE;
                    PostMessage(curr->hWnd, WM_NULL, 0, 0);
                }
                else
                {
                    DPF( 4, "Unsubclassing window %08lx", curr->hWnd );
                    KillTimer(hWnd,TOPMOST_ID);
                    SetWindowLongPtr( curr->hWnd, GWLP_WNDPROC, (INT_PTR) curr->lpWndProc );
                    delete_wininfo( curr );
                }
            }
            else
            {
                delete_wininfo( curr );
            }
        }
    }
    /*
     * changing or adding an hwnd then...
     */
    else
    {
        /*
         * brand new object...
         */
        if( curr == NULL )
        {
            if( GetDDrawWindowInfo(hWnd) != NULL)
            {
                DPF_ERR("Window already has WinInfo structure");
                return DDERR_INVALIDPARAMS;
            }

            curr = MemAlloc( sizeof( DDWINDOWINFO ) );
            if( curr == NULL )
            {
                return DDERR_OUTOFMEMORY;
            }
            curr->dwSmag = WININFO_MAGIC;
            curr->dwPid = pid;
            curr->lpLink = lpWindowInfo;
            lpWindowInfo = curr;
            curr->hWnd = hWnd;
            curr->lpWndProc = (WNDPROC) GetWindowLongPtr( hWnd, GWLP_WNDPROC );

            SetWindowLongPtr( hWnd, GWLP_WNDPROC, (INT_PTR) WindowProc );
        }

        /*
         * set ddraw/dsound specific data
         */
        if( is_ddraw )
        {
            curr->DDInfo.lpDD_lcl = this_lcl;
            curr->DDInfo.dwDDFlags = dwFlags;
            curr->dwFlags |= WININFO_DDRAWHOOKED;
        }
        else
        {
            curr->lpDSoundCallback = lpDSoundWndProc;
            curr->dwFlags |= WININFO_DSOUNDHOOKED;
        }
        DPF( 4, "Subclassing window %08lx", curr->hWnd );
    }
    return DD_OK;

} /* internalSetAppHWnd */

/*
 * ChangeHookedLCL
 *
 * This function is called when an object wants to un-hook the window,
 * but another object is still using it.  If the driver being unhooked is
 * the one that actaully did the hook, we need to setup the other LCL as
 * the one to use.
 */
HRESULT ChangeHookedLCL( LPDDRAWI_DIRECTDRAW_LCL this_lcl,
        LPDDRAWI_DIRECTDRAW_LCL new_lcl, DWORD pid )
{
    LPDDWINDOWINFO        curr;

    /*
     * find the window list item associated with this process
     */
    curr = lpWindowInfo;
    while( curr != NULL )
    {
        if( curr->dwPid == pid )
        {
            break;
        }
        curr = curr->lpLink;
    }
    if( curr == NULL )
    {
        return DD_OK;
    }

    /*
     * Are we shutting down the object that has hooked the hwnd?
     */
    if( (curr->dwFlags & WININFO_DDRAWHOOKED) &&
        ( curr->DDInfo.lpDD_lcl == this_lcl ) )
    {
        /*
         * Yes - make it use the new LCL
         */
        curr->DDInfo.lpDD_lcl = new_lcl;
    }
    return DD_OK;
}

#undef DPF_MODNAME

/*
 * SetAppHWnd
 *
 * Set the WindowList struct up with the app's hwnd info
 */
HRESULT SetAppHWnd(
                LPDDRAWI_DIRECTDRAW_LCL this_lcl,
                HWND hWnd,
                DWORD dwFlags )
{
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    DWORD       pid;
    HRESULT     ddrval;

    /*
     * set up the window
     */
    if( hWnd && (dwFlags & DDSCL_EXCLUSIVE) )
    {
        /*
         * make the window fullscreen and topmost
         */
        if ( (dwFlags & DDSCL_FULLSCREEN) &&
            !(dwFlags & DDSCL_NOWINDOWCHANGES))
        {
            MakeFullscreen(this_lcl, hWnd);
        }
    }

    /*
     * Don't hook the hWnd if it's already hooked and don't unhook it if
     * it's still being used by another object.
     */
    pid = GETCURRPID();
    pdrv_lcl = lpDriverLocalList;
    while( pdrv_lcl != NULL )
    {
        if( ( pdrv_lcl->lpGbl != this_lcl->lpGbl ) &&
            ( pdrv_lcl->dwLocalFlags & DDRAWILCL_HOOKEDHWND ) &&
            ( pdrv_lcl->hFocusWnd == this_lcl->hFocusWnd ) )
        {
            if( hWnd != NULL )
            {
                // Already hooked - no need to do more
                return DD_OK;
            }
            else
            {
                ENTERWINDOWLISTCSECT
                ddrval = ChangeHookedLCL( this_lcl, pdrv_lcl, pid );
                LEAVEWINDOWLISTCSECT
                return ddrval;
            }
        }
        pdrv_lcl = pdrv_lcl->lpLink;
    }

    ENTERWINDOWLISTCSECT
    if( hWnd == NULL )
    {
        ddrval = internalSetAppHWnd( this_lcl, NULL, dwFlags, TRUE, NULL, pid );
    }
    else
    {
        ddrval = internalSetAppHWnd( this_lcl, (HWND)this_lcl->hFocusWnd, dwFlags, TRUE, NULL, pid );
    }
    LEAVEWINDOWLISTCSECT
    return ddrval;

} /* SetAppHWnd */

/*
 * DSoundHelp
 */
HRESULT __stdcall DSoundHelp( HWND hWnd, WNDPROC lpWndProc, DWORD pid )
{
    HRESULT     ddrval;

    DPF( 4, "DSoundHelp: hWnd = %08lx, lpWndProc = %08lx, pid = %08lx", hWnd, lpWndProc, pid );
    ENTERWINDOWLISTCSECT
    ddrval = internalSetAppHWnd( NULL, hWnd, 0, FALSE, lpWndProc, pid );
    LEAVEWINDOWLISTCSECT
    return ddrval;

} /* DSoundHelp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddesurf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddesurf.c
 *  Content:	DirectDraw EnumSurfaces support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   25-jan-95	craige	split out of ddraw.c, enhanced
 *   31-jan-95	craige	and even more ongoing work...
 *   27-feb-95	craige 	new sync. macros
 *   19-mar-95	craige	use HRESULTs
 *   01-apr-95	craige	happy fun joy updated header file
 *   14-may-95	craige	cleaned out obsolete junk
 *   24-may-95  kylej   removed references to obsolete ZOrder variables
 *   07-jun-95	craige	only allow enumeration of surfaces that belong to
 *			the calling process
 *   12-jun-95	craige	new process list stuff
 *   16-jun-95	craige	removed fpVidMemOrig
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns
 *   30-jun-95	craige	use DDRAWI_HASPIXELFORMAT/HASOVERLAYDATA
 *   01-jul-95	craige	comment out compostion stuff
 *   03-jul-95  kylej   rewrote the CANBECREATED iteration
 *   04-jul-95	craige	YEEHAW: new driver struct; SEH
 *   19-jul-95	craige	EnumSurfaces wasn't wrapping all parm validation
 *   31-jul-95	craige	flag validation
 *   09-dec-95  colinmc added execute buffer support
 *   15-dec-95  colinmc fixed bug when filling surface description
 *   18-dec-95  colinmc additional caps bit checking in EnumSurfaces
 *   05-jan-95	kylej	added interface structures
 *   17-feb-96  colinmc fixed problem limiting size of execute buffers
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   29-apr-96  colinmc Bug 20063: incorrect surface description returned
 *                      for z-buffer
 *   24-mar-97  jeffno  Optimized Surfaces
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"

#undef  DPF_MODNAME
#define DPF_MODNAME "GetSurfaceDesc"

/*
 * FillDDSurfaceDesc
 *
 * NOTE: Special cases execute buffers as they have no pixel format or height.
 * You may wonder why this function is execute buffer aware when execute
 * buffers are skipped by EnumSurfaces. Well, FillDDSurfaceDesc is not simply
 * used when enumerating surfaces. It is also used when locking a surface so
 * it needs to fill in the correct stuff for execute buffers.
 */
void FillEitherDDSurfaceDesc(
		LPDDRAWI_DDRAWSURFACE_LCL lpDDSurfaceX,
		LPDDSURFACEDESC2 lpDDSurfaceDesc )
{
    LPDDRAWI_DDRAWSURFACE_GBL	lpDDSurface;

    DDASSERT(lpDDSurfaceDesc);
    DDASSERT(lpDDSurfaceDesc->dwSize == sizeof(DDSURFACEDESC) || lpDDSurfaceDesc->dwSize == sizeof(DDSURFACEDESC2) );

    lpDDSurface = lpDDSurfaceX->lpGbl;

    lpDDSurfaceDesc->dwFlags = DDSD_CAPS;
    lpDDSurfaceDesc->ddsCaps.dwCaps = lpDDSurfaceX->ddsCaps.dwCaps;
    if (lpDDSurfaceDesc->dwSize >= sizeof (DDSURFACEDESC2))
    {
        lpDDSurfaceDesc->ddsCaps.ddsCapsEx = lpDDSurfaceX->lpSurfMore->ddsCapsEx;
        if (DDSD_TEXTURESTAGE & lpDDSurfaceX->lpSurfMore->dwTextureStage)
        {
            lpDDSurfaceDesc->dwFlags |= DDSD_TEXTURESTAGE;
            lpDDSurfaceDesc->dwTextureStage = (lpDDSurfaceX->lpSurfMore->dwTextureStage & ~DDSD_TEXTURESTAGE);
        }
        else
            lpDDSurfaceDesc->dwTextureStage = 0;

        lpDDSurfaceDesc->dwFVF = lpDDSurfaceX->lpSurfMore->dwFVF;
        if (lpDDSurfaceX->lpSurfMore->dwFVF)
        {
            lpDDSurfaceDesc->dwFlags |= DDSD_FVF;
        }
    }

    lpDDSurfaceDesc->lpSurface = (FLATPTR) NULL;

    if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASCKEYDESTBLT )
    {
        lpDDSurfaceDesc->dwFlags |= DDSD_CKDESTBLT;
        lpDDSurfaceDesc->ddckCKDestBlt = lpDDSurfaceX->ddckCKDestBlt;
    }
    if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASCKEYSRCBLT )
    {
        lpDDSurfaceDesc->dwFlags |= DDSD_CKSRCBLT;
        lpDDSurfaceDesc->ddckCKSrcBlt = lpDDSurfaceX->ddckCKSrcBlt;
    }
    if( lpDDSurfaceX->dwFlags & DDRAWISURF_FRONTBUFFER )
    {
        lpDDSurfaceDesc->dwFlags |= DDSD_BACKBUFFERCOUNT;
        lpDDSurfaceDesc->dwBackBufferCount = lpDDSurfaceX->dwBackBufferCount;
    }
    if( lpDDSurfaceX->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
    {
	DDASSERT( lpDDSurfaceX->lpSurfMore != NULL );
	lpDDSurfaceDesc->dwFlags |= DDSD_MIPMAPCOUNT;
	lpDDSurfaceDesc->dwMipMapCount = lpDDSurfaceX->lpSurfMore->dwMipMapCount;
    }

    /*
     * Initialize the width, height and pitch of the surface description.
     */
    if( (lpDDSurfaceX->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
    	(lpDDSurface->ddpfSurface.dwFlags & DDPF_FOURCC) )
    {
	lpDDSurfaceDesc->dwFlags |= ( DDSD_WIDTH | DDSD_HEIGHT );
	lpDDSurfaceDesc->dwWidth  = (DWORD) lpDDSurface->wWidth;
	lpDDSurfaceDesc->dwHeight = (DWORD) lpDDSurface->wHeight;

    	switch (lpDDSurface->ddpfSurface.dwFourCC)
	{
	case FOURCC_DXT1:
	case FOURCC_DXT2:
	case FOURCC_DXT3:
	case FOURCC_DXT4:
	case FOURCC_DXT5:
	    /*
	     * A compressed texture surface is allocated as an integral number
	     * of blocks of 4x4 pixels.  It has no pixel pitch as such, so we
	     * return the linear size of the storage allocated for the surface.
	     */
	    lpDDSurfaceDesc->dwFlags |= DDSD_LINEARSIZE;
	    lpDDSurfaceDesc->dwLinearSize = lpDDSurface->dwLinearSize;
	    break;

	default:
    	    // This is what we've always done for FOURCCs, but is it correct?
	    lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;
            lpDDSurfaceDesc->lPitch   = lpDDSurface->lPitch;
    	    break;
	}
    }
    else if( lpDDSurfaceX->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
	/*
	 * For execute buffer the height is not valid and both the width
	 * and pitch are set to the linear size of the execute buffer.
	 */
        lpDDSurfaceDesc->dwFlags |= ( DDSD_WIDTH | DDSD_PITCH );
	lpDDSurfaceDesc->dwWidth  = lpDDSurface->dwLinearSize;
        lpDDSurfaceDesc->dwHeight = 0UL;
	lpDDSurfaceDesc->lPitch   = (LONG) lpDDSurface->dwLinearSize;
    }
#if 0 //Old code
    else if ( lpDDSurfaceX->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED )
    {
        lpDDSurfaceDesc->dwFlags |= ( DDSD_WIDTH | DDSD_HEIGHT );
	lpDDSurfaceDesc->dwWidth  = (DWORD) lpDDSurface->wWidth;
        lpDDSurfaceDesc->dwHeight = (DWORD) lpDDSurface->wHeight;
        if ( !(lpDDSurfaceX->lpGbl->dwGlobalFlags & DDRAWISURFGBL_MEMFREE ) )
        {
            if (lpDDSurfaceX->lpGbl->dwGlobalFlags & DDRAWISURFGBL_LATEALLOCATELINEAR)
            {
                /*
                 * Surface was allocated as a formless chunk.
                 */
                lpDDSurfaceDesc->dwFlags |= DDSD_LINEARSIZE;
                lpDDSurfaceDesc->dwLinearSize = lpDDSurfaceX->lpGbl->dwLinearSize;
            }
            else
            {
                lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;
	        lpDDSurfaceDesc->lPitch   = lpDDSurface->lPitch;
            }
        }
    }
#endif //0
    else
    {
        lpDDSurfaceDesc->dwFlags |= ( DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH );
	lpDDSurfaceDesc->dwWidth  = (DWORD) lpDDSurface->wWidth;
        lpDDSurfaceDesc->dwHeight = (DWORD) lpDDSurface->wHeight;
	lpDDSurfaceDesc->lPitch   = lpDDSurface->lPitch;
    }

    /*
     * Initialize the pixel format.
     */
    if( lpDDSurfaceX->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        /*
         * Dummy pixel format for execute buffers.
         */
        memset(&lpDDSurfaceDesc->ddpfPixelFormat, 0, sizeof(DDPIXELFORMAT));
        lpDDSurfaceDesc->ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);

        if (lpDDSurfaceDesc->dwSize >= sizeof (DDSURFACEDESC2))
        {
            if (lpDDSurfaceX->lpSurfMore->dwFVF)
            {
                lpDDSurfaceDesc->dwFVF = lpDDSurfaceX->lpSurfMore->dwFVF;
                lpDDSurfaceDesc->dwFlags |= DDSD_FVF;
            }
        }
    }
    else if( lpDDSurfaceX->ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
    {

	DDASSERT( lpDDSurfaceX->dwFlags & DDRAWISURF_HASPIXELFORMAT );
	DDASSERT( lpDDSurface->ddpfSurface.dwFlags & DDPF_ZBUFFER );
	DDASSERT( lpDDSurface->ddpfSurface.dwZBufferBitDepth !=0);

        // Note: DX5 copied the pixfmt from the surface but left the DDSD_PIXELFORMAT
        //       flag off because CreateSurface couldn't handle ZBuffers with pxfmts
        //       (because of Complex Surfaces).  Now it can, so I'm turning it on for dx6 apps

        // copy info to SD pixfmt.  This is what DX5 did too.
        lpDDSurfaceDesc->ddpfPixelFormat = lpDDSurface->ddpfSurface;

        // for pre-dx6 apps, fill in legacy SD ZBufferBitDepth field, but don't set pixfmt flag
        if (lpDDSurfaceDesc->dwSize == sizeof (DDSURFACEDESC)) {
            ((DDSURFACEDESC *)lpDDSurfaceDesc)->dwZBufferBitDepth=lpDDSurface->ddpfSurface.dwZBufferBitDepth;
            lpDDSurfaceDesc->dwFlags |= DDSD_ZBUFFERBITDEPTH;
        } else {
        // for dx6 apps, set PIXFMT flag, but not legacy SD ZBufferBitDepth field
            lpDDSurfaceDesc->dwFlags |= DDSD_PIXELFORMAT;
        }
    }
    else
    {
        lpDDSurfaceDesc->dwFlags |= DDSD_PIXELFORMAT;
        if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASPIXELFORMAT )
        {
            lpDDSurfaceDesc->ddpfPixelFormat=lpDDSurface->ddpfSurface;
        }
        else
        {
            lpDDSurfaceDesc->ddpfPixelFormat=lpDDSurface->lpDD->vmiData.ddpfDisplay;
        }
    }

    if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASOVERLAYDATA )
    {
        if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASCKEYDESTOVERLAY )
        {
            lpDDSurfaceDesc->dwFlags |= DDSD_CKDESTOVERLAY;
	    lpDDSurfaceDesc->ddckCKDestOverlay = lpDDSurfaceX->ddckCKDestOverlay;
        }
        if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASCKEYSRCOVERLAY )
        {
            lpDDSurfaceDesc->dwFlags |= DDSD_CKSRCOVERLAY;
	    lpDDSurfaceDesc->ddckCKSrcOverlay = lpDDSurfaceX->ddckCKSrcOverlay;
        }
    }
    else
    {
	lpDDSurfaceDesc->ddckCKDestOverlay.dwColorSpaceLowValue = 0;
	lpDDSurfaceDesc->ddckCKDestOverlay.dwColorSpaceHighValue = 0;
	lpDDSurfaceDesc->ddckCKSrcOverlay.dwColorSpaceLowValue = 0;
	lpDDSurfaceDesc->ddckCKSrcOverlay.dwColorSpaceHighValue = 0;
    }

} /* FillEitherDDSurfaceDesc */

void FillDDSurfaceDesc(
		LPDDRAWI_DDRAWSURFACE_LCL lpDDSurfaceX,
		LPDDSURFACEDESC lpDDSurfaceDesc )
{
    memset(lpDDSurfaceDesc,0, sizeof( DDSURFACEDESC ));
    lpDDSurfaceDesc->dwSize = sizeof( DDSURFACEDESC );
    FillEitherDDSurfaceDesc(lpDDSurfaceX, (LPDDSURFACEDESC2) lpDDSurfaceDesc);
}
void FillDDSurfaceDesc2(
		LPDDRAWI_DDRAWSURFACE_LCL lpDDSurfaceX,
		LPDDSURFACEDESC2 lpDDSurfaceDesc )
{
    memset(lpDDSurfaceDesc,0, sizeof( DDSURFACEDESC2 ));
    lpDDSurfaceDesc->dwSize = sizeof( DDSURFACEDESC2 );
    FillEitherDDSurfaceDesc(lpDDSurfaceX, lpDDSurfaceDesc);
}

/*
 * tryMatch
 *
 * tries to match a surface description with a surface object
 */
static BOOL tryMatch( LPDDRAWI_DDRAWSURFACE_LCL curr_lcl, LPDDSURFACEDESC2 psd )
{
    DWORD	flags;
    BOOL	no_match;
    LPDDRAWI_DDRAWSURFACE_GBL	curr;

    curr = curr_lcl->lpGbl;

    flags = psd->dwFlags;
    no_match = FALSE;

    if( flags & DDSD_CAPS )
    {
        if (curr_lcl->ddsCaps.dwCaps != psd->ddsCaps.dwCaps)
        {
            return FALSE;
        }
	if( memcmp( &curr_lcl->lpSurfMore->ddsCapsEx, &psd->ddsCaps.ddsCapsEx, sizeof( DDSCAPSEX ) ) )
	{
	    return FALSE;
	}
    }
    if( flags & DDSD_HEIGHT )
    {
	if( (DWORD) curr->wHeight != psd->dwHeight )
	{
	    return FALSE;
	}
    }
    if( flags & DDSD_WIDTH )
    {
	if( (DWORD) curr->wWidth != psd->dwWidth )
	{
	    return FALSE;
	}
    }
    if( flags & DDSD_LPSURFACE )
    {
	if( (LPVOID) curr->fpVidMem != psd->lpSurface )
	{
	    return FALSE;
	}
    }
    if( flags & DDSD_CKDESTBLT )
    {
	if( memcmp( &curr_lcl->ddckCKDestBlt, &psd->ddckCKDestBlt, sizeof( DDCOLORKEY ) ) )
	{
	    return FALSE;
	}
    }
    if( flags & DDSD_CKSRCBLT )
    {
	if( memcmp( &curr_lcl->ddckCKSrcBlt, &psd->ddckCKSrcBlt, sizeof( DDCOLORKEY ) ) )
	{
	    return FALSE;
	}
    }

    if( flags & DDSD_BACKBUFFERCOUNT )
    {
	if( curr_lcl->dwBackBufferCount != psd->dwBackBufferCount )
	{
	    return FALSE;
	}
    }

    if( flags & DDSD_MIPMAPCOUNT )
    {
	DDASSERT( curr_lcl->lpSurfMore != NULL );
	if( curr_lcl->lpSurfMore->dwMipMapCount != psd->dwMipMapCount )
	{
	    return FALSE;
	}
    }

    /*
     * these fields are not always present
     */
    if( flags & DDSD_PIXELFORMAT )
    {
	if( curr_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	{
	    if( memcmp( &curr->ddpfSurface, &psd->ddpfPixelFormat, sizeof( DDPIXELFORMAT ) ) )
	    {
		return FALSE;
	    }
	}
	else
	{
	    // surface description specifies pixel format but there is no
	    // pixel format in the surface.
	    return FALSE;
	}
    }

    if( curr_lcl->dwFlags & DDRAWISURF_HASOVERLAYDATA )
    {
        if( flags & DDSD_CKDESTOVERLAY )
        {
	    if( memcmp( &curr_lcl->ddckCKDestOverlay, &psd->ddckCKDestOverlay, sizeof( DDCOLORKEY ) ) )
	    {
		return FALSE;
	    }
	}
	if( flags & DDSD_CKSRCOVERLAY )
	{
	    if( memcmp( &curr_lcl->ddckCKSrcOverlay, &psd->ddckCKSrcOverlay, sizeof( DDCOLORKEY ) ) )
	    {
		return FALSE;
	    }
	}
    }
    else
    {
	if( ( flags & DDSD_CKDESTOVERLAY ) ||
	    ( flags & DDSD_CKSRCOVERLAY ) )
	{
	    return FALSE;
	}
    }

    return TRUE;

} /* tryMatch */

/*
 * What can we create? The popular question asked by the application.
 *
 * We will permute through the following items for each surface description:
 *
 * - FOURCC codes (dwFourCC)
 * - dimensions (dwHeight, dwWidth - based on modes avail only)
 * - RGB formats
 */
#define ENUM_FOURCC	0x000000001
#define ENUM_DIMENSIONS	0x000000002
#define ENUM_RGB	0x000000004

#undef  DPF_MODNAME
#define DPF_MODNAME	"EnumSurfaces"

/*
 * DD_EnumSurfaces
 */
HRESULT DDAPI DD_EnumSurfaces(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPDDSURFACEDESC lpDDSD,
		LPVOID lpContext,
		LPDDENUMSURFACESCALLBACK lpEnumCallback )
{
    DDSURFACEDESC2 ddsd2;

    DPF(2,A,"ENTERAPI: DD_EnumSurfaces");

    TRY
    {
	if( lpDDSD != NULL )
	{
	    if( !VALID_DDSURFACEDESC_PTR( lpDDSD ) )
	    {
	        DPF_ERR( "Invalid surface description. Did you set the dwSize member to sizeof(DDSURFACEDESC)?" );
                DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	        return DDERR_INVALIDPARAMS;
	    }
            ZeroMemory(&ddsd2,sizeof(ddsd2));
            memcpy(&ddsd2,lpDDSD,sizeof(*lpDDSD));
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters: Bad LPDDSURFACEDESC" );
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	return DDERR_INVALIDPARAMS;
    }

    ddsd2.dwSize = sizeof(ddsd2);

    if (lpDDSD)
        return DD_EnumSurfaces4(lpDD,dwFlags, &ddsd2, lpContext, (LPDDENUMSURFACESCALLBACK2) lpEnumCallback);
    else
        return DD_EnumSurfaces4(lpDD,dwFlags, NULL, lpContext, (LPDDENUMSURFACESCALLBACK2) lpEnumCallback);
}

/*
 * DD_EnumSurfaces4
 */
HRESULT DDAPI DD_EnumSurfaces4(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPDDSURFACEDESC2 lpDDSD,
		LPVOID lpContext,
		LPDDENUMSURFACESCALLBACK2 lpEnumCallback )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	this;
    LPDDRAWI_DDRAWSURFACE_INT	curr_int;
    LPDDRAWI_DDRAWSURFACE_LCL	curr_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	curr;
    DWORD			rc;
    BOOL			needit;
    DDSURFACEDESC2		dsd;
    LPDDSURFACEDESC2		pdsd;
    DWORD			flags;
    HRESULT                     ddrval;
    LPDIRECTDRAWSURFACE		psurf;
    DWORD			caps;
    DDSCAPSEX                   capsEx;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_EnumSurfaces4");

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwFlags & ~DDENUMSURFACES_VALID )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( lpDDSD != NULL )
	{
	    if( !VALID_DDSURFACEDESC2_PTR( lpDDSD ) )
	    {
                DPF_ERR("Bad DDSURFACEDESC2 ptr.. did you set the dwSize?");
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    caps = lpDDSD->ddsCaps.dwCaps;
	    capsEx = lpDDSD->ddsCaps.ddsCapsEx;
	}

	/*
	 * are flags OK?
	 */
	if( (dwFlags & DDENUMSURFACES_ALL) )
	{
	    if( dwFlags & (DDENUMSURFACES_MATCH | DDENUMSURFACES_NOMATCH) )
	    {
		DPF_ERR( "can't match or nomatch DDENUMSURFACES_ALL" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    if( lpDDSD == NULL )
	    {
		DPF_ERR( "No surface description" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    if( (dwFlags & DDENUMSURFACES_MATCH) && (dwFlags & DDENUMSURFACES_NOMATCH) )
	    {
		DPF_ERR( "can't match and nomatch together" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	if( dwFlags & DDENUMSURFACES_CANBECREATED )
	{
	    if( !(dwFlags & DDENUMSURFACES_MATCH) ||
		 (dwFlags & (DDENUMSURFACES_ALL | DDENUMSURFACES_NOMATCH) ) )
	    {
		DPF_ERR( "can only use MATCH for CANBECREATED" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

	if( lpDDSD != NULL )
	{
	    /*
	     * validate surface descriptions...
	     */
	    pdsd = lpDDSD;
	    flags = pdsd->dwFlags;

	    /*
	     * read-only flags
	     */
	    if( flags & DDSD_LPSURFACE )
	    {
		DPF_ERR( "Read-only flag specified in surface desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

	    /*
	     * Check for bogus caps bits.
	     */
            if( caps & ~DDSCAPS_VALID )
	    {
		DPF_ERR( "Invalid surface capability bits specified" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

            if( caps & DDSCAPS_OPTIMIZED )
            {
                DPF_ERR( "Optimized surfaces cannot be enumerated" );
                LEAVE_DDRAW();
                // ATTENTION: Should be an error, but we return DD_OK for
                // App-Compat reasons.
                return DD_OK;
            }

            if (capsEx.dwCaps2 & ~DDSCAPS2_VALID)
            {
                DPF_ERR( "invalid DDSURFACEDESC.DDSCAPS.dwSCaps2 specified" );
		LEAVE_DDRAW();
                return DDERR_INVALIDCAPS;
            }

            if (capsEx.dwCaps3 & ~DDSCAPS3_VALID)
            {
                DPF_ERR( "invalid DDSURFACEDESC.DDSCAPS.dwSCaps3 specified" );
		LEAVE_DDRAW();
                return DDERR_INVALIDCAPS;
            }

            if (capsEx.dwCaps4 & ~DDSCAPS4_VALID)
            {
                DPF_ERR( "invalid DDSURFACEDESC.DDSCAPS.dwSCaps4 specified" );
		LEAVE_DDRAW();
                return DDERR_INVALIDCAPS;
            }


            /*
             * You cannot enumerate over execute buffers (they are
             * not visible through the user level API).
             */
            if( caps & DDSCAPS_EXECUTEBUFFER )
            {
                DPF_ERR( "Invalid surface capability bit specified in surface desc" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }

	    /*
	     * check height/width
	     */
	    if( ((flags & DDSD_HEIGHT) && !(flags & DDSD_WIDTH)) ||
		(!(flags & DDSD_HEIGHT) && (flags & DDSD_WIDTH)) )
	    {
		DPF_ERR( "Specify both height & width in surface desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	
	    /*
	     * certain things you can and can't look for during CANBECREATED
	     */
	    if( dwFlags & DDENUMSURFACES_CANBECREATED )
	    {
		if( flags & (DDSD_CKDESTOVERLAY|
			     DDSD_CKDESTBLT|
			     DDSD_CKSRCOVERLAY|
			     #ifdef COMPOSITION
				DDSD_COMPOSITIONORDER |
			     #endif
			     DDSD_CKSRCBLT ))
		{
		    DPF_ERR( "Invalid flags specfied with CANBECREATED" );
		    LEAVE_DDRAW();
		    return DDERR_INVALIDPARAMS;
		}
		if( !(flags & DDSD_CAPS) )
		{
		    flags |= DDSD_CAPS;	// assume this...
		}
	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * if this is a request for what can be created, do it.
     */
    if( dwFlags & DDENUMSURFACES_CANBECREATED )
    {
	BOOL	        do_rgb=FALSE;
	BOOL	        do_fourcc=FALSE;
	BOOL	        do_dim=FALSE;
	LPDDPIXELFORMAT pdpf;
	DWORD	        i;
	DWORD	        mode;
	DWORD	        dimension_cnt;
	struct	        _dim
	{
	    DWORD       dwWidth;
	    DWORD       dwHeight;
	} *dim;
	DWORD		fourcc_cnt;
	struct		_fourcc
	{
	    DWORD	fourcc;
	    BOOL	is_fourcc;
	    BOOL	is_rgb;
	    DWORD	dwBPP;
	    DWORD	dwRBitMask;
	    DWORD	dwGBitMask;
	    DWORD	dwBBitMask;
	    DWORD       dwAlphaBitMask;
	} *fourcc;
	BOOL		done;
	BOOL            is_primary;
        DWORD           dwNumModes;
        LPDDHALMODEINFO lpModeInfo;

#ifndef WIN95
        LPCTSTR             pszDevice;
        DEVMODE             dm;
        DWORD               dwMaxModes;

        if (_stricmp(this->cDriverName, "DISPLAY"))
        {
            pszDevice = this->cDriverName;
        }
        else
        {
            pszDevice = NULL;
        }

        dwMaxModes = 256;
        lpModeInfo = MemAlloc(dwMaxModes * sizeof (*lpModeInfo));
        if (lpModeInfo == NULL)
        {
	    LEAVE_DDRAW();
            return DDERR_OUTOFMEMORY;
        }

        ZeroMemory(&dm, sizeof dm);
        dm.dmSize = sizeof dm;
        for (mode = 0, dwNumModes = 0;
            EnumDisplaySettings(pszDevice, mode, &dm); mode++)
        {
            if (dm.dmBitsPerPel >= 8)
            {
                lpModeInfo[dwNumModes].dwWidth = (WORD)dm.dmPelsWidth;
                lpModeInfo[dwNumModes].dwHeight = (WORD)dm.dmPelsHeight;
                lpModeInfo[dwNumModes].dwBPP = (WORD)dm.dmBitsPerPel;
                lpModeInfo[dwNumModes].wRefreshRate = (WORD)dm.dmDisplayFrequency;

                switch (dm.dmBitsPerPel)
                {
                case 8:
                    break;

                case 15:
                    lpModeInfo[dwNumModes].dwRBitMask = 0x7C00;
                    lpModeInfo[dwNumModes].dwGBitMask = 0x03E0;
                    lpModeInfo[dwNumModes].dwBBitMask = 0x001F;
                    lpModeInfo[dwNumModes].dwAlphaBitMask = 0;
                    lpModeInfo[dwNumModes].dwBPP = 16;
                    break;

                case 16:
                    if (this->lpModeInfo->dwBPP == 16)
                    {
                        lpModeInfo[dwNumModes].dwRBitMask = this->lpModeInfo->dwRBitMask;
                        lpModeInfo[dwNumModes].dwGBitMask = this->lpModeInfo->dwGBitMask;
                        lpModeInfo[dwNumModes].dwBBitMask = this->lpModeInfo->dwBBitMask;
                        lpModeInfo[dwNumModes].dwAlphaBitMask = this->lpModeInfo->dwAlphaBitMask;
                    }
                    else
                    {
                        lpModeInfo[dwNumModes].dwRBitMask = 0xF800;
                        lpModeInfo[dwNumModes].dwGBitMask = 0x07E0;
                        lpModeInfo[dwNumModes].dwBBitMask = 0x001F;
                        lpModeInfo[dwNumModes].dwAlphaBitMask = 0;
                    }
                    break;

                case 24:
                case 32:
                    lpModeInfo[dwNumModes].dwRBitMask = 0x00FF0000;
                    lpModeInfo[dwNumModes].dwGBitMask = 0x0000FF00;
                    lpModeInfo[dwNumModes].dwBBitMask = 0x000000FF;
                    lpModeInfo[dwNumModes].dwAlphaBitMask = 0;
                    break;
                }

                dwNumModes++;

                if (dwNumModes >= dwMaxModes)
                {
                    LPDDHALMODEINFO p = lpModeInfo;

                    dwMaxModes <<= 1;        
                    
                    lpModeInfo = MemAlloc(dwMaxModes * sizeof (*lpModeInfo));
                    if (lpModeInfo != NULL)
                    {
                        CopyMemory(lpModeInfo, p,
                            (dwMaxModes >> 1) * sizeof(*lpModeInfo));
                    }
                    
                    MemFree(p);

                    if (lpModeInfo == NULL)
                    {
	                LEAVE_DDRAW();
                        return DDERR_OUTOFMEMORY;
                    }
                }
            }
        }
#else
        dwNumModes = this->dwNumModes;
        lpModeInfo = this->lpModeInfo;
#endif

        dim = MemAlloc( sizeof(*dim) * dwNumModes );
        fourcc = MemAlloc( sizeof(*fourcc) * (dwNumModes+this->dwNumFourCC) );
	if( ( lpDDSD->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) == 0 )
	{
	    is_primary = FALSE;
	}
	else
	{
	    is_primary = TRUE;
	}
	pdpf = &(lpDDSD->ddpfPixelFormat);
	if( lpDDSD->dwFlags & DDSD_PIXELFORMAT )
	{
	    if( pdpf->dwFlags & DDPF_YUV )
	    {
	        do_fourcc = TRUE;
	    }
	    if( pdpf->dwFlags & DDPF_RGB )
	    {
	        do_rgb = TRUE;
	    }
	}
	if( !(lpDDSD->dwFlags & DDSD_HEIGHT) && !is_primary )
	{
	    do_dim = TRUE;
	}
	
	// set up dimension iteration
	dimension_cnt = 0;
	if( do_dim )
	{
	    for(mode=0, dimension_cnt = 0; mode < dwNumModes; mode++)
	    {
	        for(i=0; i<dimension_cnt; i++)
	        {
		    if( ( lpModeInfo[mode].dwWidth == dim[i].dwWidth ) &&
		        ( lpModeInfo[mode].dwHeight == dim[i].dwHeight ) )
		    {
		        break;
		    }
	        }
	        if( i == dimension_cnt )
	        {
		    // we found a new height and width
		    dim[dimension_cnt].dwWidth = lpModeInfo[mode].dwWidth;
		    dim[dimension_cnt].dwHeight = lpModeInfo[mode].dwHeight;
		    dimension_cnt++;
	        }
	    }
	}
	else
	{
	    // No dimension iteration required.
	    dimension_cnt = 1;
	    dim[0].dwWidth = lpDDSD->dwWidth;
	    dim[0].dwHeight = lpDDSD->dwHeight;
	}

	// set up fourcc/rgb iteration
	fourcc_cnt = 0;
	if( do_rgb )
	{
	    for(mode=0; mode < dwNumModes; mode++)
	    {
                for(i=0; i<fourcc_cnt; i++)
	        {
		    if( ( lpModeInfo[mode].dwBPP == (WORD)fourcc[i].dwBPP) &&
                        ( lpModeInfo[mode].dwRBitMask = fourcc[i].dwRBitMask ) &&
                        ( lpModeInfo[mode].dwGBitMask = fourcc[i].dwGBitMask ) &&
                        ( lpModeInfo[mode].dwBBitMask = fourcc[i].dwBBitMask ) &&
                        ( lpModeInfo[mode].dwAlphaBitMask = fourcc[i].dwAlphaBitMask ) )
		    {
		        break;
		    }
	        }
	        if( i == fourcc_cnt )
	        {
		    // we found a rgb format
		    fourcc[fourcc_cnt].dwBPP = (DWORD)lpModeInfo[mode].dwBPP;
		    fourcc[fourcc_cnt].dwRBitMask = lpModeInfo[mode].dwRBitMask;
		    fourcc[fourcc_cnt].dwGBitMask = lpModeInfo[mode].dwGBitMask;
		    fourcc[fourcc_cnt].dwBBitMask = lpModeInfo[mode].dwBBitMask;
		    fourcc[fourcc_cnt].dwAlphaBitMask = lpModeInfo[mode].dwAlphaBitMask;
		    fourcc[fourcc_cnt].is_fourcc = FALSE;
		    fourcc[fourcc_cnt].is_rgb = TRUE;
		    fourcc_cnt++;
	        }
	    }
	}

	if( do_fourcc )
	{
	    for(mode=0; mode < this->dwNumFourCC; mode++)
	    {
		// store the new fourcc code
		fourcc[fourcc_cnt].fourcc = this->lpdwFourCC[ mode ];
		fourcc[fourcc_cnt].is_fourcc = TRUE;
		fourcc[fourcc_cnt].is_rgb = FALSE;
		fourcc_cnt++;
 	    }
	}
	if( fourcc_cnt == 0 )
	{
	    fourcc_cnt = 1;
	    fourcc[0].is_rgb = FALSE;
	    fourcc[0].is_fourcc = FALSE;
	}
	
	// iterate through all the possibilities...
	if( !is_primary )
	{
	    lpDDSD->dwFlags |= DDSD_HEIGHT;
	    lpDDSD->dwFlags |= DDSD_WIDTH;
	}
	done = FALSE;
	for(mode=0; mode<dimension_cnt; mode++)
	{
	    lpDDSD->dwWidth = dim[mode].dwWidth;
	    lpDDSD->dwHeight = dim[mode].dwHeight;
	    for(i=0; i<fourcc_cnt; i++)
	    {
		if( fourcc[i].is_fourcc )
		{
		    pdpf->dwFlags = DDPF_YUV;
		    pdpf->dwFourCC = fourcc[i].fourcc;
		}
		else if( fourcc[i].is_rgb )
		{
		    pdpf->dwFlags = DDPF_RGB;
		    if( fourcc[i].dwBPP == 8 )
		    {
			pdpf->dwFlags |= DDPF_PALETTEINDEXED8;
		    }
		    pdpf->dwRGBBitCount = fourcc[i].dwBPP;
		    pdpf->dwRBitMask = fourcc[i].dwRBitMask;
		    pdpf->dwGBitMask = fourcc[i].dwGBitMask;
		    pdpf->dwBBitMask = fourcc[i].dwBBitMask;
		    pdpf->dwRGBAlphaBitMask = fourcc[i].dwAlphaBitMask;
		}
		
		done = FALSE;
		// The surface desc is set up, now try to create the surface
                // This will create a surface4-vtabled surface if on IDirectDraw4 int or higher
		ddrval = InternalCreateSurface( this_lcl, lpDDSD, &psurf, this_int, NULL, 0 );
		if( ddrval == DD_OK )
		{
		    FillDDSurfaceDesc2( ((LPDDRAWI_DDRAWSURFACE_INT)psurf)->lpLcl, &dsd );

                    /*
                     * Possible regression risk: make sure only DDSURFACEDESC size passed to
                     * old interfaces
                     */
                    if (LOWERTHANDDRAW4(this_int))
                    {
                        dsd.dwSize = sizeof(DDSURFACEDESC);
                    }

		    rc = lpEnumCallback( NULL,  &dsd, lpContext );
		    InternalSurfaceRelease((LPDDRAWI_DDRAWSURFACE_INT)psurf, FALSE, FALSE );
		}
		if( done )
		{
		    break;
		}
	    }
	    if( done )
	    {
		break;
	    }
	}

	LEAVE_DDRAW();
	MemFree( dim );
	MemFree( fourcc );
#ifndef WIN95
        MemFree( lpModeInfo );
#endif        
        return DD_OK;
    }

    /*
     * if it isn't a request for what exists already, then FAIL
     */
    if( !(dwFlags & DDENUMSURFACES_DOESEXIST) )
    {
        DPF(0,"Invalid Flags. You must specify at least DDENUMSURFACES_DOESEXIST or DDENUMSURFACES_CANBECREATED");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * run through all surfaces, seeing which ones we need
     */
    curr_int = this->dsList;
    while( curr_int != NULL )
    {
	curr_lcl = curr_int->lpLcl;
        curr = curr_lcl->lpGbl;
	// only enumerate the surface if it belongs to the calling local object
        if( curr_lcl->lpSurfMore->lpDD_lcl == this_lcl )
        {
    	    needit = FALSE;

            /*
             * Execute buffers are invisible to the user level API so
             * ensure we never show the user one of those.
             */
            if( !( curr_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER ) )
            {
    	        if( dwFlags & DDENUMSURFACES_ALL )
    	        {
    	            needit = TRUE;
    	        }
    	        else
    	        {
    	            needit = tryMatch( curr_lcl, lpDDSD );
    	            if( dwFlags & DDENUMSURFACES_NOMATCH )
    	            {
    		        needit = !needit;
    	            }
    	        }
            }
    	    if( needit )
    	    {
                LPDIRECTDRAWSURFACE4 returnedInt = (LPDIRECTDRAWSURFACE4) curr_int;

    	        FillDDSurfaceDesc2( curr_lcl, &dsd );
                if (LOWERTHANDDRAW4(this_int))
                {
    	            DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) curr_int , &IID_IDirectDrawSurface, (void**) & returnedInt);
                    dsd.dwSize = sizeof(DDSURFACEDESC);
                }
                else if (this_int->lpVtbl == &dd4Callbacks)
                {
    	            DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) curr_int , &IID_IDirectDrawSurface4, (void**) & returnedInt);
                }
                else
                {
    	            DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) curr_int , &IID_IDirectDrawSurface7, (void**) & returnedInt);
                }

    	        rc = lpEnumCallback( returnedInt, &dsd, lpContext );
    	        if( rc == 0 )
    	        {
    		    break;
    	        }
    	    }
        }
        curr_int = curr_int->lpLink;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_EnumSurfaces */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddcolor.c ===
/*==========================================================================
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcolor.c
 *  Content: 	Implements the DirectDrawColorControl interface, which
 *              allows controlling the colors in a primary or overlay surface.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   13-sept-96	scottm	created
 *   03-mar-97	scottm	Save/restore color when the surace is released
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#define DPF_MODNAME "DirectDrawColorControl"


/*
 * DD_Color_GetColorControls
 */
HRESULT DDAPI DD_Color_GetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor )
{
    LPDDHALCOLORCB_COLORCONTROL	pfn;
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    DDHAL_COLORCONTROLDATA      ColorData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Color_GetColorControls");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDCC;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    	if( (NULL == lpColor ) || !VALID_DDCOLORCONTROL_PTR( lpColor ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = pdrv_lcl->lpDDCB->HALDDColorControl.ColorControl;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	ColorData.lpDD = pdrv_lcl->lpGbl;
    	ColorData.lpDDSurface = this_lcl;
	ColorData.dwFlags = DDRAWI_GETCOLOR;
	ColorData.lpColorData = lpColor;

	DOHALCALL( ColorControl, pfn, ColorData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != ColorData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return ColorData.ddRVal;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * DD_Color_SetColorControls
 */
HRESULT DDAPI DD_Color_SetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor )
{
    LPDDHALCOLORCB_COLORCONTROL	pfn;
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    DDHAL_COLORCONTROLDATA ColorData;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Color_SetColorControls");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDCC;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    	if( (NULL == lpColor ) || !VALID_DDCOLORCONTROL_PTR( lpColor ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * If this is the first time, we want to save the current color settings
     * so we can restore them when the app exists.
     */
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( this_lcl->lpGbl );
    if( lpSurfGblMore->lpColorInfo == NULL )
    {
	DDCOLORCONTROL ddTempColor;
	HRESULT ddRVal;

	ddTempColor.dwSize = sizeof( ddTempColor );
	ddRVal = DD_Color_GetColorControls( lpDDCC, &ddTempColor );
	if( ddRVal == DD_OK )
	{
	    lpSurfGblMore->lpColorInfo = MemAlloc( sizeof( ddTempColor ) );
	    if( lpSurfGblMore->lpColorInfo != NULL )
	    {
		memcpy( lpSurfGblMore->lpColorInfo, &ddTempColor,
		    sizeof( ddTempColor ) );
	    }
	}
    }

    pfn = pdrv_lcl->lpDDCB->HALDDColorControl.ColorControl;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	ColorData.lpDD = pdrv_lcl->lpGbl;
    	ColorData.lpDDSurface = this_lcl;
	ColorData.dwFlags = DDRAWI_SETCOLOR;
	ColorData.lpColorData = lpColor;

	DOHALCALL( ColorControl, pfn, ColorData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != ColorData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return ColorData.ddRVal;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * ReleaseColorControl
 */
VOID ReleaseColorControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface )
{
    LPDDHALCOLORCB_COLORCONTROL	pfn;
    DDHAL_COLORCONTROLDATA ColorData;
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    DWORD rc;

    ENTER_DDRAW();

    /*
     * Restore the hardware if the color controls were changed
     */
    pdrv_lcl = lpSurface->lpSurfMore->lpDD_lcl;
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurface->lpGbl );
    if( lpSurfGblMore->lpColorInfo != NULL )
    {
    	pfn = pdrv_lcl->lpDDCB->HALDDColorControl.ColorControl;
    	if( pfn != NULL )
    	{
	    /*
	     * Call the HAL
	     */
    	    ColorData.lpDD = pdrv_lcl->lpGbl;
    	    ColorData.lpDDSurface = lpSurface;
	    ColorData.dwFlags = DDRAWI_SETCOLOR;
	    ColorData.lpColorData = lpSurfGblMore->lpColorInfo;

	    DOHALCALL( ColorControl, pfn, ColorData, rc, 0 );
	}

	/*
	 * Now release the previously allocated memory
	 */
	MemFree( lpSurfGblMore->lpColorInfo );
	lpSurfGblMore->lpColorInfo = NULL;
    }

    LEAVE_DDRAW();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddgamma.c ===
/*==========================================================================
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddgamma.c
 *  Content:    Implements the DirectDrawGammaControl interface, which
 *              allows controlling the gamma for the primary surface.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   05-mar-98  smac    created
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#define DPF_MODNAME "DirectDrawGammaControl"

#define DISPLAY_STR     "display"


/*
 * InitGamma
 *
 * Called while initializing the DDraw object.  It determines whether the
 * driver can support loadable gamma ramps and if so, it sets the
 * DDCAPS2_PRIMARYGAMMA cap bit.
 */
VOID InitGamma( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPSTR szDrvName )
{
    /*
     * In NT, we set the DDCAPS2_PRIMARYGAMMA cap in kernel mode, but on Win9X
     * we just call GetDeviceGammaRamp and if it works, we assume that the device
     * supports gamma.  However, GetDeviceGammaRamp was obviously not well tested
     * in Win9X because GDI calls a NULL pointer in some instances where the driver
     * doesn't support downloadable gamma ramps.  The only way to work around
     * this is to look at the HDC and detect the situations that crash
     * and then know not to attemp gamma in those situations.  We have to do
     * this in DDRAW16.
     */
    #ifdef WIN95
        LPWORD      lpGammaRamp;
        HDC         hdc;

        pdrv->ddCaps.dwCaps2 &= ~DDCAPS2_PRIMARYGAMMA;
        lpGammaRamp = (LPWORD) LocalAlloc( LMEM_FIXED, sizeof( DDGAMMARAMP ) );
        if( NULL != lpGammaRamp )
        {
            hdc = DD_CreateDC( szDrvName );
            if( DD16_AttemptGamma(hdc) &&       
                GetDeviceGammaRamp( hdc, lpGammaRamp ) )
            {
                pdrv->ddCaps.dwCaps2 |= DDCAPS2_PRIMARYGAMMA;
            }
            DD_DoneDC( hdc );
            LocalFree( (HLOCAL) lpGammaRamp );
        }
    #endif
    if( bGammaCalibratorExists && 
        ( pdrv->ddCaps.dwCaps2 & DDCAPS2_PRIMARYGAMMA ) )
    {
        pdrv->ddCaps.dwCaps2 |= DDCAPS2_CANCALIBRATEGAMMA;
    }
    else
    {
        pdrv->ddCaps.dwCaps2 &= ~DDCAPS2_CANCALIBRATEGAMMA;
    }
}

/*
 * SetGamma
 *
 * Sets the new GammaRamp.  If it is being set for the first time, we will
 * save the old gamma ramp so we can restore it later.
 */
BOOL SetGamma( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    BOOL bRet = TRUE;

    if( !( this_lcl->dwFlags & DDRAWISURF_SETGAMMA ) )
    {
        bRet = GetDeviceGammaRamp( (HDC) pdrv_lcl->hDC,
            this_lcl->lpSurfMore->lpOriginalGammaRamp );
    }
    if( bRet )
    {
        #ifdef WINNT
            bRet = DdSetGammaRamp( pdrv_lcl, (HDC) pdrv_lcl->hDC,
	        this_lcl->lpSurfMore->lpGammaRamp);
        #else
            bRet = SetDeviceGammaRamp( (HDC) pdrv_lcl->hDC,
                this_lcl->lpSurfMore->lpGammaRamp );
        #endif
        this_lcl->dwFlags |= DDRAWISURF_SETGAMMA;
    }
    if( !bRet )
    {
        return DDERR_UNSUPPORTED;
    }
    return DD_OK;
}

/*
 * RestoreGamma
 *
 * Restores the old GammaRamp.
 */
VOID RestoreGamma( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    BOOL bRet;
    HDC hdcTemp = NULL;

    /*
     * If we are on DDHELP's thread cleaning up, then pdrv_lcl->hDC
     * will be invalid.  In this case, we need to temporarily create
     * a new DC to use.
     */
    if( ( pdrv_lcl->dwProcessId != GetCurrentProcessId() ) &&
        ( this_lcl->dwFlags & DDRAWISURF_SETGAMMA ) )
    {
        hdcTemp = (HDC) pdrv_lcl->hDC;
        if( _stricmp( pdrv_lcl->lpGbl->cDriverName, DISPLAY_STR ) == 0 )
        {
            (HDC) pdrv_lcl->hDC = DD_CreateDC( g_szPrimaryDisplay );
        }
        else
        {
            (HDC) pdrv_lcl->hDC = DD_CreateDC( pdrv_lcl->lpGbl->cDriverName );
        }
    }

    if( ( this_lcl->dwFlags & DDRAWISURF_SETGAMMA ) &&
        ( this_lcl->lpSurfMore->lpOriginalGammaRamp != NULL ))
    {
        #ifdef WINNT
    	    bRet = DdSetGammaRamp( pdrv_lcl, (HDC) pdrv_lcl->hDC,
		this_lcl->lpSurfMore->lpOriginalGammaRamp);
        #else
            bRet = SetDeviceGammaRamp( (HDC) pdrv_lcl->hDC,
                this_lcl->lpSurfMore->lpOriginalGammaRamp );
        #endif
    }
    this_lcl->dwFlags &= ~DDRAWISURF_SETGAMMA;

    if( hdcTemp != NULL )
    {
        DD_DoneDC( (HDC) pdrv_lcl->hDC );
        (HDC) pdrv_lcl->hDC = hdcTemp;
    }
}

/*
 * ReleaseGammaControl
 */
VOID ReleaseGammaControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface )
{
    RestoreGamma( lpSurface, lpSurface->lpSurfMore->lpDD_lcl );
    if( lpSurface->lpSurfMore->lpGammaRamp != NULL )
    {
        MemFree( lpSurface->lpSurfMore->lpGammaRamp );
        lpSurface->lpSurfMore->lpGammaRamp = NULL;
    }
    if( lpSurface->lpSurfMore->lpOriginalGammaRamp != NULL )
    {
        MemFree( lpSurface->lpSurfMore->lpOriginalGammaRamp );
        lpSurface->lpSurfMore->lpOriginalGammaRamp = NULL;
    }
}

/*
 * DD_Gamma_GetGammaControls
 */
HRESULT DDAPI DD_Gamma_GetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC,
                                    DWORD dwFlags, LPDDGAMMARAMP lpGammaRamp)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DDRAWSURFACE_MORE  lpSurfMore;
    BOOL                        bRet;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Gamma_GetGammaRamp");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDGC;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
        lpSurfMore = this_lcl->lpSurfMore;

        if( (lpGammaRamp == NULL) || !VALID_BYTE_ARRAY( lpGammaRamp,
            sizeof( DDGAMMARAMP ) ) )
    	{
            DPF_ERR("DD_Gamma_GetGammaRamp: Invalid gamma table specified");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}

        if( dwFlags )
        {
            DPF_ERR("DD_Gamma_GetGammaRamp: Invalid flags specified");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * For now, only support setting the gamma for the primary surface
         */
        if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
        {
            DPF_ERR("DD_Gamma_GetGammaRamp: Must specify primary surface");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( !( pdrv_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_PRIMARYGAMMA ) )
        {
            DPF_ERR("DD_Gamma_GetGammaRamp: Device deos not support gamma ramps");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( SURFACE_LOST( this_lcl ) )
        {
            DPF_ERR("DD_Gamma_GetGammaRamp: Secified surface has been lost");
	    LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * If a gamma table has been set, return it; otherwise, get it from
     * the driver.
     */
    if( lpSurfMore->lpGammaRamp != NULL )
    {
        memcpy( lpGammaRamp, lpSurfMore->lpGammaRamp, sizeof( DDGAMMARAMP ) );
    }
    else
    {
        bRet = GetDeviceGammaRamp( (HDC) pdrv_lcl->hDC, (LPVOID) lpGammaRamp );
        if( bRet == FALSE )
        {
            DPF_ERR("DD_Gamma_GetGammaRamp: GetDeviceGammaRamp failed");
            LEAVE_DDRAW();
            return DDERR_UNSUPPORTED;
        }
    }

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * LoadGammaCalibrator
 */
VOID LoadGammaCalibrator( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    DDASSERT( pdrv_lcl->hGammaCalibrator == (ULONG_PTR) INVALID_HANDLE_VALUE );

    pdrv_lcl->hGammaCalibrator = (ULONG_PTR) LoadLibrary( szGammaCalibrator );
    if( pdrv_lcl->hGammaCalibrator != (ULONG_PTR) NULL )
    {
        pdrv_lcl->lpGammaCalibrator = (LPDDGAMMACALIBRATORPROC)
            GetProcAddress( (HANDLE)(pdrv_lcl->hGammaCalibrator), "CalibrateGammaRamp" );
        if( pdrv_lcl->lpGammaCalibrator == (ULONG_PTR) NULL )
        {
            FreeLibrary( (HMODULE) pdrv_lcl->hGammaCalibrator );
            pdrv_lcl->hGammaCalibrator = (ULONG_PTR) INVALID_HANDLE_VALUE;
        }
    }
    else
    {
        pdrv_lcl->hGammaCalibrator = (ULONG_PTR) INVALID_HANDLE_VALUE;
    }
}


/*
 * DD_Gamma_SetGammaRamp
 */
HRESULT DDAPI DD_Gamma_SetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC,
                                    DWORD dwFlags, LPDDGAMMARAMP lpGammaRamp)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DDRAWSURFACE_MORE  lpSurfMore;
    LPDDGAMMARAMP               lpTempRamp=NULL;
    HRESULT                     ddRVal;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Gamma_SetGammaRamp");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDGC;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
        lpSurfMore = this_lcl->lpSurfMore;

        if( (lpGammaRamp != NULL) && !VALID_BYTE_ARRAY( lpGammaRamp,
            sizeof( DDGAMMARAMP ) ) )
    	{
            DPF_ERR("DD_Gamma_SetGammaRamp: Invalid gamma table specified");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}

        if( dwFlags & ~DDSGR_VALID )
        {
            DPF_ERR("DD_Gamma_SetGammaRamp: Invalid flag specified");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( ( dwFlags & DDSGR_CALIBRATE ) && !bGammaCalibratorExists )
        {
            DPF_ERR("DD_Gamma_SetGammaRamp: DDSGR_CALIBRATE unsupported - Gamma calibrator not installed");
	    LEAVE_DDRAW();
            return DDERR_UNSUPPORTED;
        }

        /*
         * For now, only support setting the gamma for the primary surface
         */
        if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
        {
            DPF_ERR("DD_Gamma_SetGammaRamp: Must specify primary surface");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( !( pdrv_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_PRIMARYGAMMA ) )
        {
            DPF_ERR("DD_Gamma_SetGammaRamp: Device deos not support gamma ramps");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( SURFACE_LOST( this_lcl ) )
        {
            DPF_ERR("DD_Gamma_SetGammaRamp: Secified surface has been lost");
	    LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * lpGammaRamp is NULL, they are trying to restore the gamma.
     */
    if( lpGammaRamp == NULL )
    {
        ReleaseGammaControl( this_lcl );
    }
    else
    {
        /*
         * If they want to calibrate the gamma, we will do that now.  We will
         * copy this to a different buffer so that we don't mess up the one
         * passed in to us.
         */
        if( dwFlags & DDSGR_CALIBRATE )
        {
            /*
             * If the calibrator isn't loaded, do so now.
             */
            if( pdrv_lcl->hGammaCalibrator == (ULONG_PTR) INVALID_HANDLE_VALUE )
            {
                LoadGammaCalibrator( pdrv_lcl );
            }
            if( ( pdrv_lcl->hGammaCalibrator == (ULONG_PTR) INVALID_HANDLE_VALUE ) ||
                ( pdrv_lcl->lpGammaCalibrator == (ULONG_PTR) NULL ) )
            {
                /*
                 * If we were unable to load the library correctly,
                 * we shouldn't try again later.
                 */
                bGammaCalibratorExists = FALSE;
                DPF_ERR("DD_Gamma_SetGammaRamp: Unable to load gamma calibrator");
                LEAVE_DDRAW();
                return DDERR_UNSUPPORTED;
            }
            else
            {
                /*
                 * Call the calibrator to let it do it's thing.  First
                 * need to copy the buffer over so we don't mess with
                 * the one passed in.
                 */
                lpTempRamp = (LPDDGAMMARAMP) LocalAlloc( LMEM_FIXED,
                    sizeof( DDGAMMARAMP ) );
                if( lpTempRamp == NULL )
                {
                    DPF_ERR("DD_Gamma_SetGammaRamp: Insuficient memory for gamma ramps");
                    LEAVE_DDRAW();
                    return DDERR_OUTOFMEMORY;
                }
                memcpy( lpTempRamp, lpGammaRamp, sizeof( DDGAMMARAMP ) );
                lpGammaRamp = lpTempRamp;

                ddRVal = pdrv_lcl->lpGammaCalibrator( lpGammaRamp, pdrv_lcl->lpGbl->cDriverName );
                if( ddRVal != DD_OK )
                {
                    DPF_ERR("DD_Gamma_SetGammaRamp: Calibrator failed the call");
                    LocalFree( (HLOCAL) lpTempRamp );
                    LEAVE_DDRAW();
                    return ddRVal;
                }
            }
        }

        /*
         * If we are setting this for the first time, allocate memory to hold
         * the gamma ramps
         */
        if( lpSurfMore->lpOriginalGammaRamp == NULL )
        {
            lpSurfMore->lpOriginalGammaRamp = MemAlloc( sizeof( DDGAMMARAMP ) );
        }
        if( lpSurfMore->lpGammaRamp == NULL )
        {
            lpSurfMore->lpGammaRamp = MemAlloc( sizeof( DDGAMMARAMP ) );
        }

        /*
         * If we are in exlusive mode now, set the gamma ramp now; otherwise,
         * we'll let it get set when we enter excluisve mode.
         */
        if( lpSurfMore->lpGammaRamp && lpSurfMore->lpOriginalGammaRamp )
        {
            memcpy( lpSurfMore->lpGammaRamp, lpGammaRamp, sizeof( DDGAMMARAMP ) );
            if( pdrv_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE )
            {
                SetGamma( this_lcl, pdrv_lcl );
            }
            if( lpTempRamp != NULL )
            {
                LocalFree( (HLOCAL) lpTempRamp );
            }
        }
        else
        {
            /*
             * Out of memory condition.  Release the two ramps
             */
            if( lpTempRamp != NULL )
            {
                LocalFree( (HLOCAL) lpTempRamp );
            }
            if( lpSurfMore->lpGammaRamp != NULL )
            {
                MemFree( lpSurfMore->lpGammaRamp );
                lpSurfMore->lpGammaRamp = NULL;
            }
            if( lpSurfMore->lpOriginalGammaRamp != NULL )
            {
                MemFree( lpSurfMore->lpOriginalGammaRamp );
                lpSurfMore->lpOriginalGammaRamp = NULL;
            }
            DPF_ERR("DD_Gamma_SetGammaRamp: Insuficient memory for gamma ramps");
            LEAVE_DDRAW();
            return DDERR_OUTOFMEMORY;
        }
    }

    LEAVE_DDRAW();
    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddgdi32.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddgdi32.c
 *  Content:    Contains the cross-process mapping layer similar to gdi32.dll
 *              on NT that the per-process DLL calls into on Win9X.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   11-oct-99  smac    initial implementation
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"

#include "d3d8p.h"
#include "d3d8ddi.h"
#include "d3d8sddi.h"
#include "ddithunk.h"

extern HRESULT DDAPI DD_CreateSurface4_Main(LPDIRECTDRAW lpDD,LPDDSURFACEDESC2 lpDDSurfaceDesc,
        LPDIRECTDRAWSURFACE FAR *lplpDDSurface,IUnknown FAR *pUnkOuter,BOOL bDoSurfaceDescCheck,
        LPDDSURFACEINFO pSysMemInfo, DWORD DX8Flags);

extern void invalidateSurface(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern void makeDEVMODE(LPDDRAWI_DIRECTDRAW_GBL this, LPDDHALMODEINFO pmi, BOOL inexcl, BOOL useRefreshRate, LPDWORD pcds_flags, LPDEVMODE pdm);

void LoseDevice (DDDEVICEHANDLE* pDevice);

DDDEVICEHANDLE* pDeviceList = NULL;

// Bogus value used to initialize write only fields when communicating
// with the driver in debug builds
#define BOGUS_FIELD_VALUE          0xBAADCAFEul

typedef struct _KNOWNENTRY
{
    DWORD   PCIID;
    DWORD   VersionMajor;       // 0 means all versions
    DWORD   VersionMinor;       // 0 means all versions
    DWORD   Flags;
} KNOWNENTRY;

const KNOWNENTRY gKnownDeviceList[] =
{
    // NVidia
    {0x12D20018,          0,          0, KNOWN_ZSTENCILDEPTH},                                      // Riva 128         
    {0x10DE0020,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT
    {0x10DE0028,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2
    {0x10DE0029,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2 Ultra
    {0x10DE002C,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Vanta
    {0x10DE002D,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2 Model 64
    {0x10DE00A0,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Aladdin TNT2
    {0x10DE0100,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (GeForce) 
    {0x10DE0101,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (GeForce DDR) 
    {0x10DE0103,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (Quadro) 
    {0x10DE0110,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (GeForce2 MX) 
    {0x10DE0111,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (GeForce2 MX) 
    {0x10DE0113,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (Quadro2 MXR) 
    {0x10DE0150,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2)
    {0x10DE0151,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2 DDR) 
    {0x10DE0152,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2 BR) 
    {0x10DE0153,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (Quadro2) 
    {0x10DE0200,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV20 (GeForce 3)
    // 3DFX
    {0x121A0003,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},            // Banshee
    {0x121A0005,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},            // Voodoo3
    {0x121a0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A8R8G8B8},       // Voodoo4/5; same PCI-ID
    // ATI                                                                                           
    {0x10024742,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024744,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024749,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474D,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474F,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024750,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024752,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C42,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro (PCI)
    {0x10024C49,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro (PCI)
    {0x10024C4E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C52,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C53,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C60,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro LT

    {0x10024C4D,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X1R5G5B5},   // Rage Mobility AGP

    {0x10024C46, 0x0004000c, 0x00010411, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024C46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024D46, 0x0004000c, 0x00010411, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024D46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128

    {0x10025046, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS
    {0x10025046,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS
    {0x10025245, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025245,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025246, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025246,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x1002524B, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 VR PCI //DX8.1
    {0x1002524B,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 VR PCI //DX8.1
    {0x1002524C, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x1002524C,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128

    //New 128s for DX8.1:
    {0x10025041, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025041,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025042, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025042,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025043, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025043,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025044, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025044,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025045, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025045,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025047, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025047,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025048, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025048,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025049, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025049,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x1002504a, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x1002504a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x1002504b, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x1002504b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x1002504c, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x1002504c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x1002504d, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP            DX8.1
    {0x1002504d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP            DX8.1
    {0x1002504e, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x1002504e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x1002504f, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x1002504f,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025050, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025050,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025051, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025051,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025052, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025052,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025053, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025053,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025054, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025054,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025055, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025055,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025056, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025056,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025057, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025057,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025058, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025058,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
                        
    {0x10025345, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x10025345,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x10025346, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x10025346,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x10025347, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x10025347,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x10025348, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X   DX8.1
    {0x10025348,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X   DX8.1
    {0x1002534b, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x1002534b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x1002534c, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x1002534c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x1002534d, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x1002534d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x1002534e, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X     DX8.1
    {0x1002534e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X     DX8.1

    {0x10025446, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA GL AGP      DX8.1
    {0x10025446,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA GL AGP      DX8.1
    {0x1002544c, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA VR AGP      DX8.1
    {0x1002544c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA VR AGP      DX8.1
    {0x10025452, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA4XL VR-R AGP DX8.1
    {0x10025452,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA4XL VR-R AGP DX8.1

    {0x10025144,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025145,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025146,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025147,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6

    // Intel                                                                                         
    {0x80867800,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},  // Intel i740
    {0x80867123,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},  // Intel 810
    {0x80867125,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                              // Intel 810e
    {0x80861132,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                                                 // Intel 815
    {0x80861A12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},                                            // Intel Timna

    // Matrox                                                                                        
    {0x102b0520, 0x0004000b, 0x000110ea, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},                                      // G200 PCI
    {0x102b0520,          0,          0, KNOWN_ZSTENCILDEPTH},                                      // G200 PCI
    {0x102b0521, 0x0004000b, 0x000110ea, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // G200 AGP
    {0x102b0521,          0,          0, KNOWN_ZSTENCILDEPTH},          // G200 AGP
    {0x102b0525, 0x0004000b, 0x000110ea, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // G400, G450
    {0x102b0525,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // G400, G450
    // 3DLabs                                                                                        
    {0x3d3d0008,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH},                                      // 3DLabs Gamma
    {0x104c3d07,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8}, // Perm2
    {0x3d3d0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8},                                      // Perm2
    {0x3d3d000a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Perm3
    {0x3d3d000c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Perm3
    
    // Videologic                                                                                    
    {0x104a0010, 0x0004000c, 0x0001080c, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // PowerVR Kyro updated driver
    {0x104a0010,          0,          0, KNOWN_ZSTENCILDEPTH}, // PowerVR Kyro
    // S3                                                                                            
    {0x53338811,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge
    {0x53335631,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge
    {0x53338a01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge DX/GX DX8.1
    {0x53338c01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge MX DX8.1
    {0x53338a10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge GX2 DX8.1
    {0x53338a20,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},          // Savage3D
    {0x53338a22,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage4
    {0x53339102,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},          // Savage2K
    {0x53338c10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},          // Savage MX DX8.1
    {0x53338c12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},          // Savage IX DX8.1
    {0x53338a25,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage Pro DX8.1
    {0x53338a26,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage Pro DX8.1
    // Trident
    {0x10239880,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER}, // Trident Blade 3D 9880
    {0x10238500,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident Blade 3D/ProMedia DX8.1
    {0x10238400,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident Blade 3D/MVP4     DX8.1
    {0x10238420,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident CyberBlade i7 
    {0x10239910,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident CyberBlade DX8.1
    // SiS
    {0x10390300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5},   // SiS 300
    {0x10390300, 0x0004000d, 0x000107da, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 300
    {0x10395300, 0x0004000d, 0x000107da, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 300
    {0x10396326,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},          // SiS 6326
    {0x10396300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5},   // SiS 6300
    {0x10396300, 0x0004000d, 0x000107da, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 6300
    {0x10390310, 0x0004000d, 0x00010352, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 6300
    {0x10390315, 0x0004000d, 0x00010352, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 6300
    {0x10390325, 0x0004000c, 0x000107d3, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 6300
    {0x10396325, 0x0004000c, 0x000107d3, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 640/740
    {0x126f0720,          0,          0, KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5}  //Silicon Motion Lynx3DM
};

#define NUM_KNOWN_DEVICES      (sizeof(gKnownDeviceList)/sizeof(KNOWNENTRY))


#define CACHE_GROW_SIZE     30

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"



// Minimum size of DrawPrimitive buffer associated with a context.
#define MIN_PRIM_BUFFER_SIZE (1 << 14)
// Maximum
#define MAX_PRIM_BUFFER_SIZE (1 << 20)
// Default
#define DEF_PRIM_BUFFER_SIZE (1 << 16)

const DWORD dwOrderedFaces[6] = {
    DDSCAPS2_CUBEMAP_POSITIVEX,
    DDSCAPS2_CUBEMAP_NEGATIVEX,
    DDSCAPS2_CUBEMAP_POSITIVEY,
    DDSCAPS2_CUBEMAP_NEGATIVEY,
    DDSCAPS2_CUBEMAP_POSITIVEZ,
    DDSCAPS2_CUBEMAP_NEGATIVEZ
};

__inline LPDDRAWI_DDRAWSURFACE_INT GetHeavyweightSurf(DDSURFACE* pSurf)
{
    return (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT) ? MapLightweightSurface(pSurf) : pSurf->Surface.pHeavy;
}

#define DONE_HEAVYWEIGHT_SURF(x)                                \
    if (((PDDSURFACE)(x))->dwFlags & DDSURFACE_LIGHTWEIGHT)     \
        UnmapLightweightSurface(x)

HRESULT MapLegacyResult(HRESULT in)
{
    HRESULT hr;
    switch (in)
    {
    case DD_OK:
        hr = S_OK;
        break;

    case DDERR_OUTOFVIDEOMEMORY:
        hr = D3DERR_OUTOFVIDEOMEMORY;
        break;

    case DDERR_CURRENTLYNOTAVAIL:
    case DDERR_UNSUPPORTED:
        hr = D3DERR_NOTAVAILABLE;
        break;

    case DDERR_OUTOFMEMORY:
        hr = E_OUTOFMEMORY;
        break;

    default:
        hr = D3DERR_DRIVERINTERNALERROR;
    }
    return hr;
}


BOOL FormatCompatibleWithDisplayFormat(
    PDDDEVICEHANDLE pDD,
    D3DFORMAT Format)
{
    return (BOOL) (Format == pDD->DisplayFormatWithAlpha);
}

HRESULT LockDibEngine(LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    HRESULT ret;
    LPWORD pdflags;
    BOOL isbusy;

    pdflags = pdrv->lpwPDeviceFlags;
    isbusy = 0;

    _asm
    {
        mov eax, pdflags
        bts word ptr [eax], BUSY_BIT
        adc isbusy,0
    }
    if (isbusy && (0 == pdrv->dwWin16LockCnt)) 
    {
        D3D_WARN(2, "LOCK_DIBENGINE, dibengine is busy");
        ret = DDERR_SURFACEBUSY;
    } else
        ret = DD_OK;

    return ret;
}

void UnlockDibEngine(LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    if (0 == pdrv->dwWin16LockCnt)
    { 
        *pdrv->lpwPDeviceFlags &= ~BUSY;
    }
}

#define CALL_D3DHAL_TAKEBUSY_NOWIN16(ret, pDevice, func, data)          \
{                                                                       \
    if (func)                                                           \
    {                                                                   \
        ret = LockDibEngine((pDevice)->pDD->lpLcl->lpGbl);              \
        if (ret != DD_OK)                                               \
        {                                                               \
            ret = DDHAL_DRIVER_HANDLED;                                 \
        }                                                               \
        else                                                            \
        {                                                               \
            ret = (*(func))(data);                                      \
            UnlockDibEngine((pDevice)->pDD->lpLcl->lpGbl);              \
        }                                                               \
    }                                                                   \
    else                                                                \
    {                                                                   \
        DPF_ERR("No HAL call available");                               \
        ret = DDHAL_DRIVER_NOTHANDLED;                                  \
    }                                                                   \
}

#define CALL_D3DHAL_TAKEBUSY_TAKEWIN16(ret, pDevice, func, data)        \
{                                                                       \
    ENTER_WIN16LOCK();                                                  \
    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret, pDevice, func, data);             \
    LEAVE_WIN16LOCK();                                                  \
}

BOOL CanKnownDriverDoThis(PDDDEVICEHANDLE pDevice, DWORD Flag)
{
    BOOL ret = FALSE;
    int i;

    if (pDevice->ForceFlagsOff & Flag)
    {
        return FALSE;
    }
    else if (pDevice->ForceFlagsOn & Flag)
    {
        return TRUE;
    }

    // Only drivers in our known good list can support lightweight
    // surfaces

    if (pDevice->PCIID == 0)
    {
        DDDEVICEIDENTIFIER2 DI;

        if (InternalGetDeviceIdentifier7( (LPDIRECTDRAW) pDevice->pDD, &DI, 0, FALSE) == DD_OK)
        {
            pDevice->PCIID = (DI.dwVendorId << 16) | DI.dwDeviceId;
            pDevice->DriverVersionHigh = DI.liDriverVersion.HighPart;
            pDevice->DriverVersionLow = DI.liDriverVersion.LowPart;
        }
    }
    for (i = 0; i < NUM_KNOWN_DEVICES; i++)
    {
        if ((gKnownDeviceList[i].PCIID == pDevice->PCIID) &&
            (gKnownDeviceList[i].Flags & Flag) &&
            ((pDevice->DriverVersionHigh > gKnownDeviceList[i].VersionMajor) ||
             ((pDevice->DriverVersionHigh == gKnownDeviceList[i].VersionMajor) &&
              (pDevice->DriverVersionLow >= gKnownDeviceList[i].VersionMinor))))
        {
            ret = TRUE;
            break;
        }
    }

    return ret;
}


BOOL IsLightweightSurface(PDDDEVICEHANDLE pDevice, DDSURFACEDESC2* pddsd2, D3DFORMAT Format)
{
    // Render targets, Z buffers, cursor surfaces, and any part of flip chain 
    // must remain heavyweight surfaces.

    if (pddsd2->ddsCaps.dwCaps & (DDSCAPS_PRIMARYSURFACE |
                                  DDSCAPS_3DDEVICE |
                                  DDSCAPS_ZBUFFER |
                                  DDSCAPS_OFFSCREENPLAIN))
    {
        return FALSE;
    }

    // All paletized textures must be heavyweight unless it's at least a DX8
    // driver.  This is because some DX7 drivers don't handle palettes right.
    
    if ((pDevice->DriverLevel < 8) &&
        ((Format == D3DFMT_A8P8) || (Format == D3DFMT_P8)))
    {
        return FALSE;
    }
   
    if (pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_VOLUME)
    {
        return FALSE;
    }

    // If it's a static VB or IB, then we can let that be lightweight
    if ((pDevice->DriverLevel >= 8) &&
        (pddsd2->ddsCaps.dwCaps2 & DDSCAPS_EXECUTEBUFFER) &&
        (pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_HINTSTATIC))
    {
        return TRUE;
    }

    // Unless it's static, the runtime locks vidmem vbs indefinately,
    // so if we make them lightweight they will fill up our cache table
    // with 1000s of entries. Therefore, we will make them heavyweight.
    if ((pddsd2->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
        (pddsd2->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        return FALSE;
    }

    // Dynamic textures will be frequently locked, so it is inefficient
    // to make them light weight.
    if ((pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_HINTDYNAMIC) &&
        (pddsd2->ddsCaps.dwCaps & DDSCAPS_TEXTURE) &&
        (pddsd2->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        return FALSE;
    }

    return TRUE;
}


void UpdateSurfaceCache(DDSURFACE* pSurf)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pLcl = GET_CACHED_LIGHTWEIGHT_INT(pSurf)->lpLcl;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

    // Update those fields in the lightweight structure that the driver may
    // have changed

    pSurf->Surface.pLight->GblFlags     = pLcl->lpGbl->dwGlobalFlags;
    pSurf->Surface.pLight->fpGblVidMem  = pLcl->lpGbl->fpVidMem;
    pSurf->Surface.pLight->GblPitch     = pLcl->lpGbl->lPitch;
    pSurf->Surface.pLight->GblReserved1 = pLcl->lpGbl->dwReserved1;

    pSurf->Surface.pLight->LclFlags     = pLcl->dwFlags;
    pSurf->Surface.pLight->LclCaps1     = pLcl->ddsCaps.dwCaps;
    pSurf->Surface.pLight->LclReserved1 = pLcl->dwReserved1;

    lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE (pLcl->lpGbl);
    pSurf->Surface.pLight->GblMoreDriverReserved            = lpGblMore->dwDriverReserved;
    pSurf->Surface.pLight->GblMoreContentsStamp             = lpGblMore->dwContentsStamp;
    pSurf->Surface.pLight->pGblMoreUnswappedDriverReserved  = lpGblMore->lpvUnswappedDriverReserved;
    pSurf->Surface.pLight->fpGblMoreAliasOfVidMem           = lpGblMore->fpAliasOfVidMem;
    pSurf->Surface.pLight->cGblMorePageUnlocks              = lpGblMore->cPageUnlocks;

    if (pSurf->Surface.pLight->LclCaps1 & DDSCAPS_LOCALVIDMEM)
    {
        pSurf->Surface.pLight->fpGblMoreAliasedVidMem   = lpGblMore->fpAliasedVidMem;
    }
    else if (pSurf->Surface.pLight->LclCaps1 & DDSCAPS_NONLOCALVIDMEM)
    {
        pSurf->Surface.pLight->fpGblMorePhysicalVidMem  = lpGblMore->fpPhysicalVidMem;
    }
}


LPDDRAWI_DDRAWSURFACE_INT MapLightweightSurface(DDSURFACE* pSurf)
{
    LPDDRAWI_DDRAWSURFACE_INT       pCached = NULL;
    PDDDEVICEHANDLE                 pDevice = pSurf->pDevice;
    int                             i;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE* ppGblMore;
    DWORD                           Lowest;
    DWORD                           LowestEntry;
    CACHEENTRY*                     pCachedEntry = NULL;
    UINT                            CacheIndex;

    // If the surface is already mapped, this is pretty easy

    if (pSurf->Surface.pLight->CachedIndex)
    {
        DDASSERT(pSurf->Surface.pLight->CachedIndex & INDEX_IN_USE);

        pCachedEntry = GET_CACHED_ENTRY(pSurf);
        pCachedEntry->pSurface->dwReserved2++;    // up the ref count
        pCachedEntry->UsageStamp = pDevice->CacheUsageStamp++;

        // Protect against wrap around of the usage stamp
        if (pDevice->CacheUsageStamp == 0)
        {
            for (i = 0; i < pDevice->NumCachedSurfaces; i++)
            {
                pDevice->pCachedSurfaceTable[i].UsageStamp = 0;
            }
        }

        return pCachedEntry->pSurface;
    }

    // Otherwise, find an available surface to use

    do
    {
        // Look through the list and look for either a surface that isn't being used,
        // or one that we can use with the lowest UsageStamp.

        Lowest = LowestEntry = (DWORD) -1;
        for (i = 0; i < pDevice->NumCachedSurfaces; i++)
        {
            if (pDevice->pCachedSurfaceTable[i].pSurface->dwReserved1 == (ULONG_PTR) NULL)
            {
                pCachedEntry = &(pDevice->pCachedSurfaceTable[i]);
                CacheIndex = i;
                break;
            }
            else if ((pDevice->pCachedSurfaceTable[i].pSurface->dwReserved2 == 0) &&
                (pDevice->pCachedSurfaceTable[i].UsageStamp < Lowest))
            {
                Lowest = pDevice->pCachedSurfaceTable[i].UsageStamp;
                LowestEntry = (DWORD) i;
            }
        }

        if ((pCachedEntry == NULL) && (LowestEntry != (DWORD) -1))
        {
            // We don't have an empty one, but we found one that we can flush

            UpdateSurfaceCache((DDSURFACE*)(pDevice->pCachedSurfaceTable[LowestEntry].pSurface->dwReserved1));
            ((DDSURFACE*)(pDevice->pCachedSurfaceTable[LowestEntry].pSurface->dwReserved1))->Surface.pLight->CachedIndex = 0;
            pDevice->pCachedSurfaceTable[LowestEntry].pSurface->dwReserved1 = (ULONG_PTR) NULL;
            pCachedEntry = &(pDevice->pCachedSurfaceTable[LowestEntry]);
            CacheIndex = LowestEntry;
        }

        if (pCachedEntry == NULL)
        {
            // If we still can't find one, then we need to grow the table

            int             NewNum;
            CACHEENTRY*     pNewTable;

            NewNum = pDevice->NumCachedSurfaces + CACHE_GROW_SIZE;
            pNewTable = (CACHEENTRY*) MemAlloc(sizeof(CACHEENTRY) * NewNum);
            if (pNewTable == NULL)
            {
                return NULL;
            }
            for (i = 0; i < pDevice->NumCachedSurfaces; i++)
            {
                pNewTable[i] = pDevice->pCachedSurfaceTable[i];
            }
            while (i < NewNum)
            {
                pNewTable[i].UsageStamp = 0; 
                pNewTable[i].pSurface = (LPDDRAWI_DDRAWSURFACE_INT) 
                    MemAlloc(sizeof(DDRAWI_DDRAWSURFACE_INT) +
                             sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                             sizeof(DDRAWI_DDRAWSURFACE_GBL) +
                             sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                             sizeof(DDRAWI_DDRAWSURFACE_GBL_MORE) +
                             sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
                if (pNewTable[i].pSurface == NULL)
                {
                    break;
                }
                else
                {
                    i++;
                }
            }
            if (pDevice->pCachedSurfaceTable != NULL)
            {
                MemFree(pDevice->pCachedSurfaceTable);
            }
            pDevice->NumCachedSurfaces = i;
            pDevice->pCachedSurfaceTable = pNewTable;
        }
    } while (pCachedEntry == NULL);

    pCachedEntry->UsageStamp = pDevice->CacheUsageStamp++;

    // Protect against wrap around of the usage stamp
    if (pDevice->CacheUsageStamp == 0)
    {
        for (i = 0; i < pDevice->NumCachedSurfaces; i++)
        {
            pDevice->pCachedSurfaceTable[i].UsageStamp = 0;
        }
    }

    // We have the memory that we want to use, so now we need to initialze it

    pCached = pCachedEntry->pSurface;

    memset(pCached, 0, sizeof(DDRAWI_DDRAWSURFACE_INT) +
                       sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                       sizeof(DDRAWI_DDRAWSURFACE_GBL) +
                       sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                       sizeof(DDRAWI_DDRAWSURFACE_GBL_MORE) +
                       sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
    pCached->dwReserved1 = (ULONG_PTR) pSurf;
    pCached->dwReserved2 = 1;   // Init the ref count
    pSurf->Surface.pLight->CachedIndex = CacheIndex | INDEX_IN_USE;    // So a used entry is never 0

    pCached->lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL) 
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT));

    pCached->lpLcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE)
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT) +
                            sizeof(DDRAWI_DDRAWSURFACE_LCL));

    pCached->lpLcl->lpGbl = (LPDDRAWI_DDRAWSURFACE_GBL)
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT) +
                            sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                            sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                            sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
    
    ppGblMore = (LPDDRAWI_DDRAWSURFACE_GBL_MORE*) ((BYTE*)(pCached->lpLcl->lpGbl) - 
        sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
    *ppGblMore = (LPDDRAWI_DDRAWSURFACE_GBL_MORE)
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT) +
                            sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                            sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                            sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE) +
                            sizeof(DDRAWI_DDRAWSURFACE_GBL));

    // Now fill it in with the meaningful data

    pCached->lpLcl->dwFlags             = pSurf->Surface.pLight->LclFlags;
    pCached->lpLcl->ddsCaps.dwCaps      = pSurf->Surface.pLight->LclCaps1;
    pCached->lpLcl->dwReserved1         = pSurf->Surface.pLight->LclReserved1;
    pCached->lpLcl->dwModeCreatedIn     = pSurf->Surface.pLight->LclModeCreatedIn;
    pCached->lpLcl->dwBackBufferCount   = pSurf->Surface.pLight->LclBackBufferCount;
    pCached->lpLcl->dwProcessId         = pDevice->PID;

    pCached->lpLcl->lpGbl->dwGlobalFlags    = pSurf->Surface.pLight->GblFlags;
    pCached->lpLcl->lpGbl->lPitch           = pSurf->Surface.pLight->GblPitch;
    pCached->lpLcl->lpGbl->wWidth           = (WORD) pSurf->Surface.pLight->GblWidth;
    pCached->lpLcl->lpGbl->wHeight          = (WORD) pSurf->Height;
    pCached->lpLcl->lpGbl->dwReserved1      = pSurf->Surface.pLight->GblReserved1;
    if (pSurf->Surface.pLight->GblFormat != D3DFMT_UNKNOWN)
    {
        ConvertToOldFormat(&pCached->lpLcl->lpGbl->ddpfSurface, 
            pSurf->Surface.pLight->GblFormat);
    }
    pCached->lpLcl->lpGbl->lpVidMemHeap     = pSurf->Surface.pLight->pGblVidMemHeap;
    pCached->lpLcl->lpGbl->fpVidMem         = pSurf->Surface.pLight->fpGblVidMem;

    pCached->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2   = pSurf->Surface.pLight->MoreCaps2;
    pCached->lpLcl->lpSurfMore->ddsCapsEx.dwCaps3   = pSurf->Surface.pLight->MoreCaps3;
    pCached->lpLcl->lpSurfMore->ddsCapsEx.dwCaps4   = pSurf->Surface.pLight->MoreCaps4;
    pCached->lpLcl->lpSurfMore->rgjunc              = pSurf->Surface.pLight->MoreRgjunc;
    pCached->lpLcl->lpSurfMore->dwSurfaceHandle     = pSurf->dwCookie;
    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        pCached->lpLcl->lpSurfMore->lpDD_lcl = pDevice->pSwDD->lpLcl;
        pCached->lpLcl->lpSurfMore->lpDD_int = pDevice->pSwDD;
        pCached->lpLcl->lpGbl->lpDD          = pDevice->pSwDD->lpLcl->lpGbl;
    }
    else
    {
        pCached->lpLcl->lpSurfMore->lpDD_lcl = pDevice->pDD->lpLcl;
        pCached->lpLcl->lpSurfMore->lpDD_int = pDevice->pDD;
        pCached->lpLcl->lpGbl->lpDD          = pDevice->pDD->lpLcl->lpGbl;
    }

    (*ppGblMore)->dwDriverReserved              = pSurf->Surface.pLight->GblMoreDriverReserved;
    (*ppGblMore)->dwContentsStamp               = pSurf->Surface.pLight->GblMoreContentsStamp;
    (*ppGblMore)->lpvUnswappedDriverReserved    = pSurf->Surface.pLight->pGblMoreUnswappedDriverReserved;
    (*ppGblMore)->fpAliasOfVidMem               = pSurf->Surface.pLight->fpGblMoreAliasOfVidMem;
    (*ppGblMore)->cPageUnlocks                  = pSurf->Surface.pLight->cGblMorePageUnlocks;

    if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) 
    {
        pCached->lpLcl->lpSurfMore->dwMipMapCount   = pSurf->Surface.pLight->MoreMipMapCount;
    }
    else
    {
        pCached->lpLcl->lpSurfMore->dwFVF           = pSurf->Surface.pLight->MoreFVF;
    }

    if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        pCached->lpLcl->lpSurfMore->dwBytesAllocated    = pSurf->Surface.pLight->MoreBytesAllocated;
    }
    else if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        (*ppGblMore)->fpPhysicalVidMem  = pSurf->Surface.pLight->fpGblMorePhysicalVidMem;
    }
    else if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
    {
        (*ppGblMore)->fpAliasedVidMem   = pSurf->Surface.pLight->fpGblMoreAliasedVidMem;
    }

    pCached->lpVtbl = (LPVOID) &ddSurface7Callbacks;

    return pCached;
}

void UnmapLightweightSurface(DDSURFACE* pSurf)
{
    DDASSERT(pSurf->Surface.pLight->CachedIndex & INDEX_IN_USE);
    DDASSERT(pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT);
    DDASSERT(GET_CACHED_ENTRY(pSurf)->pSurface->dwReserved2 > 0);

    if (--(GET_CACHED_ENTRY(pSurf)->pSurface->dwReserved2) == 0)
    {
        // Vertex and command buffers are used by DP2, so we want to optimize
        // for them.  Even though we are done using the surface, we will keep
        // the heavyweight surface around so we can use it again quickly if
        // we need to.

        if (!(pSurf->Surface.pLight->LclCaps1 & DDSCAPS_EXECUTEBUFFER))
        {
            UpdateSurfaceCache(pSurf);
            GET_CACHED_ENTRY(pSurf)->pSurface->dwReserved1 = (ULONG_PTR) NULL;
            pSurf->Surface.pLight->CachedIndex = 0;
        }
    }
}

void ReleaseDX7SurfaceHandle(HANDLE hDD, DWORD handle)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;

    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry =
        pDeviceHandle->SurfaceHandleList.dwFreeList;
    pDeviceHandle->SurfaceHandleList.dwFreeList = handle;
}

DWORD GetDX7SurfaceHandle (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    DWORD           handle = pDeviceHandle->SurfaceHandleList.dwFreeList;

    if (0==handle)
    {
        // need to grow the dwList
        LPDDSURFACELISTENTRY  newList;
        DWORD   newsize;
        DWORD   index;
        if (NULL != pDeviceHandle->SurfaceHandleList.dwList)
        {
            // old size(current dwFreeList) must not be zero
            DDASSERT(0 != pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
            // new dwFreeList is always gonna be the old dwList[0].nextentry
            newsize = pDeviceHandle->SurfaceHandleList.dwList[0].nextentry + LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle()");
                return  0;
            }
            pDeviceHandle->SurfaceHandleList.dwFreeList =
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry;
            memcpy((LPVOID)newList,(LPVOID)pDeviceHandle->SurfaceHandleList.dwList,
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry*sizeof(DDSURFACELISTENTRY));
            MemFree(pDeviceHandle->SurfaceHandleList.dwList);
        }
        else
        {
            newsize = LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle()");
                return  0;
            }
            // start from one as we don't want 0 as a valid handle
            pDeviceHandle->SurfaceHandleList.dwFreeList = 1;
        }
        pDeviceHandle->SurfaceHandleList.dwList=newList;
        pDeviceHandle->SurfaceHandleList.dwList[0].nextentry=newsize;

        for (index = pDeviceHandle->SurfaceHandleList.dwFreeList;
            index < newsize - 1;
            index++)
        {
            newList[index].nextentry=index+1;
        }
        // indicate end of new FreeList
        newList[newsize-1].nextentry=0;
        // now pop up one and assign it to handle
        handle=pDeviceHandle->SurfaceHandleList.dwFreeList;
    }
    // handle slot is avialable so just remove it from freeList
    pDeviceHandle->SurfaceHandleList.dwFreeList =
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry;
#if DBG
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry=0xDEADBEEF;
#endif
    pDeviceHandle->SurfaceHandleList.dwList[handle].dwFlags=0;  //mark it's new
    pDeviceHandle->SurfaceHandleList.dwList[handle].lpSurface=NULL;
    DDASSERT (handle > 0);
    DDASSERT (handle < pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
    return handle;
}

void FreeSurfaceObject (PDDSURFACE pSurf, BOOL bDestroy)
{
    if ((pSurf != NULL) &&
        !(pSurf->dwFlags & DDSURFACE_DUMMY))
    {
        if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
        {
            LPDDRAWI_DDRAWSURFACE_INT pHeavy;

            if (pSurf->Surface.pLight != NULL)
            {
                pHeavy = GetHeavyweightSurf(pSurf);
                if (pHeavy != NULL)
                {
                    if (pSurf->dwFlags & DDSURFACE_CREATECOMPLETE)
                    {
                        SwDDIDestroySurface (pSurf->pDevice, pSurf, pHeavy->lpLcl);
                    }
                    else if (pSurf->dwFlags & DDSURFACE_CREATEEX)
                    {
                        pHeavy->lpLcl->lpGbl->fpVidMem = 0;
                        SwDDICreateSurfaceEx (pSurf->pDevice->pSwDD->lpLcl,
                            pHeavy->lpLcl);
                    }

                    // Uncache the lightweight surface

                    if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                    {
                        pHeavy->dwReserved1 = (ULONG_PTR) NULL;
                        pHeavy->dwReserved2 = 0;
                    }
                }
                
                MemFree (pSurf->Surface.pLight);
                pSurf->Surface.pLight = NULL;
            }

            if (pSurf->dwCookie != 0)
            {
                ReleaseDX7SurfaceHandle(pSurf->pDevice, pSurf->dwCookie);
                pSurf->dwCookie = 0;
            }
        }

        else if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
        {
            // If we created a texture handle, free it now

            if ((pSurf->dwFlags & DDSURFACE_DX6HANDLE) &&
                (pSurf->pDevice->pContext != NULL) &&
                (pSurf->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy != NULL))
            {
                D3DHAL_TEXTUREDESTROYDATA   data;
                DWORD                       ret;

                data.dwhContext = (ULONG_PTR) pSurf->pDevice->pContext->Context;
                data.dwHandle = pSurf->dwCookie;

                CALL_D3DHAL_TAKEBUSY_TAKEWIN16(ret,
                            pSurf->pDevice,
                            pSurf->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy,
                            &data);
            }
            pSurf->dwFlags &= ~DDSURFACE_DX6HANDLE;

            // Now delete the heavy weight surface

            if (bDestroy)
            {
                if (pSurf->Surface.pHeavy != NULL)
                {
                    if (pSurf->dwFlags & DDSURFACE_ROOT)
                    {
                        InternalSurfaceRelease(pSurf->Surface.pHeavy, FALSE, TRUE);
                    }
                }
                pSurf->Surface.pHeavy = NULL;
            }
            else if (pSurf->Surface.pHeavy != NULL)
            {
                invalidateSurface(pSurf->Surface.pHeavy->lpLcl);
            }
        }
        else if (pSurf->Surface.pLight != NULL)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

            pHeavy = MapLightweightSurface(pSurf);
            if (pHeavy != NULL)
            {
                if (bDestroy)
                {
                    pHeavy->dwIntRefCnt = 1;
                    pHeavy->lpLcl->dwLocalRefCnt = 1;
                    pHeavy->lpLcl->lpGbl->dwRefCnt = 1;

                    if (pSurf->dwFlags & DDSURFACE_ROOT)
                    {
                        pHeavy->lpLcl->lpSurfMore->pAddrefedThisOwner = (IUnknown*) pSurf->pDevice->pDD;
                    }
                    pHeavy->lpLcl->dwFlags &= ~DDRAWISURF_IMPLICITCREATE;

                    InternalSurfaceRelease(pHeavy, TRUE, TRUE);

                    pHeavy->dwReserved1 = (ULONG_PTR) NULL;
                    pHeavy->dwReserved2 = 0;
                }
                else
                {
                    invalidateSurface(pHeavy->lpLcl);
                    DONE_HEAVYWEIGHT_SURF(pSurf);
                }
            }
            if (bDestroy)
            {
                MemFree (pSurf->Surface.pLight);
                pSurf->Surface.pLight = NULL;
            }
        }
    }
}

/*****************************Private*Routine******************************\
* DdConvertToOldFormat
*
* History:
*  3-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

void ConvertToOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT NewFormat)
{
    // Zero out the format to avoid missing
    // cases where it isn't initialized right
    ZeroMemory(pOldFormat, sizeof(*pOldFormat));

    // Set Size
    pOldFormat->dwSize = sizeof(DDPIXELFORMAT);

    // Convert away
    if (HIWORD((DWORD)NewFormat))
    {
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        return;
    }

    switch (NewFormat)
    {
    case D3DFMT_R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 24;
        break;

    case D3DFMT_A8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0xFF000000;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_X8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_R5G6B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x0000f800;
        pOldFormat->dwGBitMask        = 0x000007e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x00008000;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000f000;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 8;
        break;

    case D3DFMT_A8R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000FF00;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A8P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_ALPHAPIXELS |
                                         DDPF_PALETTEINDEXED8;

        pOldFormat->dwRGBAlphaBitMask  = 0x0000FF00;
        pOldFormat->dwRGBBitCount      = 16;
        break;

    case D3DFMT_P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_PALETTEINDEXED8;
        pOldFormat->dwRGBBitCount      = 8;
        break;

    case D3DFMT_L8:
        pOldFormat->dwFlags             = DDPF_LUMINANCE;
        pOldFormat->dwLuminanceBitMask  = 0x000000FF;
        pOldFormat->dwLuminanceBitCount = 8;
        break;

    case D3DFMT_A8L8:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x0000FF00;
        pOldFormat->dwLuminanceBitMask      = 0x000000FF;
        pOldFormat->dwLuminanceBitCount     = 16;
        break;

    case D3DFMT_A4L4:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x000000F0;
        pOldFormat->dwLuminanceBitMask      = 0x0000000F;
        pOldFormat->dwLuminanceBitCount     = 8;
        break;

    case D3DFMT_V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_L6V5U5:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x0000FC00;
        pOldFormat->dwBumpDvBitMask        = 0x000003E0;
        pOldFormat->dwBumpDuBitMask        = 0x0000001F;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_X8L8V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x00FF0000;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 32;
        break;

    case D3DFMT_A8:
        pOldFormat->dwFlags                = DDPF_ALPHA;
        pOldFormat->dwAlphaBitDepth        = 8;
        break;

    case D3DFMT_D16:
    case D3DFMT_D16_LOCKABLE:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D32:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D15S1:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFE;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x0001;
        break;
    case D3DFMT_D24S8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF;
        break;
    case D3DFMT_S1D15:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0x7FFF;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x8000;
        break;
    case D3DFMT_S8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF000000;
        break;
    case D3DFMT_X8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X4S4:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0000000F;
        break;
    case D3DFMT_X4S4D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0F000000;
        break;

    default:
        // All other formats are treated as a
        // FOURCC
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        break;
    }

    return;
}

/*****************************Private*Routine******************************\
* DdConvertFromOldFormat
*
* History:
*  13-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

void ConvertFromOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT *pNewFormat)
{
    *pNewFormat = D3DFMT_UNKNOWN;
    if (pOldFormat->dwFlags & DDPF_FOURCC)
    {
        ((DWORD)*pNewFormat) = pOldFormat->dwFourCC;
    }
    else if (pOldFormat->dwFlags == DDPF_RGB)
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 8:
            if ((pOldFormat->dwRBitMask == 0x000000e0) &&
                (pOldFormat->dwGBitMask == 0x0000001c) &&
                (pOldFormat->dwBBitMask == 0x00000003))
            {
                *pNewFormat = D3DFMT_R3G3B2;
            }
            else
            {
                *pNewFormat = D3DFMT_P8;
            }
            break;

        case 16:
            if ((pOldFormat->dwRBitMask == 0x0000f800) &&
                (pOldFormat->dwGBitMask == 0x000007e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_R5G6B5;
            }
            else if ((pOldFormat->dwRBitMask == 0x00007c00) &&
                (pOldFormat->dwGBitMask == 0x000003e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_X1R5G5B5;
            }
            else if ((pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_X4R4G4B4;
            }
            break;

        case 24:
            if ((pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_R8G8B8;
            }
            break;

        case 32:
            if ((pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_X8R8G8B8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_RGB | DDPF_ALPHAPIXELS))
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 16:
            if ((pOldFormat->dwRGBAlphaBitMask == 0x0000FF00) &&
                (pOldFormat->dwRBitMask == 0x000000e0) &&
                (pOldFormat->dwGBitMask == 0x0000001c) &&
                (pOldFormat->dwBBitMask == 0x00000003))
            {
                *pNewFormat = D3DFMT_A8R3G3B2;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x0000f000) &&
                (pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_A4R4G4B4;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x0000FF00) &&
                (pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_A4R4G4B4;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x00008000) &&
                (pOldFormat->dwRBitMask == 0x00007c00) &&
                (pOldFormat->dwGBitMask == 0x000003e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_A1R5G5B5;
            }
            break;

        case 32:
            if ((pOldFormat->dwRGBAlphaBitMask == 0xff000000) &&
                (pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_A8R8G8B8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_ALPHA)
    {
        if (pOldFormat->dwAlphaBitDepth == 8)
        {
            *pNewFormat = D3DFMT_A8;
        }
    }
    else if (pOldFormat->dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_RGB))
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 8:
            if (pOldFormat->dwFlags == (DDPF_PALETTEINDEXED8 | DDPF_RGB))
            {
                *pNewFormat = D3DFMT_P8;
            }
            break;

        case 16:
            if (pOldFormat->dwFlags == (DDPF_PALETTEINDEXED8 |
                                        DDPF_RGB             |
                                        DDPF_ALPHAPIXELS) &&
                pOldFormat->dwRGBAlphaBitMask == 0xFF00)
            {

                *pNewFormat = D3DFMT_A8P8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_ZBUFFER)
    {
        switch (pOldFormat->dwZBufferBitDepth)
        {
        case 32:
            if (pOldFormat->dwZBitMask == 0xffffffff)
            {
                *pNewFormat = D3DFMT_D32;
            }
            else if (pOldFormat->dwZBitMask == 0x00FFFFFF)
            {
                *pNewFormat = D3DFMT_X8D24;
            }
            else if (pOldFormat->dwZBitMask == 0xFFFFFF00)
            {
                *pNewFormat = D3DFMT_D24X8;
            }
            break;

        case 16:
            if (pOldFormat->dwZBitMask == 0xffff)
            {
                *pNewFormat = D3DFMT_D16;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_ZBUFFER | DDPF_STENCILBUFFER))
    {
        switch (pOldFormat->dwZBufferBitDepth)
        {
        case 32:
            if ((pOldFormat->dwZBitMask == 0xffffff00) &&
                (pOldFormat->dwStencilBitMask == 0x000000ff) &&
                (pOldFormat->dwStencilBitDepth == 8))
            {
                *pNewFormat = D3DFMT_D24S8;
            }
            else if ((pOldFormat->dwZBitMask == 0x00ffffff) &&
                (pOldFormat->dwStencilBitMask == 0xff000000) &&
                (pOldFormat->dwStencilBitDepth == 8))
            {
                *pNewFormat = D3DFMT_S8D24;
            }
            break;
        case 16:
            if ((pOldFormat->dwZBitMask == 0xfffe) &&
                (pOldFormat->dwStencilBitMask == 0x0001) &&
                (pOldFormat->dwStencilBitDepth == 1))
            {
                *pNewFormat = D3DFMT_D15S1;
            }
            else if ((pOldFormat->dwZBitMask == 0x7fff) &&
                (pOldFormat->dwStencilBitMask == 0x8000) &&
                (pOldFormat->dwStencilBitDepth == 1))
            {
                *pNewFormat = D3DFMT_S1D15;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_LUMINANCE)
    {
        switch (pOldFormat->dwLuminanceBitCount)
        {
        case 8:
            if (pOldFormat->dwLuminanceBitMask == 0xFF)
            {
                *pNewFormat = D3DFMT_L8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_LUMINANCE | DDPF_ALPHAPIXELS))
    {
        switch (pOldFormat->dwLuminanceBitCount)
        {
        case 8:
            if (pOldFormat->dwLuminanceBitMask      == 0x0F &&
                pOldFormat->dwLuminanceAlphaBitMask == 0xF0)
            {
                *pNewFormat = D3DFMT_A4L4;
            }
        case 16:
            if (pOldFormat->dwLuminanceBitMask      == 0x00FF &&
                pOldFormat->dwLuminanceAlphaBitMask == 0xFF00)
            {
                *pNewFormat = D3DFMT_A8L8;
            }

            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_BUMPDUDV)
    {
        switch (pOldFormat->dwBumpBitCount)
        {
        case 16:
            if (pOldFormat->dwBumpDuBitMask == 0xFF &&
                pOldFormat->dwBumpDvBitMask == 0xFF00)
            {
                *pNewFormat = D3DFMT_V8U8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_BUMPDUDV | DDPF_BUMPLUMINANCE))
    {
        switch (pOldFormat->dwBumpBitCount)
        {
        case 16:
            if (pOldFormat->dwBumpDuBitMask        == 0x001F &&
                pOldFormat->dwBumpDvBitMask        == 0x03E0 &&
                pOldFormat->dwBumpLuminanceBitMask == 0xFC00)
            {
                *pNewFormat = D3DFMT_L6V5U5;
            }
            break;

        case 32:
            if (pOldFormat->dwBumpDuBitMask        == 0x0000FF &&
                pOldFormat->dwBumpDvBitMask        == 0x00FF00 &&
                pOldFormat->dwBumpLuminanceBitMask == 0xFF0000)
            {
                *pNewFormat = D3DFMT_X8L8V8U8;
            }
            break;
        }
    }
}

// How lost devices work:
//
// Device can be lost two ways:
// 1)  A mode change or something occurs, in which DDraw knows about it and
//     calls CleanupD3D8.  In this case, we free the surfaces and mark the
//     device as lost.
//
//     This will only happen when the DDRAW critical section is held, so as long
//     as we check for lost devices while the critical section is held, we are
//     safe to use the surface structures.
//
// 2)  A DOS box or something occurs in which case we don't know about it,
//     but we can find out by polling the busy bit.  This can occur at anytime,
//     although we are gaurenteed that it will never happen while we are holding
//     the win16 lock.  In fact, if we don't hold the win16 lock while checking
//     the busy bit, we will get false positives simple by dragging another window
//     around.
//
//  So, we have to grab the busy bit to check for lost, and we need to hold the
//  DDraw critical section throughout the remained of the call since not holding
//  it can cause surfaces to go away out from under us.  Also, when calling HAL
//  we always grab the win16 lock, so in each call we could be grabbing it twice.
//  With all of this in mind, it's probably better just to ENTER_BOTH() before
//  we check for device lost and then LEAVE_BOTH() at the end of the funtion.
//
//  We can also remove the busybit check from the HAL call since we already know
//  that it's not set since we checked it and are still holding the win16 lock, so
//  nobody else can set.

void LoseDevice (DDDEVICEHANDLE* pDevice)
{
    DDSURFACE*      pSurf;
    if (!pDevice->bDeviceLost)
    {
        // The device has transitioned to the lost state, so we need
        // walk through the list and free the vidmem surfaces..

        pDevice->bDeviceLost  = TRUE;
        pSurf = pDevice->pSurfList;
        while (pSurf != NULL)
        {
            if (IS_SURFACE_LOOSABLE(pSurf))
            {
                FreeSurfaceObject(pSurf, FALSE);
            }
            pSurf = pSurf->pNext;
        }
    }
}


BOOL CheckForDeviceLost (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFACE      pSurf;

    if (pDeviceHandle->bDeviceLost)
    {
        return TRUE;
    }

    // The below check will only be reliable if we are holding the win16 lock.
    // if dwWin16LockCnt != 0 that means BUSY bit was set by DdLock
    if ( 0 == pDeviceHandle->pDD->lpLcl->lpGbl->dwWin16LockCnt &&
        (*(pDeviceHandle->pDD->lpLcl->lpGbl->lpwPDeviceFlags) & BUSY )
       )
    {
        LoseDevice(pDeviceHandle);
        return TRUE;
    }

    return FALSE;
}


DWORD WINAPI DdBlt( PD3D8_BLTDATA pBlt )
{
    DDSURFACE*      pSrcSurf = (DDSURFACE*) pBlt->hSrcSurface;
    DDSURFACE*      pDstSurf = (DDSURFACE*) pBlt->hDestSurface;
    PDDDEVICEHANDLE pDevice  = (PDDDEVICEHANDLE) pBlt->hDD;

    // Return failure on bad paths
    pBlt->ddRVal = E_FAIL;

    ENTER_BOTH();
    if (CheckForDeviceLost(pBlt->hDD))
    {
        // Some blts should fail, others should succeed:
        // persistant -> non persitant : OK
        // persistant -> persitant : FAIL
        // non persistant -> persistant : FAIL
        // non persistant -> non persistant : OK

        if ((pDstSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pDstSurf->Pool == D3DPOOL_NONLOCALVIDMEM))
        {
            pBlt->ddRVal = DD_OK;
        }
        else
        {
            pBlt->ddRVal = D3DERR_DEVICELOST;
        }
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

#ifdef DEBUG
    // Just a colorfill? Used only in debug for
    // enforcing DISCARD
    if (pSrcSurf == NULL)
    {
        LPDDRAWI_DDRAWSURFACE_INT   pHeavyDst;

        pHeavyDst = GetHeavyweightSurf(pDstSurf);
        if (pHeavyDst != NULL)
        {
            pBlt->bltFX.dwSize = sizeof(DDBLTFX);
            pBlt->ddRVal = DD_Surface_Blt((LPDIRECTDRAWSURFACE)pHeavyDst,
                                           NULL,
                                           NULL,
                                           NULL,
                                           pBlt->dwFlags,
                                           &pBlt->bltFX);
            if (FAILED(pBlt->ddRVal))
            {
                DPF_ERR("Driver failed color-fill blt");
            }

            DONE_HEAVYWEIGHT_SURF(pDstSurf);
        }

        pBlt->ddRVal = S_OK;

        LEAVE_BOTH();
        return S_OK;
    }
#endif 

    if (DDBLT_COPYVSYNC & pBlt->dwFlags) 
    {
        DWORD                msCurrentTime;
        DWORD                threshold;

        // Compute how many milliseconds there
        // are per refresh. We round down.
        if (pDevice->pDD->lpLcl->lpGbl->dwMonitorFrequency == 0)
        {
            // 60Hz = 16.666ms per frame
            // 75Hz = 13.333ms
            // 85Hz = 11.765ms
            threshold = 13;
        }
        else
        {
            threshold = (DWORD)(1000.0f / 
                    (float)(pDevice->pDD->lpLcl->lpGbl->dwMonitorFrequency)); 
        }

        while (1)
        {
            msCurrentTime = GetTickCount();
    
            // If the previous blt was long
            // enough ago i.e. a refresh, then
            // we can break out this loop
            if ((msCurrentTime - pBlt->msLastPresent) > threshold )
                break;
        }

        // For DDBLT_COPYVSYNC remember the
        // time for this blt was sent
        pBlt->msLastPresent = msCurrentTime;
    }

    if ((pSrcSurf) && (pDstSurf))
    {
        if ((pSrcSurf->Format == pDstSurf->Format ||
            (pBlt->dwFlags & DDBLT_WINDOWCLIP)) &&
            !IS_SOFTWARE_DRIVER_SURFACE(pSrcSurf) &&
            !IS_SOFTWARE_DRIVER_SURFACE(pDstSurf))
        {
            LPDDRAWI_DDRAWSURFACE_INT   pHeavySrc;
            LPDDRAWI_DDRAWSURFACE_INT   pHeavyDst;
            DWORD                       dwFlags = pBlt->dwFlags & ~DDBLT_WINDOWCLIP;

            pHeavySrc = GetHeavyweightSurf(pSrcSurf);
            if (pHeavySrc == NULL)
            {
                pBlt->ddRVal = DDERR_OUTOFMEMORY;
                LEAVE_BOTH();
                return DDHAL_DRIVER_HANDLED;
            }
            pHeavyDst = GetHeavyweightSurf(pDstSurf);
            if (pHeavyDst == NULL)
            {
                DONE_HEAVYWEIGHT_SURF(pSrcSurf);
                pBlt->ddRVal = DDERR_OUTOFMEMORY;
                LEAVE_BOTH();
                return DDHAL_DRIVER_HANDLED;
            }
    
            if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
            {
               LPDDRAWI_DDRAWCLIPPER_INT pcClipper = pHeavyDst->lpLcl->lpSurfMore->lpDDIClipper;

               DDASSERT(IsWindow(pBlt->hWnd));
               DDASSERT(DDSCAPS_PRIMARYSURFACE & pHeavyDst->lpLcl->ddsCaps.dwCaps);
               DDASSERT(pcClipper);
               if (pcClipper)
               {
                    (HWND) pcClipper->lpLcl->lpGbl->hWnd = pBlt->hWnd;
                    dwFlags |= DDBLT_WINDOWCLIP;
                    DPF(10,"Updated hWnd=%08lx", pBlt->hWnd);
                }
            }
            pBlt->bltFX.dwSize = sizeof(DDBLTFX);
            pBlt->bltFX.dwROP = SRCCOPY;
            pBlt->ddRVal = DD_Surface_Blt((LPDIRECTDRAWSURFACE)pHeavyDst,
                                           (LPRECT) &(pBlt->rDest),
                                           (LPDIRECTDRAWSURFACE)pHeavySrc,
                                           (LPRECT) &(pBlt->rSrc),
                                           dwFlags,
                                           &pBlt->bltFX);
            DONE_HEAVYWEIGHT_SURF(pSrcSurf);
            DONE_HEAVYWEIGHT_SURF(pDstSurf);
        }
        if (FAILED(pBlt->ddRVal))
        {
            // !!! Just use GetDC on the DirectDraw surface for now, though this is
            // probably way too slow on drivers which do not support derived
            // surfaces. DirectDraw Blt support should be added soon.
            HDC hDCTarget;
            if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
                hDCTarget = GetDC(pBlt->hWnd);
            else
                hDCTarget = D3D8GetDC(pBlt->hDestSurface, NULL);
            if (hDCTarget != NULL)
            {
                HDC hDCSource = D3D8GetDC(pBlt->hSrcSurface, NULL);
                if (hDCSource != NULL)
                {
                    LONG DestWidth=pBlt->rDest.right - pBlt->rDest.left;
                    LONG DestHeight= pBlt->rDest.bottom - pBlt->rDest.top;
                    LONG SrcWidth= pBlt->rSrc.right - pBlt->rSrc.left;
                    LONG SrcHeight= pBlt->rSrc.bottom - pBlt->rSrc.top;
                    if (DestWidth == SrcWidth && DestHeight == SrcHeight)
                    {
                        if (BitBlt(
                            hDCTarget,
                            pBlt->rDest.left,
                            pBlt->rDest.top,
                            DestWidth,
                            DestHeight,
                            hDCSource,
                            pBlt->rSrc.left,
                            pBlt->rSrc.top,
                            SRCCOPY))
                        {
                            pBlt->ddRVal = S_OK;
                        }
                    }
                    else
                    {
                        // COLORONCOLOR is not the default in NT
                        int saved = SetStretchBltMode(hDCTarget,COLORONCOLOR);
                        if (StretchBlt(
                            hDCTarget,
                            pBlt->rDest.left,
                            pBlt->rDest.top,
                            DestWidth,
                            DestHeight,
                            hDCSource,
                            pBlt->rSrc.left,
                            pBlt->rSrc.top,
                            SrcWidth,
                            SrcHeight,
                            SRCCOPY))
                        {
                            pBlt->ddRVal = S_OK;
                        }
                        // restore to previous mode
                        if (saved)
                            SetStretchBltMode(hDCTarget,saved);
                    }
                    D3D8ReleaseDC(pBlt->hSrcSurface, hDCSource);
                }
                if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
                    ReleaseDC(pBlt->hWnd, hDCTarget);
                else
                    D3D8ReleaseDC(pBlt->hDestSurface, hDCTarget);
            }
        }

        // We only want to report DP2 errors  during the present call because
        // checking for it everywhere is too hard.
        if ((pBlt->ddRVal == DD_OK) &&
            (pDevice->bDP2Error) &&
            (pBlt->dwFlags & DDBLT_WINDOWCLIP))
        {
            pDevice->bDP2Error = FALSE;

            // We use a special error here to mean that the blt succeeded
            // but that that some DP2 failed since the last present
            pBlt->ddRVal = D3DERR_DEFERRED_DP2ERROR;
        }

        LEAVE_BOTH();

        pBlt->ddRVal = MapLegacyResult(pBlt->ddRVal);
        return DDHAL_DRIVER_HANDLED;
    }
    LEAVE_BOTH();

    pBlt->ddRVal = MapLegacyResult(pBlt->ddRVal);
    return DDHAL_DRIVER_NOTHANDLED;
}

DWORD APIENTRY DdFlip( PD3D8_FLIPDATA pFlip )
{
    DDSURFACE*      pCurrSurf = (DDSURFACE*) pFlip->hSurfCurr;
    DDSURFACE*      pTargSurf = (DDSURFACE*) pFlip->hSurfTarg;

    ENTER_BOTH();
    if (CheckForDeviceLost(pFlip->hDD))
    {
        LEAVE_BOTH();
        pFlip->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    if ((pCurrSurf) && (pCurrSurf->dwFlags & DDSURFACE_HEAVYWEIGHT) &&
        (pTargSurf) && (pTargSurf->dwFlags & DDSURFACE_HEAVYWEIGHT))
    {
        pFlip->ddRVal = MapLegacyResult( DD_Surface_Flip((LPDIRECTDRAWSURFACE)pCurrSurf->Surface.pHeavy,
                           (LPDIRECTDRAWSURFACE)pTargSurf->Surface.pHeavy,
                           pFlip->dwFlags));
        if (SUCCEEDED(pFlip->ddRVal))
        {
            DDSURFACE Temp;

            // The DirectX runtime swaps the surface handles when it flips, so we
            // need to swap them back to preserve the integrity
        
            Temp = *pCurrSurf;

            DDASSERT(pCurrSurf->Pitch == pTargSurf->Pitch);
            DDASSERT(pCurrSurf->Pool == pTargSurf->Pool);
            DDASSERT(pCurrSurf->Type == pTargSurf->Type);
            DDASSERT(pCurrSurf->Height == pTargSurf->Height);

            pCurrSurf->dwFlags      = pTargSurf->dwFlags;
            pCurrSurf->Surface      = pTargSurf->Surface;
            pCurrSurf->fpVidMem     = pTargSurf->fpVidMem;
            pCurrSurf->pBits        = pTargSurf->pBits;
            pCurrSurf->LockFlags    = pTargSurf->LockFlags;
            pCurrSurf->LockRect     = pTargSurf->LockRect;

            pTargSurf->dwFlags      = Temp.dwFlags;
            pTargSurf->Surface      = Temp.Surface;
            pTargSurf->fpVidMem     = Temp.fpVidMem;
            pTargSurf->pBits        = Temp.pBits;
            pTargSurf->LockFlags    = Temp.LockFlags;
            pTargSurf->LockRect     = Temp.LockRect;

            // We only want to report DP2 errors  during the present call because
            // checking for it everywhere is too hard.
            if (((DDDEVICEHANDLE*)pFlip->hDD)->bDP2Error)
            {
                ((DDDEVICEHANDLE*)pFlip->hDD)->bDP2Error = FALSE;

                // We use a special error here to mean that the flip succeeded
                // but that that some DP2 failed since the last present
                pFlip->ddRVal = D3DERR_DEFERRED_DP2ERROR;
            }
        }
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }
    LEAVE_BOTH();
    return DDHAL_DRIVER_NOTHANDLED;
}

DWORD APIENTRY DdLock( PD3D8_LOCKDATA pLock )
{
    PDDSURFACE                  pSurf = (PDDSURFACE) pLock->hSurface;
    HRESULT                     hr;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyInt;

    // Mask off new flags
    pLock->dwFlags &= (D3DLOCK_READONLY         |
                       D3DLOCK_DISCARD          |   
                       D3DLOCK_NOOVERWRITE      |
                       D3DLOCK_NOSYSLOCK);         

    // Always turn on Wait
    pLock->dwFlags |= DDLOCK_WAIT;

    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        DWORD Width;

        if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
        {
            pLock->lpSurfData = (LPVOID) pSurf->Surface.pLight->fpGblVidMem;
            pLock->lPitch = pSurf->Surface.pLight->GblPitch;
            Width = pSurf->Surface.pLight->GblWidth;
        }
        else
        {
            ENTER_DDRAW();
            pLock->lpSurfData = (LPVOID) pSurf->Surface.pHeavy->lpLcl->lpGbl->fpVidMem;
            pLock->lPitch = pSurf->Surface.pHeavy->lpLcl->lpGbl->lPitch;
            Width = (DWORD) pSurf->Surface.pHeavy->lpLcl->lpGbl->wWidth;
            LEAVE_DDRAW();
        }

        if (pLock->bHasRange)
        {
            ((BYTE*)pLock->lpSurfData) += pLock->lPitch * pLock->range.Offset;
        }
        else if (pLock->bHasRect)
        {
            ((BYTE*)pLock->lpSurfData) += pLock->lPitch * pLock->rArea.top;
            ((BYTE*)pLock->lpSurfData) += (pLock->lPitch / Width) * pLock->rArea.left;
        }
        hr = DD_OK;
    }

    else if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        ENTER_DDRAW();
        pHeavyInt = GetHeavyweightSurf(pSurf);
        if (pHeavyInt == NULL)
        {
            // This can be caused by an out of memory condition when calling
            // MapLightweightSurface

            hr = DDERR_OUTOFMEMORY;
        }
        else
        {
            if(pLock->bHasRange)
            {
                pLock->bHasRange = FALSE;
                pLock->bHasRect = TRUE;
                pLock->rArea.left = 0;
                pLock->rArea.right = 0;
                pLock->rArea.top = pLock->range.Offset;
                pLock->rArea.bottom = pLock->range.Offset + pLock->range.Size;
            }

            hr = SwDDILock (pLock->hDD, pSurf, pLock, pHeavyInt->lpLcl);
            pLock->lPitch = pHeavyInt->lpLcl->lpGbl->lPitch;
        }
        LEAVE_DDRAW();
    }
    else 
    {
        ENTER_BOTH();
        if ((CheckForDeviceLost(pLock->hDD) &&
             pSurf->Pool != D3DPOOL_MANAGED) ||
            (pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED))
        {
            DWORD Height = pSurf->Height;
            if (Height == 0)
            {
                Height++;
            }

            if ((pSurf->fpVidMem == NULL) ||
                !(pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED))
            {
                DDASSERT(pSurf->Pool != D3DPOOL_MANAGED);
                if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                    (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
                {
                    // For volumes, height actually contains the depth
                    pSurf->fpVidMem = (char*) MemAlloc(
                        pSurf->iSlicePitch * Height);
                }
                else
                {
                    pSurf->fpVidMem = (char*)MemAlloc(pSurf->Pitch * Height);
                }
                if (pSurf->fpVidMem != NULL)
                {
                    pSurf->dwFlags |= DDSURFACE_SYSMEMALLOCATED;
                }
            }

            if (pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED)
            {
                DDASSERT(CheckForDeviceLost(pLock->hDD));

                pLock->lPitch = pSurf->Pitch;
                pLock->lpSurfData = pSurf->fpVidMem;
                pSurf->dwFlags |= DDSURFACE_SYSMEMLOCK;

                if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                    (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
                {
                    pLock->lSlicePitch = pSurf->iSlicePitch;
                }

                hr = DD_OK;
            }
            else
            {
                hr = DDERR_GENERIC;
            }
        }
        else
        {
            pHeavyInt = GetHeavyweightSurf(pSurf);
            if (pHeavyInt == NULL)
            {
                // This can be caused by an out of memory condition when calling
                // MapLightweightSurface
    
                hr = DDERR_OUTOFMEMORY;
            }
            else
            {
                if(pLock->bHasRange)
                {
                    pLock->bHasRect = TRUE;
                    pSurf->LockRect.left = 0;
                    pSurf->LockRect.right = 0;
                    pSurf->LockRect.top = pLock->range.Offset;
                    pSurf->LockRect.bottom = pLock->range.Offset + pLock->range.Size;
                }
                else
                {
                    pSurf->LockRect.left    = pLock->rArea.left;
                    pSurf->LockRect.right   = pLock->rArea.right;
                    pSurf->LockRect.top     = pLock->rArea.top;
                    pSurf->LockRect.bottom  = pLock->rArea.bottom;
                }
                if (pLock->bHasBox)
                {
                    pLock->bHasRect = TRUE;
                    pSurf->LockRect.left = pLock->box.Left;
                    pSurf->LockRect.right = pLock->box.Right;
                    pSurf->LockRect.top = pLock->box.Top;
                    pSurf->LockRect.bottom = pLock->box.Bottom;
                    pSurf->LockRect.left |= (pLock->box.Front << 16);
                    pSurf->LockRect.right |= (pLock->box.Back << 16);
                }

                hr = InternalLock (pHeavyInt->lpLcl,
                                   &pLock->lpSurfData,
                                   pLock->bHasRect ? &pSurf->LockRect : NULL,
                                   pLock->dwFlags | DDLOCK_NOSYSLOCK | (pSurf->Pool == D3DPOOL_MANAGED ? 0 : DDLOCK_TAKE_WIN16));

                if (hr == DD_OK)
                {
                    pLock->lPitch = pHeavyInt->lpLcl->lpGbl->lPitch;
                    pSurf->pBits = pLock->lpSurfData;
                    pSurf->LockFlags = pLock->dwFlags;
                    if (pLock->bHasRect)
                    {
                        pSurf->dwFlags |= DDSURFACE_LOCKRECT;
                    }
                }
            }
        }
        LEAVE_BOTH();
    }

    if ((pSurf->Type == D3DRTYPE_VOLUME) ||
        (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        pLock->lSlicePitch = pSurf->iSlicePitch;
    }

    return MapLegacyResult(hr);
}


DWORD APIENTRY DdUnlock( PD3D8_UNLOCKDATA pUnlock )
{
    PDDSURFACE                  pSurf = (PDDSURFACE) pUnlock->hSurface;
    HRESULT                     hr = DDERR_GENERIC;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        hr = DD_OK;
    }
    else
    {
        if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
        {
            ENTER_DDRAW();
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {
                pHeavy = GET_CACHED_LIGHTWEIGHT_INT(pSurf);
                DDASSERT(pHeavy != NULL);
            }
            else
            {
                pHeavy = pSurf->Surface.pHeavy;
            }
            hr = SwDDIUnlock (pUnlock->hDD, pSurf, pUnlock, pHeavy->lpLcl);

            DONE_HEAVYWEIGHT_SURF(pSurf);
            LEAVE_DDRAW();
        }
        else
        {    
            if (pSurf->dwFlags & DDSURFACE_SYSMEMLOCK)
            {
                pSurf->dwFlags &= ~DDSURFACE_SYSMEMLOCK;
                hr = DD_OK;
            }
            else if (pSurf->LockFlags)
            {
                ENTER_BOTH();
                if (CheckForDeviceLost(pUnlock->hDD) && pSurf->Pool != D3DPOOL_MANAGED)
                {
                    hr = DD_OK;
                }
                else
                {
                    if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                    {
                        pHeavy = GET_CACHED_LIGHTWEIGHT_INT(pSurf);
                        DDASSERT(pHeavy != NULL);
                    }
                    else
                    {
                        pHeavy = pSurf->Surface.pHeavy;
                    }

                    hr = InternalUnlock (pHeavy->lpLcl,
                                         (pSurf->dwFlags & DDSURFACE_LOCKRECT) ? NULL : pSurf->pBits,
                                         (pSurf->dwFlags & DDSURFACE_LOCKRECT) ? &pSurf->LockRect : NULL,
                                         pSurf->LockFlags | DDLOCK_NOSYSLOCK | (pSurf->Pool == D3DPOOL_MANAGED ? 0 : DDLOCK_TAKE_WIN16));
                    pSurf->LockFlags = 0;
                    pSurf->dwFlags &= ~DDSURFACE_LOCKRECT;

                    DONE_HEAVYWEIGHT_SURF(pSurf);
                }
                LEAVE_BOTH();
            }
        }
    }
    return MapLegacyResult(hr);
}

DWORD APIENTRY DdGetBltStatus( PD3D8_GETBLTSTATUSDATA pGetBltStatus )
{
    PDDDEVICEHANDLE         pDevice = (PDDDEVICEHANDLE) pGetBltStatus->hDD;
    PDDSURFACE              pSurf = (PDDSURFACE) pGetBltStatus->hSurface;
    DDHAL_GETBLTSTATUSDATA  gbsd;
    LPDDHALSURFCB_GETBLTSTATUS  gbsfn;

    // Software drivers will only do memcpy, so we don't need to call
    // the driver

    pGetBltStatus->ddRVal = DD_OK;
    if (IS_SOFTWARE_DRIVER(pDevice))
    {
        return DDHAL_DRIVER_HANDLED;
    }

    ENTER_BOTH();
    pGetBltStatus->ddRVal = DD_OK;
    if (CheckForDeviceLost(pDevice))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    /*
    gbsfn = pDevice->pDD->lpLcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus;
    gbsd.GetBltStatus = pDevice->pDD->lpLcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus;

    if( gbsd.GetBltStatus != NULL )
    {
        DWORD                           rc;

        gbsd.lpDD = pDevice->pDD->lpLcl->lpGbl;
        gbsd.dwFlags = pGetBltStatus->dwFlags;
        gbsd.lpDDSurface = pSurf->Surface.pHeavy->lpLcl;
        DOHALCALL( GetBltStatus, gbsfn, gbsd, rc, FALSE );
        if( rc == DDHAL_DRIVER_HANDLED )
        {
            pGetBltStatus->ddRVal = gbsd.ddRVal;
        }
    }
    */

    LEAVE_BOTH();
    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdGetFlipStatus( PD3D8_GETFLIPSTATUSDATA pGetFlipStatus )
{
    DPF_ERR("DdGetFlipStatus");
    return DD_OK;
}

DWORD APIENTRY DdSetMode( PD3D8_SETMODEDATA pSetMode )
{
    UINT    BPP;
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) pSetMode->hDD;

    pSetMode->ddRVal = D3DERR_DRIVERINTERNALERROR;

    switch (pSetMode->Format)
    {
    case D3DFMT_P8:
        BPP = 8;
        break;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
        BPP = 16;
        break;

    case D3DFMT_R8G8B8:
        BPP = 24;
        break;

    case D3DFMT_A8R8G8B8:
    case D3DFMT_X8R8G8B8:
        BPP = 32;
        break;

    default:
        return DDHAL_DRIVER_HANDLED;
    }

    pSetMode->ddRVal = D3D8SetMode((HANDLE)pDeviceHandle,
                                   pDeviceHandle->szDeviceName,
                                   pSetMode->dwWidth,
                                   pSetMode->dwHeight,
                                   BPP,
                                   pSetMode->dwRefreshRate,
                                   FALSE);

    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdDestroyDDLocal( PD3D8_DESTROYDDLOCALDATA pDestroyDDLocal )
{
    DPF_ERR("DdDestroyDDLocal");
    return DD_OK;
}

DWORD APIENTRY DdWaitForVerticalBlank( PD3D8_WAITFORVERTICALBLANKDATA pWaitForVerticalBlank )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pWaitForVerticalBlank->hDD;
    LPDDHAL_WAITFORVERTICALBLANK    wfvbhalfn;
    LPDDHAL_WAITFORVERTICALBLANK    wfvbfn;
    DWORD                           dwRet = DDHAL_DRIVER_HANDLED;

    ENTER_BOTH();
    if (CheckForDeviceLost(pDevice))
    {
        static int LostTestVerticalBlank;

        pWaitForVerticalBlank->ddRVal = DD_OK;
        if (pWaitForVerticalBlank->dwFlags == DDWAITVB_I_TESTVB)
        {
            if (LostTestVerticalBlank > 0)
            {
                pWaitForVerticalBlank->bIsInVB = TRUE;
            }
            else
            {
                pWaitForVerticalBlank->bIsInVB = FALSE;
            }
            LostTestVerticalBlank = LostTestVerticalBlank == 0 ? 1 : 0;
        }
        else if (pWaitForVerticalBlank->dwFlags == DDWAITVB_BLOCKEND)
        {
            pWaitForVerticalBlank->bIsInVB = FALSE;
        }
        else
        {
            pWaitForVerticalBlank->bIsInVB = TRUE;
        }
    }
    else
    {
        wfvbfn = pDevice->pDD->lpLcl->lpDDCB->HALDD.WaitForVerticalBlank;
        wfvbhalfn = pDevice->pDD->lpLcl->lpDDCB->cbDDCallbacks.WaitForVerticalBlank;
        dwRet = DDHAL_DRIVER_NOTHANDLED;
        if( wfvbhalfn != NULL )
        {
            DDHAL_WAITFORVERTICALBLANKDATA  wfvbd;

            wfvbd.WaitForVerticalBlank = wfvbhalfn;
            wfvbd.lpDD = pDevice->pDD->lpLcl->lpGbl;
            wfvbd.dwFlags = pWaitForVerticalBlank->dwFlags;
            wfvbd.hEvent = (ULONG_PTR) NULL;
            DOHALCALL( WaitForVerticalBlank, wfvbfn, wfvbd, dwRet, FALSE );
            if (dwRet == DDHAL_DRIVER_HANDLED)
            {
                pWaitForVerticalBlank->ddRVal = MapLegacyResult(wfvbd.ddRVal);
                if (wfvbd.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
                {
                    pWaitForVerticalBlank->ddRVal = DD_OK;
                    pWaitForVerticalBlank->bIsInVB = TRUE;                   
                }
                else
                {
                    pWaitForVerticalBlank->bIsInVB = FALSE;                   
                }
            }
        }
    }
    LEAVE_BOTH();
    return dwRet;
}

void BuildSurfaceDesc( PD3D8_CREATESURFACEDATA pCreateSurface, DDSURFACEDESC2* pddsd2 )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = pDevice->pDD;
    HRESULT                     hr;
    DWORD                       i;
    PDDSURFACE                  pSurf;
    LPDIRECTDRAWSURFACE         lpDDSurface;

    memset(pddsd2, 0, sizeof(DDSURFACEDESC2));
    pddsd2->dwSize = sizeof( DDSURFACEDESC2 );

    //dwCaps3==1 means 1 sample per pixel.
    pddsd2->ddsCaps.dwCaps3 = DDSCAPS3_MULTISAMPLE_MASK & (DWORD) pCreateSurface->MultiSampleType;

    // Convert all of the caps
    switch (pCreateSurface->Type)
    {
    case D3DRTYPE_SURFACE:

        if (pCreateSurface->dwUsage & D3DUSAGE_ALPHACHANNEL)
        {
            DPF(0,"Setting alphachannel");
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_ENABLEALPHACHANNEL;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE)
        {
            // If we aren't creating a primary flip chain, then we
            // don't have to do much here.

            if (pCreateSurface->dwSCnt == 1)
            {
                pddsd2->ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE;
            }
            else
            {
                pddsd2->ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE |
                                          DDSCAPS_COMPLEX |
                                          DDSCAPS_FLIP |
                                          DDSCAPS_3DDEVICE;
            }
        }
        else if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
        {
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
        }
        else
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
        }

        if (pCreateSurface->dwSCnt > 1)
        {
            pddsd2->dwBackBufferCount = pCreateSurface->dwSCnt - 1;
            pddsd2->dwFlags |= DDSD_BACKBUFFERCOUNT;
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_COMPLEX;
        }

        break;
    case D3DRTYPE_TEXTURE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        if (pCreateSurface->dwSCnt > 1)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_MIPMAP | DDSCAPS_COMPLEX;
            pddsd2->dwFlags |= DDSD_MIPMAPCOUNT;
            pddsd2->dwMipMapCount = pCreateSurface->dwSCnt;
        }
        else
        {
            // To DDraw, a mipmap w/ one level is really only a texture
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
        }
        break;
    case D3DRTYPE_CUBETEXTURE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_COMPLEX;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_CUBEMAP;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_CUBEMAP_ALLFACES;

        DDASSERT(pCreateSurface->dwSCnt >= 6);
        DDASSERT((pCreateSurface->dwSCnt % 6) == 0);

        if (pCreateSurface->dwSCnt > 6)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_MIPMAP;
            pddsd2->dwFlags        |= DDSD_MIPMAPCOUNT;
            pddsd2->dwMipMapCount   = pCreateSurface->dwSCnt / 6;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
        }
        break;
    case D3DRTYPE_IMAGESURFACE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        // Image surfaces are marked as textures since they have the
        // greatest flexibility for formats. But they don't get
        // a CreateSurfaceEx handle since they are never passed to
        // a driver.
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
        break;


    case D3DRTYPE_COMMANDBUFFER:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_COMMANDBUFFER;
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
        DDASSERT((pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER) == 0);
        break;
    case D3DRTYPE_VERTEXBUFFER:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
        if (!(pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER))
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_VERTEXBUFFER;
        }
        if (pDevice->DriverLevel >= 8)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }
            else
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTSTATIC;
            }
        }
        break;
    case D3DRTYPE_INDEXBUFFER:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_INDEXBUFFER;
        if (pDevice->DriverLevel >= 8)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }
            else
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTSTATIC;
            }
        }
        break;
    case D3DRTYPE_VOLUME:
        // We don't create stand-alone volumes
        DDASSERT(FALSE);
        break;
    case D3DRTYPE_VOLUMETEXTURE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_VOLUME;
        pddsd2->ddsCaps.dwCaps4 =
            MAKELONG((WORD)(pCreateSurface->pSList[0].cpDepth),0);

        if (pCreateSurface->dwSCnt > 1)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_COMPLEX;
            pddsd2->dwFlags        |= DDSD_MIPMAPCOUNT;
        }
        pddsd2->dwMipMapCount = pCreateSurface->dwSCnt;

        if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
        }
        break;
    }

    if (pCreateSurface->dwUsage & D3DUSAGE_RENDERTARGET)
    {
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_3DDEVICE;
    }
    if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
    {
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
    }
    if (pDevice->DriverLevel >= 8)
    {
        if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_OPAQUE;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
        }

        // Specify new usages for DX8+ drivers
        if (!(pCreateSurface->dwUsage & D3DUSAGE_LOCK) &&
            !(pCreateSurface->dwUsage & D3DUSAGE_LOADONCE))
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_NOTUSERLOCKABLE;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_DISCARD)
        {
            DDASSERT(pCreateSurface->Type != D3DRTYPE_TEXTURE);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_CUBETEXTURE);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUMETEXTURE);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_VOLUME);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_VERTEXBUFFER);
            DDASSERT(pCreateSurface->Type != D3DRTYPE_INDEXBUFFER);

            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_DISCARDBACKBUFFER;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_POINTS)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_POINTS;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_RTPATCHES)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_RTPATCHES;
        }
        if (pCreateSurface->dwUsage & D3DUSAGE_NPATCHES)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_NPATCHES;
        }
    }
    else // Pre-DX8 driver
    {
        // We allow LOADONCE through only for textures
        if ((pCreateSurface->Type == D3DRTYPE_TEXTURE) || 
            (pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUME))
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_OPAQUE;
            }
        }
        // We allow WRITEONLY through only for VBs
        if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_WRITEONLY)
            {
                pddsd2->ddsCaps.dwCaps |= DDSCAPS_WRITEONLY;
            }
        }
    }

    switch (pCreateSurface->Pool)
    {
    case D3DPOOL_LOCALVIDMEM:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_NONLOCALVIDMEM:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_NONLOCALVIDMEM | DDSCAPS_VIDEOMEMORY;
        break;
    case D3DPOOL_SYSTEMMEM:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        break;
    case D3DPOOL_MANAGED:
        // We should only see this for DX8+ drivers <kd>
        DDASSERT(pDevice->DriverLevel >= 8);            
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_TEXTUREMANAGE;
        break;
    case D3DPOOL_DEFAULT:
        pCreateSurface->Pool = D3DPOOL_LOCALVIDMEM;
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        break;
    default:
        /* Unknown Pool?? */
        DDASSERT(FALSE);
        break;
    }
    pddsd2->dwFlags |= DDSD_CAPS;

    // Convert the pixel format:
    if ((pCreateSurface->Format != D3DFMT_UNKNOWN) &&
        (pCreateSurface->Format != D3DFMT_VERTEXDATA) &&
        (pCreateSurface->Format != D3DFMT_INDEX16) &&
        (pCreateSurface->Format != D3DFMT_INDEX32) &&
        !(pddsd2->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
    {
        pddsd2->dwFlags |= DDSD_PIXELFORMAT;

        // For non-textures, we want to promote X8R8G8B8 to A8R8G8B8 in some cases;
        // this allows things like RTs and Backbuffers to get created matching the
        // primary which is more consistent with typical DX7 usage.
        if (FormatCompatibleWithDisplayFormat(pDevice, (D3DFORMAT)pCreateSurface->Format) &&
            (pCreateSurface->Type == D3DRTYPE_SURFACE))
        {
            //Surface looks like primary:
            ConvertToOldFormat(&pddsd2->ddpfPixelFormat, pDevice->DisplayFormatWithAlpha);
        }
        else
        {
            ConvertToOldFormat(&pddsd2->ddpfPixelFormat, (D3DFORMAT)pCreateSurface->Format);
        }
    }

    if (!(pddsd2->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
    {
        pddsd2->dwHeight = pCreateSurface->pSList[0].cpHeight;
        pddsd2->dwWidth = pCreateSurface->pSList[0].cpWidth;
        pddsd2->dwFlags |= DDSD_HEIGHT | DDSD_WIDTH;

        if (pddsd2->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
        {
            pddsd2->dwHeight = 0;
            pddsd2->dwFlags &= ~DDSD_HEIGHT;
        }
    }
    if (pCreateSurface->Type == D3DRTYPE_VERTEXBUFFER)
    {
        pddsd2->dwFVF = pCreateSurface->dwFVF;
        pddsd2->dwFlags |= DDSD_FVF;
    }
    if (pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_VOLUME)
    {
        pddsd2->dwDepth = pCreateSurface->pSList[0].cpDepth;
        pddsd2->dwFlags |= DDSD_DEPTH;
    }
}


DWORD InitSoftwareSurface(PD3D8_CREATESURFACEDATA pCreateSurface,
                          DWORD                   SurfIndex,
                          DDSURFACEDESC2*         pddsd2,
                          DDSURFACE*              pSurf,
                          DDSURFACE*              pPrevious)
{
    LPDDRAWI_DDRAWSURFACE_INT   pInt;
    LPDDRAWI_DDRAWSURFACE_LCL   pLcl;
    BYTE *                      pTemp;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

    pInt = MemAlloc( sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                     sizeof(DDRAWI_DDRAWSURFACE_GBL) +
                     sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                     sizeof(DDRAWI_DDRAWSURFACE_INT));
    if (pInt == NULL)
    {
        return DDERR_OUTOFMEMORY;
    }
    pTemp = (BYTE*) pInt;
    pTemp += sizeof(DDRAWI_DDRAWSURFACE_INT);
    pInt->lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL) pTemp;
    pLcl = pInt->lpLcl;
    pTemp += sizeof(DDRAWI_DDRAWSURFACE_LCL);
    pLcl->lpGbl = (LPDDRAWI_DDRAWSURFACE_GBL) pTemp;
    pTemp += sizeof(DDRAWI_DDRAWSURFACE_GBL);
    pLcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE) pTemp;

    memcpy(&pInt->lpLcl->lpGbl->ddpfSurface, &pddsd2->ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    if (pddsd2->dwFlags & DDSD_PIXELFORMAT)
    {
        pLcl->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
    }
    pLcl->lpGbl->wWidth                 = (WORD) pCreateSurface->pSList[SurfIndex].cpWidth;
    pLcl->lpGbl->wHeight                = (WORD) pCreateSurface->pSList[SurfIndex].cpHeight;

    pLcl->ddsCaps.dwCaps                = pddsd2->ddsCaps.dwCaps;
    pLcl->lpSurfMore->ddsCapsEx.dwCaps2 = pddsd2->ddsCaps.dwCaps2;
    pLcl->lpSurfMore->ddsCapsEx.dwCaps3 = DDSCAPS3_MULTISAMPLE_MASK & (DWORD) pCreateSurface->MultiSampleType;
    pLcl->lpSurfMore->ddsCapsEx.dwCaps4 = pddsd2->ddsCaps.dwCaps4;
    pLcl->lpSurfMore->dwSurfaceHandle   = pSurf->dwCookie;

    pLcl->lpSurfMore->lpDD_lcl      = pDevice->pSwDD->lpLcl;

    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        pLcl->lpGbl->fpVidMem           = (FLATPTR) pCreateSurface->pSList[SurfIndex].pbPixels;
        pLcl->lpGbl->lPitch             = pCreateSurface->pSList[SurfIndex].iPitch;
    }

    if ((pCreateSurface->Type == D3DRTYPE_VOLUME) ||
        (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        pLcl->lpGbl->lSlicePitch = pCreateSurface->pSList[SurfIndex].iSlicePitch;
        pLcl->lpSurfMore->ddsCapsEx.dwCaps4 =
            MAKELONG((WORD)(pCreateSurface->pSList[SurfIndex].cpDepth),0);
    }

    // If it is a cube-map face, fix up the face flags in caps2.
    if (pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) 
    {
        int MipLevels;

        if (pCreateSurface->dwSCnt>6)
            pLcl->ddsCaps.dwCaps |= DDSCAPS_MIPMAP;

        MipLevels = pCreateSurface->dwSCnt/6; //since all faces are always present in DX8
        
        DDASSERT(MipLevels>=1);
        
        //the first n (where n is mip depth) faces are +x, etc.
        pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_CUBEMAP;
        pLcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~(DDSCAPS2_CUBEMAP_ALLFACES);
        pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= 
            dwOrderedFaces[SurfIndex/MipLevels];
        
        //every MipLevels'th surface is a top-level face,
        if (SurfIndex % MipLevels)
        {
            // Mark non-top levels as being a sub-level
            pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
        }
    }
    // If it is a texture, fix up the flags in caps2.
    else if ((pCreateSurface->Type == D3DRTYPE_TEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUMETEXTURE) ||
            (pCreateSurface->Type == D3DRTYPE_VOLUME))
    {
        if( SurfIndex > 0 )
        {
            pLcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
        }
    }
    
    pSurf->pTempHeavy = pInt;

    return DD_OK;
}


/*****************************Private*Routine******************************\
* SelectAttachmentSurface
*
* Returns an index into the surface creation list that indicates which
* surface this surface should be attached to. For mipmap sublevels this is
* always the preceding surface. For cubemaps, each face attaches to the
* root face (element 0).
*
* History:
*  21-Mar-2000 -by- Jeff Noyle [jeffno]
* Wrote it.
\**************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "SelectAttachmentSurface"

UINT SelectAttachmentSurface(
    PD3D8_CREATESURFACEDATA pCreateSurface,
    UINT                    iThis)
{

    //We should never be called to find the attachment from the root face.
    DDASSERT( iThis > 0);

    if ((pCreateSurface->Type == D3DRTYPE_CUBETEXTURE) &&
        ((iThis % (pCreateSurface->dwSCnt/6)) == 0) //which means we're looking at a top-level face
        )
    {
        //... so we attach this face to the root
        return 0;
    }
    else
    {
        // nope its just a mip sublevel, so we attach to the previous
        return iThis-1;
    }
}

void ExtractLightweightInfo (DDSURFACE *pSurf, LPDDRAWI_DDRAWSURFACE_INT pInt)
{
    LIGHTWEIGHTSURFACE* pLight = pSurf->Surface.pLight;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

    pLight->LclFlags                = pInt->lpLcl->dwFlags;
    pLight->LclCaps1                = pInt->lpLcl->ddsCaps.dwCaps;
    pLight->LclReserved1            = pInt->lpLcl->dwReserved1;
    pLight->LclModeCreatedIn        = pInt->lpLcl->dwModeCreatedIn;
    pLight->LclBackBufferCount      = pInt->lpLcl->dwBackBufferCount;

    pLight->GblFlags                = pInt->lpLcl->lpGbl->dwGlobalFlags;
    pLight->GblPitch                = pInt->lpLcl->lpGbl->lPitch;
    if (pSurf->Pitch == 0)
    {
        pSurf->Pitch = pLight->GblPitch;
    }
    pLight->GblWidth                = pInt->lpLcl->lpGbl->wWidth;
    pLight->GblReserved1            = pInt->lpLcl->lpGbl->dwReserved1;
    if (pLight->LclFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        ConvertFromOldFormat(&pInt->lpLcl->lpGbl->ddpfSurface, 
            &pLight->GblFormat);
    }
    else
    {
        pLight->GblFormat = D3DFMT_UNKNOWN;
    }
    pLight->pGblVidMemHeap          = pInt->lpLcl->lpGbl->lpVidMemHeap;
    pLight->fpGblVidMem             = pInt->lpLcl->lpGbl->fpVidMem;

    pLight->MoreCaps2               = pInt->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2;
    pLight->MoreCaps3               = pInt->lpLcl->lpSurfMore->ddsCapsEx.dwCaps3;
    pLight->MoreCaps4               = pInt->lpLcl->lpSurfMore->ddsCapsEx.dwCaps4;
    pLight->MoreRgjunc              = pInt->lpLcl->lpSurfMore->rgjunc;
    if ((pLight->LclCaps1 & DDSCAPS_MIPMAP) ||
        (pLight->MoreCaps2 & DDSCAPS2_VOLUME))
    {
        pLight->MoreMipMapCount     = pInt->lpLcl->lpSurfMore->dwMipMapCount;
    }
    else
    {
        pLight->MoreFVF             = pInt->lpLcl->lpSurfMore->dwFVF;
    }

    lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE (pInt->lpLcl->lpGbl);
    if (lpGblMore != NULL)
    {
        pLight->GblMoreDriverReserved   = lpGblMore->dwDriverReserved;
        pLight->GblMoreContentsStamp    = lpGblMore->dwContentsStamp;
        pLight->pGblMoreUnswappedDriverReserved = lpGblMore->lpvUnswappedDriverReserved;
        pLight->fpGblMoreAliasOfVidMem  = lpGblMore->fpAliasOfVidMem;
        pLight->cGblMorePageUnlocks     = lpGblMore->cPageUnlocks;
    }

    if (pLight->LclCaps1 & DDSCAPS_NONLOCALVIDMEM)
    {
        if (lpGblMore != NULL)
        {
            pLight->fpGblMorePhysicalVidMem = lpGblMore->fpPhysicalVidMem;
        }
    }
    else if (pLight->LclCaps1 & DDSCAPS_LOCALVIDMEM)
    {
        if (lpGblMore != NULL)
        {
            pLight->fpGblMoreAliasedVidMem  = lpGblMore->fpAliasedVidMem;
        }
    }
    else
    {
        pLight->MoreBytesAllocated      = pInt->lpLcl->lpSurfMore->dwBytesAllocated;
    }

    pSurf->Height   = pInt->lpLcl->lpGbl->wHeight;
    pSurf->dwCookie = pInt->lpLcl->lpSurfMore->dwSurfaceHandle;
}


void DiscardHeavyweightMemory( LPDDRAWI_DDRAWSURFACE_INT pInt)
{
    if (pInt->lpLcl->lpSurfMore->slist != NULL)
    {
        MemFree (pInt->lpLcl->lpSurfMore->slist);
    }
    MemFree (pInt->lpLcl);
    MemFree (pInt);
}


DWORD APIENTRY DdCreateSurface( PD3D8_CREATESURFACEDATA pCreateSurface )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = pDevice->pDD;
    HRESULT                     hr;
    DWORD                       i;
    PDDSURFACE                  pSurf;
    LPDIRECTDRAWSURFACE         lpDDSurface;
    DWORD                       dwNumToCreate;
    DDSURFACEDESC2              ddsd2;
    DWORD                       NextWidth;
    DWORD                       NextHeight;
    DEFERREDCREATE*             pDefCreate;

    ENTER_DDRAW();
    BuildSurfaceDesc (pCreateSurface, &ddsd2);

	dwNumToCreate = pCreateSurface->dwSCnt;

    // Allocate the internal surface structures for each surface in the chain
    // and initialize it if we are not reusing the surface

    if (!pCreateSurface->bReUse)
    {
        NextWidth = ddsd2.dwWidth;
        NextHeight = ddsd2.dwHeight;        
        for (i = 0; i < dwNumToCreate; i++)
        {
            pSurf = (PDDSURFACE) MemAlloc(sizeof(DDSURFACE));
            if (pSurf == NULL)
            {
                hr = DDERR_OUTOFMEMORY;
                goto CreateErrorCleanup;
            }
            pSurf->Pool = pCreateSurface->Pool;
            pSurf->Format = pCreateSurface->Format;
            pSurf->Type = pCreateSurface->Type;

            // For volume textures, we need to know the depth to handle lost
            // devices (for everything else we need to height).  To save space,
            // we will re-use the same variable.

            if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
            {
                pSurf->Height = pCreateSurface->pSList[i].cpDepth;
            }
            else
            {
                pSurf->Height = pCreateSurface->pSList[i].cpHeight;
            }
            pCreateSurface->pSList[i].hKernelHandle = (HANDLE) pSurf;
            pSurf->pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;

            // DX6 drivers cannot handle deep mipmaps, but we want to hide this from 
            // the runtime, so we need to determine if the current level is a dummy
            // level

            if ((pDevice->DriverLevel == 6) && 
                (ddsd2.ddsCaps.dwCaps & DDSCAPS_MIPMAP))
            {
                if ((pCreateSurface->pSList[i].cpWidth == NextWidth) &&
                    (pCreateSurface->pSList[i].cpHeight == NextHeight))
                {
                    // This level is OK, so mark it as such
                    ddsd2.dwMipMapCount = i + 1;
                }
                else
                {
                    pSurf->dwFlags |= DDSURFACE_DUMMY;
                    if (i == 1)
                    {
                        // If there's only one valid level, then don't call it
                        // a mipmap
                        ddsd2.ddsCaps.dwCaps &= ~DDSCAPS_COMPLEX | DDSCAPS_MIPMAP;
                        ddsd2.dwFlags &= ~DDSD_MIPMAPCOUNT;
                    }
                }
                NextWidth /= 2;
                NextHeight /= 2;
            }

            // Now figure out if this is a software driver
            // surface, or a HAL surface.

            if (IS_SOFTWARE_DRIVER(pCreateSurface->hDD) &&
                !(pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE) &&
                !(pCreateSurface->dwUsage & D3DUSAGE_OFFSCREENPLAIN))
            {
                // If they are running w/ a software driver (refrast, RGB HEL, etc.),
                // we will not allow any surfaces to be created in video memory except
                // for the primary flipping chain. And also for surfaces marked
                // D3DUSAGE_OFFSCREENPLAIN (which are used for the cursors)

                pSurf->dwFlags |= DDSURFACE_SOFTWARE;
            }
            else
            {
                pSurf->dwFlags |= DDSURFACE_HAL;
            }

            if (pCreateSurface->bTreatAsVidMem == TRUE)
            {
                // For objects that should be treated as non-persistent
                // i.e. Reset fails unless these are all freed; we
                // set a flag here and check it in DoVidMemSurfacesExist()
                pSurf->dwFlags |= DDSURFACE_TREATASVIDMEM;
            }

            if (pDevice->bLightweight && IsLightweightSurface(pDevice, &ddsd2, pCreateSurface->Format))
            {
                pSurf->dwFlags |= DDSURFACE_LIGHTWEIGHT;
                pSurf->Surface.pLight = (LIGHTWEIGHTSURFACE*) MemAlloc(sizeof(LIGHTWEIGHTSURFACE));
                if (pSurf->Surface.pLight == NULL)
                {
                    hr = DDERR_OUTOFMEMORY;
                    goto CreateErrorCleanup;
                }
            }
            else
            {

                pSurf->dwFlags |= DDSURFACE_HEAVYWEIGHT;
            }

            // Software surfaces are special cased because we want to call the software
            // driver for Create and CreateEx rather than the real driver.

            if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
            {
                if ((ddsd2.ddsCaps.dwCaps & (DDSCAPS_TEXTURE       |
                                            DDSCAPS_EXECUTEBUFFER |
                                            DDSCAPS_3DDEVICE      |
                                            DDSCAPS_ZBUFFER)) &&
                    (pCreateSurface->Type != D3DRTYPE_IMAGESURFACE))
                {
                    pSurf->dwCookie = GetDX7SurfaceHandle(pCreateSurface->hDD);
                }

                hr = InitSoftwareSurface(pCreateSurface,
                                         i,
                                         &ddsd2,
                                         pSurf,
                                         i > 0 ? pCreateSurface->pSList[i].hKernelHandle : NULL);
                if (hr != DD_OK)
                {
                    goto CreateErrorCleanup;
                }
            }
        }
    }
    else
    {
        DDASSERT(pCreateSurface->Pool == D3DPOOL_MANAGED);
    }

    pSurf = (DDSURFACE*) pCreateSurface->pSList[0].hKernelHandle;
    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        if (pCreateSurface->Pool != D3DPOOL_SYSTEMMEM)
        {
            // There is a descrepancy in the surface desc that CreateSurface
            // expects and the driver expects, so we will adjust it here for
            // the driver.

            if ((ddsd2.dwFlags & DDSD_WIDTH) &&
                !(ddsd2.dwFlags & DDSD_HEIGHT))
            {
                ddsd2.dwFlags |= DDSD_HEIGHT;
                ddsd2.dwHeight = 1;
            }

            hr = SwDDICreateSurface(pCreateSurface, &ddsd2);
            if (hr != DD_OK)
            {
                goto CreateErrorCleanup;
            }
            for (i = 0; i < pCreateSurface->dwSCnt; i++)
            {
                ((DDSURFACE*)pCreateSurface->pSList[i].hKernelHandle)->dwFlags |= 
                    DDSURFACE_CREATECOMPLETE;
            }
        }

        // We've already created the object so all
        // we have to do is call CreateSurfaceEx
        if (pSurf->dwCookie != 0)
        {
            // If it's a software driver, we may need to attach surfaces

            for (i = 1; i < pCreateSurface->dwSCnt; i++)
            {
                SwDDIAttachSurfaces (
                    ((DDSURFACE*)pCreateSurface->pSList[
                        SelectAttachmentSurface(pCreateSurface,i)
                        ].hKernelHandle)->pTempHeavy->lpLcl,
                    ((DDSURFACE*)pCreateSurface->pSList[i].hKernelHandle)->pTempHeavy->lpLcl);
            }
            SwDDICreateSurfaceEx (pDevice->pSwDD->lpLcl,
                pSurf->pTempHeavy->lpLcl);
            pSurf->dwFlags |= DDSURFACE_CREATEEX;
        }

        for (i = 0; i < pCreateSurface->dwSCnt; i++)
        {
            LPATTACHLIST    pAttach;
            LPATTACHLIST    pAttachTemp;

            pSurf = (DDSURFACE*)pCreateSurface->pSList[i].hKernelHandle;

            // For a sw driver, always destroy the attached list now.  
            // It serves no purpose after CreateSurfaceEx is called.

            if (pSurf->pTempHeavy->lpLcl->lpAttachList != NULL)
            {
                pAttach = pSurf->pTempHeavy->lpLcl->lpAttachList->lpLink;
                while (pAttach != NULL)
                {
                    pAttachTemp = pAttach;
                    pAttach = pAttach->lpLink;
                    MemFree(pAttachTemp);
                }
                MemFree(pSurf->pTempHeavy->lpLcl->lpAttachList);
                pSurf->pTempHeavy->lpLcl->lpAttachList = NULL;
            }
            if (pSurf->pTempHeavy->lpLcl->lpAttachListFrom != NULL)
            {
                pAttach = pSurf->pTempHeavy->lpLcl->lpAttachListFrom->lpLink;
                while (pAttach != NULL)
                {
                    pAttachTemp = pAttach;
                    pAttach = pAttach->lpLink;
                    MemFree(pAttachTemp);
                }
                MemFree(pSurf->pTempHeavy->lpLcl->lpAttachListFrom);
                pSurf->pTempHeavy->lpLcl->lpAttachListFrom = NULL;
            }

            pSurf->iSlicePitch = pSurf->pTempHeavy->lpLcl->lpGbl->lSlicePitch;
            pSurf->pTempHeavy->lpLcl->lpGbl->lSlicePitch = 0;   
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {
                ExtractLightweightInfo (pSurf, pSurf->pTempHeavy);
                MemFree (pSurf->pTempHeavy);
            }
            else
            {
                pSurf->Surface.pHeavy = pSurf->pTempHeavy;
            }
            pSurf->pTempHeavy = NULL;
        }
    }
    else
    {
        LPDDSURFACEINFO pSysMem = NULL;
        BOOL            bLost;

        // If it's a sysmem surface, we want them to use the memory that we
        // have already allocated, so we need to setup an array of pointers.

        if ((pCreateSurface->Pool == D3DPOOL_SYSTEMMEM) ||
            (ddsd2.ddsCaps.dwCaps2 & DDSCAPS2_VOLUME))
        {
            pSysMem = pCreateSurface->pSList;
        }

        // If we are creating a vidmem surface, we need to check for device lost
        // and if it's lost, we don't want to create the surface, but to instead
        // allocate a private buffer that we can return when lock is called.  We
        // do not want to fail the call just because the device is lost.

        ENTER_WIN16LOCK();
        bLost = CheckForDeviceLost(pDevice);

        // Special early out. If reuse is true, we haven't done anything yet (to
        // verify this, trace code above) so all we need to do is to return SURFACELOST
        // and not worry about jumping to CreateErrorCleanup below.
        if (bLost && pCreateSurface->bReUse)
        {
            DDASSERT(!IS_SOFTWARE_DRIVER_SURFACE(pSurf));
            DDASSERT(pCreateSurface->Pool == D3DPOOL_MANAGED);
            LEAVE_WIN16LOCK();
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        if ((pCreateSurface->Pool != D3DPOOL_SYSTEMMEM) &&
            bLost)
        {
            DWORD                       j;
            DDASSERT(pCreateSurface->bReUse == FALSE);
            for (i = 0; i < pCreateSurface->dwSCnt; i++)
            {
                pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;

                pSurf->Pitch = pCreateSurface->pSList[i].cpWidth * 8;
                pSurf->iSlicePitch = pSurf->Pitch * pCreateSurface->pSList[i].cpHeight;
                if (!(pSurf->dwFlags & DDSURFACE_DUMMY))
                {
                    if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                        (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
                    {
                        pSurf->fpVidMem = (char*)
                            MemAlloc(pSurf->iSlicePitch * pSurf->Height);
                    }
                    else
                    {
                        pSurf->fpVidMem = (char*)
                            MemAlloc(pSurf->Pitch * pSurf->Height);
                    }


                    if (pSurf->fpVidMem == (char*) NULL)
                    {
                        DWORD j;

                        for (j = 0; j < i; j++)
                        {
                            pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;
                            MemFree (pSurf->fpVidMem);
                        }
                        hr = DDERR_OUTOFMEMORY;
                        LEAVE_WIN16LOCK();
                        goto CreateErrorCleanup;
                    }
                    else
                    {
                        pSurf->dwFlags |= DDSURFACE_SYSMEMALLOCATED;
                    }
                }
            }

            // If the surface is driver managed, we save the creation info so that 
            // we can retry the creation at reset time
            if (ddsd2.ddsCaps.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
            {
                DDASSERT(pCreateSurface->Pool == D3DPOOL_MANAGED);
                pDefCreate = (PDEFERREDCREATE)MemAlloc(sizeof(DEFERREDCREATE));
                if (pDefCreate == NULL)
                {
                    // Cleanup stuff that we allocated above
                    for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                    {
                        pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;
                        MemFree(pSurf->fpVidMem);
                        pSurf->dwFlags &= ~DDSURFACE_SYSMEMALLOCATED;
                    }
                    hr = DDERR_OUTOFMEMORY;
                    LEAVE_WIN16LOCK();
                    goto CreateErrorCleanup;
                }
                
                // Copy
                pDefCreate->CreateData = *pCreateSurface;
                
                pDefCreate->CreateData.pSList = (LPDDSURFACEINFO)MemAlloc(sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);
                if (pDefCreate->CreateData.pSList == NULL)
                {
                    // Cleanup stuff that we allocated above
                    MemFree(pDefCreate);
                    for (i = 0; i < pCreateSurface->dwSCnt; ++i)
                    {
                        pSurf = (PDDSURFACE) pCreateSurface->pSList[i].hKernelHandle;
                        MemFree(pSurf->fpVidMem);
                        pSurf->dwFlags &= ~DDSURFACE_SYSMEMALLOCATED;
                    }
                    hr = DDERR_OUTOFMEMORY;
                    LEAVE_WIN16LOCK();
                    goto CreateErrorCleanup;
                }
                
                // Copy
                CopyMemory(pDefCreate->CreateData.pSList, pCreateSurface->pSList, sizeof(DDSURFACEINFO) * pCreateSurface->dwSCnt);
                
                // Linkup
                pDefCreate->pNext = ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList;
                ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pDeferList = pDefCreate;
                
                // *************************MEMORY LEAK WARNING*********************** //
                // The DEFERREDCREATE and DDSURFACEINFO allocations above will
                // not be cleaned up immediately if there is a failure after this
                // point. As of 5/2001, there is no case in which we will fail after
                // this point. (snene)
                // ******************************************************************* //
            }
        }
        else
        {
            DWORD   DX8Flags = DX8SFLAG_DX8;

            // If we are creating a sysmem surface while lost, we don't want
            // want to call the driver to create the SurfaceEx handle.

            if (bLost)
            {
                DX8Flags |= DX8SFLAG_ISLOST;
            }
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {
                DX8Flags |= DX8SFLAG_ISLIGHTWEIGHT;
            }
            if (pCreateSurface->Type == D3DRTYPE_IMAGESURFACE)
            {
                DX8Flags |= DX8SFLAG_IMAGESURF;
            }

            hr = DD_CreateSurface4_Main( (LPDIRECTDRAW) pdrv_int,
                                         &ddsd2,
                                         &lpDDSurface,
                                         NULL,
                                         TRUE,
                                         pSysMem,
                                         DX8Flags);

            if (hr != DD_OK)
            {
                LEAVE_WIN16LOCK();
                goto CreateErrorCleanup;
            }

            // If we let DDraw decide between local vidmem / AGP, then we need 
            // to figure out which one it chose.

            if (((LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface)->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
            {
                pCreateSurface->Pool = D3DPOOL_NONLOCALVIDMEM;
                for (i = 0; i < dwNumToCreate; i++)
                {
                    pSurf = (DDSURFACE*) pCreateSurface->pSList[i].hKernelHandle;
                    pSurf->Pool = D3DPOOL_NONLOCALVIDMEM;
                }
            }

            // Everything has worked

            //Find the pointer to the attached heavyweight surface for
            //each face, mip level, back buffer etc.
            switch(pCreateSurface->Type)
            {
                case D3DRTYPE_VERTEXBUFFER  :
                case D3DRTYPE_INDEXBUFFER   :
                case D3DRTYPE_COMMANDBUFFER :
                    //these types have no attachments
                    DDASSERT(0 ==  ( (LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface)->lpLcl->lpAttachList );
                    //but we need to fall through and set the pHeavy for the first one.
                case D3DRTYPE_SURFACE                :
                case D3DRTYPE_IMAGESURFACE           :
                case D3DRTYPE_VOLUME                 :
                case D3DRTYPE_TEXTURE                :
                case D3DRTYPE_VOLUMETEXTURE          :
                    {
                        LPDDRAWI_DDRAWSURFACE_INT        lpTemp;
                        LPDDRAWI_DDRAWSURFACE_INT        lpTemp1;
                        lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

                        //these types are allocated in a linear list of attachments
                        for (i = 0; i < dwNumToCreate; i++)
                        {
                            pSurf = (DDSURFACE*) pCreateSurface->pSList[i].hKernelHandle;
                            DDASSERT(!(pSurf->dwFlags & DDSURFACE_DUMMY));    //cuz not DX6 driver

                            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                            {
                                ExtractLightweightInfo (pSurf, lpTemp);
                            }
                            else
                            {
                                pSurf->Surface.pHeavy = lpTemp;
                            }

                            lpTemp1 = lpTemp;
                            if (lpTemp->lpLcl->lpAttachList)
                                lpTemp = lpTemp->lpLcl->lpAttachList->lpIAttached;

                            pSurf->iSlicePitch = lpTemp1->lpLcl->lpGbl->lSlicePitch;
                            lpTemp1->lpLcl->lpGbl->lSlicePitch = 0;
                            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                            {
                                if (lpTemp1->lpLcl->lpAttachList != NULL)
                                {
                                    MemFree(lpTemp1->lpLcl->lpAttachList);
                                }
                                if (lpTemp1->lpLcl->lpAttachListFrom != NULL)
                                {
                                    MemFree(lpTemp1->lpLcl->lpAttachListFrom);
                                }
                                DiscardHeavyweightMemory(lpTemp1);
                            }
                        }
                    }
                    break;
                case D3DRTYPE_CUBETEXTURE   :
                    //cubes are the hard buggers.
                    {
                        int face;
                        DWORD cLevels = dwNumToCreate/6;
                        
                        for(face=0; face<6; face++)
                        {
                            LPDDRAWI_DDRAWSURFACE_INT        lpTemp;
                            lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

                            //point lpTemp to the next top-level face (which will be
                            //attached to the face returned by create-surface)
                            //(we are already pointing thereat if it's face 0)
                            if (face)
                            {
                                LPATTACHLIST pal;
                                pal = lpTemp->lpLcl->lpAttachList;
                                do
                                {
                                    lpTemp = pal->lpIAttached;
                                    pal = pal->lpLink;
                                }
                                while(0 ==  (lpTemp->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & dwOrderedFaces[face]));
                            }

                            //for each face, we run down the attachment list
                            //which are allocated in a linear list of attachments
                            for (i = 0; i < cLevels; i++)
                            {
                                pSurf = (DDSURFACE*) pCreateSurface->pSList[face*cLevels+i].hKernelHandle;
                                DDASSERT(!(pSurf->dwFlags & DDSURFACE_DUMMY));    //cuz not DX6 driver

                                pSurf->iSlicePitch = lpTemp->lpLcl->lpGbl->lSlicePitch;
                                lpTemp->lpLcl->lpGbl->lSlicePitch = 0;
                                if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                                {
                                    ExtractLightweightInfo (pSurf, lpTemp);
                                }
                                else
                                {
                                    pSurf->Surface.pHeavy = lpTemp;
                                }

                                if ((face == 0) && (i == 0) && (cLevels > 1))
                                {
                                    // Special hack for finding mip-levels
                                    // of first face; the mip-levels for the pos-x
                                    // face are actually near the the end of the
                                    // list (interposed by the top-levels of the 
                                    // other 5 faces)
                                    int j;
                                    LPATTACHLIST pal = lpTemp->lpLcl->lpAttachList;

                                    for (j = 0; j < 5; j++)
                                    {
                                        pal = pal->lpLink;
                                    }

                                    lpTemp = pal->lpIAttached;

                                    // Check we found what we were looking for
                                    DDASSERT(lpTemp->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & dwOrderedFaces[face]);
                                }
                                else if (lpTemp->lpLcl->lpAttachList)
                                {
                                    // Normal case; i.e. just go to the surface we
                                    // are directly attached to
                                    lpTemp = lpTemp->lpLcl->lpAttachList->lpIAttached;
                                }
                            }
                        }

                        // If it's a lightweight surface, now we need to free
                        // all of the heavyweight memory

                        if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                        {
                            LPDDRAWI_DDRAWSURFACE_INT   lpTemp;
                            LPATTACHLIST                pal;
                            LPATTACHLIST                pNextPal;
                            LPATTACHLIST                pFaceList;
                            LPATTACHLIST                pTemp;

                            lpTemp = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;

                            pal = lpTemp->lpLcl->lpAttachList;
                            DiscardHeavyweightMemory(lpTemp);

                            while (pal != NULL)
                            {
                                pNextPal = pal->lpLink;

                                pFaceList = pal;
                                while (pFaceList != NULL)
                                {
                                    if (pFaceList->lpAttached->lpAttachListFrom)
                                    {
                                        MemFree (pFaceList->lpAttached->lpAttachListFrom);
                                    }
                                    pTemp = pFaceList->lpAttached->lpAttachList;
                                    DiscardHeavyweightMemory(pFaceList->lpIAttached);
                                    MemFree(pFaceList);
                                    pFaceList = pTemp;
                                }
                                pal = pNextPal;
                            }
                        }
                    }
                    break;

                default:
                    DDASSERT(0);    //unexpected type
                    break;
            }
        
            for (i = 0; i < dwNumToCreate; i++)
            {
                DWORD                       j;

                pSurf = (DDSURFACE*) pCreateSurface->pSList[i].hKernelHandle;
                if (i == 0)
                {
                    pSurf->dwFlags |= DDSURFACE_ROOT;
                }

                if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
                {
                    pSurf->Pitch = pSurf->Surface.pHeavy->lpLcl->lpGbl->lPitch;
                    if (!(pSurf->dwFlags & DDSURFACE_DUMMY))
                    {
                        if (i == 0)
                        {
                            if (DDSCAPS_PRIMARYSURFACE &
                                pSurf->Surface.pHeavy->lpLcl->ddsCaps.dwCaps)
                            {
                                if (!(DDRAWILCL_HASEXCLUSIVEMODE & pdrv_int->lpLcl->dwLocalFlags))
                                {
                                    LPDIRECTDRAWCLIPPER pcClipper;
                                    if (SUCCEEDED(DD_CreateClipper((LPDIRECTDRAW) pdrv_int,
                                            0, &pcClipper, NULL)))
                                    {
                                        if (pdrv_int->lpLcl->hWnd)
                                            DD_Clipper_SetHWnd(pcClipper, 0, (HWND) pdrv_int->lpLcl->hWnd);
                                        DD_Surface_SetClipper(lpDDSurface, pcClipper);
                                        DPF(10,"Setting Clipper=%08lx with hWnd=%08lx to Primary"
                                            " Surface", pcClipper, pdrv_int->lpLcl->hWnd);
                                        DD_Clipper_Release(pcClipper);
                                    }
                                }
                            }
                        }
                    }
                    pCreateSurface->pSList[i].hKernelHandle = (HANDLE) pSurf;
                }

                // If this is a DX6+ driver, the above CreateSurface call would
                // have created the ExSurface and assigned a driver handle value.
                // If it's a DX6 driver, however, we need to create the texture
                // handle ourselves.

                if (pDevice->DriverLevel > 6)
                {
                    if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
                    {
                        pSurf->dwCookie = pSurf->Surface.pHeavy->lpLcl->lpSurfMore->dwSurfaceHandle;
                    }
                    if (pSurf->dwCookie &&
                        bLost &&
                        (pSurf->dwFlags & DDSURFACE_ROOT))
                    {
                        // We've created the surface, but we can't create the
                        // surface Ex handle yet, so we will defer that creation until later.

                        pSurf->dwFlags |= DDSURFACE_DEFERCREATEEX;
                    }
                }
                else if ((pSurf->dwFlags & DDSURFACE_ROOT) &&
                    (pSurf->Type == D3DRTYPE_TEXTURE))
                {
                    // Don't create a texture handle if the surface is in sysmem
                    // and the device doesn't texture from sysmem

                    if ((pCreateSurface->Pool != D3DPOOL_SYSTEMMEM) ||
                        pDevice->bCanTextureSysmem)
                    {
                        D3DHAL_TEXTURECREATEDATA    data;
                        DWORD                       ret;

                        if (pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate == NULL)
                        {
                            hr = DDERR_UNSUPPORTED;
                            LEAVE_WIN16LOCK();
                            goto CreateErrorCleanup;
                        }

                        if (bLost)
                        {
                            // We cannot create the texture handle at this time,
                            // so we will do it later.

                            pSurf->dwFlags |= DDSURFACE_DEFERCREATETEXHANDLE;
                            pDevice->pContext->dwFlags |= DDCONTEXT_DEFEREDTEXTUREHANDLES;
                        }
                        else
                        {
                            // If it's a palettized texture, we need to associate a
                            // palette before calling TextureCreate or else some
                            // drivers (Rage128) will fault.

                            if ((pCreateSurface->Format == D3DFMT_P8) ||
                                (pCreateSurface->Format == D3DFMT_A8P8))
                            {
                                if (pDevice->pDefaultPalette == NULL)
                                {
                                    {
                                        PALETTEENTRY    ColorTable[256];
                                        int             i;

                                        for (i = 0; i < 256; i++)
                                        {
                                            ColorTable[i].peRed   = (UCHAR) i;
                                            ColorTable[i].peGreen = (UCHAR) i;
                                            ColorTable[i].peBlue  = (UCHAR) i;
                                        }
                                        DD_CreatePalette ((LPDIRECTDRAW) pDevice->pDD,
                                                        DDPCAPS_8BIT,
                                                        ColorTable,
                                                        &pDevice->pDefaultPalette,
                                                        NULL);
                                    }

                                    if (pDevice->pDefaultPalette == NULL)
                                    {
                                        DPF_ERR("Unable to create default palette");
                                        LEAVE_WIN16LOCK();
                                        hr = DDERR_OUTOFMEMORY;
                                        goto CreateErrorCleanup;
                                    }
                                }
                                hr = DD_Surface_SetPalette(lpDDSurface,
                                                           pDevice->pDefaultPalette);
                                if (hr != DD_OK)
                                {
                                    DPF_ERR("Unable to set default palette");
                                    LEAVE_WIN16LOCK();
                                    goto CreateErrorCleanup;
                                }
                            }

                            memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
                            data.dwhContext = pDevice->pContext->Context;
                            data.lpDDS = lpDDSurface;

                            CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                                pDevice,
                                                pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate,
                                                &data);

                            if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
                            {
                                DPF_ERR("HAL failed to handle TextureCreate");
                                LEAVE_WIN16LOCK();
                                hr = data.ddrval;
                                goto CreateErrorCleanup;
                            }

                            pSurf->dwCookie = data.dwHandle;
                            pSurf->dwFlags |= DDSURFACE_DX6HANDLE;
                        }
                    }
                }
            }
        }
        LEAVE_WIN16LOCK();
    }

    // Now insert this into our linked list
    // If re-using, then we are already on the list so don't do anything
    if (!pCreateSurface->bReUse)
    {
        for (i = 0; i < dwNumToCreate; i++)
        {
            ((PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle))->pNext =
                pDevice->pSurfList;
            ((PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle))->pPrevious =
                NULL;
            if (pDevice->pSurfList != NULL)
            {
                pDevice->pSurfList->pPrevious = (PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle);
            }
            pDevice->pSurfList = (PDDSURFACE)(pCreateSurface->pSList[i].hKernelHandle);
        }
    }
    LEAVE_DDRAW();

    return DD_OK;

    CreateErrorCleanup:
    for (i = 0; i < pCreateSurface->dwSCnt; i++)
    {
        pSurf = (PDDSURFACE)pCreateSurface->pSList[i].hKernelHandle;
        if (pSurf != NULL)
        {
            FreeSurfaceObject(pSurf, TRUE);
            // If we are reusing, then we need to keep the pSurf around
            // for a retry
            if (!pCreateSurface->bReUse)
            {
                MemFree(pSurf);
            }
        }
        pCreateSurface->pSList[i].hKernelHandle = NULL;
    }
    LEAVE_DDRAW();

    return MapLegacyResult(hr);
}


DWORD APIENTRY DdDestroySurface( PD3D8_DESTROYSURFACEDATA pDestroySurface )
{
    DWORD i;
    PDDSURFACE pSurf = (PDDSURFACE) pDestroySurface->hSurface;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pDestroySurface->hDD;
    PDEFERREDCREATE pDefCreate = pDevice->pDeferList;

    ENTER_DDRAW();
    FreeSurfaceObject(pSurf, TRUE);

    if (pSurf != NULL)
    {
        // Free fpVidMem if we allocated it

        if (pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED)
        {
            MemFree (pSurf->fpVidMem);
        }

        // Remove the surface from the linked list

        if (pDevice->pSurfList == pSurf)
        {
            pDevice->pSurfList = pSurf->pNext;
            if (pSurf->pNext != NULL)
            {
                pSurf->pNext->pPrevious = NULL;
            }
        }
        else
        {
            if (pSurf->pNext != NULL)
            {
                pSurf->pNext->pPrevious = pSurf->pPrevious;
            }
            pSurf->pPrevious->pNext = pSurf->pNext;
        }

        MemFree(pSurf);
    }

    // We look in the defer list to see if any referenced surface
    // is being destroyed. If this is the case, then we need to
    // update the defer list and mark the surfaces as freed so
    // that we don't try and resurrect destroyed surfaces. Although
    // this appears slow, it is not too bad because a deferred list
    // will be present only if a mode switch happened. In this case,
    // it doesn't hurt if things are a little slow.

    while (pDefCreate != NULL)
    {
        for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
        {
            if (pSurf == (PDDSURFACE) pDefCreate->CreateData.pSList[i].hKernelHandle)
            {
                pDefCreate->CreateData.pSList[i].hKernelHandle = 0;
                break;
            }
        }
        pDefCreate = pDefCreate->pNext;
    }

    LEAVE_DDRAW();

    return DD_OK;
}

DWORD APIENTRY DdGetScanLine( PD3D8_GETSCANLINEDATA pGetScanLine )
{  
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pGetScanLine->hDD;
    DWORD           dwRet = DDHAL_DRIVER_HANDLED;

    ENTER_BOTH();
    if (CheckForDeviceLost(pDevice))
    {
        static int LostScanLine;

        // When lost, we want to mix up the return values in case somebody
        // calling us is waiting for these values to change

        pGetScanLine->ddRVal = DD_OK;
        if (LostScanLine == 0)
        {
            pGetScanLine->dwScanLine = 0;
            pGetScanLine->bInVerticalBlank = TRUE;
        }
        else 
        {
            pGetScanLine->dwScanLine = LostScanLine;
            pGetScanLine->bInVerticalBlank = FALSE;
        }
        if ((LostScanLine += 10) > 100)
        {
            LostScanLine = 0;
        }
    }
    else
    {
        LPDDHAL_GETSCANLINE gslhalfn;
        LPDDHAL_GETSCANLINE gslfn;

        gslfn = pDevice->pDD->lpLcl->lpDDCB->HALDD.GetScanLine;
        gslhalfn = pDevice->pDD->lpLcl->lpDDCB->cbDDCallbacks.GetScanLine;
        if( gslhalfn != NULL )
        {
            DDHAL_GETSCANLINEDATA   gsld;

            gsld.GetScanLine = gslhalfn;
            gsld.lpDD = pDevice->pDD->lpLcl->lpGbl;
            DOHALCALL( GetScanLine, gslfn, gsld, dwRet, FALSE );
            if( dwRet == DDHAL_DRIVER_HANDLED )
            {
                pGetScanLine->dwScanLine = gsld.dwScanLine;
                if (gsld.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
                {
                    gsld.ddRVal = DD_OK;
                    pGetScanLine->bInVerticalBlank = TRUE;
                }
                else
                {
                    pGetScanLine->bInVerticalBlank = FALSE;
                }
                pGetScanLine->ddRVal = MapLegacyResult(gsld.ddRVal);
            }
	}
        else
        {
            dwRet = DDHAL_DRIVER_NOTHANDLED;
        }
    }

    LEAVE_BOTH();
    return dwRet;
}

DWORD APIENTRY DdSetExclusiveMode( PD3D8_SETEXCLUSIVEMODEDATA pSetExclusiveMode )
{
    DPF_ERR("DdSetExclusiveMode");
#if 0
    LPDDRAWI_DIRECTDRAW_LCL lpDX7;

    // Tell DDraw that we've grabbed exclusive mode

    ENTER_DDRAW();
    lpDX7 = ((LPDDRAWI_DIRECTDRAW_INT)(pSetExclusiveMode->lpDD->hDD))->lpLcl;

    if( pSetExclusiveMode->dwEnterExcl )
    {
        lpDX7->dwLocalFlags |= DDRAWILCL_SETCOOPCALLED | DDRAWILCL_ISFULLSCREEN;
        lpDX7->lpGbl->lpExclusiveOwner = lpDX7;
        lpDX7->lpGbl->dwFlags |= DDRAWI_FULLSCREEN;
    }
    else
    {
        lpDX7->dwLocalFlags &= ~(DDRAWILCL_SETCOOPCALLED | DDRAWILCL_ISFULLSCREEN);
        lpDX7->lpGbl->lpExclusiveOwner = NULL;
        lpDX7->lpGbl->dwFlags &= ~DDRAWI_FULLSCREEN;
    }
    LEAVE_DDRAW();
#endif
    pSetExclusiveMode->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdFlipToGDISurface( PD3D8_FLIPTOGDISURFACEDATA pFlipToGDISurface )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pFlipToGDISurface->hDD;
    LPDDRAWI_DIRECTDRAW_INT     lpDD = pDevice->pDD;

    pFlipToGDISurface->ddRVal = MapLegacyResult(DD_FlipToGDISurface((LPDIRECTDRAW)lpDD));
    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdSetColorkey( PD3D8_SETCOLORKEYDATA pSetColorkey)
{
    PDDDEVICEHANDLE     pDevice = (PDDDEVICEHANDLE) pSetColorkey->hDD;
    PDDSURFACE          pSurf = (PDDSURFACE) pSetColorkey->hSurface;

    ENTER_BOTH();
    pSetColorkey->ddRVal = DD_OK;
    if (CheckForDeviceLost(pSetColorkey->hDD))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    if (pSurf->Surface.pHeavy != NULL)
    {
        DDCOLORKEY DDColorKey;

        // Since this will only be called with DX6 drivers, we know that
        // it will only be heavyweight surfaces and we can use the legacy
        // entry point.

        DDColorKey.dwColorSpaceLowValue = pSetColorkey->ColorValue;
        pSetColorkey->ddRVal = MapLegacyResult(DD_Surface_SetColorKey((LPDIRECTDRAWSURFACE)pSurf->Surface.pHeavy,
                                                       DDCKEY_SRCBLT,
                                                       &DDColorKey));
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdGetAvailDriverMemory( PD3D8_GETAVAILDRIVERMEMORYDATA pGetAvailDriverMemory )
{
    DWORD                       dwTotal;
    DWORD                       dwFree;
    DDSCAPS                     ddscaps;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = ((PDDDEVICEHANDLE)pGetAvailDriverMemory->hDD)->pDD;

    ddscaps.dwCaps = DDSCAPS_TEXTURE;

    pGetAvailDriverMemory->ddRVal = MapLegacyResult(DD_GetAvailableVidMem( (LPDIRECTDRAW)pdrv_int, &ddscaps, &dwTotal, &dwFree ));

    pGetAvailDriverMemory->dwFree = dwFree;

    return DDHAL_DRIVER_HANDLED;
}

HRESULT CalcDDSurfInfo( PDDCONTEXT pCtx, LPDDRAWI_DDRAWSURFACE_LCL pSLcl,
                        LPDDRAWI_DDRAWSURFACE_LCL pZLcl )
{
    HRESULT ddrval;
    DWORD dwWidth, dwHeight;
    unsigned long m;
    int s;
    LPDDPIXELFORMAT pSPixFmt = NULL;
    LPDDPIXELFORMAT pZPixFmt = NULL;

    if( pSLcl == NULL ) return S_OK;

    // Get info from the surface
    dwWidth = pSLcl->lpGbl->wWidth;
    dwHeight = pSLcl->lpGbl->wHeight;
    GET_PIXEL_FORMAT( pSLcl, pSLcl->lpGbl, pSPixFmt );

    if( ( pSPixFmt->dwFlags & ( DDPF_PALETTEINDEXED4 |
                                DDPF_PALETTEINDEXED8 ) ) == 0 )
    {
        // palettized pixfmts will not have valid RGB Bitmasks, so avoid
        // computing this for them

        pCtx->red_mask = pSPixFmt->dwRBitMask;
        pCtx->green_mask = pSPixFmt->dwGBitMask;
        pCtx->blue_mask = pSPixFmt->dwBBitMask;

        if( (pCtx->red_mask == 0x0) || (pCtx->green_mask == 0x0) ||
            (pCtx->blue_mask == 0x0) )
        {
            D3D_ERR("All the color masks in the Render target's pixel-format "
                    "must be non-zero");
            return DDERR_INVALIDPIXELFORMAT;
        }

        // these are used by Clear
        for( s = 0, m = pCtx->red_mask; !(m & 1); s++, m >>= 1 );
        pCtx->red_shift = s;
        pCtx->red_scale = 255 / (pCtx->red_mask >> s);
        for( s = 0, m = pCtx->green_mask; !(m & 1); s++, m >>= 1 );
        pCtx->green_shift = s;
        pCtx->green_scale = 255 / (pCtx->green_mask >> s);
        for( s = 0, m = pCtx->blue_mask; !(m & 1); s++, m >>= 1 );
        pCtx->blue_shift = s;
        pCtx->blue_scale = 255 / (pCtx->blue_mask >> s);

        if( (pCtx->red_scale==0) || (pCtx->green_scale==0) ||
            (pCtx->blue_scale==0) )
            return DDERR_INVALIDPIXELFORMAT;

        pCtx->bDDSTargetIsPalettized=FALSE;
    }
    else
    {
        pCtx->bDDSTargetIsPalettized=TRUE;
    }

    if( pZLcl )
    {
        // Get info from the surface
        GET_PIXEL_FORMAT( pZLcl, pZLcl->lpGbl, pZPixFmt );
        if( pZPixFmt->dwZBitMask!=0x0)
        {
            for(s = 0, m = pZPixFmt->dwZBitMask; !(m & 0x1); s++, m >>= 1);
            pCtx->zmask_shift = s;
        }
        else
        {
            // if ZBitMask isn't being set, then Clear2 will never be used,
            // so zbuf_shift/stencil_shift wont be needed anyway
            pCtx->zmask_shift=0;
        }

        if( pZPixFmt->dwStencilBitMask != 0x0 )
        {
            for(s = 0, m = pZPixFmt->dwStencilBitMask; !(m & 0x1);
                s++, m >>= 1) ;
            pCtx->stencilmask_shift = s;
        }
        else
        {
            pCtx->stencilmask_shift=0;
        }
    }

    return S_OK;
}

DWORD WINAPI D3dContextCreate(PD3D8_CONTEXTCREATEDATA pCreateContext)
{
    D3DHAL_CONTEXTCREATEDATA    data;
    DWORD                       ret;
    HRESULT                     hr = S_OK;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateContext->hDD;
    LPDDRAWI_DIRECTDRAW_INT     lpDD = pDevice->pDD;
    PDDSURFACE                  lpDDSTarget = (PDDSURFACE)pCreateContext->hSurface;
    PDDSURFACE                  lpDDSZBuffer = (PDDSURFACE)pCreateContext->hDDSZ;
    PDDCONTEXT                  pContext;
    ULONG                       cjBuffer = 0;

    // Do the allocation first, since if it fails we don't have to do any real cleanup

    ENTER_BOTH();
    pDevice->pContext = NULL;
    pContext = (PDDCONTEXT) MemAlloc(sizeof(DDCONTEXT));
    if (pContext == NULL)
    {
        pCreateContext->ddrval = DDERR_OUTOFMEMORY;
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    // Now allocate the memory for the DPBuffer.
    pContext->pDPBuffer = NULL;

    cjBuffer = pCreateContext->cjBuffer;
    if( cjBuffer == 0)
    {
        cjBuffer = DEF_PRIM_BUFFER_SIZE;
    }
    else if (cjBuffer < MIN_PRIM_BUFFER_SIZE ||
             cjBuffer > MAX_PRIM_BUFFER_SIZE)
    {
        D3D_ERR("Illegal buffer size");
        pCreateContext->ddrval = D3DERR_DRIVERINTERNALERROR;
        MemFree( pContext );
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pContext->pDPBuffer = (LPVOID)MemAlloc( cjBuffer );
    if( pContext->pDPBuffer == NULL )
    {
        pCreateContext->ddrval = DDERR_OUTOFMEMORY;
        MemFree( pContext );
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pCreateContext->pvBuffer = (LPVOID)(((DWORD)pContext->pDPBuffer+31)&(~31));
    pCreateContext->cjBuffer = cjBuffer;

    // We need to check for a lost device before mucking around with the surfaces

    if (CheckForDeviceLost(pDevice))
    {
        pContext->Context = 0;
        pContext->pDevice = pDevice;
        pDevice->pContext = pContext;
        pCreateContext->dwhContext = (ULONG_PTR) pContext;

       // Remember data required to create the context later

        pContext->dwFlags = DDCONTEXT_DEFER;
        pContext->dwTempContext = pCreateContext->dwhContext;
        pContext->dwPID = pCreateContext->dwPID;
        pContext->ddrval = pCreateContext->ddrval;

        pCreateContext->ddrval = DD_OK;

        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    // Calculate the surface info for Clear emulation if needed
    hr = CalcDDSurfInfo( pContext,
                         (lpDDSTarget) ? lpDDSTarget->Surface.pHeavy->lpLcl
                         : NULL,
                         (lpDDSZBuffer) ? lpDDSZBuffer->Surface.pHeavy->lpLcl
                         : NULL );
    if( FAILED( hr ) )
    {
        pCreateContext->ddrval = MapLegacyResult(hr);
        MemFree(pContext->pDPBuffer);
        pCreateContext->pvBuffer = NULL;
        pCreateContext->cjBuffer = 0;
        MemFree(pContext);
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    memset(&data, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));

    pDevice->pContext = NULL;
    if (pDevice->DriverLevel >= 7)
    {
        if (lpDD)
            data.lpDDLcl = lpDD->lpLcl;
        else
            data.lpDDLcl = NULL;

        if (lpDDSTarget)
            data.lpDDSLcl = lpDDSTarget->Surface.pHeavy->lpLcl;
        else
            data.lpDDSLcl = NULL;

        if (lpDDSZBuffer)
            data.lpDDSZLcl = lpDDSZBuffer->Surface.pHeavy->lpLcl;
        else
            data.lpDDSZLcl = NULL;

    }
    else
    {
        if (lpDD)
            data.lpDDGbl = lpDD->lpLcl->lpGbl;
        else
            data.lpDDLcl = NULL;

        if (lpDDSTarget)
            data.lpDDS = (LPDIRECTDRAWSURFACE)lpDDSTarget->Surface.pHeavy;
        else
            data.lpDDS = NULL;

        if (lpDDSZBuffer)
            data.lpDDSZ = (LPDIRECTDRAWSURFACE)lpDDSZBuffer->Surface.pHeavy;
        else
            data.lpDDSZ = NULL;
    }

    // Hack Alert!! dwhContext is used to inform the driver which version
    // of the D3D interface is calling it.
    data.dwhContext = pCreateContext->dwhContext;
    data.dwPID  = pCreateContext->dwPID;
    data.ddrval = pCreateContext->ddrval;

    /* 0 for pre-DX5 devices.
     * 1 for DX5 devices.
     * 2 for DX6 devices.
     * 3 for DX7 devices.
     */

    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                        pDevice,
                        lpDD->lpLcl->lpGbl->lpD3DHALCallbacks->ContextCreate,
                        &data);

    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK)
    {
        D3D_ERR( "Driver did not handle ContextCreate" );
        MemFree(pContext->pDPBuffer);
        pCreateContext->pvBuffer = NULL;
        pCreateContext->cjBuffer = 0;
        MemFree(pContext);
        pCreateContext->dwhContext = 0;
        pCreateContext->ddrval = D3DERR_DRIVERINTERNALERROR;
    }
    else
    {
        pContext->Context = data.dwhContext;
        pContext->pDevice = pDevice;
        pDevice->pContext = pContext;

        pCreateContext->dwhContext = (ULONG_PTR) pContext;
        pCreateContext->ddrval = data.ddrval;
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

HRESULT WINAPI D3dContextDestroy(PD3D8_CONTEXTDESTROYDATA pDestroyContext)
{
    PDDCONTEXT pContext = (PDDCONTEXT) pDestroyContext->dwhContext;

    ENTER_BOTH();
    CheckForDeviceLost(pContext->pDevice);

    pDestroyContext->ddrval = DD_OK;
    if (pContext->Context)
    {
        D3DHAL_CONTEXTDESTROYDATA   data;
        DWORD                       ret;
        DDSURFACE*                  pSurf;

        // If there are any DX6 texture handles created w/ this context,
        // we should destroy them now.

        pSurf = pContext->pDevice->pSurfList;
        while (pSurf != NULL)
        {
            if ((pSurf->dwFlags & DDSURFACE_DX6HANDLE) &&
                (pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy != NULL))
            {
                D3DHAL_TEXTUREDESTROYDATA   data;
                DWORD                       ret;

                data.dwhContext = (ULONG_PTR) pContext->Context;
                data.dwHandle = pSurf->dwCookie;

                CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                    pSurf->pDevice,
                                    pSurf->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy,
                                    &data);
                pSurf->dwFlags &= ~DDSURFACE_DX6HANDLE;
                pSurf->dwCookie = 0;
            }
            pSurf = pSurf->pNext;
        }

        data.dwhContext = (ULONG_PTR) pContext->Context;
        CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                            pContext->pDevice,
                            pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->ContextDestroy,
                            &data);

        pDestroyContext->ddrval = MapLegacyResult(data.ddrval);
    }

    if( pContext->pDPBuffer ) MemFree( pContext->pDPBuffer );
    pContext->pDevice->pContext = NULL;
    MemFree(pContext);
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

void BltFillRects( PDDCONTEXT pCtx, PDDSURFACE pDDS, DWORD count,
                   LPD3DRECT rect, D3DCOLOR dwFillColor)
{
    HRESULT ddrval;
    DDBLTFX bltfx;
    RECT tr;
    DWORD i;
    DWORD r, g, b;

    // Fill with background color

    memset(&bltfx, 0, sizeof(bltfx));
    bltfx.dwSize = sizeof(bltfx);

// unlike clear callback, which just takes pure 32-bit ARGB word and forces the driver to scale it for
// the pixelformat, here we need to compute the exact fill word, depending on surface's R,G,B bitmasks

    if( pCtx->bDDSTargetIsPalettized )
    {
         // Palettized render targets are not supported
         DDASSERT( TRUE );
    }
    else
    {
        DDASSERT((pCtx->red_scale!=0)&&(pCtx->green_scale!=0)&&(pCtx->blue_scale!=0));
        r = RGB_GETRED(dwFillColor) / pCtx->red_scale;
        g = RGB_GETGREEN(dwFillColor) / pCtx->green_scale;
        b = RGB_GETBLUE(dwFillColor) / pCtx->blue_scale;
        bltfx.dwFillColor = (r << pCtx->red_shift) | (g << pCtx->green_shift) |
            (b << pCtx->blue_shift);
    }

    for (i = 0; i < count; i++,rect++)
    {
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do
        {
            ddrval = DD_Surface_Blt( (LPDIRECTDRAWSURFACE)pDDS->Surface.pHeavy,
                                     &tr, NULL, NULL, DDBLT_COLORFILL, &bltfx);
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

void BltFillZRects( PDDCONTEXT pCtx, PDDSURFACE pDDSZ, unsigned long Zpixel,
                    DWORD count, LPD3DRECT rect, DWORD dwWriteMask)
{
    HRESULT ddrval;
    DDBLTFX bltfx;
    DWORD i;
    RECT tr;
    DWORD dwExtraFlags=0;

    memset(&bltfx, 0, sizeof(DDBLTFX));
    bltfx.dwSize = sizeof(DDBLTFX);
    bltfx.dwFillDepth = Zpixel;

    // hack to pass DepthBlt WriteMask through ddraw/ddhel to blitlib
    if( dwWriteMask != 0 )
    {
        bltfx.dwZDestConstBitDepth = dwWriteMask;
        dwExtraFlags = DDBLT_DEPTHFILLWRITEMASK;
    }

    for(i=0; i<count ; i++, rect++)
    {
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do
        {
            ddrval = DD_Surface_Blt( 
                (LPDIRECTDRAWSURFACE)pDDSZ->Surface.pHeavy,
                &tr, NULL, NULL,
                DDBLT_DEPTHFILL |
                dwExtraFlags, &bltfx );
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

DWORD WINAPI D3dClear( PD3D8_CLEAR2DATA pData )
{
    PDDCONTEXT pContext = (PDDCONTEXT) pData->dwhContext;
    LPDDRAWI_DIRECTDRAW_GBL pGbl = NULL;
    DWORD  ret = DDHAL_DRIVER_HANDLED;
    DWORD dwFlags = pData->dwFlags;
    BOOL bDoRGBClear     = ((dwFlags & D3DCLEAR_TARGET)!=0);
    BOOL bDoZClear       = ((dwFlags & D3DCLEAR_ZBUFFER)!=0);
    BOOL bDoStencilClear = ((dwFlags & D3DCLEAR_STENCIL)!=0);
    D3DVALUE dvZ = pData->dvFillDepth;
    PDDSURFACE pZBuffer = NULL;
    LPDDRAWI_DDRAWSURFACE_GBL pZGbl = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL pZLcl = NULL;
    LPDDPIXELFORMAT pZPixFmt = NULL;

    pData->ddrval = S_OK;

    ENTER_BOTH();
    if (CheckForDeviceLost(pContext->pDevice))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }


    pGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
    if( pGbl->lpD3DHALCallbacks3->Clear2 )
    {
        D3DHAL_CLEAR2DATA Clear2Data;
        memcpy( &Clear2Data, pData, sizeof( Clear2Data ) );
        Clear2Data.dwhContext   = pContext->Context;
        Clear2Data.ddrval       = S_OK;
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks3->Clear2,
                             (D3DHAL_CLEAR2DATA *)&Clear2Data);

        LEAVE_BOTH();
        pData->ddrval = MapLegacyResult(Clear2Data.ddrval);
        return ret;
    }

    if( pGbl->lpD3DGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps &
        D3DPRASTERCAPS_ZBUFFERLESSHSR )
    {
        if( bDoStencilClear )
        {
            D3D_ERR( "Invalid flag D3DCLEAR_STENCIL: this ZBUFFERLESSHSR "
                     "device doesn't support Stencil Clears");
            pData->ddrval = D3DERR_DRIVERINTERNALERROR;
            LEAVE_BOTH();
            return DDHAL_DRIVER_NOTHANDLED;
        }

        if( bDoZClear )
        {
            if( !(pGbl->lpD3DHALCallbacks2->Clear) || (dvZ != 1.0f) )
            {
                D3D_WARN(3,"Ignoring D3DCLEAR_ZBUFFER since this "
                         "ZBUFFERLESSHSR device doesn't even support Clear "
                         "or Z!=1");
                dwFlags &= ~(D3DCLEAR_ZBUFFER);
            }
        }
    }

    if( pData->hDDSZ )
    {
        pZBuffer = (PDDSURFACE)pData->hDDSZ;
        pZLcl = pZBuffer->Surface.pHeavy->lpLcl;
        pZGbl = pZLcl->lpGbl;
        pZPixFmt = &pZGbl->ddpfSurface;
    }

    if( pGbl->lpD3DHALCallbacks2->Clear )
    {
        D3DHAL_CLEARDATA ClearData;

        if( bDoZClear || bDoStencilClear )
        {
            if( (pZPixFmt != NULL) && //PowerVR need no Zbuffer
                (DDPF_STENCILBUFFER & pZPixFmt->dwFlags))
            {
                // if surface has stencil bits, must verify either Clear2
                // callback exists or we're using SW rasterizers
                // (which require the special WriteMask DDHEL blt)
                // This case should not be hit since we check right at the
                // driver initialization time if the driver doesnt report
                // Clear2 yet it supports stencils
                if( pZLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
                {
                    goto Emulateclear;
                }
                else
                {
                    LEAVE_BOTH();
                    D3D_ERR( "Driver doesn't support StencilBuffer Clears");
                    pData->ddrval = D3DERR_DRIVERINTERNALERROR;
                    return DDHAL_DRIVER_NOTHANDLED;
                }
            }
            // if Clear2 callback doesnt exist and it's a z-only surface and
            // not doing zclear to non-max value then Clear2 is attempting to
            // do no more than Clear could do, so it's safe to call Clear()
            // instead of Clear2(), which will take advantage of older
            // drivers that implement Clear but not Clear2

            dwFlags &= ~D3DCLEAR_STENCIL;   // Device cannot do stencil
        }

        if( bDoZClear && (dvZ != 1.0) )
        {
            ClearData.dwFlags   = dwFlags & ~D3DCLEAR_ZBUFFER;
            dwFlags = D3DCLEAR_ZBUFFER;
        }
        else
        {
            ClearData.dwFlags = dwFlags;
            dwFlags = 0;
        }

        if (ClearData.dwFlags)
        {
            ClearData.dwhContext   = pContext->Context;
            // Here I will follow the ClearData.dwFillColor convention that
            // color word is raw 32bit ARGB, unadjusted for surface bit depth
            ClearData.dwFillColor  = pData->dwFillColor;
            // must clear to 0xffffffff because legacy drivers expect this
            ClearData.dwFillDepth  = 0xffffffff;
            ClearData.lpRects      = pData->lpRects;
            ClearData.dwNumRects   = pData->dwNumRects;
            ClearData.ddrval       = S_OK;

            // if((err = CheckContextSurface(this)) != D3D_OK)
            // {
            //     throw err;
            // }

            CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                                 pContext->pDevice,
                                 pGbl->lpD3DHALCallbacks2->Clear,
                                 (D3DHAL_CLEARDATA *)&ClearData);

            pData->ddrval = MapLegacyResult(ClearData.ddrval);
            LEAVE_BOTH();

            return ret;
        }
    }

Emulateclear:   // Fall back to Emulation using Blt
    {
        PDDSURFACE pTarget = (PDDSURFACE)pData->hDDS;
        LPDDRAWI_DDRAWSURFACE_GBL pTargetGbl =
            pTarget->Surface.pHeavy->lpLcl->lpGbl;
        DWORD dwStencil = pData->dwFillStencil;

        if(bDoRGBClear)
        {
            BltFillRects( pContext, (PDDSURFACE)pData->hDDS, pData->dwNumRects,
                          pData->lpRects, pData->dwFillColor );
            //ok to not return possible errors from Blt?
        }
        if( (bDoZClear || bDoStencilClear) && NULL != pZPixFmt)
        {
            DWORD   dwZbufferClearValue=0;
            DWORD   dwZbufferClearMask=0;
            DDASSERT(pZPixFmt->dwZBufferBitDepth<=32);
            DDASSERT(pZPixFmt->dwStencilBitDepth<32);
            DDASSERT(pZPixFmt->dwZBitMask!=0x0);
            DDASSERT((0xFFFFFFFF == (pZPixFmt->dwZBitMask |
                                     pZPixFmt->dwStencilBitMask)) |
                     ((DWORD)((1<<pZPixFmt->dwZBufferBitDepth)-1) ==
                      (pZPixFmt->dwZBitMask | pZPixFmt->dwStencilBitMask)));
            DDASSERT(0==(pZPixFmt->dwZBitMask & pZPixFmt->dwStencilBitMask));
            if(bDoZClear)
            {
                dwZbufferClearMask = pZPixFmt->dwZBitMask;
                // special case the common cases
                if( dvZ==1.0f )
                {
                    dwZbufferClearValue = pZPixFmt->dwZBitMask;
                }
                else if( dvZ > 0.0f )
                {
                    dwZbufferClearValue =
                        ((DWORD)((dvZ*(pZPixFmt->dwZBitMask >>
                                       pContext->zmask_shift)) + 0.5)) <<
                        pContext->zmask_shift;
                }
            }

            if( bDoStencilClear )
            {
                DDASSERT(pZPixFmt->dwStencilBitMask!=0x0);
                DDASSERT(pZPixFmt->dwFlags & DDPF_STENCILBUFFER);
                dwZbufferClearMask |= pZPixFmt->dwStencilBitMask;
                // special case the common case
                if( dwStencil != 0 )
                {
                    dwZbufferClearValue |= (dwStencil <<
                                            pContext->stencilmask_shift) &
                        pZPixFmt->dwStencilBitMask;
                }
            }
            if( dwZbufferClearMask == (pZPixFmt->dwStencilBitMask |
                                       pZPixFmt->dwZBitMask) )
            {
                // do Stencil & Z Blt together, using regular DepthFill blt
                // which will be faster than the writemask blt because its
                // write-only, instead of read-modify-write
                dwZbufferClearMask = 0;
            }
            BltFillZRects( pContext, (PDDSURFACE)pData->hDDSZ,
                           dwZbufferClearValue, pData->dwNumRects,
                           pData->lpRects, dwZbufferClearMask );
        }
    }
    LEAVE_BOTH();

    return ret;
}

DWORD WINAPI D3dSetRenderTarget( PD3D8_SETRENDERTARGETDATA pData )
{
    PDDCONTEXT pContext = (PDDCONTEXT) pData->dwhContext;
    LPDDRAWI_DIRECTDRAW_GBL pGbl = NULL;
    DWORD  ret = DDHAL_DRIVER_HANDLED;

    ENTER_BOTH();
    if (CheckForDeviceLost(pContext->pDevice))
    {
        LEAVE_BOTH();
        pData->ddrval = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    pGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
    if( pGbl->lpD3DHALCallbacks2->SetRenderTarget )
    {
        D3DHAL_SETRENDERTARGETDATA srtData;

        // If creation of the render target was defered, create it now

        if (pContext->dwFlags & DDCONTEXT_DEFER)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pTarget = NULL;
            LPDDRAWI_DDRAWSURFACE_INT   pZ = NULL;
            HRESULT                     hr;
            D3DHAL_CONTEXTCREATEDATA    data;
            DWORD                       ret;

            if (pData->hDDS)
            {
                pTarget = ((PDDSURFACE)pData->hDDS)->Surface.pHeavy;
            }
            if (pData->hDDSZ)
            {
                pZ = ((PDDSURFACE)pData->hDDSZ)->Surface.pHeavy;
            }

            // Calculate the surface info for Clear emulation if needed
            CalcDDSurfInfo(pContext,
                           (pTarget) ? pTarget->lpLcl : NULL,
                           (pZ) ? pZ->lpLcl : NULL);

            memset(&data, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));
            if (pContext->pDevice->DriverLevel >= 7)
            {
                if (pContext->pDevice->pDD != NULL)
                {
                    data.lpDDLcl = pContext->pDevice->pDD->lpLcl;
                }

                if (pTarget != NULL)
                {
                    data.lpDDSLcl = pTarget->lpLcl;
                }
                else
                {
                    data.lpDDSLcl = NULL;
                }
                if (pZ != NULL)
                {
                    data.lpDDSZLcl = pZ->lpLcl;
                }
                else
                {
                    data.lpDDSZLcl = NULL;
                }
            }
            else
            {
                if (pContext->pDevice->pDD != NULL)
                {
                    data.lpDDGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
                }

                data.lpDDS = (LPDIRECTDRAWSURFACE)pTarget;
                data.lpDDSZ = (LPDIRECTDRAWSURFACE) pZ;
            }

            // Hack Alert!! dwhContext is used to inform the driver which version
            // of the D3D interface is calling it.
            data.dwhContext = pContext->dwTempContext;
            data.dwPID  = pContext->dwPID;
            data.ddrval = pContext->ddrval;

            /* 0 for pre-DX5 devices.
             * 1 for DX5 devices.
             * 2 for DX6 devices.
             * 3 for DX7 devices.
             */

            CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                        pContext->pDevice,
                        pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->ContextCreate,
                        &data);

            if (ret == DDHAL_DRIVER_HANDLED && data.ddrval == DD_OK)
            {
                pContext->Context = data.dwhContext;
            }
            pContext->dwFlags &= ~DDCONTEXT_DEFER;
        }

        pData->bNeedUpdate = FALSE;
        memset( &srtData, 0, sizeof( srtData ) );
        srtData.dwhContext = pContext->Context;
        if( pData->hDDS )
            srtData.lpDDS =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDS)->Surface.pHeavy;
        if( pData->hDDSZ )
            srtData.lpDDSZ =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDSZ)->Surface.pHeavy;
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks2->SetRenderTarget,
                             (D3DHAL_SETRENDERTARGETDATA *)&srtData );
        pData->ddrval = MapLegacyResult(srtData.ddrval);

        // If we need to create any defered texture handles, we will do so now

        if (pContext->dwFlags & DDCONTEXT_DEFEREDTEXTUREHANDLES)
        {
            DDSURFACE* pSurf;

            pContext->dwFlags &= ~ DDCONTEXT_DEFEREDTEXTUREHANDLES;
            pSurf = pContext->pDevice->pSurfList;
            while (pSurf != NULL)
            {
                if (pSurf->dwFlags & DDSURFACE_DEFERCREATETEXHANDLE)
                {
                    D3DHAL_TEXTURECREATEDATA    data;
                    DWORD                       ret;

                    memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
                    data.dwhContext = pContext->Context;
                    data.lpDDS = (LPDIRECTDRAWSURFACE) pSurf->Surface.pHeavy;

                    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                pContext->pDevice,
                                pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate,
                                &data);

                    pSurf->dwCookie = data.dwHandle;
                    pSurf->dwFlags |= DDSURFACE_DX6HANDLE;
                    pSurf->dwFlags &= ~DDSURFACE_DEFERCREATETEXHANDLE;
                }
                pSurf = pSurf->pNext;
            }
        }

        LEAVE_BOTH();
        return ret;
    }
    else
    {
        D3DHAL_CONTEXTCREATEDATA cdata;
        D3DHAL_CONTEXTDESTROYDATA ddata;
        DDSURFACE* pTemp;

        // If we have allocated any texture handles, we need to free them now

        pTemp = pContext->pDevice->pSurfList;
        while (pTemp != NULL)
        {
            if ((pTemp->dwFlags & DDSURFACE_DX6HANDLE) &&
                (pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy != NULL))
            {
                D3DHAL_TEXTUREDESTROYDATA   data;
                DWORD                       ret;

                data.dwhContext = (ULONG_PTR) pContext->Context;
                data.dwHandle = pTemp->dwCookie;

                CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                    pTemp->pDevice,
                                    pTemp->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy,
                                    &data);
            }
            pTemp = pTemp->pNext;
        }

        pData->bNeedUpdate = TRUE;
        memset( &ddata, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA) );

        // Destroy Old Context
        ddata.dwhContext = pContext->Context;
        if (pContext->Context != 0)
        {
            CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                                 pContext->pDevice,
                                 pGbl->lpD3DHALCallbacks->ContextDestroy,
                                 &ddata );

            if (ret != DDHAL_DRIVER_HANDLED || ddata.ddrval != DD_OK)
            {
                D3D_ERR( "SRT emulation, ContextDestroy failed." );
                LEAVE_BOTH();
                pData->ddrval = MapLegacyResult(ddata.ddrval);
                return ret;
            }
        }
        pContext->dwFlags &= ~(DDCONTEXT_DEFER | DDCONTEXT_DEFEREDTEXTUREHANDLES);

        // Create a new Context
        memset( &cdata, 0, sizeof(D3DHAL_CONTEXTCREATEDATA) );
        cdata.lpDDGbl = pGbl;
        if( pData->hDDS )
            cdata.lpDDS =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDS)->Surface.pHeavy;;
        if( pData->hDDSZ )
            cdata.lpDDSZ =
                (LPDIRECTDRAWSURFACE)((PDDSURFACE)pData->hDDSZ)->Surface.pHeavy;
        // Hack Alert!! dwhContext is used to inform the driver which version
        // of the D3D interface is calling it.
        // We don't want DX6 drivers to know that we are DX8 because
        // we found at least one driver that starts behaving differently when
        // it sees anything other than 3. (the driver was TNT2 and it turned
        // off multitexturing thinking that anything other than 3 means DX5 
        // or below)
        cdata.dwhContext = 3;
        DDASSERT(pContext->pDevice->DriverLevel < 7); // should never get here for DX7 or above drivers
        cdata.dwPID  = GetCurrentProcessId();
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks->ContextCreate,
                             &cdata );
        if (ret != DDHAL_DRIVER_HANDLED || cdata.ddrval != DD_OK)
        {
            D3D_ERR( "SRT emulation, ContextCreate failed" );
            LEAVE_BOTH();
            pData->dwhContext = 0;
            pData->ddrval = MapLegacyResult(cdata.ddrval);
            return ret;
        }
        pContext->Context = cdata.dwhContext;
        pData->ddrval = MapLegacyResult(cdata.ddrval);

        // Now we need to re-create any texture handles that we destroyed

        if (pData->ddrval == DD_OK)
        {
            pTemp = pContext->pDevice->pSurfList;
            while (pTemp != NULL)
            {
                if ((pTemp->dwFlags & DDSURFACE_DX6HANDLE) ||
                    (pTemp->dwFlags & DDSURFACE_DEFERCREATETEXHANDLE))
                {
                    D3DHAL_TEXTURECREATEDATA    data;
                    DWORD                       ret;

                    memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
                    data.dwhContext = pContext->Context;
                    data.lpDDS = (LPDIRECTDRAWSURFACE) pTemp->Surface.pHeavy;

                    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret,
                                        pTemp->pDevice,
                                        pTemp->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureCreate,
                                        &data);
                    pTemp->dwCookie = data.dwHandle;
                    pTemp->dwFlags |= DDSURFACE_DX6HANDLE;
                    pTemp->dwFlags &= ~DDSURFACE_DEFERCREATETEXHANDLE;
                }
                pTemp = pTemp->pNext;
            }
        }
    }
    LEAVE_BOTH();
    return ret;
}


HRESULT WINAPI D3dContextDestroyAll(PD3D8_CONTEXTDESTROYALLDATA pDestroyAllContext)
{
    return DDHAL_DRIVER_HANDLED;
}


HRESULT WINAPI D3dGetDriverState(PD3D8_GETDRIVERSTATEDATA pGetDriverState)
{
    PDDCONTEXT  pContext = (PDDCONTEXT) pGetDriverState->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pGetDriverState->ddRVal = D3DERR_DRIVERINTERNALERROR;
    ENTER_BOTH();
    if (!CheckForDeviceLost(pContext->pDevice))
    {
        pTemp = pGetDriverState->dwhContext;
        pGetDriverState->dwhContext = (ULONG_PTR) pContext->Context;

        CALL_D3DHAL_TAKEBUSY_NOWIN16(dwRet,
                    pContext->pDevice,
                    pContext->pDevice->pDD->lpLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState,
                    (LPDDHAL_GETDRIVERSTATEDATA)pGetDriverState);
        pGetDriverState->dwhContext = pTemp;

        pGetDriverState->ddRVal = MapLegacyResult(pGetDriverState->ddRVal);
    }
    LEAVE_BOTH();

    return dwRet;
}


HRESULT WINAPI D3dValidateTextureStageState(PD3D8_VALIDATETEXTURESTAGESTATEDATA pValidate)
{
    PDDCONTEXT  pContext = (PDDCONTEXT) pValidate->dwhContext;
    DWORD       dwRet = DDHAL_DRIVER_HANDLED;
    ULONG_PTR   pTemp;

    pValidate->ddrval = D3DERR_DEVICELOST;
    pValidate->dwNumPasses = 0;
    ENTER_BOTH();
    if (!CheckForDeviceLost(pContext->pDevice))
    {
        pTemp = pValidate->dwhContext;
        pValidate->dwhContext = (ULONG_PTR) pContext->Context;
        CALL_D3DHAL_TAKEBUSY_NOWIN16(dwRet,
                    pContext->pDevice,
                    pContext->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks3->ValidateTextureStageState,
                    (D3DHAL_VALIDATETEXTURESTAGESTATEDATA*) pValidate);
        pValidate->dwhContext = pTemp;
    }
    LEAVE_BOTH();

    return dwRet;
}


DWORD WINAPI D3dDrawPrimitives2(PD3D8_DRAWPRIMITIVES2DATA pdp2data)
{
    D3DHAL_DRAWPRIMITIVES2DATA  dp2data;
    DWORD                       ret = 0;
    PDDCONTEXT                  pContext = (PDDCONTEXT) pdp2data->dwhContext;
    DDSURFACE*                  pSurfCommand;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyCommand;
    DDSURFACE*                  pSurfVertex = NULL;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyVertex = NULL;

    // Copy the data into our structure for easy access
    memcpy (&dp2data, pdp2data, sizeof(dp2data));

    // Start processing
    ENTER_BOTH();

    // Handle loss 
    if (CheckForDeviceLost(((PDDSURFACE)pdp2data->hDDCommands)->pDevice))
    {
        pdp2data->ddrval = DD_OK;
        pdp2data->dwErrorOffset = 0;

        // Need to set these values to their original
        // state so that the FE doesn't get confused.
        pdp2data->fpVidMem_CB     = 0;
        pdp2data->dwLinearSize_CB = 0;
        pdp2data->fpVidMem_VB       = 0;
        pdp2data->dwLinearSize_VB   = 0;

        // May need to return a pointer here
        if ((dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) && 
            !(dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES))
        {
            DDSURFACE*  pVertex = (PDDSURFACE)pdp2data->hDDVertex;

            if (pVertex->Pool == D3DPOOL_SYSTEMMEM)
            {                           
                if (pVertex->dwFlags & DDSURFACE_LIGHTWEIGHT)
                {
                    pdp2data->fpVidMem_VB = pVertex->Surface.pLight->fpGblVidMem;
                    pdp2data->dwLinearSize_VB = pVertex->Surface.pLight->GblPitch;
                }
                else
                {
                    pdp2data->fpVidMem_VB = pVertex->Surface.pHeavy->lpLcl->lpGbl->fpVidMem;
                    pdp2data->dwLinearSize_VB = pVertex->Surface.pHeavy->lpLcl->lpGbl->dwLinearSize;
                }
            }
            else if (pVertex->dwFlags & DDSURFACE_HEAVYWEIGHT)
            {
                if ((pVertex->fpVidMem == NULL) ||
                    !(pVertex->dwFlags & DDSURFACE_SYSMEMALLOCATED))
                {
                    pVertex->fpVidMem = (char*) MemAlloc(pVertex->Pitch);
                    if (pVertex->fpVidMem != NULL)
                    {
                        pVertex->dwFlags |= DDSURFACE_SYSMEMALLOCATED;
                    }
                }
                if (pVertex->dwFlags & DDSURFACE_SYSMEMALLOCATED)
                {
                    pdp2data->fpVidMem_VB = (ULONG_PTR) pVertex->fpVidMem;
                    pdp2data->dwLinearSize_VB = pVertex->Pitch;
                }
                else
                {
                    pdp2data->ddrval = DDERR_GENERIC;
                }
            }
        }
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pSurfCommand = (PDDSURFACE)pdp2data->hDDCommands;
    pHeavyCommand = GetHeavyweightSurf(pSurfCommand);
    if (pHeavyCommand != NULL)
    {
        dp2data.lpDDCommands = pHeavyCommand->lpLcl;
    }
    else
    {
        pdp2data->ddrval = DDERR_OUTOFMEMORY;
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    if (!(pdp2data->dwFlags & D3DHALDP2_USERMEMVERTICES))
    {
        pSurfVertex = (PDDSURFACE)pdp2data->hDDVertex;
        pHeavyVertex = GetHeavyweightSurf(pSurfVertex);
        dp2data.lpDDVertex = pHeavyVertex->lpLcl;
    }
    dp2data.dwhContext = ((PDDCONTEXT)dp2data.dwhContext)->Context;

    if (((PDDSURFACE)pdp2data->hDDCommands)->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks3->DrawPrimitives2)
    {
        CALL_D3DHAL_TAKEBUSY_NOWIN16(
            ret,
            ((PDDSURFACE)pdp2data->hDDCommands)->pDevice,
            ((PDDSURFACE)pdp2data->hDDCommands)->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks3->DrawPrimitives2,
            &dp2data);
        if ((ret == DDHAL_DRIVER_HANDLED) && (dp2data.ddrval != DD_OK)
            && (DDERR_WASSTILLDRAWING != dp2data.ddrval))
        {
            ((PDDSURFACE)pdp2data->hDDCommands)->pDevice->bDP2Error = TRUE;
        }
    }

    // If the call to the driver succeded, swap the buffers if needed and
    // perform GetAliasVidmem
    if (ret == DDHAL_DRIVER_HANDLED && (dp2data.ddrval == DD_OK))
    {
        pdp2data->fpVidMem_CB = 0;
        pdp2data->dwLinearSize_CB = 0;
        pdp2data->fpVidMem_VB = 0;
        pdp2data->dwLinearSize_VB = 0;

        if (dp2data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER)
        {
            // CONSIDER: Implement VidMem command buffer
        }

        if ((dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) && !(dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES))
        {
            FLATPTR paliasbits;
            DWORD   dwLinearSize = dp2data.lpDDVertex->lpGbl->dwLinearSize;
            if (dp2data.dwFlags & D3DHALDP2_VIDMEMVERTEXBUF)
            {
                paliasbits = GetAliasedVidMem( dp2data.lpDDVertex->lpSurfMore->lpDD_lcl,
                                               dp2data.lpDDVertex,
                                               (FLATPTR) dp2data.lpDDVertex->lpGbl->fpVidMem );
                if (paliasbits == 0)
                {
                    D3D_ERR( "Could not get Aliased pointer for vid mem vertex buffer" );
                    // Since we can't use this pointer, set it's size to 0
                    // That way next time around we will try and allocate a new one
                    dwLinearSize = 0;
                }
            }
            else
            {
                paliasbits = dp2data.lpDDVertex->lpGbl->fpVidMem;
            }

            pdp2data->fpVidMem_VB = paliasbits;
            pdp2data->dwLinearSize_VB = dwLinearSize;
        }
    }
    if ((pSurfCommand->dwFlags & DDSURFACE_LIGHTWEIGHT) &&
        (pHeavyCommand != NULL))
    {
        UnmapLightweightSurface (pSurfCommand);
    }
    if ((pSurfVertex != NULL ) &&
        (pSurfVertex->dwFlags & DDSURFACE_LIGHTWEIGHT) &&
        (pHeavyVertex != NULL))
    {
        UnmapLightweightSurface (pSurfVertex);
   }

    pdp2data->ddrval = dp2data.ddrval;
    pdp2data->dwErrorOffset = dp2data.dwErrorOffset;
    LEAVE_BOTH();

    // We don't map the errors to the new ones because the runtime still needs
    // to deal with WASSTILLDRAWING, so it does the mapping instead of us.

    return ret;
}


PALETTEINFO* GetPaletteInfo (PDDDEVICEHANDLE pDevice, DWORD PaletteID)
{
    PALETTEINFO*    pPaletteInfo;
    HRESULT         hr;
    DWORD           i;

    // The palette IDs are app defined and can range from 0 - 65500.  We don't
    // want to always allocate a table with 65500 entries, and we don't want
    // to walk a list on every palette call, so we will grow the table to the
    // desired whenever we need to.  This works well if we assume that most
    // apps will start with low numbers and then work up.

    if (PaletteID >= pDevice->NumPaletteHandleEntries)
    {
        // We need to grow the table

        DWORD           NewTableSize;
        PALETTEINFO**   pNewTable;

        if (((DWORD)-1) - PaletteID <= EXTRA_PALETTE_PADDING)
        {
            NewTableSize = PaletteID + 1;
        }
        else
        {
            NewTableSize = PaletteID + EXTRA_PALETTE_PADDING + 1;
        }
        pNewTable = MemAlloc(NewTableSize * sizeof(PALETTEINFO*));
        if (pNewTable == NULL)
        {
            return NULL;
        }
        if ((pDevice->pPaletteHandleTable) &&
            (pDevice->NumPaletteHandleEntries > 0))
        {
            memcpy(pNewTable,
                   pDevice->pPaletteHandleTable,
                   pDevice->NumPaletteHandleEntries * sizeof(PALETTEINFO*));
            MemFree(pDevice->pPaletteHandleTable);
        }
        pDevice->pPaletteHandleTable = pNewTable;
        pDevice->NumPaletteHandleEntries = NewTableSize;
    }

    // If we already have info for this palette, we just return it now

    if (pDevice->pPaletteHandleTable[PaletteID] != NULL)
    {
        return pDevice->pPaletteHandleTable[PaletteID];
    }

    // Otherwise, we allocate a structure and initialize it

    pPaletteInfo = MemAlloc(sizeof(PALETTEINFO));
    if (pPaletteInfo == NULL)
    {
        return NULL;
    }
    for (i = 0; i < 256; i++)
    {
        pPaletteInfo->ColorTable[i].peRed   = (UCHAR) i;
        pPaletteInfo->ColorTable[i].peGreen = (UCHAR) i;
        pPaletteInfo->ColorTable[i].peBlue  = (UCHAR) i;
        pPaletteInfo->ColorTable[i].peFlags = (UCHAR) 0;
    }
    hr = DD_CreatePalette ((LPDIRECTDRAW) pDevice->pDD,
                            DDPCAPS_8BIT,
                            pPaletteInfo->ColorTable,
                            &pPaletteInfo->pDDPalette,
                            NULL);
    if (hr != DD_OK)
    {
        MemFree(pPaletteInfo);
        return NULL;
    }

    pDevice->pPaletteHandleTable[PaletteID] = pPaletteInfo;
    return pPaletteInfo;
}


DWORD WINAPI DdSetPalette (PD3D8_SETPALETTEDATA pSetPalette)
{
    PALETTEINFO*    pPalette;

    DDASSERT (((PDDDEVICEHANDLE)pSetPalette->hDD)->DriverLevel == 6);

    ENTER_BOTH();
    CheckForDeviceLost(pSetPalette->hDD);

    pSetPalette->ddRVal = D3DERR_DRIVERINTERNALERROR;
    pPalette = GetPaletteInfo (pSetPalette->hDD,
                               pSetPalette->Palette);
    if (pPalette != NULL)
    {
        pSetPalette->ddRVal = DD_OK;
        if ((((DDSURFACE*)pSetPalette->hSurface)->Surface.pHeavy != NULL) &&
            (((DDSURFACE*)pSetPalette->hSurface)->Surface.pHeavy->lpLcl->lpDDPalette !=
                (LPDDRAWI_DDRAWPALETTE_INT)pPalette->pDDPalette))
        {
            pSetPalette->ddRVal = MapLegacyResult(DD_Surface_SetPalette(
                (LPDIRECTDRAWSURFACE)((DDSURFACE*)pSetPalette->hSurface)->Surface.pHeavy,
                pPalette->pDDPalette));
        }
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

DWORD WINAPI DdUpdatePalette (PD3D8_UPDATEPALETTEDATA pUpdatePalette)
{
    PALETTEINFO*    pPalette;

    DDASSERT (((PDDDEVICEHANDLE)pUpdatePalette->hDD)->DriverLevel == 6);

    ENTER_BOTH();
    CheckForDeviceLost(pUpdatePalette->hDD);

    pUpdatePalette->ddRVal = D3DERR_DRIVERINTERNALERROR;
    pPalette = GetPaletteInfo (pUpdatePalette->hDD,
                               pUpdatePalette->Palette);
    if (pPalette != NULL)
    {
        pUpdatePalette->ddRVal = MapLegacyResult(DD_Palette_SetEntries(
                                            pPalette->pDDPalette,
                                            0,
                                            0,
                                            256,
                                            pUpdatePalette->ColorTable));
    }
    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

DWORD WINAPI D3dSceneCapture (PD3D8_SCENECAPTUREDATA pData)
{
    PDDCONTEXT pContext = (PDDCONTEXT) pData->dwhContext;
    LPDDRAWI_DIRECTDRAW_GBL pGbl = NULL;
    DWORD  ret = DDHAL_DRIVER_HANDLED;

    pData->ddrval = S_OK;

    ENTER_BOTH();
    if (CheckForDeviceLost(pContext->pDevice))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    pGbl = pContext->pDevice->pDD->lpLcl->lpGbl;
    if( pGbl->lpD3DHALCallbacks->SceneCapture )
    {
        D3DHAL_SCENECAPTUREDATA SceneCaptureData;
        memcpy( &SceneCaptureData, pData, sizeof( SceneCaptureData ) );
        SceneCaptureData.dwhContext   = pContext->Context;
        SceneCaptureData.ddrval       = S_OK;
        CALL_D3DHAL_TAKEBUSY_NOWIN16( ret,
                             pContext->pDevice,
                             pGbl->lpD3DHALCallbacks->SceneCapture,
                             (D3DHAL_SCENECAPTUREDATA *)&SceneCaptureData);

        LEAVE_BOTH();
        pData->ddrval = MapLegacyResult(SceneCaptureData.ddrval);
        return ret;
    }

    LEAVE_BOTH();

    return DDHAL_DRIVER_HANDLED;
}

//
// D3D8CreateDirectDrawObject
//
// Creates a DirectDraw object in DDRAW.DLL.  By mainting a full representation of
// this object in DDRAW.DLL, it will automatically update the HAL info after mode
// changes, etc.

VOID APIENTRY D3D8CreateDirectDrawObject( LPGUID        lpGuid,
                                          char          *szDeviceName,
                                          HANDLE*       phDD,
                                          D3DDEVTYPE    Type,
                                          HINSTANCE*    phLibrary,
                                          VOID*         pInitFunction)
{
    HRESULT         hr;
    LPDIRECTDRAW    lpDD1;
    PD3D8GetSWInfo  pfnHookCreate;
    DDDEVICEHANDLE* pDeviceHandle;
    HKEY            hKey = (HKEY) NULL;

    ENTER_DDRAW();
    *phDD = NULL;
    *phLibrary = NULL;
    pDeviceHandle = (PDDDEVICEHANDLE) MemAlloc(sizeof(DDDEVICEHANDLE));
    if (pDeviceHandle == NULL)
    {
        LEAVE_DDRAW();
        return;
    }
    lstrcpy(pDeviceHandle->szDeviceName, szDeviceName);
    pDeviceHandle->PID = GetCurrentProcessId();

    hr = InternalDirectDrawCreate (NULL, &lpDD1, NULL, 
        DDRAWILCL_DIRECTDRAW7 | DDRAWILCL_DIRECTDRAW8, szDeviceName);
    if( DD_OK == hr )
    {
        // Make it point to the DX7 vtbl.  Do this rather than a QI since
        // a QI for a DX7 object has some extra overhead.

        lpDD1->lpVtbl = (LPVOID) &dd7Callbacks;
        pDeviceHandle->pDD = (HANDLE) (LPDDRAWI_DIRECTDRAW_INT)lpDD1;
        pDeviceHandle->DeviceType = Type;

        if (Type == D3DDEVTYPE_REF)
        {
            // Load the refrast and let them take things over
            *phLibrary = LoadLibrary (D3D8_REFRASTNAME);
            pDeviceHandle->pSwDD = SwDDICreateDirectDraw();
            if (pDeviceHandle->pSwDD != NULL)
            {
                *phDD = (HANDLE*) pDeviceHandle;
            }
            else
            {
                lpDD1->lpVtbl->Release(lpDD1);
            }
        }
        else if (Type == D3DDEVTYPE_SW)
        {
            pDeviceHandle->pSwDD = SwDDICreateDirectDraw();
            if (pDeviceHandle->pSwDD != NULL)
            {
                *phDD = (HANDLE*) pDeviceHandle;
                pDeviceHandle->pSwInitFunction = pInitFunction;
            }
        }
        else
        {
            *phDD = (HANDLE*) pDeviceHandle;
        }
    }

    if (*phDD == NULL)
    {
        MemFree(pDeviceHandle);
    }
    else
    {
        pDeviceHandle->pLink = pDeviceList;
        pDeviceList = pDeviceHandle;
    }
    LEAVE_DDRAW();

    // See if they want to explicitly enable/disable lightweight surfaces

    if ((*phDD != NULL) && (!RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey)))
    {
        DWORD   type;
        DWORD   value;
        DWORD   cb = sizeof(value);

        pDeviceHandle->ForceFlagsOn = 0;
        pDeviceHandle->ForceFlagsOff = 0;
#ifdef DEBUG
        if (!RegQueryValueEx(hKey, "ForceDriverFlagsOn", NULL, &type, (CONST LPBYTE)&value, &cb))
        {
            pDeviceHandle->ForceFlagsOn = value;
        }
        cb = sizeof(value);
#endif
        if (!RegQueryValueEx(hKey, "ForceDriverFlagsOff", NULL, &type, (CONST LPBYTE)&value, &cb))
        {
            pDeviceHandle->ForceFlagsOff = value;
        }
        RegCloseKey(hKey);
    }
}

//
// D3D8ReenableDirectDrawObject
//
// On Win9X, this function doesn't do anything, but we have it since Win2K
// requires it and keeping it keeps the code bases more similar between the
// two platforms.

BOOL WINAPI D3D8ReenableDirectDrawObject( HANDLE hDD, LPBOOL pbNewMode )
{
    *pbNewMode = TRUE;
    return TRUE;
}

BOOL
SWCursorForced()
{
    if (0 != GetPrivateProfileInt("Display", "SwCursor", 0, "SYSTEM.INI"))
    {
        // ini setting always takes precedence
        DPF(2,"System.ini says SwCursor is ON");
        return TRUE;
    }
    else 
    {
        HKEY key;

        if (RegOpenKey(HKEY_CURRENT_CONFIG, "Display\\Settings", &key) == ERROR_SUCCESS)
        {
            char temp[10];
            DWORD len = sizeof(temp);
            DWORD type;
            DWORD i;
            if ((RegQueryValueEx(key, "SwCursor", NULL, (LPDWORD)&type,
                (LPBYTE)(LPSTR)temp, (LPDWORD)&len) == ERROR_SUCCESS) &&
                (type == REG_SZ))
            {
                for (i = 0; i < len; i++)
                {
                    if ( 0 == temp[i] )
                        break;                   
                    if ( '0' != temp[i] )
                    {
                        RegCloseKey(key);
                        DPF(2,"Regkey SwCursor is ON");
                        return TRUE;
                    }
                }
            }
            RegCloseKey(key);
        }
    }
    return FALSE;
}

//
// D3D8QueryDirectDrawObject
//
// This gets all of the actual HAL info.  It will typically be called twice,
// the first time to get the basic info (some of the input pointers will be
// NULL), and again to get all of the info.

BOOL WINAPI D3D8QueryDirectDrawObject (HANDLE           hDD,
                                       PD3D8_DRIVERCAPS pDriverCaps,
                                       PD3D8_CALLBACKS  pCallbacks,
                                       char             *pDeviceName,
                                       HINSTANCE        hLibrary,
                                       D3D8_GLOBALDRIVERDATA*  pGblDriverData,
                                       D3DHAL_D3DEXTENDEDCAPS* pExtendedCaps,
                                       LPDDSURFACEDESC  pTextureFormats,
                                       LPDDPIXELFORMAT  pZStencilFormats,
                                       UINT*            pcTextureFormats,
                                       UINT*            pcZStencilFormats
                                       )
{
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    DDSCAPSEX                   SurfCapsEx;
    DWORD                       dwRet;
    DWORD                       i;
    HDC                         hdc;
    D3DFORMAT*                  pTempZStencil;
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) hDD;
    DDHAL_GETDRIVERINFODATA     GetDriverInfoData;
    BOOL                        GotDX8Formats;

    ENTER_DDRAW();

    pdrv_lcl = pDevice->pDD->lpLcl;
    pdrv = pdrv_lcl->lpGbl;

    // Get all of the neccesary caps

    memset(pDriverCaps, 0, sizeof(D3D8_DRIVERCAPS));

    pDriverCaps->D3DCaps.Caps         = pdrv->ddCaps.dwCaps;
    pDriverCaps->D3DCaps.Caps2        = pdrv->ddCaps.dwCaps2;
    pDriverCaps->D3DCaps.Caps3        = pdrv->ddCaps.dwSVCaps;
    pDriverCaps->SVBCaps              = pdrv->ddCaps.dwSVBCaps;
    pDriverCaps->VSBCaps              = pdrv->ddCaps.dwVSBCaps;
    pDriverCaps->SVBCaps2             = pdrv->ddCaps.dwSVBCaps2;

    SurfCapsEx.dwCaps2                = pdrv->ddsCapsMore.dwCaps2;
    SurfCapsEx.dwCaps3                = pdrv->ddsCapsMore.dwCaps3;
    SurfCapsEx.dwCaps4                = pdrv->ddsCapsMore.dwCaps4;

    if (!IS_SOFTWARE_DRIVER(pDevice))
    {
        GotDX8Formats = FALSE;

        // See if we can get the DX8 caps directly
        if ((pdrv->dwFlags & DDRAWI_DRIVERINFO2) &&
            (pdrv->pGetDriverInfo != NULL))
        {
            D3DCAPS8                caps8;
            DD_GETDRIVERINFO2DATA*  pgdi2;
            
            memset(&caps8, 0, sizeof(caps8));

            pgdi2 = (DD_GETDRIVERINFO2DATA*)&caps8;

            // sizeof(DD_STEREOMODE)? The GUID for GetDriverInfo2 is shared with
            // the stereo mode querying stuff. Therefore we need to pass down
            // the structure size (and the expected data size) as
            // sizeof(DD_STEREOMODE) even though we actually have a buffer (and
            // expect a size of sizeof(D3DCAPS8).
            pgdi2->dwReserved     = sizeof(D3DCAPS8);
            pgdi2->dwMagic        = D3DGDI2_MAGIC;
            pgdi2->dwType         = D3DGDI2_TYPE_GETD3DCAPS8;
            pgdi2->dwExpectedSize = sizeof(D3DCAPS8);

            memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
            GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
            GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
            GetDriverInfoData.lpvData        = &caps8;
            GetDriverInfoData.dwExpectedSize = sizeof(D3DCAPS8);

            // Pass a context variable so that the driver
            // knows which instance of itself to use
            // w.r.t. this function. These are different
            // values on Win95 and NT.
            GetDriverInfoData.dwContext = pdrv->dwReserved3;

            if ((pdrv->pGetDriverInfo(&GetDriverInfoData) == DDHAL_DRIVER_HANDLED) && 
                (GetDriverInfoData.ddRVal == DD_OK ))
            {
                // Looks like we got D3DCAPS8 back from the driver. Verify by means
                // of the dwActualSize field in GetDriverInfoData.
                if (sizeof(D3DCAPS8) != GetDriverInfoData.dwActualSize)
                {
                    DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(D3DCAPS8))");
                    LEAVE_DDRAW();
                    return(FALSE);
                }

                // All went well. Copy the caps data across
                memcpy(&pDriverCaps->D3DCaps, &caps8, sizeof(caps8));

                // Display drivers can all render windowed
                if (pdrv->ddCaps.dwCaps2 & DDCAPS2_CANRENDERWINDOWED)
                {
                    pDriverCaps->D3DCaps.Caps2 |= DDCAPS2_CANRENDERWINDOWED;
                }

                // Set the flag indicating that the DDI successfully reported DX8
                // style caps
                pDriverCaps->dwFlags |= DDIFLAG_D3DCAPS8;
            }
        }

        // If this driver supports the DX8 DDI then use the new surface format reporting
        // mechanism rather than the texture formats reported in the global driver data
        if (pDriverCaps->dwFlags & DDIFLAG_D3DCAPS8)
        {
            DD_GETDRIVERINFO2DATA* pgdi2;
            DD_GETFORMATCOUNTDATA  gfcd;
            DD_GETFORMATDATA       gfd;

            // If DDIFLAG_D3DCAPS8 got set we have a driver info 2 support
            DDASSERT(pdrv->dwFlags & DDRAWI_DRIVERINFO2);
            DDASSERT(pdrv->pGetDriverInfo != NULL);

            // Step 1: Get the number of supported formats
            // Please see the description comments above for a description of why the
            // reserved field is set to sizeof(DD_STEREOMODE)
            memset(&gfcd, 0, sizeof(gfcd));

            gfcd.gdi2.dwReserved     = sizeof(DD_GETFORMATCOUNTDATA);
            gfcd.gdi2.dwMagic        = D3DGDI2_MAGIC;
            gfcd.gdi2.dwType         = D3DGDI2_TYPE_GETFORMATCOUNT;
            gfcd.gdi2.dwExpectedSize = sizeof(DD_GETFORMATCOUNTDATA);

            #if DBG
                // Ensure the driver actually sets the format count if it succeeds this call
                gfcd.dwFormatCount    = BOGUS_FIELD_VALUE;
            #endif // DBG

            memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
            GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
            GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
            GetDriverInfoData.lpvData        = &gfcd;
            GetDriverInfoData.dwExpectedSize = sizeof(DD_GETFORMATCOUNTDATA);
            GetDriverInfoData.dwContext      = pdrv->dwReserved3;

            if ((pdrv->pGetDriverInfo(&GetDriverInfoData) == DDHAL_DRIVER_HANDLED) && 
                (GetDriverInfoData.ddRVal == DD_OK ))
            {
                // Looks like we got a DD_GETFORMATCOUNTDATA back from the driver. Verify by means
                // of the dwActualSize field in GetDriverInfoData.
                if (sizeof(DD_GETFORMATCOUNTDATA) != GetDriverInfoData.dwActualSize)
                {
                    DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATCOUNTDATA))");
                    LEAVE_DDRAW();
                    return(FALSE);
                }

                #ifdef DBG
                    if (BOGUS_FIELD_VALUE == gfcd.dwFormatCount)
                    {
                        DPF_ERR( "Driver succeeded GETFORMATCOUNT request but didn't set dwFormatCount" );
                        LEAVE_DDRAW();
                        return(FALSE);
                    }
                #endif // DBG

                // All went well. Replace the number of supported texture formats the driver
                // reported to us with this new number. We don't use the legacy texture format
                // list if this new mechanism is supported
            
                *pcTextureFormats = gfcd.dwFormatCount;

                // Flag the fact that we got DX8 style formats from the driver.
                GotDX8Formats = TRUE;

                // Step2: Query for each of the surface formats in turn.
                // We only do this if the caller requested that we do by means of a non-NULL
                // texture format buffer
                if (NULL != pTextureFormats)
                {
                    DWORD          c;
                    DDSURFACEDESC* pOutFormat;

                    // For simplicities sake we ask for a single format at a time. Not exactly
                    // high-performance but this should not matter at this stage of the code.
                    pOutFormat = pTextureFormats;
                    for (c = 0; c < (*pcTextureFormats); ++c)
                    {
                        // We reinitialize the entire request each time. We could probably
                        // optimize this but it doesn't seem worth it.
                        memset(&gfd, 0, sizeof(DD_GETFORMATDATA));

                        gfd.gdi2.dwReserved     = sizeof(DD_GETFORMATDATA);
                        gfd.gdi2.dwMagic        = D3DGDI2_MAGIC;
                        gfd.gdi2.dwType         = D3DGDI2_TYPE_GETFORMAT;
                        gfd.gdi2.dwExpectedSize = sizeof(DD_GETFORMATDATA);
                        gfd.dwFormatIndex        = c;
                        #if DBG
                            // Ensure the driver actually sets the format count if it succeeds this call
                            gfd.format.dwSize    = BOGUS_FIELD_VALUE;
                        #endif // DBG
 
                        memset(&GetDriverInfoData, 0, sizeof(GetDriverInfoData));
                        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
                        GetDriverInfoData.guidInfo       = GUID_GetDriverInfo2;
                        GetDriverInfoData.lpvData        = &gfd;
                        GetDriverInfoData.dwExpectedSize = sizeof(DD_GETFORMATDATA);
                        GetDriverInfoData.dwContext      = pdrv->dwReserved3;

                        if ((pdrv->pGetDriverInfo(&GetDriverInfoData) == DDHAL_DRIVER_HANDLED) && 
                            (GetDriverInfoData.ddRVal == DD_OK ))
                        {
                            // Looks like we got a DD_GETFORMATDATA back from the driver. Verify by means
                            // of the dwActualSize field in GetDriverInfoData.
                            if (sizeof(DD_GETFORMATDATA) != GetDriverInfoData.dwActualSize)
                            {
                                DPF(0, "Driver returned an data structure of incorrect size (!= sizeof(DD_GETFORMATDATA))");
                                LEAVE_DDRAW();
                                return(FALSE);
                            }

                            DDASSERT(c == gfd.dwFormatIndex);

                            #ifdef DBG
                                if (BOGUS_FIELD_VALUE == gfd.format.dwSize)
                                {
                                    DPF_ERR( "Driver succeeded GETFORMAT request but didn't set format" );
                                    LEAVE_DDRAW();
                                    return(FALSE);
                                }
                            #endif // DBG

                            // Looks like all went well so initialize the surface description
                            // part of the output format and copy the pixel format we got from
                            // the driver across
                            memset(pOutFormat, 0, sizeof(DDSURFACEDESC));
                            pOutFormat->dwSize  = sizeof(DDSURFACEDESC);
                            pOutFormat->dwFlags = DDSD_PIXELFORMAT;
                            memcpy(&pOutFormat->ddpfPixelFormat, &(gfd.format), sizeof(DDPIXELFORMAT));

                            ++pOutFormat;
                        }
                    }
                }
            }
            else
            {
                DPF(0, "Driver claims DX8 but fails call to GETFORMATCOUNT"             );
                DPF(0, "DX7 texture format list will be used but this will change soon" );
                DPF(0, "Fix driver to support DX8 style surface format reporting now"   );
            }
        }

        // The driver does not support the DX8 DDI so simply use the existing DX7
        // style texture format list.
        if (pdrv->lpD3DGlobalDriverData != NULL)
        {
            // Wackiness to get around type checking
            *pGblDriverData   = *(D3D8_GLOBALDRIVERDATA*) pdrv_lcl->lpGbl->lpD3DGlobalDriverData;

            // If we alreay have DX8 style formats from the driver don't bother using the DX7
            // style texture format list
            if (!GotDX8Formats)
            {
                *pcTextureFormats = pdrv_lcl->lpGbl->lpD3DGlobalDriverData->dwNumTextureFormats;

                if (pTextureFormats != NULL)
                {
                    memcpy(
                        pTextureFormats,
                        pdrv_lcl->lpGbl->lpD3DGlobalDriverData->lpTextureFormats,
                        pdrv_lcl->lpGbl->lpD3DGlobalDriverData->dwNumTextureFormats*sizeof(*pTextureFormats));
                }
            }

            // Get the D3D extended caps

            if (pdrv->lpD3DExtendedCaps)
            {
                *pExtendedCaps = *(pdrv->lpD3DExtendedCaps);
            }
        }
        else
        {
            // If we alreay have DX8 style formats from the driver don't bother using the DX7
            // style texture format list
            if (!GotDX8Formats)
            {
                *pcTextureFormats = 0;
            }
        }


        // Get the supported Z formats.  We only do this if we are not using a
        // software driver

        *pcZStencilFormats = pdrv->dwNumZPixelFormats;
        if (pdrv->dwNumZPixelFormats > 0)
        {
            if (pZStencilFormats)
            {
                memcpy(pZStencilFormats,
                    pdrv->lpZPixelFormats,
                    pdrv->dwNumZPixelFormats * sizeof( *pZStencilFormats ));
            }
        }
        else
        {
            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_16)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats)
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 16;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffff;
                    pZStencilFormats->dwStencilBitMask = 0x0000;
                    pZStencilFormats++;
                }
            }
            if (pGblDriverData->hwCaps.dwDeviceZBufferBitDepth & DDBD_32)
            {
                (*pcZStencilFormats)++;
                if (pZStencilFormats)
                {
                    pZStencilFormats->dwSize = sizeof(DDPIXELFORMAT);
                    pZStencilFormats->dwFlags = DDPF_ZBUFFER;
                    pZStencilFormats->dwZBufferBitDepth = 32;
                    pZStencilFormats->dwStencilBitDepth = 0;
                    pZStencilFormats->dwZBitMask = 0xffffffff;
                    pZStencilFormats->dwStencilBitMask = 0x00000000;
                    pZStencilFormats++;
                }
            }
        }
    }
   
    // Get info about the current mode

    pDriverCaps->DisplayWidth     = pdrv->vmiData.dwDisplayWidth;
    pDriverCaps->DisplayHeight    = pdrv->vmiData.dwDisplayHeight;
    pDriverCaps->DisplayFrequency = pdrv->dwMonitorFrequency;
    switch (pdrv->vmiData.ddpfDisplay.dwRGBBitCount)
    {
    case 8:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_P8;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_P8;
        break;

    case 15:
    case 16:
        if (pdrv->vmiData.ddpfDisplay.dwGBitMask == 0x7e0)
        {
            pDriverCaps->DisplayFormatWithAlpha = D3DFMT_R5G6B5;
            pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_R5G6B5;
        }
        else
        {
            pDriverCaps->DisplayFormatWithAlpha = D3DFMT_X1R5G5B5;
            pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_X1R5G5B5;
            if (pdrv->vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
            {
                pDriverCaps->DisplayFormatWithAlpha  = D3DFMT_A1R5G5B5;
            }
            //pdrv->vmiData.ddpfDisplay.dwRGBAlphaBitMask = 0;
            //pdrv->vmiData.ddpfDisplay.dwFlags &= ~DDPF_ALPHAPIXELS;
        }
        break;

    case 24:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_R8G8B8;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_R8G8B8;
        break;

    case 32:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_X8R8G8B8;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_X8R8G8B8;
        if (pdrv->vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS)
        {
            pDriverCaps->DisplayFormatWithAlpha = D3DFMT_A8R8G8B8;
        }
        //pdrv->vmiData.ddpfDisplay.dwRGBAlphaBitMask = 0;
        //pdrv->vmiData.ddpfDisplay.dwFlags &= ~DDPF_ALPHAPIXELS;
        break;

    default:
        pDriverCaps->DisplayFormatWithAlpha = D3DFMT_UNKNOWN;
        pDriverCaps->DisplayFormatWithoutAlpha  = D3DFMT_UNKNOWN;
        break;
    }

    pDevice->DisplayFormatWithAlpha = pDriverCaps->DisplayFormatWithAlpha;
    pDevice->DisplayFormatWithoutAlpha = pDriverCaps->DisplayFormatWithoutAlpha;

    // Fill in the D3D8 Callback table
    RtlZeroMemory(pCallbacks, sizeof(*pCallbacks));
    pCallbacks->CreateSurface           = DdCreateSurface;
    pCallbacks->DestroySurface          = DdDestroySurface;
    pCallbacks->Lock                    = DdLock;
    pCallbacks->Unlock                  = DdUnlock;
    pCallbacks->Blt                     = DdBlt;
    pCallbacks->GetScanLine             = DdGetScanLine;
    pCallbacks->Flip                    = DdFlip;
    pCallbacks->WaitForVerticalBlank    = DdWaitForVerticalBlank;
    pCallbacks->GetBltStatus            = DdGetBltStatus;
    pCallbacks->GetFlipStatus           = DdGetFlipStatus;
    pCallbacks->SetMode                 = DdSetMode;
    pCallbacks->FlipToGDISurface        = DdFlipToGDISurface;
    pCallbacks->SetExclusiveMode        = DdSetExclusiveMode;
    pCallbacks->GetAvailDriverMemory    = DdGetAvailDriverMemory;
    pCallbacks->Clear2                  = D3dClear;
    pCallbacks->SetRenderTarget         = D3dSetRenderTarget;
    pCallbacks->SetColorkey             = DdSetColorkey;
    pCallbacks->SetPalette              = DdSetPalette;
    pCallbacks->UpdatePalette           = DdUpdatePalette;
    pCallbacks->SceneCapture            = D3dSceneCapture;

    if ((pdrv->lpD3DHALCallbacks != NULL) &&
        (pdrv->lpD3DHALCallbacks->ContextCreate != NULL))
    {
        pCallbacks->CreateContext   = D3dContextCreate;
    }
    if ((pdrv->lpD3DHALCallbacks != NULL) &&
        (pdrv->lpD3DHALCallbacks->ContextDestroy != NULL))
    {
        pCallbacks->ContextDestroy = D3dContextDestroy;
    }
    if ((pdrv->lpD3DHALCallbacks != NULL) &&
        (pdrv->lpD3DHALCallbacks->ContextDestroyAll != NULL))
    {
        pCallbacks->ContextDestroyAll = D3dContextDestroyAll;
    }
    if (pdrv->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState != NULL)
    {
        pCallbacks->GetDriverState = D3dGetDriverState;
    }
    if ((pdrv->lpD3DHALCallbacks3 != NULL) &&
        (pdrv->lpD3DHALCallbacks3->ValidateTextureStageState != NULL))
    {
        pCallbacks->ValidateTextureStageState = D3dValidateTextureStageState;
    }
    if ((pdrv->lpD3DHALCallbacks3 != NULL) &&
        (pdrv->lpD3DHALCallbacks3->DrawPrimitives2 != NULL))
    {
        pCallbacks->DrawPrimitives2 = D3dDrawPrimitives2;
    }

    // If Refrast or the HEL has a hook, call it to let it change whatever it wants

    if (IS_SOFTWARE_DRIVER(pDevice))
    {
        *pcZStencilFormats = 0;

        SwDDIMungeCaps (
            hLibrary,
            hDD,
            pDriverCaps,
            pCallbacks,
            pTextureFormats,
            pcTextureFormats,
            pDevice->pSwInitFunction
            );
    }

    // Now we need to determine what level of DX support the driver supports

    pDevice->DriverLevel = 0;
    if (pDriverCaps->D3DCaps.MaxStreams != 0)
    {
        pDevice->DriverLevel = 8;
    }
    else if (pCallbacks->GetDriverState != 0)
    {
        pDevice->DriverLevel = 7;
    }
    else if (pCallbacks->DrawPrimitives2 != 0)
    {
        pDevice->DriverLevel = 6;
        if (pDevice->pDefaultPalette == NULL)
        {
            PALETTEENTRY    ColorTable[256];
            int             i;

            for (i = 0; i < 256; i++)
            {
                ColorTable[i].peRed   = (UCHAR) i;
                ColorTable[i].peGreen = (UCHAR) i;
                ColorTable[i].peBlue  = (UCHAR) i;
            }
            DPF_MUTE();
            DD_CreatePalette ((LPDIRECTDRAW) pDevice->pDD,
                            DDPCAPS_8BIT,
                            ColorTable,
                            &pDevice->pDefaultPalette,
                            NULL);
            DPF_UNMUTE();
        }
    }

    if (pGblDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURESYSTEMMEMORY)
    {
        pDevice->bCanTextureSysmem = TRUE;
    }


    // Can this driver handle lightweight surfaces?

    pDriverCaps->KnownDriverFlags = 0;
    if (pDevice->DriverLevel < 7)
    {
        pDevice->bLightweight = FALSE;
    }
    else if (pDevice->DriverLevel == 7)
    {
        pDevice->bLightweight = CanKnownDriverDoThis(pDevice, KNOWN_LIGHTWEIGHT);
    }
    else
    {
        pDevice->bLightweight = TRUE;
    }
        
    // What about HW cursor support?
    // The check below needs to know the hardware driver level so it cannot use
    // pDevice->DriverLevel since it may be set due to ref. 

    if (SWCursorForced())
    {
        pDriverCaps->D3DCaps.CursorCaps = 0;
    }
    else if (((0 == pdrv->lpD3DExtendedCaps) || 
         (0 == pDriverCaps->D3DCaps.MaxStreams)) &&
        (NULL != pdrv->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState))
    {
        // The hardware driver is DX7
        if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSOR))
        {
            pDriverCaps->D3DCaps.CursorCaps = D3DCURSORCAPS_COLOR; 
            pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSOR;
            if (CanKnownDriverDoThis(pDevice, KNOWN_HWCURSORLOWRES))
            {
                pDriverCaps->D3DCaps.CursorCaps |= D3DCURSORCAPS_LOWRES; 
                pDriverCaps->KnownDriverFlags |= KNOWN_HWCURSORLOWRES;
            }
        }
    }

    // If it's a pre-dx8 driver and they support cubemaps, we need to
    // specify whether they support mipped cubemaps or not.

    if (pDevice->DriverLevel < 8)
    {
        if (CanKnownDriverDoThis(pDevice, KNOWN_MIPPEDCUBEMAPS))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_MIPPEDCUBEMAPS;
        }

        // Does this driver have a Z/Stencil depth restriction?
    
        if (CanKnownDriverDoThis(pDevice, KNOWN_ZSTENCILDEPTH))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_ZSTENCILDEPTH;
        }

        // Does device have no driver known to over-queue windowed presentation blts?
        if (CanKnownDriverDoThis(pDevice, KNOWN_NOTAWINDOWEDBLTQUEUER))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_NOTAWINDOWEDBLTQUEUER;
        }

        // Does device support D3DFMT_D16_LOCKABLE
        if (CanKnownDriverDoThis(pDevice, KNOWN_D16_LOCKABLE))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_D16_LOCKABLE;
        }

        // Figure out what RT/Texture formats it supports
        if (CanKnownDriverDoThis(pDevice, KNOWN_CANMISMATCHRT))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_CANMISMATCHRT;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_R5G6B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_R5G6B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_X8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_X8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A8R8G8B8))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A8R8G8B8;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A1R5G5B5))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A1R5G5B5;
        }
        if (CanKnownDriverDoThis(pDevice, KNOWN_RTTEXTURE_A4R4G4B4))
        {
            pDriverCaps->KnownDriverFlags |= KNOWN_RTTEXTURE_A4R4G4B4;
        }
    }

    // ATI drivers don't handle palettes correctly, so we will delete
    // all palettized textures from their list.

    if (pDevice->DriverLevel < 8)
    {
        if (((pDevice->PCIID >> 16) == 0x1002) &&
            (pTextureFormats != NULL))
        {
            i = 0;
            while (i < *pcTextureFormats)
            {
                if (pTextureFormats[i].ddpfPixelFormat.dwFlags & 
                    (DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8))
                {
                    UINT j;

                    (*pcTextureFormats)--;
                    for (j = i; j < *pcTextureFormats; j++)
                    {
                        pTextureFormats[j] = pTextureFormats[j+1];
                    }
                }
                else
                {
                    i++;
                }
            }
        }
    }

    // We assume that a software driver will always support at least DX7

    if ((pDevice->DriverLevel < 7) &&
        IS_SOFTWARE_DRIVER(pDevice))
    {
        LEAVE_DDRAW();
        DPF_ERR("A Software rasterizer must contain at least DX7 driver level support");
        return FALSE;
    }
    LEAVE_DDRAW();
    return TRUE;
}

VOID CleanupDevice (PDDDEVICEHANDLE pDevice)
{
    DWORD       i;
    DDSURFACE*  pSurf;
    DDSURFACE*  pSurfTemp;

    // Cleanup the palette allocations

    if (pDevice->pDefaultPalette != NULL)
    {
        InternalPaletteRelease((LPDDRAWI_DDRAWPALETTE_INT)
            pDevice->pDefaultPalette);
            pDevice->pDefaultPalette = NULL;
    }
    if (pDevice->NumPaletteHandleEntries > 0)
    {
        for (i = 0; i < pDevice->NumPaletteHandleEntries; i++)
        {
            if (pDevice->pPaletteHandleTable[i] != NULL)
            {
                InternalPaletteRelease((LPDDRAWI_DDRAWPALETTE_INT)
                    pDevice->pPaletteHandleTable[i]->pDDPalette);
                MemFree(pDevice->pPaletteHandleTable[i]);
                pDevice->pPaletteHandleTable[i] = NULL;
            }
        }
        MemFree(pDevice->pPaletteHandleTable);
        pDevice->pPaletteHandleTable = NULL;
        pDevice->NumPaletteHandleEntries = 0;
    }

    if (pDevice->pContext)
    {
        D3D8_CONTEXTDESTROYDATA data;

        data.dwhContext = (ULONG_PTR) pDevice->pContext;
        D3dContextDestroy(&data);
        pDevice->pContext = NULL;
    }

    pSurf = pDevice->pSurfList;
    while (pSurf != NULL)
    {
        if (!IS_SOFTWARE_DRIVER_SURFACE(pSurf))
        {
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {   
                LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

                pHeavy = MapLightweightSurface(pSurf);
                if (pHeavy != NULL)
                {
                    pHeavy->dwIntRefCnt = 1;
                    pHeavy->lpLcl->dwLocalRefCnt = 1;
                    pHeavy->lpLcl->lpGbl->dwRefCnt = 1;

                    if (pSurf->dwFlags & DDSURFACE_ROOT)
                    {
                        pHeavy->lpLcl->lpSurfMore->pAddrefedThisOwner = (IUnknown*) pSurf->pDevice->pDD;
                    }

                    InternalSurfaceRelease(pHeavy, TRUE, TRUE);

                    pHeavy->dwReserved1 = (ULONG_PTR) NULL;
                    pHeavy->dwReserved2 = 0;
                }
                MemFree (pSurf->Surface.pLight);
                pSurf->Surface.pLight = NULL;
            }
            else if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
            {
                if ((pSurf->dwFlags & DDSURFACE_ROOT) &&
                    (pSurf->Surface.pHeavy != NULL))
                {
                    InternalSurfaceRelease(pSurf->Surface.pHeavy, FALSE, TRUE);
                }
            }
        }
        else
        {
            MemFree(pSurf->Surface.pHeavy);
        }
        pSurfTemp = pSurf;
        pSurf = pSurf->pNext;
        MemFree(pSurfTemp);
    }

    if (pDevice->pSwDD)
    {
        if (pDevice->pSwDD->lpLcl->lpGbl->lpDDCBtmp)
        {
            MemFree(pDevice->pSwDD->lpLcl->lpGbl->lpDDCBtmp);
        }
        MemFree(pDevice->pSwDD);
    }

    if (pDevice->NumCachedSurfaces > 0)
    {
        for (i = 0; i < (DWORD) pDevice->NumCachedSurfaces; i++)
        {
            MemFree(pDevice->pCachedSurfaceTable[i].pSurface);
        }
        MemFree(pDevice->pCachedSurfaceTable);
        pDevice->pCachedSurfaceTable = NULL;
        pDevice->NumCachedSurfaces = 0;
    }

    if (pDevice->SurfaceHandleList.dwList != NULL)
    {
        MemFree(pDevice->SurfaceHandleList.dwList);
    }
}


VOID APIENTRY D3D8DeleteDirectDrawObject( HANDLE hDD )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;
    LPDIRECTDRAW    lpDD;

    // hDD can be NULL in some error paths
    
    if (pDevice == NULL)
        return;

    ENTER_DDRAW();
    CleanupDevice(pDevice);

    lpDD = (LPDIRECTDRAW) pDevice->pDD;
    if (lpDD != NULL)
    {
        lpDD->lpVtbl->Release(lpDD);
    }

    if (pDeviceList == pDevice)
    {
        // If we're first, then update global list
        // pointer
        pDeviceList = pDevice->pLink;
    }
    else
    {
        // Find ourselves in the list
        PDDDEVICEHANDLE pDevicePrev = pDeviceList;
        while (pDevicePrev->pLink != pDevice)
        {
            pDevicePrev = pDevicePrev->pLink;
        }

        // Skip past our current node
        pDevicePrev->pLink = pDevice->pLink;
    }
    MemFree(pDevice);

    LEAVE_DDRAW();
}

HDC APIENTRY D3D8GetDC( HANDLE hSurface, LPPALETTEENTRY pPalette )
{
    HDC                         hdc   = NULL;
    PDDSURFACE                  pSurf = (PDDSURFACE) hSurface;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        DDSURFACEDESC               ddsd;

        ddsd.dwSize = sizeof(ddsd);

        pHeavy = GetHeavyweightSurf(pSurf);
        if (pHeavy == NULL)
        {
            hdc = NULL;
            DPF_ERR("Out of memory error mapping lightweight surface");
        }
        else
        {
            FillDDSurfaceDesc(pHeavy->lpLcl, &ddsd);
            ddsd.lpSurface = (void*)pHeavy->lpLcl->lpGbl->fpVidMem;

            hdc = DD16_GetDC((HDC)(pSurf->pDevice->pDD->lpLcl->hDC),
                             &ddsd,
                             NULL);

            if (hdc == NULL)
            {
                DPF_ERR("Failure to GetDC for non-heavyweight surface?");
            }
            DONE_HEAVYWEIGHT_SURF (pSurf);
        }
    }
    else 
    {
        pHeavy = GetHeavyweightSurf(pSurf);
        if (pHeavy == NULL)
        {
            DPF_ERR("Unable to map lightweight surface - out of memory");
            hdc = NULL;
        }
        else
        {
            HRESULT hr = InternalGetDC(pHeavy, &hdc, FALSE);
            if (FAILED(hr))
            {
                DPF_ERR("Could not get DC for surface");
                hdc = NULL;
            }
        }
    }
    return hdc;
}

BOOL APIENTRY D3D8ReleaseDC(HANDLE hSurface, HDC hdc)
{
    PDDSURFACE pSurf = (PDDSURFACE) hSurface;
    DDASSERT(hdc != NULL);

    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        DD16_ReleaseDC(hdc);
    }

    else
    {   
        HRESULT                     hr;
        LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

        if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
        {
            pHeavy = GET_CACHED_LIGHTWEIGHT_INT(pSurf);
            DDASSERT(pHeavy != NULL);
        }
        else
        {
            pHeavy = pSurf->Surface.pHeavy;
        }

        hr = InternalReleaseDC(pHeavy->lpLcl, hdc, FALSE);
        if (FAILED(hr))
        {
            DPF_ERR("Could not release DC?");
        }
        DONE_HEAVYWEIGHT_SURF(pSurf);
    }
    return TRUE;
}

BOOL APIENTRY D3D8SetGammaRamp( HANDLE hDD, HDC hdc, LPVOID lpGammaRamp )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;
    HRESULT         hr = E_FAIL;

    ENTER_BOTH();
    if (CheckForDeviceLost(hDD))
    {
        LEAVE_BOTH();
        return TRUE;
    }

    if (pDevice->pDD->lpLcl->lpPrimary != NULL)
    {
        hr = DD_Gamma_SetGammaRamp((LPDIRECTDRAWGAMMACONTROL) pDevice->pDD->lpLcl->lpPrimary,
                                    0, lpGammaRamp);
    }
    LEAVE_BOTH();
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }
    return FALSE;
}

// D3D8BuildModeTable
//

VOID APIENTRY D3D8BuildModeTable( char*           pDeviceName,
                                  D3DDISPLAYMODE* pTable,
                                  DWORD*          pNumEntries,
                                  D3DFORMAT       Unknown16,
                                  HANDLE          hProfile,
                                  BOOL            b16bppSupported,
                                  BOOL            b32bppSupported                                 
                                  )
{
    PDDDEVICEHANDLE         pDeviceHandle = (PDDDEVICEHANDLE) hProfile;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    DWORD                   NumModes = 0;

    DWORD           i;
    DWORD           j;
    D3DFORMAT       format;

    if ((pDeviceHandle == NULL) ||
        (pDeviceHandle->pDD == NULL))
    {
        *pNumEntries = NumModes;
        return;
    }

    ENTER_DDRAW();
    pdrv = pDeviceHandle->pDD->lpLcl->lpGbl;

    NumModes = 0;
    for (i = 0; i < pdrv->dwNumModes; i++)
    {
        // Filter out all modes other than 15, 16 and 32bpp
        if ((pdrv->lpModeInfo[i].dwBPP != 15) &&
            (pdrv->lpModeInfo[i].dwBPP != 16) &&
            (pdrv->lpModeInfo[i].dwBPP != 32))
        {
            continue;
        }

        if (((pdrv->lpModeInfo[i].dwBPP == 15) ||
             (pdrv->lpModeInfo[i].dwBPP == 16)) &&
            !b16bppSupported)
        {
            continue;
        }
        else if ((pdrv->lpModeInfo[i].dwBPP == 32) &&
            !b32bppSupported)
        {
            continue;
        }

        // Can GDI and the monitor handle this mode/refresh rate?
        if(pdrv->dwFlags & DDRAWI_DISPLAYDRV)
        {
            DWORD   cds_flags;
            DEVMODE dm;
            int     cds_rc;
            BOOL    bUseRefresh;

            bUseRefresh = (pdrv->lpModeInfo[i].wRefreshRate > 0);
            makeDEVMODE( pdrv, &pdrv->lpModeInfo[i], FALSE, bUseRefresh, &cds_flags, &dm );

            cds_flags |= CDS_TEST;
            cds_rc = xxxChangeDisplaySettingsExA(pdrv->cDriverName, &dm, NULL, cds_flags, 0);
            if( cds_rc != 0 )
            {
                continue;
            }
            if (!MonitorCanHandleMode (pdrv, 
                                       pdrv->lpModeInfo[i].dwWidth, 
                                       pdrv->lpModeInfo[i].dwHeight, 
                                       pdrv->lpModeInfo[i].wRefreshRate))
            {
                continue;
            }
        }

        // Make sure that we understand the format.

        if ((pdrv->lpModeInfo[i].dwBPP == 16) ||
            (pdrv->lpModeInfo[i].dwBPP == 15))
        {
            format = Unknown16;
        }
        else
        {
            DDASSERT(pdrv->lpModeInfo[i].dwBPP == 32);
            format = D3DFMT_X8R8G8B8;
        }

        // Add the new mode.
        if (pTable != NULL)
        {
            ///The caller must pass us a number
            DDASSERT( (*pNumEntries) );
            if ( NumModes >= *pNumEntries )
            {
                //we exceeded the number of entries allocated for us.
                //tell the caller to re-query and try again.
                NumModes = 0;
                break;
            }

            pTable[NumModes].Width       = pdrv->lpModeInfo[i].dwWidth;
            pTable[NumModes].Height      = pdrv->lpModeInfo[i].dwHeight;
            pTable[NumModes].RefreshRate = pdrv->lpModeInfo[i].wRefreshRate;
            pTable[NumModes].Format      = format;
        }
        NumModes++;
    }
    LEAVE_DDRAW();

    *pNumEntries = NumModes;
}


BOOL APIENTRY D3D8IsDeviceLost( HANDLE hDD)
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;

    return pDevice->bDeviceLost;
}

BOOL APIENTRY D3D8CanRestoreNow( HANDLE hDD)
{
    PDDDEVICEHANDLE         pDevice = (PDDDEVICEHANDLE) hDD;
    LPDDRAWI_DIRECTDRAW_GBL pGbl;
    BOOL                    bSupported = FALSE;
    HRESULT hr;

    // If we aren't lost, then it's an easy call
    ENTER_DDRAW();

    if (!(pDevice->bDeviceLost))
    {
        LEAVE_DDRAW();
        return TRUE;
    }
    hr = DD_TestCooperativeLevel((LPDIRECTDRAW)pDevice->pDD);
    if ( DD_OK == hr || DDERR_WRONGMODE == hr)
    {
        // Are we in a mode in which D3D is supported?

        pGbl = pDevice->pDD->lpLcl->lpGbl;
        if (IS_SOFTWARE_DRIVER(hDD))
        {
            // Assume that any software driver can render in modes > 8bpp

            if (pGbl->vmiData.ddpfDisplay.dwRGBBitCount > 8)
            {
                bSupported = TRUE;
            }
        }


        if (pGbl->lpD3DGlobalDriverData != NULL)
        {
            switch (pGbl->vmiData.ddpfDisplay.dwRGBBitCount)
            {
            case 15:
            case 16:
                if (pGbl->lpD3DGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & DDBD_16)
                {
                    bSupported = TRUE;
                }
                break;

            case 24:
                if (pGbl->lpD3DGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & DDBD_24)
                {
                    bSupported = TRUE;
                }
                break;

            case 32:
                if (pGbl->lpD3DGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & DDBD_32)
                {
                    bSupported = TRUE;
                }
                break;
            }
        }
    }
    LEAVE_DDRAW();

    return bSupported;
}

VOID APIENTRY D3D8RestoreDevice( HANDLE hDD)
{
    HRESULT hr;
    DWORD i, j, k;
    DWORD Width, Height, Depth;
    BYTE *SliceSrc, *SliceDst, *RowSrc, *RowDst;
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) hDD;
    PDDSURFACE      pSurf;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavy;
    PDEFERREDCREATE pDefCreate = pDevice->pDeferList;
    PDEFERREDCREATE *ppNext = &pDevice->pDeferList;
    PDEFERREDCREATE pTemp;
    D3D8_LOCKDATA LockData;
    D3D8_UNLOCKDATA UnlockData;

    ENTER_BOTH();
    if (!D3D8CanRestoreNow(hDD))
    {
        LEAVE_BOTH();
        return;
    }

    pDevice->bDeviceLost = FALSE;
    pDevice->bDP2Error = FALSE;

    // If a context was created while lost, we will not re-create it now since
    // we don't have a render target or Z Buffer (the vidmem surfaces would have
    // already been destroyed.  Therefore, we won't attempt to create the context
    // until they create the new surfaces and call SetRenderTarget.  We also
    // won't try to create any defered texture handles at this time since we may
    // not have a valid context.  We will also do that in the SetRenderTarget call.

    // Walk the list of surfaces and create any SurfaceEx surfaces that we may
    // have pending.

    pSurf = pDevice->pSurfList;
    while (pSurf != NULL)
    {
        if ((pSurf->dwFlags & DDSURFACE_DEFERCREATEEX) && 
            !(pSurf->dwFlags & DDSURFACE_DUMMY))
        {
            pHeavy = GetHeavyweightSurf(pSurf);
            if (pHeavy != NULL)
            {
                createsurfaceEx(pHeavy->lpLcl);
                DONE_HEAVYWEIGHT_SURF(pSurf);
            }

            pSurf->dwFlags &= ~DDSURFACE_DEFERCREATEEX;
        }
        pSurf = pSurf->pNext;
    }

    // Finally resurrect our deferred driver managed surfaces (Gulp!)

    while (pDefCreate != NULL)
    {
        // First check if the deferred surface exists at all. The problem
        // is that DdDestroySurface could have been called. We could have
        // removed the surface from the deferred list in DdDestroySurface
        // but since DdDestroySurface is called piecemeal, it gets
        // very annoying. The removal is best done here.
        // ASSUMPTION: if pSList[0].hKernelHandle is NULL then
        // pSList[1,2,etc].hKernelHandle are also NULL. There is no
        // reason for this to be not the case as of 3/2001.

        if (pDefCreate->CreateData.pSList[0].hKernelHandle == NULL)
        {
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
            continue;
        }

        // Attempt to resurrect

        pDefCreate->CreateData.bReUse = TRUE;
        hr = DdCreateSurface(&pDefCreate->CreateData);
        if (SUCCEEDED(hr))
        {
            for (i = 0; i < pDefCreate->CreateData.dwSCnt; i++)
            {
                pSurf = (PDDSURFACE) pDefCreate->CreateData.pSList[i].hKernelHandle;

                // Reset DDSURF_SYSMEMALLOCATED to keep DdLock below happy

                pSurf->dwFlags &= ~DDSURFACE_SYSMEMALLOCATED;

                // Lock and copy

                ZeroMemory(&LockData, sizeof(LockData));
                LockData.hDD = hDD;
                LockData.hSurface = pSurf;
                hr = DdLock(&LockData);
                if (SUCCEEDED(hr))
                {
                    SliceSrc = (BYTE*)pSurf->fpVidMem;
                    SliceDst = (BYTE*)LockData.lpSurfData;
                    Width = pDefCreate->CreateData.pSList[i].cpWidth;
                    Height = pDefCreate->CreateData.pSList[i].cpHeight;
                    Depth = pDefCreate->CreateData.pSList[i].cpDepth;
                    if (!(pDefCreate->CreateData.Type == D3DRTYPE_VOLUME ||
                        pDefCreate->CreateData.Type == D3DRTYPE_VOLUMETEXTURE))
                    {
                        Depth = 1;
                    }
                    for (j = 0; j < Depth; ++j)
                    {
                        RowSrc = SliceSrc;
                        RowDst = SliceDst;
                        for (k = 0; k < Height; ++k)
                        {
                            CopyMemory(RowDst, RowSrc, min(LockData.lPitch, (LONG)Width * 8));
                            RowSrc += Width * 8;
                            RowDst += LockData.lPitch;
                        }
                        SliceSrc += Width * Height * 8;
                        SliceDst += LockData.lSlicePitch;
                    }

                    ZeroMemory(&UnlockData, sizeof(UnlockData));
                    UnlockData.hDD = hDD;
                    UnlockData.hSurface = pSurf;
                    hr = DdUnlock(&UnlockData);
                    if (FAILED(hr))
                    {
                        // TODO: Handle/(ignore?) failure 
                        DPF(0,"Unlock failed when resurrecting driver managed surface.");
                    }
                }
                else
                {
                    // TODO: Handle/(ignore?) failure 
                    DPF(0,"Lock failed when resurrecting driver managed surface. Texture may go missing.");
                }

                // Free the temporary fpVidmem that we allocated in CreateVidmemSurface
            
                MemFree(pSurf->fpVidMem);
                pSurf->fpVidMem = 0;
            }

            // Remove from list and freeup all memory
     
            pTemp = pDefCreate->pNext;
            *ppNext = pTemp;
            MemFree(pDefCreate->CreateData.pSList);
            MemFree(pDefCreate);
            pDefCreate = pTemp;
        }
        else
        {
            // We set ReUse to FALSE to indicate that we were not able to resurrect
            pDefCreate->CreateData.bReUse = FALSE;

            ppNext = &(pDefCreate->pNext);
            pDefCreate = pDefCreate->pNext;
        }
    }

    if (pDevice->pDeferList != NULL)
    {
        // TODO:
        // Ummm, we were not able to resurrect. This may be due to out of memory
        // which probably needs to be reported to the app.
        DPF(0,"Unable to resurrect all driver managed surfaces.");
    }

    LEAVE_BOTH();
}


BOOL APIENTRY D3D8DoVidmemSurfacesExist( HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFACE pSurf;

    // Walk the list and return TRUE is we find any surfaces that are either
    // local or nonlocal vidmem.

    ENTER_DDRAW();
    pSurf = pDeviceHandle->pSurfList;
    while (pSurf != NULL)
    {
        if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
            (pSurf->dwFlags & DDSURFACE_TREATASVIDMEM))
        {
#if DBG
            DPF(0,"The following D3DPOOL_DEFAULT surfaces/buffers/textures still exist");
            pSurf = pDeviceHandle->pSurfList;
            while (pSurf != NULL)
            {
                if ((pSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
                    (pSurf->Pool == D3DPOOL_NONLOCALVIDMEM) ||
                    (pSurf->dwFlags & DDSURFACE_TREATASVIDMEM))
                {
                    switch (pSurf->Type)
                    {
                    case D3DRTYPE_SURFACE:
                        DPF(0,"  D3DRTYPE_SURFACE");
                        break;
                    case D3DRTYPE_VOLUME:
                        DPF(0,"  D3DRTYPE_VOLUME");
                        break;
                    case D3DRTYPE_TEXTURE:
                        DPF(0,"  D3DRTYPE_TEXTURE");
                        break;
                    case D3DRTYPE_VOLUMETEXTURE:
                        DPF(0,"  D3DRTYPE_VOLUMETEXTURE");
                        break;
                    case D3DRTYPE_CUBETEXTURE:
                        DPF(0,"  D3DRTYPE_CUBETEXTURE");
                        break;
                    case D3DRTYPE_VERTEXBUFFER:
                        DPF(0,"  D3DRTYPE_VERTEXBUFFER");
                        break;
                    case D3DRTYPE_INDEXBUFFER:
                        DPF(0,"  D3DRTYPE_INDEXBUFFER");
                        break;
                    case D3DRTYPE_COMMANDBUFFER:
                        DPF(0,"  D3DRTYPE_COMMANDBUFFER");
                        break;
                    default:
                        DPF(0,"  UNKNOWN SURFACE TYPE");
                        break;
                    }
                }
                pSurf = pSurf->pNext;
            }
#endif
            LEAVE_DDRAW();

            return TRUE;
        }
        pSurf = pSurf->pNext;
    }
    LEAVE_DDRAW();

    return FALSE;
}

DWORD APIENTRY D3D8GetMode( HANDLE          Handle,
                            char*           pDeviceName,
                            D3DDISPLAYMODE* pMode,
                            D3DFORMAT       Unknown16)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) Handle;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;

    ENTER_DDRAW();
    memset(pMode, 0, sizeof(D3DDISPLAYMODE));

    if (pDeviceHandle != NULL)
    {
        pdrv = pDeviceHandle->pDD->lpLcl->lpGbl;

        pMode->Width        = pdrv->vmiData.dwDisplayWidth;
        pMode->Height       = pdrv->vmiData.dwDisplayHeight;
        pMode->RefreshRate  = pdrv->dwMonitorFrequency;
        switch (pdrv->vmiData.ddpfDisplay.dwRGBBitCount)
        {
        case 8:
            pMode->Format = D3DFMT_P8;
            break;

        case 15:
        case 16:
            if (pdrv->vmiData.ddpfDisplay.dwGBitMask == 0x7e0)
            {
                pMode->Format = D3DFMT_R5G6B5;
            }
            else
            {
                pMode->Format = D3DFMT_X1R5G5B5;
            }
            break;

        case 24:
            pMode->Format = D3DFMT_R8G8B8;
            break;

        case 32:
            pMode->Format = D3DFMT_X8R8G8B8;
            break;

        default:
            pMode->Format = D3DFMT_UNKNOWN;
            break;
        }
        LEAVE_DDRAW();
        return DD_OK;
    }
    else
    {
        DEVMODE dm;
        HDC     hdc;

        memset (&dm, 0, sizeof(dm));
        dm.dmSize = sizeof(dm);

        // For pre-Win98 systems, we use GetDeviceCaps
        // because ENUM_CURRENT_SETTINGS is not
        // supported on these legacy systems.
        if (!IsWindows98())
        {
            DWORD bpp;

            hdc = GetDC(NULL);

            pMode->Width        = GetDeviceCaps(hdc, HORZRES);
            pMode->Height       = GetDeviceCaps(hdc, VERTRES);
            pMode->RefreshRate  = 0;

            bpp = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
            ReleaseDC(NULL, hdc);

            switch (bpp)
            {
            case 8:
                pMode->Format = D3DFMT_P8;
                break;

            case 24:
                pMode->Format = D3DFMT_R8G8B8;
                break;

            case 32:
                pMode->Format = D3DFMT_X8R8G8B8;
                break;

            case 15:
            case 16:
                pMode->Format = Unknown16;
                break;

            default:
                DPF(0, "Unknown desktop format");
                pMode->Format = D3DFMT_UNKNOWN;
                break;
            }
        }
        else if (EnumDisplaySettings(pDeviceName, ENUM_CURRENT_SETTINGS, &dm))
        {
            pMode->Width        = dm.dmPelsWidth;
            pMode->Height       = dm.dmPelsHeight;
            pMode->RefreshRate  = dm.dmDisplayFrequency;

            switch (dm.dmBitsPerPel)
            {
            case 8:
                pMode->Format = D3DFMT_P8;
                break;

            case 24:
                pMode->Format = D3DFMT_R8G8B8;
                break;

            case 32:
                pMode->Format = D3DFMT_X8R8G8B8;
                break;

            case 15:
            case 16:
                pMode->Format = Unknown16;
                break;

            default:
                pMode->Format = D3DFMT_UNKNOWN;
                break;
            }
        }
        else
        {
            LEAVE_DDRAW();
            DPF_ERR("EnumDisplaySettings failed?");
            DPF(0, "display is %s", pDeviceName);
            return D3DERR_DRIVERINTERNALERROR;
        }
        LEAVE_DDRAW();
        return DD_OK;
    }

    LEAVE_DDRAW();
    return D3DERR_DRIVERINTERNALERROR;
}


DWORD APIENTRY D3D8SetMode( HANDLE  Handle,
                            char*   pDeviceName,
                            UINT    Width,
                            UINT    Height,
                            UINT    BPP,
                            UINT    RefreshRate,
                            BOOL    bRestore)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) Handle;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    HRESULT                 hr = DDERR_GENERIC;
    DWORD                   i;

    ENTER_DDRAW();
    if ((pDeviceHandle != NULL) &&
        (pDeviceHandle->pDD != NULL))
    {
        // We will call DDraw to do the mode change because it is able to
        // cleanup the mode change when the app exits and because we don't
        // want to treat external mode changes and DDraw mode changes the
        // same way.

        pdrv = pDeviceHandle->pDD->lpLcl->lpGbl;
        for (i = 0; i < pdrv->dwNumModes; i++)
        {
            if ((pdrv->lpModeInfo[i].dwWidth == Width) &&
                (pdrv->lpModeInfo[i].dwHeight == Height) &&
                (pdrv->lpModeInfo[i].dwBPP == BPP))
            {
                if ((RefreshRate == 0) ||
                    (RefreshRate == pdrv->lpModeInfo[i].wRefreshRate))
                {
                    break;
                }
            }
        }
        if (i < pdrv->dwNumModes)
        {
            BOOL                    bExists;
            BOOL                    bOwn;
            LPDDRAWI_DIRECTDRAW_LCL lcl = pDeviceHandle->pDD->lpLcl;

            // When profiling, we will be doing mode changes w/o holding 
            // exlusive mode, but we need ddraw to think that we have it in
            // order to change bit depth.

            CheckExclusiveMode(lcl, &bExists, &bOwn, FALSE, NULL, FALSE);
            if (!bOwn)
            {
                if (bExists)
                {
                    LEAVE_DDRAW();
                    return D3DERR_DRIVERINTERNALERROR;
                }
                lcl->lpGbl->lpExclusiveOwner = lcl;
            }

            if (bRestore)
            {
                hr = MapLegacyResult(RestoreDisplayMode (lcl, TRUE));
            }
            else
            {
                hr = MapLegacyResult(SetDisplayMode (lcl,
                                     i,
                                     TRUE,
                                     RefreshRate != 0));
            }
            if (!bOwn)
            {
                // This check shouldn't be needed, but it's safe since just
                // about anything can happen during a mode change.

                if (lcl->lpGbl->lpExclusiveOwner == lcl)
                {
                    lcl->lpGbl->lpExclusiveOwner = NULL;
                }
            }
        }
    }
    LEAVE_DDRAW();

    return hr;
}


DWORD APIENTRY D3D8SetCooperativeLevel(
    HANDLE hDD,
    HWND hWnd,
    DWORD dwFlags )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) hDD;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = pDevice->pDD;
    return MapLegacyResult(DD_SetCooperativeLevel((LPDIRECTDRAW)pdrv_int, hWnd, dwFlags|DDSCL_DX8APP));
}

BOOL APIENTRY D3D8IsDummySurface(
    HANDLE hSurface )
{
    PDDSURFACE  pSurf = (PDDSURFACE) hSurface;

    return ((pSurf->dwFlags & DDSURFACE_DUMMY) != 0);
}

void CleanupD3D8( LPDDRAWI_DIRECTDRAW_GBL pdrv,
                  BOOL bDestroyAll,
                  DWORD PID)
{
    DDDEVICEHANDLE* pDevice;
    DDDEVICEHANDLE* pTemp;

    ENTER_DDRAW();
    pDevice = pDeviceList;

    if (bDestroyAll)
    {
        // The process has died, so clean everything up.  We don't need to call
        // the software driver for anything since it's already unloaded.

        while (pDevice != NULL)
        {
            if (pDevice->PID == PID)
            {
                CleanupDevice(pDevice);

                // Remove this device from the list

                if (pDeviceList == pDevice)
                {
                    pDeviceList = pDevice->pLink;
                }
                else
                {
                    pTemp = pDeviceList;
                    while (pTemp->pLink != pDevice)
                    {
                        pTemp = pTemp->pLink;
                    }
                    pTemp->pLink = pDevice->pLink;
                }

                // Now free the device

                pTemp = pDevice;
                pDevice = pDevice->pLink;
                MemFree(pTemp);
            }
            else
            {
                pDevice = pDevice->pLink;
            }
        }
    }
    else
    {
        // The device is getting lost, so we will mark it as lost and free up
        // any resources that will get lost.

        while (pDevice != NULL)
        {
            if (pDevice->pDD->lpLcl->lpGbl == pdrv)
            {
                LoseDevice (pDevice);
            }
            pDevice = pDevice->pLink;
        }
    }
    LEAVE_DDRAW();
}


VOID APIENTRY D3D8LoseDevice(
    HANDLE hDD )
{
    ENTER_DDRAW();
    LoseDevice (hDD);
    LEAVE_DDRAW();
}



VOID APIENTRY D3D8GetHALName(
    char*   pDisplayName,
    char*   pHALName)
{
    LPDDRAWI_DIRECTDRAW_INT lpDD_int = NULL;
       
    ENTER_DDRAW();
    InternalDirectDrawCreate( NULL,
                              (LPDIRECTDRAW*) &lpDD_int,
                              NULL,
                              DDRAWILCL_DIRECTDRAW7 | DDRAWILCL_DIRECTDRAW8,
                              pDisplayName);
    if (lpDD_int != NULL)
    {
        lstrcpy(pHALName, lpDD_int->lpLcl->lpGbl->dd32BitDriverData.szName);
        DD_Release((LPDIRECTDRAW)lpDD_int);
    }
    LEAVE_DDRAW();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddheapr.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddheapr.c
 *  Content:	Rectangular heap manager
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   30-mar-95	kylej	initial implementation
 *   07-apr-95	kylej	Added rectVidMemAmountFree
 *   15-may-95	craige	made separate VMEM struct for rect & linear
 *   18-jun-95	craige	specific pitch
 *   02-jul-95	craige	have rectVidMemInit return a BOOL
 *   28-nov-95  colinmc new function to return amount of allocated memory
 *                      in a heap
 *   05-jul-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   18-jan-97  colinmc Work Item: AGP support
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   03-Feb-98  DrewB   Made portable between user and kernel.
 *
 ***************************************************************************/

#include "ddrawpr.h"

/****************************************************************************

 This memory manager manages allocation of rectangular blocks of 
 video memory.	It has essentially the same interface as the linear
 video memory manager implemented in vmemmgr.c.	 Memory allocations
 are tracked by nodes on two circular, doubly-linked lists; the free
 list and the alloc list.  Each list has a special node called the 
 sentinel which contains a special memory size.	 The head of each
 list always points to the sentinel node and the first member of the
 list (if there is one) is pointed to by the sentinel node.  Block
 adjacency information is kept in each node so that several free nodes 
 can be coalesced into larger free nodes.  This takes place every 
 time a block of memory is freed.
 
 This memory manager is designed to have no impact on video memory usage.
 Global memory is used to maintain the allocation and free lists.  Because
 of this choice, merging of free blocks is a more expensive operation.
 The assumption is that in general, the speed of creating/destroying these
 memory blocks is not a high usage item and so it is OK to be slower.

 ****************************************************************************/

/*
 * IS_FREE and NOT_FREE are used to set the free flag in the flags
 * field of each VMEM node.  The free flag is the lsb of this field.
 */
  
#define IS_FREE  0x00000001
#define NOT_FREE 0xfffffffe
 
/*
 * SENTINEL is the value stuffed into the size field of a VMEM
 * node to identify it as the sentinel node.  This value makes
 * the assumption that no rectangle sized 0x7fff by 0xffff will
 * ever be requested.
 */
  
#define SENTINEL 0x7fffffff

/*
 * MIN_DIMENSION_SIZE determines the smallest valid dimension for a 
 * free memory block.  If dividing a rectangle will result in a 
 * rectangle with a dimension less then MIN_DIMENSION_SIZE, the 
 * rectangle is not divided.
 */

#define MIN_DIMENSION_SIZE 4

/*
 * BLOCK_BOUNDARY must be a power of 2, and at least 4.	 This gives
 * us the alignment of memory blocks.	
 */
#define BLOCK_BOUNDARY	4

// This macro results in the free list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

/*
 * Debugging helpers
 */
#define DPFVMEMR(str,p) VDPF((0,V,"%s: %d,%d (%dx%d) ptr:%08x, block:%08x",str,p->x,p->y,p->cx,p->cy,p->ptr,p))
#define CHECK_HEAP(a,b) ;

/*
 * insertIntoDoubleList - add an item to the a list. The list is
 *	    kept in order of increasing size and is doubly linked.  The
 *	    list is circular with a sentinel node indicating the end
 *	    of the list.  The sentinel node has its size field set 
 *	    to SENTINEL.
 */
void insertIntoDoubleList( LPVMEMR pnew, LPVMEMR listhead )
{
    LPVMEMR	pvmem = listhead;

    #ifdef DEBUG
	if( pnew->size == 0 )
	{
	    VDPF(( 0, V, "block size = 0!!!\n" ));
	}
    #endif

    /*
     * run through the list (sorted from smallest to largest) looking
     * for the first item bigger than the new item.  If the sentinel
     * is encountered, insert the new item just before the sentinel.
     */

    while( pvmem->size != SENTINEL ) 
    {
	if( pnew->size < pvmem->size )
	{
	    break;
	}
	pvmem = pvmem->next;
    }

    // insert the new item before the found one.
    pnew->prev = pvmem->prev;
    pnew->next = pvmem;
    pvmem->prev->next = pnew;
    pvmem->prev = pnew;

} /* insertIntoDoubleList */

/*
 * rectVidMemInit - initialize rectangular video memory manager
 */
BOOL rectVidMemInit(
		LPVMEMHEAP pvmh,
		FLATPTR start,
		DWORD width,
		DWORD height,
		DWORD pitch )
{
    LPVMEMR newNode;

    VDPF(( 4, V, "rectVidMemInit(start=%08lx,width=%ld,height=%ld,pitch=%ld)", start, width, height, pitch));

    pvmh->dwTotalSize = pitch * height;

    // Store the pitch for future address calculations.
    pvmh->stride = pitch;

    // Set up the Free list and the Alloc list by inserting the sentinel.
    pvmh->freeList = MemAlloc( sizeof(VMEMR) );
    if( pvmh->freeList == NULL )
    {
	return FALSE;
    }
    ((LPVMEMR)pvmh->freeList)->size = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->cx = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->cy = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->next = (LPVMEMR)pvmh->freeList;
    ((LPVMEMR)pvmh->freeList)->prev = (LPVMEMR)pvmh->freeList;
    ((LPVMEMR)pvmh->freeList)->pLeft = NULL;
    ((LPVMEMR)pvmh->freeList)->pUp = NULL;
    ((LPVMEMR)pvmh->freeList)->pRight = NULL;
    ((LPVMEMR)pvmh->freeList)->pDown = NULL;

    pvmh->allocList = MemAlloc( sizeof(VMEMR) );
    if( pvmh->allocList == NULL )
    {
	MemFree(pvmh->freeList);
	return FALSE;
    }
    ((LPVMEMR)pvmh->allocList)->size = SENTINEL;
    ((LPVMEMR)pvmh->allocList)->next = (LPVMEMR)pvmh->allocList;
    ((LPVMEMR)pvmh->allocList)->prev = (LPVMEMR)pvmh->allocList;

    // Initialize the free list with the whole chunk of memory
    newNode = (LPVMEMR)MemAlloc( sizeof( VMEMR ) );
    if( newNode == NULL )
    {
	MemFree(pvmh->freeList);
       	MemFree(pvmh->allocList);
	return FALSE;
    }
    newNode->ptr = start;
    newNode->size = CXCY(width, height);
    newNode->x = 0;
    newNode->y = 0;
    newNode->cx = width;
    newNode->cy = height;
    newNode->flags |= IS_FREE;
    newNode->pLeft = (LPVMEMR)pvmh->freeList;
    newNode->pUp = (LPVMEMR)pvmh->freeList;
    newNode->pRight = (LPVMEMR)pvmh->freeList;
    newNode->pDown = (LPVMEMR)pvmh->freeList;
    insertIntoDoubleList( newNode, ((LPVMEMR) pvmh->freeList)->next );

    return TRUE;

} /* rectVidMemInit */

/*
 * rectVidMemFini - done with rectangular video memory manager
 */
void rectVidMemFini( LPVMEMHEAP pvmh )
{
    LPVMEMR	curr;
    LPVMEMR	next;

    if( pvmh != NULL )
    {
	// free all memory allocated for the free list
	curr = ((LPVMEMR)pvmh->freeList)->next;
	while( curr->size != SENTINEL )
	{
	    next = curr->next;
	    MemFree( curr );
	    curr = next;
	}
	MemFree( curr );
	pvmh->freeList = NULL;

	// free all memory allocated for the allocation list
	curr = ((LPVMEMR)pvmh->allocList)->next;
	while( curr->size != SENTINEL )
	{
	    next = curr->next;
	    MemFree( curr );
	    curr = next;
	}
	MemFree( curr );
	pvmh->allocList = NULL;

	// free the heap data
	MemFree( pvmh );
    }
}   /* rectVidMemFini */

/*
 * GetBeforeWastage.
 * Align the surface in the given block. Return the size of the holes
 * on the left side of the surface.
 * Fail if alignment would cause surface to spill out of block.
 * Works for horizontal and vertical alignment.
 * IN:  dwBlockSize , dwBlockStart: Parameters of the block in which
 *                                  the surface hopes to fit
 *      dwSurfaceSize               Width or height of the surface
 *      dwAlignment                 Expected alignment. 0 means don't care
 * OUT: pdwBeforeWastage
 */
BOOL GetBeforeWastage(
    DWORD dwBlockSize,
    DWORD dwBlockStart,
    DWORD dwSurfaceSize, 
    LPDWORD pdwBeforeWastage, 
    DWORD dwAlignment )
{

    if (!dwAlignment)
    {
        *pdwBeforeWastage=0;
        /*
         * If no alignment requirement, then check if the surface fits
         */
        if (dwBlockSize >= dwSurfaceSize)
        {
            return TRUE;
        }
        return FALSE;
    }
    /*
     * There's an alignment.
     */
    *pdwBeforeWastage = (dwAlignment - (dwBlockStart % dwAlignment)) % dwAlignment;

    if ( *pdwBeforeWastage + dwSurfaceSize > dwBlockSize )
    {
            return FALSE;
    }

    DDASSERT( (dwBlockStart + *pdwBeforeWastage) % dwAlignment == 0 );
    return TRUE;
}

/*
 * rectVidMemAlloc - alloc some rectangular flat video memory
 */
FLATPTR rectVidMemAlloc( LPVMEMHEAP pvmh, DWORD cxThis, DWORD cyThis,
                         LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment )
{
    LPVMEMR	pvmem;
    DWORD	cyRem;
    DWORD	cxRem;
    DWORD	cxBelow;
    DWORD	cyBelow;
    DWORD	cxBeside;
    DWORD	cyBeside;
    LPVMEMR	pnewBeside;
    LPVMEMR	pnewBelow;
    DWORD       dwXAlignment=0;
    DWORD       dwYAlignment=0;
    DWORD       dwLeftWastage=0;
    DWORD       dwTopWastage=0;


    if((cxThis == 0) || (cyThis == 0) || (pvmh == NULL))
	return (FLATPTR) NULL;

    // Make sure the size of the block is a multiple of BLOCK_BOUNDARY
    // If every block allocated has a width which is a multiple of
    // BLOCK_BOUNDARY, it guarantees that all blocks will be allocated
    // on block boundaries.

    /*
     * Bump to new alignment
     */
    if( (cxThis >= (SENTINEL>>16) ) || (cyThis >= (SENTINEL&0xffff) ) )
	return (FLATPTR) NULL;


    if (lpAlignment)
    {
        dwXAlignment = lpAlignment->Rectangular.dwXAlignment;
        dwYAlignment = lpAlignment->Rectangular.dwYAlignment;
    }
    if (dwXAlignment < 4)
    {
        dwXAlignment = 4;
    }


    
    cxThis = (cxThis+(BLOCK_BOUNDARY-1)) & ~(BLOCK_BOUNDARY-1);

    /*
     * run through free list, looking for the closest matching block
     */

    pvmem = ((LPVMEMR)pvmh->freeList)->next;
    while (pvmem->size != SENTINEL)
    {
        if (!GetBeforeWastage( pvmem->cx, pvmem->x, cxThis, &dwLeftWastage, dwXAlignment ))
        {
	    pvmem = pvmem->next;
            continue; //X size or alignment makes surface spill out of block
        }
        // Now see if size/alignment works for Y
        if (!GetBeforeWastage( pvmem->cy, pvmem->y, cyThis, &dwTopWastage, dwYAlignment ))
        {
	    pvmem = pvmem->next;
            continue; //Y size alignment makes surface spill out of block
        }
        //success:
        break;
    }

    if(pvmem->size == SENTINEL)
    {
	// There was no rectangle large enough
	return (FLATPTR) NULL;
    }

    // pvmem now points to a rectangle that is the same size or larger
    // than the requested rectangle.  We're going to use the upper-left
    // corner of the found rectangle and divide the unused remainder into
    // two rectangles which will go on the available list.

    // grow allocation by the wastage which makes the top-left aligned
    cxThis += dwLeftWastage;
    cyThis += dwTopWastage;

    // Compute the width of the unused rectangle to the right and the 
    // height of the unused rectangle below:

    cyRem = pvmem->cy - cyThis;
    cxRem = pvmem->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are 
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow = cyRem;
    cxBeside = cxRem;

    if (cxRem <= cyRem)
    {
	cxBelow = cxThis + cxRem;
	cyBeside = cyThis;
    }
    else
    {
	cxBelow = cxThis;
	cyBeside = cyThis + cyRem;
    }

    // We only make new available rectangles of the unused right and 
    // bottom portions if they're greater in dimension than MIN_DIMENSION_SIZE.
    // It hardly makes sense to do the book-work to keep around a 
    // two pixel wide available space, for example.

    pnewBeside = NULL;
    if (cxBeside >= MIN_DIMENSION_SIZE)
    {
	pnewBeside = (LPVMEMR)MemAlloc( sizeof(VMEMR) );
	if( pnewBeside == NULL)
	    return (FLATPTR) NULL;

	// Update the adjacency information along with the other required
	// information in this new node and then insert it into the free
	// list which is sorted in ascending cxcy.

	// size information
	pnewBeside->size = CXCY(cxBeside, cyBeside);
	pnewBeside->x = pvmem->x + cxThis;
	pnewBeside->y = pvmem->y;
	pnewBeside->ptr = pvmem->ptr + cxThis;
	pnewBeside->cx = cxBeside;
	pnewBeside->cy = cyBeside;
	pnewBeside->flags |= IS_FREE;

	// adjacency information
	pnewBeside->pLeft = pvmem;
	pnewBeside->pUp = pvmem->pUp;
	pnewBeside->pRight = pvmem->pRight;
	pnewBeside->pDown = pvmem->pDown;
	insertIntoDoubleList( pnewBeside, ((LPVMEMR) pvmh->freeList)->next);

	// Modify the current node to reflect the changes we've made:

	pvmem->cx = cxThis;
    }

    pnewBelow = NULL;
    if (cyBelow >= MIN_DIMENSION_SIZE)
    {
	pnewBelow = (LPVMEMR) MemAlloc( sizeof(VMEMR) );
	if (pnewBelow == NULL)
	    return (FLATPTR) NULL;

	// Update the adjacency information along with the other required
	// information in this new node and then insert it into the free
	// list which is sorted in ascending cxcy.

	// size information
	pnewBelow->size = CXCY(cxBelow, cyBelow);
	pnewBelow->x = pvmem->x;
	pnewBelow->y = pvmem->y + cyThis;
	pnewBelow->ptr = pvmem->ptr + cyThis*pvmh->stride;
	pnewBelow->cx = cxBelow;
	pnewBelow->cy = cyBelow;
	pnewBelow->flags |= IS_FREE;

	// adjacency information
	pnewBelow->pLeft = pvmem->pLeft;
	pnewBelow->pUp = pvmem;
	pnewBelow->pRight = pvmem->pRight;
	pnewBelow->pDown = pvmem->pDown;
	insertIntoDoubleList( pnewBelow, ((LPVMEMR) pvmh->freeList)->next );

	// Modify the current node to reflect the changes we've made:

	pvmem->cy = cyThis;
    }

    // Update adjacency information for the current node

    if(pnewBelow != NULL)
    {
	pvmem->pDown = pnewBelow;
	if((pnewBeside != NULL) && (cyBeside == pvmem->cy))
	    pnewBeside->pDown = pnewBelow;
    }

    if(pnewBeside != NULL)
    {
	pvmem->pRight = pnewBeside;
	if ((pnewBelow != NULL) && (cxBelow == pvmem->cx))
	    pnewBelow->pRight = pnewBeside;
    }

    // Remove this node from the available list
    pvmem->next->prev = pvmem->prev;
    pvmem->prev->next = pvmem->next;

    // set up new pointers (pBits is the value returned to the client, pvmem
    // points to the actual top-left of the block).
    pvmem->pBits = pvmem->ptr + dwLeftWastage + dwTopWastage*pvmh->stride;
    pvmem->flags &= NOT_FREE;
    pvmem->size = CXCY(pvmem->cx, pvmem->cy);

    // Now insert it into the alloc list.
    insertIntoDoubleList( pvmem, ((LPVMEMR) pvmh->allocList)->next );

    if( NULL != lpdwSize )
    {
	/*
	 * Note this is the total number of bytes needed for this surface
	 * including the stuff off the left and right hand sides due to
	 * pitch not being equal to width. This is different from the
	 * size computed above which is simply the number of bytes within
	 * the boundary of the surface itself.
	 *
	 * The formula below calculates the number of bytes from the first
	 * byte in the rectangular surface to the first byte after it
	 * taking the pitch into account. Complex I know but it works.
	 */
	DDASSERT( 0UL != pvmem->cy );
	*lpdwSize = (pvmh->stride * (pvmem->cy - 1)) + pvmem->cx;
    }

    CHECK_HEAP("After rectVidMemAlloc",pvmh);
    return pvmem->pBits;

} /* rectVidMemAlloc */

/*
 * rectVidMemFree = free some rectangular flat video memory
 */
void rectVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    LPVMEMR	pvmem;
    LPVMEMR	pBeside;

    // Find the node in the allocated list which matches ptr
    for(pvmem=((LPVMEMR)pvmh->allocList)->next; pvmem->size != SENTINEL;
	pvmem = pvmem->next)
	if(pvmem->pBits == ptr)
	    break;

    if(pvmem->size == SENTINEL)	  // couldn't find allocated rectangle?
    {
	VDPF(( 0, V, "Couldn't find node requested freed!\n"));
	return;
    }

    // pvmem now points to the node which must be freed.  Attempt to 
    // coalesce rectangles around this node until no more action
    // is possible.

    while(1)
    {
	// Try merging with the right sibling:

	pBeside = pvmem->pRight;
	if ((pBeside->flags & IS_FREE)	     &&
	    (pBeside->cy    == pvmem->cy)    &&
	    (pBeside->pUp   == pvmem->pUp)   &&
	    (pBeside->pDown == pvmem->pDown) &&
	    (pBeside->pRight->pLeft != pBeside))
	{
	    // Add the right rectangle to ours:

	    pvmem->cx	 += pBeside->cx;
	    pvmem->pRight = pBeside->pRight;

	    // Remove pBeside from the list and free it.
	    pBeside->next->prev = pBeside->prev;
	    pBeside->prev->next = pBeside->next;
	    MemFree(pBeside);
	    continue;	    // go back and try again
	}

	// Try merging with the lower sibling:

	pBeside = pvmem->pDown;
	if ((pBeside->flags & IS_FREE)	       &&
	    (pBeside->cx     == pvmem->cx)     &&
	    (pBeside->pLeft  == pvmem->pLeft)  &&
	    (pBeside->pRight == pvmem->pRight) &&
	    (pBeside->pDown->pUp != pBeside))
	{
	    pvmem->cy	+= pBeside->cy;
	    pvmem->pDown = pBeside->pDown;

	    // Remove pBeside from the list and free it.
	    pBeside->next->prev = pBeside->prev;
	    pBeside->prev->next = pBeside->next;
	    MemFree(pBeside);
	    continue;	    // go back and try again
	}

	// Try merging with the left sibling:

	pBeside = pvmem->pLeft;
	if ((pBeside->flags & IS_FREE)	      &&
	    (pBeside->cy     == pvmem->cy)    &&
	    (pBeside->pUp    == pvmem->pUp)   &&
	    (pBeside->pDown  == pvmem->pDown) &&
	    (pBeside->pRight == pvmem)	      &&
	    (pvmem->pRight->pLeft != pvmem))
	{
	    // We add our rectangle to the one to the left:

	    pBeside->cx	   += pvmem->cx;
	    pBeside->pRight = pvmem->pRight;

	    // Remove 'pvmem' from the list and free it:
	    pvmem->next->prev = pvmem->prev;
	    pvmem->prev->next = pvmem->next;
	    MemFree(pvmem);
	    pvmem = pBeside;
	    continue;
	}

	// Try merging with the upper sibling:

	pBeside = pvmem->pUp;
	if ((pBeside->flags & IS_FREE)	       &&
	    (pBeside->cx       == pvmem->cx)   &&
	    (pBeside->pLeft  == pvmem->pLeft)  &&
	    (pBeside->pRight == pvmem->pRight) &&
	    (pBeside->pDown  == pvmem)	       &&
	    (pvmem->pDown->pUp != pvmem))
	{
	    pBeside->cy	     += pvmem->cy;
	    pBeside->pDown  = pvmem->pDown;

	    // Remove 'pvmem' from the list and free it:
	    pvmem->next->prev = pvmem->prev;
	    pvmem->prev->next = pvmem->next;
	    MemFree(pvmem);
	    pvmem = pBeside;
	    continue;
	}

	// Remove the node from its current list.

	pvmem->next->prev = pvmem->prev;
	pvmem->prev->next = pvmem->next;

	pvmem->size = CXCY(pvmem->cx, pvmem->cy);
	pvmem->flags |= IS_FREE;

	// Insert the node into the free list:
	insertIntoDoubleList( pvmem, ((LPVMEMR) pvmh->freeList)->next );

	// No more area coalescing can be done, return.

        CHECK_HEAP("After rectVidMemFree",pvmh);
	return;
    }
}

/*
 * rectVidMemAmountAllocated
 */
DWORD rectVidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    LPVMEMR	pvmem;
    DWORD	size;

    size = 0;
    // Traverse the alloc list and add up all the used space.
    for(pvmem=((LPVMEMR)pvmh->allocList)->next; pvmem->size != SENTINEL;
	pvmem = pvmem->next)
    {
	size += pvmem->cx * pvmem->cy;
    }

    return size;

} /* rectVidMemAmountAllocated */

/*
 * rectVidMemAmountFree
 */
DWORD rectVidMemAmountFree( LPVMEMHEAP pvmh )
{
    LPVMEMR	pvmem;
    DWORD	size;

    size = 0;
    // Traverse the free list and add up all the empty space.
    for(pvmem=((LPVMEMR)pvmh->freeList)->next; pvmem->size != SENTINEL;
	pvmem = pvmem->next)
    {
	size += pvmem->cx * pvmem->cy;
    }

    return size;

} /* rectVidMemAmountFree */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddithunk.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddithunk.h
 *  Content:	header file used by the NT DDI thunk layer
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Dec-99  smac    Created it
 *
 ***************************************************************************/

#ifndef __DDITHUNK_INCLUDED__
#define __DDITHUNK_INCLUDED__

typedef struct _CACHEENTRY
{
    LPDDRAWI_DDRAWSURFACE_INT   pSurface;
    DWORD                       UsageStamp;
} CACHEENTRY;

typedef struct _DEFERREDCREATE
{
    D3D8_CREATESURFACEDATA      CreateData;
    struct _DEFERREDCREATE     *pNext;
} DEFERREDCREATE, *PDEFERREDCREATE;

typedef struct _DDDEVICEHANDLE
{
    LPDDRAWI_DIRECTDRAW_INT     pDD;
    LPDDRAWI_DIRECTDRAW_INT     pSwDD;
    DWLIST                      SurfaceHandleList;
    char                        szDeviceName[MAX_DRIVER_NAME];
    BOOL                        bDeviceLost;
    D3DFORMAT                   DisplayFormatWithAlpha;
    D3DFORMAT                   DisplayFormatWithoutAlpha;
    UINT                        DriverLevel;
    struct _DDCONTEXT*          pContext;
    struct _DDSURFACE*          pSurfList;
    struct _DDDEVICEHANDLE*     pLink;
    struct _PALETTEINFO**       pPaletteHandleTable;
    DWORD                       NumPaletteHandleEntries;
    LPDIRECTDRAWPALETTE         pDefaultPalette;
    BOOL                        bCanTextureSysmem;
    DWORD                       PID;
    DWORD                       PCIID;
    DWORD                       DriverVersionHigh;
    DWORD                       DriverVersionLow;
    CACHEENTRY*                 pCachedSurfaceTable;
    int                         NumCachedSurfaces;
    DWORD                       CacheUsageStamp;
    DWORD                       ForceFlagsOn;
    DWORD                       ForceFlagsOff;
    BOOL                        bLightweight;
    VOID*                       pSwInitFunction;
    BOOL                        bDP2Error;
    PDEFERREDCREATE             pDeferList;
    D3DDEVTYPE                  DeviceType;
} DDDEVICEHANDLE, * PDDDEVICEHANDLE;

typedef struct _DDSURFACE
{
    // NOTE: dwCookie must be the first element
    // since we need easy access to it from the 
    // client and the thunk layer itself.
    DWORD                           dwCookie;

    DWORD                           dwFlags;
    union
    {
        LPDDRAWI_DDRAWSURFACE_INT   pHeavy;
        struct _LIGHTWEIGHTSURFACE* pLight;
    } Surface;
    union
    {
        BYTE*                       fpVidMem;
        LPDDRAWI_DDRAWSURFACE_INT   pTempHeavy;
    };
    int                             Pitch;
    D3DPOOL                         Pool;
    D3DFORMAT                       Format;   
    D3DRESOURCETYPE                 Type;
    DWORD                           Height;
    LPVOID                          pBits;
    DWORD                           LockFlags;
    RECT                            LockRect;
    PDDDEVICEHANDLE                 pDevice;
    struct _DDSURFACE*              pNext;
    struct _DDSURFACE*              pPrevious;
    int                             iSlicePitch;
} DDSURFACE, * PDDSURFACE;

#define DDSURFACE_LIGHTWEIGHT               0x00000001
#define DDSURFACE_HEAVYWEIGHT               0x00000002
#define DDSURFACE_ROOT                      0x00000004
#define DDSURFACE_LOCKRECT                  0x00000008
#define DDSURFACE_SOFTWARE                  0x00000010
#define DDSURFACE_HAL                       0x00000020
#define DDSURFACE_DX6HANDLE                 0x00000040
#define DDSURFACE_CREATECOMPLETE            0x00000080
#define DDSURFACE_CREATEEX                  0x00000100
#define DDSURFACE_SYSMEMALLOCATED           0x00000200
#define DDSURFACE_SYSMEMLOCK                0x00000400
#define DDSURFACE_DEFERCREATEEX             0x00000800
#define DDSURFACE_DEFERCREATETEXHANDLE      0x00001000
#define DDSURFACE_DUMMY                     0x00002000
#define DDSURFACE_TREATASVIDMEM             0x00004000      // Flag to indicate that surf should
                                                            // be treated as vid-mem for the
                                                            // "do vid-mem surfaces exist" case


typedef struct _DDCONTEXT
{
    DWORD       Context;

    void*       pDPBuffer; // This is used to cache the pointer allocated at 
                           // context-create time
    // Clear emulation cache
    DWORD       red_mask;
    DWORD       red_scale;
    DWORD       red_shift;
    DWORD       green_mask;
    DWORD       green_scale;
    DWORD       green_shift;
    DWORD       blue_mask;
    DWORD       blue_scale;
    DWORD       blue_shift;
    DWORD       zmask_shift, stencilmask_shift;
    BOOL        bDDSTargetIsPalettized;  // true if 4 or 8 bit rendertarget
    
    DDDEVICEHANDLE*                 pDevice;

    // Used for defered creates
    DWORD       dwFlags;
    DWORD       dwTempContext;
    DWORD       dwPID;
    DWORD       ddrval;
} DDCONTEXT, * PDDCONTEXT;

#define DDCONTEXT_DEFER                     0x00000001
#define DDCONTEXT_DEFEREDTEXTUREHANDLES     0x00000002


typedef struct _LIGHTWEIGHTSURFACE
{
    // Members that go to the Lcl
    DWORD       LclFlags;
    DWORD       LclCaps1;
    ULONG_PTR   LclReserved1;
    DWORD       LclModeCreatedIn;
    DWORD       LclBackBufferCount;

    // Members that go to the Gbl
    DWORD       GblFlags;  
    LONG        GblPitch;    
    DWORD       GblWidth;    
    ULONG_PTR   GblReserved1; 
    D3DFORMAT   GblFormat;
    LPVMEMHEAP  pGblVidMemHeap;
    FLATPTR     fpGblVidMem; 

    // Members that go to the More
    DWORD       MoreCaps2;
    DWORD       MoreCaps3;
    DWORD       MoreCaps4;
    VOID*       MoreRgjunc;

    // Members that go to the GblMore
    ULONG_PTR   GblMoreDriverReserved;               
    DWORD       GblMoreContentsStamp;                
    LPVOID      pGblMoreUnswappedDriverReserved;
    FLATPTR     fpGblMoreAliasOfVidMem;
    DWORD       cGblMorePageUnlocks;

    // Unions to save memory
    union
    {
        FLATPTR         fpGblMorePhysicalVidMem;        // non-local vidmem
        FLATPTR         fpGblMoreAliasedVidMem;         // local vidmem
        DWORD           MoreBytesAllocated;             // sys mem
    };
    union
    {
        DWORD           MoreMipMapCount;                // Mipmaps
        DWORD           MoreFVF;                        // Exe buffers
    };
    UINT                CachedIndex;                    // ORed with INDEX_IN_USE if in use
} LIGHTWEIGHTSURFACE, * PLIGHTWEIGHTSURFACE;

#define INDEX_IN_USE    0x80000000


typedef struct _PALETTEINFO
{
    DDSURFACE*          pSurface;
    LPDIRECTDRAWPALETTE pDDPalette;
    PALETTEENTRY        ColorTable[256];
} PALETTEINFO, * PPALETTEINFO;

#define EXTRA_PALETTE_PADDING               25


#define IS_SOFTWARE_DRIVER(x)                                       \
    (((PDDDEVICEHANDLE)(x))->pSwDD != NULL)

#define IS_SOFTWARE_DRIVER_SURFACE(x)                               \
    (((PDDSURFACE)(x))->dwFlags & DDSURFACE_SOFTWARE)

#define IS_SURFACE_LOOSABLE(x)                                      \
    (!IS_SOFTWARE_DRIVER_SURFACE(x) &&                              \
    ((((PDDSURFACE)(x))->Pool == D3DPOOL_LOCALVIDMEM) ||        \
    (((PDDSURFACE)(x))->Pool == D3DPOOL_NONLOCALVIDMEM) ||      \
    (((PDDSURFACE)(x))->Pool == D3DPOOL_MANAGED)))

#define INDEX_ENTRY(x)                                          \
    ((x) & ~INDEX_IN_USE)

#define GET_CACHED_ENTRY(x)                                     \
    (&((x)->pDevice->pCachedSurfaceTable[INDEX_ENTRY((x)->Surface.pLight->CachedIndex)]))

#define GET_CACHED_LIGHTWEIGHT_INT(x)                           \
    ((x)->pDevice->pCachedSurfaceTable[INDEX_ENTRY((x)->Surface.pLight->CachedIndex)].pSurface)


// Function protoptypes

extern void ConvertToOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT NewFormat);
extern void ConvertFromOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT *pNewFormat);
extern LPDDRAWI_DIRECTDRAW_INT SwDDICreateDirectDraw(void);
extern void SwDDIMungeCaps (HINSTANCE hLibrary, HANDLE hDD, PD3D8_DRIVERCAPS pDriverCaps, PD3D8_CALLBACKS pCallbacks, LPDDSURFACEDESC, UINT*, VOID*);
extern HRESULT SwDDICreateSurface(PD3D8_CREATESURFACEDATA pCreateSurface, DDSURFACEDESC2* pSurfDesc);
extern void SwDDIAttachSurfaces (LPDDRAWI_DDRAWSURFACE_LCL pFrom, LPDDRAWI_DDRAWSURFACE_LCL pTo);
extern void SwDDICreateSurfaceEx (LPDDRAWI_DIRECTDRAW_LCL pDrv, LPDDRAWI_DDRAWSURFACE_LCL pLcl);
extern DWORD SwDDIDestroySurface (HANDLE hDD, PDDSURFACE pSurf, LPDDRAWI_DDRAWSURFACE_LCL pLcl);
extern HRESULT SwDDILock (HANDLE hDD, PDDSURFACE pSurf, PD3D8_LOCKDATA pLockData, LPDDRAWI_DDRAWSURFACE_LCL pLcl);
extern HRESULT SwDDIUnlock( HANDLE hDD, PDDSURFACE pSurf, D3D8_UNLOCKDATA* pUnlockData, LPDDRAWI_DDRAWSURFACE_LCL pLcl );
extern LPDDRAWI_DDRAWSURFACE_INT MapLightweightSurface(DDSURFACE* pSurf);
extern void UnmapLightweightSurface(DDSURFACE* pSurf);
extern HRESULT MapLegacyResult(HRESULT hr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddheapl.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheapl.c
 *  Content:    Linear heap manager
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   03-Feb-98  DrewB   Split from old vmemmgr.c for user/kernel code.
 *
 ***************************************************************************/

#include "ddrawpr.h"

/****************************************************************************

 This memory manager is designed to have no impact on video memory usage.
 Global memory is used to maintain the allocation and free lists.  Because
 of this choice, merging of free blocks is a more expensive operation.
 The assumption is that in general, the speed of creating/destroying these
 memory blocks is not a high usage item and so it is OK to be slower.

 ****************************************************************************/

/*
 * MIN_SPLIT_SIZE determines the minimum size of a free block - if splitting
 * a block will result in less than MIN_SPLIT_SIZE bytes left, then
 * those bytes are just left as part of the new block.
 */
#define MIN_SPLIT_SIZE  15

/*
 * BLOCK_BOUNDARY must be a power of 2, and at least 4.  This gives
 * us the alignment of memory blocks.   
 */
#define BLOCK_BOUNDARY  4

/*
 * linVidMemInit - initialize video memory manager
 */
BOOL linVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, FLATPTR end )
{
    DWORD       size;

    VDPF((4,V, "linVidMemInit(%08lx,%08lx)", start, end ));

    /*
     * get the size of the heap (and verify its alignment for debug builds)
     */
    size = (DWORD)(end - start) + 1;
    #ifdef DEBUG
	if( (size & (BLOCK_BOUNDARY-1)) != 0 )
	{
	    VDPF(( 0, V, "Invalid size: %08lx (%ld)\n", size, size ));
	}
    #endif

    pvmh->dwTotalSize = size;

    /*
     * set up a free list with the whole chunk of memory on the block
     */
    pvmh->freeList = MemAlloc( sizeof( VMEML ) );
    if( pvmh->freeList == NULL )
    {
	return FALSE;
    }
    ((LPVMEML)pvmh->freeList)->next = NULL;
    ((LPVMEML)pvmh->freeList)->ptr = start;
    ((LPVMEML)pvmh->freeList)->size = size;

    pvmh->allocList = NULL;

    return TRUE;

} /* linVidMemInit */

/*
 * linVidMemFini - done with video memory manager
 */
void linVidMemFini( LPVMEMHEAP pvmh )
{
    LPVMEML     curr;
    LPVMEML     next;

    if( pvmh != NULL )
    {
	/*
	 * free all memory allocated for the free list
	 */
	curr = (LPVMEML)pvmh->freeList;
	while( curr != NULL )
	{
	    next = curr->next;
	    MemFree( curr );
	    curr = next;
	}
	pvmh->freeList = NULL;

	/*
	 * free all memory allocated for the allocation list
	 */
	curr = (LPVMEML)pvmh->allocList;
	while( curr != NULL )
	{
	    next = curr->next;
	    MemFree( curr );
	    curr = next;
	}
	pvmh->allocList = NULL;

	/*
	 * free the heap data
	 */
	MemFree( pvmh );
    }

} /* linVidMemFini */

/*
 * insertIntoList - add an item to the allocation list. list is kept in
 *                  order of increasing size
 */
void insertIntoList( LPVMEML pnew, LPLPVMEML listhead )
{
    LPVMEML     pvmem;
    LPVMEML     prev;

    #ifdef DEBUG
	if( pnew->size == 0 )
	{
	    VDPF(( 0, V, "block size = 0!!!\n" ));
	}
    #endif

    /*
     * run through the list (sorted from smallest to largest) looking
     * for the first item bigger than the new item
     */
    pvmem = *listhead;
    prev = NULL;
    while( pvmem != NULL )
    {
	if( pnew->size < pvmem->size )
	{
	    break;
	}
	prev = pvmem;
	pvmem = pvmem->next;
    }

    /*
     * insert the new item item (before the found one)
     */
    if( prev != NULL )
    {
	pnew->next = pvmem;
	prev->next = pnew;
    }
    else
    {
	pnew->next = *listhead;
	*listhead = pnew;
    }

} /* insertIntoList */

/*
 * coalesceFreeBlocks - add a new item to the free list and coalesce
 */
LPVMEML coalesceFreeBlocks( LPVMEMHEAP pvmh, LPVMEML pnew )
{
    LPVMEML     pvmem;
    LPVMEML     prev;
    FLATPTR     end;
    BOOL        done;

    pvmem = (LPVMEML)pvmh->freeList;
    pnew->next = NULL;
    end = pnew->ptr + pnew->size;
    prev = NULL;
    done = FALSE;

    /*
     * try to merge the new block "pnew"
     */
    while( pvmem != NULL )
    {
	if( pnew->ptr == (pvmem->ptr + pvmem->size) )
	{
	    /*
	     * new block starts where another ended
	     */
	    pvmem->size += pnew->size;
	    done = TRUE;
	}
	else if( end == pvmem->ptr )
	{
	    /*
	     * new block ends where another starts
	     */
	    pvmem->ptr = pnew->ptr;
	    pvmem->size += pnew->size;
	    done = TRUE;
	}
	/*
	 * if we are joining 2 blocks, remove the merged on from the
	 * list and return so that it can be re-tried (we don't recurse
	 * since we could get very deep)
	 */
	if( done )
	{
	    if( prev != NULL )
	    {
		prev->next = pvmem->next;
	    }
	    else
	    {
		pvmh->freeList = pvmem->next;
	    }
	    MemFree( pnew );
	    return pvmem;
	}
	prev = pvmem;
	pvmem = pvmem->next;
    }

    /*
     * couldn't merge, so just add to the free list
     */
    insertIntoList( pnew, (LPLPVMEML) &pvmh->freeList );
    return NULL;

} /* coalesceFreeBlocks */

/*
 * linVidMemFree = free some flat video memory
 */
void linVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    LPVMEML     pvmem;
    LPVMEML     prev;

    if( ptr == (FLATPTR) NULL )
    {
	return;
    }

    #ifdef DEBUG
	if( pvmh == NULL )
	{
	    VDPF(( 0, V, "VidMemAlloc: NULL heap handle!\n" ));
	    return;
	}
    #endif

    pvmem = (LPVMEML)pvmh->allocList;
    prev = NULL;

    /*
     * run through the allocation list and look for this ptr
     * (O(N), bummer; that's what we get for not using video memory...)
     */
    while( pvmem != NULL )
    {
	if( pvmem->ptr == ptr )
	{
	    /*
	     * remove from allocation list
	     */
	    if( prev != NULL )
	    {
		prev->next = pvmem->next;
	    }
	    else
	    {
		pvmh->allocList = pvmem->next;
	    }
	    /*
	     * keep coalescing until we can't coalesce anymore
	     */
	    while( pvmem != NULL )
	    {
		pvmem = coalesceFreeBlocks( pvmh, pvmem );
	    }
	    return;
	}
	prev = pvmem;
	pvmem = pvmem->next;
    }

} /* linVidMemFree */

/*
 * linVidMemAlloc - alloc some flat video memory
 */
FLATPTR linVidMemAlloc( LPVMEMHEAP pvmh, DWORD xsize, DWORD ysize,
                        LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment,
                        LPLONG lpNewPitch )
{
    LPVMEML     pvmem;
    LPVMEML     prev;
    LPVMEML     pnew_free;

    DWORD       dwBeforeWastage;
    DWORD       dwAfterWastage;
    FLATPTR     pAligned;

    LONG        lNewPitch;

    DWORD       size;

    if( xsize == 0 || ysize == 0 || pvmh == NULL )
    {
	return (FLATPTR) NULL;
    }

    lNewPitch = (LONG) xsize;
    if (lpAlignment && lpAlignment->Linear.dwPitchAlignment )
    {
        if (lNewPitch % lpAlignment->Linear.dwPitchAlignment)
        {
            lNewPitch += lpAlignment->Linear.dwPitchAlignment - lNewPitch % lpAlignment->Linear.dwPitchAlignment;
        }
    }
    /*
     * This weird size calculation doesn't include the little bit on the 'bottom right' of the surface
     */
    size = (DWORD) lNewPitch * (ysize-1) + xsize;
    size = (size+(BLOCK_BOUNDARY-1)) & ~(BLOCK_BOUNDARY-1);

    /*
     * run through free list, looking for the closest matching block
     */
    prev = NULL;
    pvmem = (LPVMEML)pvmh->freeList;
    while( pvmem != NULL )
    {
	while( pvmem->size >= size ) //Using while as a try block
	{
            /*
             * Setup for no alignment changes..
             */
            pAligned = pvmem->ptr;
            dwBeforeWastage = 0;
            dwAfterWastage = pvmem->size - size;
            if( lpAlignment )
            {
                //get wastage if we put the new block at the beginning or at the end of the free block
                if( lpAlignment->Linear.dwStartAlignment )
                {
                    /*
                     * The before wastage is how much we'd have to skip at the beginning to align the surface
                     */

                    dwBeforeWastage = (lpAlignment->Linear.dwStartAlignment - ((DWORD)pvmem->ptr % lpAlignment->Linear.dwStartAlignment)) % lpAlignment->Linear.dwStartAlignment;
                    //if ( dwBeforeWastage+size > pvmem->size )
                    //    break;
                    /*
                     * The after wastage is the bit between the end of the used surface and the end of the block
                     * if we snuggle this surface as close to the end of the block as possible.
                     */
                    dwAfterWastage = ( (DWORD)pvmem->ptr + pvmem->size - size ) % lpAlignment->Linear.dwStartAlignment;
                    //if ( dwAfterWastage + size > pvmem->size )
                    //    break;
                }
                /*
                 * Reassign before/after wastage to meaningful values based on where the block will actually go.
                 * Also check that aligning won't spill the surface off either end of the block.
                 */
                if ( dwBeforeWastage <= dwAfterWastage )
                {
                    if (pvmem->size < size + dwBeforeWastage)
                    {
                        /*
                         * Alignment pushes end of surface off end of block
                         */
                        break;
                    }
                    dwAfterWastage = pvmem->size - (size + dwBeforeWastage);
                    pAligned = pvmem->ptr + dwBeforeWastage;
                }
                else
                {
                    if (pvmem->size < size + dwAfterWastage)
                    {
                        /*
                         * Alignment pushes end of surface off beginning of block
                         */
                        break;
                    }
                    dwBeforeWastage = pvmem->size - (size + dwAfterWastage);
                    pAligned = pvmem->ptr + dwBeforeWastage;
                }
            }
            DDASSERT(size + dwBeforeWastage + dwAfterWastage == pvmem->size );
            DDASSERT(pAligned >= pvmem->ptr );
            DDASSERT(pAligned + size <= pvmem->ptr + pvmem->size );
            /*
             * Remove the old free block from the free list.
             */
	    if( prev != NULL )
	    {
		prev->next = pvmem->next;
	    }
	    else
	    {
		pvmh->freeList = pvmem->next;
	    }

            /*
             * If the after wastage is less than a small amount, smush it into
             * this block.
             */
            if (dwAfterWastage <= MIN_SPLIT_SIZE)
            {
                size += dwAfterWastage;
                dwAfterWastage=0;
            }
            /*
             * Add the new block to the used list, using the old free block
             */
	    pvmem->size = size;
	    pvmem->ptr = pAligned;
	    if( NULL != lpdwSize )
		*lpdwSize = size;
            if (NULL != lpNewPitch)
                *lpNewPitch = lNewPitch;
	    insertIntoList( pvmem, (LPLPVMEML) &pvmh->allocList );

            /*
             * Add a new free block for before wastage
             */
            if (dwBeforeWastage)
            {
		pnew_free = (LPVMEML)MemAlloc( sizeof( VMEML ) );
		if( pnew_free == NULL )
		{
		    return (FLATPTR) NULL;
		}
		pnew_free->size = dwBeforeWastage;
		pnew_free->ptr = pAligned-dwBeforeWastage;
		insertIntoList( pnew_free, (LPLPVMEML) &pvmh->freeList );
            }
            /*
             * Add a new free block for after wastage
             */
            if (dwAfterWastage)
            {
		pnew_free = (LPVMEML)MemAlloc( sizeof( VMEML ) );
		if( pnew_free == NULL )
		{
		    return (FLATPTR) NULL;
		}
		pnew_free->size = dwAfterWastage;
		pnew_free->ptr = pAligned+size;
		insertIntoList( pnew_free, (LPLPVMEML) &pvmh->freeList );
            }
#ifdef DEBUG
            if( lpAlignment )
            {
                if (lpAlignment->Linear.dwStartAlignment)
                {
                    VDPF((5,V,"Alignment for start is %d",lpAlignment->Linear.dwStartAlignment));
                    DDASSERT(pvmem->ptr % lpAlignment->Linear.dwStartAlignment == 0);
                }
                if (lpAlignment->Linear.dwPitchAlignment)
                {
                    VDPF((5,V,"Alignment for pitch is %d",lpAlignment->Linear.dwPitchAlignment));
                    DDASSERT(lNewPitch % lpAlignment->Linear.dwPitchAlignment == 0);
                }
            }
#endif
	    return pvmem->ptr;
	}
	prev = pvmem;
	pvmem = pvmem->next;
    }
    return (FLATPTR) NULL;

} /* linVidMemAlloc */

/*
 * linVidMemAmountAllocated
 */
DWORD linVidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;
    DWORD       size;

    pvmem = (LPVMEML)pvmh->allocList;
    size = 0;
    while( pvmem != NULL )
    {
	size += pvmem->size;
	pvmem = pvmem->next;
    }
    return size;

} /* linVidMemAmountAllocated */

/*
 * linVidMemAmountFree
 */
DWORD linVidMemAmountFree( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;
    DWORD       size;

    pvmem = (LPVMEML)pvmh->freeList;
    size = 0;
    while( pvmem != NULL )
    {
	size += pvmem->size;
	pvmem = pvmem->next;
    }
    return size;

} /* linVidMemAmountFree */

/*
 * linVidMemLargestFree - alloc some flat video memory
 */
DWORD linVidMemLargestFree( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;

    if( pvmh == NULL )
    {
	return 0;
    }

    pvmem = (LPVMEML)pvmh->freeList;

    if( pvmem == NULL )
    {
	return 0;
    }
    
    while( 1 )
    {
	if( pvmem->next == NULL )
	{
	    return pvmem->size;
	}
	pvmem = pvmem->next;
    }
    
} /* linVidMemLargestFree */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddfake.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddfake.c
 *  Content:	fake out that we are a driver (for HEL)
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-mar-95	craige 	initial implementation
 *   01-apr-95	craige	happy fun joy updated header file
 *   30-jun-95	craige	turned off > 16bpp
 *   04-jul-95	craige	YEEHAW: new driver struct
 *   15-jul-95	craige	set DDCAPS_NOHARDWARE
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   22-jul-95	craige	emulation only needs to initialize correctly
 *   19-dec-95  jeffno  Counting number of modes in BuildModes fails if only 1 mode available\
 *   09-jan-96	kylej	re-enable > 16bpp modes
 *   13-mar-96  jeffno  Buildmodes not called under NT. Fix a >16bpp problem.
 *   19-apr-96  colinmc Bug 18059: New driver caps bit to indicate that a
 *                      driver can't interleave 2D and 3D operations in a
 *                      3D scene
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   15-oct-96  toddla  multimonitor support
 *   17-jan-97  colinmc Fixed problem with multimonitor on emulated displays
 *
 ***************************************************************************/
#include "ddrawpr.h"

static DWORD ropsSupported[DD_ROP_SPACE] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

/*
 * getBitMask
 */
BOOL getBitMask( LPDDHALMODEINFO pmi )
{
    pmi->wFlags = 0;
    if( pmi->dwBPP == 8 )
    {
	pmi->wFlags |= DDMODEINFO_PALETTIZED;
    }
    switch( pmi->dwBPP )
    {
    case 8:
	pmi->dwRBitMask = 0;
	pmi->dwGBitMask = 0;
	pmi->dwBBitMask = 0;
	break;
    case 16:
	pmi->dwRBitMask = 0xf800;
	pmi->dwGBitMask = 0x07e0;
	pmi->dwBBitMask = 0x001f;
	break;
    case 24:
	pmi->dwRBitMask = 0xff0000;
	pmi->dwGBitMask = 0x00ff00;
	pmi->dwBBitMask = 0x0000ff;
	break;
    case 32:
	pmi->dwRBitMask = 0xff0000;
	pmi->dwGBitMask = 0x00ff00;
	pmi->dwBBitMask = 0x0000ff;
	break;
    default:
    	return FALSE;
    }
    return TRUE;

} /* getBitMask */

/*
 * getDisplayMode
 *
 * get the current display settings
 */
static BOOL getDisplayMode( HDC hdc, LPDDHALMODEINFO pmi, DWORD FAR *pfreq )
{
    if( hdc != NULL )
    {
	pmi->dwBPP = GetDeviceCaps( hdc, BITSPIXEL ) * GetDeviceCaps( hdc, PLANES );
	*pfreq = GetDeviceCaps( hdc, VREFRESH );
	pmi->dwWidth = GetDeviceCaps( hdc, HORZRES );
	pmi->dwHeight = GetDeviceCaps( hdc, VERTRES );
	pmi->lPitch = GetDeviceCaps( hdc, DESKTOPHORZRES );
	DPF( 5, "getDisplayMode:" );
	DPF( 5, "    bpp=%ld, refresh=%ld", pmi->dwBPP, *pfreq );
	DPF( 5, "    dwHeight=%ld, dwWidth=%ld", pmi->dwHeight, pmi->dwWidth );
	DPF( 5, "    lStride=%ld", pmi->lPitch );
	getBitMask( pmi );
    }
    else
    {
	return FALSE;
    }
    return TRUE ;

} /* getDisplayMode */

/*
 * BuildModes
 *
 * build a HAL mode info array by using EnumDisplaySettings
 */
DWORD BuildModes( LPSTR szDevice, LPDDHALMODEINFO FAR *ppddhmi )
{
    DWORD		nummodes;
    DWORD               maxmodes;
    DWORD		cmode;
    DEVMODE		dm0;
    DEVMODE		dm;
    LPDDHALMODEINFO     pmi;

    ZeroMemory(&dm0,sizeof(dm0));
    ZeroMemory(&dm,sizeof(dm));
    dm0.dmSize = dm.dmSize = sizeof(dm0);

    /*
     * count the number of modes
     */
    nummodes = 0;
    cmode = 0;
    while( 1 )
    {
	if( cmode == 0 )
	{
            if( !EnumDisplaySettings( szDevice, cmode, &dm0 ) )
	    {
		break;
	    }
	}
	else
	{
            if( !EnumDisplaySettings( szDevice, cmode, &dm ) )
	    {
		break;
	    }
	}
	cmode++;
    	if( cmode==1 ? dm0.dmBitsPerPel >= 8 : dm.dmBitsPerPel >= 8 ) //was incorrectly counting when only 1 mode.
	{
	    nummodes++;
	}
    }
    DPF( 5, "Driver says nummodes=%d", nummodes );
    if( nummodes == 0 )
    {
	*ppddhmi = NULL;
	return 0;
    }

    /*
     * allocate some memory to hold all the mode data
     */
    pmi = MemAlloc( nummodes * sizeof( DDHALMODEINFO ) );
    if( pmi == NULL )
    {
	*ppddhmi = NULL;
	return 0;
    }

    /*
     * go get the mode data
     */
    cmode = 0;
    maxmodes = nummodes;
    nummodes = 0;
    while( 1 )
    {
        if (nummodes >= maxmodes)
        {
            break;
        }
	if( cmode == 0 )
	{
	    dm = dm0;
	}
	else
	{
            if( !EnumDisplaySettings( szDevice, cmode, &dm ) )
	    {
		break;
	    }
	}
	cmode++;
	/*
	 * don't care about 4bpp or 1bpp modes...
	 */
	if( dm.dmBitsPerPel < 8 )
	{
	    continue;
	}
    	pmi[nummodes].dwWidth = dm.dmPelsWidth;
    	pmi[nummodes].dwHeight = dm.dmPelsHeight;
    	pmi[nummodes].lPitch = dm.dmPelsWidth;
    	pmi[nummodes].dwBPP = dm.dmBitsPerPel;
    	pmi[nummodes].dwAlphaBitMask = 0;
	getBitMask( &pmi[nummodes] );
	nummodes++;
    }
    DPF( 5, "Enum Display Settings says nummodes=%d", nummodes );

    *ppddhmi = pmi;
    return nummodes;

} /* BuildModes */

/*
 * BuildPixelFormat
 *
 * generate a pixel format structure based on the mode
 */
void BuildPixelFormat(
                HDC             hdc,
		LPDDHALMODEINFO pmi,
		LPDDPIXELFORMAT pdpf )
{
    HBITMAP	    hbm;
    BITMAPINFO	    *pbmi;

    pdpf->dwSize = sizeof( DDPIXELFORMAT );
    pdpf->dwYUVBitCount = 0;
    pdpf->dwYBitMask = 0;
    pdpf->dwUBitMask = 0;
    pdpf->dwVBitMask = 0;
    pdpf->dwYUVAlphaBitMask = 0;
    pdpf->dwFourCC = 0;

    pdpf->dwFlags = DDPF_RGB;
    if( pmi->wFlags & DDMODEINFO_PALETTIZED )
    {
	pdpf->dwFlags |= DDPF_PALETTEINDEXED8;
    }
    pdpf->dwRGBBitCount = pmi->dwBPP;

    /*
     * This looks suspiciously like it was intended to run on 8 or 16 bpp
     * and nothing else. I changed it so we do this for 24 and 32 bpp
     * modes as well. jeffno 960610
     */
    if( pmi->dwBPP != 8 && hdc)
    {
        pbmi = (BITMAPINFO *)MemAlloc( sizeof( BITMAPINFOHEADER ) + 256 * 4 );
	if( pbmi )
	{
	    hbm = CreateCompatibleBitmap(hdc, 1, 1);
            if (hbm == NULL)
            {
                DPF( 0, "CreateCompatibleBitmap failed; unable to build pixel format");
            }
            else
            {
	        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	        pbmi->bmiHeader.biBitCount = 0;
	        GetDIBits(hdc, hbm, 0, 1, NULL, pbmi, DIB_RGB_COLORS);
	        pbmi->bmiHeader.biClrUsed = 0;
	        pbmi->bmiHeader.biCompression = BI_BITFIELDS;
	        GetDIBits(hdc, hbm, 0, 1, NULL, pbmi, DIB_RGB_COLORS);

	        pmi->dwRBitMask = *(long*)&(pbmi->bmiColors[0]);
	        pmi->dwGBitMask = *(long*)&(pbmi->bmiColors[1]);
	        pmi->dwBBitMask = *(long*)&(pbmi->bmiColors[2]);

	        DeleteObject( hbm );
            }
	    MemFree( pbmi );
	}
    }

    pdpf->dwRBitMask = pmi->dwRBitMask;
    pdpf->dwGBitMask = pmi->dwGBitMask;
    pdpf->dwBBitMask = pmi->dwBBitMask;
    pdpf->dwRGBAlphaBitMask = pmi->dwAlphaBitMask = 0;
    DPF(5, "Masks for current mode are: %08x %08x %08x", pdpf->dwRBitMask, pdpf->dwGBitMask, pdpf->dwBBitMask);
} /* BuildPixelFormat */

/*
 * FakeDDCreateDriverObject
 *
 * fake up that we are a driver that can't do anything...
 */
LPDDRAWI_DIRECTDRAW_GBL FakeDDCreateDriverObject(
                HDC hdc_dd,
                LPSTR szDrvName,
		LPDDRAWI_DIRECTDRAW_GBL pdd_old,
		BOOL reset,
                HANDLE hDDVxd )
{
    DDHALINFO			ddhi;
    LPDDRAWI_DIRECTDRAW_GBL	pdd;
    DDPIXELFORMAT		dpf;
    LPDDHALMODEINFO		pmi;
    DDHALMODEINFO		cmodeinfo;
    DWORD                       freq;
    LPSTR                       szDevice;

    if( (szDrvName != NULL) && (_stricmp(szDrvName, "DISPLAY") != 0) )
        szDevice = szDrvName;
    else
        szDevice = NULL;

    /*
     * initialize the DDHALINFO struct
     */
    memset( &ddhi, 0, sizeof( ddhi ) );
    ddhi.dwSize = sizeof( ddhi );

    /*
     * capabilities supported (none)
     */
    ddhi.ddCaps.dwCaps = DDCAPS_NOHARDWARE;
    ddhi.ddCaps.dwCaps2 = 0;
    ddhi.ddCaps.dwFXCaps = 0;
    ddhi.ddCaps.dwCKeyCaps = 0;
    ddhi.ddCaps.ddsCaps.dwCaps = 0;

    /*
     * pointer to primary surface
     */
    ddhi.vmiData.fpPrimary = 0;

    /*
     * build mode and pixel format info
     */
    pmi = &cmodeinfo;
    if( !getDisplayMode( hdc_dd, pmi, &freq ) )
    {
        DPF( 0, "Could not get base mode" );
	return NULL;
    }
    #if WIN95
    {
	int	i;
        ddhi.dwNumModes = BuildModes( szDevice, &ddhi.lpModeInfo );
	ddhi.dwModeIndex = (DWORD)-1;
	for( i=0;i<(int)ddhi.dwNumModes;i++ )
	{
	    if( (ddhi.lpModeInfo[i].dwBPP == pmi->dwBPP) &&
	    	(ddhi.lpModeInfo[i].dwHeight == pmi->dwHeight) &&
	    	(ddhi.lpModeInfo[i].dwWidth == pmi->dwWidth) )
	    {
		ddhi.dwModeIndex = i;
		DPF( 5, "dwModeIndex = %d", i );
		break;
	    }
	}
    }
    #else
    {
        if (!GetCurrentMode(pdd_old, &ddhi, szDrvName))
        {
            DPF(0, "Could not get current mode information");
            return NULL;
        }
    }
    #endif

    ddhi.vmiData.dwDisplayHeight = pmi->dwHeight;
    ddhi.vmiData.dwDisplayWidth = pmi->dwWidth;
    ddhi.vmiData.lDisplayPitch = pmi->lPitch;

    /*
     * set up pixel format of primary surface
     */
    BuildPixelFormat( hdc_dd, pmi, &dpf );
    ddhi.vmiData.ddpfDisplay = dpf;

    /*
     * fourcc code information
     */
    ddhi.ddCaps.dwNumFourCCCodes = 0;
    ddhi.lpdwFourCC = NULL;

    /*
     * Fill in heap info
     */
    ddhi.vmiData.dwNumHeaps = 0;
    ddhi.vmiData.pvmList = NULL;

    /*
     * required alignments of the scanlines of each kind of memory
     * (DWORD is the MINIMUM)
     */
    ddhi.vmiData.dwOffscreenAlign = sizeof( DWORD );
    ddhi.vmiData.dwOverlayAlign = sizeof( DWORD );
    ddhi.vmiData.dwTextureAlign = sizeof( DWORD );
    ddhi.vmiData.dwAlphaAlign = sizeof( DWORD );
    ddhi.vmiData.dwZBufferAlign = sizeof( DWORD );

    /*
     * callback functions
     */
    ddhi.lpDDCallbacks = NULL;
    ddhi.lpDDSurfaceCallbacks = NULL;
    ddhi.lpDDPaletteCallbacks = NULL;

    /*
     * create the driver object
     */
    pdd = DirectDrawObjectCreate( &ddhi, reset, pdd_old, hDDVxd, szDrvName, 0, 0 /* ATTENTION: No lcl flags in emulation */ );

    if( pdd != NULL )
    {
	pdd->dwFlags |= DDRAWI_NOHARDWARE;
        pdd->dwFlags |= DDRAWI_DISPLAYDRV;
        pdd->dwFlags |= DDRAWI_GDIDRV;

        lstrcpy(pdd->cDriverName, szDrvName);

        /*
    	 * get mode info from HEL
     	 */
    	{
	    void UpdateDirectDrawMode( LPDDRAWI_DIRECTDRAW_GBL this );
	    UpdateDirectDrawMode( pdd );
    	}
    }

    MemFree( ddhi.lpModeInfo );

    return pdd;

} /* FakeDDCreateDriverObject */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddiunk.c ===
/*==========================================================================
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddiunk.c
 *  Content:    DirectDraw IUnknown interface
 *              Implements QueryInterface, AddRef, and Release
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   14-mar-95  craige  split out of ddraw.c
 *   19-mar-95  craige  process termination cleanup fixes
 *   29-mar-95  craige  DC per process to clean up; use GETCURRPID
 *   31-mar-95  craige  cleanup palettes
 *   01-apr-95  craige  happy fun joy updated header file
 *   07-apr-95  craige  bug 14 - check GUID ptr in QI
 *                      don't release NULL hdc
 *   12-may-95  craige  check for guids
 *   15-may-95  craige  restore mode, free surfaces & palettes on a
 *                      per-process basis
 *   24-may-95  craige  release allocated tables
 *   02-jun-95  craige  extra parm in AddToActiveProcessList
 *   06-jun-95  craige  call RestoreDisplayMode
 *   07-jun-95  craige  removed DCLIST
 *   12-jun-95  craige  new process list stuff
 *   21-jun-95  craige  clipper stuff
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   03-jul-95  craige  YEEHAW: new driver struct; SEH
 *   13-jul-95  craige  removed spurious frees of ddhel dll (obsolete);
 *                      don't restore the mode if not excl mode owner on death
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   21-nov-95  colinmc made Direct3D a queryable interface off DirectDraw
 *   27-nov-95  jeffno  ifdef'd out VxD stuff (in DD_Release) for winnt
 *   01-dec-95  colinmc new IID for DirectDraw V2
 *   22-dec-95  colinmc Direct3D support no longer conditional
 *   25-dec-95	craige	allow a NULL lpGbl ptr for QI, AddRef, Release
 *   31-dec-95	craige	validate riid
 *   01-jan-96  colinmc Fixed D3D integration bug which lead to
 *                      the Direct3D DLL being released too early.
 *   13-jan-96  colinmc Temporary workaround for Direct3D cleanup problem
 *   04-jan-96  kylej   add interface structures
 *   26-jan-96  jeffno  Destroy NT kernel-mode objects
 *   07-feb-96  jeffno  Rearrange DD_Release so that freed objects aren't referenced
 *   08-feb-96  colinmc New D3D interface
 *   17-feb-96  colinmc Removed final D3D references
 *   28-feb-96  colinmc Fixed thread-unsafe problem in DD_Release
 *   22-mar-96  colinmc Bug 13316: uninitialized interfaces
 *   23-mar-96  colinmc Bug 12252: Direct3D not properly cleaned up on GPF
 *   27-mar-96  colinmc Bug 14779: Bad cleanup on Direct3DCreate failure
 *   18-apr-96  colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *   29-apr-96  colinmc Bug 19954: Must query for Direct3D before texture
 *                      or device
 *   03-may-96  kylej   Bug 19125: Preserve V1 SetCooperativeLevel behaviour
 *   15-sep-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   29-jan-97  smac    Fixed video port container bug
 *   03-mar-97  smac    Added kernel mode interface
 *   08-mar-97  colinmc Added support for DMA style AGP parts
 *   30-sep-97  jeffno  IDirectDraw4
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#define DPF_MODNAME "DirectDraw::QueryInterface"

/*
 * Create the Direct3D interface aggregated by DirectDraw. This involves
 * loading the Direct3D DLL, getting the Direct3DCreate entry point and
 * invoking it.
 *
 * NOTE: This function does not call QueryInterface() on the returned
 * interface to bump the reference count as this function may be invoked
 * by one of the surface QueryInterface() calls to initialized Direct3D
 * before the user makes a request for external interface.
 *
 * Returns:
 * DD_OK         - success
 * E_NOINTERFACE - we could not find valid Direct3D DLLs (we assumed its not
 *                 installed and so the Direct3D interfaces are not understood)
 * D3DERR_       - We found a valid Direct3D installation but the object
 *                 creation failed for some reason.
 */
HRESULT InitD3DRevision(
    LPDDRAWI_DIRECTDRAW_INT this_int,
    HINSTANCE * pDLLHinstance,
    IUnknown ** ppOwnedIUnknown,
    DWORD dwRevisionLevel )
{
    D3DCreateProc lpfnD3DCreateProc;
    HRESULT rval;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;

    this_lcl = this_int->lpLcl;

    /*
     * This function does no checking to ensure that it
     * has not already been invoked for this driver object
     * so this must be NULL on entry.
     */
    DDASSERT( NULL == this_lcl->pD3DIUnknown );

    DPF( 4, "Initializing Direct3D" );

    /*
     * Load the Direct3D DLL.
     */

    if(*pDLLHinstance == NULL)
    {
        char* pDLLName;

        if (dwRevisionLevel < 0x700)
        {
            pDLLName = D3D_DLLNAME;
        }
        else
        {
            pDLLName = D3DDX7_DLLNAME;
        }

        *pDLLHinstance = LoadLibrary( pDLLName );

        if( *pDLLHinstance == NULL )
        {
            DPF( 0, "Could not locate the Direct3D DLL (%s)", pDLLName);
            return E_NOINTERFACE;
        }
    }

    lpfnD3DCreateProc = (D3DCreateProc)GetProcAddress( *pDLLHinstance, D3DCREATE_PROCNAME );
    this_lcl->pPaletteUpdateNotify = (LPPALETTEUPDATENOTIFY)GetProcAddress( *pDLLHinstance, PALETTEUPDATENOTIFY_NAME );
    this_lcl->pPaletteAssociateNotify = (LPPALETTEASSOCIATENOTIFY)GetProcAddress( *pDLLHinstance, PALETTEASSOCIATENOTIFY_NAME );
    this_lcl->pSurfaceFlipNotify = (LPSURFACEFLIPNOTIFY)GetProcAddress( *pDLLHinstance, SURFACEFLIPNOTIFY_NAME );
    this_lcl->pFlushD3DDevices = (FLUSHD3DDEVICES)GetProcAddress( *pDLLHinstance, FLUSHD3DDEVICES_NAME );
    this_lcl->pD3DTextureUpdate = (D3DTEXTUREUPDATE)GetProcAddress( *pDLLHinstance, D3DTEXTUREUPDATE_NAME );
    if (dwRevisionLevel >= 0x700)
    {
        this_lcl->pFlushD3DDevices2 = this_lcl->pFlushD3DDevices;
        this_lcl->pD3DCreateTexture = (D3DCREATETEXTURE)GetProcAddress( *pDLLHinstance, D3DCREATETEXTURE_NAME );
        this_lcl->pD3DDestroyTexture = (D3DDESTROYTEXTURE)GetProcAddress( *pDLLHinstance, D3DDESTROYTEXTURE_NAME );
        this_lcl->pD3DSetPriority = (D3DSETPRIORITY)GetProcAddress( *pDLLHinstance, D3DSETPRIORITY_NAME );
        this_lcl->pD3DGetPriority = (D3DGETPRIORITY)GetProcAddress( *pDLLHinstance, D3DGETPRIORITY_NAME );
        this_lcl->pD3DSetLOD = (D3DSETLOD)GetProcAddress( *pDLLHinstance, D3DSETLOD_NAME );
        this_lcl->pD3DGetLOD = (D3DGETLOD)GetProcAddress( *pDLLHinstance, D3DGETLOD_NAME );
        this_lcl->pBreakVBLock = (LPBREAKVBLOCK)GetProcAddress( *pDLLHinstance, BREAKVBLOCK_NAME );
        this_lcl->pddSurfaceCallbacks = &ddSurfaceCallbacks;
    }
    else
    {
        this_lcl->pFlushD3DDevices2 = (FLUSHD3DDEVICES)GetProcAddress( *pDLLHinstance, FLUSHD3DDEVICES2_NAME );
        this_lcl->pD3DCreateTexture = NULL;
        this_lcl->pD3DDestroyTexture = NULL;
        this_lcl->pD3DSetPriority = NULL;
        this_lcl->pD3DGetPriority = NULL;
        this_lcl->pD3DSetLOD = NULL;
        this_lcl->pD3DGetLOD = NULL;
        this_lcl->pBreakVBLock = NULL;
        this_lcl->pddSurfaceCallbacks = NULL;
    }

    if( lpfnD3DCreateProc == NULL )
    {
        DPF( 0, "Could not locate the Direct3DCreate entry point" );
        FreeLibrary( *pDLLHinstance );
        *pDLLHinstance = NULL;
        return E_NOINTERFACE;
    }

    /*
     * ### Tada - an aggregated object creation ###
     */
    #ifdef USE_D3D_CSECT
        rval = (*lpfnD3DCreateProc)( ppOwnedIUnknown, (LPUNKNOWN)this_int );
    #else /* USE_D3D_CSECT */
        #ifdef WINNT
           rval = (*lpfnD3DCreateProc)( 0, ppOwnedIUnknown, (LPUNKNOWN)this_int );
        #else
           rval = (*lpfnD3DCreateProc)( lpDDCS, ppOwnedIUnknown, (LPUNKNOWN)this_int );
        #endif
    #endif /* USE_D3D_CSECT */
    if( rval == DD_OK )
    {
        DPF( 4, "Created aggregated Direct3D interface" );
        return DD_OK;
    }
    else
    {
        /*
         * Direct3D did understand the IID but failed to initialize for
         * some other reason.
         */
        DPF( 0, "Could not create aggregated Direct3D interface" );
        *ppOwnedIUnknown = NULL;
        FreeLibrary( *pDLLHinstance );
        *pDLLHinstance = NULL;
        return rval;
    }
}

HRESULT InitD3D( LPDDRAWI_DIRECTDRAW_INT this_int )
{
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;

    this_lcl = this_int->lpLcl;
    if( DDRAWILCL_DIRECTDRAW7 & this_lcl->dwLocalFlags)
    {
        return InitD3DRevision( this_int, &this_lcl->hD3DInstance, &this_lcl->pD3DIUnknown, 0x700);
    }
    else
    {
        return InitD3DRevision( this_int, &this_lcl->hD3DInstance, &this_lcl->pD3DIUnknown, 0x600);
    }
}

#if 0
/*
 * This function builds a d3d device context for use by ddraw. DDraw will use this context
 * initially to send palette update messages.
 */
HRESULT InitDDrawPrivateD3DContext( LPDDRAWI_DIRECTDRAW_INT this_int )
{
    IUnknown *              pD3DUnknown;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    HRESULT                 hr=DD_OK;
    HINSTANCE               hInstance;

    this_lcl = this_int->lpLcl;

    DDASSERT( 0 == (this_lcl->dwLocalFlags & DDRAWILCL_ATTEMPTEDD3DCONTEXT) );

    /*
     * If this is a dx7 ddraw object, then we will piggy back off of the d3d object
     * that's created when IDirect3Dx is QIed. This saves creating another d3d object
     * since they are quite piggy.
     * If this is not a dx7 object, then we have to get our own dx7 d3d, since the dx6
     * d3d can't understand our extra calls.
     */
    if( DDRAWILCL_DIRECTDRAW7 & this_lcl->dwLocalFlags)
    {
        if( !D3D_INITIALIZED( this_lcl ) )
            hr = InitD3D( this_int );

        this_lcl->hinstDDrawPrivateD3D = 0;

        pD3DUnknown = this_lcl->pD3DIUnknown;
        hInstance = this_lcl->hD3DInstance;
        //We set this up so d3d doesn't have to struggle trying to figure out which iunknown to use
        this_lcl->pPrivateD3DInterface = this_lcl->pD3DIUnknown;
    }
    else
    {
        /*
         * Have to create a new one and keep it around
         */
        hr = InitD3DRevision( this_int, &this_lcl->hinstDDrawPrivateD3D, &this_lcl->pPrivateD3DInterface, 0x700 );
        pD3DUnknown = this_lcl->pPrivateD3DInterface;
        hInstance = this_lcl->hinstDDrawPrivateD3D;
    }

    if (SUCCEEDED(hr))
    {
        GETDDRAWCONTEXT pGetContext;

        DDASSERT(hInstance);
        DDASSERT(pD3DUnknown);
        /*
         * Go create the d3d device
         */
        pGetContext = (GETDDRAWCONTEXT)GetProcAddress( hInstance, GETDDRAWCONTEXT_NAME );

        if (pGetContext)
        {
            this_lcl->pDeviceContext = pGetContext(this_lcl);
            /*
             * Go get the notification entry points.
             * If either of these fail, we carry on regardless.
             */
            this_lcl->pPaletteUpdateNotify = (LPPALETTEUPDATENOTIFY)GetProcAddress( hInstance, PALETTEUPDATENOTIFY_NAME );
            this_lcl->pPaletteAssociateNotify = (LPPALETTEASSOCIATENOTIFY)GetProcAddress( hInstance, PALETTEASSOCIATENOTIFY_NAME );
        }
    }
    this_lcl->dwLocalFlags |= DDRAWILCL_ATTEMPTEDD3DCONTEXT;
    return hr;
}
#endif

/*
 * getDDInterface
 */
LPDDRAWI_DIRECTDRAW_INT getDDInterface( LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPVOID lpddcb )
{
    LPDDRAWI_DIRECTDRAW_INT curr_int;

    ENTER_DRIVERLISTCSECT();
    for( curr_int = lpDriverObjectList; curr_int != NULL; curr_int = curr_int->lpLink )
    {
        if( (curr_int->lpLcl == this_lcl) &&
            (curr_int->lpVtbl == lpddcb) )
        {
            break;
        }
    }
    if( NULL == curr_int )
    {
        // Couldn't find an existing interface, create one.
        curr_int = MemAlloc( sizeof( DDRAWI_DIRECTDRAW_INT ) );
        if( NULL == curr_int )
        {
            LEAVE_DRIVERLISTCSECT();
            return NULL;
        }

        /*
         * set up data
         */
        curr_int->lpVtbl = lpddcb;
        curr_int->lpLcl = this_lcl;
        curr_int->dwIntRefCnt = 0;
        curr_int->lpLink = lpDriverObjectList;
        lpDriverObjectList = curr_int;
    }
    LEAVE_DRIVERLISTCSECT();
    DPF( 5, "New driver interface created, %08lx", curr_int );
    return curr_int;
}
#ifdef POSTPONED
/*
 * Delegating IUnknown for DDraw
 */
HRESULT DDAPI DD_DelegatingQueryInterface(
                LPDIRECTDRAW lpDD,
                REFIID riid,
                LPVOID FAR * ppvObj )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    HRESULT                     hr;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_DelegatingQueryInterface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * We have to check if the owning IUnknown is actually one of our own
     * interfaces
     */
    if ( IS_NATIVE_DDRAW_INTERFACE(this_int->lpLcl->pUnkOuter) )
    {
        /*
         * So we can trust that the int pointer really is a pointer to DDRAW_DIRECTDRAW_INT
         */
        hr = this_int->lpLcl->pUnkOuter->lpVtbl->QueryInterface((IUnknown*)lpDD, riid, ppvObj);
    }
    else
    {
        /*
         * So we have no idea whose pointer it is, better pass its this pointer.
         */
        hr = this_int->lpLcl->pUnkOuter->lpVtbl->QueryInterface(this_int->lpLcl->pUnkOuter, riid, ppvObj);
    }

    LEAVE_DDRAW();
    return hr;
}

DWORD DDAPI DD_DelegatingAddRef( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    DWORD                       dw;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_DelegatingAddRef");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
            // what error code can you return from AddRef??
	    return 0;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
        // what error code can you return from AddRef??
	return 0;
    }

    /*
     * We have to check if the owning IUnknown is actually one of our own
     * interfaces
     */
    if ( IS_NATIVE_DDRAW_INTERFACE(this_int->lpLcl->pUnkOuter) )
    {
        /*
         * So we can trust that the int pointer really is a pointer to DDRAW_DIRECTDRAW_INT
         */
        dw = this_int->lpLcl->pUnkOuter->lpVtbl->AddRef((IUnknown*)lpDD);
    }
    else
    {
        /*
         * So we have no idea whose pointer it is, better pass its this pointer.
         */
        dw = this_int->lpLcl->pUnkOuter->lpVtbl->AddRef(this_int->lpLcl->pUnkOuter);
    }

    LEAVE_DDRAW();
    return dw;
}

DWORD DDAPI DD_DelegatingRelease( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    DWORD                       dw;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_DeletegatingRelease");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
            // what error code can you return from AddRef??
	    return 0;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
        // what error code can you return from Release??
	return 0;
    }

    /*
     * We have to check if the owning IUnknown is actually one of our own
     * interfaces
     */
    if ( IS_NATIVE_DDRAW_INTERFACE(this_int->lpLcl->pUnkOuter) )
    {
        /*
         * So we can trust that the int pointer really is a pointer to DDRAW_DIRECTDRAW_INT
         */
        dw = this_int->lpLcl->pUnkOuter->lpVtbl->Release((IUnknown*)lpDD);
    }
    else
    {
        /*
         * So we have no idea whose pointer it is, better pass its this pointer.
         */
        dw = this_int->lpLcl->pUnkOuter->lpVtbl->Release(this_int->lpLcl->pUnkOuter);
    }

    LEAVE_DDRAW();
    return dw;
}

#endif //postponed

/*
 * DD_QueryInterface
 */
HRESULT DDAPI DD_QueryInterface(
                LPDIRECTDRAW lpDD,
                REFIID riid,
                LPVOID FAR * ppvObj )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    HRESULT                     rval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_QueryInterface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        if( !VALID_PTR_PTR( ppvObj ) )
        {
            DPF( 1, "Invalid object ptr" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( !VALIDEX_IID_PTR( riid ) )
        {
            DPF( 1, "Invalid iid ptr" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *ppvObj = NULL;
        this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * Is the IID one of DirectDraw's?
     */
#ifdef POSTPONED
    if( IsEqualIID(riid, &IID_IUnknown) )
    {
        /*
         * If we are being aggregated and the QI is for IUnknown,
         * then we must return a non delegating interface. The only way this can
         * happen is if the incoming vtable points to our non delegating vtables.
         * In this case we can simply addref and return.
         * If we are not aggregated, then the QI must have the same pointer value
         * as any other QI for IUnknown, so we make that the ddCallbacks.
         */
        if( ( this_int->lpVtbl == &ddNonDelegatingUnknownCallbacks ) ||
            ( this_int->lpVtbl == &ddUninitNonDelegatingUnknownCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &ddCallbacks );
    }
    else
#endif
    if (IsEqualIID(riid, &IID_IDirectDraw) || IsEqualIID(riid, &IID_IUnknown) )
    {
        if( ( this_int->lpVtbl == &ddCallbacks ) ||
            ( this_int->lpVtbl == &ddUninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &ddCallbacks );
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw2 ) )
    {
        if( (this_int->lpVtbl == &dd2Callbacks )||
            ( this_int->lpVtbl == &dd2UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd2Callbacks );
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw4 ) )
    {
        if( (this_int->lpVtbl == &dd4Callbacks ) ||
            ( this_int->lpVtbl == &dd4UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd4Callbacks );
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw7 ) )
    {
        if( (this_int->lpVtbl == &dd7Callbacks ) ||
            ( this_int->lpVtbl == &dd7UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
        {
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd7Callbacks );
            #ifdef WIN95
                if ( *ppvObj )
                {
                    DDGetMonitorInfo( (LPDDRAWI_DIRECTDRAW_INT) *ppvObj );
                }
            #endif
        }
    }
    else if( IsEqualIID(riid, &IID_IDDVideoPortContainer ) )
    {
        if( this_int->lpVtbl == &ddVideoPortContainerCallbacks )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = getDDInterface (this_int->lpLcl, &ddVideoPortContainerCallbacks);
    }
    else if( IsEqualIID(riid, &IID_IDirectDrawKernel ) )
    {
        /*
         * Don't create the interface if the VDD didn't have a handle
         * the kernel mode interface.
         */
        if( !IsKernelInterfaceSupported( this_lcl ) )
        {
            DPF( 0, "Kernel Mode interface not supported" );
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }

        if( this_int->lpVtbl == &ddKernelCallbacks )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = getDDInterface (this_int->lpLcl, &ddKernelCallbacks);
    }
    else if( IsEqualIID(riid, &IID_IDDVideoAcceleratorContainer ) )
    {
        /*
         * Don't create the interface if the hardware doesn't support it
         */
        if( !IsMotionCompSupported( this_lcl ) )
        {
            DPF( 0, "Motion comp interface not supported" );
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }

        if( this_int->lpVtbl == &ddMotionCompContainerCallbacks )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = getDDInterface (this_int->lpLcl, &ddMotionCompContainerCallbacks);
        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
    else
    {
#ifndef _IA64_
#if _WIN32_WINNT >= 0x0501
        typedef BOOL (WINAPI *PFN_ISWOW64PROC)( HANDLE hProcess,
                                                PBOOL Wow64Process );
        HINSTANCE hInst = NULL;
        hInst = LoadLibrary( "kernel32.dll" );
        if( hInst )
        {
            PFN_ISWOW64PROC pfnIsWow64 = NULL;
            pfnIsWow64 = (PFN_ISWOW64PROC)GetProcAddress( (HMODULE)hInst, "IsWow64Process" );
            // We assume that if this function is not available, then it is some OS where
            // WOW64 does not exist (this means that pre-Release versions of XP are busted)
            if( pfnIsWow64 )
            {
                BOOL wow64Process;
                if (pfnIsWow64(GetCurrentProcess(), &wow64Process) && wow64Process)
                {
                    DPF_ERR("Pre-DX8 D3D interfaces are not supported on WOW64");
                    LEAVE_DDRAW();
                    return E_NOINTERFACE;
                }
            }
            FreeLibrary( hInst );
        }
        else
        {
            DPF_ERR("LoadLibrary failed. Quitting.");
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
#endif // _WIN32_WINNT >= 0x0501
#else  // _IA64_
        DPF_ERR("Pre-DX8 D3D interfaces are not supported on IA64");
        LEAVE_DDRAW();
        return E_NOINTERFACE;
#endif // _IA64_

        DPF( 4, "IID not understood by DirectDraw QueryInterface - trying Direct3D" );

        /*
         * It's not one of DirectDraw's so it might be the Direct3D
         * interface. So try Direct3D.
         */
        if( !D3D_INITIALIZED( this_lcl ) )
        {
            /*
             * No Direct3D interface yet so try and create one.
             */
            rval = InitD3D( this_int );
            if( FAILED( rval ) )
            {
                /*
                 * Direct3D could not be initialized. No point trying to
                 * query for the Direct3D interface if we could not
                 * initialize Direct3D.
                 *
                 * NOTE: This assumes that DirectDraw does not aggregate
                 * any other object type. If it does this code will need
                 * to be revised.
                 */
                LEAVE_DDRAW();
                return rval;
            }
        }

        DDASSERT( D3D_INITIALIZED( this_lcl ) );

        /*
         * We have a Direct3D interface so try the IID out on it.
         */
        DPF( 4, "Passing query off to Direct3D interface" );
        rval = this_lcl->pD3DIUnknown->lpVtbl->QueryInterface( this_lcl->pD3DIUnknown, riid, ppvObj );
        if( rval == DD_OK )
        {
            DPF( 4, "Sucessfully queried for the Direct3D interface" );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }

    if( NULL == *ppvObj )
    {
        DPF_ERR( "IID not understood by DirectDraw" );
        LEAVE_DDRAW();
        return E_NOINTERFACE;
    }
    else
    {
        /*
         * Note that this casts the ppvObj to an IUnknown and then calls it.
         * This is better than hard-coding to call the DD_AddRef, since we
         * may be aggregated and so need to punt addref calls to the owning
         * iunknown. This will happen automatically if it's any recognized non-IUnknown
         * interface because they all have a delegating unknown
         */
        ((IUnknown*)( *ppvObj ))->lpVtbl->AddRef(*ppvObj);
        LEAVE_DDRAW();
        return DD_OK;
    }
} /* DD_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDraw::UnInitedQueryInterface"
/*
 * DD_UnInitedQueryInterface
 */
HRESULT DDAPI DD_UnInitedQueryInterface(
                LPDIRECTDRAW lpDD,
                REFIID riid,
                LPVOID FAR * ppvObj )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_UnInitedQueryInterface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        if( !VALID_PTR_PTR( ppvObj ) )
        {
            DPF( 1, "Invalid object ptr" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( !VALIDEX_IID_PTR( riid ) )
        {
            DPF( 1, "Invalid iid ptr" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * Is the IID one of DirectDraw's?
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_IDirectDraw) )
    {
        /*
         * Our IUnknown interface is the same as our V1
         * interface.  We must always return the V1 interface
         * if IUnknown is requested.
         */
        if( ( this_int->lpVtbl == &ddCallbacks ) ||
            ( this_int->lpVtbl == &ddUninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &ddUninitCallbacks );

        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw2 ) )
    {
        if( (this_int->lpVtbl == &dd2Callbacks ) ||
            ( this_int->lpVtbl == &dd2UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd2UninitCallbacks );

        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw4 ) )
    {
        if( (this_int->lpVtbl == &dd4Callbacks ) ||
            ( this_int->lpVtbl == &dd4UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd4UninitCallbacks );

        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
    else if( IsEqualIID(riid, &IID_IDirectDraw7 ) )
    {
        if( (this_int->lpVtbl == &dd7Callbacks ) ||
            ( this_int->lpVtbl == &dd7UninitCallbacks ) )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDInterface( this_int->lpLcl, &dd7UninitCallbacks );

        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }


    DPF( 2, "IID not understood by uninitialized DirectDraw QueryInterface" );

    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_UnInitedQueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDraw::AddRef"

/*
 * DD_AddRef
 */
DWORD DDAPI DD_AddRef( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_AddRef");
    /* DPF( 2, "DD_AddRef, pid=%08lx, obj=%08lx", GETCURRPID(), lpDD ); */

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return 0;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return 0;
    }

    /*
     * bump refcnt
     */
    if( this != NULL )
    {
        this->dwRefCnt++;
    }
    this_lcl->dwLocalRefCnt++;
    this_int->dwIntRefCnt++;

    #ifdef DEBUG
        if( this == NULL )
        {
            DPF( 5, "DD_AddRef, Reference Count: Global Undefined Local = %ld Int = %ld",
                this_lcl->dwLocalRefCnt, this_int->dwIntRefCnt );
        }
        else
        {
            DPF( 5, "DD_AddRef, Reference Count: Global = %ld Local = %ld Int = %ld",
                this->dwRefCnt, this_lcl->dwLocalRefCnt, this_int->dwIntRefCnt );
        }
    #endif

    LEAVE_DDRAW();

    return this_int->dwIntRefCnt;

} /* DD_AddRef */

#ifdef WIN95
#define MMDEVLDR_IOCTL_CLOSEVXDHANDLE       6
/*
 * closeVxDHandle
 */
static void closeVxDHandle( DWORD dwHandle )
{

    HANDLE hFile;

    hFile = CreateFile(
        "\\\\.\\MMDEVLDR.VXD",
        GENERIC_WRITE,
        FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
        NULL);

    if( hFile == INVALID_HANDLE_VALUE )
    {
        return;
    }

    DeviceIoControl( hFile,
                     MMDEVLDR_IOCTL_CLOSEVXDHANDLE,
                     NULL,
                     0,
                     &dwHandle,
                     sizeof(dwHandle),
                     NULL,
                     NULL);

    CloseHandle( hFile );
    DPF( 5, "closeVxdHandle( %08lx ) done", dwHandle );

} /* closeVxDHandle */
#endif

#if 0
/*
 * This function calls d3dim700.dll to clean up any driver state that may be stored per-ddrawlocal
 */
void CleanUpD3DPerLocal(LPDDRAWI_DIRECTDRAW_LCL this_lcl)
{
    HINSTANCE                   hInstance=0;
    /*
     * Call d3d for per-local cleanup. We only call d3dim7.
     * For safety, we'll just load a new copy of the DLL whether or not we're on ddhelp's PID
     */
    hInstance = LoadLibrary( D3DDX7_DLLNAME );

    if (hInstance)
    {
        FreeLibrary(hInstance);
    }
}
#endif


/*
 * DD_Release
 *
 * Once the globalreference count reaches 0, all surfaces are freed and all
 * video memory heaps are destroyed.
 */
DWORD DDAPI DD_Release( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWPALETTE_INT   ppal_int;
    LPDDRAWI_DDVIDEOPORT_INT    pvport_int;
    DWORD                       rc;
    DWORD                       refcnt;
    DWORD                       intrefcnt;
    DWORD                       lclrefcnt;
    DWORD                       gblrefcnt;
    int                         i;
    DDHAL_DESTROYDRIVERDATA     dddd;
    DWORD                       pid;
    HANDLE                      hinst;
    HANDLE                      hvxd;
    #ifdef WIN95
        DWORD                   event16;
        DWORD                   eventDOSBox;
        HANDLE                  hthisvxd;
    #endif
    #ifdef WINNT
        LPATTACHED_PROCESSES    lpap;
    #endif

    ENTER_DDRAW();

        pid = GETCURRPID();

    DPF(2,A,"ENTERAPI: DD_Release");
    /* DPF( 2, "DD_Release, pid=%08lx, obj=%08lx", pid, lpDD ); */

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return 0;
        }
        if ( this_int->dwIntRefCnt == 0 )
        {
            DPF_ERR( "DDraw Interface pointer has 0 ref count! Interface has been over-released.");
            LEAVE_DDRAW();
            return 0;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return 0;
    }

    /*
     * decrement process reference count
     */
    this_int->dwIntRefCnt--;
    intrefcnt = this_int->dwIntRefCnt;
    this_lcl->dwLocalRefCnt--;
    lclrefcnt = this_lcl->dwLocalRefCnt;
    if( this != NULL )
    {
        this->dwRefCnt--;
        gblrefcnt = this->dwRefCnt;
    }
    else
    {
        gblrefcnt = (DWORD) -1;
    }

    DPF( 5, "DD_Release, Ref Count: Global = %ld Local = %ld Interface = %ld",
        gblrefcnt, lclrefcnt, intrefcnt );


    /*
     * if the global refcnt is zero, free the driver object
     * note that the local object must not be freed yet because
     * we need to use the HAL callback tables
     */

    hinst = NULL;
    #ifdef WIN95
        event16 = 0;
        eventDOSBox = 0;
        hthisvxd = INVALID_HANDLE_VALUE;
    #endif
    /*
     * if local object is freed, for the owning process we:
     * - cleanup palettes, clippers & surfaces
     * - restore display mode
     * - release exclusive mode
     * - find the DC used by the process
     */
    if( lclrefcnt == 0 )
    {
        #ifdef TIMING
            // Printing timing information
            TimerDump();
        #endif

        /*
         * see if the hwnd was hooked, if so, undo it!
         */
        if( this_lcl->dwLocalFlags & DDRAWILCL_HOOKEDHWND )
        {
            SetAppHWnd( this_lcl, NULL, 0 );
            this_lcl->dwLocalFlags &= ~DDRAWILCL_HOOKEDHWND;
        }

        //
        // Do not call CleanUpD3DPerLocal because it does a LoadLibrary on
        // d3dim700.dll and is currently unnecessary. The LoadLibrary can
        // cause problems when opengl32.dll is detaching from a process
        // because they call DD_Release. Since ddraw.dll is statically linked
        // to opengl32.dll, it may be marked to be unloaded when opengl32.dll
        // is, and the load of d3dim700.dll here can cause ddraw.dll to be
        // reloaded at a different address, in this case, before the first
        // instance of ddraw.dll has been freed.
        //

        //CleanUpD3DPerLocal(this_lcl);

        if( GetCurrentProcessId() == GETCURRPID() )
        {
            /*
             * If we have created the Direct3D IUnknown release it now.
             * NOTE: The life of an aggregated object is the same as that
             * of its owning interface so we can also free the DLL at
             * this point.
             * NOTE: We must free the library AFTER ProcessSurfaceCleanup
             * as it can invoke D3D members to clean up device and texture
             * surfaces.
             */
            if( this_lcl->pD3DIUnknown != NULL )
            {
                DPF(4, "Releasing Direct3D IUnknown");
                this_lcl->pD3DIUnknown->lpVtbl->Release( this_lcl->pD3DIUnknown );
                /*
                 * Actually, this FreeLibrary will kill the process if the app
                 * did the final release of d3d after the final release of ddraw.
                 * The d3d release will punt to the owning IUnknown (us) and we
                 * will decrement ref count to zero and free the d3d DLL then
                 * return to the caller. The caller was IDirect3D::Release within
                 * the d3d DLL, so we would free the code that called us.
                 * For DX5 we will take out this FreeLibrary to fix the shutdown
                 * problem, but we should probably find something better for DX6 etc.
                 */
                //FreeLibrary( this_lcl->hD3DInstance );
                this_lcl->pD3DIUnknown = NULL;
                this_lcl->hD3DInstance = NULL;
            }
        }

        if( this != NULL )
        {
            BOOL excl_exists,has_excl;
            /*
             * punt process from any surfaces and palettes
             */
            FreeD3DSurfaceIUnknowns( this, pid, this_lcl );
            ProcessSurfaceCleanup( this, pid, this_lcl );
            ProcessPaletteCleanup( this, pid, this_lcl );
            ProcessClipperCleanup( this, pid, this_lcl );
            ProcessVideoPortCleanup( this, pid, this_lcl );
            ProcessMotionCompCleanup( this, pid, this_lcl );
#ifdef WIN95
            if (this_lcl->lpDDCB && this_lcl->lpDDCB->HALDDMiscellaneous2.DestroyDDLocal)
            {
                DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
                DDHAL_DESTROYDDLOCALDATA destDDLcl;
                destDDLcl.dwFlags = 0;
                destDDLcl.pDDLcl  = this_lcl;
                ENTER_WIN16LOCK();
                dwRet = this_lcl->lpDDCB->HALDDMiscellaneous2.DestroyDDLocal(&destDDLcl);
                LEAVE_WIN16LOCK();
                if (dwRet == DDHAL_DRIVER_NOTHANDLED)
                {
                    DPF(0, "DD_Release: failed DestroyDDLocal");
                }
            }
#endif
            /*
             * reset the display mode if needed
             * and only if we are doing the v1 SetCooperativeLevel behaviour
             */

            CheckExclusiveMode(this_lcl, &excl_exists, &has_excl, FALSE, NULL, FALSE);

            if( this_lcl->dwLocalFlags & DDRAWILCL_V1SCLBEHAVIOUR)
            {
                if( (gblrefcnt == 0) ||
                    (!excl_exists) ||
                    (has_excl ) )
                {
                    RestoreDisplayMode( this_lcl, TRUE );
                }
            }
            else
            {
                /*
                 * Even in V2 or later, we want to restore the display
                 * mode for a non exclusive app.  Exclusive mode apps
                 * will restore their mode in DoneExclusiveMode
                 */
                if(!excl_exists)
                {
                    RestoreDisplayMode( this_lcl, TRUE );
                }
            }

            /*
             * exclusive mode held by this process? if so, release it
             */
            if( has_excl )
            {
                DoneExclusiveMode( this_lcl );
            }

            #ifdef WIN95
                /*
                 * We don't close the VXD handle just yet as we may need it
                 * to release virtual memory aliases if the global object
                 * is dying. Just remember that we need to free it for now.
                 */
                hthisvxd = (HANDLE) this_lcl->hDDVxd;

                /*
                 * Get a VXD handle we can use to communicate with the DirectX vxd.
                 * Please note that this code can be executed in the context of
                 * the processes which created the local object or DDHELP's if an
                 * application is shutting down without cleaning up. Therefore we
                 * can't just use the VXD handle stored in the local object as that
                 * my belong to a dead process (and hence be an invalid handle in
                 * the current process). Therefore, we need to detect whether we
                 * are being executed by DDHELP or an application process and
                 * choose a vxad handle appropriately. This is the destinction
                 * between hthisvxd which is the VXD handle stored in the local
                 * object and hvxd which is the VXD handle we can actually use
                 * to talk to the VXD.
                 */
                hvxd = ( ( GetCurrentProcessId() != GETCURRPID() ) ? hHelperDDVxd : hthisvxd );
                DDASSERT( INVALID_HANDLE_VALUE != hvxd );
            #else /* WIN95 */
                /*
                 * Handle is not used on NT. Just pass NULL.
                 */
                hvxd = INVALID_HANDLE_VALUE;
            #endif /* WIN95 */

            /*
             * If we created a device window ourselves, destroy it now
             */
            if( ( this_lcl->dwLocalFlags & DDRAWILCL_CREATEDWINDOW ) &&
                IsWindow( (HWND) this_lcl->hWnd ) )
            {
                DestroyWindow( (HWND) this_lcl->hWnd );
                this_lcl->hWnd = 0;
                this_lcl->dwLocalFlags &= ~DDRAWILCL_CREATEDWINDOW;
            }

            /*
             * If we previously loaded a gamma calibrator, unload it now.
             */
            if( this_lcl->hGammaCalibrator != (ULONG_PTR)INVALID_HANDLE_VALUE )
            {
                /*
                 * If we are on the helper thread, we don't need to unload the
                 * calibrator because it's already gone.
                 */
                if( GetCurrentProcessId() == GETCURRPID() )
                {
                    FreeLibrary( (HMODULE)this_lcl->hGammaCalibrator );
                }
                this_lcl->hGammaCalibrator = (ULONG_PTR) INVALID_HANDLE_VALUE;
            }

            /*
             * If a mode test was started, but not finished, release the
             * memory now.
             */
            if( this_lcl->lpModeTestContext )
            {
                MemFree( this_lcl->lpModeTestContext->lpModeList );
                MemFree( this_lcl->lpModeTestContext );
                this_lcl->lpModeTestContext = NULL;
            }

            /*
             * The palette handle bitfield
             */
            MemFree(this_lcl->pPaletteHandleUsedBitfield);
            this_lcl->pPaletteHandleUsedBitfield = 0;
        }
    }

    /*
     * Note the local object is freed after the global...
     */

    if( gblrefcnt == 0 )
    {
        DPF( 4, "FREEING DRIVER OBJECT" );

        /*
         * Notify driver.
         */
        dddd.lpDD = this;
        if((this->dwFlags & DDRAWI_EMULATIONINITIALIZED) &&
           (this_lcl->lpDDCB->HELDD.DestroyDriver != NULL))
        {
            /*
             * if the HEL was initialized, make sure we call the HEL
             * DestroyDriver function so it can clean up.
             */
            DPF( 4, "Calling HEL DestroyDriver" );
            dddd.DestroyDriver = NULL;

            /*
             * we don't really care about the return value of this call
             */
            rc = this_lcl->lpDDCB->HELDD.DestroyDriver( &dddd );
        }

        // Note that in a multimon system, a driver that is not attached to the
        // desktop is destroyed by GDI at termination of the process that uses
        // the driver.  In this case, Ddhelp cleanup must not try to destroy the
        // driver again or it will cause a GP fault.
        if( (this_lcl->lpDDCB->cbDDCallbacks.DestroyDriver != NULL) &&
            ((this->dwFlags & DDRAWI_ATTACHEDTODESKTOP) ||
             (dwGrimReaperPid != GetCurrentProcessId())))
        {
            dddd.DestroyDriver = this_lcl->lpDDCB->cbDDCallbacks.DestroyDriver;
            DPF( 4, "Calling DestroyDriver" );
            rc = this_lcl->lpDDCB->HALDD.DestroyDriver( &dddd );
            if( rc == DDHAL_DRIVER_HANDLED )
            {
                // Ignore any failure since there's no way to report a failure to
                // the app and exiting now would leave a half initialized interface
                // in the DriverObjectList
                DPF( 5, "DDHAL_DestroyDriver: ddrval = %ld", dddd.ddRVal );
            }
        }

        /*
         * release all surfaces
         */
        psurf_int = this->dsList;
        while( psurf_int != NULL )
        {
            LPDDRAWI_DDRAWSURFACE_INT   next_int;

            refcnt = psurf_int->dwIntRefCnt;
            next_int = psurf_int->lpLink;
            while( refcnt > 0 )
            {
                DD_Surface_Release( (LPDIRECTDRAWSURFACE) psurf_int );
                refcnt--;
            }
            psurf_int = next_int;
        }

        /*
         * release all palettes
         */
        ppal_int = this->palList;
        while( ppal_int != NULL )
        {
            LPDDRAWI_DDRAWPALETTE_INT   next_int;

            refcnt = ppal_int->dwIntRefCnt;
            next_int = ppal_int->lpLink;
            while( refcnt > 0 )
            {
                DD_Palette_Release( (LPDIRECTDRAWPALETTE) ppal_int );
                refcnt--;
            }
            ppal_int = next_int;
        }

        /*
         * release all videoports
         */
        pvport_int = this->dvpList;
        while( pvport_int != NULL )
        {
            LPDDRAWI_DDVIDEOPORT_INT    next_int;

            refcnt = pvport_int->dwIntRefCnt;
            next_int = pvport_int->lpLink;
            while( refcnt > 0 )
            {
                DD_VP_Release( (LPDIRECTDRAWVIDEOPORT) pvport_int );
                refcnt--;
            }
            pvport_int = next_int;
        }

        #ifdef WINNT
            /*
             * The driver needs to know to free its internal state
             */

            // Update DDraw handle in driver GBL object.
            this->hDD = this_lcl->hDD;

            DdDeleteDirectDrawObject(this);
            lpap = lpAttachedProcesses;
            while( lpap != NULL )
            {
                if( lpap->dwPid == pid )
                    lpap->dwNTToldYet = 0;

                lpap = lpap->lpLink;
            }
        #endif

        #ifdef USE_ALIAS
            /*
             * If this local object has heap aliases release them now.
             * NOTE: This really should release the heap aliases as by
             * this point all the surfaces should have gone.
             */
            if( NULL != this->phaiHeapAliases )
            {
                DDASSERT( 1UL == this->phaiHeapAliases->dwRefCnt );

                /*
                 * Need to decide which VXD handle to use. If we are executing
                 * on a DDHELP thread use the helper's VXD handle.
                 */
                ReleaseHeapAliases( hvxd, this->phaiHeapAliases );
            }
        #endif /* USE_ALIAS */

        /*
         * Notify the kernel mode interface that we are done using it
         */
        ReleaseKernelInterface( this_lcl );

#ifndef WINNT
        /*
         * free all video memory heaps
         */
        for( i=0;i<(int)this->vmiData.dwNumHeaps;i++ )
        {
            LPVIDMEM    pvm;
            pvm = &this->vmiData.pvmList[i];
            HeapVidMemFini( pvm, hvxd );
        }
#endif //not WINNT

        /*
         * free extra tables
         */
        MemFree( this->lpdwFourCC );
        MemFree( this->vmiData.pvmList );
#ifndef WINNT
        //On NT, lpModeInfo points to a contained member of "this"
        MemFree( this->lpModeInfo );
#endif
        MemFree( this->lpDDVideoPortCaps );
        MemFree( this->lpDDKernelCaps );
        MemFree( (LPVOID) this->lpD3DHALCallbacks2 );
        MemFree( (LPVOID) this->lpD3DHALCallbacks3);
        MemFree( (LPVOID) this->lpD3DExtendedCaps );
        MemFree( this->lpddNLVCaps );
        MemFree( this->lpddNLVHELCaps );
        MemFree( this->lpddNLVBothCaps );
#ifdef WINNT
        if ( this->lpD3DGlobalDriverData )
            MemFree( this->lpD3DGlobalDriverData->lpTextureFormats );
        // The lpD3DGlobalDriverData, lpD3DHALCallbacks and EXEBUF structs
        // are allocated in one chunk in ddcreate.c
        MemFree( (void *)this->lpD3DHALCallbacks );
        if (NULL != this->SurfaceHandleList.dwList)
        {
            MemFree(this->SurfaceHandleList.dwList);
        }
#endif

        MemFree(this->lpZPixelFormats);
        MemFree(this->lpddMoreCaps);
        MemFree(this->lpddHELMoreCaps);
        MemFree(this->lpddBothMoreCaps);
        MemFree( this->lpMonitorInfo );
#ifdef POSTPONED
        MemFree((LPVOID) this->lpDDUmodeDrvInfo);
        MemFree((LPVOID) this->lpDDOptSurfaceInfo);
#endif

        #ifdef WIN95
            DD16_DoneDriver( this->hInstance );
            event16 = this->dwEvent16;
            eventDOSBox = this->dwDOSBoxEvent;
        #endif
        hinst = (HANDLE) ULongToPtr(this->hInstance);
        /*
         * The DDHAL_CALLBACKS structure tacked onto the end of the
         * global object is also automatically freed here because it
         * was allocated with the global object in a single malloc
         */
        MemFree( this );

        DPF( 4, "Driver is now FREE" );
    }

    if( lclrefcnt == 0 )
    {
        #ifdef WIN95
            /*
             * We are now finished with the local object's VXD handle. However
             * we don't discard it if we are running in DDHELP's context as, in
             * that case, the handle has been freed by the operating system
             * and closing it would be possitively dangerous.
             */
            if( ( GetCurrentProcessId() == GETCURRPID() ) && this )
            {
                DDASSERT( INVALID_HANDLE_VALUE != hthisvxd );
                CloseHandle( hthisvxd );
            }
        #endif /* WIN95 */

        /*
         * only free DC's if we aren't running on DDHELP's context
         */
        if( (GetCurrentProcessId() == GETCURRPID()) && ((HDC)this_lcl->hDC != NULL) )
        {
            LPDDRAWI_DIRECTDRAW_LCL ddlcl;


            // If there are other local objects in this process,
            // wait to delete the hdc until the last object is
            // deleted.

            for( ddlcl=lpDriverLocalList; ddlcl != NULL; ddlcl = ddlcl->lpLink)
            {
                if( (ddlcl != this_lcl) && (ddlcl->hDC == this_lcl->hDC) )
                    break;
            }
            if( ddlcl == NULL )
            {
                WORD fPriv;
                #ifdef WIN95
                    // We need to unmark it as private now so
                    // that the delete will succeed
                    fPriv = DD16_MakeObjectPrivate((HDC)this_lcl->hDC, FALSE);
                    DDASSERT(fPriv == TRUE);
                    /*
                     * The following assert will fail occasionally inside
                     * GetObjectType. I mean crash. Don't understand. We
                     * should put the assert back in for 5a and see if it blows
                     * on our machines.
                     */

                    //DDASSERT(GetObjectType((HDC)this_lcl->hDC) == OBJ_DC);
                #endif

                DeleteDC( (HDC)this_lcl->hDC );
            }
        }
#ifdef  WIN95
        if (NULL != this_lcl->SurfaceHandleList.dwList)
        {
            MemFree(this_lcl->SurfaceHandleList.dwList);
        }
#endif  //WIN95
        /*
         * delete this local object from the master list
         */
        RemoveLocalFromList( this_lcl );

        // Free the local object (finally)!
        MemFree( this_lcl );
    }

    #ifdef WIN95
        if( event16 != 0 )
        {
            closeVxDHandle( event16 );
        }
        if( eventDOSBox != 0 )
        {
            closeVxDHandle( eventDOSBox );
        }
    #endif

    /*
     * if interface is freed, we reset the vtbl and remove it
     * from the list of drivers.
     */
    if( intrefcnt == 0 )
    {
        /*
         * delete this driver object from the master list
         */
        RemoveDriverFromList( this_int, gblrefcnt == 0 );

        /*
         * just in case someone comes back in with this pointer, set
         * an invalid vtbl.
         */
        this_int->lpVtbl = NULL;
        MemFree( this_int );
    }

    LEAVE_DDRAW();

#ifndef WINNT
    if( hinst != NULL )
    {
        HelperKillModeSetThread( (DWORD) hinst );
        HelperKillDOSBoxThread( (DWORD) hinst );
    }
#endif //!WINNT

    HIDESHOW_IME();     //Show/hide the IME OUTSIDE of the ddraw critsect.

    return intrefcnt;

} /* DD_Release */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddheap.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheap.c
 *  Content:    Top-level heap routines.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-dec-94  craige  initial implementation
 *   06-jan-95  craige  integrated into DDRAW
 *   20-mar-95  craige  prepare for rectangular memory manager
 *   27-mar-95  craige  linear or rectangular vidmem
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  fill in free video memory
 *   15-may-95  craige  made separate VMEM struct for rect & linear
 *   10-jun-95  craige  exported fns
 *   02-jul-95  craige  fail if VidMemInit if linear or rect. fail;
 *                      removed linFindMemBlock
 *   17-jul-95  craige  added VidMemLargestFree
 *   01-dec-95  colinmc added VidMemAmountAllocated
 *   11-dec-95  kylej   added VidMemGetRectStride
 *   05-jul-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   03-Feb-98  DrewB   Made portable between user and kernel.
 *
 ***************************************************************************/

#include "ddrawpr.h"

/*
 * IsDifferentPixelFormat
 *
 * determine if two pixel formats are the same or not
 *
 * (CMcC) 12/14/95 Really useful - so no longer static
 *
 * This function really shouldn't be in a heap file but it's
 * needed by both the user and kernel code so this is a convenient
 * place to put it to have it shared.
 */
BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 )
{
    /*
     * same flags?
     */
    if( pdpf1->dwFlags != pdpf2->dwFlags )
    {
	VDPF(( 4, S, "Flags differ!" ));
	return TRUE;
    }

    /*
     * same bitcount for non-YUV surfaces?
     */
    if( !(pdpf1->dwFlags & (DDPF_YUV | DDPF_FOURCC)) )
    {
	if( pdpf1->dwRGBBitCount != pdpf2->dwRGBBitCount )
	{
	    VDPF(( 4, S, "RGB Bitcount differs!" ));
	    return TRUE;
	}
    }

    /*
     * same RGB properties?
     */
    if( pdpf1->dwFlags & DDPF_RGB )
    {
	if( pdpf1->dwRBitMask != pdpf2->dwRBitMask )
	{
	    VDPF(( 4, S, "RBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwGBitMask != pdpf2->dwGBitMask )
	{
	    VDPF(( 4, S, "GBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwBBitMask != pdpf2->dwBBitMask )
	{
	    VDPF(( 4, S, "BBitMask differs!" ));
	    return TRUE;
	}
        if( ( pdpf1->dwFlags & DDPF_ALPHAPIXELS ) &&
	    ( pdpf1->dwRGBAlphaBitMask != pdpf2->dwRGBAlphaBitMask )
          )
        {
            VDPF(( 4, S, "RGBAlphaBitMask differs!" ));
            return TRUE;
        }
    }

    /*
     * same YUV properties?
     */
    if( pdpf1->dwFlags & DDPF_YUV )
    {
	VDPF(( 5, S, "YUV???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
	if( pdpf1->dwYUVBitCount != pdpf2->dwYUVBitCount )
	{
	    return TRUE;
	}
	if( pdpf1->dwYBitMask != pdpf2->dwYBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwUBitMask != pdpf2->dwUBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwVBitMask != pdpf2->dwVBitMask )
	{
	    return TRUE;
	}
        if( ( pdpf1->dwFlags & DDPF_ALPHAPIXELS ) &&
	    (pdpf1->dwYUVAlphaBitMask != pdpf2->dwYUVAlphaBitMask )
          )
	{
	    return TRUE;
	}
    }

    /*
     * Possible to use FOURCCs w/o setting the DDPF_YUV flag
     * ScottM 7/11/96
     */
    else if( pdpf1->dwFlags & DDPF_FOURCC )
    {
	VDPF(( 5, S, "FOURCC???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
    }

    /*
     *	If Interleaved Z then check Z bit masks are the same
     */
    if( pdpf1->dwFlags & DDPF_ZPIXELS )
    {
	VDPF(( 5, S, "ZPIXELS???" ));
	if( pdpf1->dwRGBZBitMask != pdpf2->dwRGBZBitMask )
	    return TRUE;
    }

    return FALSE;

} /* IsDifferentPixelFormat */

/*
 * VidMemInit - initialize video memory manager heap
 */
LPVMEMHEAP WINAPI VidMemInit(
		DWORD   flags,
		FLATPTR start,
		FLATPTR width_or_end,
		DWORD   height,
		DWORD   pitch )
{
    LPVMEMHEAP  pvmh;

    pvmh = (LPVMEMHEAP)MemAlloc( sizeof( VMEMHEAP ) );
    if( pvmh == NULL )
    {
	return NULL;
    }
    pvmh->dwFlags = flags;
    ZeroMemory( & pvmh->Alignment.ddsCaps, sizeof(pvmh->Alignment.ddsCaps) );

    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	if( !linVidMemInit( pvmh, start, width_or_end ) )
	{
	    MemFree( pvmh );
	    return NULL;
	}
    }
    else
    {
	if( !rectVidMemInit( pvmh, start, (DWORD) width_or_end, height,
                             pitch ) )
	{
	    MemFree( pvmh );
	    return NULL;
	}
    }
    return pvmh;

} /* VidMemInit */

/*
 * VidMemFini - done with video memory manager
 */
void WINAPI VidMemFini( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	linVidMemFini( pvmh );
    }
    else
    {
	rectVidMemFini( pvmh );
    }

} /* VidMemFini */

/*
 * InternalVidMemAlloc - alloc some flat video memory and give us back the size
 * we allocated
 */
FLATPTR WINAPI InternalVidMemAlloc( LPVMEMHEAP pvmh, DWORD x, DWORD y,
                                    LPDWORD lpdwSize,
                                    LPSURFACEALIGNMENT lpAlignment,
                                    LPLONG lpNewPitch )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAlloc( pvmh, x, y, lpdwSize, lpAlignment, lpNewPitch );
    }
    else
    {
	FLATPTR lp = rectVidMemAlloc( pvmh, x, y, lpdwSize, lpAlignment );
        if (lp && lpNewPitch )
        {
            *lpNewPitch = (LONG) pvmh->stride;
        }
        return lp;
    }
    return (FLATPTR) NULL;

} /* InternalVidMemAlloc */

/*
 * VidMemAlloc - alloc some flat video memory
 */
FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD x, DWORD y )
{
    DWORD dwSize;

    /*
     * We are not interested in the size here.
     */
    return InternalVidMemAlloc( pvmh, x, y, &dwSize , NULL , NULL );
} /* VidMemAlloc */

/*
 * VidMemFree = free some flat video memory
 */
void WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	linVidMemFree( pvmh, ptr );
    }
    else
    {
	rectVidMemFree( pvmh, ptr );
    }

} /* VidMemFree */

/*
 * VidMemAmountAllocated
 */
DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAmountAllocated( pvmh );
    }
    else
    {
	return rectVidMemAmountAllocated( pvmh );
    }
 
} /* VidMemAmountAllocated */

/*
 * VidMemAmountFree
 */
DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAmountFree( pvmh );
    }
    else
    {
	return rectVidMemAmountFree( pvmh );
    }
 
} /* VidMemAmountFree */

/*
 * VidMemLargestFree
 */
DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemLargestFree( pvmh );
    }
    else
    {
	return 0;
    }

} /* VidMemLargestFree */

/*
 * HeapVidMemInit
 *
 * Top level heap initialization code which handles AGP stuff.
 */
LPVMEMHEAP WINAPI HeapVidMemInit( LPVIDMEM lpVidMem,
		                  DWORD    pitch,
		                  HANDLE   hdev,
                                  LPHEAPALIGNMENT pgad)
{
    DWORD         dwSize;
    FLATPTR       fpLinStart;
    LARGE_INTEGER liDevStart;
    PVOID         pvReservation;

    DDASSERT( NULL != lpVidMem );

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        BOOL    fIsUC;
        BOOL    fIsWC;
        DWORD   dwSizeReserved = 0;

        /*
         * Its a non-local heap so the first thing we need to do
         * is to reserved the heap address range.
         */

        /*
         * Compute the size of the heap.
         */
        if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
        {
            dwSize = (DWORD)(lpVidMem->fpEnd - lpVidMem->fpStart) + 1UL;
            if (dwSize & 1)
            {
                DPF_ERR("Driver error: fpEnd of non-local heap should be inclusive");
            }
        }
        else
        {
            DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
            dwSize = (pitch * lpVidMem->dwHeight);
        }
        DDASSERT( 0UL != dwSize );

        if( lpVidMem->dwFlags & VIDMEM_ISWC )
        {
            fIsUC = FALSE;
            fIsWC = TRUE;
        }
        else
        {
            fIsUC = TRUE;
            fIsWC = FALSE;
        }

        if( !(dwSizeReserved = AGPReserve( hdev, dwSize, fIsUC, fIsWC,
                                           &fpLinStart, &liDevStart,
                                           &pvReservation )) )
        {
            VDPF(( 0, V, "Could not reserve a GART address range for a "
                   "linear heap of size 0x%08x", dwSize ));
            return 0UL;
        }
        else
        {
            VDPF((4,V, "Allocated a GART address range starting at "
                  "0x%08x (linear) 0x%08x:0x%08x (physical) of size %d",
                  fpLinStart, liDevStart.HighPart, liDevStart.LowPart,
                  dwSizeReserved ));
        }

        if (dwSizeReserved != dwSize)
        {
            VDPF((1,V,"WARNING! This system required that the full "
                  "nonlocal aperture could not be reserved!"));
            VDPF((1,V,"         Requested aperture:%08x, "
                  "Reserved aperture:%08x", dwSize, dwSizeReserved));
        }

        /*
         * Update the heap for the new start address
         * (and end address for a linear heap).
         */
        lpVidMem->fpStart = fpLinStart;
        if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
        {
            lpVidMem->fpEnd = ( fpLinStart + dwSizeReserved ) - 1UL;
        }
        else
        {
            DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
            DDASSERT( pitch );
            lpVidMem->dwHeight = dwSizeReserved / pitch;
        }
    }

    if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
    {
	VDPF(( 4,V, "VidMemInit: Linear:      fpStart = 0x%08x fpEnd = 0x%08x",
	     lpVidMem->fpStart, lpVidMem->fpEnd ));
	lpVidMem->lpHeap = VidMemInit( VMEMHEAP_LINEAR, lpVidMem->fpStart,
                                       lpVidMem->fpEnd, 0, 0 );
    }
    else
    {
	VDPF(( 4,V, "VidMemInit: Rectangular: fpStart = 0x%08x "
               "dwWidth = %ld dwHeight = %ld, pitch = %ld",
	     lpVidMem->fpStart, lpVidMem->dwWidth, lpVidMem->dwHeight,
               pitch  ));
	lpVidMem->lpHeap = VidMemInit( VMEMHEAP_RECTANGULAR, lpVidMem->fpStart,
				       lpVidMem->dwWidth, lpVidMem->dwHeight,
                                       pitch );
    }

    /*
     * Modify the caps and alt-caps so that you don't allocate local
     * video memory surfaces out of AGP memory and vice-verse.
     */
    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
	/*
	 * Its an AGP heap. So don't let explict LOCAL video memory
	 * be allocated out of this heap.
	 */
	lpVidMem->ddsCaps.dwCaps    |= DDSCAPS_LOCALVIDMEM;
	lpVidMem->ddsCapsAlt.dwCaps |= DDSCAPS_LOCALVIDMEM;
    }
    else
    {
	/*
	 * Its a local video memory heap. So don't let explicity NON-LOCAL
	 * video memory be allocated out of this heap.
	 */
	lpVidMem->ddsCaps.dwCaps    |= DDSCAPS_NONLOCALVIDMEM;
	lpVidMem->ddsCapsAlt.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
    }

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        if (lpVidMem->lpHeap != NULL)
        {
            /*
             * We start out with no committed memory.
             */
            lpVidMem->lpHeap->fpGARTLin      = fpLinStart;
            // Fill in partial physical address for Win9x.
            lpVidMem->lpHeap->fpGARTDev      = liDevStart.LowPart;
            // Fill in complete physical address for NT.
            lpVidMem->lpHeap->liPhysAGPBase  = liDevStart;
            lpVidMem->lpHeap->pvPhysRsrv     = pvReservation;
            lpVidMem->lpHeap->dwCommitedSize = 0UL;
        }
        else if (pvReservation != NULL)
        {
            AGPFree( hdev, pvReservation );
        }
    }

    /*
     * Copy any extended alignment data into the private heap structure
     */
    if ( lpVidMem->lpHeap )
    {
        if ( pgad )
        {
            lpVidMem->lpHeap->dwFlags |= VMEMHEAP_ALIGNMENT;
            lpVidMem->lpHeap->Alignment = *pgad;
            VDPF((4,V,"Extended alignment turned on for this heap."));
            VDPF((4,V,"Alignments are turned on for:"));
            VDPF((4,V,"  %08X",pgad->ddsCaps));
        }
        else
        {
            /*
             * This means the allocation routines will do no alignment modifications
             */
            VDPF((4,V,"Extended alignment turned OFF for this heap."));
            lpVidMem->lpHeap->dwFlags &= ~VMEMHEAP_ALIGNMENT;
        }
    }

    return lpVidMem->lpHeap;
} /* HeapVidMemInit */

/*
 * HeapVidMemFini
 *
 * Top level heap release code. Handle AGP stuff
 */
void WINAPI HeapVidMemFini( LPVIDMEM lpVidMem, HANDLE hdev )
{
    DWORD dwCommittedSize = 0UL;
    PVOID pvReservation;

    /*
     * Remember how much memory we committed to the AGP heap.
     */
    DDASSERT( NULL != lpVidMem->lpHeap );
    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        dwCommittedSize = lpVidMem->lpHeap->dwCommitedSize;
        pvReservation = lpVidMem->lpHeap->pvPhysRsrv;
    }

    /*
     * Free the memory manager
     */
    VidMemFini( lpVidMem->lpHeap );
    lpVidMem->lpHeap = NULL;

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        BOOL fSuccess;
        
        /*
         * If this is a non-local (AGP) heap then decommit and
         * free the GART memory now.
         */
        if( 0UL != dwCommittedSize )
        {
            /*
             * Only decommit if we actually bothered to commit something
             * in the first place.
             */
            fSuccess = AGPDecommitAll( hdev, pvReservation, dwCommittedSize );
            /*
             * Should never fail and not much we can do if it does apart
             * from assert that something bad is happening.
             */
            DDASSERT( fSuccess );
        }

        fSuccess = AGPFree( hdev, pvReservation );
        /*
         * Again this should only fail if the OS is in an unstable state
         * or if I have messed up (sadly the later is all too likely)
         * so assert.
         */
        DDASSERT( fSuccess );
    }   
} /* HeapVidMemFini */

/*
 * This is an external entry point which can be used by drivers to allocate 
 * aligned surfaces.
 */
FLATPTR WINAPI HeapVidMemAllocAligned( 
                LPVIDMEM lpVidMem,
                DWORD dwWidth, 
                DWORD dwHeight, 
                LPSURFACEALIGNMENT lpAlignment , 
                LPLONG lpNewPitch )
{
    HANDLE  hdev;
    FLATPTR ptr;
    DWORD   dwSize;

    if ( lpVidMem == NULL ||
         lpVidMem->lpHeap == NULL ||
         (lpVidMem->dwFlags & VIDMEM_HEAPDISABLED) )
    {
	return (FLATPTR) NULL;
    }

    /*
     * As we may need to commit AGP memory we need a device handle
     * to communicate with the AGP controller. Rather than hunting
     * through the driver object list hoping we will find a
     * local object for this process we just create a handle
     * and discard it after the allocation. This should not be
     * performance critical code to start with.
     */
    hdev = OsGetAGPDeviceHandle(lpVidMem->lpHeap);
    if (hdev == NULL)
    {
        return 0;
    }

    /* Pass NULL Alignment and new pitch pointer */
    ptr = HeapVidMemAlloc( lpVidMem, dwWidth, dwHeight,
                           hdev, lpAlignment, lpNewPitch, &dwSize );

    OsCloseAGPDeviceHandle( hdev );

    return ptr; 
}

/*
 * HeapVidMemAlloc
 *
 * Top level video memory allocation function. Handles AGP stuff
 */
FLATPTR WINAPI HeapVidMemAlloc( LPVIDMEM lpVidMem, DWORD x, DWORD y,
                                HANDLE hdev, LPSURFACEALIGNMENT lpAlignment,
                                LPLONG lpNewPitch, LPDWORD pdwSize )
{
    FLATPTR fpMem;
    DWORD   dwSize;

    DDASSERT( NULL != lpVidMem );
    DDASSERT( NULL != lpVidMem->lpHeap );

    fpMem = InternalVidMemAlloc( lpVidMem->lpHeap, x, y, &dwSize,
                                 lpAlignment, lpNewPitch );
    if( 0UL == fpMem )
    {
	return fpMem;
    }

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        DWORD dwCommittedSize;
        /*
         * If this is a non-local heap then we may not have actually
         * committed the memory that has just been allocated. We can
         * determine this by seeing if the highest address so far
         * committed is less than the last address in the surface.
         */
        dwCommittedSize = lpVidMem->lpHeap->dwCommitedSize;
        if( (fpMem + dwSize) > (lpVidMem->fpStart + dwCommittedSize) )
        {
            DWORD dwSizeToCommit;
            BOOL  fSuccess;

            /*
             * We have not yet committed sufficient memory from this heap for
             * this surface so commit now. We don't want to recommit for every
             * surface creation so we have a minimum commit size
             * (dwAGPPolicyCommitDelta). We also need to ensure that by forcing
             * the granularity we don't go over the total size of the heap. So
             * clamp to that also.
             */
            dwSizeToCommit = (DWORD)((fpMem + dwSize) -
                                     (lpVidMem->fpStart + dwCommittedSize));
            if( dwSizeToCommit < dwAGPPolicyCommitDelta )
                dwSizeToCommit = min(dwAGPPolicyCommitDelta,
                                     lpVidMem->lpHeap->dwTotalSize -
                                     dwCommittedSize);

            /*
             * Okay, we have the offset and the size we need to commit. So ask
             * the OS to commit memory to that portion of this previously
             * reserved GART range.
             *
             * NOTE: We start commiting from the start of the currently
             * uncommitted area.
             */
            fSuccess = AGPCommit( hdev, lpVidMem->lpHeap->pvPhysRsrv,
                                  dwCommittedSize, dwSizeToCommit );
            if( !fSuccess )
            {
                /*
                 * Couldn't commit. Must be out of memory.
                 * Put the allocated memory back and fail.
                 */
                VidMemFree( lpVidMem->lpHeap, fpMem );
                return (FLATPTR) NULL;
            }
            lpVidMem->lpHeap->dwCommitedSize += dwSizeToCommit;
        }
    }

    if (pdwSize != NULL)
    {
        *pdwSize = dwSize;
    }
    
    return fpMem;
} /* HeapVidMemAlloc */

/*
 * SurfaceCapsToAlignment
 *
 * Return a pointer to the appropriate alignment element in a VMEMHEAP
 * structure given surface caps.
 *
 */
LPSURFACEALIGNMENT SurfaceCapsToAlignment(
    LPVIDMEM			lpVidmem ,
    LPDDRAWI_DDRAWSURFACE_LCL	lpSurfaceLcl,
    LPVIDMEMINFO                lpVidMemInfo)
{
    LPVMEMHEAP			lpHeap;
    LPDDSCAPS			lpCaps;
    LPDDRAWI_DDRAWSURFACE_GBL	lpSurfaceGbl;

    DDASSERT( lpVidmem );
    DDASSERT( lpSurfaceLcl );
    DDASSERT( lpVidMemInfo );
    DDASSERT( lpVidmem->lpHeap );

    if ( !lpVidmem->lpHeap )
        return NULL;

    lpCaps = &lpSurfaceLcl->ddsCaps;
    lpHeap = lpVidmem->lpHeap;
    lpSurfaceGbl = lpSurfaceLcl->lpGbl;

    if ( (lpHeap->dwFlags & VMEMHEAP_ALIGNMENT) == 0 )
        return NULL;

    if ( lpCaps->dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            VDPF((4,V,"Aligning surface as execute buffer"));
            return & lpHeap->Alignment.ExecuteBuffer;
        }
        /*
         * If the surface is an execute buffer, then no other
         * alignment can apply
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_OVERLAY )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_OVERLAY )
        {
            VDPF((4,V,"Aligning surface as overlay"));
            return & lpHeap->Alignment.Overlay;
        }
        /*
         * If the surface is an overlay, then no other alignment can apply
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_TEXTURE )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_TEXTURE )
        {
            VDPF((4,V,"Aligning surface as texture"));
            return & lpHeap->Alignment.Texture;
        }
        /*
         * If it's a texture, it can't be an offscreen or any of the others
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_ZBUFFER )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
        {
            VDPF((4,V,"Aligning surface as Z buffer"));
            return & lpHeap->Alignment.ZBuffer;
        }
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_ALPHA )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_ALPHA )
        {
            VDPF((4,V,"Aligning surface as alpha buffer"));
            return & lpHeap->Alignment.AlphaBuffer;
        }
        return NULL;
    }

    /*
     * We need to give a surface which may potentially become a back buffer
     * the alignment which is reserved for potentially visible back buffers.
     * This includes any surface which has made it through the above checks
     * and has the same dimensions as the primary.
     * Note we check only the dimensions of the primary. There's an outside
     * chance that an app could create its back buffer before it creates
     * the primary
     */
    do
    {
	if ( lpSurfaceLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	{
	    if (IsDifferentPixelFormat( &lpVidMemInfo->ddpfDisplay,
                                        &lpSurfaceGbl->ddpfSurface ))
	    {
		/*
		 * Different pixel format from primary means this surface
                 * cannot be part of primary chain
		 */
		break;
	    }

	}

	if ( (DWORD)lpSurfaceGbl->wWidth != lpVidMemInfo->dwDisplayWidth )
	    break;

	if ( (DWORD)lpSurfaceGbl->wHeight != lpVidMemInfo->dwDisplayHeight )
	    break;


	/*
	 * This surface could potentially be part of primary chain.
         * It has the same
	 * pixel format as the primary and the same dimensions.
	 */
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_FLIP )
        {
            VDPF((4,V,"Aligning surface as potential primary surface"));
            return & lpHeap->Alignment.FlipTarget;
        }

	/*
	 * Drop through and check for offscreen if driver specified no
         * part-of-primary-chain alignment
	 */
	break;
    } while (0);

    if ( lpCaps->dwCaps & DDSCAPS_OFFSCREENPLAIN )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN )
        {
            VDPF((4,V,"Aligning surface as offscreen plain"));
            return & lpHeap->Alignment.Offscreen;
        }
    }

    VDPF((4,V,"No extended alignment for surface"));
    return NULL;
}

/*
 * DdHeapAlloc
 *
 * Search all heaps for one that has space and the appropriate
 * caps for the requested surface type and size.
 *
 * We AND the caps bits required and the caps bits not allowed
 * by the video memory.   If the result is zero, it is OK.
 *
 * This is called in 2 passes.   Pass1 is the preferred memory state,
 * pass2 is the "oh no no memory" state.
 *
 * On pass1, we use ddsCaps in the VIDMEM struct.
 * On pass2, we use ddsCapsAlt in the VIDMEM struct.
 *
 */
FLATPTR DdHeapAlloc( DWORD dwNumHeaps,
                     LPVIDMEM pvmHeaps,
                     HANDLE hdev,
                     LPVIDMEMINFO lpVidMemInfo,
                     DWORD dwWidth,
                     DWORD dwHeight,
                     LPDDRAWI_DDRAWSURFACE_LCL lpSurfaceLcl,
                     DWORD dwFlags,
                     LPVIDMEM *ppvmHeap,
                     LPLONG plNewPitch,
                     LPDWORD pdwNewCaps,
                     LPDWORD pdwSize)
{
    LPVIDMEM	pvm;
    DWORD	vm_caps;
    int		i;
    FLATPTR	pvidmem;
    HANDLE      hvxd;
    LPDDSCAPS	lpCaps;

    LPDDSCAPSEX lpExtendedRestrictions;
    LPDDSCAPSEX lpExtendedCaps;

    DDASSERT( NULL != pdwNewCaps );
    DDASSERT( NULL != lpSurfaceLcl );

    lpCaps = &lpSurfaceLcl->ddsCaps;
    lpExtendedCaps = &lpSurfaceLcl->lpSurfMore->ddsCapsEx;

    for( i = 0 ; i < (int)dwNumHeaps ; i++ )
    {
	pvm = &pvmHeaps[i];

        // Skip disabled heaps.
        if (pvm->dwFlags & VIDMEM_HEAPDISABLED)
        {
            continue;
        }
        
        /*
         * Skip rectangular heaps if we were told to.
         */
        if (dwFlags & DDHA_SKIPRECTANGULARHEAPS)
        {
            if (pvm->dwFlags & VIDMEM_ISRECTANGULAR)
            {
                continue;
            }
        }

	/*
	 * If local or non-local video memory has been explicity
	 * specified then ignore heaps which don't match the required
	 * memory type.
	 */
	if( ( lpCaps->dwCaps & DDSCAPS_LOCALVIDMEM ) &&
            ( pvm->dwFlags & VIDMEM_ISNONLOCAL ) )
	{
	    VDPF(( 4, V, "Local video memory was requested but heap is "
                   "non local. Ignoring heap %d", i ));
	    continue;
	}

	if( ( lpCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM ) &&
            !( pvm->dwFlags & VIDMEM_ISNONLOCAL ) )
	{
	    VDPF(( 4, V, "Non-local video memory was requested but "
                   "heap is local. Ignoring heap %d", i ));
	    continue;
	}

	if( !( lpCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM ) &&
	     ( pvm->dwFlags & VIDMEM_ISNONLOCAL ) &&
             ( dwFlags & DDHA_ALLOWNONLOCALMEMORY ) )
	{
            /*
             * We can allow textures to fail over to DMA model cards
             * if the card exposes an appropriate heap. This won't
             * affect cards which can't texture from nonlocal, because
             * they won't expose such a heap. This mod doesn't affect
             * execute model because all surfaces fail over to nonlocal
             * for them.
             * Note that we should only fail over to nonlocal if the
             * surface wasn't explicitly requested in local. There is a
             * clause a few lines up which guarantees this.
             */
            if ( !(lpCaps->dwCaps & DDSCAPS_TEXTURE) )
            {
	        VDPF(( 4, V, "Non-local memory not explicitly requested "
                       "for non-texture surface. Ignoring non-local heap %d",
                       i ));
	        continue;
            }

            /*
             * If the device can't texture out of AGP, we need to fail this
             * heap, since the app is probably expecting to texture out of
             * this surface.
             */
            if ( !(dwFlags & DDHA_ALLOWNONLOCALTEXTURES) )
            {
                continue;
            }
	}

	if( dwFlags & DDHA_USEALTCAPS )
	{
	    vm_caps = pvm->ddsCapsAlt.dwCaps;
            lpExtendedRestrictions = &(pvm->lpHeap->ddsCapsExAlt);
	}
	else
	{
	    vm_caps = pvm->ddsCaps.dwCaps;
            lpExtendedRestrictions = &(pvm->lpHeap->ddsCapsEx);
	}
        
	if( ((lpCaps->dwCaps & vm_caps) == 0) &&
            ((lpExtendedRestrictions->dwCaps2 & lpExtendedCaps->dwCaps2) == 0) &&
            ((lpExtendedRestrictions->dwCaps3 & lpExtendedCaps->dwCaps3) == 0) &&
            ((lpExtendedRestrictions->dwCaps4 & lpExtendedCaps->dwCaps4) == 0))
	{
	    pvidmem = HeapVidMemAlloc(
		pvm,
                dwWidth,
		dwHeight,
		hdev,
		SurfaceCapsToAlignment(pvm, lpSurfaceLcl, lpVidMemInfo),
		plNewPitch,
                pdwSize);

	    if( pvidmem != (FLATPTR) NULL )
	    {
		*ppvmHeap = pvm;

		if( pvm->dwFlags & VIDMEM_ISNONLOCAL )
		    *pdwNewCaps |= DDSCAPS_NONLOCALVIDMEM;
		else
		    *pdwNewCaps |= DDSCAPS_LOCALVIDMEM;
		return pvidmem;
	    }
	}
    }
    return (FLATPTR) NULL;

} /* DdHeapAlloc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddkernel.c ===
/*==========================================================================
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddkernel.c
 *  Content: 	APIs for getting the kernel mode handles for
 *              DirectDraw and the surfaces
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   09-jan-97	smac	created
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
    #include "ddkmmini.h"
    #include "ddkmapi.h"
#else
    #include "minivdd.h"
    #include "ddkmmini.h"
    #include "ddkmapip.h"
#endif
#define DPF_MODNAME "DirectDrawVideoPort"

#define DISPLAY_STR     "display"

extern char g_szPrimaryDisplay[]; // usually \\.\Display1 on Win98

#if WIN95
/*
 * IsWindows98
 */
BOOL IsWindows98( VOID )
{
    OSVERSIONINFO osVer;

    osVer.dwOSVersionInfoSize = sizeof( osVer );
    osVer.dwMinorVersion = 0;
    GetVersionEx( &osVer );

    return( ( osVer.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ) &&
        ( osVer.dwMinorVersion > 0 ) );
}


/*
 * SyncKernelSurface
 *
 * Initializes the buffer with the kernel surface info and then gives
 * it to the HAL so they can make whatever modifications are neccesary
 * and to fill in the dwDriverReserved fields with their internal state
 * data.
 */
HRESULT SyncKernelSurface( LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
			   LPDDKMSURFACEINFO lpddkmSurfaceInfo )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    DDHAL_SYNCSURFACEDATA HALSurfaceData;
    LPDDHALKERNELCB_SYNCSURFACE pfn;
    LPDDPIXELFORMAT lpddpfFormat;
    DWORD rc;

    /*
     * Determine the default data the best that we can
     */
    memset( &HALSurfaceData, 0, sizeof( HALSurfaceData ) );
    HALSurfaceData.dwSize = sizeof( HALSurfaceData );
    HALSurfaceData.lpDD = lpSurface->lpSurfMore->lpDD_lcl;
    HALSurfaceData.lpDDSurface = lpSurface;
    HALSurfaceData.dwSurfaceOffset = 0;
    HALSurfaceData.fpLockPtr = lpSurface->lpGbl->fpVidMem;
    HALSurfaceData.lPitch = (DWORD) lpSurface->lpGbl->lPitch;
    HALSurfaceData.dwOverlayOffset = 0;
    if( lpSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
    {
    	HALSurfaceData.dwOverlaySrcWidth =
	    lpSurface->rcOverlaySrc.right -
	    lpSurface->rcOverlaySrc.left;
    	HALSurfaceData.dwOverlaySrcHeight =
	    lpSurface->rcOverlaySrc.bottom -
	    lpSurface->rcOverlaySrc.top;
    	HALSurfaceData.dwOverlayDestWidth =
	    lpSurface->rcOverlayDest.right -
	    lpSurface->rcOverlayDest.left;
    	HALSurfaceData.dwOverlayDestHeight =
	    lpSurface->rcOverlayDest.bottom -
	    lpSurface->rcOverlayDest.top;
    }
    else
    {
    	HALSurfaceData.dwOverlaySrcWidth = 0;
    	HALSurfaceData.dwOverlaySrcHeight = 0;
    	HALSurfaceData.dwOverlayDestWidth = 0;
    	HALSurfaceData.dwOverlayDestHeight = 0;
    }

    /*
     * Now call the HAL and have it fill in the rest of the values
     */
    pfn = lpSurface->lpSurfMore->lpDD_lcl->lpDDCB->HALDDKernel.SyncSurfaceData;
    if( pfn != NULL )
    {
	DOHALCALL( SyncSurfaceData, pfn, HALSurfaceData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != HALSurfaceData.ddRVal )
	{
	    return (HRESULT)rc;
	}
    }
    else
    {
    	return DDERR_UNSUPPORTED;
    }

    /*
     * Now put all of the data into a structure that the VDD can understand
     */
    lpddkmSurfaceInfo->ddsCaps = lpSurface->ddsCaps.dwCaps;
    lpddkmSurfaceInfo->dwSurfaceOffset = HALSurfaceData.dwSurfaceOffset;
    lpddkmSurfaceInfo->fpLockPtr = HALSurfaceData.fpLockPtr;
    lpddkmSurfaceInfo->dwWidth = (DWORD) lpSurface->lpGbl->wWidth;
    lpddkmSurfaceInfo->dwHeight = (DWORD) lpSurface->lpGbl->wHeight;
    lpddkmSurfaceInfo->lPitch = HALSurfaceData.lPitch;
    lpddkmSurfaceInfo->dwOverlayFlags = lpSurface->lpSurfMore->dwOverlayFlags;
    lpddkmSurfaceInfo->dwOverlayOffset = HALSurfaceData.dwOverlayOffset;
    lpddkmSurfaceInfo->dwOverlaySrcWidth = HALSurfaceData.dwOverlaySrcWidth;
    lpddkmSurfaceInfo->dwOverlaySrcHeight = HALSurfaceData.dwOverlaySrcHeight;
    lpddkmSurfaceInfo->dwOverlayDestWidth = HALSurfaceData.dwOverlayDestWidth;
    lpddkmSurfaceInfo->dwOverlayDestHeight = HALSurfaceData.dwOverlayDestHeight;
    lpddkmSurfaceInfo->dwDriverReserved1 = HALSurfaceData.dwDriverReserved1;
    lpddkmSurfaceInfo->dwDriverReserved2 = HALSurfaceData.dwDriverReserved2;
    lpddkmSurfaceInfo->dwDriverReserved3 = HALSurfaceData.dwDriverReserved3;
    if( lpSurface->lpSurfMore->lpVideoPort == NULL )
    {
    	lpddkmSurfaceInfo->dwVideoPortId = (DWORD)-1;
    }
    else
    {
    	lpddkmSurfaceInfo->dwVideoPortId =
	    lpSurface->lpSurfMore->lpVideoPort->ddvpDesc.dwVideoPortID;
    }
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurface->lpGbl );
    lpddkmSurfaceInfo->dwPhysicalPageTable = lpSurfGblMore->dwPhysicalPageTable;
    lpddkmSurfaceInfo->pPageTable = (DWORD)lpSurfGblMore->pPageTable;
    lpddkmSurfaceInfo->cPages = lpSurfGblMore->cPages;
    GET_PIXEL_FORMAT( lpSurface, lpSurface->lpGbl, lpddpfFormat );
    if( lpddpfFormat != NULL )
    {
	lpddkmSurfaceInfo->dwFormatFlags    = lpddpfFormat->dwFlags;
	lpddkmSurfaceInfo->dwFormatFourCC   = lpddpfFormat->dwFourCC;
	lpddkmSurfaceInfo->dwFormatBitCount = lpddpfFormat->dwRGBBitCount;
	lpddkmSurfaceInfo->dwRBitMask       = lpddpfFormat->dwRBitMask;
	lpddkmSurfaceInfo->dwGBitMask       = lpddpfFormat->dwGBitMask;
	lpddkmSurfaceInfo->dwBBitMask       = lpddpfFormat->dwBBitMask;
    }

    return DD_OK;
}


/*
 * SyncKernelVideoPort
 *
 * Initializes the buffer with the kernel video port info and then gives
 * it to the HAL so they can make whatever modifications are neccesary
 * and to fill in the dwDriverReserved fields with their internal state
 * data.
 */
HRESULT SyncKernelVideoPort( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort,
			     LPDDKMVIDEOPORTINFO lpddkmVideoPortInfo )
{
    LPDDHALKERNELCB_SYNCVIDEOPORT pfn;
    DDHAL_SYNCVIDEOPORTDATA HALVideoPortData;
    DWORD rc;

    /*
     * Determine the default data the best that we can
     */
    memset( &HALVideoPortData, 0, sizeof( HALVideoPortData ) );
    HALVideoPortData.dwSize = sizeof( HALVideoPortData );
    HALVideoPortData.lpDD = lpVideoPort->lpDD;
    HALVideoPortData.lpVideoPort = lpVideoPort;
    HALVideoPortData.dwOriginOffset = 0;
    if( lpVideoPort->ddvpInfo.dwVPFlags & DDVP_PRESCALE )
    {
    	HALVideoPortData.dwHeight = lpVideoPort->ddvpInfo.dwPrescaleHeight;
    }
    else if( lpVideoPort->ddvpInfo.dwVPFlags & DDVP_CROP )
    {
    	HALVideoPortData.dwHeight = lpVideoPort->ddvpInfo.rCrop.bottom -
    	    lpVideoPort->ddvpInfo.rCrop.top;
    }
    else
    {
    	HALVideoPortData.dwHeight = lpVideoPort->ddvpDesc.dwFieldHeight;
    }
    if( lpVideoPort->ddvpInfo.dwVPFlags & DDVP_INTERLEAVE )
    {
    	HALVideoPortData.dwHeight *= 2;
    }
    HALVideoPortData.dwVBIHeight = lpVideoPort->ddvpInfo.dwVBIHeight;

    /*
     * Now call the HAL and have it fill in the rest of the values
     */
    pfn = lpVideoPort->lpDD->lpDDCB->HALDDKernel.SyncVideoPortData;
    if( pfn != NULL )
    {
	DOHALCALL( SyncVideoPortData, pfn, HALVideoPortData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != HALVideoPortData.ddRVal )
	{
	    return (HRESULT)rc;
	}
    }
    else
    {
    	return DDERR_UNSUPPORTED;
    }

    /*
     * Now put all of the data into a structure that the VDD can understand
     */
    lpddkmVideoPortInfo->dwOriginOffset = HALVideoPortData.dwOriginOffset;
    lpddkmVideoPortInfo->dwHeight = HALVideoPortData.dwHeight;
    lpddkmVideoPortInfo->dwVBIHeight = HALVideoPortData.dwVBIHeight;
    lpddkmVideoPortInfo->dwDriverReserved1 = HALVideoPortData.dwDriverReserved1;
    lpddkmVideoPortInfo->dwDriverReserved2 = HALVideoPortData.dwDriverReserved2;
    lpddkmVideoPortInfo->dwDriverReserved3 = HALVideoPortData.dwDriverReserved3;

    return DD_OK;
}


/*
 * UpdateKernelSurface
 */
HRESULT UpdateKernelSurface( LPDDRAWI_DDRAWSURFACE_LCL lpSurface )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    HANDLE hDeviceHandle;
    DWORD ddRVal;

    if( !IsKernelInterfaceSupported( lpSurface->lpSurfMore->lpDD_lcl ) )
    {
	return DDERR_UNSUPPORTED;
    }

    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurface->lpGbl );
    if( lpSurfGblMore->hKernelSurface == 0 )
    {
	return DDERR_GENERIC;
    }
    else
    {
	DDKMSURFACEUPDATE ddkmSurfaceInfo;
	DWORD dwReturned;

        hDeviceHandle = GETDDVXDHANDLE( lpSurface->lpSurfMore->lpDD_lcl );
	if( INVALID_HANDLE_VALUE == hDeviceHandle )
	{
	    return DDERR_UNSUPPORTED;
	}

	/*
	 * Get/sync the surface info
	 */
	ddRVal = SyncKernelSurface( lpSurface, &(ddkmSurfaceInfo.si) );
	if( ddRVal != DD_OK )
	{
    	    DPF( 0, "Unable to sync surface data with HAL" );
	    return ddRVal;
	}

	/*
	 * Get the handle from the VDD
	 */
	ddkmSurfaceInfo.dwDirectDrawHandle =
	    lpSurface->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle;
	ddkmSurfaceInfo.dwSurfaceHandle =
	    lpSurfGblMore->hKernelSurface;
	ddRVal = (DWORD) DDERR_GENERIC;
    	DeviceIoControl( hDeviceHandle,
    	    DD_DXAPI_UPDATE_SURFACE_INFO,
	    &ddkmSurfaceInfo,
	    sizeof( ddkmSurfaceInfo ),
	    &ddRVal,
	    sizeof( ddRVal ),
	    &dwReturned,
	    NULL);
	if( ddRVal != DD_OK )
	{
    	    DPF( 0, "Unable to update the surface info" );
	    return DDERR_UNSUPPORTED;
	}
    }

    return DD_OK;
}


/*
 * GetKernelSurfaceState
 */
HRESULT GetKernelSurfaceState( LPDDRAWI_DDRAWSURFACE_LCL lpSurf, LPDWORD lpdwStateFlags )
{
    DDGETSURFACESTATEIN ddStateInput;
    DDGETSURFACESTATEOUT ddStateOutput;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    HANDLE hDeviceHandle;
    DWORD dwReturned;

    *lpdwStateFlags = 0;
    if( !IsKernelInterfaceSupported( lpSurf->lpSurfMore->lpDD_lcl ) )
    {
	return DDERR_UNSUPPORTED;
    }

    hDeviceHandle = GETDDVXDHANDLE( lpSurf->lpSurfMore->lpDD_lcl );
    if( INVALID_HANDLE_VALUE == hDeviceHandle )
    {
	return DDERR_UNSUPPORTED;
    }

    /*
     * Send the new info down to the VDD
     */
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurf->lpGbl );
    ddStateInput.hDirectDraw = (HANDLE)
	(lpSurf->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle);
    ddStateInput.hSurface = (HANDLE)
	(lpSurfGblMore->hKernelSurface);
    ddStateOutput.ddRVal = (DWORD) DDERR_GENERIC;
    DeviceIoControl( hDeviceHandle,
    	DD_DXAPI_PRIVATE_GET_SURFACE_STATE,
	&ddStateInput,
	sizeof( ddStateInput ),
	&ddStateOutput,
	sizeof( ddStateOutput ),
	&dwReturned,
	NULL);
    if( ddStateOutput.ddRVal != DD_OK )
    {
	DPF( 0, "Unable to get the surface state" );
	return DDERR_UNSUPPORTED;
    }
    *lpdwStateFlags = ddStateOutput.dwStateStatus;

    return DD_OK;
}

/*
 * SetKernelDOSBoxEvent
 */
HRESULT SetKernelDOSBoxEvent( LPDDRAWI_DIRECTDRAW_LCL lpDD )
{
    DDSETDOSBOXEVENT ddDOSBox;
    DWORD dwReturned;
    DWORD ddRVal;

    ddDOSBox.dwDirectDrawHandle = lpDD->lpGbl->hKernelHandle;
    ddDOSBox.dwDOSBoxEvent = lpDD->lpGbl->dwDOSBoxEvent;
    ddRVal = (DWORD) DDERR_GENERIC;
    DeviceIoControl( (HANDLE)lpDD->hDDVxd,
	DD_DXAPI_SET_DOS_BOX_EVENT,
	&ddDOSBox,
	sizeof( ddDOSBox ),
	&ddRVal,
	sizeof( ddRVal ),
	&dwReturned,
	NULL);

    return DD_OK;
}


/*
 * UpdateKernelVideoPort
 *
 * On NT, this same stuff is done in kernel mode as part of the
 * UpdateVideo call, so it doesn't have to do it again here.
 */
HRESULT UpdateKernelVideoPort( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    LPDDRAWI_DDRAWSURFACE_LCL lpSurf;
    DDKMVIDEOPORTINFO ddkmVideoPortInfo;
    HANDLE hDeviceHandle;
    DWORD dwReturned;
    DWORD ddRVal;
    DWORD dwIRQ;
    DWORD i;

    if( ( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps == NULL ) ||
    	( lpVideoPort->lpDD->lpGbl->hKernelHandle == (DWORD)NULL ) )
    {
	return DDERR_UNSUPPORTED;
    }

    hDeviceHandle = GETDDVXDHANDLE( lpVideoPort->lpDD );
    if( INVALID_HANDLE_VALUE == hDeviceHandle )
    {
	return DDERR_UNSUPPORTED;
    }

    /*
     * Start filling in the info
     */
    memset( &ddkmVideoPortInfo, 0, sizeof( DDKMVIDEOPORTINFO ) );
    ddkmVideoPortInfo.dwDirectDrawHandle =
	lpVideoPort->lpDD->lpGbl->hKernelHandle;
    ddkmVideoPortInfo.dwVideoPortId = lpVideoPort->ddvpDesc.dwVideoPortID;
    ddkmVideoPortInfo.dwVPFlags = lpVideoPort->ddvpInfo.dwVPFlags;
    ddkmVideoPortInfo.dwFlags = dwFlags;
    if( lpVideoPort->dwFlags & DDRAWIVPORT_ON )
    {
	ddkmVideoPortInfo.dwFlags |= DDKMVP_ON;
    }
    if( dwFlags != DDKMVP_RELEASE )
    {
	if( ( lpVideoPort->dwFlags & DDRAWIVPORT_SOFTWARE_AUTOFLIP ) &&
	    ( lpVideoPort->ddvpInfo.dwVPFlags & DDVP_AUTOFLIP ) )
	{
	    if( lpVideoPort->dwNumAutoflip > 0 )
	    {
		ddkmVideoPortInfo.dwFlags |= DDKMVP_AUTOFLIP;
	    }
	    if( lpVideoPort->dwNumVBIAutoflip > 0 )
	    {
		ddkmVideoPortInfo.dwFlags |= DDKMVP_AUTOFLIP_VBI;
	    }
	}
	ddkmVideoPortInfo.dwNumAutoflipping = lpVideoPort->dwNumAutoflip;
	ddkmVideoPortInfo.dwNumVBIAutoflipping = lpVideoPort->dwNumVBIAutoflip;

	/*
	 * Fill in surface handles for the regular video
	 */
	if( lpVideoPort->lpSurface != NULL )
	{
	    if( lpVideoPort->dwNumAutoflip > 0 )
	    {
		for( i = 0; i < lpVideoPort->dwNumAutoflip; i++ )
		{
		    lpSurf = lpVideoPort->lpFlipInts[i]->lpLcl;
		    DDASSERT( lpSurf != NULL );
		    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurf->lpGbl );
		    ddkmVideoPortInfo.dwSurfaceHandle[i] =
			lpSurfGblMore->hKernelSurface;
		}
	    }
	    else
	    {
	    	lpSurf = lpVideoPort->lpSurface->lpLcl;
	    	lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurf->lpGbl );
	    	ddkmVideoPortInfo.dwSurfaceHandle[0] =
		    lpSurfGblMore->hKernelSurface;
	    }
	}

	/*
	 * Fill in surface handles for the VBI data
	 */
	if( lpVideoPort->lpVBISurface != NULL )
	{
	    if( lpVideoPort->dwNumVBIAutoflip > 0 )
	    {
		DWORD dwCnt = 0;

		for( i = lpVideoPort->dwNumAutoflip;
		    i < (lpVideoPort->dwNumVBIAutoflip + lpVideoPort->dwNumAutoflip);
		    i++ )
		{
		    lpSurf = lpVideoPort->lpFlipInts[i]->lpLcl;
		    DDASSERT( lpSurf != NULL );
		    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurf->lpGbl );
		    ddkmVideoPortInfo.dwVBISurfaceHandle[dwCnt++] =
		        lpSurfGblMore->hKernelSurface;
		}
	    }
	    else
	    {
	    	lpSurf = lpVideoPort->lpVBISurface->lpLcl;
	    	lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurf->lpGbl );
	    	ddkmVideoPortInfo.dwVBISurfaceHandle[0] =
		    lpSurfGblMore->hKernelSurface;
	    }
	}

	/*
	 * Sync with the HAL
	 */
	if( dwFlags == DDKMVP_UPDATE )
	{
	    /*
	     * Get/sync the surface info
	     */
	    ddRVal = SyncKernelVideoPort( lpVideoPort, &ddkmVideoPortInfo );
	    if( ddRVal != DD_OK )
	    {
	    	DPF( 0, "Unable to sync video port data with HAL" );
	    	return ddRVal;
	    }
	}

	/*
	 * Does this support an IRQ?
	 */
	dwIRQ = DDIRQ_VPORT0_VSYNC;
	dwIRQ <<= ( lpVideoPort->ddvpDesc.dwVideoPortID * 2 );
    	if( !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwIRQCaps &
	    dwIRQ ) )
	{
	    ddkmVideoPortInfo.dwFlags |= DDKMVP_NOIRQ;
	}
    	if( !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwCaps &
	    DDKERNELCAPS_SKIPFIELDS ) )
	{
	    ddkmVideoPortInfo.dwFlags |= DDKMVP_NOSKIP;
	}
    }

    /*
     * Notify DDVXD if the even field is shifted down by one line
     * due to half lines.  This is really only an issue when capturing.
     */
    if( lpVideoPort->ddvpDesc.VideoPortType.dwFlags & DDVPCONNECT_HALFLINE )
    {
	ddkmVideoPortInfo.dwFlags |= DDKMVP_HALFLINES;
    }

    /*
     * Send the new info down to the VDD
     */
    ddRVal = (DWORD) DDERR_GENERIC;
    DeviceIoControl( hDeviceHandle,
    	DD_DXAPI_UPDATE_VP_INFO,
	&ddkmVideoPortInfo,
	sizeof( ddkmVideoPortInfo ),
	&ddRVal,
	sizeof( ddRVal ),
	&dwReturned,
	NULL);
    if( ddRVal != DD_OK )
    {
	DPF( 0, "Unable to update the video port info" );
	return DDERR_UNSUPPORTED;
    }

    return DD_OK;
}

/*
 * EnableAutoflip
 */
VOID EnableAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, BOOL bEnable )
{
    DDENABLEAUTOFLIP ddkmEnableAutoflip;
    HANDLE hDeviceHandle;
    DWORD dwReturned;
    DWORD ddRVal;

    if( lpVideoPort == NULL )
    {
	return;
    }

    #ifdef WIN95
        if( !IsWindows98() )
        {
            return;
        }
    #endif

    hDeviceHandle = GETDDVXDHANDLE( lpVideoPort->lpDD );
    if( INVALID_HANDLE_VALUE == hDeviceHandle )
    {
	return;
    }

    /*
     * Start filling in the info
     */
    memset( &ddkmEnableAutoflip, 0, sizeof( DDENABLEAUTOFLIP ) );
    ddkmEnableAutoflip.dwDirectDrawHandle =
	lpVideoPort->lpDD->lpGbl->hKernelHandle;
    ddkmEnableAutoflip.dwVideoPortId = lpVideoPort->ddvpDesc.dwVideoPortID;
    ddkmEnableAutoflip.bEnableAutoflip = bEnable;
    ddRVal = (DWORD) DDERR_GENERIC;
    DeviceIoControl( hDeviceHandle,
    	DD_DXAPI_ENABLE_AUTOFLIP,
	&ddkmEnableAutoflip,
	sizeof( ddkmEnableAutoflip ),
	&ddRVal,
	sizeof( ddRVal ),
	&dwReturned,
	NULL);
}


/*
 * MungeAutoflipCaps
 */
void MungeAutoflipCaps( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPDDVIDEOPORTCAPS lpVideoPortCaps;
    DWORD i;

    if( ( pdrv->hKernelHandle != (DWORD) NULL ) &&
	( pdrv->lpDDVideoPortCaps != NULL ) &&
	( pdrv->lpDDKernelCaps != NULL ) &&
    	( pdrv->lpDDKernelCaps->dwCaps & DDKERNELCAPS_AUTOFLIP ) )
    {
	/*
	 * Software autoflipping is supported, so set the autoflip
	 * capabilities to the max.
	 */
	for( i = 0; i < pdrv->ddCaps.dwMaxVideoPorts; i++ )
	{
    	    lpVideoPortCaps = &(pdrv->lpDDVideoPortCaps[i]);
    	    if( ( lpVideoPortCaps != NULL ) &&
    	    	VALID_DDVIDEOPORTCAPS_PTR( lpVideoPortCaps ) )
    	    {
    	    	lpVideoPortCaps->dwCaps |= DDVPCAPS_AUTOFLIP;
    	    	lpVideoPortCaps->dwNumAutoFlipSurfaces = MAX_AUTOFLIP;
		if( lpVideoPortCaps->dwCaps & DDVPCAPS_VBISURFACE )
		{
    	    	    lpVideoPortCaps->dwNumVBIAutoFlipSurfaces = MAX_AUTOFLIP;
    	    	}
	    }
	}
    }
}
#endif


/*
 * InternalReleaseKernelHandle
 */
HRESULT InternalReleaseKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, BOOL bLosingSurface )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    HANDLE hDeviceHandle;
    DWORD dwReturned;
    DWORD ddRVal;
    #ifdef WIN95
    DDRELEASEHANDLE ddRelease;
    #endif

    #ifdef WIN95
        if( lpSurface->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle == (DWORD) NULL )
        {
	    return DD_OK;
        }

        hDeviceHandle = GETDDVXDHANDLE( lpSurface->lpSurfMore->lpDD_lcl );
        if( INVALID_HANDLE_VALUE == hDeviceHandle )
        {
	    return DDERR_UNSUPPORTED;
        }
    #endif

    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurface->lpGbl );
    if( lpSurfGblMore->hKernelSurface == 0 )
    {
	return DD_OK;
    }

    /*
     * Check the ref count to make sure it's time to release this surface
     */
    if( bLosingSurface )
    {
	lpSurfGblMore->dwKernelRefCnt = 0;
    }
    else if( lpSurfGblMore->dwKernelRefCnt > 0 )
    {
	if( --(lpSurfGblMore->dwKernelRefCnt) > 0 )
	{
	    return DD_OK;
	}
    }

    #if WIN95

	/*
	 * Tell the VDD to release the surface
	 */
	ddRelease.dwDirectDrawHandle =
	    lpSurface->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle;
	ddRelease.hSurface = lpSurfGblMore->hKernelSurface;
	ddRVal = (DWORD) DDERR_GENERIC;

    	DeviceIoControl( hDeviceHandle,
    	    DD_DXAPI_RELEASE_SURFACE_HANDLE,
	    &ddRelease,
	    sizeof( ddRelease ),
	    &ddRVal,
	    sizeof( ddRVal ),
	    &dwReturned,
	    NULL);
	if( ddRVal != DD_OK )
	{
	    DPF_ERR( "Unable to release the surface handle in the VDD" );
	    return (HRESULT)ddRVal;
	}

    #else
	{
    	    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl = lpSurface->lpSurfMore->lpDD_lcl;
    	    LPDDRAWI_DIRECTDRAW_GBL pdrv = pdrv_lcl->lpGbl;

	    // Update DDraw handle in driver GBL object before calling DdGetDxHandle.
	    pdrv->hDD = pdrv_lcl->hDD;
	    DdGetDxHandle( NULL, lpSurface, TRUE );
	}

    #endif

    lpSurfGblMore->hKernelSurface = 0;

    return DD_OK;
}


/*
 * InternalCreateKernelSurfaceHandle
 */
HRESULT InternalCreateKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface,
					   PULONG_PTR lpHandle )
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    HANDLE hDeviceHandle;
    DWORD ddRVal;

    *lpHandle = 0;
    if( !IsKernelInterfaceSupported( lpSurface->lpSurfMore->lpDD_lcl ) )
    {
	return DDERR_UNSUPPORTED;
    }

    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurface->lpGbl );
    if( lpSurfGblMore->hKernelSurface != 0 )
    {
	*lpHandle = lpSurfGblMore->hKernelSurface;
	lpSurfGblMore->dwKernelRefCnt++;
    }
    else
    {
	#if WIN95
	    DDKMSURFACEINFO ddkmSurfaceInfo;
	    DDGETSURFACEHANDLE ddkmGetSurfaceHandle;
	    DWORD dwReturned;

            hDeviceHandle = GETDDVXDHANDLE( lpSurface->lpSurfMore->lpDD_lcl );
	    if( INVALID_HANDLE_VALUE == hDeviceHandle )
	    {
	    	return DDERR_UNSUPPORTED;
	    }

	    /*
	     * Get/sync the surface info
	     */
	    ddRVal = SyncKernelSurface( lpSurface, &ddkmSurfaceInfo );
	    if( ddRVal != DD_OK )
	    {
    		DPF( 0, "Unable to sync surface data with HAL" );
		return ddRVal;
	    }

	    /*
             * Get the handle from DDRAW.VXD
	     */
	    ddkmSurfaceInfo.dwDirectDrawHandle =
	    	lpSurface->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle;
	    ddkmGetSurfaceHandle.ddRVal = (DWORD) DDERR_GENERIC;
	    ddkmGetSurfaceHandle.hSurface = 0;
    	    DeviceIoControl( hDeviceHandle,
    		DD_DXAPI_GET_SURFACE_HANDLE,
	    	&ddkmSurfaceInfo,
	    	sizeof( ddkmSurfaceInfo ),
	    	&ddkmGetSurfaceHandle,
	    	sizeof( ddkmGetSurfaceHandle ),
	    	&dwReturned,
		NULL);
	    if( ( ddkmGetSurfaceHandle.ddRVal != DD_OK ) ||
	    	( ddkmGetSurfaceHandle.hSurface == 0 ) )
	    {
    		DPF( 0, "Unable to get surface handle from the VDD" );
		return DDERR_UNSUPPORTED;
	    }
	    *lpHandle = lpSurfGblMore->hKernelSurface =
	   	ddkmGetSurfaceHandle.hSurface;

        #else

	    *lpHandle = (ULONG_PTR) DdGetDxHandle( NULL, lpSurface, 0 );
	    if( *lpHandle == 0 )
	    {
	        return DDERR_GENERIC;
	    }
	    lpSurfGblMore->hKernelSurface = *lpHandle;

        #endif

	lpSurfGblMore->dwKernelRefCnt = 1;
    }

    return DD_OK;
}


/*
 * InitKernelInterface
 */

#ifdef WINNT
#ifndef MAX_AUTOFLIP
#define MAX_AUTOFLIP 10
#endif
#endif

HRESULT InitKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD )
{
#ifdef WIN95
    VDD_IOCTL_SET_NOTIFY_INPUT vddNotify;
    DDINITDEVICEIN ddInput;
    DDINITDEVICEOUT ddOutput;
    DDSETKERNELCAPS ddSetCaps;
#endif
    LPDDKERNELCAPS lpKernelCaps;
    HANDLE hDeviceHandle;
    DWORD dwReturned;
    DWORD ddRVal;
    DWORD dwTemp;
    BYTE szDisplayName[MAX_DRIVER_NAME];

    #ifdef WIN95

        /*
         * Don't do anything unles we're Windows98 or later
         */
        if( !IsWindows98() )
        {
	    return DDERR_UNSUPPORTED;
        }

	/*
	 * Get the name of the VDD device to open
	 * This is a hack to do some temporary work on Win95
	 */
	lstrcpy( szDisplayName, lpDD->lpGbl->cDriverName );
	if( _stricmp( szDisplayName, DISPLAY_STR ) == 0 )
	{
	    lstrcpy( szDisplayName, g_szPrimaryDisplay );
	}

	/*
	 * Open the VDD for communication
	 */
	lpDD->lpGbl->hKernelHandle = 0;
	hDeviceHandle = CreateFile( szDisplayName,
	    GENERIC_WRITE,
	    FILE_SHARE_WRITE,
	    NULL,
	    OPEN_EXISTING,
	    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
	    NULL);
	if( INVALID_HANDLE_VALUE == hDeviceHandle )
	{
	    DPF( 0, "Unable to open the VDD" );
	    return DDERR_UNSUPPORTED;
	}

	/*
	 * Get the function table from the mini VDD
	 */
	memset( &ddInput, 0, sizeof( ddInput ) );
    	DeviceIoControl( hDeviceHandle,
	    VDD_IOCTL_GET_DDHAL,
	    &dwTemp,
	    sizeof( DWORD ),
	    &(ddInput.MiniVDDTable),
	    sizeof( DDMINIVDDTABLE ),
	    &dwReturned,
	    NULL);

	/*
         * Send the new info down to DDRAW.VXD
	 */
	lpKernelCaps = lpDD->lpGbl->lpDDKernelCaps;
	if( lpKernelCaps != NULL )
	{
	    ddInput.dwMaxVideoPorts = lpDD->lpGbl->ddCaps.dwMaxVideoPorts;
	    if( lpDD->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANBOBINTERLEAVED )
	    {
    	        ddInput.dwDeviceFlags |= DDKMDF_CAN_BOB_INTERLEAVED;
	    }
	    if( lpDD->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED )
	    {
    	        ddInput.dwDeviceFlags |= DDKMDF_CAN_BOB_NONINTERLEAVED;
	    }
	    if( !( lpKernelCaps->dwCaps & DDKERNELCAPS_SETSTATE ) )
	    {
    	        ddInput.dwDeviceFlags |= DDKMDF_NOSTATE;
	    }
	}
	ddOutput.ddRVal = (DWORD) DDERR_GENERIC;
        DeviceIoControl( (HANDLE)lpDD->hDDVxd,
	    DD_DXAPI_INIT_DEVICE,
	    &ddInput,
	    sizeof( ddInput ),
	    &ddOutput,
	    sizeof( ddOutput ),
	    &dwReturned,
	    NULL);
	if( ddOutput.ddRVal != DD_OK )
	{
	    DPF( 0, "Unable to initialize the kernel data" );
	    CloseHandle( hDeviceHandle );
	    return DDERR_UNSUPPORTED;
	}

	/*
	 * If unable to allocate the IRQ, disable functionality that depends
	 * on it.
	 */
	if( lpKernelCaps != NULL )
	{
	    if( !ddOutput.bHaveIRQ )
	    {
	        DPF( 1, "Unable to allocate IRQ - disabling some kernel mode functionality" );
	        lpKernelCaps->dwIRQCaps = 0;
	    }

	    /*
	     * Disable kernel mode caps for which functions are not available
	     */
	    if( ( ddInput.MiniVDDTable.vddGetIRQInfo == NULL ) ||
	        ( ddInput.MiniVDDTable.vddEnableIRQ == NULL ) )
	    {
	        // Can't to any IRQ stuff w/o these functions
	        DPF( 1, "vddGet/EnableIRQ not supported - overriding dwIRQCaps" );
	        lpKernelCaps->dwIRQCaps = 0;
	    }
	    if( ddInput.MiniVDDTable.vddSetState == NULL )
	    {
	        DPF( 1, "vddSetState not supported - overriding DDKERNELCAPS_SETSTATE" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_SETSTATE;
	    }
	    if( ddInput.MiniVDDTable.vddLock == NULL )
	    {
	        DPF( 1, "vddLock not supported - overriding DDKERNELCAPS_LOCK" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_LOCK;
	    }
	    if( ddInput.MiniVDDTable.vddSkipNextField == NULL )
	    {
	        DPF( 1, "vddSkipNextField not supported - overriding DDKERNELCAPS_SKIPFIELDS" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_SKIPFIELDS;
	    }
	    if( ddInput.MiniVDDTable.vddFlipOverlay == NULL )
	    {
	        DPF( 1, "vddFlipOverlay not supported - overriding DDKERNELCAPS_FLIPOVERLAY" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_FLIPOVERLAY;
	    }
	    if( ddInput.MiniVDDTable.vddFlipVideoPort == NULL )
	    {
	        DPF( 1, "vddFlipVideoPort not supported - overriding DDKERNELCAPS_FLIPVIDEOPORT" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_FLIPVIDEOPORT;
	    }
	    if( ddInput.MiniVDDTable.vddGetPolarity == NULL )
	    {
	        DPF( 1, "vddGetFieldPolarity not supported - overriding DDKERNELCAPS_FIELDPOLARITY" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_FIELDPOLARITY;
	    }
	    if( ( ddInput.MiniVDDTable.vddTransfer == NULL ) ||
	        ( ddInput.MiniVDDTable.vddGetTransferStatus == NULL ) )
	    {
	        DPF( 1, "vddTransfer/GetTransferStatus not supported - overriding DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM/SYSMEM" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM;
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_CAPTURE_SYSMEM;
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_CAPTURE_INVERTED;
	    }
	    if( ( ddInput.MiniVDDTable.vddBobNextField == NULL ) &&
	        ( lpDD->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANBOBINTERLEAVED ) )
	    {
	        DPF( 1, "vddBobNextField not supported - overriding DDKERNELCAPS_AUTOFLIP" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_AUTOFLIP;
	    }
	    if( ( ddInput.MiniVDDTable.vddFlipOverlay == NULL ) ||
	        ( ddInput.MiniVDDTable.vddFlipVideoPort == NULL ) )
	    {
	        DPF( 1, "vddFlipOverlay/VideoPort not supported - overriding DDKERNELCAPS_AUTOFLIP" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_AUTOFLIP;
	    }
	    if( !( lpKernelCaps->dwIRQCaps & DDIRQ_VPORT0_VSYNC ) )
	    {
	        DPF( 1, "DDIRQ_VPORT0_VSYNC not set - overriding DDKERNELCAPS_AUTOFLIP" );
	        lpKernelCaps->dwCaps &= ~( DDKERNELCAPS_AUTOFLIP | DDKERNELCAPS_SETSTATE );
	    }
	    if( !( lpKernelCaps->dwCaps & DDKERNELCAPS_AUTOFLIP ) )
	    {
	        DPF( 1, "DDKERNELCAPS_AUTOFLIP not set - overriding DDKERNELCAPS_SKIPFIELDS" );
	        lpKernelCaps->dwCaps &= ~DDKERNELCAPS_SKIPFIELDS;
	    }

	    /*
             * Notify DDVXD of the updated caps
	     */
    	    ddSetCaps.dwDirectDrawHandle = ddOutput.dwDirectDrawHandle;
    	    ddSetCaps.dwCaps = lpKernelCaps->dwCaps;
    	    ddSetCaps.dwIRQCaps = lpKernelCaps->dwIRQCaps;
	    ddRVal = (DWORD) DDERR_GENERIC;
            DeviceIoControl( (HANDLE)lpDD->hDDVxd,
	        DD_DXAPI_SET_KERNEL_CAPS,
	        &ddSetCaps,
	        sizeof( ddSetCaps ),
	        &ddRVal,
	        sizeof( ddRVal ),
	        &dwReturned,
	        NULL);
	    if( ddRVal != DD_OK )
	    {
	        DPF( 0, "Unable to initialize the kernel data" );
	        CloseHandle( hDeviceHandle );
	        return DDERR_UNSUPPORTED;
	    }
	}


	/*
	 * Tell the VDD to notify us of dos box and res change events.
	 */
	vddNotify.NotifyMask = VDD_NOTIFY_START_MODE_CHANGE |
	    VDD_NOTIFY_END_MODE_CHANGE | VDD_NOTIFY_ENABLE | VDD_NOTIFY_DISABLE;
	vddNotify.NotifyType = VDD_NOTIFY_TYPE_CALLBACK;
	vddNotify.NotifyProc = ddOutput.pfnNotifyProc;
	vddNotify.NotifyData = ddOutput.dwDirectDrawHandle;
    	DeviceIoControl( hDeviceHandle,
	    VDD_IOCTL_SET_NOTIFY,
	    &vddNotify,
	    sizeof( vddNotify ),
	    &dwTemp,
	    sizeof( dwTemp ),
	    &dwReturned,
	    NULL);
	CloseHandle( hDeviceHandle );

	lpDD->lpGbl->hKernelHandle = ddOutput.dwDirectDrawHandle;
	lpDD->lpGbl->pfnNotifyProc = ddOutput.pfnNotifyProc;

	/*
	 * Everything worked.  If they can support software autoflipping,
	 * we'll update the video port caps structure accordingly.
	 */
    MungeAutoflipCaps( lpDD->lpGbl );

    #else

	/*
	 * Can we software autoflip?  If so, we'll update the video
	 * port caps structure accordingly.
	 */
	lpKernelCaps = lpDD->lpGbl->lpDDKernelCaps;
	if( ( lpKernelCaps != NULL ) &&
	    ( lpKernelCaps->dwCaps & DDKERNELCAPS_AUTOFLIP ) &&
	    ( lpDD->lpGbl->lpDDVideoPortCaps != NULL ) )
	{
    	    LPDDVIDEOPORTCAPS lpVideoPortCaps;
	    DWORD i;

	    for( i = 0; i < lpDD->lpGbl->ddCaps.dwMaxVideoPorts; i++ )
	    {
    	    	lpVideoPortCaps = &(lpDD->lpGbl->lpDDVideoPortCaps[i]);
    	    	if( ( lpVideoPortCaps != NULL ) &&
    	    	    VALID_DDVIDEOPORTCAPS_PTR( lpVideoPortCaps ) )
    	    	{
    	    	    lpVideoPortCaps->dwCaps |= DDVPCAPS_AUTOFLIP;
    	    	    lpVideoPortCaps->dwNumAutoFlipSurfaces = MAX_AUTOFLIP;
		    if( lpVideoPortCaps->dwCaps & DDVPCAPS_VBISURFACE )
		    {
    	    	        lpVideoPortCaps->dwNumVBIAutoFlipSurfaces = MAX_AUTOFLIP;
		    }
    	    	}
	    }
	}

    #endif

    return DD_OK;
}


/*
 * ReleaseKernelInterface
 */
HRESULT ReleaseKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD )
{
    HANDLE hDDVxd;
    HANDLE hVDD;
    DWORD dwTemp;
    DWORD dwReturned;
    BYTE szDisplayName[MAX_DRIVER_NAME];

    /*
     * Do nothing if no interface has been created.
     */
    if( lpDD->lpGbl->hKernelHandle == 0 )
    {
	return DD_OK;
    }

    #if WIN95

	/*
	 * Tell the VDD to stop notifying us of DOS box and res change events.
	 */
	if( lpDD->lpGbl->pfnNotifyProc != 0 )
	{
	    /*
	     * Get the name of the VDD device to open
	     */
	    lstrcpy( szDisplayName, lpDD->lpGbl->cDriverName );
	    if( _stricmp( szDisplayName, DISPLAY_STR ) == 0 )
	    {
	        lstrcpy( szDisplayName, g_szPrimaryDisplay );
	    }

	    hVDD = CreateFile( szDisplayName,
	    	GENERIC_WRITE,
	    	FILE_SHARE_WRITE,
	    	NULL,
	    	OPEN_EXISTING,
	    	FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
	    	NULL);
	    if( hVDD != INVALID_HANDLE_VALUE )
	    {
    	    	VDD_IOCTL_SET_NOTIFY_INPUT vddNotify;

	    	vddNotify.NotifyMask = 0;
	    	vddNotify.NotifyType = VDD_NOTIFY_TYPE_CALLBACK;
	    	vddNotify.NotifyProc = lpDD->lpGbl->pfnNotifyProc;
	    	vddNotify.NotifyData = lpDD->lpGbl->hKernelHandle;
    	    	DeviceIoControl( hVDD,
	    	    VDD_IOCTL_SET_NOTIFY,
	    	    &vddNotify,
	    	    sizeof( vddNotify ),
	    	    &dwTemp,
	    	    sizeof( dwTemp ),
	    	    &dwReturned,
	    	    NULL);
	    	CloseHandle( hVDD );
	    }
	}

	/*
	 * Need to decide which VXD handle to use. If we are executing
	 * on a DDHELP thread use the helper's VXD handle.
	 */
        hDDVxd = ( ( GetCurrentProcessId() != GETCURRPID() ) ? hHelperDDVxd : (HANDLE)lpDD->hDDVxd );
	dwTemp = lpDD->lpGbl->hKernelHandle;
        if( ( hDDVxd != NULL ) && ( dwTemp != 0 ) )
	{
            DeviceIoControl( hDDVxd,
	    	DD_DXAPI_RELEASE_DEVICE,
	    	&dwTemp,
	    	sizeof( DWORD ),
	    	&dwTemp,
	    	sizeof( DWORD ),
	    	&dwReturned,
	    	NULL);
	}

    #else

	DdGetDxHandle( lpDD, NULL, TRUE );

    #endif

    return DD_OK;
}


/*
 * Determines if software autoflipping is an option.
 */
BOOL CanSoftwareAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort )
{
    DWORD dwIRQ;

    #if WIN95

        /*
         * Fail if the ring 0 interface is not present
         */
        if( ( lpVideoPort == NULL ) ||
            ( !IsKernelInterfaceSupported( lpVideoPort->lpDD ) ) ||
    	    ( lpVideoPort->lpDD->lpGbl->hKernelHandle == (DWORD) 0 ) ||
    	    ( lpVideoPort->dwFlags & DDRAWIVPORT_NOKERNELHANDLES ) )
        {
	    return FALSE;
        }

        /*
         * Check the ring 0 caps to see if autoflipping is available
         */
        if( ( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps == NULL ) ||
    	    !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwCaps &
    	    DDKERNELCAPS_AUTOFLIP ) )
        {
	    return FALSE;
        }

        /*
         * Check to make sure an IRQ is available for this video port
         */
        dwIRQ = DDIRQ_VPORT0_VSYNC;
        dwIRQ <<= ( lpVideoPort->ddvpDesc.dwVideoPortID * 2 );
        if( !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwIRQCaps & dwIRQ ) )
        {
	    return FALSE;
        }

    #else

        /*
         * Check the ring 0 caps to see if autoflipping is available
         */
        if( (lpVideoPort == NULL ) ||
	    ( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps == NULL ) ||
    	    !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwCaps &
    	    DDKERNELCAPS_AUTOFLIP ) )
        {
	    return FALSE;
        }

        /*
         * Check to make sure an IRQ is available for this video port
         */
        dwIRQ = DDIRQ_VPORT0_VSYNC;
        dwIRQ <<= ( lpVideoPort->ddvpDesc.dwVideoPortID * 2 );
        if( !( lpVideoPort->lpDD->lpGbl->lpDDKernelCaps->dwIRQCaps & dwIRQ ) )
        {
	    return FALSE;
        }

    #endif

    return TRUE;
}


/*
 * DD_Kernel_GetCaps
 */
HRESULT DDAPI DD_Kernel_GetCaps(LPDIRECTDRAWKERNEL lpDDK, LPDDKERNELCAPS lpCaps )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Kernel_GetCaps");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDK;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this = this_int->lpLcl->lpGbl;
	if( !VALID_DDKERNELCAPS_PTR( lpCaps ) )
	{
	    DPF( 0, "Invalid DDKERNELCAPS ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        if( !IsKernelInterfaceSupported( this_int->lpLcl ) )
	{
	    DPF( 0, "Device does not support kernel interface" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    memcpy( lpCaps, this->lpDDKernelCaps, sizeof( DDKERNELCAPS ));
    lpCaps->dwSize = sizeof( DDKERNELCAPS );

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * DD_Kernel_GetKernelHandle
 */
HRESULT DDAPI DD_Kernel_GetKernelHandle(LPDIRECTDRAWKERNEL lpDDK, PULONG_PTR lpHandle )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Kernel_GetKernelHandle");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDK;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this = this_int->lpLcl->lpGbl;
	if( !VALID_DWORD_PTR( lpHandle ) )
	{
	    DPF( 0, "Invalid handle ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        if( !IsKernelInterfaceSupported( this_int->lpLcl ) )
	{
	    DPF( 0, "Device does not support kernel interface" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    #ifdef WINNT
	this->hKernelHandle = (ULONG_PTR) DdGetDxHandle( this_int->lpLcl, NULL, FALSE );
	if( this->hKernelHandle == 0 )
	{
	    DPF( 0, "Kernel failed GetDxHandle" );
	    LEAVE_DDRAW();
	    return DDERR_GENERIC;
	}
    #endif
    *lpHandle = this->hKernelHandle;

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * DD_Kernel_ReleaseKernelHandle
 *
 * Does nothing - should it?
 */
HRESULT DDAPI DD_Kernel_ReleaseKernelHandle(LPDIRECTDRAWKERNEL lpDDK )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_GBL	this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Kernel_ReleaseKernelHandle");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDK;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this = this_int->lpLcl->lpGbl;
        if( !IsKernelInterfaceSupported( this_int->lpLcl ) )
	{
	    DPF( 0, "Device does not support kernel interface" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    #ifdef WINNT
	ReleaseKernelInterface( this_int->lpLcl );
    #endif

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * DD_SurfaceKernel_GetKernelHandle
 */
HRESULT DDAPI DD_SurfaceKernel_GetKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK,
					PULONG_PTR lpHandle )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    DWORD ddRVal;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_SurfaceKernel_GetKernelHandle");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDK;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( !VALID_DWORD_PTR( lpHandle ) )
	{
	    DPF( 0, "Invalid handle ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        if( !IsKernelInterfaceSupported( this_int->lpLcl->lpSurfMore->lpDD_lcl ) )
	{
	    DPF( 0, "Device does not support kernel interface" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    ddRVal = InternalCreateKernelSurfaceHandle( this_int->lpLcl, lpHandle );

    LEAVE_DDRAW();
    return ddRVal;
}


/*
 * DD_SurfaceKernel_ReleaseKernelHandle
 */
HRESULT DDAPI DD_SurfaceKernel_ReleaseKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE 	lpSurfGblMore;
    DWORD	ddRVal;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_SurfaceKernel_ReleaseKernelHandle");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDK;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this = this_int->lpLcl->lpGbl;
    	lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( this );
    	if( lpSurfGblMore->hKernelSurface == 0 )
	{
	    DPF_ERR( "Kernel handle has already been released" );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
	if( this_int->lpLcl->lpSurfMore->lpDD_lcl->lpGbl->hKernelHandle == (DWORD) 0 )
	{
	    DPF( 0, "Device does not support kernel interface" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    ddRVal = InternalReleaseKernelSurfaceHandle( this_int->lpLcl, FALSE );

    LEAVE_DDRAW();
    return ddRVal;
}


/*
 * IsKernelInterfaceSupported
 */
BOOL IsKernelInterfaceSupported( LPDDRAWI_DIRECTDRAW_LCL lpDD )
{
    #ifdef WIN95
        if( ( lpDD->lpGbl->hKernelHandle == (DWORD) NULL ) ||
	    ( lpDD->lpGbl->lpDDKernelCaps == NULL ) ||
            ( lpDD->lpDDCB->HALDDKernel.SyncSurfaceData == NULL ) )
        {
	    return FALSE;
        }
    #else
        if( ( lpDD->lpGbl->lpDDKernelCaps == NULL ) ||
    	    ( lpDD->lpGbl->lpDDKernelCaps->dwCaps == 0 ) )
        {
	    return FALSE;
        }
    #endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddmcp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddmc.h
 *  Content:	DirectDrawMotionComp include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-sep-97	smac
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDVA_INCLUDED__
#define __DDVA_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoAccelerator objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDDVideoAcceleratorContainer,	0xACA12120,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
DEFINE_GUID( IID_IDirectDrawVideoAccelerator,   0xC9B2D740,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoAcceleratorContainer		FAR *LPDDVIDEOACCELERATORCONTAINER;
typedef struct IDirectDrawVideoAccelerator		FAR *LPDIRECTDRAWVIDEOACCELERATOR;

typedef struct IDDVideoAcceleratorContainerVtbl DDVIDEOACCELERATORCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoAcceleratorVtbl  DIRECTDRAWVIDEOACCELERATORCALLBACKS;


typedef struct _tag_DDVAUncompDataInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} DDVAUncompDataInfo, *LPDDVAUncompDataInfo;

typedef struct _tag_DDVAInternalMemInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} DDVAInternalMemInfo, *LPDDVAInternalMemInfo;


typedef struct _tag_DDVACompBufferInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} DDVACompBufferInfo, *LPDDVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVABeginFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    LPDIRECTDRAWSURFACE7    pddDestSurface;             // [in]     destination buffer in which to decoding this frame
    DWORD                   dwSizeInputData;            // [in]     size of other misc data to begin frame
    LPVOID                  pInputData;                 // [in]     pointer to misc data
    DWORD                   dwSizeOutputData;           // [in/out] size of other misc data to begin frame
    LPVOID                  pOutputData;                // [out]    pointer to misc data
} DDVABeginFrameInfo, *LPDDVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVAEndFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} DDVAEndFrameInfo, *LPDDVAEndFrameInfo;

typedef struct _tag_DDVABUFFERINFO
{
    DWORD                   dwSize;                     // [in]    size of the struct
    LPDIRECTDRAWSURFACE7    pddCompSurface;             // [in]    pointer to buffer containing compressed data
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} DDVABUFFERINFO, *LPDDVABUFFERINFO;


/*
 * INTERACES FOLLOW:
 *	IDDVideoAcceleratorContainer
 *	IDirectDrawVideoAccelerator
 */

/*
 * IDDVideoAcceleratorContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoAcceleratorContainer
DECLARE_INTERFACE_( IDDVideoAcceleratorContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDDVideoAcceleratorContainer methods ***/
    STDMETHOD(CreateVideoAccelerator)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPVOID, DWORD, LPDIRECTDRAWVIDEOACCELERATOR FAR *, IUnknown FAR *) PURE;
    STDMETHOD(GetCompBufferInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDWORD, LPDDVACompBufferInfo ) PURE;
    STDMETHOD(GetInternalMemInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDDVAInternalMemInfo ) PURE;
    STDMETHOD(GetVideoAcceleratorGUIDs)(THIS_ LPDWORD, LPGUID ) PURE;
    STDMETHOD(GetUncompFormatsSupported)(THIS_ LPGUID, LPDWORD, LPDDPIXELFORMAT ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IVideoAcceleratorContainer_Release(p)                         (p)->lpVtbl->Release(p)
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p,a,b,c,d,e,f)    (p)->lpVtbl->CreateVideoAccelerator(p, a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(p, a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(p, a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->lpVtbl->GetVideoAcceleratorGUIDs(p, a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->lpVtbl->GetUncompFormatsSupported(p, a, b, c)
#else
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->QueryInterface(a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->AddRef()
#define IVideoAcceleratorContainer_Release(p)                         (p)->Release()
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p, a, b, c,d,e,f) (p)->CreateVideoAccelerator(a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->GetCompBufferInfo(a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->GetInternalMemInfo(a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->GetVideoAcceleratorGUIDs(a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(a, b, c)
#endif

#endif


/*
 * IDirectDrawVideoAccelerator
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoAccelerator
DECLARE_INTERFACE_( IDirectDrawVideoAccelerator, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirecytDrawVideoAccelerator methods ***/
    STDMETHOD(BeginFrame)(THIS_ LPDDVABeginFrameInfo) PURE;
    STDMETHOD(EndFrame)(THIS_ LPDDVAEndFrameInfo) PURE;
    STDMETHOD(QueryRenderStatus)(THIS_ LPDIRECTDRAWSURFACE7, DWORD)PURE;
    STDMETHOD(Execute)(THIS_ 
                       DWORD,            // Function
                       LPVOID,           // Input data
                       DWORD,            // Input data length
                       LPVOID,           // Output data
                       DWORD,            // Output data length
                       DWORD,            // Number of buffers
                       LPDDVABUFFERINFO  // Buffer info array
                       ) PURE;
};

//  Flags for QueryRenderStatus
#define DDVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0 
                                                     // if query for update

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoAccelerator_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoAccelerator_BeginFrame(p,a)            (p)->lpVtbl->BeginFrame(p,a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->lpVtbl->EndFrame(p,a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->lpVtbl->QueryRenderStatus(p,a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->lpVtbl->RenderMacroBlocks(p,a,b)
#else
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->AddRef()
#define IVideoAccelerator_Release(p)                 (p)->Release()
#define IVideoAccelerator_BeginFrame(p,a)            (p)->BeginFrame(a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->EndFrame(a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->QueryRenderStatus(a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->RenderMacroBlocks(a,b)
#endif

#endif


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddmc.c ===
/*==========================================================================
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddmc.c
 *  Content: 	DirectDrawMotionComp
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-sep-97	smac	created
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#define DPF_MODNAME "DirectDrawMotionComp"



/*
 * IsMotionCompSupported
 */
BOOL IsMotionCompSupported( LPDDRAWI_DIRECTDRAW_LCL this_lcl )
{
    if( this_lcl->lpDDCB->HALDDMotionComp.GetMoCompGuids == NULL )
    {
	return FALSE;
    }
    return TRUE;
}


/*
 * DD_MC_AddRef
 */
DWORD DDAPI DD_MC_AddRef( LPDIRECTDRAWVIDEOACCELERATOR lpDDMC )
{
    LPDDRAWI_DDMOTIONCOMP_INT        this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL        this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_AddRef");
    /* DPF( 2, "DD_MC_AddRef, pid=%08lx, obj=%08lx", GETCURRPID(), lpDDMC ); */

    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * bump refcnt
     */
    this_lcl->dwRefCnt++;
    this_int->dwIntRefCnt++;

    LEAVE_DDRAW();

    return this_int->dwIntRefCnt;

} /* DD_MC_AddRef */


/*
 * DD_MC_QueryInterface
 */
HRESULT DDAPI DD_MC_QueryInterface(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, REFIID riid, LPVOID FAR * ppvObj )
{
    LPDDRAWI_DDMOTIONCOMP_INT                this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL                this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_QueryInterface");

    /*
     * validate parms
     */
    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid motion comp pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF_ERR( "Invalid motion comp interface pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * asking for IUnknown?
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawVideoAccelerator) )
    {
	/*
	 * Our IUnknown interface is the same as our V1
	 * interface.  We must always return the V1 interface
	 * if IUnknown is requested.
	 */
    	*ppvObj = (LPVOID) this_int;
	DD_MC_AddRef( *ppvObj );
	LEAVE_DDRAW();
	return DD_OK;
    }

    DPF_ERR( "IID not understood by DirectDraw" );

    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_MC_QueryInterface */


/*
 * DD_MC_Release
 */
DWORD DDAPI DD_MC_Release(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC )
{
    LPDDRAWI_DDMOTIONCOMP_INT   this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL   this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDHALMOCOMPCB_DESTROY     pfn;
    DWORD 			dwIntRefCnt;
    DWORD			rc;
    LPDDRAWI_DDMOTIONCOMP_INT   curr_int;
    LPDDRAWI_DDMOTIONCOMP_INT   last_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_Release");

    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid motion comp pointer" );
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	pdrv = this_lcl->lpDD->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * decrement the reference count.  if it hits zero, free the surface
     */
    this_lcl->dwRefCnt--;
    this_int->dwIntRefCnt--;

    DPF( 5, "DD_MC_Release, Reference Count: Local = %ld Int = %ld",
         this_lcl->dwRefCnt, this_int->dwIntRefCnt );

    /*
     * interface at zero?
     */
    dwIntRefCnt = this_int->dwIntRefCnt;
    if( dwIntRefCnt == 0 )
    {
	/*
	 * Notify the HAL
	 */
        pfn = this_lcl->lpDD->lpDDCB->HALDDMotionComp.DestroyMoComp;
	if( NULL != pfn )
	{
            DDHAL_DESTROYMOCOMPDATA DestroyData;

	    DestroyData.lpDD = this_lcl->lpDD;
            DestroyData.lpMoComp = this_lcl;

            DOHALCALL( DestroyMoComp, pfn, DestroyData, rc, 0 );
	    if( ( DDHAL_DRIVER_HANDLED == rc ) && ( DD_OK != DestroyData.ddRVal ) )
	    {
	    	LEAVE_DDRAW();
	    	return DestroyData.ddRVal;
	    }
    	}

	/*
	 * Remove it from our internal list
	 */
	curr_int = pdrv->mcList;
	last_int = NULL;
	while( curr_int != this_int )
	{
	    last_int = curr_int;
	    curr_int = curr_int->lpLink;
	    if( curr_int == NULL )
	    {
		DPF_ERR( "MotionComp object not in list!" );
		LEAVE_DDRAW();
		return 0;
	    }
	}
	if( last_int == NULL )
	{
	    pdrv->mcList = pdrv->mcList->lpLink;
	}
	else
	{
	    last_int->lpLink = curr_int->lpLink;
	}

	/*
	 * just in case someone comes back in with this pointer, set
	 * an invalid vtbl & data ptr.
	 */
	this_int->lpVtbl = NULL;
	this_int->lpLcl = NULL;
	MemFree( this_int );
    }

    LEAVE_DDRAW();

    return dwIntRefCnt;
}


/*
 * IsApprovedMCGuid
 *
 * The Motion Comp API can be used as a generic escape mechanism to
 * the driver, which we don't want to happen.  One way to deter this is
 * to control which GUIDs are used.  If somebody wants to use a new GUID,
 * we should approve their need and then assign them a GUID.  Since we want
 * to reserve GUIDs that we can assign in the future, we will reserve
 * four ranges 20 GUID values and will only accept GUIDs within one of
 * these ranges.
 */
BOOL IsApprovedMCGuid( LPGUID lpGuid )
{
    return TRUE;
}


/*
 * DDMCC_CreateMotionComp
 */
HRESULT DDAPI DDMCC_CreateMotionComp(
        LPDDVIDEOACCELERATORCONTAINER lpDDMCC,
	LPGUID lpGuid,
        LPDDVAUncompDataInfo lpUncompInfo,
	LPVOID lpData,
	DWORD  dwDataSize,
	LPDIRECTDRAWVIDEOACCELERATOR FAR *lplpDDMotionComp,
	IUnknown FAR *pUnkOuter )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    LPDDHALMOCOMPCB_CREATE cvpfn;
    LPDDRAWI_DDMOTIONCOMP_INT new_int;
    LPDDRAWI_DDMOTIONCOMP_LCL new_lcl;
    DWORD dwNumGuids;
    LPGUID lpGuidList;
    LPGUID lpTemp;
    DWORD rc;
    DWORD i;

    if( pUnkOuter != NULL )
    {
	return CLASS_E_NOAGGREGATION;
    }
    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDMCC_CreateMotionComp");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDMCC;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
    	this = this_lcl->lpGbl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    this->hDD = this_lcl->hDD;
	#endif
    	if( ( NULL == lplpDDMotionComp ) || !VALID_PTR_PTR( lplpDDMotionComp ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpGuid == NULL ) || !VALID_BYTE_ARRAY( lpGuid, sizeof( GUID ) ) )
    	{
            DPF_ERR ( "DDMCC_CreateMotionComp: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( ( lpUncompInfo == NULL ) ||
            !VALID_BYTE_ARRAY( lpUncompInfo, sizeof( DDVAUncompDataInfo ) ) )
    	{
            DPF_ERR ( "DDMCC_CreateMotionComp: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( !IsApprovedMCGuid( lpGuid ) )
	{
            DPF_ERR ( "DDMCC_CreateMotionComp: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwDataSize > 0 )
	{
	    if( ( lpData == NULL ) || !VALID_BYTE_ARRAY( lpData, dwDataSize ) )
    	    {
                DPF_ERR ( "DDMCC_CreateMotionComp: invalid lpData passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	}
	else
	{
	    lpData = NULL;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    if( this_lcl->dwProcessId != GetCurrentProcessId() )
    {
	DPF_ERR( "Process does not have access to object" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Verify that the GUID can be supported.
     */
    rc = DDMCC_GetMotionCompGUIDs( lpDDMCC,
	&dwNumGuids, NULL );
    if( rc != DD_OK )
    {
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    lpGuidList = (LPGUID) MemAlloc( sizeof( GUID ) * dwNumGuids );
    if( NULL == lpGuidList )
    {
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }
    rc = DDMCC_GetMotionCompGUIDs( lpDDMCC, &dwNumGuids, lpGuidList );
    if( rc != DD_OK )
    {
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    lpTemp = lpGuidList;
    for (i = 0; i < dwNumGuids; i++)
    {
    	if( ( IsEqualIID( lpGuid, lpTemp++ ) ) )
	{
	    break;
	}
    }
    MemFree( lpGuidList );
    if( i >= dwNumGuids )
    {
	DPF_ERR( "invalid GUID specified" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Allocate it
     */
    new_int = MemAlloc( sizeof( DDRAWI_DDMOTIONCOMP_INT ) +
        sizeof( DDRAWI_DDMOTIONCOMP_LCL ) );
    if( NULL == new_int )
    {
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }
    new_lcl = (LPDDRAWI_DDMOTIONCOMP_LCL) ((LPBYTE)new_int + sizeof( DDRAWI_DDMOTIONCOMP_INT ) );
    new_int->lpLcl = new_lcl;
    new_int->lpVtbl = (LPVOID)&ddMotionCompCallbacks;
    new_lcl->lpDD = this_lcl;
    new_lcl->dwProcessId = GetCurrentProcessId();
    memcpy( &(new_lcl->guid), lpGuid, sizeof( GUID ) );
    new_lcl->dwUncompWidth = lpUncompInfo->dwUncompWidth;
    new_lcl->dwUncompHeight = lpUncompInfo->dwUncompHeight;
    memcpy( &(new_lcl->ddUncompPixelFormat), &(lpUncompInfo->ddUncompPixelFormat), sizeof( DDPIXELFORMAT ) );

    /*
     * Notify the HAL that we created it
     */
    cvpfn = this_lcl->lpDDCB->HALDDMotionComp.CreateMoComp;
    if( NULL != cvpfn )
    {
        DDHAL_CREATEMOCOMPDATA CreateData;

    	CreateData.lpDD = this_lcl;
        CreateData.lpMoComp = new_lcl;
	CreateData.lpGuid = lpGuid;
        CreateData.dwUncompWidth = lpUncompInfo->dwUncompWidth;
        CreateData.dwUncompHeight = lpUncompInfo->dwUncompHeight;
        memcpy( &(CreateData.ddUncompPixelFormat), &(lpUncompInfo->ddUncompPixelFormat), sizeof( DDPIXELFORMAT ) );
	CreateData.lpData = lpData;
	CreateData.dwDataSize = dwDataSize;

        DOHALCALL( CreateMoComp, cvpfn, CreateData, rc, 0 );
	if( ( DDHAL_DRIVER_HANDLED == rc ) &&  (DD_OK != CreateData.ddRVal ) )
	{
	    LEAVE_DDRAW();
	    return CreateData.ddRVal;
	}
    }

    DD_MC_AddRef( (LPDIRECTDRAWVIDEOACCELERATOR )new_int );
    *lplpDDMotionComp = (LPDIRECTDRAWVIDEOACCELERATOR) new_int;
    new_int->lpLink = this->mcList;
    this->mcList = new_int;

    LEAVE_DDRAW();

    return DD_OK;
} /* DDMCC_CreateMotionComp */


/*
 * DDMCC_GetMotionCompFormats
 */
HRESULT DDAPI DDMCC_GetUncompressedFormats(
        LPDDVIDEOACCELERATORCONTAINER lpDDMCC,
	LPGUID lpGuid,
        LPDWORD lpdwNumFormats,
	LPDDPIXELFORMAT lpFormats )
{
    LPDDHALMOCOMPCB_GETFORMATS pfn;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDPIXELFORMAT lpTemp;
    DDHAL_GETMOCOMPFORMATSDATA GetFormatData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDMCC_GetMotionCompFormats");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDMCC;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
            DPF_ERR ( "DDMCC_GetMotionCompFormats: Invalid DirectDraw ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    this_lcl->lpGbl->hDD = this_lcl->hDD;
	#endif
    	if( (lpdwNumFormats == NULL) || !VALID_BYTE_ARRAY( lpdwNumFormats, sizeof( LPVOID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetMotionCompFormats: lpNumFormats not valid");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL != lpFormats )
    	{
	    if( 0 == *lpdwNumFormats )
    	    {
                DPF_ERR ( "DDMCC_GetMotionCompFormats: lpNumFormats not valid");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	    if( !VALID_BYTE_ARRAY( lpFormats, *lpdwNumFormats * sizeof( DDPIXELFORMAT ) ) )
    	    {
                DPF_ERR ( "DDMCC_GetMotionCompFormats: invalid array passed in");
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
	if( ( lpGuid == NULL ) || !VALID_BYTE_ARRAY( lpGuid, sizeof( GUID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetMotionCompFormats: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( !IsApprovedMCGuid( lpGuid ) )
	{
            DPF_ERR ( "DDMCC_GetMotionCompFormats: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_int->lpLcl->lpDDCB->HALDDMotionComp.GetMoCompFormats;
    if( pfn != NULL )
    {
	/*
	 * Get the number of formats
	 */
    	GetFormatData.lpDD = this_int->lpLcl;
    	GetFormatData.lpGuid = lpGuid;
    	GetFormatData.lpFormats = NULL;

        DOHALCALL( GetMoCompFormats, pfn, GetFormatData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return GetFormatData.ddRVal;
	}
	else if( DD_OK != GetFormatData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetFormatData.ddRVal;
	}

	if( NULL == lpFormats )
	{
    	    *lpdwNumFormats = GetFormatData.dwNumFormats;
	}

	else
	{
	    /*
	     * Make sure we have enough room for formats
	     */
	    if( GetFormatData.dwNumFormats > *lpdwNumFormats )
	    {
		lpTemp = (LPDDPIXELFORMAT) MemAlloc(
		    sizeof( DDPIXELFORMAT ) * GetFormatData.dwNumFormats );
    	        GetFormatData.lpFormats = lpTemp;
	    }
	    else
	    {
    	    	GetFormatData.lpFormats = lpFormats;
	    }

            DOHALCALL( GetMoCompFormats, pfn, GetFormatData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	    else if( DD_OK != GetFormatData.ddRVal )
	    {
	        LEAVE_DDRAW();
	        return GetFormatData.ddRVal;
	    }

	    if( GetFormatData.lpFormats != lpFormats )
	    {
		memcpy( lpFormats, lpTemp,
		    sizeof( DDPIXELFORMAT ) * *lpdwNumFormats );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
		*lpdwNumFormats = GetFormatData.dwNumFormats;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDMCC_GetMotionCompFormats */


/*
 * DDMCC_GetMotionCompGUIDs
 */
HRESULT DDAPI DDMCC_GetMotionCompGUIDs(
        LPDDVIDEOACCELERATORCONTAINER lpDDMCC,
        LPDWORD lpdwNumGuids,
	LPGUID lpGuids )
{
    LPDDHALMOCOMPCB_GETGUIDS pfn;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPGUID lpTemp = NULL;
    LPGUID lpTempGuid;
    DDHAL_GETMOCOMPGUIDSDATA GetGuidData;
    DWORD rc;
    DWORD i;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: GetMotionCompGUIDs");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDMCC;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
            DPF_ERR ( "DDMCC_GetMotionCompGUIDs: Invalid DirectDraw ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    this_lcl->lpGbl->hDD = this_lcl->hDD;
	#endif
    	if( (lpdwNumGuids == NULL) || !VALID_BYTE_ARRAY( lpdwNumGuids, sizeof( LPVOID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetMotionCompGuids: lpNumGuids not valid");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    	if( NULL != lpGuids )
    	{
	    if( 0 == *lpdwNumGuids )
    	    {
                DPF_ERR ( "DDMCC_GetMotionCompGUIDs: lpNumGuids not valid");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	    if( !VALID_BYTE_ARRAY( lpGuids, *lpdwNumGuids * sizeof( GUID ) ) )
    	    {
                DPF_ERR ( "DDMCC_GetMotionCompGUIDs: invalid array passed in");
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_int->lpLcl->lpDDCB->HALDDMotionComp.GetMoCompGuids;
    if( pfn != NULL )
    {
	/*
	 * Get the number of GUIDs
	 */
    	GetGuidData.lpDD = this_int->lpLcl;
    	GetGuidData.lpGuids = NULL;

        DOHALCALL( GetMoCompGuids, pfn, GetGuidData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
	    return GetGuidData.ddRVal;
	}
	else if( DD_OK != GetGuidData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return GetGuidData.ddRVal;
	}

	if( NULL == lpGuids )
	{
    	    *lpdwNumGuids = GetGuidData.dwNumGuids;
	}

	else
	{
	    /*
	     * Make sure we have enough room for GUIDs
	     */
	    if( GetGuidData.dwNumGuids > *lpdwNumGuids )
	    {
		lpTemp = (LPGUID) MemAlloc(
		    sizeof( GUID ) * GetGuidData.dwNumGuids );
    	        GetGuidData.lpGuids = lpTemp;
	    }
	    else
	    {
    	    	GetGuidData.lpGuids = lpGuids;
	    }

            DOHALCALL( GetMoCompGuids, pfn, GetGuidData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
	    else if( DD_OK != GetGuidData.ddRVal )
	    {
	        LEAVE_DDRAW();
	        return GetGuidData.ddRVal;
	    }

	    /*
	     * If the driver returned a GUID that is not from our valid
	     * range, fail the call
	     */
	    lpTempGuid = GetGuidData.lpGuids;
	    for( i = 0; i < GetGuidData.dwNumGuids; i++ )
	    {
		if( !IsApprovedMCGuid( lpTempGuid ) )
		{
		    if( lpTemp != NULL )
		    {
			MemFree( lpTemp );
		    }
		    DPF_ERR("The driver returned a GUID that DDraw didn't assign");
		    LEAVE_DDRAW();
	            return DDERR_GENERIC;
		}
		lpTempGuid++;
	    }

	    if( GetGuidData.lpGuids != lpGuids )
	    {
		memcpy( lpGuids, lpTemp,
		    sizeof( GUID ) * *lpdwNumGuids );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
		*lpdwNumGuids = GetGuidData.dwNumGuids;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDMCC_GetMotionCompGUIDs */

/*
 * DDMCC_GetCompBuffInfo
 */
HRESULT DDAPI DDMCC_GetCompBuffInfo(
        LPDDVIDEOACCELERATORCONTAINER lpDDMCC,
	LPGUID lpGuid,
        LPDDVAUncompDataInfo lpUncompInfo,
        LPDWORD lpdwNumBuffInfo,
        LPDDVACompBufferInfo lpCompBuffInfo )
{
    LPDDHALMOCOMPCB_GETCOMPBUFFINFO pfn;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDMCCOMPBUFFERINFO lpTemp = NULL;
    DDHAL_GETMOCOMPCOMPBUFFDATA GetCompBuffData;
    DWORD rc;

    ENTER_DDRAW();

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDMCC;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
            DPF_ERR ( "DDMCC_GetCompBuffInfo: Invalid DirectDraw ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
        if( (lpdwNumBuffInfo == NULL) || !VALID_BYTE_ARRAY( lpdwNumBuffInfo, sizeof( LPVOID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetCompBuffInfo: lpNumBuffInfo not valid");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( NULL != lpCompBuffInfo )
    	{
            if( 0 == *lpdwNumBuffInfo )
    	    {
                DPF_ERR ( "DDMCC_GetCompBuffInfo lpCompBuffInfo not valid");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
            if( !VALID_BYTE_ARRAY( lpCompBuffInfo, *lpdwNumBuffInfo * sizeof( DDVACompBufferInfo ) ) )
    	    {
                DPF_ERR ( "DDMCC_GetCompBuffInfo: invalid array passed in");
	    	LEAVE_DDRAW();
	    	return DDERR_INVALIDPARAMS;
    	    }
      	}
        if( ( lpUncompInfo == NULL ) ||
            !VALID_BYTE_ARRAY( lpUncompInfo, sizeof( DDVAUncompDataInfo ) ) )
    	{
            DPF_ERR ( "DDMCC_GetCompBuffInfo: invalid lpUncompInfo passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpGuid == NULL ) || !VALID_BYTE_ARRAY( lpGuid, sizeof( GUID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetCompBuffInfo: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( !IsApprovedMCGuid( lpGuid ) )
	{
            DPF_ERR ( "DDMCC_GetCompBuffInfo: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = this_int->lpLcl->lpDDCB->HALDDMotionComp.GetMoCompBuffInfo;
    if( pfn != NULL )
    {
	/*
         * Get the number of buffer types
	 */
        GetCompBuffData.lpDD = this_int->lpLcl;
        GetCompBuffData.lpGuid = lpGuid;
        GetCompBuffData.dwWidth= lpUncompInfo->dwUncompWidth;
        GetCompBuffData.dwHeight= lpUncompInfo->dwUncompHeight;
        memcpy( &GetCompBuffData.ddPixelFormat,
            &(lpUncompInfo->ddUncompPixelFormat), sizeof( DDPIXELFORMAT ) );
        GetCompBuffData.lpCompBuffInfo = NULL;
        GetCompBuffData.dwNumTypesCompBuffs = 0;

        DOHALCALL( GetMoCompBuffInfo, pfn, GetCompBuffData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
            return GetCompBuffData.ddRVal;
	}
        else if( DD_OK != GetCompBuffData.ddRVal )
	{
	    LEAVE_DDRAW();
            return GetCompBuffData.ddRVal;
	}

        if( NULL == lpCompBuffInfo )
	{
            *lpdwNumBuffInfo = GetCompBuffData.dwNumTypesCompBuffs;
	}

	else
	{
	    /*
	     * Make sure we have enough room for formats
	     */
            if( GetCompBuffData.dwNumTypesCompBuffs > *lpdwNumBuffInfo )
	    {
                lpTemp = (LPDDMCCOMPBUFFERINFO) MemAlloc(
                    sizeof( DDMCCOMPBUFFERINFO ) * GetCompBuffData.dwNumTypesCompBuffs );
                GetCompBuffData.lpCompBuffInfo = lpTemp;
	    }
	    else
	    {
                GetCompBuffData.lpCompBuffInfo = (LPDDMCCOMPBUFFERINFO)lpCompBuffInfo;
	    }

            DOHALCALL( GetMoCompBuffInfo, pfn, GetCompBuffData, rc, 0 );
	    if( DDHAL_DRIVER_HANDLED != rc )
	    {
	        LEAVE_DDRAW();
	        return DDERR_UNSUPPORTED;
	    }
            else if( DD_OK != GetCompBuffData.ddRVal )
	    {
	        LEAVE_DDRAW();
                return GetCompBuffData.ddRVal;
	    }

            if( GetCompBuffData.lpCompBuffInfo != (LPDDMCCOMPBUFFERINFO)lpCompBuffInfo )
	    {
                memcpy( lpCompBuffInfo, lpTemp,
                    sizeof( DDVACompBufferInfo ) * *lpdwNumBuffInfo );
		MemFree( lpTemp );
    		LEAVE_DDRAW();
		return DDERR_MOREDATA;
	    }
	    else
	    {
                *lpdwNumBuffInfo = GetCompBuffData.dwNumTypesCompBuffs;
	    }
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDMCC_GetCompBuffInfo */

/*
 * DDMCC_GetInternalMemInfo
 */
HRESULT DDAPI DDMCC_GetInternalMoCompInfo(
        LPDDVIDEOACCELERATORCONTAINER lpDDMCC,
	LPGUID lpGuid,
        LPDDVAUncompDataInfo lpUncompInfo,
        LPDDVAInternalMemInfo lpMemInfo )
{
    LPDDHALMOCOMPCB_GETINTERNALINFO pfn;
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    DDHAL_GETINTERNALMOCOMPDATA GetInternalData;
    DWORD rc;

    ENTER_DDRAW();

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDDMCC;
    	if( !VALID_DIRECTDRAW_PTR( this_int ) )
    	{
            DPF_ERR ( "DDMCC_GetInternalMemInfo: Invalid DirectDraw ptr");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
        if( ( lpUncompInfo == NULL ) ||
            !VALID_BYTE_ARRAY( lpUncompInfo, sizeof( DDVAUncompDataInfo ) ) )
    	{
            DPF_ERR ( "DDMCC_GetInternalMemInfo: invalid lpUncompInfo passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( ( lpMemInfo == NULL ) ||
            !VALID_BYTE_ARRAY( lpMemInfo, sizeof( DDVAInternalMemInfo ) ) )
    	{
            DPF_ERR ( "DDMCC_GetInternalMemInfo: invalid lpUncompInfo passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( ( lpGuid == NULL ) || !VALID_BYTE_ARRAY( lpGuid, sizeof( GUID ) ) )
    	{
            DPF_ERR ( "DDMCC_GetInternalMemInfo: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
	if( !IsApprovedMCGuid( lpGuid ) )
	{
            DPF_ERR ( "DDMCC_GetInternalMemInfo: invalid GUID passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    lpMemInfo->dwScratchMemAlloc = 0;
    pfn = this_int->lpLcl->lpDDCB->HALDDMotionComp.GetInternalMoCompInfo;
    if( pfn != NULL )
    {
	/*
         * Get the number of buffer types
	 */
        GetInternalData.lpDD = this_int->lpLcl;
        GetInternalData.lpGuid = lpGuid;
        GetInternalData.dwWidth= lpUncompInfo->dwUncompWidth;
        GetInternalData.dwHeight= lpUncompInfo->dwUncompHeight;
        memcpy( &GetInternalData.ddPixelFormat,
            &(lpUncompInfo->ddUncompPixelFormat), sizeof( DDPIXELFORMAT ) );

        DOHALCALL( GetInternalMoCompInfo, pfn, GetInternalData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
            return GetInternalData.ddRVal;
	}
        else if( DD_OK != GetInternalData.ddRVal )
	{
	    LEAVE_DDRAW();
            return GetInternalData.ddRVal;
	}
        lpMemInfo->dwScratchMemAlloc = GetInternalData.dwScratchMemAlloc;
    }

    LEAVE_DDRAW();

    return DD_OK;
} /* DDMCC_GetInternalMemInfo */

/*
 * DD_MC_BeginFrame
 */
HRESULT DDAPI DD_MC_BeginFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC,
                               LPDDVABeginFrameInfo lpInfo )
{
    LPDDRAWI_DDMOTIONCOMP_INT this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL this_lcl;
    DDHAL_BEGINMOCOMPFRAMEDATA BeginFrameData;
    LPDDHALMOCOMPCB_BEGINFRAME pfn;
    DWORD i;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_BeginFrame");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
        if( ( lpInfo == NULL ) || !VALID_BYTE_ARRAY( lpInfo, sizeof( DDVABeginFrameInfo ) ) )
    	{
            DPF_ERR ( "DD_MC_BeginFrame: invalid structure passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( ( lpInfo->pddDestSurface == NULL ) ||
            !VALID_DIRECTDRAWSURFACE_PTR( ((LPDDRAWI_DDRAWSURFACE_INT)lpInfo->pddDestSurface) ) )
        {
            DPF_ERR ( "DD_MC_BeginFrame: invalid dest surface specified");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( lpInfo->dwSizeInputData > 0 )
	{
            if( ( lpInfo->pInputData == NULL ) ||
                !VALID_BYTE_ARRAY( lpInfo->pInputData, lpInfo->dwSizeInputData ) )
    	    {
                DPF_ERR ( "DD_MC_BeginFrame: invalid lpInputData passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	}
        if( lpInfo->dwSizeOutputData > 0 )
	{
            if( ( lpInfo->pOutputData == NULL ) ||
                !VALID_BYTE_ARRAY( lpInfo->pOutputData, lpInfo->dwSizeOutputData ) )
    	    {
                DPF_ERR ( "DD_MC_BeginFrame: invalid lpOutputData passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Call the HAL
     */
    pfn = this_lcl->lpDD->lpDDCB->HALDDMotionComp.BeginMoCompFrame;
    if( pfn != NULL )
    {
    	BeginFrameData.lpDD = this_lcl->lpDD;
        BeginFrameData.lpMoComp = this_lcl;
        BeginFrameData.lpDestSurface = ((LPDDRAWI_DDRAWSURFACE_INT)lpInfo->pddDestSurface)->lpLcl;
        BeginFrameData.dwInputDataSize = lpInfo->dwSizeInputData;
        BeginFrameData.lpInputData = BeginFrameData.dwInputDataSize == 0 ? NULL : lpInfo->pInputData;
        BeginFrameData.dwOutputDataSize = lpInfo->dwSizeOutputData;
        BeginFrameData.lpOutputData = BeginFrameData.dwOutputDataSize == 0 ? NULL : lpInfo->pOutputData;

        DOHALCALL( BeginMoCompFrame, pfn, BeginFrameData, rc, 0 );

        if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
	}
        if( BeginFrameData.ddRVal == DD_OK )
        {
            if( BeginFrameData.dwOutputDataSize > 0 )
            {
                lpInfo->dwSizeOutputData = BeginFrameData.dwOutputDataSize;
            }
        }
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return BeginFrameData.ddRVal;
}


/*
 * DD_MC_EndFrame
 */
HRESULT DDAPI DD_MC_EndFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC,
        LPDDVAEndFrameInfo lpInfo )
{
    LPDDRAWI_DDMOTIONCOMP_INT this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL this_lcl;
    DDHAL_ENDMOCOMPFRAMEDATA EndFrameData;
    LPDDHALMOCOMPCB_ENDFRAME pfn;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_EndFrame");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
        if( ( lpInfo == NULL ) || !VALID_BYTE_ARRAY( lpInfo, sizeof( DDVAEndFrameInfo ) ) )
    	{
            DPF_ERR ( "DD_MC_EndFrame: invalid structure passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
        if( lpInfo->dwSizeMiscData > 0 )
	{
            if( ( lpInfo->pMiscData == NULL ) ||
                !VALID_BYTE_ARRAY( lpInfo->pMiscData, lpInfo->dwSizeMiscData ) )
    	    {
                DPF_ERR ( "DD_MC_BeginFrame: invalid lpData passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Call the HAL
     */
    pfn = this_lcl->lpDD->lpDDCB->HALDDMotionComp.EndMoCompFrame;
    if( pfn != NULL )
    {
    	EndFrameData.lpDD = this_lcl->lpDD;
        EndFrameData.lpMoComp = this_lcl;
        EndFrameData.dwInputDataSize = lpInfo->dwSizeMiscData;
        EndFrameData.lpInputData = EndFrameData.dwInputDataSize > 0 ? lpInfo->pMiscData : NULL;

        DOHALCALL( EndMoCompFrame, pfn, EndFrameData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return EndFrameData.ddRVal;
}


/*
 * DD_MC_RenderMacroBlocks
 */
HRESULT DDAPI DD_MC_RenderMacroBlocks(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC,
        DWORD dwFunction, LPVOID lpInData, DWORD dwInSize, LPVOID lpOutData,
        DWORD dwOutSize, DWORD dwNumBuffers, LPDDVABUFFERINFO lpBuffInfo )
{
    LPDDRAWI_DDMOTIONCOMP_INT this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL this_lcl;
    DDHAL_RENDERMOCOMPDATA RenderData;
    LPDDHALMOCOMPCB_RENDER pfn;
    LPDDMCBUFFERINFO lpTempArray = NULL;
    LPDDMCBUFFERINFO lpTempDest;
    LPDDVABUFFERINFO lpTempSrc;
    DWORD rc;
    DWORD i;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_RenderMacroBlocks");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
        if( dwNumBuffers > 0 )
	{
            if( ( lpBuffInfo== NULL ) ||
                !VALID_BYTE_ARRAY( lpBuffInfo, sizeof( DDVABUFFERINFO) * dwNumBuffers ) )
    	    {
                DPF_ERR ( "DD_MC_RenderMacroBlocks: invalid buffer pointer passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }

            if( lpInData == NULL )
            {
                dwInSize = 0;
            }
            else if( !VALID_BYTE_ARRAY( lpInData, dwInSize) )
    	    {
                DPF_ERR ( "DD_MC_RenderMacroBlocks: invalid input data pointer passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }

            if( lpOutData == NULL )
            {
                dwOutSize = 0;
            }
            else if( !VALID_BYTE_ARRAY( lpOutData, dwOutSize) )
    	    {
                DPF_ERR ( "DD_MC_RenderMacroBlocks: invalid output data pointer passed in");
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
    	    }

            lpTempArray = LocalAlloc( LPTR, sizeof( DDMCBUFFERINFO ) * dwNumBuffers );
            if( lpTempArray == NULL )
            {
                LEAVE_DDRAW();
                return DDERR_OUTOFMEMORY;
            }
            lpTempSrc = lpBuffInfo;
            lpTempDest = lpTempArray;
            for( i = 0; i < dwNumBuffers; i++)
            {
                if( ( lpTempSrc->pddCompSurface == NULL ) ||
                    !VALID_DIRECTDRAWSURFACE_PTR( ((LPDDRAWI_DDRAWSURFACE_INT)lpTempSrc->pddCompSurface) ) )
                {
                    if( lpTempArray != NULL )
                    {
                        LocalFree( lpTempArray );
                    }
                    DPF_ERR ( "DD_MC_RendermacroBlockse: invalid surface specified");
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPARAMS;
                }
                lpTempDest->dwSize = lpTempSrc->dwSize;
                lpTempDest->lpCompSurface = ((LPDDRAWI_DDRAWSURFACE_INT)(lpTempSrc->pddCompSurface))->lpLcl;
                lpTempDest->dwDataOffset = lpTempSrc->dwDataOffset;
                lpTempDest++->dwDataSize = lpTempSrc++->dwDataSize;
            }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        if( lpTempArray != NULL )
        {
            LocalFree( lpTempArray );
        }
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Call the HAL
     */
    pfn = this_lcl->lpDD->lpDDCB->HALDDMotionComp.RenderMoComp;
    if( pfn != NULL )
    {
        RenderData.lpDD = this_lcl->lpDD;
        RenderData.lpMoComp = this_lcl;
        RenderData.dwNumBuffers = dwNumBuffers;
        RenderData.lpBufferInfo = lpTempArray;
        RenderData.lpInputData = lpInData;
        RenderData.dwInputDataSize = dwInSize;
        RenderData.lpOutputData = lpOutData;
        RenderData.dwOutputDataSize = dwOutSize;
        RenderData.dwFunction = dwFunction;

        DOHALCALL( RenderMoComp, pfn, RenderData, rc, 0 );

        if( lpTempArray != NULL )
        {
            LocalFree( lpTempArray );
        }
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
	}
    }
    else
    {
        if( lpTempArray != NULL )
        {
            LocalFree( lpTempArray );
        }
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return RenderData.ddRVal;
}


/*
 * DD_MC_QueryRenderStatus
 */
HRESULT DDAPI DD_MC_QueryRenderStatus(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC,
        LPDIRECTDRAWSURFACE7 lpSurface, DWORD dwFlags )
{
    LPDDRAWI_DDMOTIONCOMP_INT this_int;
    LPDDRAWI_DDMOTIONCOMP_LCL this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT surf_int;
    DDHAL_QUERYMOCOMPSTATUSDATA QueryData;
    LPDDHALMOCOMPCB_QUERYSTATUS pfn;
    DWORD rc;
    DWORD i;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_MC_QueryRenderStatus");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDMOTIONCOMP_INT) lpDDMC;
        if( !VALID_DDMOTIONCOMP_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;

        surf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpSurface;
        if( ( surf_int == NULL ) ||
            !VALID_DIRECTDRAWSURFACE_PTR( surf_int ) )
        {
            DPF_ERR("DD_MD_QueryRenderStatus: Invalid surface passed in");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
        }

        if( dwFlags & ~(DDMCQUERY_VALID) )
        {
            DPF_ERR("DD_MD_QueryRenderStatus: Invalid flag specified");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * Call the HAL
     */
    pfn = this_lcl->lpDD->lpDDCB->HALDDMotionComp.QueryMoCompStatus;
    if( pfn != NULL )
    {
    	QueryData.lpDD = this_lcl->lpDD;
        QueryData.lpMoComp = this_lcl;
        QueryData.lpSurface = surf_int->lpLcl;
        QueryData.dwFlags = dwFlags;

        DOHALCALL( QueryMoCompStatus, pfn, QueryData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
	{
	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return QueryData.ddRVal;
}

/*
 * ProcessMotionCompCleanup
 *
 * A process is done, clean up any motion comp objects that it may
 * still exist.
 *
 * NOTE: we enter with a lock taken on the DIRECTDRAW object.
 */
void ProcessMotionCompCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDMOTIONCOMP_INT        pmc_int;
    LPDDRAWI_DDMOTIONCOMP_LCL        pmc_lcl;
    LPDDRAWI_DDMOTIONCOMP_INT        pmcnext_int;
    DWORD			rcnt;
    ULONG			rc;

    /*
     * run through all motion comp objects owned by the driver object, and find ones
     * that have been accessed by this process.  If the pdrv_lcl parameter
     * is non-null, only delete motion comp objects created by that local driver object.
     */
    pmc_int = pdrv->mcList;
    DPF( 4, "ProcessMotionCompCleanup" );
    while( pmc_int != NULL )
    {
	pmc_lcl = pmc_int->lpLcl;
	pmcnext_int = pmc_int->lpLink;
	rc = 1;
	if( ( pmc_lcl->dwProcessId == pid ) &&
	    ( (NULL == pdrv_lcl) || (pmc_lcl->lpDD == pdrv_lcl) ) )
	{
	    /*
	     * release the references by this process
	     */
	    rcnt = pmc_int->dwIntRefCnt;
	    DPF( 5, "Process %08lx had %ld accesses to motion comp %08lx", pid, rcnt, pmc_int );
	    while( rcnt >  0 )
	    {
		rc = DD_MC_Release( (LPDIRECTDRAWVIDEOACCELERATOR) pmc_int );
		pmcnext_int = pdrv->mcList;
		if( rc == 0 )
		{
		    break;
		}
		rcnt--;
	    }
	}
	else
	{
            DPF( 5, "Process %08lx had no accesses to motion comp object %08lx", pid, pmc_int );
	}
	pmc_int = pmcnext_int;
    }
    DPF( 4, "Leaving ProcessMotionCompCleanup");

} /* ProcessMotionCompCleanup */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddmode.c ===
/*========================================================================== *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddmode.c
 *  Content:    DirectDraw mode support
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   31-jan-95  craige  split out of ddraw.c and enhanced
 *   27-feb-95  craige  new sync. macros
 *   01-mar-95  craige  Win95 mode stuff
 *   19-mar-95  craige  use HRESULTs
 *   28-mar-95  craige  made modeset work again
 *   01-apr-95  craige  happy fun joy updated header file
 *   19-apr-95  craige  check for invalid callback in EnumDisplayModes
 *   14-may-95  craige  allow BPP change; validate EnumDisplayModes modes
 *   15-may-95  craige  keep track of who changes the mode
 *   02-jun-95  craige  keep track of the mode set by a process
 *   06-jun-95  craige  added internal fn RestoreDisplayMode
 *   11-jun-95  craige  don't allow mode switch if surfaces locked
 *   12-jun-95  craige  new process list stuff
 *   25-jun-95  craige  one ddraw mutex
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   30-jun-95  craige  turned off > 16bpp
 *   01-jul-95  craige  bug 106 - always went to last mode if mode not found
 *   02-jul-95  craige  RestoreDisplayMode needs to call HEL too
 *   04-jul-95  craige  YEEHAW: new driver struct; SEH
 *   05-jul-95  craige  crank up priority during mode change
 *   13-jul-95  craige  first step in mode set fix; made it work
 *   19-jul-95  craige  bug 189 - graphics mode change being ignored sometimes
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   22-jul-95  craige  bug 216 - random hang switching bpp - fixed by
 *                      using apps hwnd to hide things.
 *                      bug 230 - unsupported starting modes
 *   29-jul-95  toddla  allways call HEL for SetMode for display driver
 *   10-aug-95  toddla  EnumDisplayModes changed to take a lp not a lplp
 *   02-sep-95  craige  bug 854: disable > 640x480 modes for rel 1
 *   04-sep-95  craige  bug 894: allow forcing of mode set
 *   08-sep-95  craige  bug 932: set preferred mode after RestoreDisplayMode
 *   05-jan-96  kylej   add interface structures
 *   09-jan-96  kylej   enable >640x480 modes for rel 2
 *   27-feb-96  colinmc ensured that bits-per-pixel is always tested for
 *                      when enumerating display modes and that enumeration
 *                      always assumes you will be in exclusive mode when
 *                      you actually do the mode switch
 *   11-mar-96  jeffno  Dynamic mode switch stuff for NT
 *   24-mar-96  kylej   Check modes with monitor profile
 *   26-mar-96  jeffno  Added ModeChangedOnENTERDDRAW
 *   15-sep-96	craige	modex only work
 *   05-oct-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   15-dec-96  jeffno  Added more modex modes
 *   29-jan-97  jeffno  Mode13 support
 *   30-jan-97  colinmc Bug 5555: Bad DPF
 *   01-feb-97  colinmc Bug 5594: New ModeX modes are dangerous
 *   02-feb-97  toddla  pass driver name to DD16_GetMonitor functions
 *   03-may-98 johnstep NT-specific mode code moved to ddmodent.c
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"


// DX7 introduced a new style of refresh rate testing (for stereo), but we
// had to back away from it in DX8, so rather then using the LOWERTHANDDRAW7
// macro, we have to create our own that takes DX8 into account.

#define NEW_STYLE_REFRESH(x)    \
    (!LOWERTHANDDRAW7(x) && !((x)->lpLcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8))


static DDHALMODEINFO    ddmiModeXModes[] =
{
    #ifdef EXTENDED_MODEX
	{
	    320,    // width (in pixels) of mode
	    175,    // height (in pixels) of mode
	    320,    // pitch (in bytes) of mode
	    8,      // bits per pixel
	    (WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	    0,      // refresh rate
	    0,      // red bit mask
	    0,      // green bit mask
	    0,      // blue bit mask
	    0       // alpha bit mask
	},
    #endif // EXTENDED_MODEX
    {
	320,    // width (in pixels) of mode
	200,    // height (in pixels) of mode
	320,    // pitch (in bytes) of mode
	8,      // bits per pixel
	(WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	0,      // refresh rate
	0,      // red bit mask
	0,      // green bit mask
	0,      // blue bit mask
	0       // alpha bit mask
    },
    {
	320,    // width (in pixels) of mode
	240,    // height (in pixels) of mode
	320,    // pitch (in bytes) of mode
	8,      // bits per pixel
	(WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	0,      // refresh rate
	0,      // red bit mask
	0,      // green bit mask
	0,      // blue bit mask
	0       // alpha bit mask
    },
    #ifdef EXTENDED_MODEX
	{
	    320,    // width (in pixels) of mode
	    350,    // height (in pixels) of mode
	    320,    // pitch (in bytes) of mode
	    8,      // bits per pixel
	    (WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	    0,      // refresh rate
	    0,      // red bit mask
	    0,      // green bit mask
	    0,      // blue bit mask
	    0       // alpha bit mask
	},
        {
	    320,    // width (in pixels) of mode
	    400,    // height (in pixels) of mode
	    320,    // pitch (in bytes) of mode
	    8,      // bits per pixel
	    (WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	    0,      // refresh rate
	    0,      // red bit mask
	    0,      // green bit mask
	    0,      // blue bit mask
	    0       // alpha bit mask
        },
        {
	    320,    // width (in pixels) of mode
	    480,    // height (in pixels) of mode
	    320,    // pitch (in bytes) of mode
	    8,      // bits per pixel
	    (WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	    0,      // refresh rate
	    0,      // red bit mask
	    0,      // green bit mask
	    0,      // blue bit mask
	    0       // alpha bit mask
        },
    #endif // EXTENDED_MODEX
    /*
     * This is the standard VGA 320x200 linear mode. This mode must stay at the
     * end of the modex mode list, or else makeModeXModeIfNeeded might trip up
     * and pick this mode first. We want makeModeXModeIfNeeded to continue to
     * force modex and only modex.
     */
    {
	320,    // width (in pixels) of mode
	200,    // height (in pixels) of mode
	320,    // pitch (in bytes) of mode
	8,      // bits per pixel
	(WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX | DDMODEINFO_STANDARDVGA), // flags
	0,      // refresh rate
	0,      // red bit mask
	0,      // green bit mask
	0,      // blue bit mask
	0       // alpha bit mask
    }
};
#define NUM_MODEX_MODES (sizeof( ddmiModeXModes ) / sizeof( ddmiModeXModes[0] ) )


/*
 * makeModeXModeIfNeeded
 */
static LPDDHALMODEINFO makeModeXModeIfNeeded(
    	LPDDHALMODEINFO pmi,
	LPDDRAWI_DIRECTDRAW_LCL this_lcl )
{
    int			j;
    LPDDHALMODEINFO     pmi_j;

    /*
     * The app compat flags which mean ModeX mode only still mean ModeX mode
     * only. This routine will not substitute a standard VGA mode for a ModeX
     * mode by virtue of the order of these modes in the modex mode table.
     */
    if( (this_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_MODEXONLY) ||
	(dwRegFlags & DDRAW_REGFLAGS_MODEXONLY) )
    {
	for( j=0;j<NUM_MODEX_MODES; j++ )
	{
	    pmi_j = &ddmiModeXModes[j];
	    if( (pmi->dwWidth == pmi_j->dwWidth) &&
		(pmi->dwHeight == pmi_j->dwHeight) &&
		(pmi->dwBPP == pmi_j->dwBPP) &&
		((pmi->wFlags & pmi_j->wFlags) & DDMODEINFO_PALETTIZED ) )
	    {
                DPF(2,"Forcing mode %dx%d into modex", pmi->dwWidth,pmi->dwHeight );
		return pmi_j;
	    }
	}
    }
    return pmi;

} /* makeModeXModeIfNeeded */


/*
 * makeDEVMODE
 *
 * create a DEVMODE struct (and flags) from mode info
 *
 * NOTE: We now always set the exclusive bit here and
 * we always set the bpp. This is because we were
 * previously not setting the bpp when not exclusive
 * so the checking code was always passing the surface
 * if it could do a mode of that size regardless of
 * color depth.
 *
 * The new semantics of EnumDisplayModes is that it
 * gives you a list of all display modes you could
 * switch into if you were exclusive.
 */
void makeDEVMODE(
		LPDDRAWI_DIRECTDRAW_GBL this,
		LPDDHALMODEINFO pmi,
		BOOL inexcl,
		BOOL useRefreshRate,
		LPDWORD pcds_flags,
		LPDEVMODE pdm )
{
    ZeroMemory( pdm, sizeof(*pdm) );
    pdm->dmSize = sizeof( *pdm );
    pdm->dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL;
    if( useRefreshRate && (pmi->wRefreshRate != 0) )
	pdm->dmFields |= DM_DISPLAYFREQUENCY;
    pdm->dmPelsWidth = pmi->dwWidth;
    pdm->dmPelsHeight = pmi->dwHeight;
    pdm->dmBitsPerPel = pmi->dwBPP;
    pdm->dmDisplayFrequency = pmi->wRefreshRate;

    *pcds_flags = CDS_EXCLUSIVE | CDS_FULLSCREEN;

} /* makeDEVMODE */

/*
 * AddModeXModes
 */
void AddModeXModes( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    DWORD               i;
    DWORD               j;
    LPDDHALMODEINFO     pmi_i;
    LPDDHALMODEINFO     pmi_j;
    BOOL                hasmode[NUM_MODEX_MODES];
    DWORD               newmodecnt;
    LPDDHALMODEINFO     pmi;

    for( j=0;j<NUM_MODEX_MODES; j++ )
    {
	hasmode[j] = FALSE;
    }

    /*
     * find out what modes are already supported
     */
    for( i=0;i<pdrv->dwNumModes;i++ )
    {
	pmi_i = &pdrv->lpModeInfo[i];
	for( j=0;j<NUM_MODEX_MODES; j++ )
	{
	    pmi_j = &ddmiModeXModes[j];
	    if( (pmi_i->dwWidth == pmi_j->dwWidth) &&
		(pmi_i->dwHeight == pmi_j->dwHeight) &&
		(pmi_i->dwBPP == pmi_j->dwBPP) &&
		((pmi_i->wFlags & pmi_j->wFlags) & DDMODEINFO_PALETTIZED ) )
	    {
		// There is a mode already in the mode table the same as the modeX mode.
		// check to make sure that the driver really supports it
		DWORD   cds_flags;
		DEVMODE dm;
		int     cds_rc;

		makeDEVMODE( pdrv, pmi_i, TRUE, FALSE, &cds_flags, &dm );

		cds_flags |= CDS_TEST;
		cds_rc = ChangeDisplaySettings( &dm, cds_flags );
		if( cds_rc != 0)
		{
		    // The driver does not support this mode even though it is in the mode table.
		    // Mark the mode as unsupported and go ahead and add the ModeX mode.
		    DPF( 2, "Mode %d not supported (%dx%dx%d), rc = %d, marking invalid", i,
				pmi_i->dwWidth, pmi_i->dwHeight, pmi_i->dwBPP,
				cds_rc );
		    pmi_i->wFlags |= DDMODEINFO_UNSUPPORTED;
		}
		else
		{
		    // Don't add the ModeX mode, the driver supports a linear mode.
		    hasmode[j] = TRUE;
		}
	    }
	}
    }

    /*
     * count how many new modes we need
     */
    newmodecnt = 0;
    for( j=0;j<NUM_MODEX_MODES; j++ )
    {
	if( !hasmode[j] )
	{
	    newmodecnt++;
	}
    }

    /*
     * create new struct
     */
    if( newmodecnt > 0 )
    {
	pmi = MemAlloc( (newmodecnt + pdrv->dwNumModes) * sizeof( DDHALMODEINFO ) );
	if( pmi != NULL )
	{
	    memcpy( pmi, pdrv->lpModeInfo, pdrv->dwNumModes * sizeof( DDHALMODEINFO ) );
	    for( j=0;j<NUM_MODEX_MODES; j++ )
	    {
		if( !hasmode[j] )
		{
		    DPF( 2, "Adding ModeX mode %ldx%ldx%ld (standard VGA flag is %d)",
			    ddmiModeXModes[j].dwWidth,
			    ddmiModeXModes[j].dwHeight,
			    ddmiModeXModes[j].dwBPP,
                            (ddmiModeXModes[j].wFlags &DDMODEINFO_STANDARDVGA) ? 1 : 0);
		    pmi[ pdrv->dwNumModes ] = ddmiModeXModes[j];
		    pdrv->dwNumModes++;
		}
	    }
	    MemFree( pdrv->lpModeInfo );
	    pdrv->lpModeInfo = pmi;
	}
    }
    //
    //  make sure the last mode we validate is the current mode
    //  this works around a Win95 VDD bug.
    //
    (void) ChangeDisplaySettings( NULL, CDS_TEST );
} /* AddModeXModes */

BOOL MonitorCanHandleMode(LPDDRAWI_DIRECTDRAW_GBL this, DWORD width, DWORD height, WORD refreshRate )
{
    DWORD   max_monitor_x;
    DWORD   min_refresh;
    DWORD   max_refresh;

    max_monitor_x = (DWORD)DD16_GetMonitorMaxSize(this->cDriverName);

    if( ( max_monitor_x != 0 ) && ( width > max_monitor_x ) )
    {
	DPF(1, "Mode's width greater than monitor maximum width (%d)", max_monitor_x);
	return FALSE;
    }

    if( refreshRate == 0 )
    {
	// default refresh rate specified, no need to verify it
	return TRUE;
    }

    // a refresh rate was specified, we'd better make sure the monitor can handle it

    if(DD16_GetMonitorRefreshRateRanges(this->cDriverName, (int)width, (int) height, &min_refresh, &max_refresh))
    {
	if( (min_refresh != -1) && (min_refresh != 0) && (refreshRate < min_refresh) )
	{
	    DPF(1, "Requested refresh rate < monitor's minimum refresh rate (%d)", min_refresh);
	    return FALSE;
	}
	if( (min_refresh != -1) && (max_refresh != 0) && (refreshRate > max_refresh) )
	{
	    DPF(1, "Requested refresh rate > monitor's maximum refresh rate (%d)", max_refresh);
	    return FALSE;
	}
    }

    // The monitor likes it.
    return TRUE;
}

/*
 * setSurfaceDescFromMode
 */
static void setSurfaceDescFromMode(
                LPDDRAWI_DIRECTDRAW_LCL this_lcl,
		LPDDHALMODEINFO pmi,
		LPDDSURFACEDESC pddsd
        )
{
    memset( pddsd, 0, sizeof( DDSURFACEDESC ) );
    pddsd->dwSize = sizeof( DDSURFACEDESC );
    pddsd->dwFlags = DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT |
		     DDSD_PITCH | DDSD_REFRESHRATE;
    pddsd->dwHeight = pmi->dwHeight;
    pddsd->dwWidth = pmi->dwWidth;
    pddsd->lPitch = pmi->lPitch;
    pddsd->dwRefreshRate = (DWORD)pmi->wRefreshRate;

    pddsd->ddpfPixelFormat.dwSize = sizeof( DDPIXELFORMAT );
    pddsd->ddpfPixelFormat.dwFlags = DDPF_RGB;
    pddsd->ddpfPixelFormat.dwRGBBitCount = (DWORD)pmi->dwBPP;
    if( pmi->wFlags & DDMODEINFO_PALETTIZED )
    {
	pddsd->ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED8;
    }
    else
    {
	pddsd->ddpfPixelFormat.dwRBitMask = pmi->dwRBitMask;
	pddsd->ddpfPixelFormat.dwGBitMask = pmi->dwGBitMask;
	pddsd->ddpfPixelFormat.dwBBitMask = pmi->dwBBitMask;
	pddsd->ddpfPixelFormat.dwRGBAlphaBitMask = pmi->dwAlphaBitMask;
    }

    if (pmi->wFlags & DDMODEINFO_MODEX)
    {
        /*
         * We only turn on these flags if the app is not hacked to turn them off and
         * the registry hasn't been set to turn them off.
         */
        if ( (!(dwRegFlags & DDRAW_REGFLAGS_NODDSCAPSINDDSD)) && (!(this_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_NODDSCAPSINDDSD)) )
        {
            pddsd->dwFlags |= DDSD_CAPS;
            /*
             * If both MODEX and STANDARDVGA are set in the mode info, then it's
             * a regular VGA mode (i.e. mode 0x13)
             */
            if (pmi->wFlags & DDMODEINFO_STANDARDVGA )
            {
	        pddsd->ddsCaps.dwCaps |= DDSCAPS_STANDARDVGAMODE;
            }
            else
            {
	        pddsd->ddsCaps.dwCaps |= DDSCAPS_MODEX;
            }
        }
    }

} /* setSurfaceDescFromMode */

#undef DPF_MODNAME
#define DPF_MODNAME     "GetDisplayMode"

HRESULT DDAPI DD_GetDisplayMode(
		LPDIRECTDRAW lpDD,
		LPDDSURFACEDESC lpSurfaceDesc )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDHALMODEINFO             pmi;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetDisplayMode");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( !VALIDEX_DDSURFACEDESC2_PTR( lpSurfaceDesc ) &&
	    !VALIDEX_DDSURFACEDESC_PTR( lpSurfaceDesc ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( this->dwModeIndex == DDUNSUPPORTEDMODE)
	{
	    DPF_ERR( "Driver is in an unsupported mode" );
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTEDMODE;
	}
	pmi = &this->lpModeInfo[ this->dwModeIndex ];
	pmi = makeModeXModeIfNeeded( pmi, this_lcl );

        ZeroMemory(lpSurfaceDesc,lpSurfaceDesc->dwSize);
	setSurfaceDescFromMode( this_lcl, pmi, lpSurfaceDesc );

        /*
         * Maintain old behavior..
         */
        if (LOWERTHANDDRAW4(this_int))
        {
            lpSurfaceDesc->dwSize = sizeof(DDSURFACEDESC);
        }
        else
        {
            lpSurfaceDesc->dwSize = sizeof(DDSURFACEDESC2);


        }

        /*
         * set stereo surface caps bits if driver marks mode as stereo mode
         * 
         */
        if ( pmi->wFlags & DDMODEINFO_STEREO &&
            !LOWERTHANDDRAW7(this_int) &&
            VALIDEX_DDSURFACEDESC2_PTR(lpSurfaceDesc)
            )
        {
            LPDDSURFACEDESC2 pddsd2=(LPDDSURFACEDESC2) lpSurfaceDesc;
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_STEREOSURFACELEFT;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetDisplayMode */

#undef DPF_MODNAME
#define DPF_MODNAME     "SetDisplayMode"

/*
 * bumpPriority
 */
static DWORD bumpPriority( void )
{
    DWORD       oldclass;
    HANDLE      hprocess;

    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass( hprocess );
    SetPriorityClass( hprocess, HIGH_PRIORITY_CLASS );
    return oldclass;

} /* bumpPriority */

/*
 * restorePriority
 */
static void restorePriority( DWORD oldclass )
{
    HANDLE      hprocess;

    hprocess = GetCurrentProcess();
    SetPriorityClass( hprocess, oldclass );

} /* restorePriority */

#if 0
static char     szClassName[] = "DirectDrawFullscreenWindow";
static HWND     hWndTmp;
static HCURSOR  hSaveClassCursor;
static HCURSOR  hSaveCursor;
static LONG     lWindowLong;
static RECT     rWnd;

#define         OCR_WAIT_DEFAULT 102

/*
 * curtainsUp
 */
void curtainsUp( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    HCURSOR hcursor= (HCURSOR)LoadImage(NULL,MAKEINTRESOURCE(OCR_WAIT_DEFAULT),IMAGE_CURSOR,0,0,0);

    if( (pdrv_lcl->hWnd != 0) && IsWindow( (HWND) pdrv_lcl->hWnd ) )
    {
	lWindowLong = GetWindowLong( (HWND) pdrv_lcl->hWnd, GWL_EXSTYLE );
	SetWindowLong( (HWND) pdrv_lcl->hWnd, GWL_EXSTYLE, lWindowLong |
				(WS_EX_TOOLWINDOW) );
	hSaveClassCursor = (HCURSOR) GetClassLong( (HWND) pdrv_lcl->hWnd, GCL_HCURSOR );
	SetClassLong( (HWND) pdrv_lcl->hWnd, GCL_HCURSOR, (LONG) hcursor );
	GetWindowRect( (HWND) pdrv_lcl->hWnd, (LPRECT) &rWnd );
	SetWindowPos( (HWND) pdrv_lcl->hWnd, NULL, 0, 0,
	    10000, 10000,
	    SWP_NOZORDER | SWP_NOACTIVATE );
	SetForegroundWindow( (HWND) pdrv_lcl->hWnd );
    }
    else
    {
	WNDCLASS        cls;
	pdrv_lcl->hWnd = 0;
	cls.lpszClassName  = szClassName;
	cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
	cls.hInstance      = hModule;
	cls.hIcon          = NULL;
	cls.hCursor        = hcursor;
	cls.lpszMenuName   = NULL;
	cls.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
	cls.lpfnWndProc    = (WNDPROC)DefWindowProc;
	cls.cbWndExtra     = 0;
	cls.cbClsExtra     = 0;

	RegisterClass(&cls);

	DPF( 4, "*** CREATEWINDOW" );
	hWndTmp = CreateWindowEx(WS_EX_TOPMOST|WS_EX_TOOLWINDOW,
	    szClassName, szClassName,
	    WS_POPUP|WS_VISIBLE, 0, 0, 10000, 10000,
	    NULL, NULL, hModule, NULL);
	DPF( 5, "*** BACK FROM CREATEWINDOW, hwnd=%08lx", hWndTmp );

	if( hWndTmp != NULL)
	{
	    SetForegroundWindow( hWndTmp );
	}
    }
    hSaveCursor = SetCursor( hcursor );

} /* curtainsUp */

/*
 * curtainsDown
 */
void curtainsDown( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    if( (pdrv_lcl->hWnd != 0) && IsWindow( (HWND) pdrv_lcl->hWnd ) )
    {
	SetWindowLong( (HWND) pdrv_lcl->hWnd, GWL_EXSTYLE, lWindowLong );
	SetClassLong( (HWND) pdrv_lcl->hWnd, GCL_HCURSOR, (LONG) hSaveClassCursor );
	SetCursor( hSaveCursor );
	SetWindowPos( (HWND) pdrv_lcl->hWnd, NULL,
	    rWnd.left, rWnd.top,
	    rWnd.right-rWnd.left,
	    rWnd.bottom-rWnd.top,
	    SWP_NOZORDER | SWP_NOACTIVATE );
    }
    else
    {
	SetCursor( hSaveCursor );
	pdrv_lcl->hWnd = 0;
	if( hWndTmp != NULL )
	{
	    DestroyWindow( hWndTmp );
	    UnregisterClass( szClassName, hModule );
	}
    }
    hWndTmp = NULL;

} /* curtainsDown */
#endif

/*
 * stopModeX
 */
static void stopModeX( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    DPF( 4, "***************** Turning off ModeX or standard VGA *****************" );
    ModeX_RestoreMode();

    pdrv->dwFlags &= ~(DDRAWI_MODEX|DDRAWI_STANDARDVGA);
    DPF( 4, "**************** DONE Turning off ModeX or standard VGA *************" );

} /* stopModeX */

/*
 * SetDisplayMode
 */
HRESULT SetDisplayMode(
		LPDDRAWI_DIRECTDRAW_LCL this_lcl,
		DWORD modeidx,
		BOOL force,
		BOOL useRefreshRate)
{
    DWORD                       rc;
    DDHAL_SETMODEDATA           smd;
    LPDDHAL_SETMODE             smfn;
    LPDDHAL_SETMODE             smhalfn;
    LPDDHALMODEINFO             pmi;
    LPDDHALMODEINFO             orig_pmi;
    BOOL                        inexcl;
    BOOL                        emulation;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       oldclass;
    BOOL                        use_modex;
    BOOL                        was_modex;
    DWORD                       real_modeidx;

    /*
     * Signify that the app at least tried to set a mode.
     * Redrawing of the desktop will only happen if this flag is set.
     */
    this_lcl->dwLocalFlags |= DDRAWILCL_MODEHASBEENCHANGED;

    this = this_lcl->lpGbl;

    /*
     * don't allow if surfaces open
     */
    if( !force )
    {
	#ifdef USE_ALIAS
	    /*
	     * See comment on alias stuff in DD_SetDisplayMode2()
	     */
	    if( this->dwWin16LockCnt > 0 )
	    {
		DPF_ERR( "Can't switch modes with locked surfaces holding Win16 lock!" );
		return DDERR_SURFACEBUSY;
	    }
	#else /* USE_ALIAS */
	    if( this->dwSurfaceLockCount > 0 )
	    {
		DPF_ERR( "Can't switch modes with locked surfaces!" );
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */
    }

    if( modeidx == DDUNSUPPORTEDMODE )
    {
	DPF_ERR( "Trying to set to an unsupported mode" );
	return DDERR_UNSUPPORTEDMODE;
    }

    /*
     * is our current mode a disp dib mode?
     */
    was_modex = FALSE;
    orig_pmi = NULL;
    if( this->dwModeIndex != DDUNSUPPORTEDMODE )
    {
	orig_pmi = &this->lpModeInfo[ this->dwModeIndex ];
	orig_pmi = makeModeXModeIfNeeded( orig_pmi, this_lcl );
	if( orig_pmi->wFlags & DDMODEINFO_MODEX )
	{
	    was_modex = TRUE;
	}
    }

    /*
     * is the new mode a mode x mode
     */
    pmi = &this->lpModeInfo[ modeidx ];
    pmi = makeModeXModeIfNeeded( pmi, this_lcl );
    if( pmi->wFlags & DDMODEINFO_MODEX )
    {
	DPF( 5, "Mode %ld is a ModeX or standard VGA mode", modeidx);
	use_modex = TRUE;
    }
    else
    {
	use_modex = FALSE;
    }

    /*
     * don't re-set the mode to the same one...
     * NOTE: we ALWAYS set the mode in emulation on Win95 since our index could be wrong
     */
    if( modeidx == this->dwModeIndex && !(this->dwFlags & DDRAWI_NOHARDWARE) )
    {
	DPF( 5, "%08lx: Current Mode match: %ldx%ld, %dbpp", GetCurrentProcessId(),
			pmi->dwWidth, pmi->dwHeight, pmi->dwBPP );
	return DD_OK;
    }

    DPF( 5, "***********************************************" );
    DPF( 5, "*** SETDISPLAYMODE: %ldx%ld, %dbpp", pmi->dwWidth, pmi->dwHeight, pmi->dwBPP );
    DPF( 5, "*** dwModeIndex (current) = %ld", this->dwModeIndex );
    DPF( 5, "*** modeidx (new) = %ld", modeidx );
    DPF( 5, "*** use_modex = %ld", use_modex );
    DPF( 5, "*** was_modex = %ld", was_modex );
    DPF( 5, "***********************************************" );

    /*
     * check if in exclusive mode
     */
    inexcl = (this->lpExclusiveOwner == this_lcl);

    /*
     * check bpp
     */
    if( (this->dwFlags & DDRAWI_DISPLAYDRV) && !force )
    {
	DWORD dwBPP;

	if( NULL == orig_pmi )
	{
	    /*
	     * This is branch is taken if we are currently running in an unsupported
	     * mode.
	     */
	    DDASSERT( 0UL != this_lcl->hDC );
	    dwBPP = ( GetDeviceCaps( (HDC)( this_lcl->hDC ), BITSPIXEL ) *
		      GetDeviceCaps( (HDC)( this_lcl->hDC ), PLANES ) );
	}
	else
	{
	    dwBPP = orig_pmi->dwBPP;
	}

	if( (dwBPP != pmi->dwBPP) || ((dwBPP == pmi->dwBPP) && use_modex ) )
	{
	    if( !inexcl || !(this->dwFlags & DDRAWI_FULLSCREEN) )
	    {
		DPF_ERR( "Can't change BPP if not in exclusive fullscreen mode" );
		return DDERR_NOEXCLUSIVEMODE;
	    }
	}
    }

    /*
     * see if we need to shutdown modex mode
     */
    if( was_modex )
    {
	stopModeX( this );
    }

    /*
     * see if we need to set a modex mode
     */
    if( use_modex )
    {
	DWORD                   i;
	LPDDHALMODEINFO         tmp_pmi;

	real_modeidx = modeidx;
	for( i=0;i<this->dwNumModes;i++ )
	{
	    tmp_pmi = &this->lpModeInfo[ i ];
	    if( (tmp_pmi->dwWidth == 640) &&
		(tmp_pmi->dwHeight == 480) &&
		(tmp_pmi->dwBPP == 8) &&
		(tmp_pmi->wFlags & DDMODEINFO_PALETTIZED) )
	    {
		DPF( 5, "MODEX or Standard VGA: Setting to 640x480x8 first (index=%ld)", i );
		modeidx = i;
		break;
	    }
	}
	if( i == this->dwNumModes )
	{
	    DPF( 0, "Mode not supported" );
	    return DDERR_INVALIDMODE;
	}
    }
    /*
     * get the driver to set the new mode...
     */
    if( ( this->dwFlags & DDRAWI_DISPLAYDRV ) ||
	( this->dwFlags & DDRAWI_NOHARDWARE ) ||
	( this_lcl->lpDDCB->cbDDCallbacks.SetMode == NULL ) )
    {
	smfn = this_lcl->lpDDCB->HELDD.SetMode;
	smhalfn = smfn;
	emulation = TRUE;

    // If this DDraw object was created for a particular device, explicitly,
    // and we're using the HEL (which we will be except on non-display
    // devices), then stuff the this_lcl pointer into ddRVal so we can
    // check the EXPLICITMONITOR flag from mySetMode.
    smd.ddRVal = (HRESULT) this_lcl;

    DPF( 4, "Calling HEL SetMode" );
    }
    else
    {
	smhalfn = this_lcl->lpDDCB->cbDDCallbacks.SetMode;
	smfn = this_lcl->lpDDCB->HALDD.SetMode;
	emulation = FALSE;
    }
    if( smhalfn != NULL )
    {
	DWORD   oldmode;
	BOOL    didsetmode;

	/*
	 * set the mode if this isn't a modex mode, or if it is a modex
	 * mode but wasn't one before
	 */
	if( !use_modex || (use_modex && !was_modex) )
	{
	    smd.SetMode = smhalfn;
	    smd.lpDD = this;
	    smd.dwModeIndex = modeidx;
	    smd.inexcl = inexcl;
	    smd.useRefreshRate = useRefreshRate;
	    this->dwFlags |= DDRAWI_CHANGINGMODE;
	    oldclass = bumpPriority();
	    DOHALCALL( SetMode, smfn, smd, rc, emulation );
	    restorePriority( oldclass );
	    this->dwFlags &= ~DDRAWI_CHANGINGMODE;
	    didsetmode = TRUE;
	}
	else
	{
	    rc = DDHAL_DRIVER_HANDLED;
	    smd.ddRVal = DD_OK;
	    didsetmode = FALSE;
	}
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( smd.ddRVal == DD_OK )
	    {
		oldmode = this->dwModeIndexOrig; // save original mode index
		if( didsetmode )
		{
                    CleanupD3D8(this, FALSE, 0);
                    FetchDirectDrawData( this, TRUE, 0, GETDDVXDHANDLE( this_lcl ), NULL, 0 , this_lcl );
                    this->dwModeIndex = modeidx;
                    this_lcl->dwPreferredMode = modeidx;
                    DPF(5,"Preferred mode index is %d, desired mode is %d",this_lcl->dwPreferredMode,modeidx);
		    this->dwModeIndexOrig = oldmode;

                    /*
                     * Some drivers will re-init the gamma ramp on a mode
                     * change, so if we previously set a new gamma ramp,
                     * we'll set it again.
                     */
                    if( ( this_lcl->lpPrimary != NULL ) &&
                        ( this_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) &&
                        ( this_lcl->lpPrimary->lpLcl->dwFlags & DDRAWISURF_SETGAMMA ) )
                    {
                        SetGamma( this_lcl->lpPrimary->lpLcl, this_lcl );
                    }

		    /*
		     * It is possible that calling ChangeDisplaySettings could
		     * generate a WM_ACTIVATE app message to the app telling
		     * it to deactivate, which would cause RestoreDisplaymode
		     * to be called before we setup the new mode index.  In this
		     * case, it would not actually restore the mode but it would
		     * clear the MODEHASBEENCHANGEDFLAG, insuring that we could
                     * never restore the original mode.  The simple workaround
		     * it to set this flag again.
		     */
		    this_lcl->dwLocalFlags |= DDRAWILCL_MODEHASBEENCHANGED;
                    /*
                     * The driver local's DC will have been invalidated (DCX_CLIPCHILDREN set) by the
                     * mode switch, if it occurred via ChangeDisplaySettigs. Record this fact so the emulation
                     * code can decide to reinit the device DC.
                     */
		    this_lcl->dwLocalFlags |= DDRAWILCL_DIRTYDC;
		}

		/*
		 * now set modex mode
		 */
		if( use_modex )
		{
		    extern void HELStopDCI( void );
		    DPF( 4, "********************** Setting MODEX or STANDARD VGA MODE **********************" );

		    if( this->dwFlags & DDRAWI_ATTACHEDTODESKTOP )
		    {
		        HELStopDCI();
		    }

                    ModeX_SetMode( (UINT)pmi->dwWidth, (UINT)pmi->dwHeight, (UINT) (pmi->wFlags & DDMODEINFO_STANDARDVGA) );
		    /*
		     * ModeX now active, program our driver object and return
		     */
		    /*
		     * We know this code can only ever be called from an application
		     * thread so we don't have to worry about using DDHELP's VXD handle.
		     */
                    fetchModeXData( this, pmi, (HANDLE) this_lcl->hDDVxd );
		    this->dwModeIndex = real_modeidx;
		    this_lcl->dwPreferredMode = real_modeidx;
		    this->dwModeIndexOrig = oldmode;
		    DPF( 4, "********************** Done Setting MODEX MODE **********************" );

		    /*
		     * It is possible that calling ChangeDisplaySettings could
		     * generate a WM_ACTIVATE app message to the app telling
		     * it to deactivate, which would cause RestoreDisplaymode
		     * to be called before we setup the new mode index.  In this
		     * case, it would not actually restore the mode but it would
		     * clear the MODEHASBEENCHANGEDFLAG, insuring that we could
		     * never restore the origainl mode.  The simple workaround
		     * it to set this flag again.
		     */
		    this_lcl->dwLocalFlags |= DDRAWILCL_MODEHASBEENCHANGED;

		    return DD_OK;

		}
	    }
	    return smd.ddRVal;
	}
    }

    return DDERR_UNSUPPORTED;

} /* SetDisplayMode */

/*
 * DD_SetDisplayMode
 */
HRESULT DDAPI DD_SetDisplayMode(
		LPDIRECTDRAW lpDD,
		DWORD dwWidth,
		DWORD dwHeight,
		DWORD dwBPP )
{
    DPF(2,A,"ENTERAPI: DD_SetDisplayMode");

    DPF(4,"DD1 setdisplay mode called");
    return DD_SetDisplayMode2(lpDD,dwWidth,dwHeight,dwBPP,0,0);
} /* DD_SetDisplayMode */

/*
 * DD_SetDisplayMode2
 */
HRESULT DDAPI DD_SetDisplayMode2(
		LPDIRECTDRAW lpDD,
		DWORD dwWidth,
		DWORD dwHeight,
		DWORD dwBPP,
		DWORD dwRefreshRate,
                DWORD dwFlags)
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    int                         i;
    int                         j;
    LPDDHALMODEINFO             pmi;
    HRESULT                     ddrval;
    int                         iChosenMode;
    DWORD                       dwNumberOfTempModes;

    typedef struct
    {
        DDHALMODEINFO               mi;
        int                         iIndex;
    }TEMP_MODE_LIST;

    TEMP_MODE_LIST * pTempList=0;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_SetDisplayMode2");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	/*
	 * Check for invalid flags
	 */
	if( dwFlags & ~ DDSDM_VALID)
	{
	    DPF_ERR( "Invalid flags specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	#ifdef USE_ALIAS
	    /*
	     * Behaviour change. Previously we did not allow a mode switch
	     * if any video memory (or implicit system memory) surfaces
	     * were locked. However, we not allow mode switches for
	     * locked VRAM surfaces as long as they don't have the Win16
	     * lock (in which case this code is irrelevant as the DirectDraw
	     * critical section will prevent them ever hitting this code).
	     * So the behaviour is now that if vram surface are locked but
	     * are not holding the Win16 lock they can mode switch away.
	     * If however, we have Win16 locked VRAM surfaces then they can't
	     * mode switch. This should only have any effect if the application
	     * holding the locks attempts the mode switch. In which case,
	     * previously it would fail if it had any VRAM or implicit system
	     * memory surfaces locked whereas now it will only fail if it has
	     * the primary or other unaliased VRAM surface locked.
	     */
	    if( this->dwWin16LockCnt > 0 )
	    {
		DPF_ERR( "Can't switch modes with locked surfaces holding Win16 lock!" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#else /* USE_ALIAS */
	    /*
	     * don't allow change if surfaces are locked
	     */
	    if( this->dwSurfaceLockCount )
	    {
		DPF_ERR( "Surfaces are locked, can't switch the mode" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */

	/*
	 * don't allow change if some other process has exclusive mode
	 */
	if( (this->lpExclusiveOwner != NULL) &&
	    (this->lpExclusiveOwner != this_lcl ) )
	{
	    DPF_ERR( "Can't change mode; exclusive mode not owned" );
	    LEAVE_DDRAW();
	    return DDERR_NOEXCLUSIVEMODE;
	}

        /*
         * Modes are now chosen in a 3-step process:
         * -Build a temporary list of modes which match the desired spatial and color resolutions
         * -Sort this list into ascending refresh rate order.
         * -Select from this list the rate which best matches what we want.
         */

        if( (this_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_MODEXONLY) ||
	    (dwRegFlags & DDRAW_REGFLAGS_MODEXONLY) )
        {
            /*
             * Don't allow VGA mode if ModeX only.
             * Note if either of these flags are set, there won't actually be a VGA mode in the
             * table, so we wouldn't match it anyway. The problem comes in when makeModeXModeIfNeeded
             * overrides an accelerated mode. The duplication-check loop below will attempt to
             * skip the newly modex 320x200x8 since it doesn't match the VGA 320x200x8 which it is expecting later in
             * the table. That VGA mode won't be in the table, so the dupe check code skips the mode we
             * actually wanted (since we are forcing to modex). If we turn off the app's request for
             * VGA, then that dupe check won't be made, and we should pick up the modex mode.
             */
            DPF(2,"Turning off request for standard VGA due to ModeX override");
            dwFlags &= ~DDSDM_STANDARDVGAMODE;
        }

        /*
         * Step 1. Build a list of modes which match the desired spatial and color resolutions
         */
        pTempList = (TEMP_MODE_LIST*) MemAlloc(this->dwNumModes * sizeof(TEMP_MODE_LIST));
        if (0 == pTempList)
        {
            LEAVE_DDRAW();
            return DDERR_OUTOFMEMORY;
        }

        dwNumberOfTempModes=0;
	DPF( 5, "Looking for %ldx%ldx%ld", dwWidth, dwHeight, dwBPP );
        for(i = 0;i <(int) (this->dwNumModes);i++)
        {
	    pmi = &this->lpModeInfo[i];
	    pmi = makeModeXModeIfNeeded( pmi, this_lcl );

	    DPF( 5, "Found %ldx%ldx%ldx (flags = %ld)", pmi->dwWidth, pmi->dwHeight, pmi->dwBPP, pmi->wFlags );

	    if( (pmi->dwWidth == dwWidth) &&
		(pmi->dwHeight == dwHeight) &&
		((DWORD)pmi->dwBPP == dwBPP) &&
		((pmi->wFlags & DDMODEINFO_UNSUPPORTED) == 0) &&
                (!LOWERTHANDDRAW7(this_int) || !(pmi->wFlags & DDMODEINFO_DX7ONLY)) )
            {
                /*
                 * The behaviour is that linear modes override ModeX modes
                 * and standard VGA modes. If the app sets
                 * DDSDM_STANDARDVGAMODE even when a linear mode has replaced
                 * both the modex and mode13 modes, then we will IGNORE the app's
                 * request for VGA and run with the linear mode. This most closely
                 * matches the ModeX behaviour.
                 * If there's an accelerated 320x200 mode, then there will be neither
                 * the modex nor the VGA mode in the mode table. If there's no accelerated
                 * mode, then there will be both modex and vga modes in the list.
                 * Therefore, if the app specified VGA, we only pay attention to them
                 * and ignore a 320x200x8 mode if it is a modex mode.
                 */
                if ( (dwFlags & DDSDM_STANDARDVGAMODE)
                    && (pmi->wFlags & DDMODEINFO_MODEX) && ((pmi->wFlags & DDMODEINFO_STANDARDVGA)==0) )
                {
                    /*
                     * App wants a standard VGA mode, but this mode is mode X. Move on.
                     */
                    continue;

                }

                if(!(this->dwFlags & DDRAWI_DISPLAYDRV ))
                {
                    if (pmi->wFlags & DDMODEINFO_DX7ONLY)
                    {
                        //
                        // Can't pass generated modes to non-display drivers
                        // because they actually get the index, and a generated
                        // mode's index would be beyond the end of their table.
                        //
                        
                        continue;
                    }
                }

                pTempList[dwNumberOfTempModes].mi = *pmi;
                pTempList[dwNumberOfTempModes].iIndex = i;
                dwNumberOfTempModes++;
            }
        }
        if (0 == dwNumberOfTempModes)
        {
            MemFree(pTempList);
	    LEAVE_DDRAW();
	    DPF( 0,"Mode not found... No match amongst available spatial and color resolutions (wanted %dx%dx%d)",dwWidth,dwHeight,dwBPP );
	    return DDERR_INVALIDMODE;
	}

        for(i=0;i<(int)dwNumberOfTempModes;i++)
            DPF(5,"Copied mode list element %d:%dx%dx%d@%d",i,
                pTempList[i].mi.dwWidth,
                pTempList[i].mi.dwHeight,
                pTempList[i].mi.dwBPP,
                pTempList[i].mi.wRefreshRate);

        /*
         * Step 2. Sort list into ascending refresh order
         * Bubble sort
         * Note this does nothing if there's only one surviving mode.
         */
        for (i=0;i<(int)dwNumberOfTempModes;i++)
        {
            for (j=(int)dwNumberOfTempModes-1;j>i;j--)
            {
                if (pTempList[i].mi.wRefreshRate > pTempList[j].mi.wRefreshRate)
                {
                    TEMP_MODE_LIST temp = pTempList[i];
                    pTempList[i] = pTempList[j];
                    pTempList[j] = temp;
                }
            }
        }

        for(i=0;i<(int)dwNumberOfTempModes;i++)
            DPF(5,"Sorted mode list element %d:%dx%dx%d@%d",i,
                pTempList[i].mi.dwWidth,
                pTempList[i].mi.dwHeight,
                pTempList[i].mi.dwBPP,
                pTempList[i].mi.wRefreshRate);

        /*
         * Step 3. Find the rate we're looking for.
         * There are three cases.
         * 1:Looking for a specific refresh
         * 2a:Not looking for a specific refresh and stepping down in spatial resolution
         * 2a:Not looking for a specific refresh and stepping up in spatial resolution
         */
        iChosenMode = -1;

        if (dwRefreshRate)
        {
            /* case 1 */
            DPF(5,"App wants rate of %d",dwRefreshRate);
            for (i=0;i<(int)dwNumberOfTempModes;i++)
            {
                /*
                 * We'll never match a zero (hardware default) rate here,
                 * but if there's only one rate which has refresh=0
                 * the app will never ask for a non-zero rate, because it will
                 * never have seen one at enumerate time.
                 */
                if ( (DWORD) (pTempList[i].mi.wRefreshRate) == dwRefreshRate )
                {
                    iChosenMode=pTempList[i].iIndex;
                    break;
                }
            }
        }
        else
        {
            /*
             * Case 2b: Going up in spatial resolution, so just pick the
	     * lowest rate (earliest in list) which isn't a hardware
	     * default, unless no such rate exists.
             */
            iChosenMode=pTempList[0].iIndex;
        }

        if (-1 == iChosenMode)
        {
            MemFree(pTempList);
	    LEAVE_DDRAW();
	    DPF( 0,"Mode not found... No match amongst available refresh rates (wanted %dx%dx%d@%d)",dwWidth,dwHeight,dwBPP,dwRefreshRate);
	    return DDERR_INVALIDMODE;
	}

        MemFree(pTempList);

	pmi = &this->lpModeInfo[iChosenMode];

	/*
	 * only allow ModeX modes if the cooplevel is ok
	 */
	if( (pmi->wFlags & DDMODEINFO_MODEX) && !(this_lcl->dwLocalFlags & DDRAWILCL_ALLOWMODEX) )
	{
	    LEAVE_DDRAW();
	    DPF( 0,"must set DDSCL_ALLOWMODEX to use ModeX or Standard VGA modes" );
	    return DDERR_INVALIDMODE;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    // See if the monitor likes it.  If using an interface older than DX7,
    // we check using the old way; otherwise, we check using the new way
    if( !NEW_STYLE_REFRESH( this_int ) )
    {
        if( !(pmi->wFlags & DDMODEINFO_MODEX) && !MonitorCanHandleMode(this, pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate) )
        {
            // Monitor doesn't like it
            LEAVE_DDRAW();
            DPF_ERR("Mode not compatible with monitor");
            return DDERR_INVALIDMODE;
        }
    }
    else if( !(pmi->wFlags & DDMODEINFO_MODEX) )
    {
        if( !MonitorCanHandleMode(this, pmi->dwWidth, pmi->dwHeight, 0) ||
            !CanMonitorHandleRefreshRate( this, pmi->dwWidth, pmi->dwHeight, 
            //Only pass a refresh rate if the app asked for one (otherwise, asking for 0
            //will cause us to pass the first wRefreshRate in the mode table).
            dwRefreshRate ? pmi->wRefreshRate : 0 ) ) 
        {
            // Monitor doesn't like it
            LEAVE_DDRAW();
            DPF_ERR("Mode not compatible with monitor");
            return DDERR_INVALIDMODE;
        }
    }

    /*
     * set the display mode, and pay attention to refresh rate if we were asked to.
     * Always pay attention to rate on NT.
     * NOTE!!! This is a very slight change from what we did in released DX2!!!
     * - This function is now called from DD_SetDisplayMode with a refresh rate of 0,
     *   so we check for that circumstance and use it to say to the driver wether
     *   or not to pay attention to the refresh rate. Fine. However, now when
     *   someone calls DD_SetDisplayMode2 with a refresh rate of 0, we tell
     *   the driver to ignore the rate, when before we were telling the driver
     *   to force to some rate we found in the mode table (which would have been
     *   the first mode which matched resolution in the list... probably the lowest
     *   refresh rate).
     */
    #if 1 //def WIN95
        if (0 == dwRefreshRate)
            ddrval = SetDisplayMode( this_lcl, iChosenMode, FALSE, FALSE );
        else
    #endif
        ddrval = SetDisplayMode( this_lcl, iChosenMode, FALSE, TRUE );

    LEAVE_DDRAW();
    return ddrval;

} /* DD_SetDisplayMode2 */

#undef DPF_MODNAME
#define DPF_MODNAME     "RestoreDisplayMode"

/*
 * RestoreDisplayMode
 *
 * For use by DD_RestoreDisplayMode & internally.
 * Must be called with driver lock taken
 */
HRESULT RestoreDisplayMode( LPDDRAWI_DIRECTDRAW_LCL this_lcl, BOOL force )
{
    DWORD                       rc;
    DDHAL_SETMODEDATA           smd;
    BOOL                        inexcl;
    DWORD                       pid;
    LPDDHAL_SETMODE             smfn;
    LPDDHAL_SETMODE             smhalfn;
    BOOL                        emulation;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       oldclass;
    BOOL                        was_modex;
    LPDDHALMODEINFO             pmi;

    DPF(2,A,"ENTERAPI: DD_RestoreDisplayMode");

    this = this_lcl->lpGbl;
    #ifdef DEBUG
    	if( DDUNSUPPORTEDMODE != this->dwModeIndexOrig )
	{
            DPF(5,"Restoring Display mode to index %d, %dx%dx%d@%d",this->dwModeIndexOrig,
                this->lpModeInfo[this->dwModeIndexOrig].dwWidth,
                this->lpModeInfo[this->dwModeIndexOrig].dwHeight,
                this->lpModeInfo[this->dwModeIndexOrig].dwBPP,
                this->lpModeInfo[this->dwModeIndexOrig].wRefreshRate);
	}
	else
	{
	    DPF(5,"Restoring Display mode to a non-DirectDraw mode");
	}
    #endif /* DEBUG */

    if (0 == (this_lcl->dwLocalFlags & DDRAWILCL_MODEHASBEENCHANGED) )
    {
        /*
         * This app never made a mode change, so we ignore the restore, in case someone switch desktop
         * modes while playing a movie in a window, for instance. We do it before the redraw window
         * so that we don't flash icons when a windowed app exits.
         */
	DPF( 2, "Mode was never changed by this app" );
	return DD_OK;
    }

    /*
     * we ALWAYS set the mode in emulation on Win95 since our index could be wrong
     */
    if( ( (this->dwModeIndex == this->dwModeIndexOrig) &&
	!(this->dwFlags & DDRAWI_NOHARDWARE) ) || (this->lpModeInfo==NULL) )
    {
	DPF( 2, "Mode wasn't changed" );
        RedrawWindow( NULL, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN );
        /*
         * Scenario: Start an app that can do windowed<->fullscreen transitions. Start windowed.
         * Go fullscreen (sets MODEHASBEENCHANGED). Go windowed. Use control panel to
         * change display settings. Exit app. Original mode will be restored.
         * If we reset this flag, that won't happen.
         */
        this_lcl->dwLocalFlags &= ~DDRAWILCL_MODEHASBEENCHANGED;

	return DD_OK;
    }


    DPF( 4, "In RestoreDisplayMode" );

    pid = GetCurrentProcessId();

    /*
     * don't allow mode change if surfaces are locked
     */
    if( !force )
    {
	#ifdef USE_ALIAS
	    /*
	     * See comment on aliasing in DD_ResetDisplayMode()
	     */
	    if( this->dwWin16LockCnt > 0 )
	    {
		DPF_ERR( "Can't switch modes with locked surfaces holding Win16 lock!" );
		return DDERR_SURFACEBUSY;
	    }
	#else /* USE_ALIAS */
	    if( this->dwSurfaceLockCount > 0 )
	    {
		DPF( 0, "Can't switch modes with locked surfaces!" );
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */
    }

    /*
     * see if we're in exclusive mode
     */
    if( force )
    {
	inexcl = TRUE;
    }
    else
    {
	inexcl = (this->lpExclusiveOwner == this_lcl);
    }

    /*
     * check bpp
     */
    pmi = &this->lpModeInfo[ this->dwModeIndex ];
    pmi = makeModeXModeIfNeeded( pmi, this_lcl );
    if( pmi->wFlags & DDMODEINFO_MODEX )
    {
	was_modex = TRUE;
    }
    else
    {
	was_modex = FALSE;
    }

    /*
     * turn off modex first...
     */
    if( was_modex )
    {
	stopModeX( this );
    }

    /*
     * get the driver to restore the mode...
     */
    if( ( this->dwFlags & DDRAWI_DISPLAYDRV ) ||
	( this->dwFlags & DDRAWI_NOHARDWARE ) ||
	( this_lcl->lpDDCB->cbDDCallbacks.SetMode == NULL ) )
    {
	smfn = this_lcl->lpDDCB->HELDD.SetMode;
	smhalfn = smfn;
	emulation = TRUE;

    // Store the this_lcl so we can check for multimon-aware in mySetMode
    smd.ddRVal = (HRESULT) this_lcl;
    }
    else
    {
	smhalfn = this_lcl->lpDDCB->cbDDCallbacks.SetMode;
	smfn = this_lcl->lpDDCB->HALDD.SetMode;
	emulation = FALSE;
    }
    if( smhalfn != NULL )
    {
	smd.SetMode = smhalfn;
	smd.lpDD = this;
        smd.dwModeIndex = (DWORD) -1;
	smd.inexcl = inexcl;
	smd.useRefreshRate = TRUE;
        this->dwFlags |= DDRAWI_CHANGINGMODE;
	oldclass = bumpPriority();

        // Store the this_lcl so we can check for multimon-aware in mySetMode
        smd.ddRVal = (HRESULT) this_lcl;

	DOHALCALL( SetMode, smfn, smd, rc, emulation );
	restorePriority( oldclass );
	this->dwFlags &= ~DDRAWI_CHANGINGMODE;

	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( smd.ddRVal != DD_OK )
	    {
		/*
		 * Scenario: Laptop boots w/ external monitor, switch to
		 * 10x7 mode.  Shutdown, unplug the monitor, reboot.  Mode
		 * is 640x480 but registry says it's 10x7.  Run a low-res
		 * game, we call ChangeDisplaySettings(NULL), which tries
		 * to restore things according to the registry, so it
		 * fails.  The result is we stay in low-res mode, which
		 * pretty much means we have to reboot.
		 *
		 * To work around this, we will explixitly set the mode that
		 * we started in.
		 */
		smd.dwModeIndex = this->dwModeIndexOrig;
                this->dwFlags |= DDRAWI_CHANGINGMODE;
		oldclass = bumpPriority();
	        smd.lpDD = this;
		DOHALCALL( SetMode, smfn, smd, rc, emulation );
		restorePriority( oldclass );
		this->dwFlags &= ~DDRAWI_CHANGINGMODE;
	    }
	    if( smd.ddRVal == DD_OK )
	    {
		DPF( 5, "RestoreDisplayMode: Process %08lx Mode = %ld", GETCURRPID(), this->dwModeIndex );
                CleanupD3D8(this, FALSE, 0);
                FetchDirectDrawData( this, TRUE, 0, GETDDVXDHANDLE( this_lcl ), NULL, 0 , this_lcl );

                /*
                 * Some drivers will re-init the gamma ramp on a mode
                 * change, so if we previously set a new gamma ramp,
                 * we'll set it again.
                 */
                if( ( this_lcl->lpPrimary != NULL ) &&
                    ( this_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) &&
                    ( this_lcl->lpPrimary->lpLcl->dwFlags & DDRAWISURF_SETGAMMA ) )
                {
                    SetGamma( this_lcl->lpPrimary->lpLcl, this_lcl );
                }

                /*
                 * Scenario: Start an app that can do windowed<->fullscreen transitions. Start windowed.
                 * Go fullscreen (sets MODEHASBEENCHANGED). Go windowed. Use control panel to
                 * change display settings. Exit app. Original mode will be restored.
                 * If we reset this flag, that won't happen.
                 */
                this_lcl->dwLocalFlags &= ~DDRAWILCL_MODEHASBEENCHANGED;

                /*
                 * The driver local's DC will have been invalidated (DCX_CLIPCHILDREN set) by the
                 * mode switch, if it occurred via ChangeDisplaySettigs. Record this fact so the emulation
                 * code can decide to reinit the device DC.
                 */
		this_lcl->dwLocalFlags |= DDRAWILCL_DIRTYDC;

		if( this->dwFlags & DDRAWI_DISPLAYDRV )
		{
                    DPF(4,"Redrawing all windows");
		    RedrawWindow( NULL, NULL, NULL, RDW_INVALIDATE | RDW_ERASE |
				     RDW_ALLCHILDREN );
		}
	    }
	    return smd.ddRVal;
	}
    }

    return DDERR_UNSUPPORTED;

} /* RestoreDisplayMode */

/*
 * DD_RestoreDisplayMode
 *
 * restore mode
 */
HRESULT DDAPI DD_RestoreDisplayMode( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    HRESULT                     ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_RestoreDisplayMode");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	/*
	 * switching to the same mode?
	 */
	if( this->dwModeIndex == this->dwModeIndexOrig )
	{
	    LEAVE_DDRAW();
	    return DD_OK;
	}

	/*
	 * don't allow change if some other process has exclusive mode
	 */
	if( (this->lpExclusiveOwner != NULL) &&
	    (this->lpExclusiveOwner != this_lcl ) )
	{
	    DPF_ERR( "Can't change mode; exclusive mode owned" );
	    LEAVE_DDRAW();
	    return DDERR_NOEXCLUSIVEMODE;
	}

	#ifdef USE_ALIAS
	    /*
	     * Behaviour change. Previously we did not allow a mode switch
	     * if any video memory (or implicit system memory) surfaces
	     * were locked. However, we not allow mode switches for
	     * locked VRAM surfaces as long as they don't have the Win16
	     * lock (in which case this code is irrelevant as the DirectDraw
	     * critical section will prevent them ever hitting this code).
	     * So the behaviour is now that if vram surface are locked but
	     * are not holding the Win16 lock they can mode switch away.
	     * If however, we have Win16 locked VRAM surfaces then they can't
	     * mode switch. This should only have any effect if the application
	     * holding the locks attempts the mode switch. In which case,
	     * previously it would fail if it had any VRAM or implicit system
	     * memory surfaces locked whereas now it will only fail if it has
	     * the primary or other unaliased VRAM surface locked.
	     *
	     * !!! NOTE: My gut feeling is that this should have no impact on
	     * anyone. However, we need to pull it and see.
	     */
	    if( this->dwWin16LockCnt > 0 )
	    {
		DPF_ERR( "Can't switch modes with locked surfaces holding Win16 lock!" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#else /* USE_ALIAS */
	    /*
	     * don't allow change if surfaces are locked
	     */
	    if( this->dwSurfaceLockCount )
	    {
		DPF_ERR( "Surfaces are locked, can't switch the mode" );
		LEAVE_DDRAW();
		return DDERR_SURFACEBUSY;
	    }
	#endif /* USE_ALIAS */
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }


    ddrval = RestoreDisplayMode( this_lcl, FALSE );
    if( ddrval == DD_OK )
    {
	this_lcl->dwPreferredMode = this->dwModeIndex;
	DPF( 5, "Preferred mode is now %ld", this_lcl->dwPreferredMode );
    }

    LEAVE_DDRAW();
    return ddrval;

} /* DD_RestoreDisplayMode */

#undef DPF_MODNAME
#define DPF_MODNAME     "EnumDisplayModes"

/*
 * DD_EnumDisplayModes
 */
HRESULT DDAPI DD_EnumDisplayModes(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPDDSURFACEDESC lpDDSurfaceDesc,
		LPVOID lpContext,
		LPDDENUMMODESCALLBACK lpEnumCallback )
{
    DPF(2,A,"ENTERAPI: DD_EnumDisplayModes");

    if( lpDDSurfaceDesc != NULL )
    {
        DDSURFACEDESC2 ddsd2 = {sizeof(ddsd2)};

        ZeroMemory(&ddsd2,sizeof(ddsd2));

        TRY
        {
	    if( !VALID_DIRECTDRAW_PTR( ((LPDDRAWI_DIRECTDRAW_INT)lpDD) ) )
	    {
	        return DDERR_INVALIDOBJECT;
	    }
	        if( !VALID_DDSURFACEDESC_PTR( lpDDSurfaceDesc ) )
	    {
	        DPF_ERR( "Invalid surface description. Did you set the dwSize member?" );
                DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	        return DDERR_INVALIDPARAMS;
	    }

            memcpy(&ddsd2,lpDDSurfaceDesc,sizeof(*lpDDSurfaceDesc));
        }
        EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            DPF_ERR( "Exception encountered validating parameters: Bad LPDDSURFACEDESC" );
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	    return DDERR_INVALIDPARAMS;
        }

        ddsd2.dwSize = sizeof(ddsd2);
        return DD_EnumDisplayModes4(lpDD,dwFlags,&ddsd2,lpContext, (LPDDENUMMODESCALLBACK2) lpEnumCallback);
    }

    return DD_EnumDisplayModes4(lpDD,dwFlags,NULL,lpContext,(LPDDENUMMODESCALLBACK2)lpEnumCallback);
}
HRESULT DDAPI DD_EnumDisplayModes4(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPDDSURFACEDESC2 lpDDSurfaceDesc,
		LPVOID lpContext,
		LPDDENUMMODESCALLBACK2 lpEnumCallback )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       rc;
    DDSURFACEDESC2              ddsd;
    LPDDHALMODEINFO             pmi;
    int                         i, j;
    BOOL                        inexcl;
    BOOL                        bUseRefreshRate = FALSE;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_EnumDisplayModes4");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	if( lpDDSurfaceDesc != NULL )
	{
	    if( !VALID_DDSURFACEDESC2_PTR(lpDDSurfaceDesc) )
	    {
		DPF_ERR( "Invalid surface description" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

	if ( dwFlags & ~DDEDM_VALID)
	{
	    DPF_ERR( "Invalid flags") ;
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
	{
	    DPF_ERR( "Invalid enum. callback routine" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * see if we're in exclusive mode
     */
    inexcl = (this->lpExclusiveOwner == this_lcl);

    if( (this_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_MODEXONLY) ||
	(dwRegFlags & DDRAW_REGFLAGS_MODEXONLY) )
    {
        /*
         * Don't allow VGA mode if ModeX only.
         * Note if either of these flags are set, there won't actually be a VGA mode in the
         * table, so we wouldn't match it anyway. The problem comes in when makeModeXModeIfNeeded
         * overrides an accelerated mode. The duplication-check loop below will attempt to
         * skip the newly modex 320x200x8 since it doesn't match the VGA 320x200x8 which it is expecting later in
         * the table. That VGA mode won't be in the table, so the dupe check code skips the mode we
         * actually wanted (since we are forcing to modex). If we turn off the app's request for
         * VGA, then that dupe check won't be made, and we should pick up the modex mode.
         */
        DPF(2,"Turning off request for standard VGA due to ModeX override");
        dwFlags &= ~DDEDM_STANDARDVGAMODES;
    }


    /*
     * go through all possible modes...
     */
    for( i=0;i<(int)this->dwNumModes;i++ )
    {
	pmi = &this->lpModeInfo[i];
	pmi = makeModeXModeIfNeeded( pmi, this_lcl );
        DPF(5,"Enumerating mode %d. %dx%d",i,pmi->dwWidth,pmi->dwHeight);

        if( ( pmi->wFlags & DDMODEINFO_DX7ONLY ) &&
            LOWERTHANDDRAW7( this_int ) )
        {
            continue;
        }

	/*
	 * check to see if this is a duplicate mode
	 */
	for (j=0; j<i; j++)
	{
	    // if we find a duplicate, break out early
	    if( (this->lpModeInfo[j].dwHeight == pmi->dwHeight) &&
		(this->lpModeInfo[j].dwWidth  == pmi->dwWidth)  &&
		(this->lpModeInfo[j].dwBPP    == pmi->dwBPP) )
	    {
		// basic mode matches, what about refresh rate?
		if( dwFlags & DDEDM_REFRESHRATES )
		{
		    // if refresh rate is not unique then the modes match
		    if( this->lpModeInfo[j].wRefreshRate == pmi->wRefreshRate )
		    {
			DPF(5, "matched: %d %d", this->lpModeInfo[j].wRefreshRate, pmi->wRefreshRate);
                        /*
                         * We have an identical mode, unless one is standard VGA and the other is not
                         */
		        if( dwFlags & DDEDM_STANDARDVGAMODES )
                        {
                            /*
                             * If the app cares about VGA modes, then a difference in the vganess
                             * of the two modes means they don't match.
                             */
                            if ( (this->lpModeInfo[j].wFlags ^ pmi->wFlags) & DDMODEINFO_STANDARDVGA )
                            {
                                /*
                                 * One mode is standard VGA and the other is not. Since
                                 * the app asked to enumerate standard VGA modes, we don't
                                 * consider this a match.
                                 */
                                continue;
                            }
                        }
                        /*
                         * Found identical refresh rate, and either app didn't care that
                         * modes are different in terms of VGAness or they are the same in
                         * terms of VGAness. Consider this a match.
                         */
			break;
		    }
		    // unique refresh rate and the app cares, the modes don't match
                    continue;
		}
		else
		{
		    // the app doesn't care about refresh rates
		    if( dwFlags & DDEDM_STANDARDVGAMODES )
                    {
                        if ( (this->lpModeInfo[j].wFlags ^ pmi->wFlags) & DDMODEINFO_STANDARDVGA )
                        {
                            /*
                             * One mode is standard VGA and the other is not. Since
                             * the app asked to enumerate standard VGA modes, we don't
                             * consider this a match.
                             */
                            continue;
                        }
                        /*
                         * Modes are the same as far as VGAness goes. drop through and break
                         * since they match
                         */
                    }
                    /*
                     * The app specified neither refresh rates nor VGA, so any mode which is
                     * duplicated at least on resolution (spatial and color) is skipped
                     */
		    break;
		}
	    }
	}

	if( j != i)
	{
	    // broke out early, mode i is not unique, move on to the next one.
	    continue;
	}

	/*
	 * check if surface description matches mode
	 */
	if ( lpDDSurfaceDesc )
	{
	    if( lpDDSurfaceDesc->dwFlags & DDSD_HEIGHT )
	    {
		if( lpDDSurfaceDesc->dwHeight != pmi->dwHeight )
		{
		    continue;
		}
	    }
	    if( lpDDSurfaceDesc->dwFlags & DDSD_WIDTH )
	    {
		if( lpDDSurfaceDesc->dwWidth != pmi->dwWidth )
		{
		    continue;
		}
	    }
	    if( lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT )
	    {
		if( lpDDSurfaceDesc->ddpfPixelFormat.dwRGBBitCount != pmi->dwBPP )
		{
		    continue;
		}
	    }
	    if( lpDDSurfaceDesc->dwFlags & DDSD_REFRESHRATE )
	    {
		bUseRefreshRate = TRUE;
		if( lpDDSurfaceDesc->dwRefreshRate != (DWORD)pmi->wRefreshRate )
		{
		    continue;
		}
	    }
	    else
	    {
		bUseRefreshRate = FALSE;
	    }
	}

	/*
	 * see if driver will allow this
	 */
        if (!(pmi->wFlags & DDMODEINFO_MODEX) )
	{
           if(this->dwFlags & DDRAWI_DISPLAYDRV)
           {

	        DWORD   cds_flags;
	        DEVMODE dm;
	        int     cds_rc;

	        makeDEVMODE( this, pmi, inexcl, bUseRefreshRate, &cds_flags, &dm );

	        cds_flags |= CDS_TEST;
	        cds_rc = xxxChangeDisplaySettingsExA(this->cDriverName, &dm, NULL, cds_flags, 0);
	        if( cds_rc != 0 )
	        {
		    if( bUseRefreshRate )
		    {
		        DPF( 1, "Mode %d not supported (%ldx%ldx%ld rr=%d), rc = %d", i,
			    pmi->dwWidth, pmi->dwHeight, pmi->dwBPP, pmi->wRefreshRate, cds_rc );
		    }
		    else
		    {
		        DPF( 1, "Mode %d not supported (%ldx%ldx%ld), rc = %d", i,
			    pmi->dwWidth, pmi->dwHeight, pmi->dwBPP, cds_rc );
		    }
		    continue;
	        }
           }
            if( !NEW_STYLE_REFRESH( this_int ) )
            {
                // We check for a display driver, merely to maintain identical behaviour to DX6-:
                // We never used to do the Monitor check on voodoos.
                if (this->dwFlags & DDRAWI_DISPLAYDRV)
                {
                    if( !MonitorCanHandleMode( this, pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate ) )
                    {
                        DPF( 1, "Monitor can't handle mode %d: (%ldx%ld rr=%d)", i,
                            pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate);
                        continue;
                    }
                }
            }
            else
            {
                // Call MonitorcanHandleMode to verify that that the size works,
                // but we'll use our own hacked mechanism to determine if the
                // refresh is supported

                if( !MonitorCanHandleMode( this, pmi->dwWidth, pmi->dwHeight, 0 ) )
                {
                    DPF( 1, "Monitor can't handle mode %d: (%ldx%ld rr=%d)", i,
                        pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate);
                    continue;
                }
                if( ( pmi->wRefreshRate > 0 ) &&
	            (dwFlags & DDEDM_REFRESHRATES) )
                {
                    if( !CanMonitorHandleRefreshRate( this, pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate ) )
                    {
                        DPF( 1, "Monitor can't handle mode %d: (%ldx%ld rr=%d)", i,
                            pmi->dwWidth, pmi->dwHeight, pmi->wRefreshRate);
                        continue;
                    }
                }
            }
        }

	if( (this->dwFlags & DDRAWI_DISPLAYDRV) &&
	    (pmi->wFlags & DDMODEINFO_MODEX) &&
	    !(this_lcl->dwLocalFlags & DDRAWILCL_ALLOWMODEX) )
	{
	    DPF( 2, "skipping ModeX or standard VGA mode" );
	    continue;
	}

	/*
	 * invoke callback with surface desc.
	 */
        ZeroMemory(&ddsd,sizeof(ddsd));
	    setSurfaceDescFromMode( this_lcl, pmi, (LPDDSURFACEDESC)&ddsd );
        if (LOWERTHANDDRAW4(this_int))
        {
            ddsd.dwSize = sizeof(DDSURFACEDESC);
        }
        else
        {
            ddsd.dwSize = sizeof(DDSURFACEDESC2);
        }

        if ((pmi->wFlags & DDMODEINFO_STEREO) &&
            !LOWERTHANDDRAW7(this_int)
            )
        {
            ddsd.ddsCaps.dwCaps2 |= DDSCAPS2_STEREOSURFACELEFT;
        }

        /*
         * Hardware default rates on NT are signified as 1Hz. We translate this to
         * 0Hz for DDraw apps. At SetDisplayMode time, 0Hz is translated back to 1Hz.
         */
	if(0==(dwFlags & DDEDM_REFRESHRATES))
        {
	    ddsd.dwRefreshRate = 0;
        }


   

	rc = lpEnumCallback( (LPDDSURFACEDESC2) &ddsd, lpContext );
	if( rc == 0 )
	{
	    break;
	}
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_EnumDisplayModes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddkmapip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkmapi.h
 *  Content:	Kernel mode APIs for accessing DirectDraw support.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   31-jan-97	scottm	initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDKMAPI_INCLUDED__
#define __DDKMAPI_INCLUDED__


/*
 * API entry point
 */
DWORD
FAR PASCAL
DxApi(
    DWORD  dwFunctionNum,
    LPVOID lpvInBuffer,
    DWORD  cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD  cbOutBuffer
);

typedef
DWORD
(FAR PASCAL *LPDXAPI)(
    DWORD   dwFunctionNum,
    LPVOID  lpvInBuffer,
    DWORD   cbInBuffer,
    LPVOID  lpvOutBuffer,
    DWORD   cbOutBuffer
);

#define DXAPI_MAJORVERSION		1
#define DXAPI_MINORVERSION              0

#define DD_FIRST_DXAPI					0x500

typedef ULONG (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);

/*
 * Queries the DXAPI version number.
 *
 * Input:  Null
 * Output: LPDDGETVERSIONNUMBER
 */
#define DD_DXAPI_GETVERSIONNUMBER                       (DD_FIRST_DXAPI)

    typedef struct _DDGETVERSIONNUMBER
    {
        DWORD   ddRVal;
        DWORD   dwMajorVersion;
        DWORD   dwMinorVersion;
    } DDGETVERSIONNUMBER, FAR *LPDDGETVERSIONNUMBER;

/*
 * Closes the kernel mode handle.
 *
 * Input:  LPDDCLOSEHANDLE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_CLOSEHANDLE                            (DD_FIRST_DXAPI+1)

    typedef struct _DDCLOSEHANDLE
    {
        HANDLE  hHandle;
    } DDCLOSEHANDLE, FAR *LPDDCLOSEHANDLE;

/*
 * Opens the DirectDraw object and returns a kernel mode handle.
 *
 * Input:  LPDDOPENDIRECTDRAWIN
 * Output: LPDDOPENDIRECTDRAWOUT
 */
#define DD_DXAPI_OPENDIRECTDRAW                         (DD_FIRST_DXAPI+2)

    typedef struct _DDOPENDIRECTDRAWIN
    {
        ULONG_PTR            dwDirectDrawHandle;
        LPDD_NOTIFYCALLBACK pfnDirectDrawClose;
        PVOID               pContext;
    } DDOPENDIRECTDRAWIN, FAR *LPDDOPENDIRECTDRAWIN;

    typedef struct _DDOPENDIRECTDRAWOUT
    {
        DWORD   ddRVal;
        HANDLE  hDirectDraw;
    } DDOPENDIRECTDRAWOUT, FAR *LPDDOPENDIRECTDRAWOUT;

/*
 * Opens the surface and returns a kernel mode handle.
 *
 * Input:  LPDDOPENSURFACEIN
 * Output: LPDDOPENSURFACEOUT
 */
#define DD_DXAPI_OPENSURFACE                            (DD_FIRST_DXAPI+3)

    typedef struct _DDOPENSURFACEIN
    {
	HANDLE	            hDirectDraw;
        ULONG_PTR            dwSurfaceHandle;
        LPDD_NOTIFYCALLBACK pfnSurfaceClose;
        PVOID               pContext;
    } DDOPENSURFACEIN, FAR *LPDDOPENSURFACEIN;

    typedef struct _DDOPENSURFACEOUT
    {
        DWORD   ddRVal;
        HANDLE  hSurface;
    } DDOPENSURFACEOUT, FAR *LPDDOPENSURFACEOUT;

/*
 * Opens the VideoPort and returns a kernel mode handle.
 *
 * Input:  LPDDOPENVIDEOPORTIN
 * Output: LPDDOPENVIDEOPORTOUT
 */
#define DD_DXAPI_OPENVIDEOPORT                          (DD_FIRST_DXAPI+4)

    typedef struct _DDOPENVIDEOPORTIN
    {
	HANDLE		    hDirectDraw;
        ULONG               dwVideoPortHandle;
        LPDD_NOTIFYCALLBACK pfnVideoPortClose;
        PVOID               pContext;
    } DDOPENVIDEOPORTIN, FAR *LPDDOPENVIDEOPORTIN;

    typedef struct _DDOPENVIDEOPORTOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoPort;
    } DDOPENVIDEOPORTOUT, FAR *LPDDOPENVIDEOPORTOUT;

/*
 * Returns the kernel mode capabilities supported by the device
 *
 * Input:  HANDLE hDirectDraw
 * Output: LPDDGETKERNELCAPSOUT
 */
#define DD_DXAPI_GETKERNELCAPS                          (DD_FIRST_DXAPI+5)

    typedef struct _DDGETKERNELCAPSOUT
    {
	DWORD	ddRVal;
        DWORD	dwCaps;
	DWORD	dwIRQCaps;
    } DDGETKERNELCAPSOUT, FAR *LPDDGETKERNELCAPSOUT;

/*
 * Gets the current field number
 *
 * Input:  LPDDGETFIELDNUMIN
 * Output: LPDDGETFIELDNUMOUT
 */
#define DD_DXAPI_GET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+6)

    typedef struct _DDGETFIELDNUMIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETFIELDNUMIN, FAR *LPDDGETFIELDNUMIN;

    typedef struct _DDGETFIELDNUMOUT
    {
	DWORD	ddRVal;
	DWORD	dwFieldNum;
    } DDGETFIELDNUMOUT, FAR *LPDDGETFIELDNUMOUT;

/*
 * Sets the current field number
 *
 * Input:  LPDDSETFIELDNUM
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+7)

    typedef struct _DDSETFIELDNUM
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwFieldNum;
    } DDSETFIELDNUM, FAR *LPDDSETFIELDNUM;

/*
 * Indicates which fields should be skipped to undo the 3:2 pulldown.
 *
 * Input:  LPDDSETSKIPFIELD
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_SKIP_FIELD			(DD_FIRST_DXAPI+8)

    typedef struct _DDSETSKIPFIELD
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwStartField;
    } DDSETSKIPFIELD, FAR *LPDDSETSKIPFIELD;

/*
 * Notifies whether the surface is in bob or weave mode.
 *
 * Input:  LPDDGETSURFACESTATEIN
 * Output: LPDDGETSURFACESTATEOUT
 */
#define DD_DXAPI_GET_SURFACE_STATE			(DD_FIRST_DXAPI+9)

    typedef struct _DDGETSURFACESTATEIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDGETSURFACESTATEIN, FAR *LPDDGETSURFACESTATEIN;

    typedef struct _DDGETSURFACESTATEOUT
    {
	DWORD	ddRVal;
	DWORD	dwStateCaps;
	DWORD	dwStateStatus;
    } DDGETSURFACESTATEOUT, FAR *LPDDGETSURFACESTATEOUT;

/*
 * Changes the surface between bob and weave mode.
 *
 * Input:  LPDDSETSURFACESTATE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_SURFACE_STATE			(DD_FIRST_DXAPI+10)

    typedef struct _DDSETSURFACETATE
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
	DWORD	dwState;
	DWORD	dwStartField;
    } DDSETSURFACESTATE, FAR *LPDDSETSURFACESTATE;

/*
 * Allows direct access to the surface memory
 *
 * Input:  LPDDLOCKIN
 * Output: LPDDLOCKOUT
 */
#define DD_DXAPI_LOCK					(DD_FIRST_DXAPI+11)

    typedef struct _DDLOCKIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDLOCKIN, FAR *LPDDLOCKIN;

    typedef struct _DDLOCKOUT
    {
	DWORD	ddRVal;
	DWORD	dwSurfHeight;
	DWORD	dwSurfWidth;
	LONG	lSurfPitch;
	PVOID	lpSurface;
	DWORD	SurfaceCaps;
	DWORD	dwFormatFlags;
	DWORD	dwFormatFourCC;
	DWORD	dwFormatBitCount;
	union
	{
	    DWORD	dwRBitMask;
	    DWORD	dwYBitMask;
    	};
    	union
    	{
	    DWORD	dwGBitMask;
	    DWORD	dwUBitMask;
	};
	union
	{
	    DWORD	dwBBitMask;
	    DWORD	dwVBitMask;
	};
    } DDLOCKOUT, FAR *LPDDLOCKOUT;

/*
 * Flips the overlay surface
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_OVERLAY				(DD_FIRST_DXAPI+12)

    typedef struct _DDFLIPOVERLAY
    {
	HANDLE	hDirectDraw;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPOVERLAY, FAR *LPDDFLIPOVERLAY;

/*
 * Flips the video port
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_VP				(DD_FIRST_DXAPI+13)

    typedef struct _DDFLIPVIDEOPORT
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPVIDEOPORT, FAR *LPDDFLIPVIDEOPORT;

/*
 * Returns the current surface receiving the data while autoflipping
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_CURRENT_VP_AUTOFLIP_SURFACE	(DD_FIRST_DXAPI+14)

    typedef struct _DDGETAUTOFLIPIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETAUTOFLIPIN, FAR *LPDDGETAUTOFLIPIN;

    typedef struct _DDGETAUTOFLIPOUT
    {
	DWORD	ddRVal;
	HANDLE	hVideoSurface;
	HANDLE	hVBISurface;
	BOOL	bPolarity;
    } DDGETAUTOFLIPOUT, FAR *LPDDGETAUTOFLIPOUT;

/*
 * Returns the surface that received the previous field of data (could
 * be the same as current if video is interleaved)
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_LAST_VP_AUTOFLIP_SURFACE		(DD_FIRST_DXAPI+15)

/*
 * Registers a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_REGISTER_CALLBACK			(DD_FIRST_DXAPI+16)

    typedef struct _DDREGISTERCALLBACK
    {
	HANDLE 	            hDirectDraw;
	ULONG	            dwEvents;
	LPDD_NOTIFYCALLBACK pfnCallback;
	ULONG_PTR            dwParam1;
	ULONG_PTR            dwParam2;
	PVOID	            pContext;
    } DDREGISTERCALLBACK, FAR *LPDDREGISTERCALLBACK;

/*
 * Unregisters a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_UNREGISTER_CALLBACK			(DD_FIRST_DXAPI+17)

/*
 * Returns the polarity (odd/even) of the current field
 *
 * Input:  LPDDGETPOLARITYIN
 * Output: LPDDGETPOLARITYOUT
 */
#define DD_DXAPI_GET_POLARITY				(DD_FIRST_DXAPI+18)

    typedef struct _DDGETPOLARITYIN
    {
	HANDLE 	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETPOLARITYIN, FAR *LPDDGETPOLARITYIN;

    typedef struct _DDGETPOLARITYOUT
    {
	DWORD 	ddRVal;
	BOOL	bPolarity;
    } DDGETPOLARITYOUT, FAR *LPDDGETPOLARITYOUT;

/*
 * Opens the device for capture
 *
 * Input:  LPDDOPENCAPTUREDEVICEIN
 * Output: LPDDOPENCAPTUREDEVICEOUT
 */
#define DD_DXAPI_OPENVPCAPTUREDEVICE			(DD_FIRST_DXAPI+19)

    typedef struct _DDOPENVPCAPTUREDEVICEIN
    {
	HANDLE  hDirectDraw;
	HANDLE  hVideoPort;
	DWORD   dwStartLine;
	DWORD   dwEndLine;
	DWORD   dwCaptureEveryNFields;
	LPDD_NOTIFYCALLBACK pfnCaptureClose;
	PVOID   pContext;
	DWORD	dwFlags;
    } DDOPENVPCAPTUREDEVICEIN, FAR * LPDDOPENVPCAPTUREDEVICEIN;

    typedef struct _DDOPENVPCAPTUREDEVICEOUT
    {
	DWORD	ddRVal;
	HANDLE	hCapture;
    } DDOPENVPCAPTUREDEVICEOUT, FAR * LPDDOPENVPCAPTUREDEVICEOUT;

    #define DDOPENCAPTURE_VIDEO	0x0001	// Capture from the video stream
    #define DDOPENCAPTURE_VBI	0x0002	// Capture from the VBI stream

/*
 * Adds a capture buffer to the internal video port capture queue
 *
 * Input:  LPDDADDVPCAPTUREBUFF
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_ADDVPCAPTUREBUFFER			(DD_FIRST_DXAPI+20)

    typedef struct _DDCAPBUFFINFO
    {
	DWORD   	dwFieldNumber;
	DWORD   	bPolarity;
	LARGE_INTEGER	liTimeStamp;
	DWORD   	ddRVal;
    } DDCAPBUFFINFO, FAR * LPDDCAPBUFFINFO;

    typedef struct _DDADDVPCAPTUREBUFF
    {
	HANDLE  hCapture;
	DWORD   dwFlags;
	PMDL    pMDL;
	PKEVENT pKEvent;
	LPDDCAPBUFFINFO lpBuffInfo;
    } DDADDVPCAPTUREBUFF, FAR * LPDDADDVPCAPTUREBUFF;

    #define DDADDBUFF_SYSTEMMEMORY	0x0001	// lpBuffer points to sys mem
    #define DDADDBUFF_NONLOCALVIDMEM	0x0002	// lpBuffer points to AGP mem
    #define DDADDBUFF_INVERT		0x0004	// invert the buffer during capture

/*
 * Flushes the internal video port capture queue
 *
 * Input:  HANDLE to capture device
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLUSHVPCAPTUREBUFFERS			(DD_FIRST_DXAPI+21)


//@@BEGIN_MSINTERNAL
//#ifdef WIN95

    /*
     * These IOCTLS are private and should not be used by clients.
     * They are to allow DirectDraw to sync the state/data between
     * the two drivers
     */
    #define DDHANDLEADJUST	8

    /*
     * Input:  LPDDINITDEVICEIN
     * Output: LPDDINITDEVICEOUT
     */
    #define DD_DXAPI_INIT_DEVICE			(DD_FIRST_DXAPI+22)

    	typedef struct _DDINITDEVICEIN
    	{
	    DWORD		dwDeviceFlags;
	    DWORD		dwMaxVideoPorts;
	    DDMINIVDDTABLE	MiniVDDTable;
    	} DDINITDEVICEIN, FAR *LPDDINITDEVICEIN;

    	typedef struct _DDINITDEVICEOUT
    	{
	    DWORD		ddRVal;
	    DWORD		dwDirectDrawHandle;
	    ULONG_PTR		pfnNotifyProc;
	    DWORD		bHaveIRQ;
    	} DDINITDEVICEOUT, FAR *LPDDINITDEVICEOUT;

    /*
     * Input:  DWORD dwDirectDrawHandle
     * Output: none
     */
    #define DD_DXAPI_RELEASE_DEVICE			(DD_FIRST_DXAPI+23)

    /*
     * Input:  LPDDKMSURFACEINFO
     * Output: LPDDGETSURFACEHANDLE
     */
    #define DD_DXAPI_GET_SURFACE_HANDLE			(DD_FIRST_DXAPI+24)

    	typedef struct _DDKMSURFACEINFO
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	ddsCaps;		// Ring 3 creation caps
	    DWORD	dwSurfaceOffset;	// Offset in frame buffer of surface
	    ULONG_PTR	fpLockPtr;		// Surface lock ptr
	    DWORD	dwWidth;		// Surface width
	    DWORD	dwHeight;		// Surface height
	    LONG	lPitch;			// Surface pitch
	    DWORD	dwOverlayFlags;		// DDOVER_XX flags
	    DWORD	dwOverlayOffset;	// Offset in frame buffer of overlay
	    DWORD	dwOverlaySrcWidth;	// Src width of overlay
	    DWORD	dwOverlaySrcHeight;	// Src height of overlay
	    DWORD	dwOverlayDestWidth;	// Dest width of overlay
	    DWORD	dwOverlayDestHeight;	// Dest height of overlay
	    DWORD	dwVideoPortId; 		// ID of video port (-1 if not connected to a video port)
	    DWORD	dwPhysicalPageTable;
	    ULONG_PTR	pPageTable;
	    DWORD	cPages;
	    DWORD	dwFormatFlags;
	    DWORD	dwFormatFourCC;
	    DWORD	dwFormatBitCount;
	    DWORD	dwRBitMask;
	    DWORD	dwGBitMask;
	    DWORD	dwBBitMask;
	    ULONG_PTR	dwDriverReserved1;	// Reserved for the HAL/Mini VDD
	    ULONG_PTR	dwDriverReserved2;	// Reserved for the HAL/Mini VDD
	    ULONG_PTR	dwDriverReserved3;	// Reserved for the HAL/Mini VDD
    	} DDKMSURFACEINFO, FAR *LPDDKMSURFACEINFO;

    	typedef struct _DDGETSURFACEHANDLE
    	{
	    DWORD	ddRVal;			// Return code
	    DWORD	hSurface;		// New surface handle
    	} DDGETSURFACEHANDLE, FAR *LPDDGETSURFACEHANDLE;

    /*
     * Input:  LPDDRELEASEHANDLE
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_RELEASE_SURFACE_HANDLE		(DD_FIRST_DXAPI+25)

    	typedef struct _DDRELEASEHANDLE
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	hSurface;		// Surface handle to release
    	} DDRELEASEHANDLE, FAR *LPDDRELEASEHANDLE;

    /*
     * Input:  LPDDKMSURFACEUPDATE
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_UPDATE_SURFACE_INFO		(DD_FIRST_DXAPI+26)

    	typedef struct _DDKMSURFACEUPDATE
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	dwSurfaceHandle;	// Handle of surface to update
	    DDKMSURFACEINFO	si;	// New surface info
    	} DDKMSURFACEUPDATE, FAR *LPDDKMSURFACEUPDATE;

    /*
     * Input:  LPDDKMVIDEOPORTINFO
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_UPDATE_VP_INFO			(DD_FIRST_DXAPI+27)

    	#define MAX_AUTOFLIP	10

    	typedef struct _DDKMVIDEOPORTINFO
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	dwVideoPortId;		// ID of video port (0 - MaxVideoPorts-1)
	    DWORD	dwVPFlags;		// Offset in frame buffer of surface
	    DWORD	dwFlags;		// Flags used internally
	    DWORD	dwOriginOffset;		// Start address relative to surface
	    DWORD	dwHeight;		// Height of total video region (per field)
	    DWORD	dwVBIHeight;		// Height of VBI region (per field)
	    DWORD	dwNumAutoflipping;	// Number of surfaces being autoflipped
	    DWORD	dwNumVBIAutoflipping;	// Number of VBI surfaces being autoflipped
	    DWORD	dwSurfaceHandle[MAX_AUTOFLIP];	// Surface receiving the data (up to 10 autoflipping)
	    DWORD	dwVBISurfaceHandle[MAX_AUTOFLIP]; // Surface receiving VBI data (up to 10 autoflipping)
	    ULONG_PTR	dwDriverReserved1;	// Reserved for the HAL/Mini VDD
	    ULONG_PTR	dwDriverReserved2;	// Reserved for the HAL/Mini VDD
	    ULONG_PTR	dwDriverReserved3;	// Reserved for the HAL/Mini VDD
    	} DDKMVIDEOPORTINFO, FAR *LPDDKMVIDEOPORTINFO;

    /*
     * Same as DD_DXAPI_GET_SURFACE_STATE, but it doesn't require that
     * you open the surace first.
     *
     * Input:  LPDDGETSURFACESTATEIN
     * Output: LPDDGETSURFACESTATEOUT
     */
    #define DD_DXAPI_PRIVATE_GET_SURFACE_STATE	       (DD_FIRST_DXAPI+28)

    /*
     * Input:  LPDDSETDOSBOXEVENT
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_SET_DOS_BOX_EVENT		       (DD_FIRST_DXAPI+29)

    	typedef struct _DDSETDOSBOXEVENT
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	dwDOSBoxEvent;
    	} DDSETDOSBOXEVENT, FAR *LPDDSETDOSBOXEVENT;

    /*
     * Input:  LPDDSETKERNELCAPS
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_SET_KERNEL_CAPS		       (DD_FIRST_DXAPI+30)

    	typedef struct _DDSETKERNELCAPS
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	dwCaps;
	    DWORD	dwIRQCaps;
    	} DDSETKERNELCAPS, FAR *LPDDSETKERNELCAPS;

    /*
     * Input:  LPDDSETKERNELCAPS
     * Output: DWORD DirectDraw return value
     */
    #define DD_DXAPI_ENABLE_AUTOFLIP		       (DD_FIRST_DXAPI+31)

    	typedef struct _DDENABLEAUTOLFIP
    	{
	    DWORD	dwDirectDrawHandle;
	    DWORD	dwVideoPortId;		// ID of video port (0 - MaxVideoPorts-1)
	    BOOL	bEnableAutoflip;
    	} DDENABLEAUTOFLIP, FAR *LPDDENABLEAUTOFLIP;

    #define DD_LAST_DXAPI	DD_DXAPI_ENABLE_AUTOFLIP

//#endif

//@@END_MSINTERNAL
/*
 * State flags returned by DSVXD_DXAPI_DD_GET_SURFACE_STATE
 */
#define DDSTATE_BOB				0x0001
#define DDSTATE_WEAVE				0x0002
#define DDSTATE_EXPLICITLY_SET			0x0004
#define DDSTATE_SOFTWARE_AUTOFLIP		0x0008
#define DDSTATE_SKIPEVENFIELDS			0x0010

/*
 * Event flags - passed into RegisterCallback
 */
#define DDEVENT_DISPLAY_VSYNC			0x0001
#define DDEVENT_VP_VSYNC			0x0002
#define DDEVENT_VP_LINE				0x0004
#define DDEVENT_PRERESCHANGE			0x0008
#define DDEVENT_POSTRESCHANGE			0x0010
#define DDEVENT_PREDOSBOX			0x0020
#define DDEVENT_POSTDOSBOX			0x0040

/*
 * Notification flags - passed to the notification proc
 */
#define DDNOTIFY_DISPLAY_VSYNC			0x0001	// dwParam1 = hDirectDraw
#define DDNOTIFY_VP_VSYNC			0x0002	// dwParam1 = hVideoPort
#define DDNOTIFY_VP_LINE	  		0x0004	// dwParam1 = hVideoPort
#define DDNOTIFY_PRERESCHANGE			0x0008	// dwParam1 = hDirectDraw
#define DDNOTIFY_POSTRESCHANGE			0x0010	// dwParam1 = hDirectDraw
#define DDNOTIFY_PREDOSBOX			0x0020  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTDOSBOX			0x0040  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSEDIRECTDRAW		0x0080  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSESURFACE			0x0100  // dwParam1 = hSurface
#define DDNOTIFY_CLOSEVIDEOPORT			0x0200  // dwParam1 = hVideoPort
#define DDNOTIFY_CLOSECAPTURE			0x0400  // dwParam1 = hCapture

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddkernel.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkernel.h
 *  Content:	APIs for accessing kernel mode support.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   09-jan-97	scottm	initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDKM_INCLUDED__
#define __DDKM_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by to get kernel interfaces
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDirectDrawKernel,             0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawSurfaceKernel,      0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );

#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke the kernel API functions.
 *
 *==========================================================================*/

typedef struct IDirectDrawKernel		FAR *LPDIRECTDRAWKERNEL;
typedef struct IDirectDrawSurfaceKernel		FAR *LPDIRECTDRAWSURFACEKERNEL;
typedef struct _DDKERNELCAPS			FAR *LPDDKERNELCAPS;


/*
 * INTERACES FOLLOW:
 *	IDirectDrawKernel
 *	IVideoPort
 */

/*
 * IDirectDrawKernel
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawKernel
DECLARE_INTERFACE_( IDirectDrawKernel, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDDKERNELCAPS) PURE;
    STDMETHOD(GetKernelHandle)(THIS_ PULONG_PTR) PURE;
    STDMETHOD(ReleaseKernelHandle)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawKernel_GetCaps(p, a)             (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawKernel_GetKernelHandle(p, a)     (p)->lpVtbl->GetKernelHandle(p, a)
#define IDirectDrawKernel_ReleaseKernelHandle(p)    (p)->lpVtbl->ReleaseKernelHandle(p)
#endif

#endif

/*
 * IDirectDrawSurfaceKernel
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawSurfaceKernel
DECLARE_INTERFACE_( IDirectDrawSurfaceKernel, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(GetKernelHandle)(THIS_ PULONG_PTR) PURE;
    STDMETHOD(ReleaseKernelHandle)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurfaceKernel_GetKernelHandle(p, a)     (p)->lpVtbl->GetKernelHandle(p, a)
#define IDirectDrawSurfaceKernel_ReleaseKernelHandle(p)    (p)->lpVtbl->ReleaseKernelHandle(p)
#endif

#endif


/*
 * DDKERNELCAPS
 */
typedef struct _DDKERNELCAPS
{
    DWORD dwSize;			// size of the DDKERNELCAPS structure
    DWORD dwCaps;                       // Contains the DDKERNELCAPS_XXX flags
    DWORD dwIRQCaps;                    // Contains the DDIRQ_XXX flags
} DDKERNELCAPS, FAR *LPDDKERNELCAPS;



/****************************************************************************
 *
 * DDKERNELCAPS CAPS
 *
 ****************************************************************************/

/*
 * Indicates that the device supports field skipping.
 */
#define DDKERNELCAPS_SKIPFIELDS			0x00000001l

/*
 * Indicates that the device can support software autoflipping.
 */
#define DDKERNELCAPS_AUTOFLIP			0x00000002l

/*
 * Indicates that the device can switch between bob and weave.
 */
#define DDKERNELCAPS_SETSTATE			0x00000004l

/*
 * Indicates that a client can gain direct access to the frame buffer.
 */
#define DDKERNELCAPS_LOCK			0x00000008l

/*
 * Indicates that a client can manually flip the video port.
 */
#define DDKERNELCAPS_FLIPVIDEOPORT		0x00000010l

/*
 * Indicates that a client can manually flip the overlay.
 */
#define DDKERNELCAPS_FLIPOVERLAY		0x00000020l

/*
 * Indicates that the device supports a video port capture interface
 * capable of transfering data to system memory.
 */
#define DDKERNELCAPS_CAPTURE_SYSMEM		0x00000040l

/*
 * Indicates that the device supports a video port capture interface
 * capable of transfering data to non-local video memory.
 */
#define DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM	0x00000080l

/*
 * Indicates that the device can report the polarity (even/odd) of
 * the curent video field.
 */
#define DDKERNELCAPS_FIELDPOLARITY		0x00000100l

/*
 * Indicates that the device supports inverting the DIBs while capturing
 * the data.
 */
#define DDKERNELCAPS_CAPTURE_INVERTED		0x00000200l

/****************************************************************************
 *
 * DDKERNELCAPS IRQ CAPS
 *
 ****************************************************************************/

/*
 * The device can generate display VSYNC IRQs
 */
#define DDIRQ_DISPLAY_VSYNC			0x00000001l

/*
 * Reserved
 */
#define DDIRQ_RESERVED1				0x00000002l

/*
 * The device can generate video ports VSYNC IRQs using video port 0
 */
#define DDIRQ_VPORT0_VSYNC			0x00000004l

/*
 * The device can generate video ports line IRQs using video port 0
 */
#define DDIRQ_VPORT0_LINE			0x00000008l

/*
 * The device can generate video ports VSYNC IRQs using video port 1
 */
#define DDIRQ_VPORT1_VSYNC			0x00000010l

/*
 * The device can generate video ports line IRQs using video port 1
 */
#define DDIRQ_VPORT1_LINE			0x00000020l

/*
 * The device can generate video ports VSYNC IRQs using video port 2
 */
#define DDIRQ_VPORT2_VSYNC			0x00000040l

/*
 * The device can generate video ports line IRQs using video port 2
 */
#define DDIRQ_VPORT2_LINE			0x00000080l

/*
 * The device can generate video ports VSYNC IRQs using video port 3
 */
#define DDIRQ_VPORT3_VSYNC			0x00000100l

/*
 * The device can generate video ports line IRQs using video port 3
 */
#define DDIRQ_VPORT3_LINE			0x00000200l

/*
 * The device can generate video ports VSYNC IRQs using video port 4
 */
#define DDIRQ_VPORT4_VSYNC			0x00000400l

/*
 * The device can generate video ports line IRQs using video port 4
 */
#define DDIRQ_VPORT4_LINE			0x00000800l

/*
 * The device can generate video ports VSYNC IRQs using video port 5
 */
#define DDIRQ_VPORT5_VSYNC			0x00001000l

/*
 * The device can generate video ports line IRQs using video port 5
 */
#define DDIRQ_VPORT5_LINE			0x00002000l

/*
 * The device can generate video ports VSYNC IRQs using video port 6
 */
#define DDIRQ_VPORT6_VSYNC			0x00004000l

/*
 * The device can generate video ports line IRQs using video port 6
 */
#define DDIRQ_VPORT6_LINE			0x00008000l

/*
 * The device can generate video ports VSYNC IRQs using video port 7
 */
#define DDIRQ_VPORT7_VSYNC			0x00010000l

/*
 * The device can generate video ports line IRQs using video port 7
 */
#define DDIRQ_VPORT7_LINE			0x00020000l

/*
 * The device can generate video ports VSYNC IRQs using video port 8
 */
#define DDIRQ_VPORT8_VSYNC			0x00040000l

/*
 * The device can generate video ports line IRQs using video port 8
 */
#define DDIRQ_VPORT8_LINE			0x00080000l

/*
 * The device can generate video ports VSYNC IRQs using video port 9
 */
#define DDIRQ_VPORT9_VSYNC			0x00010000l

/*
 * The device can generate video ports line IRQs using video port 9
 */
#define DDIRQ_VPORT9_LINE			0x00020000l



#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddmodent.c ===
//=============================================================================
//
//  Copyright (C) 1998 Microsoft Corporation. All rights reserved.
//
//     File:  ddmodent.c
//  Content:  DirectDraw display mode code for NT
//
//  Date        By        Reason
//  ----------  --------  -----------------------------------------------------
//  02/20/1998  johnstep  Initialial implementation, replaces ddmode.c on NT
//  05/29/1998  jeffno    ModeX emulation
//
//=============================================================================

#include "ddrawpr.h"
#include "ddrawgdi.h"

#define MODEX_WIDTH     320
#define MODEX_HEIGHT1   200
#define MODEX_HEIGHT2   240
#define MODEX_BPP       8

//=============================================================================
//
//  Function: GetNumberOfMonitorAttachedToDesktop
//
//  Count number of monitors attached to current desktop.
//
//=============================================================================

DWORD GetNumberOfMonitorAttachedToDesktop()
{
    DWORD dwNumberOfMonitor = 0;
    DWORD iDevNum = 0;
    DISPLAY_DEVICE DisplayDevice;

    ZeroMemory(&DisplayDevice,sizeof(DISPLAY_DEVICE));
    DisplayDevice.cb = sizeof(DISPLAY_DEVICE);

    while (EnumDisplayDevices(NULL,iDevNum,&DisplayDevice,0))
    {
        if (DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)
        {
            dwNumberOfMonitor++;
        }

        ZeroMemory(&DisplayDevice,sizeof(DISPLAY_DEVICE));
        DisplayDevice.cb = sizeof(DISPLAY_DEVICE);

        iDevNum++;
    }

    return dwNumberOfMonitor;
}


//=============================================================================
//
//  Function: resetAllDirectDrawObjects
//
//  On NT we have to reenable all the DirectDraw objects on any mode change
//  because a mode change disables all the kernel mode DirectDraw objects due
//  to desktop changes, etc.
//
//=============================================================================

void resetAllDirectDrawObjects()
{
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    BOOL bRestoreGamma;
    HDC hdc;
    WORD wMonitorsAttachedToDesktop = (WORD) GetNumberOfMonitorAttachedToDesktop();

    // First mark all DirectDraw global objects as having not changed.

    for (pdd_lcl = lpDriverLocalList; pdd_lcl;)
    {
        if (pdd_lcl->lpGbl)
        {
            pdd_lcl->lpGbl->dwFlags |= DDRAWI_DDRAWDATANOTFETCHED;
        }
        pdd_lcl = pdd_lcl->lpLink;
    }

    // Now reset all drivers unmarking them as we go. We may need to create
    // temporary kernel mode DirectDraw objects in order to pass down a valid
    // handle to the kernel.

    for (pdd_lcl = lpDriverLocalList; pdd_lcl;)
    {
        pdd_gbl = pdd_lcl->lpGbl;

        if (pdd_gbl && (pdd_gbl->dwFlags & DDRAWI_DDRAWDATANOTFETCHED))
        {
            // Determine if the gamma ramp needs to be restored

            bRestoreGamma = ( pdd_lcl->lpPrimary != NULL ) &&
                ( pdd_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) &&
                ( pdd_lcl->lpPrimary->lpLcl->dwFlags & DDRAWISURF_SETGAMMA );

            pdd_gbl->dwFlags &= ~DDRAWI_DDRAWDATANOTFETCHED;

            if (!(pdd_gbl->dwFlags & DDRAWI_MODEX))
            {
                // If we find a local for this process/driver pair, we will use
                // its hDD to pass to the kernel. If not, we must create a
                // temproary kernel mode DirectDraw object, and delete it after
                // resetting the driver.

                FetchDirectDrawData(pdd_gbl, TRUE, 0, NULL, NULL, 0, pdd_lcl);
            }
            else
            {
                DDHALMODEINFO mi =
                {
	            MODEX_WIDTH,    // width (in pixels) of mode
	            MODEX_HEIGHT1,    // height (in pixels) of mode
	            MODEX_WIDTH,    // pitch (in bytes) of mode
	            MODEX_BPP,      // bits per pixel
	            (WORD)(DDMODEINFO_PALETTIZED | DDMODEINFO_MODEX), // flags
	            0,      // refresh rate
	            0,      // red bit mask
	            0,      // green bit mask
	            0,      // blue bit mask
	            0       // alpha bit mask
                };

                //fixup the height to the actual height:
                mi.dwHeight = pdd_lcl->dmiPreferred.wHeight;

                fetchModeXData( pdd_gbl, &mi, INVALID_HANDLE_VALUE );
            }

            pdd_gbl->dmiCurrent.wMonitorsAttachedToDesktop = (BYTE)wMonitorsAttachedToDesktop;

            hdc = DD_CreateDC(pdd_gbl->cDriverName);

            if ( pdd_gbl->dwFlags & DDRAWI_NOHARDWARE )
            {
                // The HEL will wipe out our hard-earned modex data otherwise
                if (0 == (pdd_gbl->dwFlags & DDRAWI_MODEX) )
                {
                    extern void UpdateDirectDrawMode(LPDDRAWI_DIRECTDRAW_GBL);
                    UpdateDirectDrawMode(pdd_gbl);
                }
            }
            else
            {
                if( bRestoreGamma )
                {
                    SetGamma( pdd_lcl->lpPrimary->lpLcl, pdd_lcl );
                }

                InitDIB(hdc, pdd_gbl->gpbmiSrc);
                InitDIB(hdc, pdd_gbl->gpbmiDest);
            }

            DD_DoneDC(hdc);
        }
        pdd_lcl = pdd_lcl->lpLink;
    }
    CheckAliasedLocksOnModeChange();
}

//=============================================================================
//
//  Function: ModeChangedOnENTERDDRAW
//
//=============================================================================

void ModeChangedOnENTERDDRAW(void)
{
    resetAllDirectDrawObjects();
}

//=============================================================================
//
//  Function: FillBitMasks
//
//=============================================================================

void FillBitMasks(LPDDPIXELFORMAT pddpf, HDC hdc)
{
    if (hdc)
    {
        HBITMAP hbm;
        BITMAPINFO *pbmi;
        DWORD *pdwColors;

        if (pbmi = LocalAlloc(LPTR, 3 * sizeof (RGBQUAD) + sizeof (BITMAPINFO)))
        {
            if (hbm = CreateCompatibleBitmap(hdc, 1, 1))
            {
                pbmi->bmiHeader.biSize = sizeof (BITMAPINFOHEADER);

                if (GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS))
                {
                    if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                    {
                        GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight,
                            NULL, pbmi, DIB_RGB_COLORS);

                        pdwColors = (DWORD *) &pbmi->bmiColors[0];
                        pddpf->dwRBitMask = pdwColors[0];
                        pddpf->dwGBitMask = pdwColors[1];
                        pddpf->dwBBitMask = pdwColors[2];
                        pddpf->dwRGBAlphaBitMask = 0;
                    }
                }
                DeleteObject(hbm);
            }
            LocalFree(pbmi);
        }
    }
    else
    {
        switch (pddpf->dwRGBBitCount)
        {
        case 15:
            pddpf->dwRBitMask = 0x7C00;
            pddpf->dwGBitMask = 0x03E0;
            pddpf->dwBBitMask = 0x001F;
            pddpf->dwRGBAlphaBitMask = 0;
            break;

        case 16:
            pddpf->dwRBitMask = 0xF800;
            pddpf->dwGBitMask = 0x07E0;
            pddpf->dwBBitMask = 0x001F;
            pddpf->dwRGBAlphaBitMask = 0;
            break;

        case 32:
            pddpf->dwRBitMask = 0x00FF0000;
            pddpf->dwGBitMask = 0x0000FF00;
            pddpf->dwBBitMask = 0x000000FF;
            pddpf->dwRGBAlphaBitMask = 0x00000000;
            break;

        default:
            pddpf->dwRBitMask = 0;
            pddpf->dwGBitMask = 0;
            pddpf->dwBBitMask = 0;
            pddpf->dwRGBAlphaBitMask = 0;
        }
    }
}

//=============================================================================
//
//  Function: setPixelFormat
//
//=============================================================================

static void setPixelFormat(LPDDPIXELFORMAT pddpf, HDC hdc, DWORD bpp)
{
    pddpf->dwSize = sizeof (DDPIXELFORMAT);
    pddpf->dwFlags = DDPF_RGB;
    pddpf->dwRGBBitCount = hdc ? GetDeviceCaps(hdc, BITSPIXEL) : bpp;

    switch (pddpf->dwRGBBitCount)
    {
        case 8:
            pddpf->dwFlags |= DDPF_PALETTEINDEXED8;
            pddpf->dwRBitMask = 0;
            pddpf->dwGBitMask = 0;
            pddpf->dwBBitMask = 0;
            pddpf->dwRGBAlphaBitMask = 0;
            break;

        case 24:
            pddpf->dwRBitMask = 0x00FF0000;
            pddpf->dwGBitMask = 0x0000FF00;
            pddpf->dwBBitMask = 0x000000FF;
            pddpf->dwRGBAlphaBitMask = 0x00000000;
            break;

        default:
            FillBitMasks(pddpf, hdc);
            break;
    }
}

//=============================================================================
//
//  Function: DD_GetDisplayMode
//
//=============================================================================

HRESULT DDAPI DD_GetDisplayMode(LPDIRECTDRAW pdd, LPDDSURFACEDESC pddsd)
{
    LPDDRAWI_DIRECTDRAW_INT pdd_int;
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    HDC hdc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetDisplayMode");

    TRY
    {
        pdd_int = (LPDDRAWI_DIRECTDRAW_INT) pdd;
        if (!VALID_DIRECTDRAW_PTR(pdd_int))
        {
            DPF(0, "Invalid object");
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        pdd_lcl = pdd_int->lpLcl;
        pdd_gbl = pdd_lcl->lpGbl;

        if (!VALIDEX_DDSURFACEDESC2_PTR(pddsd) &&
            !VALIDEX_DDSURFACEDESC_PTR(pddsd))
        {
            DPF(0, "Invalid params");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("DD_GetDisplayMode: Exception encountered validating parameters");
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    ZeroMemory(pddsd, pddsd->dwSize);

    if (LOWERTHANDDRAW4(pdd_int))
    {
        pddsd->dwSize = sizeof (DDSURFACEDESC);
    }
    else
    {
        pddsd->dwSize = sizeof (DDSURFACEDESC2);
    }

    pddsd->dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH | DDSD_PIXELFORMAT | DDSD_REFRESHRATE;

    hdc = DD_CreateDC(pdd_gbl->cDriverName);

    pddsd->dwWidth = pdd_gbl->lpModeInfo->dwWidth;
    pddsd->dwHeight = pdd_gbl->lpModeInfo->dwHeight;
    pddsd->dwRefreshRate = pdd_gbl->lpModeInfo->wRefreshRate;

    setPixelFormat(&(pddsd->ddpfPixelFormat), hdc, 0);
    pddsd->lPitch = (pddsd->dwWidth * pddsd->ddpfPixelFormat.dwRGBBitCount) >> 3; // hack

    // set stereo surface caps bits if driver marks mode as stereo mode
    if (GetDDStereoMode(pdd_gbl,
                            pddsd->dwWidth,
                            pddsd->dwHeight,
                            pddsd->ddpfPixelFormat.dwRGBBitCount,
                            pddsd->dwRefreshRate) &&
        !LOWERTHANDDRAW7(pdd_int) &&
        VALIDEX_DDSURFACEDESC2_PTR(pddsd))
    {
        LPDDSURFACEDESC2 pddsd2  = (LPDDSURFACEDESC2)pddsd;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_STEREOSURFACELEFT;
    }

    DD_DoneDC(hdc);

    LEAVE_DDRAW();

    return DD_OK;
}

//=============================================================================
//
//  Function: SetDisplayMode
//
//=============================================================================


/*
 * IsRefreshRateSupported
 */
BOOL IsRefreshRateSupported(LPDDRAWI_DIRECTDRAW_GBL   pdrv,
                            DWORD                     Width,
                            DWORD                     Height,
                            DWORD                     BitsPerPixel,
                            DWORD                     RefreshRate)
{
    DEVMODE dm;
    LPSTR pDeviceName;
    int i;

    pDeviceName = (_stricmp(pdrv->cDriverName, "display") == 0) ?
        g_szPrimaryDisplay : pdrv->cDriverName;

    for (i = 0;; i++)
    {
        ZeroMemory(&dm, sizeof dm);
        dm.dmSize = sizeof dm;

        if (EnumDisplaySettings(pDeviceName, i, &dm))
        {
            if ((dm.dmPelsWidth == Width) &&
                (dm.dmPelsHeight == Height) &&
                (dm.dmBitsPerPel == BitsPerPixel) &&
                (dm.dmDisplayFrequency == RefreshRate))
            {
                return TRUE;
            }
        }
        else
        {
            break;
        }
    }

    return FALSE;
}

/*
 * PickRefreshRate
 *
 * On NT, we want to pick a high reffresh rate, but we don't want to pick one 
 * too high.  In theory, mode pruning would be 100% safe and we can always pick
 * a high one, but we don't trust it 100%.  
 */
DWORD PickRefreshRate(LPDDRAWI_DIRECTDRAW_GBL   pdrv,
                      DWORD                     Width,
                      DWORD                     Height,
                      DWORD                     RefreshRate,
                      DWORD                     BitsPerPixel)
{
    DEVMODE dm;
    LPSTR pDeviceName;

    pDeviceName = (_stricmp(pdrv->cDriverName, "display") == 0) ?
        g_szPrimaryDisplay : pdrv->cDriverName;
    
    if (dwRegFlags & DDRAW_REGFLAGS_FORCEREFRESHRATE)
    {
        if (IsRefreshRateSupported(pdrv,
                                   Width,
                                   Height,
                                   BitsPerPixel,
                                   dwForceRefreshRate))
        {
            return dwForceRefreshRate;
        }
    }

    // If the app specified the refresh rate, we will use it; otherwise, we'll
    // pick one ourselves.
    if (RefreshRate == 0)
    {
        // If the mode requires no more bandwidth than the desktop mode from which
        // the app was launched, we will go ahead and try that mode.
        ZeroMemory(&dm, sizeof dm);
        dm.dmSize = sizeof dm;

        EnumDisplaySettings(pDeviceName, ENUM_REGISTRY_SETTINGS, &dm);

        if ((Width <= dm.dmPelsWidth) &&
            (Height <= dm.dmPelsHeight))
        {
            if (IsRefreshRateSupported(pdrv,
                                       Width,
                                       Height,
                                       BitsPerPixel,
                                       dm.dmDisplayFrequency))
            {
                RefreshRate = dm.dmDisplayFrequency;
            }
        }

        // If we still don't have a refresh rate, try 75hz
        if (RefreshRate == 0)
        {
            if (IsRefreshRateSupported(pdrv,
                                       Width,
                                       Height,
                                       BitsPerPixel,
                                       75))
            {
                RefreshRate = 75;
            }
        }

        // If we still don't have a refresh rate, use 60hz
        if (RefreshRate == 0)
        {
            if (IsRefreshRateSupported(pdrv,
                                       Width,
                                       Height,
                                       BitsPerPixel,
                                       60))
            {
                RefreshRate = 60;
            }
        }
    }

    return RefreshRate;
}

HRESULT SetDisplayMode(
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl,
    DWORD index,
    BOOL force,
    BOOL useRefreshRate)
{
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    DEVMODE dm;
    LONG result;
    BOOL bNewMode;
    DDHALINFO ddhi;
    LPCTSTR pszDevice;
    DWORD refreshRate;
    BOOL forceRefresh;

    pdd_lcl->dwLocalFlags |= DDRAWILCL_MODEHASBEENCHANGED;

    pdd_gbl = pdd_lcl->lpGbl;

    //
    // If not forcing, do not change mode with surface locks.
    //

    if (!force)
    {
        if (pdd_gbl->dwSurfaceLockCount > 0)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pTemp; 

            // When we enabled vidmem vertex buffers in DX8, we found that some
            // apps do not unlock them before the mode change, but we don't want
            // to break them now, so we will hack around this by allowing the 
            // mode switch to occur if all that's locked are vidmem VBs.

            pTemp = pdd_gbl->dsList;
            while (pTemp != NULL)
            {
                if (pTemp->lpLcl->lpGbl->dwUsageCount > 0)
                {
                    if ((pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                        !(pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                    {
                        break;
                    }
                }
                pTemp = pTemp->lpLink;
            }

            if (pTemp != NULL)
            {
                return DDERR_SURFACEBUSY;
            }
        }
    }

    //
    // Add code here to not set mode if it didn't change?
    //

    ZeroMemory(&dm, sizeof dm);
    dm.dmSize = sizeof dm;

    dm.dmBitsPerPel = pdd_lcl->dmiPreferred.wBPP;
    dm.dmPelsWidth = pdd_lcl->dmiPreferred.wWidth;
    dm.dmPelsHeight = pdd_lcl->dmiPreferred.wHeight;

    if (dm.dmBitsPerPel == 16)
    {
        if (pdd_gbl->lpModeInfo->wFlags & DDMODEINFO_555MODE)
        {
            dm.dmBitsPerPel = 15;
        }
    }

    dm.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;

    if (useRefreshRate)
    {
        dm.dmDisplayFrequency = PickRefreshRate(pdd_lcl->lpGbl,
                                      dm.dmPelsWidth,
                                      dm.dmPelsHeight,
                                      pdd_lcl->dmiPreferred.wRefreshRate,
                                      dm.dmBitsPerPel);
        dm.dmFields |= DM_DISPLAYFREQUENCY;
    }
    else
    {
        dm.dmDisplayFrequency = PickRefreshRate(pdd_lcl->lpGbl,
                                      dm.dmPelsWidth,
                                      dm.dmPelsHeight,
                                      0,
                                      dm.dmBitsPerPel);
        if (dm.dmDisplayFrequency > 0)
        {
            dm.dmFields |= DM_DISPLAYFREQUENCY;
            pdd_lcl->dmiPreferred.wRefreshRate = (WORD) dm.dmDisplayFrequency;
        }
    }

    if (_stricmp(pdd_gbl->cDriverName, "DISPLAY"))
    {
        pszDevice = pdd_gbl->cDriverName;
    }
    else
    {
        pszDevice = NULL;
    }

    // clean up any previous modex stuff:
    pdd_gbl->dwFlags &= ~DDRAWI_MODEX;

    NotifyDriverToDeferFrees();

    pdd_gbl->dwFlags |= DDRAWI_CHANGINGMODE;
    result = ChangeDisplaySettingsEx(pszDevice, &dm, NULL, CDS_FULLSCREEN, 0);
    pdd_gbl->dwFlags &= ~DDRAWI_CHANGINGMODE;

    DPF(5, "ChangeDisplaySettings: %d", result);

    if (result != DISP_CHANGE_SUCCESSFUL)
    {
        //
        // Check if it's a potentially emulated ModeX mode
        //
        if (pdd_lcl->dwLocalFlags & DDRAWILCL_ALLOWMODEX)
        {
            if (pdd_lcl->dmiPreferred.wBPP == MODEX_BPP &&
                pdd_lcl->dmiPreferred.wWidth == MODEX_WIDTH)
            {
                if (pdd_lcl->dmiPreferred.wHeight == MODEX_HEIGHT2 || pdd_lcl->dmiPreferred.wHeight == MODEX_HEIGHT1)
                {
                    // Set 640x480x8 for consistency with win9x and reliable mouse pos messages.
                    dm.dmFields &= ~DM_DISPLAYFREQUENCY;
                    dm.dmPelsWidth = 640;
                    dm.dmPelsHeight = 480;

                    pdd_gbl->dwFlags |= DDRAWI_CHANGINGMODE;
                    result = ChangeDisplaySettingsEx(pszDevice, &dm, NULL, CDS_FULLSCREEN, 0);
                    pdd_gbl->dwFlags &= ~DDRAWI_CHANGINGMODE;
                }
            }
        }

        if (result == DISP_CHANGE_SUCCESSFUL)
        {
            //now we are in 640x480, we need to mark the ddraw local that it's in emulated modex
            pdd_gbl->dwFlags |= DDRAWI_MODEX;
        }
        else
        {
            //failed to set 640x480
            NotifyDriverOfFreeAliasedLocks();
            return DDERR_UNSUPPORTED;
        }
    }

    uDisplaySettingsUnique = DdQueryDisplaySettingsUniqueness();

    resetAllDirectDrawObjects();
    
    pdd_lcl->dwLocalFlags |= DDRAWILCL_MODEHASBEENCHANGED | DDRAWILCL_DIRTYDC;

    return DD_OK;
}

//=============================================================================
//
//  Function: DD_SetDisplayMode
//
//=============================================================================

HRESULT DDAPI DD_SetDisplayMode(
    LPDIRECTDRAW pdd,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP)
{
    DPF(2,A,"ENTERAPI: DD_SetDisplayMode");
	
    return DD_SetDisplayMode2(pdd, dwWidth, dwHeight, dwBPP, 0, 0);
}

//=============================================================================
//
//  Function: DD_SetDisplayMode2
//
//=============================================================================

HRESULT DDAPI DD_SetDisplayMode2(
    LPDIRECTDRAW pdd,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP,
    DWORD dwRefreshRate,
    DWORD dwFlags)
{
    LPDDRAWI_DIRECTDRAW_INT pdd_int;
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    HRESULT hr;
    DISPLAYMODEINFO dmiSave;
    BOOL excl_exists,has_excl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_SetDisplayMode2");

    TRY
    {
        pdd_int = (LPDDRAWI_DIRECTDRAW_INT) pdd;
        if (!VALID_DIRECTDRAW_PTR(pdd_int))
        {
            DPF(0, "Invalid object");
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        if (dwFlags & ~DDSDM_VALID)
        {
            DPF_ERR("Invalid flags");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        pdd_lcl = pdd_int->lpLcl;
        pdd_gbl = pdd_lcl->lpGbl;

        if (pdd_gbl->dwSurfaceLockCount > 0)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pTemp; 

            // When we enabled vidmem vertex buffers in DX8, we found that some
            // apps do not unlock them before the mode change, but we don't want
            // to break them now, so we will hack around this by allowing the 
            // mode switch to occur if all that's locked are vidmem VBs.

            pTemp = pdd_gbl->dsList;
            while (pTemp != NULL)
            {
                if (pTemp->lpLcl->lpGbl->dwUsageCount > 0)
                {
                    if ((pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                        !(pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                    {
                        break;
                    }
                }
                pTemp = pTemp->lpLink;
            }

            if (pTemp != NULL)
            {
                DPF_ERR("Surfaces are locked, can't switch the mode");
                LEAVE_DDRAW();
                return DDERR_SURFACEBUSY;
            }
        }

        CheckExclusiveMode(pdd_lcl, &excl_exists, &has_excl, FALSE, NULL, FALSE);
        if (excl_exists &&
            (!has_excl))
        {
            DPF_ERR("Can't change mode; exclusive mode not owned");
            LEAVE_DDRAW();
            return DDERR_NOEXCLUSIVEMODE;
        }

        dmiSave = pdd_lcl->dmiPreferred;

        pdd_lcl->dmiPreferred.wWidth = (WORD) dwWidth;
        pdd_lcl->dmiPreferred.wHeight = (WORD) dwHeight;
        pdd_lcl->dmiPreferred.wBPP = (BYTE) dwBPP;
        pdd_lcl->dmiPreferred.wRefreshRate = (WORD) dwRefreshRate;
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("DD_SetDisplayMode2: Exception encountered validating parameters");
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    hr = SetDisplayMode(pdd_lcl, 0, FALSE, dwRefreshRate ? TRUE : FALSE);
    if (FAILED(hr))
    {
        pdd_lcl->dmiPreferred = dmiSave;
    }
    else
    {
        pdd_lcl->dmiPreferred = pdd_gbl->dmiCurrent;
    }

    LEAVE_DDRAW();

    return hr;
}

//=============================================================================
//
//  Function: RestoreDisplayMode
//
//=============================================================================

HRESULT RestoreDisplayMode(LPDDRAWI_DIRECTDRAW_LCL pdd_lcl, BOOL force)
{
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    LPCTSTR pszDevice;
    LONG result;

    pdd_gbl = pdd_lcl->lpGbl;

    pdd_gbl->dwFlags &= ~DDRAWI_MODEX;

    if (!(pdd_lcl->dwLocalFlags & DDRAWILCL_MODEHASBEENCHANGED))
    {
        DPF(2, "Mode was never changed by this app");
        return DD_OK;
    }

    if (!force)
    {
        if (pdd_gbl->dwSurfaceLockCount > 0)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pTemp; 

            // When we enabled vidmem vertex buffers in DX8, we found that some
            // apps do not unlock them before the mode change, but we don't want
            // to break them now, so we will hack around this by allowing the 
            // mode switch to occur if all that's locked are vidmem VBs.

            pTemp = pdd_gbl->dsList;
            while (pTemp != NULL)
            {
                if (pTemp->lpLcl->lpGbl->dwUsageCount > 0)
                {
                    if ((pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                        !(pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                    {
                        break;
                    }
                }
                pTemp = pTemp->lpLink;
            }

            if (pTemp != NULL)
            {
                return DDERR_SURFACEBUSY;
            }
        }
    }

    if (_stricmp(pdd_gbl->cDriverName, "DISPLAY"))
    {
        pszDevice = pdd_gbl->cDriverName;
    }
    else
    {
        pszDevice = NULL;
    }

    NotifyDriverToDeferFrees();
    pdd_gbl->dwFlags |= DDRAWI_CHANGINGMODE;
    result = ChangeDisplaySettingsEx(pszDevice, NULL, NULL, CDS_FULLSCREEN, 0);
    pdd_gbl->dwFlags &= ~DDRAWI_CHANGINGMODE;

    if (result != DISP_CHANGE_SUCCESSFUL)
    {
        NotifyDriverOfFreeAliasedLocks();
        return DDERR_UNSUPPORTED;
    }

    //
    // FetchDirectDrawData here, which will update the global object with
    // the new mode information.
    //

    uDisplaySettingsUnique = DdQueryDisplaySettingsUniqueness();

    resetAllDirectDrawObjects();

    pdd_lcl->dwLocalFlags &= ~DDRAWILCL_MODEHASBEENCHANGED;
    pdd_lcl->dwLocalFlags |= DDRAWILCL_DIRTYDC;

    RedrawWindow(NULL, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);

    return DD_OK;
}

//=============================================================================
//
//  Function: DD_RestoreDisplayMode
//
//=============================================================================

HRESULT DDAPI DD_RestoreDisplayMode(LPDIRECTDRAW pdd)
{
    LPDDRAWI_DIRECTDRAW_INT pdd_int;
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    BOOL excl_exists,has_excl;
    HRESULT hr;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_RestoreDisplayMode");

    TRY
    {
        pdd_int = (LPDDRAWI_DIRECTDRAW_INT) pdd;
        if (!VALID_DIRECTDRAW_PTR(pdd_int))
        {
            DPF(0, "Invalid object");
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        pdd_lcl = pdd_int->lpLcl;
        pdd_gbl = pdd_lcl->lpGbl;

        CheckExclusiveMode(pdd_lcl, &excl_exists, &has_excl, FALSE, NULL, FALSE);
        if (excl_exists &&
            (!has_excl))
        {
            DPF_ERR("Can't change mode; exclusive mode owned");
            LEAVE_DDRAW();
            return DDERR_NOEXCLUSIVEMODE;
        }

        if (pdd_gbl->dwSurfaceLockCount > 0)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pTemp; 

            // When we enabled vidmem vertex buffers in DX8, we found that some
            // apps do not unlock them before the mode change, but we don't want
            // to break them now, so we will hack around this by allowing the 
            // mode switch to occur if all that's locked are vidmem VBs.

            pTemp = pdd_gbl->dsList;
            while (pTemp != NULL)
            {
                if (pTemp->lpLcl->lpGbl->dwUsageCount > 0)
                {
                    if ((pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                        !(pTemp->lpLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                    {
                        break;
                    }
                }
                pTemp = pTemp->lpLink;
            }

            if (pTemp != NULL)
            {
                DPF_ERR("Surfaces are locked, can't switch the mode");
                LEAVE_DDRAW();
                return DDERR_SURFACEBUSY;
            }
        }
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("DD_RestoreDisplayMode: Exception encountered validating parameters");
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    hr = RestoreDisplayMode(pdd_lcl, TRUE);

    LEAVE_DDRAW();

    return hr;
}

//=============================================================================
//
//  Function: DD_EnumDisplayModes
//
//=============================================================================

HRESULT DDAPI DD_EnumDisplayModes(
    LPDIRECTDRAW pdd,
    DWORD dwFlags,
    LPDDSURFACEDESC pddsd,
    LPVOID pContext,
    LPDDENUMMODESCALLBACK pEnumCallback)
{
    DPF(2,A,"ENTERAPI: DD_EnumDisplayModes");

    if (pddsd)
    {
        DDSURFACEDESC2 ddsd2;

        TRY
        {
            if(!VALID_DIRECTDRAW_PTR(((LPDDRAWI_DIRECTDRAW_INT) pdd)))
            {
                return DDERR_INVALIDOBJECT;
            }

            if(!VALID_DDSURFACEDESC_PTR(pddsd))
            {
                DPF_ERR("Invalid surface description. Did you set the dwSize member?");
                DPF_APIRETURNS(DDERR_INVALIDPARAMS);
                return DDERR_INVALIDPARAMS;
            }

            CopyMemory(&ddsd2, pddsd, sizeof *pddsd);
        }
        EXCEPT(EXCEPTION_EXECUTE_HANDLER)
        {
            DPF_ERR("Exception encountered validating parameters: Bad LPDDSURFACEDESC");
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }

        ddsd2.dwSize = sizeof ddsd2;
        ZeroMemory(((LPBYTE)&ddsd2 + sizeof *pddsd), (sizeof ddsd2) - (sizeof *pddsd));

        return DD_EnumDisplayModes4(pdd, dwFlags, &ddsd2, pContext, (LPDDENUMMODESCALLBACK2) pEnumCallback);
    }

    return DD_EnumDisplayModes4(pdd, dwFlags, NULL, pContext, (LPDDENUMMODESCALLBACK2) pEnumCallback);
}

BOOL EnumerateMode(
        LPDDRAWI_DIRECTDRAW_INT pdd_int,
        LPDDENUMMODESCALLBACK2 pEnumCallback,
        LPVOID pContext,
        WORD wWidth,
        WORD wHeight,
        WORD wBPP,
        WORD wRefreshRate,
        DWORD dwFlags,
        BOOL bIsEmulatedModex )
{
    DDSURFACEDESC2 ddsd;

    ZeroMemory(&ddsd, sizeof ddsd);

    if (LOWERTHANDDRAW4(pdd_int))
    {
        ddsd.dwSize = sizeof (DDSURFACEDESC);
    }
    else
    {
        ddsd.dwSize = sizeof (DDSURFACEDESC2);
    }

    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT | DDSD_PITCH | DDSD_REFRESHRATE;
    ddsd.dwWidth = wWidth;
    ddsd.dwHeight = wHeight;
    ddsd.lPitch = (ddsd.dwWidth * wBPP) >> 3; // hack

    setPixelFormat(&(ddsd.ddpfPixelFormat), NULL, wBPP);

    if (dwFlags & DDEDM_REFRESHRATES)
    {
        ddsd.dwRefreshRate = wRefreshRate;
    }
    else
    {
        ddsd.dwRefreshRate = 0;
    }

    if ( bIsEmulatedModex )
    {
        ddsd.ddsCaps.dwCaps |= DDSCAPS_MODEX;
    } else
    { 
        // call driver here if this is a stereo mode!!!
        if (!LOWERTHANDDRAW7(pdd_int) &&
            GetDDStereoMode(pdd_int->lpLcl->lpGbl,
                            wWidth,
                            wHeight,
                            wBPP,
                            ddsd.dwRefreshRate))
        {
            ddsd.ddsCaps.dwCaps2 |= DDSCAPS2_STEREOSURFACELEFT;
        }
    }
    return pEnumCallback(&ddsd, pContext);
}
//=============================================================================
//
//  Function: DD_EnumDisplayModes4
//
//=============================================================================

HRESULT DDAPI DD_EnumDisplayModes4(
    LPDIRECTDRAW pdd,
    DWORD dwFlags,
    LPDDSURFACEDESC2 pddsd,
    LPVOID pContext,
    LPDDENUMMODESCALLBACK2 pEnumCallback)
{
    LPDDRAWI_DIRECTDRAW_INT pdd_int;
    LPDDRAWI_DIRECTDRAW_LCL pdd_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdd_gbl;
    HRESULT hr;
    DEVMODE dm;
    int i, j;
    DWORD dwResult;
    DISPLAYMODEINFO *pdmi;
    DISPLAYMODEINFO *pdmiTemp;
    int numModes;
    int maxModes;
    LPCTSTR pszDevice;
    BOOL                    bFound320x240x8 = FALSE;
    BOOL                    bFound320x200x8 = FALSE;
    BOOL                    bFound640x480x8 = FALSE;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_EnumDisplayModes4");

    TRY
    {
        pdd_int = (LPDDRAWI_DIRECTDRAW_INT) pdd;
        if (!VALID_DIRECTDRAW_PTR(pdd_int))
        {
            DPF(0, "Invalid object");
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        pdd_lcl = pdd_int->lpLcl;
        pdd_gbl = pdd_lcl->lpGbl;

        if (pddsd && !VALID_DDSURFACEDESC2_PTR(pddsd))
        {
            DPF_ERR("Invalid surface description");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if (dwFlags & ~DDEDM_VALID)
        {
            DPF_ERR("Invalid flags");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if (!VALIDEX_CODE_PTR(pEnumCallback))
        {
            DPF_ERR("Invalid enumerate callback pointer");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("Exception encountered validating parameters: Bad LPDDSURFACEDESC");
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    maxModes = 256; // enough to handle most drivers

    pdmi = LocalAlloc(LMEM_FIXED, maxModes * sizeof (DISPLAYMODEINFO));
    if (!pdmi)
    {
        DPF_ERR("Out of memory building mode list");
        LEAVE_DDRAW();
        return DDERR_GENERIC;
    }

    if (_stricmp(pdd_gbl->cDriverName, "DISPLAY"))
    {
        pszDevice = pdd_gbl->cDriverName;
    }
    else
    {
        pszDevice = NULL;
    }

    dm.dmSize = sizeof(dm);
    for (numModes = 0, j = 0; EnumDisplaySettings(pszDevice, j, &dm); ++j)
    {
        //Filter MODEX driver modes
        if ( (_stricmp(dm.dmDeviceName,"MODEX") == 0) || (_stricmp(dm.dmDeviceName,"VGA") == 0) )
        {
            DPF(5,"Filtered mode %dx%dx%d from %s",dm.dmPelsWidth,dm.dmPelsHeight,dm.dmBitsPerPel,dm.dmDeviceName);
            continue;
        }

        if (dm.dmBitsPerPel == MODEX_BPP)
        {
            if (dm.dmPelsWidth == MODEX_WIDTH)
            {
                if (dm.dmPelsHeight == MODEX_HEIGHT1)
                    bFound320x200x8 = TRUE;
                if (dm.dmPelsHeight == MODEX_HEIGHT2)
                    bFound320x240x8 = TRUE;
            }
            if (dm.dmPelsWidth == 640 && dm.dmPelsHeight == 480)
                bFound640x480x8 = TRUE;
        }

        //Filter less than 256 color modes
        if (dm.dmBitsPerPel < 8)
        {
            continue;
        }

        //
        // NOTE: If the driver supports 15 bpp but not 16, then
        // EnumDisplaySettings will return 16 for compatibility reasons. The
        // bitmasks we fill in will be for 16 bpp (since we can't determine
        // which mode it really is), so they may be incorrect.
        //
        // There should never be a case where we got only 15 bpp. If a driver
        // only supports 555, it should be reported as 16 bpp.
        //

        if (dm.dmBitsPerPel == 15)
        {
            dm.dmBitsPerPel = 16;
        }

        //
        // If the caller supplied a DDSURFACEDESC, check for width,
        // height, bpp, and refresh rate for a match.
        //

        if (pddsd &&
            (((pddsd->dwFlags & DDSD_WIDTH) &&
            (dm.dmPelsWidth != pddsd->dwWidth)) ||
            ((pddsd->dwFlags & DDSD_HEIGHT) &&
            (dm.dmPelsHeight != pddsd->dwHeight)) ||
            ((pddsd->dwFlags & DDSD_PIXELFORMAT) &&
            (dm.dmBitsPerPel != pddsd->ddpfPixelFormat.dwRGBBitCount)) ||
            ((pddsd->dwFlags & DDSD_REFRESHRATE) &&
            (dm.dmDisplayFrequency != pddsd->dwRefreshRate))))
        {
            continue; // current mode does not match criteria
        }

        //
        // Check to see if mode is already in the list. The flag which
        // affects this is DDEDM_REFRESHRATES.
        //

        for (i = 0; i < numModes; ++i)
        {
            if ((dm.dmPelsWidth == pdmi[i].wWidth) &&
                (dm.dmPelsHeight == pdmi[i].wHeight) &&
                (dm.dmBitsPerPel == pdmi[i].wBPP))
            {
                if (dwFlags & DDEDM_REFRESHRATES)
                {
                    if (dm.dmDisplayFrequency == pdmi[i].wRefreshRate)
                    {
                        break; // found a match
                    }
                }
                else
                {
                    break; // found a match
                }
            }
        }
        if (i < numModes)
        {
            continue; // mode already in list
        }

        pdmi[numModes].wWidth = (WORD) dm.dmPelsWidth;
        pdmi[numModes].wHeight = (WORD) dm.dmPelsHeight;
        pdmi[numModes].wBPP = (BYTE) dm.dmBitsPerPel;
        pdmi[numModes].wRefreshRate = (dwFlags & DDEDM_REFRESHRATES) ?
            (WORD) dm.dmDisplayFrequency : 0;

        if (++numModes >= maxModes)
        {
            if (maxModes < 8192)
            {
                maxModes <<= 1;

                pdmiTemp = LocalAlloc(LMEM_FIXED, maxModes * sizeof (DISPLAYMODEINFO));
                if (pdmiTemp)
                {
                    CopyMemory(pdmiTemp, pdmi, numModes * sizeof (DISPLAYMODEINFO));
                    LocalFree(pdmi);
                    pdmi = pdmiTemp;
                }
                else
                {
                    LocalFree(pdmi);
                    DPF_ERR("Out of memory expanding mode list");
                    LEAVE_DDRAW();
                    return DDERR_GENERIC;
                }
            }
            else
            {
                LocalFree(pdmi);
                DPF_ERR("Too many display modes");
                LEAVE_DDRAW();
                return DDERR_GENERIC;
            }
        }
    }

    //
    // Should we sort modes here? Probably not.
    //

    for (i = 0; i < numModes; ++i)
    {
        if (!EnumerateMode(
            pdd_int,
            pEnumCallback, pContext,
            pdmi[i].wWidth,
            pdmi[i].wHeight,
            pdmi[i].wBPP,
            pdmi[i].wRefreshRate,
            dwFlags,
            FALSE )) //not a modex mode
        {
            break;
        }
    }

    //
    // Enumerate emulated modex modes if required
    //
    while (1)
    {
        if (pdd_lcl->dwLocalFlags & DDRAWILCL_ALLOWMODEX)
        {
            //640x480 is necessary to turn on emulation
            if ( bFound640x480x8 )
            {
                if ( !bFound320x200x8 )
                {
                    if (!EnumerateMode(
                        pdd_int,
                        pEnumCallback, pContext,
                        MODEX_WIDTH,MODEX_HEIGHT1,MODEX_BPP,60,
                        dwFlags,
                        TRUE )) //not a modex mode
                    {
                        break;
                    }
                }
                if ( !bFound320x240x8 )
                {
                    if (!EnumerateMode(
                        pdd_int,
                        pEnumCallback, pContext,
                        MODEX_WIDTH,MODEX_HEIGHT2,MODEX_BPP,60,
                        dwFlags,
                        TRUE )) //not a modex mode
                    {
                        break;
                    }
                }
            }
        }
        break;
    }

    LocalFree(pdmi);
    LEAVE_DDRAW();

    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddkmmini.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkmmini.h
 *  Content:	Mini VDD support for DirectDraw
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   31-jan-97	scottm	initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDKMMINI_INCLUDED__
#define __DDKMMINI_INCLUDED__


/*============================================================================
 *
 * DDHAL table filled in by the Mini VDD and called by DirectDraw
 *
 *==========================================================================*/

typedef DWORD (* MINIPROC)(VOID);

typedef struct _DDMINIVDDTABLE {
    DWORD	dwMiniVDDContext;
    MINIPROC	vddGetIRQInfo;
    MINIPROC	vddIsOurIRQ;
    MINIPROC	vddEnableIRQ;
    MINIPROC	vddSkipNextField;
    MINIPROC	vddBobNextField;
    MINIPROC	vddSetState;
    MINIPROC	vddLock;
    MINIPROC	vddFlipOverlay;
    MINIPROC	vddFlipVideoPort;
    MINIPROC	vddGetPolarity;
    MINIPROC	vddReserved1;
    MINIPROC	vddGetCurrentAutoflip;
    MINIPROC	vddGetPreviousAutoflip;
    MINIPROC	vddTransfer;
    MINIPROC	vddGetTransferStatus;
} DDMINIVDDTABLE;
typedef DDMINIVDDTABLE *LPDDMINIVDDTABLE;


/*============================================================================
 *
 * MDL structure for handling pagelocked memory.  This is copied from WDM.H
 *
 *==========================================================================*/

typedef struct _MDL {
    struct _MDL *MdlNext;
    short MdlSize;
    short MdlFlags;
    struct _EPROCESS *Process;
    ULONG *lpMappedSystemVa;
    ULONG *lpStartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL;
typedef MDL *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_LOCK_HELD               0x0200
#define MDL_SCATTER_GATHER_VA       0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000
#define MDL_64_BIT_VA               0x8000

#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_LOCK_HELD               | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )

typedef DWORD *PKEVENT;

/*============================================================================
 *
 * Structures maintained by DirectDraw
 *
 *==========================================================================*/

//
// Data for every kernel mode surface
//
typedef struct _DDSURFACEDATA {
    DWORD	dwSize;			// Structure size
    DWORD	ddsCaps;		// Ring 3 creation caps
    DWORD	dwSurfaceOffset;	// Offset in frame buffer of surface
    DWORD	fpLockPtr;		// Surface lock ptr
    DWORD	dwWidth;		// Surface width
    DWORD	dwHeight;		// Surface height
    LONG	lPitch;			// Surface pitch
    DWORD	dwOverlayFlags;		// DDOVER_XX flags
    DWORD	dwOverlayOffset;	// Offset in frame buffer of overlay
    DWORD	dwOverlaySrcWidth;	// Src width of overlay
    DWORD	dwOverlaySrcHeight;	// Src height of overlay
    DWORD	dwOverlayDestWidth;	// Dest width of overlay
    DWORD	dwOverlayDestHeight;	// Dest height of overlay
    DWORD	dwVideoPortId; 		// ID of video port (-1 if not connected to a video port)
    ULONG	pInternal1;		// Private
    ULONG	pInternal2;		// Private
    ULONG	pInternal3;		// Private
    DWORD	dwFormatFlags;
    DWORD	dwFormatFourCC;
    DWORD	dwFormatBitCount;
    DWORD	dwRBitMask;
    DWORD	dwGBitMask;
    DWORD	dwBBitMask;
    DWORD	dwSurfInternalFlags;	// Private internal flags
    DWORD	dwIndex;		// Private
    DWORD	dwRefCnt;		// Private
    DWORD	dwDriverReserved1;	// Reserved for the HAL/Mini VDD
    DWORD	dwDriverReserved2;	// Reserved for the HAL/Mini VDD
    DWORD	dwDriverReserved3;	// Reserved for the HAL/Mini VDD
} DDSURFACEDATA;
typedef DDSURFACEDATA * LPDDSURFACEDATA;

//
// Data for every kernel mode video port
//
typedef struct DDVIDEOPORTDATA {
    DWORD	dwSize;			// Structure size
    DWORD	dwVideoPortId;		// ID of video port (0 - MaxVideoPorts-1)
    DWORD	dwVPFlags;		// Offset in frame buffer of surface
    DWORD	dwOriginOffset;		// Start address relative to surface
    DWORD	dwHeight;		// Height of total video region (per field)
    DWORD	dwVBIHeight;		// Height of VBI region (per field)
    DWORD	dwDriverReserved1;	// Reserved for the HAL/Mini VDD
    DWORD	dwDriverReserved2;	// Reserved for the HAL/Mini VDD
    DWORD	dwDriverReserved3;	// Reserved for the HAL/Mini VDD
} DDVIDEOPORTDATA;
typedef DDVIDEOPORTDATA *LPDDVIDEOPORTDATA;


/*============================================================================
 *
 * Structures used to communicate with the Mini VDD
 *
 *==========================================================================*/

// Output from vddGetIRQInfo
typedef struct _DDGETIRQINFO {
    DWORD	dwSize;
    DWORD	dwFlags;
    DWORD	dwIRQNum;
} DDGETIRQINFO;
#define IRQINFO_HANDLED                 0x01    // Mini VDD is managing IRQ
#define IRQINFO_NOTHANDLED              0x02    // Mini VDD wants VDD to manage the IRQ
#define IRQINFO_NODISABLEFORDOSBOX      0x04    // DDraw should  not tell mini VDD to disable IRQs when DOS boxes
                                                //  occur because they might still be able to operate in this mode

// Input to vddEnableIRQ
typedef struct _DDENABLEIRQINFO {
    DWORD dwSize;
    DWORD dwIRQSources;
    DWORD dwLine;
    DWORD IRQCallback;	// Mini VDD calls this when IRQ happens if they are managing the IRQ
    DWORD dwContext;	// Context to be specified in EBX when IRQCallback is called
} DDENABLEIRQINFO;

// Input to vddFlipVideoPort
typedef struct _DDFLIPVIDEOPORTINFO {
    DWORD dwSize;
    DWORD lpVideoPortData;
    DWORD lpCurrentSurface;
    DWORD lpTargetSurface;
    DWORD dwFlipVPFlags;
} DDFLIPVIDEOPORTINFO;

// Input to vddFlipOverlay
typedef struct _DDFLIPOVERLAYINFO {
    DWORD dwSize;
    DWORD lpCurrentSurface;
    DWORD lpTargetSurface;
    DWORD dwFlags;
} DDFLIPOVERLAYINFO;

// Input to vddSetState
typedef struct _DDSTATEININFO {
    DWORD dwSize;
    DWORD lpSurfaceData;
    DWORD lpVideoPortData;
} DDSTATEININFO;

// Output from vddSetState
typedef struct _DDSTATEOUTINFO {
    DWORD dwSize;
    DWORD dwSoftwareAutoflip;
    DWORD dwSurfaceIndex;
    DWORD dwVBISurfaceIndex;
} DDSTATEOUTINFO;

// Input to vddGetPolarity
typedef struct _DDPOLARITYININFO {
    DWORD dwSize;
    DWORD lpVideoPortData;
} DDPOLARITYININFO;

// Output from vddGetPolarity
typedef struct _DDPOLARITYOUTINFO {
    DWORD dwSize;
    DWORD bPolarity;
} DDPOLARITYOUTINFO;

// Input to vddLock
typedef struct _DDLOCKININFO {
    DWORD dwSize;
    DWORD lpSurfaceData;
} DDLOCKININFO;

// Output from vddLock
typedef struct _DDLOCKOUTINFO {
    DWORD dwSize;
    DWORD dwSurfacePtr;
} DDLOCKOUTINFO;

// Input to vddBobNextField
typedef struct _DDBOBINFO {
    DWORD dwSize;
    DWORD lpSurface;
} DDBOBINFO;

// Input to vddSkipNextField
typedef struct _DDSKIPINFO {
    DWORD dwSize;
    DWORD lpVideoPortData;
    DWORD dwSkipFlags;
} DDSKIPINFO;

// Input to vddSetSkipPattern
typedef struct _DDSETSKIPINFO {
    DWORD dwSize;
    DWORD lpVideoPortData;
    DWORD dwPattern;
    DWORD dwPatternSize;
} DDSETSKIPINFO;

// Input to vddGetCurrent/PreviousAutoflip
typedef struct _DDGETAUTOFLIPININFO {
    DWORD dwSize;
    DWORD lpVideoPortData;
} DDGETAUTOFLIPININFO;

// Output from vddGetCurrent/PreviousAutoflip
typedef struct _DDGETAUTOFLIPOUTINFO {
    DWORD dwSize;
    DWORD dwSurfaceIndex;
    DWORD dwVBISurfaceIndex;
} DDGETAUTOFLIPOUTINFO;

// Input to vddTransfer
typedef struct _DDTRANSFERININFO {
    DWORD dwSize;
    DWORD lpSurfaceData;
    DWORD dwStartLine;
    DWORD dwEndLine;
    DWORD dwTransferID;
    DWORD dwTransferFlags;
    PMDL  lpDestMDL;
} DDTRANSFERININFO;

// Input to vddTransfer
typedef struct _DDTRANSFEROUTINFO {
    DWORD dwSize;
    DWORD dwBufferPolarity;
} DDTRANSFEROUTINFO;

// Input to vddGetTransferStatus
typedef struct _DDGETTRANSFERSTATUSOUTINFO {
    DWORD dwSize;
    DWORD dwTransferID;
} DDGETTRANSFERSTATUSOUTINFO;


//@@BEGIN_MSINTERNAL
  /*
   * The following IRQ flags are duplicated in DDKERNEL.H.  Any changes must
   * be made in both places!!!
   */
//@@END_MSINTERNAL
// IRQ source flags
#define DDIRQ_DISPLAY_VSYNC			0x00000001l
#define DDIRQ_BUSMASTER				0x00000002l
#define DDIRQ_VPORT0_VSYNC			0x00000004l
#define DDIRQ_VPORT0_LINE			0x00000008l
#define DDIRQ_VPORT1_VSYNC			0x00000010l
#define DDIRQ_VPORT1_LINE			0x00000020l
#define DDIRQ_VPORT2_VSYNC			0x00000040l
#define DDIRQ_VPORT2_LINE			0x00000080l
#define DDIRQ_VPORT3_VSYNC			0x00000100l
#define DDIRQ_VPORT3_LINE			0x00000200l
#define DDIRQ_VPORT4_VSYNC			0x00000400l
#define DDIRQ_VPORT4_LINE			0x00000800l
#define DDIRQ_VPORT5_VSYNC			0x00001000l
#define DDIRQ_VPORT5_LINE			0x00002000l
#define DDIRQ_VPORT6_VSYNC			0x00004000l
#define DDIRQ_VPORT6_LINE			0x00008000l
#define DDIRQ_VPORT7_VSYNC			0x00010000l
#define DDIRQ_VPORT7_LINE			0x00020000l
#define DDIRQ_VPORT8_VSYNC			0x00040000l
#define DDIRQ_VPORT8_LINE			0x00080000l
#define DDIRQ_VPORT9_VSYNC			0x00010000l
#define DDIRQ_VPORT9_LINE			0x00020000l
#define DDIRQ_MISCELLANOUS                      0x80000000l

// SkipNextField flags
#define DDSKIP_SKIPNEXT			1
#define DDSKIP_ENABLENEXT		2

//@@BEGIN_MSINTERNAL
  /*
   * The following flip flags are duplicated in DVP.H.  Any changes must
   * be made in both places!!!
   */
//@@END_MSINTERNAL
// Flip VP flags
#define DDVPFLIP_VIDEO			0x00000001l
#define DDVPFLIP_VBI			0x00000002l

//@@BEGIN_MSINTERNAL
   /*
    * The following flags correspond to the DDADDBUFF_XXXX flags defined
    * in DDKMAPI.H.  Please keep these in sync!
    */
//@@END_MSINTERNAL
#define DDTRANSFER_SYSTEMMEMORY		0x00000001
#define DDTRANSFER_NONLOCALVIDMEM	0x00000002
#define DDTRANSFER_INVERT		0x00000004
#define DDTRANSFER_CANCEL		0x00000080
#define DDTRANSFER_HALFLINES		0x00000100


//@@BEGIN_MSINTERNAL

    #define MAX_DDKM_DEVICES	9

    /*
     * The following flags are passed to UpdateVPInfo by ring 3 DDraw
     */
    #define DDKMVP_CREATE	0x0001	// Are creating video port
    #define DDKMVP_RELEASE	0x0002	// Are releasing video port
    #define DDKMVP_UPDATE	0x0004	// Are updating the video port
    #define DDKMVP_ON		0x0008	// Video port is on
    #define DDKMVP_AUTOFLIP  	0x0010	// Autoflipping should be performed in software
    #define DDKMVP_AUTOFLIP_VBI	0x0020	// Autoflipping VBI should be performed in software
    #define DDKMVP_NOIRQ	0x0040	// VP will not generate VSYNC IRQ
    #define DDKMVP_NOSKIP	0x0080	// VP cannot skip fields
    #define DDKMVP_HALFLINES	0x0100	// Due to half lines, even field data is shifted down one line

    /*
     * The following internal flags are stored in KMVPEDATA.dwInternalFlags
     * and maintain the internal state information.
     */
    #define DDVPIF_ON			0x0001	// The video port is on
    #define DDVPIF_AUTOFLIP		0x0002	// Video data is autoflipped using IRQ
    #define DDVPIF_AUTOFLIP_VBI		0x0004	// VBI data is autoflipped using IRQ
    #define DDVPIF_BOB			0x0008	// Video data using bob via the IRQ
    #define DDVPIF_NOIRQ		0x0010	// VP will not generate VSYNC IRQ
    #define DDVPIF_NOSKIP		0x0020	// VP cannot skip fields
    #define DDVPIF_CAPTURING		0x0040	// VP has capture buffers in queue
    #define DDVPIF_NEW_STATE		0x0080	// A new state change has been posted
    #define DDVPIF_SKIPPED_LAST		0x0100	// The previous field was skipped - VP needs restoring
    #define DDVPIF_SKIP_SET		0x0200	// dwStartSkip contains valid data needs restoring
    #define DDVPIF_NEXT_SKIP_SET	0x0400	// dwNextSkip contains valid data
    #define DDVPIF_FLIP_NEXT		0x0800	// This video field was not flipped due to interleaving
    #define DDVPIF_FLIP_NEXT_VBI	0x1000	// This VBI field was not flipped due to interleaving
    #define DDVPIF_VBI_INTERLEAVED	0x2000	// Is the VBI data interleaved?
    #define DDVPIF_HALFLINES      	0x4000	// Due to half lines, even field data is shifted down one line
    #define DDVPIF_DISABLEAUTOFLIP     	0x8000	// Overlay autolfipping is temporarily disabled

    /*
     * Device capabilities
     */
    #define DDKMDF_IN_USE			0x00000001	// Can bob while interleaved
    #define DDKMDF_CAN_BOB_INTERLEAVED		0x00000002	// Can bob while interleaved
    #define DDKMDF_CAN_BOB_NONINTERLEAVED	0x00000004	// Can bob while non-interleaved
    #define DDKMDF_NOSTATE			0x00000008	// No support for switching from bob/weave
    #define DDKMDF_TRANSITION 			0x00000010	// Currently in a full-screen DOS box or res-change
    #define DDKMDF_STARTDOSBOX                  0x00000020      // Interim flag required to make power downs behave like DOS boxes
    #define DDKMDF_NODISABLEIRQ                 0x00000040      // DDraw should  not tell mini VDD to disable IRQs when DOS boxes
                                                                //  occur because they might still be able to operate in this mode

    /*
     * Internal flags used to describe the VPE actions at IRQ time
     */
    #define ACTION_BOB		0x0001
    #define ACTION_FLIP		0x0002
    #define ACTION_FLIP_VBI	0x0004
    #define ACTION_STATE	0x0008
    #define ACTION_BUSMASTER	0x0010

    /*
     * Internal surface flags
     */
    #define DDKMSF_STATE_SET		0x00000001
    #define DDKMSF_TRANSFER		0x00000002

    typedef DWORD (* MINIPROC)(VOID);

    /*
     * Info about each registered event
     */
    #ifndef LPDD_NOTIFYCALLBACK
	typedef DWORD (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);
    #endif
    typedef struct _KMEVENTNODE {
    	DWORD		dwEvents;
	LPDD_NOTIFYCALLBACK pfnCallback;
    	DWORD		dwParam1;
    	DWORD		dwParam2;
    	ULONG		pContext;
    	struct _KMEVENTNODE *lpNext;
    } KMEVENTNODE;
    typedef KMEVENTNODE *LPKMEVENTNODE;

    /*
     * Info about each allocated handle
     */
    typedef struct _KMHANDLENODE {
    	DWORD		dwHandle;
    	LPDD_NOTIFYCALLBACK pfnCallback;
    	ULONG		pContext;
    	struct _KMHANDLENODE *lpNext;
    } KMHANDLENODE;
    typedef KMHANDLENODE *LPKMHANDLENODE;

    typedef struct KMCAPTUREBUFF {
	DWORD   dwBuffFlags;
	PMDL    pBuffMDL;
	PKEVENT pBuffKEvent;
	ULONG	*lpBuffInfo;
	DWORD	dwInternalBuffFlags;
	LPDDSURFACEDATA lpBuffSurface;
    } KMCAPTUREBUFF;
    typedef KMCAPTUREBUFF *LPKMCAPTUREBUFF;

    #define DDBUFF_INUSE		0x0001
    #define DDBUFF_READY		0x0002
    #define DDBUFF_WAITING		0x0004

    /*
     * Info about each capture stream
     */
    #define DDKM_MAX_CAP_BUFFS		10
    typedef struct _KMCAPTURENODE {
    	DWORD		dwHandle;
    	DWORD		dwStartLine;
    	DWORD		dwEndLine;
	DWORD		dwCaptureEveryNFields;
	DWORD		dwCaptureCountDown;
    	LPDD_NOTIFYCALLBACK pfnCaptureClose;
	ULONG		pContext;
	KMCAPTUREBUFF	kmcapQueue[DDKM_MAX_CAP_BUFFS];
	DWORD		bUsed;
	DWORD		dwTop;
	DWORD		dwBottom;
	DWORD		dwPrivateFlags;
	DWORD		dwTheTransferId;
    	struct _KMCAPTURENODE *lpNext;
    } KMCAPTURENODE;
    typedef KMCAPTURENODE *LPKMCAPTURENODE;

    #define DDKMCAPT_VBI	0x0001
    #define DDKMCAPT_VIDEO	0x0002

    /*
     * Info that is needed of each video port
     */
    typedef struct _KMVPEDATA {
        DDVIDEOPORTDATA	ddvpData; 		// Video port data
        DWORD		dwInternalFlags;	// DDVPIF_xxx flags
        DWORD		dwNumAutoflip;		// Number of surfaces being autoflipped
        DWORD		dwNumVBIAutoflip;	// Number of VBI surfaces being autoflipped
        DWORD		dwSurfaces[10];		// Surface receiving the data (up to 10 autoflipping)
        DWORD		dwVBISurfaces[10];	// Surface receiving VBI data (up to 10 autoflipping)
        DWORD		dwIRQCnt_VPSYNC;	// VP VSYNC IRQ usage cnt
	DWORD		dwIRQCnt_VPLine;	// VP line IRQ usage cnt
    	DWORD		dwIRQLine;		// Line # of line IRQ
    	DWORD		dwCurrentField; 	// Current field number
	DWORD		dwStartSkip;		// Next field to skip
	DWORD		dwNextSkip;		// Field to skip after dwStartSkip
    	DWORD		dwActions;		// Actions required by IRQ logic
    	DWORD		dwCurrentBuffer;        // Current buffer (for autoflipping)
    	DWORD		dwCurrentVBIBuffer;	// Current VBI buffer (for autoflipping)
    	DWORD		dwNewState;		// For handling state changes posted on a certain field
    	DWORD		dwStateStartField;	// Field on which to start a new state change
    	DWORD		dwRefCnt;		// Reference count
    	LPKMHANDLENODE	lpHandleList;
	LPKMCAPTURENODE lpCaptureList;
	DWORD		dwCaptureCnt;
    } KMVPEDATA;
    typedef KMVPEDATA *LPKMVPEDATA;

    /*
     * Info that is needed of each VGA
     */
    typedef struct _KMSTATEDATA {
    	DWORD		dwDeviceFlags;		// Device flags
    	ULONG		pContext;		// Passed to Mini VDD
    	DWORD		dwListHandle;  		// List of surface handles
    	LPKMVPEDATA	lpVideoPort;		// Array containing video port info
    	DWORD  		dwHigh;         	// For error checking
    	DWORD		dwLow;          	// For error checking
    	DWORD		dwMaxVideoPorts;	// Number of video ports supported by device
    	DWORD		dwNumVPInUse;		// Number of video ports currently in use
    	DWORD		dwIRQHandle;    	// IRQ Handle (if we are managing the IRQ)
    	DWORD		dwIRQFlags;		// Sources, etc.
    	DWORD		dwIRQCnt_VSYNC; 	// # times graphics VSYNC IRQ is requested
    	DWORD		dwEventFlags;		// Which IRQs have registered notification
    	DWORD		dwIRQEvents;		// Which IRQs occurred that require event notification
    	DWORD		dwRefCnt;
    	DWORD		dwDOSBoxEvent;
	DWORD		dwCaps;
	DWORD		dwIRQCaps;
    	LPKMEVENTNODE	lpEventList;
    	LPKMHANDLENODE	lpHandleList;
    	MINIPROC	pfnGetIRQInfo;
    	MINIPROC	pfnIsOurIRQ;
    	MINIPROC	pfnEnableIRQ;
    	MINIPROC	pfnSkipNextField;
    	MINIPROC	pfnBobNextField;
    	MINIPROC	pfnSetState;
    	MINIPROC	pfnLock;
    	MINIPROC	pfnFlipOverlay;
    	MINIPROC	pfnFlipVideoPort;
    	MINIPROC	pfnGetPolarity;
    	MINIPROC	pfnSetSkipPattern;
    	MINIPROC	pfnGetCurrentAutoflip;
    	MINIPROC	pfnGetPreviousAutoflip;
    	MINIPROC	pfnTransfer;
    	MINIPROC	pfnGetTransferStatus;
    } KMSTATEDATA;
    typedef KMSTATEDATA *LPKMSTATEDATA;


//@@END_MSINTERNAL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddpal.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddpal.c
 *  Content:	DirectDraw palette functions
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27-jan-95	craige	initial implementation
 *   11-mar-95	craige	more HAL fns, filled out CreatePalette
 *   19-mar-95	craige	use HRESULTs, process termination cleanup fixes
 *   26-mar-95	craige	filled out remaining fns
 *   28-mar-95	craige	switched to PALETTEENTRY from RGBQUAD
 *   31-mar-95	craige	use critical sections with palettes
 *   01-apr-95	craige	happy fun joy updated header file
 *   04-apr-95	craige	use driver directly in exclusive mode
 *   07-apr-95	craige	bug 14 - check GUID ptr in QI
 *   10-apr-95	craige	mods to process list stuff
 *   			bug 3,16 - palette issues: use driver in excl. mode
 *   12-apr-95	craige	don't use GETCURRPID all the time; proper csect ordering
 *   06-may-95	craige	use driver-level csects only
 *   12-may-95	craige	check for real guids in QI
 *   02-jun-95	craige	extra parm in AddToActiveProcessList
 *   12-jun-95	craige	new process list stuff
 *   20-jun-95  kylej   moved palette emulation code into ddhel
 *   21-jun-95	craige	couple of internal inteface cleanup issues
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns
 *   02-jul-95	craige	implemented GetCaps; added SEH for parm. validation
 *   04-jul-95	craige	YEEHAW: new driver struct
 *   05-jul-95	craige	added Initialize
 *   08-jul-95	kylej	Surface and DirectDraw Palette calls require 
 *			exclusive mode. Removed ResetSysPalette.  Make a
 *                      SetPalette call to the HAL/HEL to detach a palette.
 *   11-jul-95	craige	fail aggregation calls
 *   13-jul-95	craige	bug 94 - flag validation fixes
 *   20-jul-95	craige	stop palette code from running non-palettized
 *   31-jul-95  toddla  unselect palette in InternalPaletteRelease
 *   31-jul-95	craige	validate flags
 *   21-aug-95	craige	mode X support
 *   27-aug-95	craige	bug 735: added SetPaletteAlways
 *			bug 742: use ALLOW256
 *   14-oct-95  colinmc add support for attaching palettes to offscreen and
 *                      texture map surfaces
 *   07-nov-95  colinmc support for 1, 2 and 4-bit palettes and palette
 *                      sharing added
 *   09-dec-95  colinmc added execute buffer support
 *   02-jan-96	kylej	handle new interface structs
 *   09-feb-96  colinmc surface lost flag moved from global to local object
 *   03-mar-96  colinmc fixed problem with QueryInterface returning local
 *                      object rather than interface.
 *   13-mar-96  colinmc added IID validation to QueryInterface
 *   16-mar-96  colinmc fixed problem with palettes being released too many
 *                      times
 *   19-mar-96  colinmc Bug 12129: Bogus lpColorTable causes CreatePalette
 *                      to bomb
 *   19-apr-96  colinmc Bug 17473: CreatePalette faults on bogus palette
 *                      pointer
 *   02-may-96	kylej	Bug 20066: GetPalette doesn't NULL pointer on failure
 *   23-sep-96  ketand  Added TIMING routines
 *   24-mar-97  jeffno  Optimized Surfaces
 *   26-nov-97  t-craigs Added IDirectDrawPalette2 stuff
 *
 ***************************************************************************/

#include "ddrawpr.h"

#define SIZE_DDPCAPS (DDPCAPS_1BIT | DDPCAPS_2BIT | DDPCAPS_4BIT | DDPCAPS_8BIT)

#define PE_FLAGS (PC_NOCOLLAPSE |PC_RESERVED)

#define BITS_PER_BITFIELD_ENTRY (sizeof(DWORD)*8)

/*
 * Generate a palette handle. We keep a bitfiled in the ddraw local that
 * tells us if we can recycle a handle. Note that handles are 1-based,
 * and these routines deal with that
 */
DWORD GeneratePaletteHandle(LPDDRAWI_DIRECTDRAW_LCL lpDD_lcl)
{
    DWORD                       cbits,*pdw;

    /*
     * Check for an unused entry in the palette-handle-used bitfield. We check
     */
    for (cbits=0; cbits< lpDD_lcl->cbitsPaletteBitfieldBitCount; cbits++ )
    {
        if ( 0 == (lpDD_lcl->pPaletteHandleUsedBitfield[cbits/BITS_PER_BITFIELD_ENTRY] 
                    & (1<<(cbits % BITS_PER_BITFIELD_ENTRY))) )
        {
            /*
             * Found a recycled handle
             */
            lpDD_lcl->pPaletteHandleUsedBitfield[cbits/BITS_PER_BITFIELD_ENTRY] |=
                (1<<(cbits % BITS_PER_BITFIELD_ENTRY));
            return cbits+1; //plus one since 0 is error return
        }
    }

    /* 
     * Didn't find a recycled entry. Get a new handle
     */

    DDASSERT( cbits == lpDD_lcl->cbitsPaletteBitfieldBitCount );

    if ( (cbits% BITS_PER_BITFIELD_ENTRY) == 0)
    {
        /* 
         * Have to grow the table since the current table fits exactly in a number of DWORDs
         */
        pdw = MemAlloc( ((cbits / BITS_PER_BITFIELD_ENTRY) +1)*sizeof(DWORD) );

        if (pdw)
        {
            /*
             * Couldn't convince myself the MemRealloc both worked and would zero remaining space.
             */
            memcpy(pdw, lpDD_lcl->pPaletteHandleUsedBitfield, 
                (cbits / BITS_PER_BITFIELD_ENTRY) * sizeof(DWORD) );
            MemFree(lpDD_lcl->pPaletteHandleUsedBitfield);
            lpDD_lcl->pPaletteHandleUsedBitfield = pdw;
        }
        else
        {
            return 0;
        }
    }

    /*
     * Table is big enough. Grab the entry and mark it.
     */
    cbits = lpDD_lcl->cbitsPaletteBitfieldBitCount++;
    lpDD_lcl->pPaletteHandleUsedBitfield[cbits/BITS_PER_BITFIELD_ENTRY] |=
        (1<<(cbits % BITS_PER_BITFIELD_ENTRY));
    return cbits+1; //+1 since zero is an error return, and it helps out drivers to know 0 is invalid
}

void FreePaletteHandle(LPDDRAWI_DIRECTDRAW_LCL lpDD_lcl, DWORD dwHandle)
{
    DDASSERT( dwHandle <= lpDD_lcl->cbitsPaletteBitfieldBitCount );

    if (dwHandle == 0)
        return;

    dwHandle -=1; //since handles are 1-based

    lpDD_lcl->pPaletteHandleUsedBitfield[dwHandle/BITS_PER_BITFIELD_ENTRY] &=
        ~(1<<(dwHandle % BITS_PER_BITFIELD_ENTRY));

}

/*
 * newPaletteInterface
 *
 * Construct a new palette interface which points to an existing local object.
 */
static LPVOID newPaletteInterface( LPDDRAWI_DDRAWPALETTE_LCL this_lcl, LPVOID lpvtbl )
{
    LPDDRAWI_DDRAWPALETTE_INT	pnew_int;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;

    
    pnew_int = MemAlloc( sizeof( DDRAWI_DDRAWPALETTE_INT ));
    if( NULL == pnew_int )
    {
	return NULL;
    }

    /*
     * set up data
     */
    pnew_int->lpVtbl = lpvtbl;
    pnew_int->lpLcl = this_lcl;
    pnew_int->dwIntRefCnt = 0;

    /*
     * link this into the global list of palettes
     */
    pdrv = this_lcl->lpDD_lcl->lpGbl;
    pnew_int->lpLink = pdrv->palList;
    pdrv->palList = pnew_int;
    return pnew_int;

} /* newPaletteInterface */


#undef DPF_MODNAME
#define DPF_MODNAME "Palette::QueryInterface"

/*
 * DD_Palette_QueryInterface
 */
HRESULT DDAPI DD_Palette_QueryInterface(
		LPDIRECTDRAWPALETTE lpDDPalette,
		REFIID riid,
		LPVOID FAR * ppvObj )
{
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_QueryInterface");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
        if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
        {
	    DPF_ERR( "Invalid palette pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( !VALID_PTR_PTR( ppvObj ) )
        {
	    DPF( 1, "Invalid palette pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
        }
        if( !VALIDEX_IID_PTR( riid ) )
        {
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
        }
        this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return (DWORD) DDERR_INVALIDPARAMS;
    }

    if( IsEqualIID(riid, &IID_IUnknown) ||
    	IsEqualIID(riid, &IID_IDirectDrawPalette) )
    {
	if( this_int->lpVtbl == (LPVOID) &ddPaletteCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) newPaletteInterface( this_lcl, (LPVOID)&ddPaletteCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Palette_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }
#ifdef POSTPONED
    if (IsEqualIID(riid, &IID_IPersist))
    {
	/*
	 * if this is already an IID_IPersist interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddPalettePersistCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) newPaletteInterface( this_lcl, (LPVOID)&ddPalettePersistCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Palette_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }
    if (IsEqualIID(riid, &IID_IPersistStream))
    {
	/*
	 * if this is already an IID_IPersistStream interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddPalettePersistStreamCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) newPaletteInterface( this_lcl, (LPVOID)&ddPalettePersistStreamCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Palette_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }
    if (IsEqualIID(riid, &IID_IDirectDrawPalette2))
    {
	/*
	 * if this is already an IID_IDirectDrawPalette2 interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddPalette2Callbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) newPaletteInterface( this_lcl, (LPVOID)&ddPalette2Callbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Palette_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }
#endif //POSTPONED

    LEAVE_DDRAW();
    return (DWORD) DDERR_GENERIC;

} /* DD_Palette_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "Palette::AddRef"

/*
 * DD_Palette_AddRef
 */
DWORD DDAPI DD_Palette_AddRef( LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    DWORD			rcnt;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_AddRef");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
    
	/*
	 * update palette reference count
	 */
	this->dwRefCnt++;
	this_lcl->dwLocalRefCnt++;
	this_int->dwIntRefCnt++;
	rcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;
	DPF( 5, "Palette %08lx addrefed, refcnt = %ld,%ld,%ld", 
	    this_lcl, this->dwRefCnt, rcnt, 
	    this_int->dwIntRefCnt );
    
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    LEAVE_DDRAW();
    return this_int->dwIntRefCnt;

} /* DD_Palette_AddRef */

#undef DPF_MODNAME
#define DPF_MODNAME "Palette::Release"

/*
 * InternalPaletteRelease
 *
 * Done with a palette.   if no one else is using it, then we can free it.
 * Also called by ProcessPaletteCleanup
 */
ULONG DDAPI InternalPaletteRelease( LPDDRAWI_DDRAWPALETTE_INT this_int )
{
    DWORD			intrefcnt;
    DWORD			lclrefcnt;
    DWORD			gblrefcnt;
    BOOL			root_object_deleted;
    BOOL			do_free;
    ULONG			rc;
    DDHAL_DESTROYPALETTEDATA	dpd;
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_INT	curr_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_INT	last_int;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    IUnknown *                  pOwner = NULL;

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;
    pdrv_lcl = this->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;

    /*
     * decrement reference count to this palette.  If it hits zero,
     * cleanup
     */
    this->dwRefCnt--;
    this_lcl->dwLocalRefCnt--;
    this_int->dwIntRefCnt--;
    intrefcnt = this_int->dwIntRefCnt;
    lclrefcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;
    gblrefcnt = this->dwRefCnt;
    DPF( 5, "Palette %08lx released, refcnt = %ld,%ld,%ld", this_int, gblrefcnt, lclrefcnt, intrefcnt );

    /*
     * local object gone?
     */
    root_object_deleted = FALSE;
    if( lclrefcnt == 0 )
    {
        /*
         * Remove private data
         */
        FreeAllPrivateData( &this_lcl->pPrivateDataHead );

        /*
         * If the ddraw interface which created this palette caused the surface to addref the ddraw
         * object, then we need to release that addref now.
         */
        pOwner = this_lcl->pAddrefedThisOwner;

	/*
	 * see if we are deleting the root object
	 */
	if( this_lcl->dwLocalRefCnt & OBJECT_ISROOT )
	{
	    root_object_deleted = TRUE;
	}
    }

    /*
     * did the object get globally deleted?
     */
    do_free = FALSE;
    if( gblrefcnt == 0 )
    {
	LPDDHALPALCB_DESTROYPALETTE	dphalfn;
	LPDDHALPALCB_DESTROYPALETTE	dpfn;
	BOOL                        	emulation;

        do_free = TRUE;

	/*
         * if this palette is selected into the primary, unselect it!
         */
        if (pdrv_lcl && pdrv_lcl->lpPrimary &&
            pdrv_lcl->lpPrimary->lpLcl->lpDDPalette == this_int)
        {
            SetPaletteAlways(pdrv_lcl->lpPrimary, NULL);
        }

        FreePaletteHandle( pdrv_lcl, this->dwHandle );

	/*
	 * destroy the hardware
	 */
	if( ( pdrv_lcl->lpDDCB->HALDDPalette.DestroyPalette == NULL ) ||
	    ( this->dwFlags & DDRAWIPAL_INHEL ) )
	{
	    // use HEL 
	    dpfn = pdrv_lcl->lpDDCB->HELDDPalette.DestroyPalette;
	    dphalfn = dpfn;
	    emulation = TRUE;
	}
	else
	{
	    // use HAL
            dpfn = pdrv_lcl->lpDDCB->HALDDPalette.DestroyPalette;
	    dphalfn = pdrv_lcl->lpDDCB->cbDDPaletteCallbacks.DestroyPalette;
	    emulation = FALSE;
	}
	
	if( dphalfn != NULL )
	{
	    dpd.DestroyPalette = dphalfn;
	    dpd.lpDD = pdrv_lcl->lpGbl;
	    dpd.lpDDPalette = this;
	    DOHALCALL( DestroyPalette, dpfn, dpd, rc, emulation );
	    if( rc == DDHAL_DRIVER_HANDLED )
	    {
		if( dpd.ddRVal != DD_OK )
		{
		    DPF_ERR( "HAL call failed" );
                    /*
                     * If the palette took a ref count on the ddraw object that created it,
                     * release that ref now as the very last thing
                     * We don't want to do this on ddhelp's thread cuz it really mucks up the
                     * process cleanup stuff. 
                     */
                    if (pOwner && (dwHelperPid != GetCurrentProcessId()) )
                    {
                        pOwner->lpVtbl->Release(pOwner);
                    }

		    /* GEE: What do we do here since we no longer return
		     * error codes from Release.
		     */
		    return (DWORD) dpd.ddRVal;
		}
	    }
            /*
             * Moved here from ddhel.c. Non-display drivers mean that the hel isn't called for palette
             * destroy, so we were leaking palette tables. It's called exactly here to most closely 
             * duplicate the old behaviour, but reduce any risk of drivers using the color table or whatever.
             */
            if (this->lpColorTable)
            {
                MemFree(this->lpColorTable);
                this->lpColorTable = NULL;
            }
        }
	else 
	{
	    /*
	     * We can't do this; we've already committed to releasing at
	     * this point!
	     */
	    // couldn't handle it
	    // return (ULONG)DDERR_UNSUPPORTED;
	}

	/*
	 * if this was the final delete, but this wasn't the root object,
	 * then we need to delete the dangling root object
	 */
	if( !root_object_deleted )
	{
            LPVOID root_lcl;

            root_lcl = (LPVOID) (((LPBYTE) this) - sizeof( DDRAWI_DDRAWPALETTE_LCL ) );
	    MemFree( root_lcl );
	}
    }
    else if( lclrefcnt == 0 )
    {
	/*
	 * only remove the object if it wasn't the root.   if it
	 * was the root, we must leave it dangling until the last
	 * object referencing it goes away.
	 */
	if( !root_object_deleted )
	{
	    do_free = TRUE;
	}
    }

    /*
     * free the object if needed
     */
    if( do_free )
    {
	/*
	 * just in case someone comes back in with this pointer, set
	 * an invalid vtbl & data ptr.
	 */

        this_lcl->lpGbl = NULL;
	MemFree( this_lcl );
    }

    /*
     * need to delete the interface?
     */
    if( intrefcnt == 0 )
    {
	/*
	 * remove palette from list of all palettes
	 */
	curr_int = pdrv->palList;
	last_int = NULL;
	while( curr_int != this_int )
	{
	    last_int = curr_int;
	    curr_int = curr_int->lpLink;
	    if( curr_int == NULL )
	    {
		return 0;
	    }
	}
	if( last_int == NULL )
	{
	    pdrv->palList = pdrv->palList->lpLink;
	}
	else
	{
	    last_int->lpLink = curr_int->lpLink;
	}
	/*
	 * Invalidate the interface
	 */
	this_int->lpVtbl = NULL;
	this_int->lpLcl = NULL;
	MemFree( this_int );
    }

    /*
     * If the palette took a ref count on the ddraw object that created it,
     * release that ref now as the very last thing
     * We don't want to do this on ddhelp's thread cuz it really mucks up the
     * process cleanup stuff. 
     */
    if (pOwner && (dwHelperPid != GetCurrentProcessId()) )
    {
        pOwner->lpVtbl->Release(pOwner);
    }

    return intrefcnt;

} /* InternalPaletteRelease */

/*
 * DD_Palette_Release
 *
 * Done with a palette.   if no one else is using it, then we can free it.
 */
ULONG DDAPI DD_Palette_Release( LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    ULONG			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_Release");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALIDEX_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
    
	rc = InternalPaletteRelease( this_int );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    LEAVE_DDRAW();
    return rc;

} /* DD_Palette_Release */

#undef DPF_MODNAME
#define DPF_MODNAME "GetCaps"

/*
 * DD_Palette_GetCaps
 */
HRESULT DDAPI DD_Palette_GetCaps(
		LPDIRECTDRAWPALETTE lpDDPalette,
		LPDWORD lpdwCaps )
{
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    DWORD			caps;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_GetCaps");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_DWORD_PTR( lpdwCaps ) )
	{
	    DPF_ERR( "invalid caps pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*lpdwCaps = 0;
	this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * basic palette size caps.
     */
    caps = SIZE_FLAGS_TO_PCAPS( this->dwFlags );

    /*
     * is this palette attached to the primary?
     */
    pdrv_lcl = this->lpDD_lcl;
    if (pdrv_lcl && pdrv_lcl->lpPrimary && pdrv_lcl->lpPrimary->lpLcl->lpDDPalette &&
        (pdrv_lcl->lpPrimary->lpLcl->lpDDPalette == this_int))
	caps |= DDPCAPS_PRIMARYSURFACE;

    /*
     * an allow256 palette?
     */
    if( this->dwFlags & DDRAWIPAL_ALLOW256 )
    {
	caps |= DDPCAPS_ALLOW256;
    }

    /*
     * does this palette store indices into an 8-bit destination
     * palette.
     */
    if( this->dwFlags & DDRAWIPAL_STORED_8INDEX )
    {
        caps |= DDPCAPS_8BITENTRIES;
    }

    *lpdwCaps = caps;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Palette_GetCaps */

#undef DPF_MODNAME
#define DPF_MODNAME "Initialize"

/*
 * DD_Palette_Initialize
 */
HRESULT DDAPI DD_Palette_Initialize(
		LPDIRECTDRAWPALETTE lpDDPalette,
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPPALETTEENTRY lpDDColorTable )
{
    DPF_ERR( "DirectDrawPalette: DD_Palette_Initialize");

    DPF(2,A,"ENTERAPI: ");
    return DDERR_ALREADYINITIALIZED;
} /* DD_Palette_Initialize */

#undef DPF_MODNAME
#define DPF_MODNAME "SetEntries"

/*
 * DD_Palette_SetEntries
 */

HRESULT DDAPI DD_Palette_SetEntries(
		LPDIRECTDRAWPALETTE lpDDPalette,
		DWORD dwFlags,
		DWORD dwBase,
		DWORD dwNumEntries,
		LPPALETTEENTRY lpEntries )
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    DWORD			rc;
    DDHAL_SETENTRIESDATA	sed;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDHALPALCB_SETENTRIES	sehalfn;
    LPDDHALPALCB_SETENTRIES	sefn;
    DWORD			size;
    BOOL                        emulation;
    DWORD                       entry_size;

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Palette_SetEntries");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_BOTH();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;

	/*
	 * check number of entries
	 */
	size = FLAGS_TO_SIZE( this->dwFlags );
	if( dwNumEntries < 1 || dwNumEntries > size )
	{
	    DPF_ERR( "Invalid number of entries" );
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwBase >= size )
	{
	    DPF_ERR( "Invalid base palette index" );
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwNumEntries+dwBase > size )
	{
	    DPF_ERR( "palette indices requested would go past the end of the palette" );
	    LEAVE_BOTH();
	    return DDERR_INVALIDPARAMS;
	}

	if( this->dwFlags & DDRAWIPAL_STORED_8INDEX )
	{
	    entry_size = sizeof( BYTE );
	    if( !VALID_BYTE_ARRAY( lpEntries, dwNumEntries ) )
	    {
	        DPF_ERR( "Invalid 8-bit palette index array" );
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    entry_size = sizeof( PALETTEENTRY );
	    if( !VALID_PALETTEENTRY_ARRAY( lpEntries, dwNumEntries ) )
	    {
	        DPF_ERR( "Invalid PALETTEENTRY array" );
		LEAVE_BOTH();
    	        return DDERR_INVALIDPARAMS;
	    }
	}
	pdrv_lcl = this->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

	/*
	 * copy the entries
	 */
	memcpy( ((LPBYTE)this->lpColorTable) + (entry_size * dwBase),
	        lpEntries, dwNumEntries * entry_size );
    
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_BOTH();
	return DDERR_INVALIDPARAMS;
    }

    if( ( pdrv_lcl->lpDDCB->HALDDPalette.SetEntries == NULL ) ||
	( this->dwFlags & DDRAWIPAL_INHEL ) )
    {
	// use HEL
	sefn = pdrv_lcl->lpDDCB->HELDDPalette.SetEntries;
	sehalfn = sefn;
	emulation = TRUE;
    }
    else
    {
	// use HAL
	sefn = pdrv_lcl->lpDDCB->HALDDPalette.SetEntries;
	sehalfn = pdrv_lcl->lpDDCB->cbDDPaletteCallbacks.SetEntries;
	emulation = FALSE;
    }

    if( sehalfn != NULL )
    {
	sed.SetEntries = sehalfn;
	sed.lpDD = pdrv;
	sed.lpDDPalette = this;
	sed.dwBase = dwBase;
	sed.dwNumEntries = dwNumEntries;
	sed.lpEntries = lpEntries;
	DOHALCALL_NOWIN16( SetEntries, sefn, sed, rc, emulation );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( sed.ddRVal != DD_OK )
	    {
		DPF( 5, "DDHAL_SetEntries: ddrval = %ld", sed.ddRVal );
		LEAVE_BOTH();
		return (DWORD) sed.ddRVal;
	    }

	    // We have now set the palette as we have been asked; so
	    // we may need to update some outstanding DCs. 
	    UpdateDCOnPaletteChanges( this );

	}
    }
    else
    {
	LEAVE_BOTH();
	return DDERR_UNSUPPORTED;
    }

    BUMP_PALETTE_STAMP(this);

    /*
     * If the palette's handle is non-zero, that means the palette has already been exposed to the
     * driver by a palette associate notify call. If the handle is zero, then the driver has never
     * seen the palette before and doesn't care about setentries for it. The driver will get its 
     * first setentries immediately after the setpalette call (See DD_Surface_SetPalette)
     * Mustn't do this on ddhelp's context, since the DLL will be long gone. (Note this should never 
     * happen anyway).
     */
    if( dwHelperPid != GetCurrentProcessId() )
    {
        if (this->dwHandle)
        {
            if ( pdrv_lcl->pPaletteUpdateNotify && pdrv_lcl->pD3DIUnknown)
            {
                pdrv_lcl->pPaletteUpdateNotify( pdrv_lcl->pD3DIUnknown, this->dwHandle , dwBase, dwNumEntries, lpEntries );
            }
        }
    }

    LEAVE_BOTH();

    return DD_OK;

} /* DD_Palette_SetEntries */

#undef DPF_MODNAME
#define DPF_MODNAME "GetEntries"

/*
 * DD_Palette_GetEntries
 */
HRESULT DDAPI DD_Palette_GetEntries(
		LPDIRECTDRAWPALETTE lpDDPalette,
		DWORD dwFlags,
		DWORD dwBase,
		DWORD dwNumEntries,
		LPPALETTEENTRY lpEntries )
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    DWORD			size;
    DWORD                       entry_size;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_GetEntries");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	/*
	 * check number of entries
	 */
	size = FLAGS_TO_SIZE( this->dwFlags );
	if( dwNumEntries < 1 || dwNumEntries > size )
	{
	    DPF_ERR( "Invalid number of entries" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwBase >= size )
	{
	    DPF_ERR( "Invalid base palette index" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwNumEntries+dwBase > size )
	{
	    DPF_ERR( "palette indices requested would go past the end of the palette" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( this->dwFlags & DDRAWIPAL_STORED_8INDEX )
	{
	    entry_size = sizeof( BYTE );
	    if( !VALID_BYTE_ARRAY( lpEntries, dwNumEntries ) )
	    {
	        DPF_ERR( "Invalid 8-bit palette index array" );
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    entry_size = sizeof( PALETTEENTRY );
	    if( !VALID_PALETTEENTRY_ARRAY( lpEntries, dwNumEntries ) )
	    {
	        DPF_ERR( "Invalid PALETTEENTRY array" );
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
	    }
	}

	/* GetEntries function body */
	memcpy( lpEntries, ((LPBYTE)this->lpColorTable) + (dwBase * entry_size),
		dwNumEntries * entry_size );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Palette_GetEntries */

#undef DPF_MODNAME
#define DPF_MODNAME "GetPalette"

/*
 * DD_Surface_GetPalette
 *
 * Surface function: get the palette associated with surface
 */
HRESULT DDAPI DD_Surface_GetPalette(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAWPALETTE FAR * lplpDDPalette)
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    HRESULT                     hr;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetPalette");

    TRY
    {
	if( !VALID_PTR_PTR( lplpDDPalette ) )
	{
	    DPF_ERR( "Invalid palette pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        *lplpDDPalette = NULL;	// in case we fail

	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
    
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
    
        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	if( this_lcl->lpDDPalette == NULL )
	{
	    DPF( 1, "No palette associated with surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOPALETTEATTACHED;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

#ifdef POSTPONED
    if (LOWERTHANSURFACE4(this_int))
    {
        hr = DD_Palette_QueryInterface(
            (LPDIRECTDRAWPALETTE) this_lcl->lpDDPalette,
            &IID_IDirectDrawPalette,
            (void**)lplpDDPalette );
    }
    else
    {
        hr = DD_Palette_QueryInterface( 
            (LPDIRECTDRAWPALETTE) this_lcl->lpDDPalette,
            &IID_IDirectDrawPalette2,
            (void**)lplpDDPalette );
    }
#else
    hr = DD_Palette_QueryInterface(
            (LPDIRECTDRAWPALETTE) this_lcl->lpDDPalette,
            &IID_IDirectDrawPalette,
            (void**)lplpDDPalette );
#endif
    LEAVE_DDRAW();
    return hr;

} /* DD_Surface_GetPalette */

#undef DPF_MODNAME
#define DPF_MODNAME	"SetPalette"

/*
 * DD_Surface_SetPalette
 *
 * Surface function: set the palette associated with surface
 *
 * NOTE: Currently the only way a windowed app. has of
 * realizing its palette on the primary is to call SetPalette
 * (full screen app. palette's are realized for them by the
 * WM_ACTIVATEAPP hook). Hence, the logic is to AddRef the
 * palette only if it is not already set as the surface's
 * palette).
 * Perhaps we need a RealizePalette() call?
 */
HRESULT DDAPI DD_Surface_SetPalette(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_INT	this_pal_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_pal_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	this_pal;
    LPDDRAWI_DDRAWPALETTE_INT   prev_pal_int;
    LPDDPIXELFORMAT		pddpf;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    BOOL			attach;
    DWORD			rc;
    DDHAL_SETPALETTEDATA	spd;
    LPDDHALSURFCB_SETPALETTE	sphalfn;
    LPDDHALSURFCB_SETPALETTE	spfn;
    BOOL			emulation;
    BOOL                        isprimary;
    BOOL                        excl_exists;
    BOOL                        has_excl;

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_SetPalette");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_BOTH();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

        /*
         * Palettes don't make any sense on z-buffers or execute
         * buffers.
         */
        if( this_lcl->ddsCaps.dwCaps & ( DDSCAPS_ZBUFFER | DDSCAPS_EXECUTEBUFFER ) )
        {
            DPF_ERR( "Invalid surface type: cannot attach palette" );
	    LEAVE_BOTH();
            return DDERR_INVALIDSURFACETYPE;
        }

        // 
        // New interfaces don't let mipmap sublevels have palettes
        //
        if ((!LOWERTHANSURFACE7(this_int)) && 
            (this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL))
        {
            DPF_ERR( "Cannot attach palette to mipmap sublevels" );
            LEAVE_BOTH();
            return DDERR_NOTONMIPMAPSUBLEVEL;
        }

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_BOTH();
	    return DDERR_SURFACELOST;
	}
    
	this_pal_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( this_pal_int != NULL )
	{
	    if( !VALID_DIRECTDRAWPALETTE_PTR( this_pal_int ) )
	    {
		LEAVE_BOTH();
		return DDERR_INVALIDOBJECT;
	    }
	    this_pal_lcl = this_pal_int->lpLcl;
	    this_pal = this_pal_lcl->lpGbl;
	}
	else
	{
	    this_pal_lcl = NULL;
	    this_pal = NULL;
	}
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

        if ( this_pal_int && 
             (this_pal->dwFlags & DDRAWIPAL_ALPHA) &&
             (! (this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)) )
        {
            DPF_ERR( "Attaching palette w/alpha to non-texture surface" );
            LEAVE_BOTH();
            return DDERR_INVALIDSURFACETYPE;
        }

	/* 
	 * don't allow a palette from one global to be
	 * used with a different one (because it doesn't work)
	 */
	if( this_pal_int && pdrv != this_pal_lcl->lpDD_lcl->lpGbl )
	{
            /*
             * Don't check if either device isn't a display driver (i.e. 3dfx)
             * since that's a back-compat hole.
             */
            if ( (this->lpDD->dwFlags & DDRAWI_DISPLAYDRV) &&
                 (this_pal_lcl->lpDD_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV) )
            {
	        DPF_ERR( "Can't set a palette created from one DDraw onto a surface created by another DDraw" );
	        LEAVE_BOTH();
	        return DDERR_INVALIDPARAMS;
            }
	}
    
        CheckExclusiveMode(pdrv_lcl, &excl_exists, &has_excl, FALSE, NULL, FALSE);

	/*
	 * don't allow primary palette set if not exclusive mode owner
	 */
	isprimary = FALSE;
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
	{
	    isprimary = TRUE;
	    if( excl_exists )
	    {
		if( !has_excl )
		{
		    DPF_ERR( "Cannot set palette on primary when other process owns exclusive mode" );
		    LEAVE_BOTH();
		    return DDERR_NOEXCLUSIVEMODE;
		}
	    }
	}

	/*
	 * Was a palette previously attached to this surface?
	 * If so, we will need to release if all goes well so
	 * remember it.
	 */
	prev_pal_int = this_lcl->lpDDPalette;
    
	/*
	 * NULL palette, remove palette from this surface
	 */
	attach = TRUE;
	if( this_pal == NULL )
	{
	    attach = FALSE;
	    this_pal_int = prev_pal_int;
	    if( this_pal_int == NULL )
	    {
		DPF_ERR( "No attached palette" );
		LEAVE_BOTH();
		return DDERR_NOPALETTEATTACHED;
	    }
	    this_pal_lcl = this_pal_int->lpLcl;
	    this_pal = this_pal_lcl->lpGbl;
	}
    
        if( attach )
	{
	    /*
	     * NOTE: We used to do a lot of HEL specific checking. With the
	     * addition of support for palettes on non-primary surfaces and
	     * non-256 entry palettes this became redundant. We also used
	     * to explicitly check that, if attaching to the primary, the
	     * current mode was palettized and 8-bit. Doesn't look to me like
	     * any of that was necessary as DDPF_PALETTEINDEXED8 should be
	     * set if the primary is 8-bit palettized.
	     */
	    GET_PIXEL_FORMAT( this_lcl, this, pddpf );
	    if( ( ( this_pal->dwFlags & DDRAWIPAL_2   ) && !( pddpf->dwFlags & DDPF_PALETTEINDEXED1 ) ) ||
	        ( ( this_pal->dwFlags & DDRAWIPAL_4   ) && !( pddpf->dwFlags & DDPF_PALETTEINDEXED2 ) ) ||
	        ( ( this_pal->dwFlags & DDRAWIPAL_16  ) && !( pddpf->dwFlags & DDPF_PALETTEINDEXED4 ) ) ||
	        ( ( this_pal->dwFlags & DDRAWIPAL_256 ) && !( pddpf->dwFlags & DDPF_PALETTEINDEXED8 ) ) )
	    {
	        DPF_ERR( "Palette size does not match surface format - cannot set palette" );
		LEAVE_BOTH();
	        return DDERR_INVALIDPIXELFORMAT; 
	    }

            /*
	     * Ensure that both the palette and surface agree on whether they are using
	     * indices into the destination surface's palette.
	     */
	    if( this_pal->dwFlags & DDRAWIPAL_STORED_8INDEX )
	    {
	        if( !(pddpf->dwFlags & DDPF_PALETTEINDEXEDTO8) )
                {
	            DPF_ERR( "Surface is not PALETTEINDEXEDTO8 - cannot set palette" );
		    LEAVE_BOTH();
		    return DDERR_INVALIDPIXELFORMAT;
	        }
	    }
	    else
	    {
	        if( pddpf->dwFlags & DDPF_PALETTEINDEXEDTO8 )
                {
	            DPF_ERR( "Surface is PALETTEINDEXEDTO8 - cannot set palette" );
		    LEAVE_BOTH();
		    return DDERR_INVALIDPIXELFORMAT;
	        }
	    }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_BOTH();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * ATTENTION!!!
     * We shouldn't pass optimized surfaces to an unsuspecting HAL, but if we don't then we could
     * break drivers that hook SetPalette... Since the HAL is probably only going to be watching
     * for a primary, and also is unlikely to go looking at the surface's contents,
     * I'm going to let this one slide.
     */
    if( ( this_pal->dwFlags & DDRAWIPAL_INHEL) ||
	( pdrv_lcl->lpDDCB->HALDDSurface.SetPalette == NULL ) )
    {
	// use HEL
	spfn = pdrv_lcl->lpDDCB->HELDDSurface.SetPalette;
	sphalfn = spfn;
	emulation = TRUE;
    }
    else
    {
	// use HAL
	spfn = pdrv_lcl->lpDDCB->HALDDSurface.SetPalette;
	sphalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.SetPalette;
	emulation = FALSE;
    }
    
    if( sphalfn != NULL )
    {
	spd.SetPalette = sphalfn;
	spd.lpDD = pdrv;
	spd.lpDDPalette = this_pal;
	spd.lpDDSurface = this_lcl;
	spd.Attach = attach;
	DOHALCALL_NOWIN16( SetPalette, spfn, spd, rc, emulation );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( spd.ddRVal == DD_OK )
	    {
		if( attach )
		{
		    /*
		     * Only AddRef the palette if its being attached to
		     * a new surface.
		     */
		    if( this_lcl->lpDDPalette != this_pal_int )
		    {
		        this_lcl->lpDDPalette = this_pal_int;
		        DD_Palette_AddRef( lpDDPalette );
		    }
		}
		else
		{
		    this_lcl->lpDDPalette = NULL;
		}

		/*
		 * If we had a previous palette and it was different
		 * from the new palette then we must release it.
		 * NOTE: We compare against the incoming parameter
		 * rather than this_pal_lcl as this_pal_lcl is set to the
		 * previous palette if we are removing a palette.
		 * NOTE: It is important that we update the surface's
		 * palette pointer before calling Release() as, otherwise,
		 * release can end up calling SetPalette() and so on.
		 */
		if( ( prev_pal_int != NULL ) &&
		    ( prev_pal_int != (LPDDRAWI_DDRAWPALETTE_INT )lpDDPalette ) )
		{
		    // This palette may no longer the exclusive one
		    if( isprimary )
		    {
			if( has_excl )
			{
			    prev_pal_int->lpLcl->lpGbl->dwFlags &= ~DDRAWIPAL_EXCLUSIVE;
			}
		    }
		    // Release it
		    DD_Palette_Release( (LPDIRECTDRAWPALETTE)prev_pal_int );
		}

		if( attach )
		{
		    // Ok, we have set the palette onto the surface
		    // Check if there are any outstanding DCs that need updating
		    UpdateOutstandingDC( this_lcl, this_pal );
		}
		else
		{
		    // Ok, we have removed a palette onto the surface
		    // Check if there are any outstanding DCs that need updating
		    UpdateOutstandingDC( this_lcl, NULL );
		}

                BUMP_SURFACE_STAMP(this);

                /*
                 * Update the driver's associations and palette entries
                 */
                if( dwHelperPid != GetCurrentProcessId() )
                {
                    BOOL bUpdateEntries = FALSE;

                    if (attach)
                    {
                        if (this_pal->dwHandle == 0)
                        {
                            /*
                             *  The driver has never seen this palette before. We must send an associate notify first, and
                             * then an update entries
                             */
                            bUpdateEntries = TRUE;
                            this_pal->dwHandle = GeneratePaletteHandle(pdrv_lcl);
                        }
                        if (this_pal->dwHandle && pdrv_lcl->pD3DIUnknown ) 
                            //could be zero in low memory conditions
                        {
                            if ( pdrv_lcl->pPaletteAssociateNotify )
                            {
                                // NOTE: we send the handle for DX6 and down
                                // for DX7 we pass the the local itself.
                                // DX7 needs the whole local to get the
                                // batching correct; MB41840

                                if( DDRAWILCL_DIRECTDRAW7 & pdrv_lcl->dwLocalFlags )
                                {
                                    LPPALETTEASSOCIATENOTIFY7 pPaletteAssociateNotify = 
                                        (LPPALETTEASSOCIATENOTIFY7)pdrv_lcl->pPaletteAssociateNotify;

                                    pPaletteAssociateNotify( 
                                        pdrv_lcl->pD3DIUnknown, 
                                        this_pal->dwHandle,
                                        this_pal->dwFlags,
                                        this_lcl );
                                }
                                else
                                {
                                    // When a DX6 app is talking to a DX7 driver,
                                    // we need to force a flush of the token
                                    // stream as part of this SetPalette.
                                    //
                                    // This automatically happens if the number
                                    // of devices is > 1. So if necessary
                                    // we temporarily increment the device
                                    // count. We don't do this for IA64.
                                    // MB41840 for more details.
                                    
                                    #ifndef _WIN64
                                        DWORD *pIUnknown = (DWORD *)(pdrv_lcl->pD3DIUnknown);
                                        DWORD *pD3D      = (DWORD *)(*(pIUnknown + 2));
                                        DWORD *pnumDevs  = (DWORD *)(pD3D + 3);
                                        BOOL  bFixDeviceCount = FALSE;

                                        DDASSERT(pD3D != NULL);

                                        if (*pnumDevs == 1)
                                        {
                                            *pnumDevs = 2;
                                            bFixDeviceCount = TRUE;
                                        }
                                    #endif // _WIN64

                                    pdrv_lcl->pPaletteAssociateNotify( 
                                        pdrv_lcl->pD3DIUnknown, 
                                        this_pal->dwHandle,
                                        this_pal->dwFlags,
                                        this_lcl->lpSurfMore->dwSurfaceHandle );

                                    #ifndef _WIN64
                                        // Restore the device count
                                        if (bFixDeviceCount)
                                        {
                                            DDASSERT(*pnumDevs == 2);
                                            *pnumDevs = 1;
                                        }
                                    #endif // _WIN64
                                }
                            }
                            if ( pdrv_lcl->pPaletteUpdateNotify )
                            {
                                pdrv_lcl->pPaletteUpdateNotify( 
                                    pdrv_lcl->pD3DIUnknown, 
                                    this_pal->dwHandle , 
                                    0, 
                                    FLAGS_TO_SIZE(this_pal->dwFlags), 
                                    this_pal->lpColorTable );
                            }
                        }
                    }
                }
	    }

	    LEAVE_BOTH();
	    return spd.ddRVal;
	}
	LEAVE_BOTH();
	return DDERR_UNSUPPORTED;
    }

    /*
     * !!! NOTE: Currently if the driver does not care about
     * SetPalette we do nothing but return OK. Should we
     * not, however, still point the surface at the palette
     * and point the palette at the surface at the very
     * least?
     */

    LEAVE_BOTH();
    return DD_OK;

} /* DD_Surface_SetPalette */

/*
 * SetPaletteAlways
 */
HRESULT SetPaletteAlways( 
		LPDDRAWI_DDRAWSURFACE_INT psurf_int,
		LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD	oldflag;
    HRESULT	ddrval;

    psurf_lcl = psurf_int->lpLcl;
    oldflag = psurf_lcl->dwFlags & DDRAWISURF_INVALID;
    psurf_lcl->dwFlags &= ~DDRAWISURF_INVALID;
    ddrval = DD_Surface_SetPalette( (LPDIRECTDRAWSURFACE) psurf_int, lpDDPalette );
    psurf_lcl->dwFlags |= oldflag;
    return ddrval;

} /* SetPaletteAlways */

#undef DPF_MODNAME
#define DPF_MODNAME	"CreatePalette"

/*
 * DD_CreatePalette
 *
 * Driver function: create a palette
 */
HRESULT DDAPI DD_CreatePalette(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPPALETTEENTRY lpColorTable,
		LPDIRECTDRAWPALETTE FAR *lplpDDPalette,
		IUnknown FAR *pUnkOuter )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	this;
    LPDDRAWI_DDRAWPALETTE_INT	ppal_int;
    LPDDRAWI_DDRAWPALETTE_LCL	ppal_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	ppal;
    DWORD			pal_size;
    DDHAL_CREATEPALETTEDATA	cpd;
    DWORD			rc;
    DWORD			pflags;
    BOOL			is_excl;
    LPDDHAL_CREATEPALETTE	cpfn;
    LPDDHAL_CREATEPALETTE	cphalfn;
    BOOL                        emulation;
    BYTE                        indexedpe;
    BYTE                        hackindexedpe;
    PALETTEENTRY		pe;
    PALETTEENTRY                hackpe;
    DWORD			num_entries;
    DWORD                       entry_size;
    int                         num_size_flags;

    if( pUnkOuter != NULL )
    {
	return CLASS_E_NOAGGREGATION;
    }

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CreatePalette");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( !VALID_PTR_PTR( lplpDDPalette ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*lplpDDPalette = NULL;

	if( dwFlags & ~DDPCAPS_VALID )
	{
	    DPF_ERR( "Invalid caps" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	/*
	 * verify that cooperative level is set
	 */
	if( !(this_lcl->dwLocalFlags & DDRAWILCL_SETCOOPCALLED) )
	{
	    DPF_ERR( "Must call SetCooperativeLevel before calling Create functions" );
	    LEAVE_DDRAW();
	    return DDERR_NOCOOPERATIVELEVELSET;
	}
    
	/*
	 * verify flags
	 */
	if( dwFlags & (DDPCAPS_VSYNC|
		       DDPCAPS_PRIMARYSURFACE|
		       DDPCAPS_PRIMARYSURFACELEFT) )
	{
	    DPF_ERR( "Read only flags specified" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	num_size_flags = 0;
	if( dwFlags & DDPCAPS_1BIT )
	    num_size_flags++;
	if( dwFlags & DDPCAPS_2BIT )
	    num_size_flags++;
	if( dwFlags & DDPCAPS_4BIT )
	    num_size_flags++;
	if( dwFlags & DDPCAPS_8BIT )
	    num_size_flags++;
	if( num_size_flags != 1 )
	{
	    DPF_ERR( "Must specify one and one only of 2, 4, 16 or 256 color palette" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        if( dwFlags & DDPCAPS_ALPHA )
        {
            if( dwFlags & DDPCAPS_8BITENTRIES )
            {
                DPF_ERR( "8BITENTRIES not valid with ALPHA" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
        }
	if( dwFlags & DDPCAPS_8BIT )
	{
	    if( dwFlags & DDPCAPS_8BITENTRIES )
	    {
		DPF_ERR( "8BITENTRIES only valid with 1BIT, 2BIT or 4BIT palette" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    if( dwFlags & DDPCAPS_ALLOW256 )
	    {
		DPF_ERR( "ALLOW256 only valid with 8BIT palette" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

        pflags = SIZE_PCAPS_TO_FLAGS( dwFlags );
        num_entries = FLAGS_TO_SIZE( pflags );

        /*
	 * Can't just assume the lpColorTable is an array of PALETTENTRYs.
	 * If DDPCAPS_8BITENTRIES is set then this is in fact an array of
	 * bytes in disguise. Validate appropriately.
	 */
	if( dwFlags & DDPCAPS_8BITENTRIES )
	{
	    entry_size = sizeof(BYTE);
	    indexedpe = ((LPBYTE)lpColorTable)[num_entries-1];   // validate
	    if( !VALID_BYTE_ARRAY( lpColorTable, num_entries ) )
	    {
	        DPF_ERR( "Invalid lpColorTable array" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    /*
	     * NOTE: You may well be wondering what this "hackindexedpe" bit is all about.
	     * Well - indexedpe is not actually used for anything. It's only a probe to
	     * test to see if the color table array is valid. We do this all over the place
	     * but unfortunately we don't actually need the result here so our friend
	     * Mr. Optimizing Compiler decides to discard the assignment and so nullify
	     * the test. In order to ensure the array access stays in we declare dummy
	     * variable and assign to them. This is enough to keep the code in (the
	     * compiler is not smart enough to see that the variable assigned to is
	     * not used). Same goes for hackpe below.
	     */
	    hackindexedpe = indexedpe;
	}
	else
	{
	    entry_size = sizeof(PALETTEENTRY);
	    pe = lpColorTable[num_entries-1];	// validate
	    if( !VALID_PALETTEENTRY_ARRAY( lpColorTable, num_entries ) )
	    {
	        DPF_ERR( "Invalid lpColorTable array" );
	        LEAVE_DDRAW();
	        return DDERR_INVALIDPARAMS;
	    }
	    hackpe = pe;
	}
        CheckExclusiveMode(this_lcl, NULL, &is_excl, FALSE, NULL, FALSE);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * allocate the palette object
     */
    pal_size = sizeof( DDRAWI_DDRAWPALETTE_GBL ) +
	       sizeof( DDRAWI_DDRAWPALETTE_LCL );
    ppal_lcl = (LPDDRAWI_DDRAWPALETTE_LCL) MemAlloc( pal_size );
    if( ppal_lcl == NULL )
    {
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }

    ppal_lcl->lpGbl = (LPDDRAWI_DDRAWPALETTE_GBL) (((LPBYTE)ppal_lcl) +
    			sizeof( DDRAWI_DDRAWPALETTE_LCL ) );
    ppal = ppal_lcl->lpGbl;
    ppal_lcl->lpDD_lcl = this_lcl;
    ppal_lcl->lpDD_Int = this_int;

    /*
     * Initialize some palette global state
     */
    ppal->dwContentsStamp = 1;

    if( dwFlags & DDPCAPS_ALLOW256 )
    {
	pflags |= DDRAWIPAL_ALLOW256;
    }

    if( dwFlags & DDPCAPS_8BITENTRIES )
    {
        pflags |= DDRAWIPAL_STORED_8INDEX;
    }

    if (dwFlags & DDPCAPS_ALPHA )
    {
        pflags |= DDRAWIPAL_ALPHA;
    }

    ppal_lcl->pPrivateDataHead = NULL;

    /*
     * allocate palette
     */
    ppal->lpColorTable = MemAlloc( entry_size * num_entries );
    if( ppal->lpColorTable == NULL )
    {
	MemFree( ppal_lcl );
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }

    /*
     * Create an interface for this palette
     */
#ifdef POSTPONED
    if (LOWERTHANDDRAW4(this_int))
    {
#endif
        ppal_int = newPaletteInterface( ppal_lcl, (LPVOID)&ddPaletteCallbacks );
#ifdef POSTPONED
    }
    else
    {
	ppal_int = newPaletteInterface( ppal_lcl, (LPVOID)&ddPalette2Callbacks );
    }
#endif
    
    if( NULL == ppal_int )
    {
	MemFree( ppal->lpColorTable );
	MemFree( ppal_lcl );
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }

    /*
     * copy the color table
     * we now copy the color table BEFORE we call the device's CreatePalette()
     * this is done as the device may want to overwrite certain of the palette
     * entries (e.g. if you don't specify DDPCAPS_ALLOW256 then the driver may
     * well choose to overwrite the 0 and 255 with black and white).
     */
    memcpy( ppal->lpColorTable, lpColorTable, entry_size * num_entries );

    /*
     * fill in misc stuff
     */
    ppal->lpDD_lcl = this_lcl;
    ppal->dwFlags = pflags;

    /*
     * are palettes even supported by the driver?
     */
    if( ( this->ddCaps.ddsCaps.dwCaps & DDSCAPS_PALETTE ) ||
        ( this->ddHELCaps.ddsCaps.dwCaps & DDSCAPS_PALETTE ) )
    {
	/* GEE: where do we allow the caller to require the palette
	 * be provided in hardware?
	 */
    
        if( (this->dwFlags & DDRAWI_DISPLAYDRV) ||
             this_lcl->lpDDCB->cbDDCallbacks.CreatePalette == NULL )
	{
	    // use HEL
	    cpfn = this_lcl->lpDDCB->HELDD.CreatePalette;
	    cphalfn = cpfn;
	    emulation = TRUE;
	}
	else
	{
	    // use HAL
	    cpfn = this_lcl->lpDDCB->HALDD.CreatePalette;
	    cphalfn = this_lcl->lpDDCB->cbDDCallbacks.CreatePalette;
	    emulation = FALSE;
	}
	cpd.CreatePalette = this_lcl->lpDDCB->cbDDCallbacks.CreatePalette;
	cpd.lpDD = this;
	cpd.lpDDPalette=ppal;
	cpd.lpColorTable=lpColorTable;
	cpd.is_excl = is_excl;
	DOHALCALL( CreatePalette, cpfn, cpd, rc, emulation );
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( cpd.ddRVal != DD_OK )
	    {
	        DPF( 5, "DDHAL_CreatePalette: ddrval = %ld", cpd.ddRVal );
	        LEAVE_DDRAW();
	        return cpd.ddRVal;
	    }
	}
	else
	{
	    LEAVE_DDRAW();
	    return DDERR_UNSUPPORTED;
	}
    }
    else
    {
	LEAVE_DDRAW();
	return DDERR_UNSUPPORTED;
    }

    /*
     * bump reference count, return object
     */
    ppal->dwProcessId = GetCurrentProcessId();
    ppal_lcl->dwLocalRefCnt = OBJECT_ISROOT;
    ppal_int->dwIntRefCnt++;
    ppal_lcl->dwLocalRefCnt++;
    ppal->dwRefCnt++;

    *lplpDDPalette = (LPDIRECTDRAWPALETTE) ppal_int;

    /*
     * If this ddraw object generates independent child objects, then this palette takes
     * a ref count on that ddraw object.
     */
    if (CHILD_SHOULD_TAKE_REFCNT(this_int))
    {
        /*
         * We need to remember which interface created this palette, in case we need to take a ref count
         * and then release it when the palette dies
         */
        lpDD->lpVtbl->AddRef(lpDD);
        ppal_lcl->pAddrefedThisOwner = (IUnknown *) lpDD;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_CreatePalette */

/*
 * ProcessPaletteCleanup
 *
 * A process is done, clean up any surfaces that it may have locked.
 *
 * NOTE: we enter with a lock taken on the DIRECTDRAW object.
 */
void ProcessPaletteCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDRAWPALETTE_INT	ppal_int;
    LPDDRAWI_DDRAWPALETTE_INT	ppnext_int;
    LPDDRAWI_DDRAWPALETTE_GBL	ppal;
    DWORD			rcnt;

    /*
     * run through all palettes owned by the driver object, and find ones
     * that have been accessed by this process
     */
    ppal_int = pdrv->palList;
    DPF( 4, "ProcessPaletteCleanup, ppal=%08lx", ppal_int );
    while( ppal_int != NULL )
    {
	ULONG	rc;
	ppal = ppal_int->lpLcl->lpGbl;
	ppnext_int = ppal_int->lpLink;

	rc = 1;
	if( ( ppal->dwProcessId == pid ) &&
	    ( ( NULL == pdrv_lcl ) || ( pdrv_lcl == ppal_int->lpLcl->lpDD_lcl ) ) )
	{
	    /*
	     * release the references by this process
	     */
	    rcnt = ppal_int->dwIntRefCnt;
	    DPF( 5, "Process %08lx had %ld accesses to palette %08lx", pid, rcnt, ppal_int );
	    while( rcnt >  0 )
	    {
		rc = InternalPaletteRelease( ppal_int );
		if( rc == 0 )
		{
		    break;
		}
		rcnt--;
	    }
	}
	else
	{
	    DPF( 5, "Process %08lx does not have access to palette" );
	}
	ppal_int = ppnext_int;
    }

} /* ProcessPaletteCleanup */


/*
 * DD_Palette_IsEqual
 */

HRESULT EXTERN_DDAPI DD_Palette_IsEqual(
                LPDIRECTDRAWPALETTE lpDDPThis,
                LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	this;
    LPDDRAWI_DDRAWPALETTE_INT	pal_int;
    LPDDRAWI_DDRAWPALETTE_LCL	pal_lcl;
    LPDDRAWI_DDRAWPALETTE_GBL	pal;
    DWORD			size;
    DWORD                       entry_size;
    UINT                        i,j;
    DWORD                       entry;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_IsEqual");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPThis;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

        pal_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( pal_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	pal_lcl = pal_int->lpLcl;
	pal = pal_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * First check the flags
     */
    if (this->dwFlags != pal->dwFlags)
    {
        DPF(2,"Different palette structures");
        LEAVE_DDRAW();
        return DD_FALSE;
    }

    size = FLAGS_TO_SIZE(this->dwFlags);

    if( this->dwFlags & DDRAWIPAL_STORED_8INDEX )
    {
	entry_size = sizeof( BYTE );
    }
    else
    {
	entry_size = sizeof( PALETTEENTRY );
    }
    
    switch (size)
    {
    case 2: // fall-thru
    case 4: // fall-thru
    case 16:
        if (memcmp(this->lpColorTable, pal->lpColorTable, size*entry_size) != 0)
        {
	    DPF(2, "Color tables are not the same" );
	    LEAVE_DDRAW();
    	    return DD_FALSE;
	}
        break;

    case 256:
        for (i = 0; i < 16; ++i)
        {
            entry = i;
            for (j = 0; j < 16; j++)
            {
                if ((*(LPDWORD)&(this->lpColorTable[entry]) != (*(LPDWORD)&pal->lpColorTable[entry])))
                {
                    DPF(5,"Color table entry mismatch: 0x%08x, 0x%08x",
                        *(LPDWORD)&this->lpColorTable[entry],
                        *(LPDWORD)&pal->lpColorTable[entry] );
                    LEAVE_DDRAW();
                    return DD_FALSE;
                }

                entry += 16;
            }
        }
    }

    /*
     * The palettes are the same!
     */
    LEAVE_DDRAW();

    return DD_OK;

} /* DD_Palette_SetEntries */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddoptsur.c ===
//-------------------------------------------------------------------------------
//
//  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
//
//  File:       ddoptsur.c
//  Content:    DirectDraw Optimized Surface support
//  History:
//   Date      By       Reason
//   ====      ==       ======
//   2-nov-97  anankan  Original implementation
//
//-------------------------------------------------------------------------------

#include "ddrawpr.h"

//-------------------------------------------------------------------------------
//
// IsRecognizedOptSurfaceGUID
//
// Checks to see if the GUID passed is recognized by the driver.
// This is done by looking at the list maintained in LPDDRAWI_DIRECTDRAW_GBL
//
//-------------------------------------------------------------------------------
BOOL
IsRecognizedOptSurfaceGUID(
    LPDDRAWI_DIRECTDRAW_GBL  this,
    LPGUID                   pGuid)
{
    int i;

    LPDDOPTSURFACEINFO pOptSurfInfo;
    pOptSurfInfo = this->lpDDOptSurfaceInfo;

    for (i = 0; i < (int)pOptSurfInfo->dwNumGuids; i++)
    {
        if (IsEqualIID(pGuid, &(pOptSurfInfo->lpGuidArray[i])))
            return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------------------------------
//
// ValidateSurfDesc
//
// Fill in correct surf desc to be passed to the driver
//
//-------------------------------------------------------------------------------
HRESULT
ValidateSurfDesc(
    LPDDSURFACEDESC2         pOrigSurfDesc
    )
{
    DWORD   caps = pOrigSurfDesc->ddsCaps.dwCaps;

    //
    // check for no caps at all!
    //
    if( caps == 0 )
    {
    	DPF_ERR( "no caps specified" );
        return DDERR_INVALIDCAPS;
    }

    //
    // check for bogus caps.
    //
    if( caps & ~DDSCAPS_VALID )
    {
        DPF_ERR( "Create surface: invalid caps specified" );
        return DDERR_INVALIDCAPS;
    }

    //
    // Anything other than a texture is not allowed
    // ATTENTION: some more flags need to be checked
    //
    if(caps & (DDSCAPS_EXECUTEBUFFER      |
               DDSCAPS_BACKBUFFER         |
               DDSCAPS_FRONTBUFFER        |
               DDSCAPS_OFFSCREENPLAIN     |
               DDSCAPS_PRIMARYSURFACE     |
               DDSCAPS_PRIMARYSURFACELEFT |
               DDSCAPS_VIDEOPORT          |
               DDSCAPS_ZBUFFER            |
               DDSCAPS_OWNDC              |
               DDSCAPS_OVERLAY            |
               DDSCAPS_3DDEVICE           |
               DDSCAPS_ALLOCONLOAD)
        )
    {
        DPF_ERR( "currently only textures can be optimized" );
        return DDERR_INVALIDCAPS;
    }

    if( !(caps & DDSCAPS_TEXTURE) )
    {
        DPF_ERR( "DDSCAPS_TEXTURE needs to be set" );
        return DDERR_INVALIDCAPS;
    }

    // Pixelformat not specified ?
    if (!(pOrigSurfDesc->dwFlags & DDSD_PIXELFORMAT))
    {
        DPF_ERR( "Pixel format needs to be set" );
        return DDERR_INVALIDCAPS;
    }

    return DD_OK;
}

//-------------------------------------------------------------------------------
//
// DD_CanOptimizeSurface
//
// Check to see if a surface given the description be optimized.
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_CanOptimizeSurface(
    LPDIRECTDRAW             pDD,
    LPDDSURFACEDESC2         pDDSurfDesc,
    LPDDOPTSURFACEDESC       pDDOptSurfDesc,
    BOOL                    *bTrue
    )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    DDHAL_CANOPTIMIZESURFACEDATA ddhal_cosd;
    LPDDOPTSURFACEINFO    pDDOptSurfInfo = NULL;
    HRESULT ddrval = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CanOptimizeSurface");

    //
    // Setup DPF stuff
    //
    DPF_ENTERAPI(pDD);

    //
    // Parameter validation
    //
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) pDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            DPF_ERR( "Invalid driver object passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( this->dwModeIndex == DDUNSUPPORTEDMODE )
        {
            DPF_ERR( "Driver is in an unsupported mode" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_UNSUPPORTEDMODE);
            return DDERR_UNSUPPORTEDMODE;
        }

        if( !VALID_DDSURFACEDESC2_PTR( pDDSurfDesc ) )
        {
            DPF_ERR( "Invalid surface description. Did you set the dwSize member?" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }

        if( !VALID_DDOPTSURFACEDESC_PTR( pDDOptSurfDesc ) )
        {
            DPF_ERR( "Invalid optimized surface description. Did you set the dwSize member?" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }

        if( !VALID_PTR( bTrue,  sizeof (*bTrue)) )
        {
            DPF_ERR( "Invalid Boolean pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *bTrue  = TRUE;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
        return DDERR_INVALIDPARAMS;
    }

    //
    // Quit with error if:
    // 1) No hardware
    // 2) Hardware doesnt support optimized surfaces
    // 3) pSurfDesc does not provide useful information
    // 4) Is the guid one of the recognized ones
    // 5) The driver fails for some reason
    //

    // 1)
    if( this->dwFlags & DDRAWI_NOHARDWARE )
    {
        DPF_ERR ("No hardware present");
        LEAVE_DDRAW();
        return DDERR_NODIRECTDRAWHW;
    }

    // 2)
    if ((0 == this->lpDDOptSurfaceInfo) ||
        !(this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        DPF_ERR ("Optimized surfaces not supported");
        LEAVE_DDRAW();
        return DDERR_NOOPTSURFACESUPPORT;
    }

    // 3)
    ddrval = ValidateSurfDesc (pDDSurfDesc);
    if (ddrval != DD_OK)
    {
        DPF_ERR ("Invalid surface description");
        LEAVE_DDRAW();
        return ddrval;
    }

    // 4)
    if (!IsRecognizedOptSurfaceGUID (this, &(pDDOptSurfDesc->guid)))
    {
        DPF_ERR( "Not a recognized GUID" );
        LEAVE_DDRAW();
        return DDERR_UNRECOGNIZEDGUID;
    }

    // Call the driver
    ZeroMemory (&ddhal_cosd, sizeof (ddhal_cosd));
    ddhal_cosd.lpDD            = this_lcl;
    ddhal_cosd.ddOptSurfDesc   = *pDDOptSurfDesc;
    ddhal_cosd.ddSurfaceDesc   = *pDDSurfDesc;

    // Make the HAL call
    pDDOptSurfInfo = this->lpDDOptSurfaceInfo;
    DOHALCALL(CanOptimizeSurface, pDDOptSurfInfo->CanOptimizeSurface, ddhal_cosd, ddrval, FALSE );

    if (ddrval != DD_OK)
    {
        DPF_ERR ("LoadUnOptSurface failed in the driver");
        LEAVE_DDRAW();
        return ddrval;
    }

    if (ddhal_cosd.bCanOptimize != 0)
    {
        *bTrue = TRUE;
    }
    else
    {
        *bTrue = FALSE;
    }

    LEAVE_DDRAW();
    return DD_OK;
}

//-------------------------------------------------------------------------------
//
// CreateAndLinkUninitializedSurface
//
// Create a surface, and link it into the chain.
// We create a single surface place-holder  here, real work is done at the
// Load/Copy time.
//
//-------------------------------------------------------------------------------
HRESULT
CreateAndLinkUnintializedSurface(
    LPDDRAWI_DIRECTDRAW_LCL this_lcl,
    LPDDRAWI_DIRECTDRAW_INT this_int,
    LPDIRECTDRAWSURFACE FAR *ppDDSurface
    )
{
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   pSurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf;
    LPVOID                     *ppSurf_gbl_more;
    DDSCAPS                     caps;
    DDPIXELFORMAT               ddpf;
    int                         surf_size;
    int                         surf_size_lcl;
    int                         surf_size_lcl_more;
#ifdef WIN95
    DWORD                       ptr16;
#endif
    HRESULT                     ddrval = DD_OK;

    // DDraw-global
    this = this_lcl->lpGbl;
    #ifdef WINNT
	// Update DDraw handle in driver GBL object.
	this->hDD = this_lcl->hDD;
    #endif //WINNT

    //
    // Zero the caps
    //
    ZeroMemory (&caps, sizeof (DDCAPS));

    //
    // PixelFormat: Mark it as an empty surface
    //
    ZeroMemory (&ddpf, sizeof (ddpf));
    ddpf.dwSize = sizeof (ddpf);
    ddpf.dwFlags = DDPF_EMPTYSURFACE;


    //
    // Allocate the internal Surface structure and initialize the fields
    //
    //
    // fail requests for non-local video memory allocations if the driver does
    // not support non-local video memory.
    //
    // NOTE: Should we really do this or just let the allocation fail from
    // naturalcauses?
    //
    // ALSO NOTE: Don't have to worry about emulation as no emulated surface
    // should
    // ever get this far with DDSCAPS_NONLOCALVIDMEM set.
    //
    // ALSO ALSO NOTE: Should we also fail DDSCAPS_LOCALVIDMEM if the driver does
    // not support DDSCAPS_NONLOCALVIDMEM. My feeling is that we should allow.
    // DDSCAPS_LOCALVIDMEM is legal with a non AGP driver - redundant but legal.
    //

    //
    // allocate the surface struct, allowing for overlay and pixel
    // format data
    //
    // NOTE: This single allocation can allocate space for local surface
    // structure (DDRAWI_DDRAWSURFACE_LCL), the additional local surface
    // structure (DDRAWI_DDRAWSURFACE_MORE) and the global surface structure
    // (DDRAWI_DDRAWSURFACE_GBL). And now the global surface more
    // structure too (DDRAWI_DDRAWSURFACE_GBL_MORE). As both the local and
    // global objects can be variable sized this can get pretty complex.
    // Additionally, we have 4 bytes just before the surface_gbl that points to
    // the surface_gbl_more.
    //
    // CAVEAT: All future surfaces that share this global all point to this
    // allocation. The last surface's release has to free it. During
    // InternalSurfaceRelease (in ddsiunk.c) a calculation is made to determine
    // the start of this memory allocation. If the surface being released is
    // the first one, then freeing "this_lcl" will free the whole thing. If
    // not, then "this_lcl->lpGbl - (Surface_lcl + surface_more + more_ptr)"
    // is computed. Keep this layout in synch with code in ddsiunk.c.
    //
    //  The layout of the various objects in the allocation is as follows:
    //
    // +-----------------+---------------+----+------------+-----------------+
    // | SURFACE_LCL     | SURFACE_MORE  |More| SURFACE_GBL| SURFACE_GBL_MORE|
    // | (variable)      |               |Ptr | (variable) |         |
    // +-----------------+---------------+----+------------+-----------------+
    // <- surf_size_lcl ->           |                   |
    // <- surf_size_lcl_more ------------>                   |
    // <- surf_size --------------------------------------------------------->
    //
    //

    // ATTENTION: Currently ignores to account for the overlays
#if 0
    surf_size_lcl = sizeof( DDRAWI_DDRAWSURFACE_LCL );
#endif
    surf_size_lcl = offsetof( DDRAWI_DDRAWSURFACE_LCL, ddckCKSrcOverlay );
    surf_size_lcl_more = surf_size_lcl + sizeof( DDRAWI_DDRAWSURFACE_MORE );

    // Assume that the pixelformat is present for allocating the GBL
    surf_size = surf_size_lcl_more + sizeof( DDRAWI_DDRAWSURFACE_GBL );
#if 0
    surf_size = surf_size_lcl_more + offsetof( DDRAWI_DDRAWSURFACE_GBL,
                                               ddpfSurface );
#endif

    // Need to allocate a pointer just before the SURFACE_GBL to
    // point to the beginning of the GBL_MORE.
    surf_size += sizeof( LPDDRAWI_DDRAWSURFACE_GBL_MORE );

    // Need to allocate a SURFACE_GBL_MORE too
    surf_size += sizeof( DDRAWI_DDRAWSURFACE_GBL_MORE );

    DPF( 8, "Allocating struct (%ld)", surf_size );

#ifdef WIN95
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc16 (surf_size, &ptr16);
#else
    pSurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc (surf_size);
#endif

    if (pSurf_lcl == NULL)
    {
        DPF_ERR ("Failed to allocate internal surface structure");
        ddrval =  DDERR_OUTOFMEMORY;
        goto error_exit_create_link;
    }

    // Initialize SURFACE_GBL pointer
    // skipping 4 bytes for a pointer to the GBL_MORE
    ZeroMemory (pSurf_lcl, surf_size);
    pSurf_lcl->lpGbl = (LPVOID) (((LPSTR) pSurf_lcl) + surf_size_lcl_more +
                                 sizeof (LPVOID));

    // Initialize GBL_MORE pointer
    ppSurf_gbl_more = (LPVOID *)((LPBYTE)pSurf_lcl->lpGbl - sizeof (LPVOID));
    *ppSurf_gbl_more = (LPVOID) ((LPBYTE)pSurf_lcl + surf_size
                                 - sizeof (DDRAWI_DDRAWSURFACE_GBL_MORE));

    // Sanity Check
    DDASSERT( *ppSurf_gbl_more ==
              (LPVOID) GET_LPDDRAWSURFACE_GBL_MORE(pSurf_lcl->lpGbl));

    //
    // 1) Initialize GBL_MORE structure
    //
    GET_LPDDRAWSURFACE_GBL_MORE(pSurf_lcl->lpGbl)->dwSize =
        sizeof( DDRAWI_DDRAWSURFACE_GBL_MORE );

    // Init the contents stamp to 0 means the surface's contents can
    // change at any time.
    GET_LPDDRAWSURFACE_GBL_MORE( pSurf_lcl->lpGbl )->dwContentsStamp = 0;

    //
    // 2) Initialize DDRAWI_DDRAWSURFACE_GBL structure
    //
    pSurf = pSurf_lcl->lpGbl;
    pSurf->ddpfSurface = ddpf;
    pSurf->lpDD = this;

    //
    // 3) Allocate and initialize DDRAWI_DDRAWSURFACE_INT structure
    //
    pSurf_int = (LPDDRAWI_DDRAWSURFACE_INT)
        MemAlloc( sizeof(DDRAWI_DDRAWSURFACE_INT));
    if( NULL == pSurf_int )
    {
        DPF_ERR ("Failed allocation of DDRAWI_DDRAWSURFACE_INT");
        ddrval = DDERR_OUTOFMEMORY;
        goto error_exit_create_link;
    }

    // fill surface specific stuff
    ZeroMemory (pSurf_int, sizeof(DDRAWI_DDRAWSURFACE_INT));
    pSurf_int->lpLcl = pSurf_lcl;
    pSurf_int->lpVtbl = NULL;

    //
    // 4) Initialize DDRAWI_DDRAWSURFACE_LCL structure
    //
    pSurf_lcl->dwLocalRefCnt = OBJECT_ISROOT;
    pSurf_lcl->dwProcessId = GetCurrentProcessId();
#ifdef WIN95
    pSurf_lcl->dwModeCreatedIn = this->dwModeIndex;
#else
    pSurf_lcl->dmiCreated = this->dmiCurrent;
#endif
    pSurf_lcl->dwBackBufferCount = 0;

    // Flag it as an:
    // 1) empty surface
    // 2) Front surface
    // 3) Has a pixelformat
    pSurf_lcl->dwFlags = (DDRAWISURF_EMPTYSURFACE |
                          DDRAWISURF_FRONTBUFFER  |
                          DDRAWISURF_HASPIXELFORMAT);
    //
    // 5) Initialize DDRAWI_DDRAWSURFACE_MORE structure
    //
    pSurf_lcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE) (((LPSTR) pSurf_lcl) +
                                                          surf_size_lcl );
    pSurf_lcl->lpSurfMore->dwSize = sizeof( DDRAWI_DDRAWSURFACE_MORE );
    pSurf_lcl->lpSurfMore->lpIUnknowns = NULL;
    pSurf_lcl->lpSurfMore->lpDD_lcl = this_lcl;
    pSurf_lcl->lpSurfMore->lpDD_int = this_int;
    pSurf_lcl->lpSurfMore->dwMipMapCount = 0UL;
    pSurf_lcl->lpSurfMore->lpddOverlayFX = NULL;
    pSurf_lcl->lpSurfMore->lpD3DDevIList = NULL;
    pSurf_lcl->lpSurfMore->dwPFIndex = PFINDEX_UNINITIALIZED;

    // fill in the current caps
    pSurf_lcl->ddsCaps = caps;

#ifdef WINNT
    //
    // NT kernel needs to know about surface
    //

    //don't let NT kernel know about exec buffers
    DPF(8,"Attempting to create NT kernel mode surface object");

    if (!DdCreateSurfaceObject(pSurf_lcl, FALSE))
    {
        DPF_ERR("NT kernel mode stuff won't create its surface object!");
        ddrval = DDERR_GENERIC;
        goto error_exit_create_link;
    }
    DPF(9,"Kernel mode handle is %08x", pSurf_lcl->hDDSurface);
#endif

    //
    // Link the newly created surface to the DDraw surface chain
    //
    pSurf_int->lpLink = this->dsList;
    this->dsList = pSurf_int;

    //
    // AddRef the newly created surface
    //
    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) pSurf_int );

    //
    // Now assign it to the ptr-to-ptr passed in
    //
	*ppDDSurface = (LPDIRECTDRAWSURFACE) pSurf_int;
    return DD_OK;

error_exit_create_link:
    //
    // Free any allocated memory
    //

    // 1) The allocated SURFACE_LCL
    if (pSurf_lcl)
    {
	    MemFree (pSurf_lcl);
    }

    // 2) The Surface_int
    if (pSurf_int)
    {
        MemFree (pSurf_int);
    }

    return ddrval;
}

//-------------------------------------------------------------------------------
//
// createAndLinkOptSurface
//
// Create a surface, and link it into the chain.
// We create a single surface place-holder  here, real work is done at the
// Load/Copy time.
//
//-------------------------------------------------------------------------------
HRESULT
createAndLinkOptSurface(
    LPDDRAWI_DIRECTDRAW_LCL this_lcl,
    LPDDRAWI_DIRECTDRAW_INT this_int,
    LPDDOPTSURFACEDESC      pDDOptSurfaceDesc,
    LPDIRECTDRAWSURFACE FAR *ppDDSurface
    )
{
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   new_surf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   new_surf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   new_surf;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE   new_surf_gbl_more;
    DDSCAPS2                    caps2;
    LPDDOPTSURFACEDESC          pOptSurfDesc;
    DDPIXELFORMAT               ddpf;
    HRESULT                     ddrval = DD_OK;

    // DDraw-global
    this = this_lcl->lpGbl;

    //
    // Fix the caps
    //
    ZeroMemory (&caps2, sizeof (DDSCAPS));
    caps2.dwCaps = DDSCAPS_OPTIMIZED;
    if (pDDOptSurfaceDesc->ddSCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        caps2.dwCaps |= DDSCAPS_SYSTEMMEMORY;
    if (pDDOptSurfaceDesc->ddSCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        caps2.dwCaps |= DDSCAPS_VIDEOMEMORY;
    if (pDDOptSurfaceDesc->ddSCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
        caps2.dwCaps |= DDSCAPS_LOCALVIDMEM;
    if (pDDOptSurfaceDesc->ddSCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        caps2.dwCaps |= DDSCAPS_NONLOCALVIDMEM;

    // Quit is the memory type is not supported
    if (caps2.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        if (!(this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM))
        {
            DPF_ERR( "Driver does not support non-local video memory" );
            ddrval = DDERR_NONONLOCALVIDMEM;
            goto error_exit_create_opt;
        }
    }

#if 0
    // Quit if textures are not supported
    if (!(this->ddCaps.dwCaps & DDSCAPS_TEXTURE))
    {
        DPF_ERR( "Driver does not support textures" );
        return DDERR_NOTEXTUREHW;
    }
#endif

    //
    // PixelFormat: Mark it as an empty surface
    //
    ZeroMemory (&ddpf, sizeof (ddpf));
    ddpf.dwSize = sizeof (ddpf);
    ddpf.dwFlags = DDPF_EMPTYSURFACE;

    //
    // OptSurfaceDesc
    //
    pOptSurfDesc = MemAlloc (sizeof (DDOPTSURFACEDESC));
    if (NULL == pOptSurfDesc)
    {
        DPF_ERR ("Memory allocation failed for opt surface descriptor");
        ddrval = DDERR_OUTOFMEMORY;
        goto error_exit_create_opt;
    }
    ZeroMemory (pOptSurfDesc, sizeof (*pOptSurfDesc));
    CopyMemory (pOptSurfDesc, pDDOptSurfaceDesc, sizeof (DDOPTSURFACEDESC));

    // Create and link an uninitialized surface
    ddrval =  CreateAndLinkUnintializedSurface (this_lcl,
                                                this_int,
                                                ppDDSurface);
    if (ddrval != DD_OK)
    {
        DPF_ERR ("createAndLinkUninitializedSurface failed");
        goto error_exit_create_opt;
    }


    //
    // 1) Update GBL_MORE structure
    //
    new_surf_int = (LPDDRAWI_DDRAWSURFACE_INT)*ppDDSurface;
    new_surf_lcl = new_surf_int->lpLcl;
    new_surf     = new_surf_lcl->lpGbl;
    new_surf_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(new_surf);
    new_surf_gbl_more->lpDDOptSurfaceDesc = pOptSurfDesc;
    // Init the contents stamp to 0 means the surface's contents can
    // change at any time.
    new_surf_gbl_more->dwContentsStamp = 0;

    //
    // 2) Update DDRAWI_DDRAWSURFACE_GBL structure
    //
    new_surf->ddpfSurface = ddpf;

    //
    // 3) Update DDRAWI_DDRAWSURFACE_INT structure
    //
    new_surf_int->lpVtbl = &ddOptSurfaceCallbacks;

    //
    // 4) Update DDRAWI_DDRAWSURFACE_LCL structure
    //

    // Flag it as an:
    // 1) empty surface
    // 2) Front surface
    // 3) Has a pixelformat
    new_surf_lcl->dwFlags = (DDRAWISURF_EMPTYSURFACE |
                             DDRAWISURF_FRONTBUFFER  |
                             DDRAWISURF_HASPIXELFORMAT);
    // fill in the current caps
    CopyMemory (&new_surf_lcl->ddsCaps, &caps2, sizeof(new_surf_lcl->ddsCaps));


    return DD_OK;

error_exit_create_opt:
    //
    // Free any allocated memory
    //

    // 1) The allocated OPTSURFDESC
    if (pOptSurfDesc)
    {
	    MemFree (pOptSurfDesc);
    }

    return ddrval;
}

//-------------------------------------------------------------------------------
//
// InternalCreateOptSurface
//
// Create the surface.
// This is the internal way of doing this; used by EnumSurfaces.
// Assumes the directdraw lock has been taken.
//
//-------------------------------------------------------------------------------

HRESULT
InternalCreateOptSurface(
    LPDDRAWI_DIRECTDRAW_LCL  this_lcl,
    LPDDOPTSURFACEDESC       pDDOptSurfaceDesc,
    LPDIRECTDRAWSURFACE FAR *ppDDSurface,
    LPDDRAWI_DIRECTDRAW_INT  this_int )
{
    DDSCAPS2        caps2;
    DDOSCAPS        ocaps;
    HRESULT         ddrval;
    LPDDRAWI_DIRECTDRAW_GBL this;

    this = this_lcl->lpGbl;

    // Validate Caps
    caps2 = pDDOptSurfaceDesc->ddSCaps;
    if (caps2.dwCaps & ~DDOSDCAPS_VALIDSCAPS)
    {
        DPF_ERR( "Unrecognized optimized surface caps" );
        return DDERR_INVALIDCAPS;
    }

    ocaps = pDDOptSurfaceDesc->ddOSCaps;
    if (ocaps.dwCaps & ~DDOSDCAPS_VALIDOSCAPS)
    {
        DPF_ERR( "Unrecognized optimized surface caps" );
        return DDERR_INVALIDCAPS;
    }

    //
    // valid memory caps?
    //
    if ((caps2.dwCaps & DDSCAPS_SYSTEMMEMORY)
        && (caps2.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        DPF_ERR( "Can't specify SYSTEMMEMORY and VIDEOMEMORY" );
        return DDERR_INVALIDCAPS;
    }

    //
    // If DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM are specified
    // then DDSCAPS_VIDOEMEMORY must be explicity specified. Note, we
    // can't dely this check until checkCaps() as by that time the heap
    // scanning software may well have turned on DDSCAPS_VIDOEMEMORY.
    //
    if ((caps2.dwCaps & (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM)) &&
        !(caps2.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        DPF_ERR( "DDOSDCAPS_VIDEOMEMORY must be specified with DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM" );
        return DDERR_INVALIDCAPS;
    }

    //
    // have to specify if it is sys-mem or vid-mem
    //
    if ((caps2.dwCaps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_SYSTEMMEMORY)) == 0)
    {
        DPF_ERR( "Need to specify the memory type" );
        return DDERR_INVALIDCAPS;
    }

    //
    // Validate optimization type caps
    //
    if ((ocaps.dwCaps & (DDOSDCAPS_OPTCOMPRESSED | DDOSDCAPS_OPTREORDERED)) == 0)
    {
        DPF_ERR ("Not specified whether compressed or reordered, let the driver choose");
    }

    // Cannot be both compresses and reordered
    if ((ocaps.dwCaps & DDOSDCAPS_OPTCOMPRESSED)
        && (ocaps.dwCaps & DDOSDCAPS_OPTREORDERED))
    {
        DPF_ERR ("Cannot be both compresses and reordered");
        return DDERR_INVALIDCAPS;
    }

    ddrval = createAndLinkOptSurface (this_lcl, this_int, pDDOptSurfaceDesc,
                                      ppDDSurface);
    return ddrval;
}

//-------------------------------------------------------------------------------
//
// CreateOptSurface method of IDirectDrawSurface4
//
// Create an optimized surface given the Optimized surface descriptor
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_CreateOptSurface(
    LPDIRECTDRAW             pDD,
    LPDDOPTSURFACEDESC       pDDOptSurfaceDesc,
    LPDIRECTDRAWSURFACE FAR *ppDDS,
    IUnknown FAR            *pUnkOuter )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    DDOPTSURFACEDESC ddosd;
    HRESULT         ddrval;

    ZeroMemory(&ddosd,sizeof(ddosd));
    ddosd.dwSize = sizeof (ddosd);

    //
    // Return error if aggregation expected
    //
    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CreateOptSurface");

    //
    // Setup DPF stuff
    //
    DPF_ENTERAPI(pDD);

    //
    // Parameter validation
    //
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) pDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            DPF_ERR( "Invalid driver object passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        // verify that cooperative level is set
        if( !(this_lcl->dwLocalFlags & DDRAWILCL_SETCOOPCALLED) )
        {
            DPF_ERR( "Must call SetCooperativeLevel before calling Create functions" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_NOCOOPERATIVELEVELSET);
            return DDERR_NOCOOPERATIVELEVELSET;
        }

        if( this->dwModeIndex == DDUNSUPPORTEDMODE )
        {
            DPF_ERR( "Driver is in an unsupported mode" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_UNSUPPORTEDMODE);
            return DDERR_UNSUPPORTEDMODE;
        }

        if( !VALID_DDOPTSURFACEDESC_PTR( pDDOptSurfaceDesc ) )
        {
            DPF_ERR( "Invalid optimized surface description. Did you set the dwSize member?" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }
        memcpy(&ddosd, pDDOptSurfaceDesc, sizeof(*pDDOptSurfaceDesc));
        *ppDDS = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
        return DDERR_INVALIDPARAMS;
    }

    // Quit if there is no hardware present
    if( this->dwFlags & DDRAWI_NOHARDWARE )
    {
        ddrval = DDERR_NODIRECTDRAWHW;
        goto exit_create;
    }

    // Assert that: (0 == this->lpDDOptSurfaceInfo) <==> (if and only if)
    // (this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES)

    //Check to see if the driver supports OptSurface
    if ((0 == this->lpDDOptSurfaceInfo) // GetDriverInfo failed for some reason
        || !(this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        ddrval = DDERR_NOOPTSURFACESUPPORT;
        goto exit_create;
    }

    //
    // Check if the GUID passed is a recognized optimized surface GUID
    // The compression ratio is more a hint.
    //
    if (!IsRecognizedOptSurfaceGUID (this, &(pDDOptSurfaceDesc->guid)))
    {
        DPF_ERR( "Not a recognized GUID" );
        ddrval = DDERR_UNRECOGNIZEDGUID;
        goto exit_create;
    }

    //
    // Now create the Optimized surface
    //
    ddrval = InternalCreateOptSurface(this_lcl, &ddosd, ppDDS, this_int);

exit_create:
    DPF_APIRETURNS(ddrval);
    LEAVE_DDRAW();
    return ddrval;
}

//-------------------------------------------------------------------------------
//
// CreateOptSurface method of IDirectDrawSurface4
//
// Create an optimized surface given the Optimized surface descriptor
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_ListOptSurfaceGUIDS(
    LPDIRECTDRAW    pDD,
    DWORD          *pNumGuids,
    LPGUID          pGuidArray )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    HRESULT         ddrval = DD_OK;
    LPGUID          pRetGuids = NULL;
    LPDDOPTSURFACEINFO pOptSurfInfo;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_ListOptSurfaceGUIDS");

    //
    // Parameter validation
    //
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) pDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            DPF_ERR( "Invalid driver object passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( !VALID_PTR( pGuidArray, sizeof (GUID) ))
        {
            DPF_ERR( "Invalid GuidArray pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        pGuidArray = NULL;

        if( !VALID_PTR( pNumGuids,  sizeof (*pNumGuids)) )
        {
            DPF_ERR( "Invalid GuidArray pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *pNumGuids  = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
        return DDERR_INVALIDPARAMS;
    }

    pOptSurfInfo = this->lpDDOptSurfaceInfo;

    // Assert that: (0 == this->lpDDOptSurfaceInfo) <==> (if and only if)
    // (this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES)

    //Check to see if the driver supports OptSurface
    if ((0 == pOptSurfInfo) // GetDriverInfo failed for some reason
        || !(this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        ddrval = DDERR_NOOPTSURFACESUPPORT;
        goto list_exit;
    }

    // If there are no GUIDS reported by the driver,
    // return the nulled out out-params.
    if (pOptSurfInfo->dwNumGuids == 0)
    {
        ddrval = DD_OK;
        goto list_exit;
    }

    // Allocate the array of GUIDS
    // ATTENTION: Incomplete allocation?
    pRetGuids = MemAlloc(pOptSurfInfo->dwNumGuids * sizeof(GUID));
	if( NULL == pRetGuids )
	{
	    ddrval = DDERR_OUTOFMEMORY;
        goto list_exit;
	}

    // Copy the GUID array to be returned
    CopyMemory ((PVOID)pRetGuids, (PVOID)pOptSurfInfo->lpGuidArray,
                pOptSurfInfo->dwNumGuids * sizeof(GUID));
    pGuidArray = pRetGuids;
    *pNumGuids = pOptSurfInfo->dwNumGuids;

list_exit:
    LEAVE_DDRAW();
    return ddrval;
}

//-------------------------------------------------------------------------------
//
// GetOptSurfaceDesc method of IDirectDrawOptSurface
//
// Get the Optimized surface description
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_OptSurface_GetOptSurfaceDesc(
    LPDIRECTDRAWSURFACE  pDDS,
    LPDDOPTSURFACEDESC   pDDOptSurfDesc)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE   this_gbl_more;
    LPDDOPTSURFACEDESC   pDDRetOptSurfDesc = NULL;
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_OptSurface_GetOptSurfaceDesc");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(this);

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        if( !VALID_DDOPTSURFACEDESC_PTR( pDDOptSurfDesc ) )
        {
            DPF_ERR( "Invalid optimized surface description. Did you set the dwSize member?" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }
        pDDOptSurfDesc = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    //
    // Quit with error if:
    // 1) No hardware
    // 2) Hardware doesnt support optimized surfaces
    // 3) Surface is an unoptimized surface
    //

    // DDraw Gbl pointer
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

    // Assert that: (0 == this->lpDDOptSurfaceInfo) <==> (if and only if)
    // (this->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES)

    // 1)
    if( pdrv->dwFlags & DDRAWI_NOHARDWARE )
    {
        DPF_ERR ("No hardware present");
        LEAVE_DDRAW();
        return DDERR_NODIRECTDRAWHW;
    }

    // 2)
    if ((0 == pdrv->lpDDOptSurfaceInfo) ||
        !(pdrv->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        DPF_ERR ("Optimized surfaces not supported");
        LEAVE_DDRAW();
        return DDERR_NOOPTSURFACESUPPORT;
    }

    // 3)
    if (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        DPF_ERR ("Current surface is not an optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANOPTIMIZEDSURFACE;
    }

    pDDRetOptSurfDesc = MemAlloc (sizeof (*pDDRetOptSurfDesc));
    if (!pDDRetOptSurfDesc)
    {
        DPF_ERR ("Memory allocation failed");
        LEAVE_DDRAW();
        return DDERR_OUTOFMEMORY;
    }
    ZeroMemory (pDDRetOptSurfDesc, sizeof (*pDDRetOptSurfDesc));
    CopyMemory (pDDRetOptSurfDesc, this_gbl_more->lpDDOptSurfaceDesc,
                sizeof (*pDDRetOptSurfDesc));
    pDDOptSurfDesc = pDDRetOptSurfDesc;

    LEAVE_DDRAW();
    return DD_OK;
}

//-------------------------------------------------------------------------------
//
// DoLoadUnOptSurf
//
// Actually make the HAL call and update data-structures if the call
// succeeds.
//
//-------------------------------------------------------------------------------
HRESULT
DoLoadUnOptSurf(
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   this,
    LPDDRAWI_DDRAWSURFACE_LCL   src_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   src
    )
{
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    DDHAL_OPTIMIZESURFACEDATA   ddhal_osd;
    LPDDOPTSURFACEINFO    pDDOptSurfInfo = NULL;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE this_gbl_more, src_gbl_more;
    HRESULT ddrval = DD_OK;

    // Get the ddraw pointers
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;
    pDDOptSurfInfo = pdrv->lpDDOptSurfaceInfo;
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE (this);

    // Setup data to pass to the driver
    ZeroMemory (&ddhal_osd, sizeof (DDHAL_COPYOPTSURFACEDATA));
    ddhal_osd.lpDD           = pdrv_lcl;
    ddhal_osd.ddOptSurfDesc  = *(this_gbl_more->lpDDOptSurfaceDesc);
    ddhal_osd.lpDDSSrc       = src_lcl;
    ddhal_osd.lpDDSDest      = this_lcl;

    // Make the HAL call
    DOHALCALL(OptimizeSurface, pDDOptSurfInfo->OptimizeSurface, ddhal_osd, ddrval, FALSE );

    if (ddrval != DD_OK)
    {
        DPF_ERR ("LoadUnOptSurface failed in the driver");
        return ddrval;
    }

    // ATTENTION: Should the driver do these updates ?

    // 1) Update the DDRAWI_DDRAWSURFACE_LCL structure
    //    Color key stuff is ignored for now
    this_lcl->dwFlags = src_lcl->dwFlags;
    this_lcl->dwFlags &= ~DDRAWISURF_EMPTYSURFACE;
    this_lcl->ddsCaps = src_lcl->ddsCaps;
    this_lcl->ddsCaps.dwCaps |= DDSCAPS_OPTIMIZED;
#ifdef WIN95
    this_lcl->dwModeCreatedIn = src_lcl->dwModeCreatedIn;
#else
    this_lcl->dmiCreated = src_lcl->dmiCreated;
#endif
    this_lcl->dwBackBufferCount = src_lcl->dwBackBufferCount;

    // 2) Update the DDRAWI_DDRAWSURFACE_MORE structure
    this_lcl->lpSurfMore->dwMipMapCount = src_lcl->lpSurfMore->dwMipMapCount;
    this_lcl->lpSurfMore->ddsCapsEx = src_lcl->lpSurfMore->ddsCapsEx;

    // 3) Update the DDRAWI_DDRAWSURFACE_GBL structure
    this->dwGlobalFlags = src->dwGlobalFlags;
    this->wHeight = src->wHeight;
    this->wWidth = src->wWidth;
    this->ddpfSurface = src->ddpfSurface;

    // 4) Update the DDRAWI_DDRAWSURFACE_GBL_MORE structure
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE (this);
    src_gbl_more  = GET_LPDDRAWSURFACE_GBL_MORE (src);

    this_gbl_more->dwContentsStamp = src_gbl_more->dwContentsStamp;
    CopyMemory (this_gbl_more->lpDDOptSurfaceDesc,
                src_gbl_more->lpDDOptSurfaceDesc,
                sizeof (DDOPTSURFACEDESC));

    return ddrval;
}

//-------------------------------------------------------------------------------
//
// FilterSurfCaps
//
// Check to see if the surface is can be optimized
//
//-------------------------------------------------------------------------------
HRESULT
FilterSurfCaps(
    LPDDRAWI_DDRAWSURFACE_LCL   surf_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   surf)
{
    DWORD   caps = surf_lcl->ddsCaps.dwCaps;

    //
    // check for no caps at all!
    //
    if( caps == 0 )
    {
    	DPF_ERR( "no caps specified" );
        return DDERR_INVALIDCAPS;
    }

    //
    // check for bogus caps.
    //
    if( caps & ~DDSCAPS_VALID )
    {
        DPF_ERR( "Create surface: invalid caps specified" );
        return DDERR_INVALIDCAPS;
    }

    //
    // Anything other than a texture is not allowed
    // ATTENTION: some more flags need to be checked
    //
    if(caps & (DDSCAPS_EXECUTEBUFFER      |
               DDSCAPS_BACKBUFFER         |
               DDSCAPS_FRONTBUFFER        |
               DDSCAPS_OFFSCREENPLAIN     |
               DDSCAPS_PRIMARYSURFACE     |
               DDSCAPS_PRIMARYSURFACELEFT |
               DDSCAPS_VIDEOPORT          |
               DDSCAPS_ZBUFFER            |
               DDSCAPS_OWNDC              |
               DDSCAPS_OVERLAY            |
               DDSCAPS_3DDEVICE           |
               DDSCAPS_ALLOCONLOAD)
        )
    {
        DPF_ERR( "currently only textures can be optimized" );
        return DDERR_INVALIDCAPS;
    }

    if( !(caps & DDSCAPS_TEXTURE) )
    {
        DPF_ERR( "DDSCAPS_TEXTURE needs to be set" );
        return DDERR_INVALIDCAPS;
    }

    return DD_OK;
}

//-------------------------------------------------------------------------------
//
// LoadUnoptimizedSurf method of IDirectDrawOptSurface
//
// Load an unoptimized surface. This is a way to optimize a surface.
//
// The Surface's PIXELFORMAT will be that of the pDDSSrc in case the call
// succeeds.
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_OptSurface_LoadUnoptimizedSurf(
    LPDIRECTDRAWSURFACE pDDS,
    LPDIRECTDRAWSURFACE pDDSSrc)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DDRAWSURFACE_INT   src_int;
    LPDDRAWI_DDRAWSURFACE_LCL   src_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   src;
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    HRESULT                     ddrval = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_OptSurface_LoadUnoptimizedSurf");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        src_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDSSrc;
        if( !VALID_DIRECTDRAWSURFACE_PTR( src_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        src_lcl = src_int->lpLcl;
        if( SURFACE_LOST( src_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
        src = src_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    //ATTENTION: Should src be AddRef'd ?

    //
    // Quit with error if:
    // 1) No hardware
    // 2) Hardware doesnt support optimized surfaces
    // 3) Surface is an unoptimized surface
    // 4) Src is an optimized surface
    // 5) Current surface is not empty (should we enforce it, or let the driver
    //    deal with it ?)
    // 6) The surface is not the "right" type
    // 7) The driver fails for some reason
    //

    // DDraw Gbl pointer
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

    // 1)
    if( pdrv->dwFlags & DDRAWI_NOHARDWARE )
    {
        DPF_ERR ("No hardware present");
        LEAVE_DDRAW();
        return DDERR_NODIRECTDRAWHW;
    }

    // 2)
    if ((0 == pdrv->lpDDOptSurfaceInfo) ||
        !(pdrv->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        DPF_ERR ("Optimized surfaces not supported");
        LEAVE_DDRAW();
        return DDERR_NOOPTSURFACESUPPORT;
    }

    // 3)
    if (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        DPF_ERR ("Current surface is not an optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANOPTIMIZEDSURFACE;
    }

    // 4)
    if (src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
    {
        DPF_ERR ("Source surface is an optimized surface");
        LEAVE_DDRAW();
        return DDERR_ISOPTIMIZEDSURFACE;
    }

    // 5)
    if (!(this_lcl->dwFlags & DDRAWISURF_EMPTYSURFACE))
    {
        DPF_ERR ("Current surface is not an empty optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANEMPTYOPTIMIZEDSURFACE;
    }

    // 6)
    ddrval = FilterSurfCaps (src_lcl, src);
    if (ddrval != DD_OK)
    {
        DPF_ERR ("Source surface cannot be optimized");
        LEAVE_DDRAW();
        return DDERR_NOTANEMPTYOPTIMIZEDSURFACE;
    }

    // Now attempt the actual load
    ddrval = DoLoadUnOptSurf (this_lcl, this, src_lcl, src);

    LEAVE_DDRAW();
    return ddrval;
}

//-------------------------------------------------------------------------------
//
// DoCopyOptSurf
//
// Actually make the HAL call and update data-structures if the call
// succeeds.
//
//-------------------------------------------------------------------------------
HRESULT
DoCopyOptSurf(
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   this,
    LPDDRAWI_DDRAWSURFACE_LCL   src_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   src
    )
{
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    DDHAL_COPYOPTSURFACEDATA    ddhal_cosd;
    LPDDOPTSURFACEINFO    pDDOptSurfInfo = NULL;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE this_gbl_more, src_gbl_more;
    HRESULT ddrval = DD_OK;

    // Get the ddraw pointers
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;
    pDDOptSurfInfo = pdrv->lpDDOptSurfaceInfo;

    // Setup data to pass to the driver
    ZeroMemory (&ddhal_cosd, sizeof (DDHAL_COPYOPTSURFACEDATA));
    ddhal_cosd.lpDD      = pdrv_lcl;
    ddhal_cosd.lpDDSSrc  = src_lcl;
    ddhal_cosd.lpDDSDest = this_lcl;

    DOHALCALL(CopyOptSurface, pDDOptSurfInfo->CopyOptSurface, ddhal_cosd, ddrval, FALSE );

    // If the driver call succeeds, then copy the surface description and
    // pixel format etc.
    if (ddrval != DD_OK)
    {
        DPF_ERR ("CopyOptSurface failed in the driver");
        return ddrval;
    }

    // ATTENTION: Should the driver do these updates ?

    // 1) Update the DDRAWI_DDRAWSURFACE_LCL structure
    //    Color key stuff is ignored for now
    this_lcl->dwFlags = src_lcl->dwFlags;
    this_lcl->ddsCaps = src_lcl->ddsCaps;
#ifdef WIN95
    this_lcl->dwModeCreatedIn = src_lcl->dwModeCreatedIn;
#else
    this_lcl->dmiCreated = src_lcl->dmiCreated;
#endif
    this_lcl->dwBackBufferCount = src_lcl->dwBackBufferCount;

    // 2) Update the DDRAWI_DDRAWSURFACE_MORE structure
    this_lcl->lpSurfMore->dwMipMapCount = src_lcl->lpSurfMore->dwMipMapCount;
    this_lcl->lpSurfMore->ddsCapsEx = src_lcl->lpSurfMore->ddsCapsEx;

    // 3) Update the DDRAWI_DDRAWSURFACE_GBL structure
    this->dwGlobalFlags = src->dwGlobalFlags;
    this->wHeight = src->wHeight;
    this->wWidth = src->wWidth;
    this->ddpfSurface = src->ddpfSurface;

    // 4) Update the DDRAWI_DDRAWSURFACE_GBL_MORE structure
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE (this);
    src_gbl_more  = GET_LPDDRAWSURFACE_GBL_MORE (src);

    this_gbl_more->dwContentsStamp = src_gbl_more->dwContentsStamp;
    CopyMemory (this_gbl_more->lpDDOptSurfaceDesc,
                src_gbl_more->lpDDOptSurfaceDesc,
                sizeof (DDOPTSURFACEDESC));

    return ddrval;
}

//-------------------------------------------------------------------------------
//
// CopyOptimizedSurf method of IDirectDrawOptSurface
//
// Copy an optimized surface.
//
// The Surface's PIXELFORMAT will be that of the pDDSSrc in case the call
// succeeds.
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_OptSurface_CopyOptimizedSurf(
    LPDIRECTDRAWSURFACE pDDS,
    LPDIRECTDRAWSURFACE pDDSSrc)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DDRAWSURFACE_INT   src_int;
    LPDDRAWI_DDRAWSURFACE_LCL   src_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   src;
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    HRESULT                     ddrval = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_OptSurface_CopyOptimizedSurf");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        src_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDSSrc;
        if( !VALID_DIRECTDRAWSURFACE_PTR( src_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        src_lcl = src_int->lpLcl;
        src = src_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    //ATTENTION: Should src be AddRef'd ?

    //
    // Quit with error if:
    // 1) No hardware
    // 2) Hardware doesnt support optimized surfaces
    // 3) Surface is an unoptimized surface
    // 4) Src is an unoptimized surface
    // 5) Src is an empty optimized surface
    // 6) Current surface is not empty (should we enforce it, or let the driver
    //    deal with it ?)
    // 7) The driver fails for some reason
    //

    // DDraw Gbl pointer
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

    // 1)
    if( pdrv->dwFlags & DDRAWI_NOHARDWARE )
    {
        DPF_ERR ("No hardware present");
        LEAVE_DDRAW();
        return DDERR_NODIRECTDRAWHW;
    }

    // 2)
    if ((0 == pdrv->lpDDOptSurfaceInfo) ||
        !(pdrv->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        DPF_ERR ("Optimized surfaces not supported");
        LEAVE_DDRAW();
        return DDERR_NOOPTSURFACESUPPORT;
    }

    // 3)
    if (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        DPF_ERR ("Current surface is not an optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANOPTIMIZEDSURFACE;
    }

    // 4)
    if (!(src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        DPF_ERR ("Source surface is not an optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANOPTIMIZEDSURFACE;
    }

    // 5)
    if (src_lcl->dwFlags & DDRAWISURF_EMPTYSURFACE)
    {
        DPF_ERR ("Source surface is an empty optimized surface");
        LEAVE_DDRAW();
        return DDERR_ISANEMPTYOPTIMIZEDSURFACE;
    }

    // 6)
    if (!(this_lcl->dwFlags & DDRAWISURF_EMPTYSURFACE))
    {
        DPF_ERR ("Current surface is not an empty optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANEMPTYOPTIMIZEDSURFACE;
    }

    // Now attempt the actual copy
    ddrval = DoCopyOptSurf (this_lcl, this, src_lcl, src);

    LEAVE_DDRAW();
    return ddrval;
}

//-------------------------------------------------------------------------------
//
// DoUnOptimize
//
// Actually make the HAL call and update data-structures if the call
// succeeds.
//
//-------------------------------------------------------------------------------
HRESULT
DoUnOptimize(
    LPDDSURFACEDESC2            pSurfDesc,
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl,
    LPDDRAWI_DDRAWSURFACE_GBL   this,
    LPDIRECTDRAWSURFACE FAR    *ppDDSDest
    )
{
    LPDDRAWI_DIRECTDRAW_INT	    pdrv_int;
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL	new_surf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	new_surf_int;
    LPDDRAWI_DDRAWSURFACE_GBL	new_surf;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE new_surf_gbl_more;
    DDPIXELFORMAT               ddpf;
    DDSCAPS                     caps;
    DDHAL_UNOPTIMIZESURFACEDATA ddhal_uosd;
    LPDDOPTSURFACEINFO          pDDOptSurfInfo = NULL;
    LPDDRAWI_DDRAWSURFACE_INT	pSurf_int, prev_int;
    HRESULT ddrval = DD_OK;

    // Get the ddraw pointers
	pdrv_int = this_lcl->lpSurfMore->lpDD_int;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

    //
    // Fix the caps
    //
    ZeroMemory (&caps, sizeof (DDSCAPS));
    if (pSurfDesc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        caps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
    if (pSurfDesc->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        caps.dwCaps |= DDSCAPS_VIDEOMEMORY;
    if (pSurfDesc->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
        caps.dwCaps |= DDSCAPS_LOCALVIDMEM;
    if (pSurfDesc->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        caps.dwCaps |= DDSCAPS_NONLOCALVIDMEM;

    // Quit if the memory type is not supported
    if (caps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        if (!(pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM))
        {
            DPF_ERR( "Driver does not support non-local video memory" );
            return DDERR_NONONLOCALVIDMEM;
        }
    }

#if 0
    // Quit if textures are not supported
    if (!(pdrv->ddCaps.dwCaps & DDCAPS_TEXTURE))
    {
        DPF_ERR( "Driver does not support textures" );
        return DDERR_NOTEXTUREHW;
    }
#endif

    //
    // PixelFormat: Mark it as an empty surface
    //
    ZeroMemory (&ddpf, sizeof (ddpf));
    ddpf.dwSize = sizeof (ddpf);
    ddpf.dwFlags = DDPF_EMPTYSURFACE;

    // Make a new uninitialized surface
    ddrval = CreateAndLinkUnintializedSurface (pdrv_lcl, pdrv_int, ppDDSDest);
    if (ddrval != DD_OK)
    {
        DPF_ERR ("createAndLinkUnintializedSurface failed");
        return ddrval;
    }

    //
    // 1) Update GBL_MORE structure
    //
    new_surf_int = (LPDDRAWI_DDRAWSURFACE_INT)*ppDDSDest;
    new_surf_lcl = new_surf_int->lpLcl;
    new_surf     = new_surf_lcl->lpGbl;
    new_surf_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE (new_surf);
    // Init the contents stamp to 0 means the surface's contents can
    // change at any time.
    new_surf_gbl_more->dwContentsStamp = 0;

    //
    // 2) Update DDRAWI_DDRAWSURFACE_GBL structure
    //
    new_surf->ddpfSurface = this->ddpfSurface;

    //
    // 3) Update DDRAWI_DDRAWSURFACE_INT structure
    //
    new_surf_int->lpVtbl = &ddSurface4Callbacks;

    //
    // 4) Update DDRAWI_DDRAWSURFACE_LCL structure
    //

    // Flag it as an:
    // 1) empty surface
    // 2) Front surface
    // 3) Has a pixelformat
    new_surf_lcl->dwFlags = (DDRAWISURF_EMPTYSURFACE |
                             DDRAWISURF_FRONTBUFFER  |
                             DDRAWISURF_HASPIXELFORMAT);
    // fill in the current caps
    new_surf_lcl->ddsCaps = caps;


    // Try the unoptimize
    pDDOptSurfInfo = pdrv->lpDDOptSurfaceInfo;

    // Setup data to pass to the driver
    ZeroMemory (&ddhal_uosd, sizeof (DDHAL_UNOPTIMIZESURFACEDATA));
    ddhal_uosd.lpDD      = pdrv_lcl;
    ddhal_uosd.lpDDSSrc  = this_lcl;
    ddhal_uosd.lpDDSDest = new_surf_lcl;

    DOHALCALL(UnOptimizeSurface, pDDOptSurfInfo->UnOptimizeSurface, ddhal_uosd, ddrval, FALSE );

    if (ddrval == DD_OK)
    {
        return DD_OK;
    }

    // If there was an error, then destroy the surface
    // Since it is an empty surface, all we need to do is:
    //   i) unlink the surface from the ddraw-chain
    //  ii) on NT, inform the kernel
    // iii) free all the allocated memory

    // i)
    prev_int = NULL;
    pSurf_int = pdrv->dsList;
    while ((pSurf_int != NULL) && (pSurf_int != new_surf_int))
    {
        prev_int = pSurf_int;
        pSurf_int = pSurf_int->lpLink;
    }
    if (pSurf_int == new_surf_int)
    {
        prev_int->lpLink = new_surf_int->lpLink;
    }

    // ii)
#ifdef WINNT
    DPF(8,"Attempting to destroy NT kernel mode surface object");

    if (!DdDeleteSurfaceObject (new_surf_lcl))
    {
        DPF_ERR("NT kernel mode stuff won't delete its surface object!");
        ddrval = DDERR_GENERIC;
    }
#endif

    // iii)
    MemFree (new_surf_lcl);

    return ddrval;
}

//-------------------------------------------------------------------------------
//
// Unoptimize method of IDirectDrawOptSurface
//
// Unoptimize an optimized surface. In doing so, it creates a new surface.
//
// The pDDSDest surface's PIXELFORMAT will be that of the pDDS in case the call
// succeeds. This means that the pixelformat of the original surface that was
// loaded is restored.
//
//-------------------------------------------------------------------------------
HRESULT
EXTERN_DDAPI
DD_OptSurface_Unoptimize(
    LPDIRECTDRAWSURFACE pDDS,
    LPDDSURFACEDESC2    pSurfDesc,
    LPDIRECTDRAWSURFACE FAR *ppDDSDest,
    IUnknown FAR *pUnkOuter)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DIRECTDRAW_LCL	    pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	    pdrv;
    HRESULT                     ddrval = DD_OK;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_OptSurface_Unoptimize");

    TRY
    {
        if( !VALID_DDSURFACEDESC2_PTR( pSurfDesc ) )
        {
            DPF_ERR( "Invalid surface description. Did you set the dwSize member?" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }

        this_int = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        if( !VALID_PTR_PTR( ppDDSDest ) )
        {
            DPF_ERR( "Invalid dest. surface pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        *ppDDSDest = NULL;

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    //
    // Quit with error if:
    // 0) pSurfaceDesc not understood
    // 1) No hardware
    // 2) Hardware doesnt support optimized surfaces
    // 3) Surface is an unoptimized surface
    // 4) Surface is an empty optimized surface
    // 5) The driver fails for some reason
    //

    // DDraw Gbl pointer
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv = pdrv_lcl->lpGbl;

    // 0)
    if (pSurfDesc->ddsCaps.dwCaps & ~(DDSCAPS_SYSTEMMEMORY |
                                      DDSCAPS_VIDEOMEMORY |
                                      DDSCAPS_NONLOCALVIDMEM |
                                      DDSCAPS_LOCALVIDMEM))
    {
        DPF_ERR ("Invalid flags");
        LEAVE_DDRAW();
        return DDERR_INVALIDCAPS;
    }

    // 1)
    if( pdrv->dwFlags & DDRAWI_NOHARDWARE )
    {
        DPF_ERR ("No hardware present");
        LEAVE_DDRAW();
        return DDERR_NODIRECTDRAWHW;
    }

    // 2)
    if ((0 == pdrv->lpDDOptSurfaceInfo) ||
        !(pdrv->ddCaps.dwCaps2 & DDCAPS2_OPTIMIZEDSURFACES))
    {
        DPF_ERR ("Optimized surfaces not supported");
        LEAVE_DDRAW();
        return DDERR_NOOPTSURFACESUPPORT;
    }

    // 3)
    if (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        DPF_ERR ("Current surface is not an optimized surface");
        LEAVE_DDRAW();
        return DDERR_NOTANOPTIMIZEDSURFACE;
    }

    // 4)
    if (this_lcl->dwFlags & DDRAWISURF_EMPTYSURFACE)
    {
        DPF_ERR ("Current surface is an empty optimized surface");
        LEAVE_DDRAW();
        return DDERR_ISANEMPTYOPTIMIZEDSURFACE;
    }

    // Do the actual unoptimize
    ddrval = DoUnOptimize (pSurfDesc, this_lcl, this, ppDDSDest);

    LEAVE_DDRAW();
    return ddrval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddrawpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawpr.h
 *  Content:    DirectDraw private header file
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   25-dec-94  craige  initial implementation
 *   06-jan-95  craige  video memory manager
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   31-jan-95  craige  and even more ongoing work...
 *   22-feb-95  craige  use critical sections on Win95
 *   27-feb-95  craige  new sync. macros
 *   03-mar-95  craige  WaitForVerticalBlank stuff
 *   06-mar-95  craige  HEL integration
 *   08-mar-95  craige  GetFourCCCodes
 *   11-mar-95  craige  palette stuff
 *   19-mar-95  craige  use HRESULTs
 *   20-mar-95  craige  new CSECT work
 *   23-mar-95  craige  attachment work
 *   26-mar-95  craige  added TMPALLOC and TMPFREE
 *   27-mar-95  craige  linear or rectangular vidmem
 *   28-mar-95  craige  switched to PALETTEENTRY from RGBQUAD
 *   29-mar-95  craige  debug memory manager; build.h; hacks for DLL
 *                      unload problem...
 *   31-mar-95  craige  use critical sections with palettes
 *   03-apr-95  craige  added MAKE_SURF_RECT
 *   04-apr-95  craige  added DD_GetPaletteEntries, DD_SetPaletteEntries
 *   06-apr-95  craige  split out process list stuff; fill in free vidmem
 *   12-apr-95  craige  add debugging to CSECT macros
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   14-may-95  craige  added DoneExclusiveMode, DD16_EnableReboot; cleaned out
 *                      obsolete junk
 *   23-may-95  craige  no longer use MapLS_Pool; added Flush, GetBatchLimit
 *                      and SetBatchLimit
 *   24-may-95  craige  added Restore
 *   28-may-95  craige  unicode support; cleaned up HAL: added GetBltStatus;
 *                      GetFlipStatus; GetScanLine
 *   02-jun-95  craige  added SetDisplayMode
 *   04-jun-95  craige  added AllocSurfaceMem, IsLost
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   06-jun-95  craige  added RestoreDisplayMode
 *   07-jun-95  craige  added StartExclusiveMode
 *   10-jun-95  craige  split out vmemmgr stuff
 *   13-jun-95  kylej   move FindAttachedFlip to misc.c, added CanBeFlippable
 *   18-jun-95  craige  specify pitch for rectangular heaps
 *   20-jun-95  craige  added DD16_InquireVisRgn; make retail builds
 *                      not bother to check for NULL (since there are 4
 *                      billion other invalid ptrs we don't check for...)
 *   21-jun-95  craige  new clipper stuff
 *   23-jun-95  craige  ATTACHED_PROCESSES stuff
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  replaced batch limit/flush stuff with BltBatch
 *   30-jun-95  kylej   function prototypes to support mult. prim. surfaces
 *   30-jun-95  craige  changed GET_PIXEL_FORMAT to use HASPIXELFORMAT flag
 *   01-jul-95  craige  hide composition & streaming stuff
 *   02-jul-95  craige  SEH macros; added DD16_ChangeDisplaySettings
 *   03-jul-95  kylej   Changed EnumSurfaces declaration
 *   03-jul-95  craige  YEEHAW: new driver struct; Removed GetProcessPrimary
 *   05-jul-95  craige  added Initialize fn to each object
 *   07-jul-95  craige  added some VALIDEX_xxx structs
 *   07-jul-95  kylej   proto XformRect, STRETCH_X and STRETCH_Y macros
 *   08-jul-95  craige  added FindProcessDDObject; added InvalidateAllSurfaces
 *   09-jul-95  craige  added debug output to win16 lock macro; added
 *                      ComputePitch, added hasvram flag to MoveToSystemMemory;
 *                      changed SetExclusiveMode to SetCooperativeLevel;
 *                      added ChangeToSoftwareColorKey
 *   10-jul-95  craige  support SetOverlayPosition
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock;
 *                      Get/SetOverlayPosition takes LONGs
 *   13-jul-95  toddla  remove _export from thunk functions
 *   18-jul-95  craige  removed DD_Surface_Flush
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   28-jul-95  craige  go back to private DDRAW lock
 *   31-jul-95  craige  added DCIIsBanked
 *   01-aug-95  craige  added ENTER/LEAVE_BOTH; DOHALCALL_NOWIN16
 *   04-aug-95  craige  added InternalLock/Unlock
 *   10-aug-95  toddla  changed proto of EnumDisplayModes
 *   10-aug-95  toddla  added VALIDEX_DDSURFACEDESC_PTR
 *   12-aug-95  craige  added use_full_lock parm to MoveToSystemMemory and
 *                      ChangeToSoftwareColorKey
 *   13-aug-95  craige  flags parm for Flip
 *   21-aug-95  craige  mode X support
 *   27-aug-95  craige  bug 735: added SetPaletteAlways
 *                      bug 738: use GUID instead of IID
 *   02-sep-95  craige  bug 786: verify dwSize in retail
 *   04-sep-95  craige  bug 894: force flag to SetDisplayMode
 *   10-sep-95  toddla  added string ids
 *   21-sep-95  craige  bug 1215: added DD16_SetCertified
 *   11-nov-95  colinmc added new pointer validition macro for byte arrays
 *   27-nov-95  colinmc new member to return available vram of a given type
 *                      (defined by DDSCAPS)
 *   10-dec-95  colinmc added execute buffer support
 *   14-dec-95  colinmc added shared back and z-buffer support
 *   25-dec-95  craige  added class factory support
 *   31-dec-95  craige  added VALID_IID_PTR
 *   26-jan-96  jeffno  FlipToGDISurface now only takes 1 arg
 *   09-feb-96  colinmc local surface objects now have invalid surface flag
 *   12-feb-96  jeffno  Cheaper Mutex implementation for NT
 *   15-feb-96  jeffno  GETCURRENTPID needs to call HackCurrentPID on both 95 and NT
 *   17-feb-96  colinmc Removed dependency on Direct3D include files
 *   24-feb-96  colinmc Added prototype for new member which is used to
 *                      determine if the callback tables have already been
 *                      initialized.
 *   02-mar-96  colinmc Simply disgusting and temporary hack to keep
 *                      interim drivers working
 *   14-mar-96  colinmc Changes for the clipper class factory
 *   17-mar-96  colinmc Bug 13124: flippable mip-maps
 *   20-mar-96  colinmc Bug 13634: unidirectional attachments cause infinite
 *                      loop on cleanup
 *   22-mar-96  colinmc Bug 13316: Uninitialized interfaces
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   10-apr-96  colinmc Bug 16903: HEL using obsolete FindProcessDDObject
 *   13-apr-96  colinmc Bug 17736: No driver notifcation of flip to GDI
 *   15-apr-96  colinmc Bug 16885: Can't pass NULL to initialize in C++
 *   16-apr-96  colinmc Bug 17921: Remove interim driver support
 *   26-mar-96  jeffno  Removed cheap mutexes. Added check for mode change for NT's
 *                      ENTERDDRAW.
 *   29-apr-96  colinmc Bug 19954: Must query for Direct3D before texture or
 *                      device interface
 *   11-may-96  colinmc Bug 22293: New macro to validate GUID even if not
 *                      in debug
 *   17-may-96  kylej   Bug 23301: validate DDHALINFO size >= current size
 *   28-jul-96  colinmc Bug 2613:  Minimal support for secondary (stacked)
 *                                 drivers.
 *   16-aug-96  craige  include ddreg.h, added dwRegFlags + flag defns
 *   03-sep-96  craige  added app compat stuff.
 *   23-sep-96  ketand  added InternalGetClipList
 *   01-oct-96  ketand  added TIMING routings
 *   05-oct-96  colinmc Work Item: Remove requirement on taking Win16 lock
 *                      for VRAM surfaces (not primary)
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   09-nov-96  colinmc Fixed problem with old and new drivers not working
 *                      with DirectDraw
 *   17-nov-96  colinmc New ref flag to control the enabling and disabling
 *                      of PrintScreen
 *   02-jan-97  colinmc Initial AGP implementation work
 *   12-jan-97  colinmc More Win16 lock work
 *   13-jan-97 jvanaken Basic support for IDirectDrawSurface3 interface
 *   18-jan-97  colinmc AGP VMM support
 *   21-jan-97  ketand  Change DD16_SetPaletteEntries for multi-mon. Deleted
 *                      unused code.
 *   26-jan-97  ketand  Remove unused DD16_GetPaletteEntries. (It didn't handle
 *                      multi-mon; and wasn't worth fixing.) Also, remove
 *                      globals that don't work anymore with multi-mon.
 *   30-jan-97  colinmc Work item 4125: Need time bomb for final
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   02-feb-97  toddla  pass driver name to DD16_GetMonitor functions
 *                      added DD16_GetDeviceConfig
 *   02-feb-97  colinmc Bug 5625: V1.0 DirectX drivers don't get recognized
 *                      due to bad size check on DDCALLBACKS
 *   05-feb-97  ketand  Remove unused parameter from ClipRgnToRect
 *   22-feb-97  colinmc Enabled OWNDC for explicit system memory surfaces
 *   03-mar-97  smac    Added kernel mode interface
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   04-mar-97  ketand  Added UpdateOutstandingDC to track palette changes
 *   08-mar-97  colinmc Added support for DMA style AGP parts
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   22-mar-97  colinmc Bug 6673: Add compile time option to allow new
 *                      applications to run against legacy run times.
 *   23-mar-97  colinmc Bug 6673 again: Changed structure numbering scheme
 *                      for consistency's sake
 *   24-mar-97  jeffno  Optimized Surfaces
 *   07-may-97  colinmc Moved AGP support detection from misc.c to ddagp.c
 *   30-sep-97  jeffno  IDirectDraw4
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   26-nov-97 t-craigs Added IDirectDrawPalette2
 *   19-dec-97 jvanaken IDDS4::Unlock now takes a pointer to a rectangle.
 *
 ***************************************************************************/

#ifndef __DDRAWPR_INCLUDED__
#define __DDRAWPR_INCLUDED__

#ifdef WIN95

#ifdef WINNT
#undef WINNT
#endif

#endif

#ifndef WIN95
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#endif

#ifdef WIN95
    #define WIN16_SEPARATE
#endif
#include "verinfo.h"

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <mmsystem.h>

#if defined( WIN95 ) && !defined ( NT_BUILD_ENVIRONMENT )
#undef PBT_APMRESUMEAUTOMATIC
    #include <pbt.h>
#endif

//#ifdef NT_BUILD_ENVIRONMENT
    /*
     * These are various definitions brought over from the win95 world, just to get us
     * compiling under the NT headers.
     */
    #ifdef WIN32
        /*
         * These come from \proj\dev\sdk\inc\winbase.h
         */
        #define FILE_FLAG_GLOBAL_HANDLE         0x00800000  // ;internal
        VOID    // ;internal
        WINAPI  // ;internal
        ReinitializeCriticalSection(    // ;internal
            LPCRITICAL_SECTION lpCriticalSection        // ;internal
            );  // ;internal

       //
       // Windows 9x stuff
       //

       #define CDS_EXCLUSIVE       0x80000000
       #define DISPLAY_DEVICE_VGA  0x00000010
       #define DCX_USESTYLE        0x00010000

    #endif //IS_32


    /*
     * These two come from \proj\dev\msdev\include\pbt.h
     */
    #define PBT_APMSUSPEND                  0x0004
    #define PBT_APMSTANDBY                  0x0005

//#endif //NT_BUILD_ENVIRONMENT

#include <string.h>
#include <stddef.h>

#if defined( IS_32 ) || defined( WIN32 ) || defined( _WIN32 )
    #undef IS_32
    #define IS_32
    #pragma pack(1)
    #include <dibeng.inc>
    #pragma pack()
    #ifndef HARDWARECURSOR
        //#pragma message("defining local version of HARDWARECURSOR")
        #define HARDWARECURSOR 0x0100 // new post-Win95 deFlag
    #endif
#else
    #define IID void
#endif

#pragma warning( disable: 4704)

#include "dpf.h"

/*
 * registry stuff
 */
#include "ddreg.h"

/*
 * application compat. stuff
 */
#define DDRAW_APPCOMPAT_MODEXONLY           0x00000001l
#define DDRAW_APPCOMPAT_NODDSCAPSINDDSD     0x00000002l
#define DDRAW_APPCOMPAT_MMXFORRGB           0x00000004l
#define DDRAW_APPCOMPAT_EXPLICITMONITOR     0x00000008l
#define DDRAW_APPCOMPAT_SCREENSAVER         0x00000010l
#define DDRAW_APPCOMPAT_FORCEMODULATED      0x00000020l
#define DDRAW_APPCOMPAT_TEXENUMINCL_0       0x00000040l  // two bit field
#define DDRAW_APPCOMPAT_TEXENUMINCL_1       0x00000080l
#define DDRAW_APPCOMPAT_TEXENUMLIMIT        0x00000100l
#define DDRAW_APPCOMPAT_SKIPWHEELMSG        0x00000200l // Win98 only
#define DDRAW_APPCOMPAT_TEXENUMDX7FOURCC    0x00000400l
#define DDRAW_APPCOMPAT_VALID               0x000007ffl

#define DDRAW_REGFLAGS_MODEXONLY        0x00000001l
#define DDRAW_REGFLAGS_EMULATIONONLY    0x00000002l
#define DDRAW_REGFLAGS_SHOWFRAMERATE    0x00000004l
#define DDRAW_REGFLAGS_ENABLEPRINTSCRN  0x00000008l
#define DDRAW_REGFLAGS_FORCEAGPSUPPORT  0x00000010l
#define DDRAW_REGFLAGS_DISABLEMMX       0x00000020l
#define DDRAW_REGFLAGS_DISABLEWIDESURF  0x00000040l
#define DDRAW_REGFLAGS_AGPPOLICYMAXBYTES 0x00000200l
#define DDRAW_REGFLAGS_FORCEREFRESHRATE 0x00008000l
#ifdef DEBUG
    #define DDRAW_REGFLAGS_DISABLENOSYSLOCK  0x00000080l
    #define DDRAW_REGFLAGS_FORCENOSYSLOCK    0x00000100l
#endif
#define DDRAW_REGFLAGS_NODDSCAPSINDDSD  0x00000400l
#define DDRAW_REGFLAGS_DISABLEAGPSUPPORT 0x00000800l
#ifdef DEBUG
    #define DDRAW_REGFLAGS_DISABLEINACTIVATE 0x00001000l
    #define DDRAW_REGFLAGS_PREGUARD          0x00002000l
    #define DDRAW_REGFLAGS_POSTGUARD         0x00004000l
#endif
#define DDRAW_REGFLAGS_USENONLOCALVIDMEM    0x00010000l

#define DDRAW_REGFLAGS_ENUMERATEATTACHEDSECONDARIES 0x00008000l
#define DDRAW_REGFLAGS_FLIPNONVSYNC         0x00020000l

extern  DWORD dwRegFlags;

#include "memalloc.h"

#if defined( IS_32 ) || defined( WIN32 ) || defined( _WIN32 )
    #include <objbase.h>
#else
    #define IUnknown void
#endif
#include "ddrawi.h"
#include "dwininfo.h"

#ifdef WIN95
    #include "..\ddraw16\modex.h"
#endif

/*
 * Need this to get CDS_ macros under NT build environment for win95.
 * winuserp.h comes from private\windows\inc
 */
#ifdef NT_BUILD_ENVIRONMENT
    #ifdef WIN32
        #include "winuserp.h"
    #endif
#endif
#include "ids.h"

/*
 * NT kernel mode stub(ish)s
 */
#ifndef WIN95
    #include "ddrawgdi.h"
#endif

/*
 * Driver version info
 */

//========================================================================
// advanced driver information
//========================================================================
typedef struct tagDDDRIVERINFOEX
{
        DDDEVICEIDENTIFIER      di;
        char                    szDeviceID[MAX_DDDEVICEID_STRING];
} DDDRIVERINFOEX, * LPDDDRIVERINFOEX;



/*
 * Direct3D interfacing defines.
 */
#ifndef NO_D3D
#include "ddd3dapi.h"
#endif
#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN95
    #define USE_CRITSECTS
    extern void DDAPI DD16_SetEventHandle( DWORD hInstance, DWORD dwEvent );
    extern void DDAPI DD16_DoneDriver( DWORD hInstance );
    extern void DDAPI DD16_GetDriverFns( LPDDHALDDRAWFNS list );
    extern void DDAPI DD16_GetHALInfo( LPDDHALINFO pinfo );
    extern LONG DDAPI DD16_ChangeDisplaySettings( LPDEVMODE pdm, DWORD flags);
    extern HRGN DDAPI DD16_InquireVisRgn( HDC );
    extern void DDAPI DD16_SelectPalette( HDC, HPALETTE, BOOL );
    extern BOOL DDAPI DD16_SetPaletteEntries( HDC hdc, DWORD dwBase, DWORD dwNum, LPPALETTEENTRY, BOOL fPrimary );
    extern void DDAPI DD16_EnableReboot( BOOL );
    extern void DDAPI DD16_SetCertified( BOOL iscert );
    extern BOOL DDAPI DCIIsBanked( HDC hdc );
    #define GETCURRPID HackGetCurrentProcessId
    VOID WINAPI MakeCriticalSectionGlobal( CSECT_HANDLE lpcsCriticalSection );

    extern HDC  DDAPI DD16_GetDC(HDC hdc, LPDDSURFACEDESC pddsd, LPPALETTEENTRY lpPalette);
    extern void DDAPI DD16_ReleaseDC(HDC hdc);
    extern BOOL DDAPI DD16_SafeMode(HDC hdc, BOOL fSafeMode);

    extern void DDAPI DD16_Exclude(DWORD dwPDevice, RECTL FAR *prcl);
    extern void DDAPI DD16_Unexclude(DWORD dwPDevice);

    extern int DDAPI DD16_Stretch(DWORD DstPtr, int DstPitch, UINT DstBPP, int DstX, int DstY, int DstDX, int DstDY,
                       DWORD SrcPtr, int SrcPitch, UINT SrcBPP, int SrcX, int SrcY, int SrcDX, int SrcDY);
    extern BOOL DDAPI DD16_IsWin95MiniDriver( void );
    extern int  DDAPI DD16_GetMonitorMaxSize(LPSTR szDevice);
    extern BOOL DDAPI DD16_GetMonitorRefreshRateRanges(LPSTR szDevice, int xres, int yres, int FAR *pmin, int FAR *pmax);
    extern DWORD DDAPI DD16_GetDeviceConfig(LPSTR szDevice, LPVOID lpConfig, DWORD size);
    extern BOOL DDAPI DD16_GetMonitorEDIDData(LPSTR szDevice, LPVOID lpEdidData);
    extern DWORD DDAPI DD16_GetRateFromRegistry( LPSTR szDevice );
    extern int DDAPI DD16_SetRateInRegistry( LPSTR szDevice, DWORD dwRateToRestore );

    #ifdef USE_ALIAS
        extern BOOL DDAPI DD16_FixupDIBEngine( void );
    #endif /* USE_ALIAS */
    extern WORD DDAPI DD16_MakeObjectPrivate(HDC hdc, BOOL fPrivate);
    extern BOOL DDAPI DD16_AttemptGamma(HDC hdc);
    extern BOOL DDAPI DD16_IsDeviceBusy(HDC hdc);

#else
    #define DD16_DoneDriver( hInstance ) 0
    #define DD16_GetDriverFns( list ) 0
    #define DD16_GetHALInfo( pinfo ) 0
    #define DD16_ChangeDisplaySettings( pdm, flags) ChangeDisplaySettings( pdm, flags )
    #define DD16_SelectPalette( hdc, hpal ) SelectPalette( hdc, hpal, FALSE )
    #define DD16_EnableReboot( retboot ) 0
    #define DD16_WWOpen( ptr ) 0
    #define DD16_WWClose( ptr, newlist ) 0
    #define DD16_WWNotifyInit( pww, lpcallback, param ) 0
    #define DD16_WWGetClipList( pww, prect, rdsize, prd ) 0
    //
    // On NT, it is an assert that we are never called by DDHELP, so we should always be
    // working on the current process.
    //
    #define GETCURRPID GetCurrentProcessId
    #define DCIIsBanked( hdc ) FALSE
    #define DD16_IsWin95MiniDriver() TRUE
    #define DD16_SetCertified( iscert ) 0
    #define DD16_GetMonitorMaxSize(dev) 0
    #define DD16_GetMonitorRefreshRateRanges( dev, xres, yres, pmin, pmax) 0
    #define DD16_GetRateFromRegistry( szDevice ) 0
    #define DD16_SetRateInRegistry( szDevice, dwRateToRestore ) 0
    #ifdef USE_ALIAS
        #define DD16_FixupDIBEngine() TRUE
    #endif /* USE_ALIAS */
    #define DD16_AttemptGamma( hdc) 0
    #define DD16_IsDeviceBusy( hdc) 0
#endif

#ifndef NO_DDHELP
    #include "w95help.h"
#endif //NO_DDHELP

#define TRY             _try
#define EXCEPT(a)       _except( a )

extern LPDDRAWI_DDRAWCLIPPER_INT lpGlobalClipperList;

/*
 * list of processes attached to DLL
 */
typedef struct ATTACHED_PROCESSES
{
    struct ATTACHED_PROCESSES   *lpLink;
    DWORD                       dwPid;
#ifdef WINNT
    DWORD                       dwNTToldYet;
#endif
} ATTACHED_PROCESSES, FAR *LPATTACHED_PROCESSES;

//extern LPATTACHED_PROCESSES   lpAttachedProcesses;

/* Structure for keeping track of DCs that have
 * been handed out by DDraw for surfaces.
 */
typedef struct _dcinfo
{
    HDC hdc;                            // HDC associated with surface
    LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl; // Surface associated with HDC
    struct _dcinfo * pdcinfoNext;       // Pointer to next
} DCINFO, *LPDCINFO;
/*
 *  Head of the list of DCs handed out.
 */
extern DCINFO *g_pdcinfoHead;

/*
 * macros for doing allocations of a temporary basis.
 * Tries alloca first, if that fails, it will allocate storage from the heap
 */
#ifdef USEALLOCA
    #define TMPALLOC( ptr, size ) \
            ptr = _alloca( (size)+sizeof( DWORD ) ); \
            if( ptr == NULL ) \
            { \
                ptr = MemAlloc( (size)+sizeof( DWORD ) ); \
                if( ptr != NULL ) \
                { \
                    *(DWORD *)ptr = 1; \
                    (LPSTR) ptr += sizeof( DWORD ); \
                } \
            } \
            else \
            { \
                *(DWORD *)ptr = 0; \
                (LPSTR) ptr += sizeof( DWORD ); \
            }

    #define TMPFREE( ptr ) \
            if( ptr != NULL ) \
            { \
                (LPSTR) ptr -= sizeof( DWORD ); \
                if( (*(DWORD *) ptr) ) \
                { \
                    MemFree( ptr ); \
                } \
            }
#else

    #define TMPALLOC( ptr, size )  ptr = MemAlloc( size );
    #define TMPFREE( ptr )  MemFree( ptr );

#endif

/*
 * macros for getting at values that aren't always present in the surface
 * object
 */
#define GET_PIXEL_FORMAT( thisx, thisl, pddpf ) \
    if( thisx->dwFlags & DDRAWISURF_HASPIXELFORMAT ) \
    { \
        pddpf = &thisl->ddpfSurface; \
    } \
    else \
    { \
        pddpf = &thisl->lpDD->vmiData.ddpfDisplay; \
    }

/*
 * macro for building a rectangle that is the size of a surface.
 * For multi-monitor systems, we have a different code path
 * to deal with the fact that the upper-left coord may not be zero.
 */
#define MAKE_SURF_RECT( surf, surf_lcl, r ) \
    r.top = 0;                  \
    r.left = 0;                 \
    r.bottom = (DWORD) surf->wHeight; \
    r.right = (DWORD) surf->wWidth;

/*
 * macro for doing doing HAL call.
 *
 * Takes the Win16 lock for 32-bit Win95 driver routines.  This serves a
 * 2-fold purpose:
 *      1) keeps the 16-bit portion of the driver safe
 *      2) 32-bit routine needs lock others out while its updating
 *         its hardware
 */
#if defined( WIN95 ) && defined( WIN16_SEPARATE )
    #define DOHALCALL( halcall, fn, data, rc, isHEL ) \
        if( (fn != _DDHAL_##halcall) && !isHEL ) { \
            ENTER_WIN16LOCK(); \
            rc = fn( &data ); \
            LEAVE_WIN16LOCK(); \
        } else { \
            rc = fn( &data ); \
        }

    #define DOHALCALL_NOWIN16( halcall, fn, data, rc, isHEL ) \
            rc = fn( &data );
#else
    #define DOHALCALL( halcall, fn, data, rc, isHEL ) \
            if (fn) \
                rc = fn( &data );\
            else\
                rc = DDHAL_DRIVER_NOTHANDLED;
    #define DOHALCALL_NOWIN16( halcall, fn, data, rc, isHEL ) \
            if (fn) \
                rc = fn( &data );\
            else\
                rc = DDHAL_DRIVER_NOTHANDLED;
#endif


/*
 * macro for incrementing/decrementing the driver ref count
 */
#define CHANGE_GLOBAL_CNT( pdrv, thisg, cnt ) \
    if( !(thisg->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED) ) \
    { \
        (int) pdrv->dwSurfaceLockCount += (int) (cnt); \
    }


/*
 * reminder
 */
#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str

/*
 * maximum timeout (in ms) when spinlocked on a surface
 */
#define MAX_TIMEOUT     5000

/*
 * defined in dllmain.c
 */
extern CSECT_HANDLE     lpDDCS;
#ifdef WINNT
    extern HANDLE hDriverObjectListMutex;
    extern DWORD dwNumLockedWhenModeSwitched;
#else
    #ifdef IS_32
        extern CRITICAL_SECTION csDriverObjectList;
    #endif
#endif
#define MAX_TIMER_HWNDS 15
extern HWND ghwndTopmostList[MAX_TIMER_HWNDS];
extern int giTopmostCnt;
extern BOOL bGammaCalibratorExists;
extern BYTE szGammaCalibrator[MAX_PATH];
extern DWORD dwForceRefreshRate;

/*
 * blt flags
 */
#define DDBLT_PRIVATE_ALIASPATTERN      0x80000000l

/*
 * get the fail code based on what HAL and HEL support; used by BLT
 *
 * assumes variables halonly, helonly, fail are defined
 */
#define GETFAILCODEBLT( testhal, testhel, halonly, helonly, flag ) \
    if( halonly ) { \
        if( !(testhal & flag) ) { \
            fail = TRUE; \
        } \
    } else if( helonly ) { \
        if( !(testhel & flag) ) { \
            fail = TRUE; \
        } \
    } else { \
        if( !(testhal & flag) ) { \
            if( !(testhel & flag) ) { \
                fail = TRUE; \
            } else { \
                helonly = TRUE; \
            } \
        } else { \
            halonly = TRUE; \
        } \
    }

/*
 * get the fail code based on what HAL and HEL support
 *
 * assumes variables halonly, helonly, fail are defined
 */
#define GETFAILCODE( testhal, testhel, flag ) \
    if( halonly ) \
    { \
        if( !(testhal & flag) ) \
        { \
            fail = TRUE; \
        } \
    } \
    else if( helonly ) \
    { \
        if( !(testhel & flag) ) \
        { \
            fail = TRUE; \
        } \
    } \
    else \
    { \
        if( !(testhal & flag) ) \
        { \
            if( !(testhel & flag) ) \
            { \
                fail = TRUE; \
            } \
            else \
            { \
                helonly = TRUE; \
            } \
        } \
        else \
        { \
            halonly = TRUE; \
        } \
    }


typedef struct {
    DWORD               src_height;
    DWORD               src_width;
    DWORD               dest_height;
    DWORD               dest_width;
    BOOL                halonly;
    BOOL                helonly;
    LPDDHALSURFCB_BLT   bltfn;
    LPDDHALSURFCB_BLT   helbltfn;
} SPECIAL_BLT_DATA, FAR *LPSPECIAL_BLT_DATA;

/*
 * synchronization
 */
#ifdef WINNT
#define RELEASE_EXCLUSIVEMODE_MUTEX                             \
    {                                                           \
        if (hExclusiveModeMutex)                                \
        {                                                       \
            BOOL bSucceed = ReleaseMutex(hExclusiveModeMutex);  \
            if (!bSucceed)                                      \
            {                                                   \
                DPF_ERR("Release Exclusive Mutex Failed. App "  \
                        "should not release Exclusive Mode on " \
                        "different thread than it was taken."); \
            }                                                   \
        }                                                       \
    }
#else
    #define RELEASE_EXCLUSIVEMODE_MUTEX ;
#endif


//--------------------------------- new cheap mutexes -------------------------------------------
//
// Global Critical Sections have two components. One piece is shared between all
// applications using the global lock. This portion will typically reside in some
// sort of shared memory
//
// The second piece is per-process. This contains a per-process handle to the shared
// critical section lock semaphore. The semaphore is itself shared, but each process
// may have a different handle value to the semaphore.
//
// Global critical sections are attached to by name. The application wishing to
// attach must know the name of the critical section (actually the name of the shared
// lock semaphore, and must know the address of the global portion of the critical
// section
//

typedef struct _GLOBAL_SHARED_CRITICAL_SECTION {
    LONG LockCount;
    LONG RecursionCount;
    DWORD OwningThread;
    DWORD OwningProcess;
    DWORD Reserved;
} GLOBAL_SHARED_CRITICAL_SECTION, *PGLOBAL_SHARED_CRITICAL_SECTION;

typedef struct _GLOBAL_LOCAL_CRITICAL_SECTION {
    PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion;
    HANDLE LockSemaphore;
    DWORD Reserved1;
    DWORD Reserved2;
} GLOBAL_LOCAL_CRITICAL_SECTION, *PGLOBAL_LOCAL_CRITICAL_SECTION;

/*
 * The following functions are defined in mutex.c
 */
BOOL
WINAPI
AttachToGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion,
    PGLOBAL_SHARED_CRITICAL_SECTION lpGlobalPortion,
    LPCSTR lpName
    );
BOOL
WINAPI
DetachFromGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
VOID
WINAPI
EnterGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
VOID
WINAPI
LeaveGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    );
void
DestroyPIDsLock(
                PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion,
                DWORD                           dwPid,
                LPSTR                           lpName
    );


#define DDRAW_FAST_CS_NAME "DdrawGlobalFastCrit"
extern GLOBAL_LOCAL_CRITICAL_SECTION CheapMutexPerProcess;
extern GLOBAL_SHARED_CRITICAL_SECTION CheapMutexCrossProcess;

#define CHEAP_LEAVE {LeaveGlobalCriticalSection(&CheapMutexPerProcess);}
#define CHEAP_ENTER {EnterGlobalCriticalSection(&CheapMutexPerProcess);}

#ifdef WINNT
//    #define USE_CHEAP_MUTEX
#define NT_USES_CRITICAL_SECTION
#endif

extern void ModeChangedOnENTERDDRAW(void); // in ddmodent.c
extern ULONG uDisplaySettingsUnique;

//
#ifdef IS_32
    #ifndef USE_CRITSECTS
        #define INIT_DDRAW_CSECT()
        #define FINI_DDRAW_CSECT()
        #define ENTER_DDRAW()
        #define LEAVE_DDRAW()
        #define ENTER_DRIVERLISTCSECT()
        #define LEAVE_DRIVERLISTCSECT()
    #else //so use csects:
        #ifdef DEBUG
            //extern int iWin16Cnt;
            //extern int iDLLCSCnt;
            #define INCCSCNT() iDLLCSCnt++;
            #define DECCSCNT() iDLLCSCnt--;
            #define INCW16CNT() iWin16Cnt++;
            #define DECW16CNT() iWin16Cnt--;
        #else
            #define INCCSCNT()
            #define DECCSCNT()
            #define INCW16CNT()
            #define DECW16CNT()
        #endif //debug

        #ifdef WINNT
                extern HANDLE hDirectDrawMutex; //def'd in dllmain.c
                #ifdef USE_CHEAP_MUTEX
                    //--------------------------------- new cheap mutexes -------------------------------------------
                        #define ENTER_DDRAW() {CHEAP_ENTER;}
                        #define ENTER_DDRAW_INDLLMAIN() CHEAP_ENTER
                        #define LEAVE_DDRAW() CHEAP_LEAVE
                    #define INIT_DDRAW_CSECT()                                                                     \
                        {                                                                                          \
                            if (!AttachToGlobalCriticalSection(&CheapMutexPerProcess,&CheapMutexCrossProcess,DDRAW_FAST_CS_NAME) )  \
                                {DPF(0,"===================== Mutex Creation FAILED =================");}          \
                        }

                    #define FINI_DDRAW_CSECT() {DetachFromGlobalCriticalSection(&CheapMutexPerProcess);}

                #else

                    #ifdef NT_USES_CRITICAL_SECTION
                        //
                        // Use critical sections
                        //
                        #define INIT_DDRAW_CSECT() InitializeCriticalSection( lpDDCS );

                        #define FINI_DDRAW_CSECT() DeleteCriticalSection( lpDDCS );

                        extern DWORD gdwRecursionCount;

                        #define ENTER_DDRAW() \
                                {                                                                   \
                                    DWORD dwUniqueness;                                             \
                                    EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS );            \
                                    gdwRecursionCount++;                                            \
                                    dwUniqueness = DdQueryDisplaySettingsUniqueness();              \
                                    if (dwUniqueness != uDisplaySettingsUnique &&                   \
                                        1 == gdwRecursionCount)                                     \
                                    {                                                               \
                                        ModeChangedOnENTERDDRAW();                                  \
                                        uDisplaySettingsUnique = dwUniqueness;                      \
                                    }                                                               \
                                }

                        #define ENTER_DDRAW_INDLLMAIN() \
                                    EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS );            \
                                    gdwRecursionCount++;

                        #define LEAVE_DDRAW() { gdwRecursionCount--; LeaveCriticalSection( (LPCRITICAL_SECTION) lpDDCS );}


                    #else
                        //
                        // Use a mutex object.
                        //

                        #define INIT_DDRAW_CSECT()                                                      \
                            { if (hDirectDrawMutex) {DPF(0,"Direct draw mutex initialised twice!");}    \
                              else{                                                                     \
                                hDirectDrawMutex = CreateMutex(NULL,FALSE,"DirectDrawMutexName");       \
                                if (!hDirectDrawMutex) {DPF(0,"===================== Mutex Creation FAILED =================");}\
                                }      \
                            }

                        extern DWORD gdwRecursionCount;
                        #define FINI_DDRAW_CSECT() { if (hDirectDrawMutex) CloseHandle(hDirectDrawMutex); }
                        #define LEAVE_DDRAW() { gdwRecursionCount--;ReleaseMutex(hDirectDrawMutex); }
                        #define ENTER_DDRAW()                                                       \
                                {                                                                   \
                                    DWORD dwUniqueness,dwWaitValue;                                 \
                                    dwWaitValue = WaitForSingleObject(hDirectDrawMutex,INFINITE);   \
                                    gdwRecursionCount++;                                            \
                                    dwUniqueness = DdQueryDisplaySettingsUniqueness();              \
                                    if (dwUniqueness != uDisplaySettingsUnique &&                   \
                                        1 == gdwRecursionCount)                                     \
                                    {                                                               \
                                        ModeChangedOnENTERDDRAW();                                  \
                                        uDisplaySettingsUnique = dwUniqueness;                      \
                                    }                                                               \
                                }
                        #define ENTER_DDRAW_INDLLMAIN() WaitForSingleObject(hDirectDrawMutex,INFINITE);
                    #endif //use (expensive) mutexes
                #endif //use_cheap_mutex

                #define ENTER_DRIVERLISTCSECT() \
                        WaitForSingleObject(hDriverObjectListMutex,INFINITE);
                #define LEAVE_DRIVERLISTCSECT() \
                        ReleaseMutex(hDriverObjectListMutex);

        #else //not winnt:
            #ifdef WIN16_SEPARATE
                #define INIT_DDRAW_CSECT() \
                        ReinitializeCriticalSection( lpDDCS ); \
                        MakeCriticalSectionGlobal( lpDDCS );

                #define FINI_DDRAW_CSECT() \
                        DeleteCriticalSection( lpDDCS );

                #define ENTER_DDRAW() \
                        DPF( 7, "*****%08lx ENTER_DDRAW: CNT = %ld," REMIND( "" ), GETCURRPID(), iDLLCSCnt ); \
                        EnterCriticalSection( (LPCRITICAL_SECTION) lpDDCS ); \
                        INCCSCNT(); \
                        DPF( 7, "*****%08lx GOT DDRAW CSECT: CNT = %ld," REMIND(""), GETCURRPID(), iDLLCSCnt );

                #define LEAVE_DDRAW() \
                        DECCSCNT() \
                        DPF( 7, "*****%08lx LEAVE_DDRAW: CNT = %ld," REMIND( "" ), GETCURRPID(), iDLLCSCnt ); \
                        LeaveCriticalSection( (LPCRITICAL_SECTION) lpDDCS );

            #else //not WIN16_SEPARATE

                #define INIT_DDRAW_CSECT()
                #define FINI_DDRAW_CSECT()
                #define ENTER_DDRAW()   \
                            DPF( 7, "*****%08lx ENTER_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                            _EnterSysLevel( lpWin16Lock ); \
                            INCW16CNT(); \
                            DPF( 7, "*****%08lx GOT WIN16LOCK: CNT = %ld," REMIND(""), GETCURRPID(), iWin16Cnt );
                #define LEAVE_DDRAW() \
                            DECW16CNT() \
                            DPF( 7, "*****%08lx LEAVE_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                            _LeaveSysLevel( lpWin16Lock );

            #endif //win16_separate
            #define ENTER_DRIVERLISTCSECT() \
                        EnterCriticalSection( &csDriverObjectList );

            #define LEAVE_DRIVERLISTCSECT() \
                        LeaveCriticalSection( &csDriverObjectList );
        #endif  //winnt
    #endif //use csects

    extern DWORD gdwSetIME; // from ddraw.c
    // This macro is used to show/hide the IME outside of the ddraw critsect
    #define HIDESHOW_IME()                                          \
            if (gdwSetIME)                                          \
            {                                                       \
                SystemParametersInfo(                               \
                    SPI_SETSHOWIMEUI, gdwSetIME - 1, NULL, 0);      \
                                                                    \
                InterlockedExchange(&gdwSetIME, 0);                 \
            }

    #if defined(WIN95)
        /*
         * selector management functions
         */
        extern DWORD _stdcall MapLS( LPVOID );  // flat -> 16:16
        extern void _stdcall UnMapLS( DWORD ); // unmap 16:16
        extern LPVOID _stdcall MapSLFix( DWORD ); // 16:16->flat
        extern LPVOID _stdcall MapSL( DWORD ); // 16:16->flat
        //extern void _stdcall UnMapSLFix( LPVOID ); // 16:16->flat
        /*
         * win16 lock
         */
        extern void _stdcall    GetpWin16Lock( LPVOID FAR *);
        extern void _stdcall    _EnterSysLevel( LPVOID );
        extern void _stdcall    _LeaveSysLevel( LPVOID );
        extern LPVOID           lpWin16Lock;
    #endif win95
#endif //is_32

#ifdef WIN95
    #ifdef WIN16_SEPARATE
        #define ENTER_WIN16LOCK()       \
                    DPF( 7, "*****%08lx ENTER_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                    _EnterSysLevel( lpWin16Lock ); \
                    INCW16CNT(); \
                    DPF( 7, "*****%08lx GOT WIN16LOCK: CNT = %ld," REMIND(""), GETCURRPID(), iWin16Cnt );
        #define LEAVE_WIN16LOCK()       \
                    DECW16CNT() \
                    DPF( 7,"*****%08lx LEAVE_WIN16LOCK: CNT = %ld," REMIND( "" ), GETCURRPID(), iWin16Cnt ); \
                    _LeaveSysLevel( lpWin16Lock );
    #else
        #define ENTER_WIN16LOCK()       badbadbad
        #define LEAVE_WIN16LOCK()       badbadbad
    #endif
#else
    #define ENTER_WIN16LOCK()
    #define LEAVE_WIN16LOCK()
#endif

#ifdef WIN16_SEPARATE
    #define ENTER_BOTH() \
            ENTER_DDRAW(); \
            ENTER_WIN16LOCK();

    #define LEAVE_BOTH() \
            LEAVE_WIN16LOCK(); \
            LEAVE_DDRAW();
#else
    #define ENTER_BOTH() \
            ENTER_DDRAW();
    #define LEAVE_BOTH() \
            LEAVE_DDRAW();
#endif

/* We now have a special case in dllmain on NT... */
#ifndef ENTER_DDRAW_INDLLMAIN
    #define ENTER_DDRAW_INDLLMAIN() ENTER_DDRAW()
#endif

#ifdef WIN95

    /*
     * DDHELP's handle for communicating with the DirectSound VXD. We need this
     * when we are executing DDRAW code with one of DDHELP's threads.
     */
    extern HANDLE hHelperDDVxd;

    /*
     * Macro to return the DirectSound VXD handle to use when communicating with
     * the VXD. This is necessary as we need to communicate with the VXD from
     * DirectDraw executing on a DDHELP thread. In which case we need to use
     * the VXD handle defined above (which is the VXD handle DDHELP got when it
     * loaded DDRAW.VXD). Otherwise, we use the VXD handle out of the given
     * local object.
     *
     * NOTE: We don't use GETCURRPID() or HackGetCurrentProcessId() as we want
     * the real PID not one that has been munged.
     */
    #define GETDDVXDHANDLE( pdrv_lcl ) \
        ( ( GetCurrentProcessId() == ( pdrv_lcl )->dwProcessId ) ? (HANDLE) ( ( pdrv_lcl )->hDDVxd ) : hHelperDDVxd )

#else  /* !WIN95 */

    #define GETDDVXDHANDLE( pdrv_lcl ) NULL

#endif /* !WIN95 */

#define VDPF(Args) DPF Args
#include "ddheap.h"
#include "ddagp.h"
/* apphack.c */
extern void FreeAppHackData(void);


/* cliprgn.h */
extern void ClipRgnToRect( LPRECT prect, LPRGNDATA prd );

/* ddcsurf.c */
extern BOOL isPowerOf2(DWORD dw, int* pPower);
extern HRESULT checkSurfaceDesc( LPDDSURFACEDESC2 lpsd, LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD FAR *psflags, BOOL emulation, BOOL real_sysmem, LPDDRAWI_DIRECTDRAW_INT pdrv_int );
extern DWORD ComputePitch( LPDDRAWI_DIRECTDRAW_GBL thisg, DWORD caps, DWORD width, UINT bpp );
extern DWORD GetBytesFromPixels( DWORD pixels, UINT bpp );
extern HRESULT createsurfaceEx(LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl);
#ifdef WINNT
extern BOOL WINAPI CompleteCreateSysmemSurface(LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl);
#endif
// modified and moved to dx8priv.h
// extern HRESULT InternalCreateSurface( LPDDRAWI_DIRECTDRAW_LCL thisg, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *lplpDDSurface, LPDDRAWI_DIRECTDRAW_INT this_int );

extern HRESULT AllocSurfaceMem( LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPDDRAWI_DDRAWSURFACE_LCL *slist, int nsurf );
#ifdef DEBUG
    void SurfaceSanityTest( LPDDRAWI_DIRECTDRAW_LCL pdrv, LPSTR title );
    #define SURFSANITY( a,b ) SurfaceSanityTest( a, b );
#else
    #define SURFSANITY( a,b )
#endif

/* ddclip.c */
extern HRESULT InternalCreateClipper( LPDDRAWI_DIRECTDRAW_GBL lpDD, DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter, BOOL fInitialized, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DIRECTDRAW_INT pdrv_int );
void ProcessClipperCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* ddcreate.c */
extern BOOL IsVGADevice(LPSTR szDevice);
extern char g_szPrimaryDisplay[];
extern BOOL xxxEnumDisplayDevicesA(LPVOID lpUnused, DWORD iDevice, struct _DISPLAY_DEVICEA *pdd, DWORD dwFlags);
extern BOOL CurrentProcessCleanup( BOOL );
extern LPHEAPALIGNMENT GetExtendedHeapAlignment( LPDDRAWI_DIRECTDRAW_GBL pddd , LPDDHAL_GETHEAPALIGNMENTDATA pghad, int iHeap);
extern void RemoveDriverFromList( LPDDRAWI_DIRECTDRAW_INT lpDD, BOOL );
extern void RemoveLocalFromList( LPDDRAWI_DIRECTDRAW_LCL lpDD_lcl );
extern LPDDRAWI_DIRECTDRAW_GBL DirectDrawObjectCreate( LPDDHALINFO lpDDHALInfo, BOOL reset, LPDDRAWI_DIRECTDRAW_GBL pdrv, HANDLE hDDVxd, char *szDrvName, DWORD dwDriverContext, DWORD dwLocalFlags );
extern LPDDRAWI_DIRECTDRAW_GBL FetchDirectDrawData( LPDDRAWI_DIRECTDRAW_GBL pdrv, BOOL reset, DWORD hInstance, HANDLE hDDVxd, char *szDrvName, DWORD dwDriverContext, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern LPVOID NewDriverInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPVOID lpvtbl );
extern DWORD DirectDrawMsg(LPSTR msg);
extern BOOL DirectDrawSupported( BOOL bDisplayMessage );
extern BOOL IsMultiMonitor( void );
extern LPDDRAWI_DIRECTDRAW_GBL fetchModeXData(LPDDRAWI_DIRECTDRAW_GBL pdrv,LPDDHALMODEINFO pmi, HANDLE hDDVxd );

#ifdef WINNT
extern BOOL GetCurrentMode(LPDDRAWI_DIRECTDRAW_GBL, LPDDHALINFO lpHalInfo, char *szDrvName);
extern HRESULT GetNTDeviceRect( LPSTR pDriverName, LPRECT lpRect );
extern void CheckAliasedLocksOnModeChange( void );
extern void NotifyDriverOfFreeAliasedLocks( void );
extern void NotifyDriverToDeferFrees( void );
#endif

extern HDC  DD_CreateDC(LPSTR pdrvname);
extern void DD_DoneDC(HDC hdc);

#ifdef IS_32
extern LONG xxxChangeDisplaySettingsExA(LPCSTR szDevice, LPDEVMODEA pdm, HWND hwnd, DWORD dwFlags,LPVOID lParam);

// modified and moved to dx8priv.h
//extern HRESULT InternalDirectDrawCreate( GUID * lpGUID, LPDIRECTDRAW *lplpDD, LPDDRAWI_DIRECTDRAW_INT pnew_int, DWORD dwFlags );

extern void UpdateRectFromDevice( LPDDRAWI_DIRECTDRAW_GBL pdrv );
extern void UpdateAllDeviceRects( void );
#endif

/* ddiunk.c */
extern HRESULT InitD3D( LPDDRAWI_DIRECTDRAW_INT this_int );
extern HRESULT InitDDrawPrivateD3DContext( LPDDRAWI_DIRECTDRAW_INT this_int );

/* dddefwp.c */
extern HRESULT SetAppHWnd( LPDDRAWI_DIRECTDRAW_LCL thisg, HWND hWnd, DWORD dwFlags );
extern VOID CleanupWindowList( DWORD pid );
extern void ClipTheCursor(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPRECT lpRect);

/* ddesurf.c */
extern void FillDDSurfaceDesc( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC lpdsd );
extern void FillDDSurfaceDesc2( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC2 lpdsd );
extern void FillEitherDDSurfaceDesc( LPDDRAWI_DDRAWSURFACE_LCL psurf, LPDDSURFACEDESC2 lpdsd );

/* ddfake.c */
extern BOOL getBitMask( LPDDHALMODEINFO pmi );
extern LPDDRAWI_DIRECTDRAW_GBL FakeDDCreateDriverObject( HDC hdc_dd, LPSTR szDrvName, LPDDRAWI_DIRECTDRAW_GBL, BOOL reset, HANDLE hDDVxd );
extern DWORD BuildModes( LPSTR szDevice, LPDDHALMODEINFO FAR *ppddhmi );
extern void BuildPixelFormat(HDC, LPDDHALMODEINFO, LPDDPIXELFORMAT);

/* ddpal.c */
extern void ResetSysPalette( LPDDRAWI_DDRAWSURFACE_GBL psurf, BOOL dofree );
extern void ProcessPaletteCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern ULONG DDAPI InternalPaletteRelease( LPDDRAWI_DDRAWPALETTE_INT this_int );
extern HRESULT SetPaletteAlways( LPDDRAWI_DDRAWSURFACE_INT psurf_int, LPDIRECTDRAWPALETTE lpDDPalette );

/* ddraw.c */
extern void DoneExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv );
extern void StartExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv, DWORD dwFlags, DWORD pid );
extern HRESULT FlipToGDISurface( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_INT psurf_int); //, FLATPTR fpprim );
extern void CheckExclusiveMode(LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPBOOL pbExclusiveExists, LPBOOL pbThisLclOwnsExclusive, BOOL bKeepMutex, HWND hwnd, BOOL bCanGetIt);

/* ddsacc.c */
void WINAPI AcquireDDThreadLock(void);
void WINAPI ReleaseDDThreadLock(void);
extern void RemoveProcessLocks( LPDDRAWI_DIRECTDRAW_LCL pdrv, LPDDRAWI_DDRAWSURFACE_LCL this_lcl, DWORD pid );
extern HRESULT InternalLock( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID *pbits,
                             LPRECT lpDestRect, DWORD dwFlags);
extern HRESULT InternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpSurfaceData, LPRECT lpDestRect, DWORD dwFlags );
#ifdef USE_ALIAS
    extern void BreakSurfaceLocks( LPDDRAWI_DDRAWSURFACE_GBL thisg );
#endif /* USE_ALIAS */

/* ddsatch.c */
extern void UpdateMipMapCount( LPDDRAWI_DDRAWSURFACE_INT psurf_int );
extern HRESULT AddAttachedSurface( LPDDRAWI_DDRAWSURFACE_INT psurf_from, LPDDRAWI_DDRAWSURFACE_INT psurf_to, BOOL implicit );
extern void DeleteAttachedSurfaceLists( LPDDRAWI_DDRAWSURFACE_LCL psurf );
#define DOA_DONTDELETEIMPLICIT FALSE
#define DOA_DELETEIMPLICIT     TRUE
extern HRESULT DeleteOneAttachment( LPDDRAWI_DDRAWSURFACE_INT this_int, LPDDRAWI_DDRAWSURFACE_INT pattsurf_int, BOOL cleanup, BOOL delete_implicit );
extern HRESULT DeleteOneLink( LPDDRAWI_DDRAWSURFACE_INT this_int, LPDDRAWI_DDRAWSURFACE_INT pattsurf_int );

/* ddsblt.c */
extern void WaitForDriverToFinishWithSurface(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl );
extern LPDDRAWI_DDRAWSURFACE_LCL FindAttached( LPDDRAWI_DDRAWSURFACE_LCL ptr, DWORD caps );
extern HRESULT XformRect(RECT * prcSrc,RECT * prcDest,RECT * prcClippedDest,RECT * prcClippedSrc,DWORD scale_x,DWORD scale_y);
// SCALE_X and SCALE_Y are fixed point variables scaled 16.16. These macros used by calls to XformRect.
#define SCALE_X(rcSrc,rcDest) ( ((rcSrc.right - rcSrc.left) << 16) / (rcDest.right - rcDest.left))
#define SCALE_Y(rcSrc,rcDest) ( ((rcSrc.bottom - rcSrc.top) << 16) / (rcDest.bottom - rcDest.top))

/* ddsckey.c */
extern HRESULT CheckColorKey( DWORD dwFlags, LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDCOLORKEY lpDDColorKey, LPDWORD psflags, BOOL halonly, BOOL helonly );
extern HRESULT ChangeToSoftwareColorKey( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL );

/* ddsiunk.c */
extern LPDDRAWI_DDRAWSURFACE_LCL NewSurfaceLocal( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpvtbl );
extern LPDDRAWI_DDRAWSURFACE_INT NewSurfaceInterface( LPDDRAWI_DDRAWSURFACE_LCL thisx, LPVOID lpvtbl );
extern void DestroySurface( LPDDRAWI_DDRAWSURFACE_LCL thisg );
extern void LooseManagedSurface( LPDDRAWI_DDRAWSURFACE_LCL thisg );
extern DWORD InternalSurfaceRelease( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL bLightweight, BOOL bDX8 );
extern void ProcessSurfaceCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern void FreeD3DSurfaceIUnknowns( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* ddmode.c */
extern HRESULT SetDisplayMode( LPDDRAWI_DIRECTDRAW_LCL thisx, DWORD modeidx, BOOL force, BOOL useRefreshRate );
extern HRESULT RestoreDisplayMode( LPDDRAWI_DIRECTDRAW_LCL thisx, BOOL force );
extern void AddModeXModes( LPDDRAWI_DIRECTDRAW_GBL pdrv );
extern BOOL MonitorCanHandleMode(LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD width, DWORD height, WORD refreshRate );
extern BOOL GetDDStereoMode( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD dwWidth, DWORD dwHeight, DWORD dwBpp, DWORD dwRefreshRate);

/* ddsurf.c */
extern HRESULT InternalGetBltStatus(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPDDRAWI_DDRAWSURFACE_LCL this_lcl , DWORD dwFlags );
extern HRESULT MoveToSystemMemory( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL hasvram, BOOL use_full_lock );
extern void InvalidateAllPrimarySurfaces( LPDDRAWI_DIRECTDRAW_GBL );
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalPrimary( LPDDRAWI_DIRECTDRAW_GBL );
extern BOOL MatchPrimary( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC2 lpDDSD );
extern void InvalidateAllSurfaces( LPDDRAWI_DIRECTDRAW_GBL thisg, HANDLE hDDVxd, BOOL fRebuildAliases );
#ifdef SHAREDZ
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalZBuffer( LPDDRAWI_DIRECTDRAW_GBL );
extern LPDDRAWI_DDRAWSURFACE_GBL FindGlobalBackBuffer( LPDDRAWI_DIRECTDRAW_GBL );
extern BOOL MatchSharedZBuffer( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC lpDDSD );
extern BOOL MatchSharedBackBuffer( LPDDRAWI_DIRECTDRAW_GBL thisg, LPDDSURFACEDESC lpDDSD );
#endif
extern HRESULT InternalPageLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern HRESULT InternalPageUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

extern LPDDRAWI_DDRAWSURFACE_INT getDDSInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID lpddcb );

extern HRESULT InternalGetDC( LPDDRAWI_DDRAWSURFACE_INT this_int, HDC FAR *lphdc
#ifdef WIN95
        , BOOL bWin16Lock
#endif  //WIN95
        );
extern HRESULT InternalReleaseDC( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, HDC hdc
#ifdef WIN95
        , BOOL bWin16Lock
#endif  //WIN95
        );
extern HRESULT EXTERN_DDAPI GetSurfaceFromDC( HDC hdc, LPDIRECTDRAWSURFACE *ppdds, HDC *phdcDriver );
extern HRESULT InternalAssociateDC( HDC hdc, LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl );
extern HRESULT InternalRemoveDCFromList( HDC hdc, LPDDRAWI_DDRAWSURFACE_LCL pdds_lcl );

// ddgdi32.c
#ifdef WIN95
extern void CleanupD3D8( LPDDRAWI_DIRECTDRAW_GBL pdrv, BOOL bDestroyAll, DWORD PID);
#endif

// function from ddsprite.c to clean pid from master sprite list:
void ProcessSpriteCleanup(LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid);

#ifdef WIN95
extern void UpdateOutstandingDC( LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl, LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl );
extern void UpdateDCOnPaletteChanges( LPDDRAWI_DDRAWPALETTE_GBL ppal_gbl );
#else
#define UpdateOutstandingDC(x,y)
#define UpdateDCOnPaletteChanges(x)
#endif


#ifdef USE_ALIAS
    /* ddalias.c */
    extern HRESULT CreateHeapAliases( HANDLE hvxd, LPDDRAWI_DIRECTDRAW_GBL pdrv );
    extern BOOL    ReleaseHeapAliases( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern HRESULT MapHeapAliasesToVidMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern HRESULT MapHeapAliasesToDummyMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );
    extern FLATPTR GetAliasedVidMem( LPDDRAWI_DIRECTDRAW_LCL   pdrv,
                                     LPDDRAWI_DDRAWSURFACE_LCL surf_lcl,
                                     FLATPTR                   fpVidMem );
#endif /* USE_ALIAS */

/* dllmain.c */
extern BOOL RemoveProcessFromDLL( DWORD pid );

/* misc.c */
extern BOOL CanBeFlippable( LPDDRAWI_DDRAWSURFACE_LCL thisg, LPDDRAWI_DDRAWSURFACE_LCL this_attach);
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedFlip( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedSurfaceLeft( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindAttachedMipMap( LPDDRAWI_DDRAWSURFACE_INT thisg );
extern LPDDRAWI_DDRAWSURFACE_INT FindParentMipMap( LPDDRAWI_DDRAWSURFACE_INT thisg );
#ifdef WIN95
    extern HANDLE GetDXVxdHandle( void );
#endif /* WIN95 */

/* ddcallbk.c */
extern void InitCallbackTables( void );
extern BOOL CallbackTablesInitialized( void );

/* ddvp.c */
extern void ProcessVideoPortCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern HRESULT InternalStopVideo( LPDDRAWI_DDVIDEOPORT_INT this_int );
extern LPDDRAWI_DDVIDEOPORT_LCL GetVideoPortFromSurface( LPDDRAWI_DDRAWSURFACE_INT surf_int );
extern DWORD IsValidAutoFlipSurface( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
#define IVAS_NOAUTOFLIPPING             0
#define IVAS_SOFTWAREAUTOFLIPPING       1
#define IVAS_HARDWAREAUTOFLIPPING       2
extern VOID RequireSoftwareAutoflip( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
extern VOID SetRingZeroSurfaceData( LPDDRAWI_DDRAWSURFACE_LCL lpSurface_lcl );
extern DWORD FlipVideoPortSurface( LPDDRAWI_DDRAWSURFACE_INT , DWORD );
extern VOID OverrideOverlay( LPDDRAWI_DDRAWSURFACE_INT lpSurf_int, LPDWORD lpdwFlags );
extern BOOL MustSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurf_int );
extern VOID RequireSoftwareBob( LPDDRAWI_DDRAWSURFACE_INT lpSurface_int );
extern VOID DecrementRefCounts( LPDDRAWI_DDRAWSURFACE_INT surf_int );

/* ddcolor.c */
extern VOID ReleaseColorControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );

/* ddgamma.c */
extern VOID ReleaseGammaControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );
extern BOOL SetGamma( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern VOID RestoreGamma( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );
extern VOID InitGamma( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPSTR szDrvName );

/* ddkernel.c */
extern HRESULT InternalReleaseKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, BOOL bLosingSurface );
extern HRESULT InternalCreateKernelSurfaceHandle( LPDDRAWI_DDRAWSURFACE_LCL lpSurface, PULONG_PTR lpHandle );
extern HRESULT UpdateKernelSurface( LPDDRAWI_DDRAWSURFACE_LCL lpSurface );
extern HRESULT UpdateKernelVideoPort( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwFlags );
extern HRESULT GetKernelFieldNum( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, LPDWORD lpdwFieldNum );
extern HRESULT SetKernelFieldNum( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwFieldNum );
extern HRESULT SetKernelSkipPattern( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, DWORD dwStartField, DWORD dwPatternSize, DWORD dwPattern );
extern HRESULT InitKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern HRESULT GetKernelSurfaceState( LPDDRAWI_DDRAWSURFACE_LCL lpSurf, LPDWORD lpdwStateFlags );
extern HRESULT ReleaseKernelInterface( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern BOOL CanSoftwareAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort );
extern BOOL IsKernelInterfaceSupported( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern HRESULT SetKernelDOSBoxEvent( LPDDRAWI_DIRECTDRAW_LCL lpDD );
extern VOID EnableAutoflip( LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort, BOOL bEnable );
extern BOOL IsWindows98( VOID );

/* ddmc.c */
extern BOOL IsMotionCompSupported( LPDDRAWI_DIRECTDRAW_LCL this_lcl );
extern void ProcessMotionCompCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl );

/* private.c */
extern void FreeAllPrivateData(LPPRIVATEDATANODE * ppListHead);

/* factory.c */
extern HRESULT InternalCreateDDFactory2(void **, IUnknown * pUnkOuter);

// ddrestor.c
extern HRESULT AllocSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern void FreeSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern HRESULT BackupSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern HRESULT RestoreSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern void BackupAllSurfaces(LPDDRAWI_DIRECTDRAW_GBL this_gbl);
extern void MungeAutoflipCaps(LPDDRAWI_DIRECTDRAW_GBL pdrv);

/* ddrefrsh.c */
extern HRESULT DDGetMonitorInfo( LPDDRAWI_DIRECTDRAW_INT lpDD_int);
extern void MassageModeTable(LPDDRAWI_DIRECTDRAW_GBL);
extern HRESULT ExpandModeTable( LPDDRAWI_DIRECTDRAW_GBL pddd );
extern BOOL CanMonitorHandleRefreshRate( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight, int wRefresh );

/* drvinfo.c */
extern BOOL Voodoo1GoodToGo( GUID * pGuid );
extern HRESULT InternalGetDeviceIdentifier7( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER2 pDI, DWORD dwFlags, BOOL bWHQL);


/* A handy one from ddhel.c */
/* DDRAW16 doesn't need this. */
#ifdef WIN32
    SCODE InitDIB(HDC hdc, LPBITMAPINFO lpbmi);
#endif
void ResetBITMAPINFO(LPDDRAWI_DIRECTDRAW_GBL thisg);
BOOL doPixelFormatsMatch(LPDDPIXELFORMAT lpddpf1,
                                LPDDPIXELFORMAT lpddpf2);
HRESULT ConvertToPhysColor(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl, LPDDARGB pSource, LPDWORD pdwPhysColor);
HRESULT ConvertFromPhysColor(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl, LPDWORD pdwPhysColor, LPDDARGB pDest);
extern DWORD GetSurfPFIndex(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl);
extern DWORD GetDxtBlkSize(DWORD dwFourCC);

/*
 * HEL's public memory allocator
 */
extern void HELFreeSurfaceSysMem(LPDDRAWI_DDRAWSURFACE_LCL lpsurf_lcl);
extern LPVOID HELAllocateSurfaceSysMem(LPDDRAWI_DDRAWSURFACE_LCL lpsurf_lcl, DWORD nWidth,
                                DWORD nHeight, LPDWORD lpdwSurfaceSize, LPLONG lpSurfPitch );
#ifndef NO_DDHELP
    /* w95hack.c */
    extern DWORD HackGetCurrentProcessId( void );
    extern BOOL DDAPI DDNotify( LPDDHELPDATA phd );
    extern void DDAPI DDNotifyModeSet( LPDDRAWI_DIRECTDRAW_GBL );
    extern void DDAPI DDNotifyDOSBox( LPDDRAWI_DIRECTDRAW_GBL );
#endif //NO_DDHELP

#ifdef POSTPONED
/* Delegating IUnknown functions */
extern HRESULT EXTERN_DDAPI DD_DelegatingQueryInterface(LPDIRECTDRAW, REFIID, LPVOID FAR *);
extern DWORD EXTERN_DDAPI DD_DelegatingAddRef( LPDIRECTDRAW lpDD );
extern DWORD EXTERN_DDAPI DD_DelegatingRelease( LPDIRECTDRAW lpDD );
#endif

/* DirectDrawFactory2 functions */
extern HRESULT EXTERN_DDAPI DDFac2_QueryInterface(LPDIRECTDRAWFACTORY2, REFIID, LPVOID FAR *);
extern DWORD EXTERN_DDAPI DDFac2_AddRef( LPDIRECTDRAWFACTORY2 lpDDFac );
extern ULONG EXTERN_DDAPI DDFac2_Release( LPDIRECTDRAWFACTORY2 lpDDFac );
extern HRESULT EXTERN_DDAPI DDFac2_CreateDirectDraw(LPDIRECTDRAWFACTORY2, GUID FAR *, HWND, DWORD dwCoopLevelFlags, DWORD, IUnknown *, struct IDirectDraw4 ** );
#ifdef IS_32
#ifdef SM_CMONITORS
    extern HRESULT EXTERN_DDAPI DDFac2_DirectDrawEnumerate(LPDIRECTDRAWFACTORY2 , LPDDENUMCALLBACKEX , LPVOID  , DWORD );
#else
    /*
     * This def'n is a hack to keep us building under NT build which doesn't have the
     * multimon headers in it yet
     */
    extern HRESULT EXTERN_DDAPI DDFac2_DirectDrawEnumerate(LPDIRECTDRAWFACTORY2 , LPDDENUMCALLBACK , LPVOID  , DWORD );
#endif
#endif

/* DIRECTDRAW functions */
extern HRESULT EXTERN_DDAPI DD_UnInitedQueryInterface( LPDIRECTDRAW lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern HRESULT EXTERN_DDAPI DD_QueryInterface( LPDIRECTDRAW lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_AddRef( LPDIRECTDRAW lpDD );
extern DWORD   EXTERN_DDAPI DD_Release( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_Compact( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_CreateClipper( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreatePalette( LPDIRECTDRAW lpDD, DWORD dwFlags, LPPALETTEENTRY lpDDColorTable, LPDIRECTDRAWPALETTE FAR *lplpDDPalette, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreateSurface( LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_CreateSurface4( LPDIRECTDRAW lpDD, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DD_DuplicateSurface( LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSurface, LPDIRECTDRAWSURFACE FAR *lplpDupDDSurface );
extern HRESULT EXTERN_DDAPI DD_EnumDisplayModes( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK lpEnumModesCallback );
extern HRESULT EXTERN_DDAPI DD_EnumDisplayModes4( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMMODESCALLBACK2 lpEnumModesCallback );
extern HRESULT EXTERN_DDAPI DD_EnumSurfaces( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpEnumCallback );
extern HRESULT EXTERN_DDAPI DD_EnumSurfaces4( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPVOID lpContext, LPDDENUMSURFACESCALLBACK2 lpEnumCallback );
extern HRESULT EXTERN_DDAPI DD_FlipToGDISurface( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_GetCaps( LPDIRECTDRAW lpDD, LPDDCAPS lpDDDriverCaps, LPDDCAPS lpHELCaps );
extern HRESULT EXTERN_DDAPI DD_GetColorKey( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_GetDisplayMode( LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpSurfaceDesc );
extern HRESULT EXTERN_DDAPI DD_GetFourCCCodes(LPDIRECTDRAW,DWORD FAR *,DWORD FAR *);
extern HRESULT EXTERN_DDAPI DD_GetGDISurface( LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE FAR * );
extern HRESULT EXTERN_DDAPI DD_GetScanLine( LPDIRECTDRAW lpDD, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_GetVerticalBlankStatus( LPDIRECTDRAW lpDD, BOOL FAR * );
extern HRESULT EXTERN_DDAPI DD_Initialize(LPDIRECTDRAW, GUID FAR *);
extern HRESULT EXTERN_DDAPI DD_SetColorKey( LPDIRECTDRAW lpDD, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_SetCooperativeLevel(LPDIRECTDRAW,HWND,DWORD);
extern HRESULT EXTERN_DDAPI DD_SetDisplayMode(LPDIRECTDRAW,DWORD,DWORD,DWORD);
extern HRESULT EXTERN_DDAPI DD_SetDisplayMode2(LPDIRECTDRAW,DWORD,DWORD,DWORD,DWORD,DWORD);
extern HRESULT EXTERN_DDAPI DD_RestoreDisplayMode(LPDIRECTDRAW);
extern HRESULT EXTERN_DDAPI DD_GetMonitorFrequency( LPDIRECTDRAW lpDD, LPDWORD lpdwFrequency);
extern HRESULT EXTERN_DDAPI DD_WaitForVerticalBlank( LPDIRECTDRAW lpDD, DWORD dwFlags, HANDLE hEvent );
extern HRESULT EXTERN_DDAPI DD_GetAvailableVidMem( LPDIRECTDRAW lpDD, LPDDSCAPS lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree );
extern HRESULT EXTERN_DDAPI DD_GetAvailableVidMem4( LPDIRECTDRAW lpDD, LPDDSCAPS2 lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree );
extern HRESULT EXTERN_DDAPI DD_GetSurfaceFromDC( LPDIRECTDRAW lpDD, HDC, LPDIRECTDRAWSURFACE *);
extern HRESULT EXTERN_DDAPI DD_RestoreAllSurfaces( LPDIRECTDRAW lpDD );
extern HRESULT EXTERN_DDAPI DD_GetDeviceIdentifier( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER, DWORD);
extern HRESULT EXTERN_DDAPI DD_GetDeviceIdentifier7( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER2, DWORD);
extern HRESULT EXTERN_DDAPI DD_StartModeTest( LPDIRECTDRAW7 lpDD, LPSIZE lpModesToTest, DWORD dwNumEntries, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_EvaluateMode( LPDIRECTDRAW7 lpDD, DWORD dwFlags, DWORD *pSecondsUntilTimeout);
#ifdef IS_32
    //streaming stuff confuses ddraw16
    #ifndef __cplusplus
        extern HRESULT EXTERN_DDAPI DD_CreateSurfaceFromStream( LPDIRECTDRAW4 lpDD, IStream *, LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE4 *, IUnknown *);
        extern HRESULT EXTERN_DDAPI DD_CreateSurfaceFromFile( LPDIRECTDRAW4 lpDD, BSTR, LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE4 *, IUnknown *);
    #endif
#endif
extern HRESULT EXTERN_DDAPI DD_CreateOptSurface( LPDIRECTDRAW, LPDDOPTSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *pUnkOuter);
extern HRESULT EXTERN_DDAPI DD_ListOptSurfaceGUIDS(LPDIRECTDRAW, DWORD *, LPGUID);
extern HRESULT EXTERN_DDAPI DD_CanOptimizeSurface(LPDIRECTDRAW, LPDDSURFACEDESC2, LPDDOPTSURFACEDESC, BOOL FAR *);
extern HRESULT EXTERN_DDAPI DD_TestCooperativeLevel(LPDIRECTDRAW);

/* DIRECTDRAWPALETTE functions */
extern HRESULT EXTERN_DDAPI DD_Palette_QueryInterface( LPDIRECTDRAWPALETTE lpDDPalette, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_Palette_AddRef( LPDIRECTDRAWPALETTE lpDDPalette );
extern DWORD   EXTERN_DDAPI DD_Palette_Release( LPDIRECTDRAWPALETTE lpDDPalette );
extern HRESULT EXTERN_DDAPI DD_Palette_GetCaps( LPDIRECTDRAWPALETTE lpDDPalette, LPDWORD lpdwFlags );
extern HRESULT EXTERN_DDAPI DD_Palette_Initialize( LPDIRECTDRAWPALETTE, LPDIRECTDRAW lpDD, DWORD dwFlags, LPPALETTEENTRY lpDDColorTable );
extern HRESULT EXTERN_DDAPI DD_Palette_SetEntries( LPDIRECTDRAWPALETTE lpDDPalette, DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpEntries );
extern HRESULT EXTERN_DDAPI DD_Palette_GetEntries( LPDIRECTDRAWPALETTE lpDDPalette, DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpEntries );
extern HRESULT EXTERN_DDAPI DD_Palette_SetPrivateData( LPDIRECTDRAWPALETTE, REFIID, LPVOID, DWORD, DWORD);
extern HRESULT EXTERN_DDAPI DD_Palette_GetPrivateData( LPDIRECTDRAWPALETTE, REFIID, LPVOID, LPDWORD);
extern HRESULT EXTERN_DDAPI DD_Palette_FreePrivateData( LPDIRECTDRAWPALETTE, REFIID );
extern HRESULT EXTERN_DDAPI DD_Palette_GetUniquenessValue( LPDIRECTDRAWPALETTE, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Palette_ChangeUniquenessValue( LPDIRECTDRAWPALETTE );
extern HRESULT EXTERN_DDAPI DD_Palette_IsEqual( LPDIRECTDRAWPALETTE, LPDIRECTDRAWPALETTE );


/* DIRECTDRAWCLIPPER functions */
extern HRESULT EXTERN_DDAPI DD_UnInitedClipperQueryInterface( LPDIRECTDRAWCLIPPER lpDD, REFIID riid, LPVOID FAR * ppvObj );
extern HRESULT EXTERN_DDAPI DD_Clipper_QueryInterface( LPVOID lpDDClipper, REFIID riid, LPVOID FAR * ppvObj );
extern ULONG   EXTERN_DDAPI DD_Clipper_AddRef( LPVOID lpDDClipper );
extern ULONG   EXTERN_DDAPI DD_Clipper_Release( LPVOID lpDDClipper );
extern HRESULT EXTERN_DDAPI DD_Clipper_GetClipList( LPDIRECTDRAWCLIPPER, LPRECT, LPRGNDATA, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Clipper_GetHWnd(LPDIRECTDRAWCLIPPER,HWND FAR *);
extern HRESULT EXTERN_DDAPI DD_Clipper_Initialize( LPDIRECTDRAWCLIPPER, LPDIRECTDRAW lpDD, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_Clipper_IsClipListChanged(LPDIRECTDRAWCLIPPER,BOOL FAR *);
extern HRESULT EXTERN_DDAPI DD_Clipper_SetClipList(LPDIRECTDRAWCLIPPER,LPRGNDATA, DWORD);
extern HRESULT EXTERN_DDAPI DD_Clipper_SetHWnd(LPDIRECTDRAWCLIPPER, DWORD, HWND );
extern HRESULT EXTERN_DDAPI DD_Clipper_SetNotificationCallback(LPDIRECTDRAWCLIPPER, DWORD,LPCLIPPERCALLBACK, LPVOID);

/* Private DIRECTDRAWCLIPPER functions */
extern HRESULT InternalGetClipList( LPDIRECTDRAWCLIPPER lpDDClipper, LPRECT lpRect, LPRGNDATA lpClipList, LPDWORD lpdwSize, LPDDRAWI_DIRECTDRAW_GBL pdrv);

/* DIRECTDRAWSURFACE functions */
extern HRESULT EXTERN_DDAPI DD_Surface_QueryInterface( LPVOID lpDDSurface, REFIID riid, LPVOID FAR * ppvObj );
extern ULONG   EXTERN_DDAPI DD_Surface_AddRef( LPVOID lpDDSurface );
extern ULONG   EXTERN_DDAPI DD_Surface_Release( LPVOID lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_AddAttachedSurface(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_AddOverlayDirtyRect(LPDIRECTDRAWSURFACE, LPRECT);
extern HRESULT EXTERN_DDAPI DD_Surface_AlphaBlt(LPDIRECTDRAWSURFACE, LPRECT, LPDIRECTDRAWSURFACE, LPRECT, DWORD, LPDDALPHABLTFX);
extern HRESULT EXTERN_DDAPI DD_Surface_Blt(LPDIRECTDRAWSURFACE,LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX);
extern HRESULT EXTERN_DDAPI DD_Surface_BltFast(LPDIRECTDRAWSURFACE,DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_BltBatch( LPDIRECTDRAWSURFACE, LPDDBLTBATCH, DWORD, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_ChangeUniquenessValue( LPDIRECTDRAWSURFACE );
extern HRESULT EXTERN_DDAPI DD_Surface_DeleteAttachedSurfaces(LPDIRECTDRAWSURFACE, DWORD,LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_EnumAttachedSurfaces(LPDIRECTDRAWSURFACE,LPVOID, LPDDENUMSURFACESCALLBACK );
extern HRESULT EXTERN_DDAPI DD_Surface_EnumOverlayZOrders(LPDIRECTDRAWSURFACE,DWORD,LPVOID,LPDDENUMSURFACESCALLBACK);
extern HRESULT EXTERN_DDAPI DD_Surface_Flip(LPDIRECTDRAWSURFACE,LPDIRECTDRAWSURFACE, DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_FreePrivateData(LPDIRECTDRAWSURFACE, REFIID);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface(LPDIRECTDRAWSURFACE,LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface4(LPDIRECTDRAWSURFACE4,LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetAttachedSurface7(LPDIRECTDRAWSURFACE7,LPDDSCAPS2, LPDIRECTDRAWSURFACE7 FAR *);
extern HRESULT EXTERN_DDAPI DD_Surface_GetBltStatus(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetCaps( LPDIRECTDRAWSURFACE lpDDSurface, LPDDSCAPS lpDDSCaps );
extern HRESULT EXTERN_DDAPI DD_Surface_GetCaps4( LPDIRECTDRAWSURFACE lpDDSurface, LPDDSCAPS2 lpDDSCaps );
extern HRESULT EXTERN_DDAPI DD_Surface_GetClipper( LPDIRECTDRAWSURFACE, LPDIRECTDRAWCLIPPER FAR * );
extern HRESULT EXTERN_DDAPI DD_Surface_GetColorKey( LPDIRECTDRAWSURFACE lpDDSurface, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_Surface_GetDC( LPDIRECTDRAWSURFACE, HDC FAR * );
extern HRESULT EXTERN_DDAPI DD_Surface_GetDDInterface(LPDIRECTDRAWSURFACE lpDDSurface, LPVOID FAR *lplpDD );
extern HRESULT EXTERN_DDAPI DD_Surface_GetOverlayPosition( LPDIRECTDRAWSURFACE, LPLONG, LPLONG );
extern HRESULT EXTERN_DDAPI DD_Surface_GetPalette(LPDIRECTDRAWSURFACE,LPDIRECTDRAWPALETTE FAR*);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPixelFormat(LPDIRECTDRAWSURFACE, LPDDPIXELFORMAT);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPrivateData(LPDIRECTDRAWSURFACE, REFIID, LPVOID, LPDWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetSurfaceDesc(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC);
extern HRESULT EXTERN_DDAPI DD_Surface_GetSurfaceDesc4(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC2);
extern HRESULT EXTERN_DDAPI DD_Surface_GetFlipStatus(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetUniquenessValue( LPDIRECTDRAWSURFACE, LPDWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_Initialize( LPDIRECTDRAWSURFACE, LPDIRECTDRAW lpDD, LPDDSURFACEDESC lpDDSurfaceDesc);
extern HRESULT EXTERN_DDAPI DD_Surface_IsLost( LPDIRECTDRAWSURFACE lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_Lock(LPDIRECTDRAWSURFACE,LPRECT,LPDDSURFACEDESC lpDDSurfaceDesc, DWORD, HANDLE hEvent );
extern HRESULT EXTERN_DDAPI DD_Surface_PageLock(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_PageUnlock(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_ReleaseDC(LPDIRECTDRAWSURFACE,HDC );
#ifdef POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_Resize(LPDIRECTDRAWSURFACE,DWORD,DWORD,DWORD);
#endif //POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_Restore( LPDIRECTDRAWSURFACE lpDDSurface );
extern HRESULT EXTERN_DDAPI DD_Surface_SetBltOrder(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_SetClipper( LPDIRECTDRAWSURFACE, LPDIRECTDRAWCLIPPER );
extern HRESULT EXTERN_DDAPI DD_Surface_SetColorKey( LPDIRECTDRAWSURFACE lpDDSurface, DWORD dwFlags, LPDDCOLORKEY lpDDColorKey );
extern HRESULT EXTERN_DDAPI DD_Surface_SetOverlayPosition( LPDIRECTDRAWSURFACE, LONG, LONG );
extern HRESULT EXTERN_DDAPI DD_Surface_SetPalette(LPDIRECTDRAWSURFACE,LPDIRECTDRAWPALETTE);
extern HRESULT EXTERN_DDAPI DD_Surface_SetPrivateData(LPDIRECTDRAWSURFACE, REFIID, LPVOID, DWORD, DWORD);
#ifdef POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_SetSpriteDisplayList(LPDIRECTDRAWSURFACE,LPDDSPRITE *,DWORD,DWORD,LPDIRECTDRAWSURFACE,DWORD);
#endif //POSTPONED2
extern HRESULT EXTERN_DDAPI DD_Surface_SetSurfaceDesc( LPDIRECTDRAWSURFACE3, LPDDSURFACEDESC, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_SetSurfaceDesc4( LPDIRECTDRAWSURFACE3, LPDDSURFACEDESC2, DWORD );
extern HRESULT EXTERN_DDAPI DD_Surface_Unlock(LPDIRECTDRAWSURFACE,LPVOID);
extern HRESULT EXTERN_DDAPI DD_Surface_Unlock4(LPDIRECTDRAWSURFACE,LPRECT);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlay(LPDIRECTDRAWSURFACE,LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlayDisplay(LPDIRECTDRAWSURFACE,DWORD);
extern HRESULT EXTERN_DDAPI DD_Surface_UpdateOverlayZOrder(LPDIRECTDRAWSURFACE,DWORD,LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_Surface_SetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwPriority);
extern HRESULT EXTERN_DDAPI DD_Surface_GetPriority(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwPriority);
extern HRESULT EXTERN_DDAPI DD_Surface_SetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, DWORD dwLOD);
extern HRESULT EXTERN_DDAPI DD_Surface_GetLOD(LPDIRECTDRAWSURFACE7 lpDDSurface, LPDWORD lpdwLOD);

/* DrawDrawVideoPortContainer functions */
extern HRESULT EXTERN_DDAPI DDVPC_QueryInterface(LPDDVIDEOPORTCONTAINER lpDVP, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DDVPC_AddRef(LPDDVIDEOPORTCONTAINER lpDVP );
extern DWORD   EXTERN_DDAPI DDVPC_Release( LPDDVIDEOPORTCONTAINER lpDD );
extern HRESULT EXTERN_DDAPI DDVPC_CreateVideoPort(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwFlags, LPDDVIDEOPORTDESC lpDesc, LPDIRECTDRAWVIDEOPORT FAR *lplpVideoPort, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DDVPC_EnumVideoPorts(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwReserved, LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext, LPDDENUMVIDEOCALLBACK lpCallback );
extern HRESULT EXTERN_DDAPI DDVPC_GetVideoPortConnectInfo(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwVideoPortID, LPDWORD lpdwNumGUIDs, LPDDVIDEOPORTCONNECT lpConnect );
extern HRESULT EXTERN_DDAPI DDVPC_QueryVideoPortStatus(LPDDVIDEOPORTCONTAINER lpDVP, DWORD dwVideoPortID, LPDDVIDEOPORTSTATUS lpStatus );

/* DirectDrawVideoPort functions */
extern HRESULT EXTERN_DDAPI DD_VP_QueryInterface(LPDIRECTDRAWVIDEOPORT lpDVP, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_VP_AddRef(LPDIRECTDRAWVIDEOPORT lpDVP );
extern DWORD   EXTERN_DDAPI DD_VP_Release(LPDIRECTDRAWVIDEOPORT lpDVP );
extern HRESULT EXTERN_DDAPI DD_VP_SetTargetSurface(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_Flip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE lpSurface, DWORD );
extern HRESULT EXTERN_DDAPI DD_VP_GetBandwidth(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDPIXELFORMAT lpf, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags, LPDDVIDEOPORTBANDWIDTH lpBandwidth );
extern HRESULT EXTERN_DDAPI DD_VP_GetInputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwNum, LPDDPIXELFORMAT lpf, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_GetOutputFormats(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDPIXELFORMAT lpf, LPDWORD lp1, LPDDPIXELFORMAT lp2, DWORD dwFlags );
extern HRESULT EXTERN_DDAPI DD_VP_GetCurrentAutoFlip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE FAR* lpSurf, LPDIRECTDRAWSURFACE FAR* lpVBI, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetLastAutoFlip(LPDIRECTDRAWVIDEOPORT lpDVP, LPDIRECTDRAWSURFACE FAR* lpSurf, LPDIRECTDRAWSURFACE FAR* lpVBI, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetField(LPDIRECTDRAWVIDEOPORT lpDVP, LPBOOL lpField );
extern HRESULT EXTERN_DDAPI DD_VP_GetLine(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwLine );
extern HRESULT EXTERN_DDAPI DD_VP_StartVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo );
extern HRESULT EXTERN_DDAPI DD_VP_StopVideo(LPDIRECTDRAWVIDEOPORT lpDVP );
extern HRESULT EXTERN_DDAPI DD_VP_UpdateVideo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDVIDEOPORTINFO lpInfo );
extern HRESULT EXTERN_DDAPI DD_VP_WaitForSync(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwFlags, DWORD dwLine, DWORD dwTimeOut );
extern HRESULT EXTERN_DDAPI DD_VP_SetFieldNumber(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwFieldNum );
extern HRESULT EXTERN_DDAPI DD_VP_GetFieldNumber(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwFieldNum );
extern HRESULT EXTERN_DDAPI DD_VP_SetSkipFieldPattern(LPDIRECTDRAWVIDEOPORT lpDVP, DWORD dwStartField, DWORD dwPattSize, DWORD dwPatt );
extern HRESULT EXTERN_DDAPI DD_VP_GetSignalStatus(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwStatus );
extern HRESULT EXTERN_DDAPI DD_VP_GetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_VP_SetColorControls(LPDIRECTDRAWVIDEOPORT lpDVP, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_VP_GetStateInfo(LPDIRECTDRAWVIDEOPORT lpDVP, LPDWORD lpdwStateFlags );

/* DirectDrawVideoPortNotify functions */
extern HRESULT EXTERN_DDAPI DD_VP_Notify_AcquireNotification( LPDIRECTDRAWVIDEOPORTNOTIFY lpNotify, HANDLE* pEvent, LPDDVIDEOPORTNOTIFY pBuffer );
extern HRESULT EXTERN_DDAPI DD_VP_Notify_ReleaseNotification( LPDIRECTDRAWVIDEOPORTNOTIFY lpNotify, HANDLE pEvent );

/* DrawDrawColorControl functions */
extern HRESULT EXTERN_DDAPI DD_Color_GetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor );
extern HRESULT EXTERN_DDAPI DD_Color_SetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor );

/* DrawDrawGammaControl functions */
extern HRESULT EXTERN_DDAPI DD_Gamma_GetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC, DWORD dwFlags, LPVOID lpGammaTable );
extern HRESULT EXTERN_DDAPI DD_Gamma_SetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC, DWORD dwFlags, LPVOID lpGammaTable );

/* DirectDrawKernel functions */
extern HRESULT EXTERN_DDAPI DD_Kernel_GetCaps(LPDIRECTDRAWKERNEL lpDDK, LPDDKERNELCAPS lpCaps );
extern HRESULT EXTERN_DDAPI DD_Kernel_GetKernelHandle(LPDIRECTDRAWKERNEL lpDDK, PULONG_PTR lpHandle );
extern HRESULT EXTERN_DDAPI DD_Kernel_ReleaseKernelHandle(LPDIRECTDRAWKERNEL lpDDK );

/* DirectDrawSurfaceKernel functions */
extern HRESULT EXTERN_DDAPI DD_SurfaceKernel_GetKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK, PULONG_PTR lpHandle );
extern HRESULT EXTERN_DDAPI DD_SurfaceKernel_ReleaseKernelHandle(LPDIRECTDRAWSURFACEKERNEL lpDDK );

/* DIrectDrawSurface and palette IPersist and IPersistStream functions */
#ifdef IS_32
    extern HRESULT EXTERN_DDAPI DD_PStream_GetSizeMax(IPersistStream * lpSurfOrPalette, ULARGE_INTEGER * pMax);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_Save(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm, BOOL bClearDirty);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_IsDirty(LPDIRECTDRAWSURFACE lpDDS);
    extern HRESULT EXTERN_DDAPI DD_Surface_Persist_GetClassID(LPDIRECTDRAWSURFACE lpDDS, CLSID * pClassID);
    extern HRESULT EXTERN_DDAPI DD_Surface_PStream_Load(LPDIRECTDRAWSURFACE lpDDS, IStream * pStrm);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_Save(LPDIRECTDRAWPALETTE lpDDS, IStream * pStrm, BOOL bClearDirty);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_IsDirty(LPDIRECTDRAWPALETTE lpDDS);
    extern HRESULT EXTERN_DDAPI DD_Palette_Persist_GetClassID(LPDIRECTDRAWPALETTE lpDDS, CLSID * pClassID);
    extern HRESULT EXTERN_DDAPI DD_Palette_PStream_Load(LPDIRECTDRAWPALETTE lpDDS, IStream * pStrm);
#endif

/* DirectDrawOptSurface functions */
extern HRESULT EXTERN_DDAPI DD_OptSurface_GetOptSurfaceDesc(LPDIRECTDRAWSURFACE, LPDDOPTSURFACEDESC);
extern HRESULT EXTERN_DDAPI DD_OptSurface_LoadUnoptimizedSurf(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_OptSurface_CopyOptimizedSurf(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
extern HRESULT EXTERN_DDAPI DD_OptSurface_Unoptimize(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *);

/* DrawDrawMotionCompContainer functions */
extern HRESULT EXTERN_DDAPI DDMCC_CreateMotionComp(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPVOID lpData, DWORD dwDataSize, LPDIRECTDRAWVIDEOACCELERATOR FAR *lplpMotionComp, IUnknown FAR *pUnkOuter );
extern HRESULT EXTERN_DDAPI DDMCC_GetUncompressedFormats(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDWORD lpNumFormats, LPDDPIXELFORMAT lpFormats );
extern HRESULT EXTERN_DDAPI DDMCC_GetMotionCompGUIDs(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPDWORD lpNumGuids, LPGUID lpGuids );
extern HRESULT EXTERN_DDAPI DDMCC_GetCompBuffInfo(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPDWORD lpNumBuffInfo, LPDDVACompBufferInfo lpCompBuffInfo );
extern HRESULT EXTERN_DDAPI DDMCC_GetInternalMoCompInfo(LPDDVIDEOACCELERATORCONTAINER lpDDMCC, LPGUID lpGuid, LPDDVAUncompDataInfo lpUncompInfo, LPDDVAInternalMemInfo lpMemInfo );

/* DrawDrawMotionComp functions */
extern HRESULT EXTERN_DDAPI DD_MC_QueryInterface(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, REFIID riid, LPVOID FAR * ppvObj );
extern DWORD   EXTERN_DDAPI DD_MC_AddRef(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC);
extern DWORD   EXTERN_DDAPI DD_MC_Release(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC);
extern HRESULT EXTERN_DDAPI DD_MC_BeginFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDDVABeginFrameInfo lpInfo);
extern HRESULT EXTERN_DDAPI DD_MC_EndFrame(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDDVAEndFrameInfo lpInfo);
extern HRESULT EXTERN_DDAPI DD_MC_QueryRenderStatus(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, LPDIRECTDRAWSURFACE7 lpSurface, DWORD dwFlags);
extern HRESULT EXTERN_DDAPI DD_MC_RenderMacroBlocks(LPDIRECTDRAWVIDEOACCELERATOR lpDDMC, DWORD dwFunction, LPVOID lpInput, DWORD dwInputSize, LPVOID lpOutput, DWORD dwOutSize, DWORD dwNumBuffers, LPDDVABUFFERINFO lpBuffInfo);

//#endif //WIN95

/*
 * HAL fns
 */

//#ifdef WIN95
/*
 * thunk helper fns
 */
extern DWORD DDAPI _DDHAL_CreatePalette( LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData );
extern DWORD DDAPI DDThunk16_CreatePalette( LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData );

extern DWORD DDAPI _DDHAL_CreateSurface( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );
extern DWORD DDAPI DDThunk16_CreateSurface( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );

extern DWORD DDAPI _DDHAL_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );
extern DWORD DDAPI DDThunk16_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );

extern DWORD DDAPI _DDHAL_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlankData );
extern DWORD DDAPI DDThunk16_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlankData );

extern DWORD DDAPI _DDHAL_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA lpDestroyDriverData );
extern DWORD DDAPI DDThunk16_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA lpDestroyDriverData );

extern DWORD DDAPI _DDHAL_SetMode( LPDDHAL_SETMODEDATA lpSetModeData );
extern DWORD DDAPI DDThunk16_SetMode( LPDDHAL_SETMODEDATA lpSetModeData );

extern DWORD DDAPI _DDHAL_GetScanLine( LPDDHAL_GETSCANLINEDATA lpGetScanLineData );
extern DWORD DDAPI DDThunk16_GetScanLine( LPDDHAL_GETSCANLINEDATA lpGetScanLineData );

extern DWORD DDAPI _DDHAL_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveModeData );
extern DWORD DDAPI DDThunk16_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveModeData );

extern DWORD DDAPI _DDHAL_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurfaceData );
extern DWORD DDAPI DDThunk16_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurfaceData );

extern DWORD DDAPI _DDHAL_GetAvailDriverMemory ( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpGetAvailDriverMemoryData );
extern DWORD DDAPI DDThunk16_GetAvailDriverMemory ( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpGetAvailDriverMemoryData );

extern DWORD DDAPI _DDHAL_UpdateNonLocalHeap ( LPDDHAL_UPDATENONLOCALHEAPDATA lpUpdateNonLocalHeapData );
extern DWORD DDAPI DDThunk16_UpdateNonLocalHeap ( LPDDHAL_UPDATENONLOCALHEAPDATA lpUpdateNonLocalHeapData );

/*
 * Palette Object HAL fns
 */
extern DWORD DDAPI _DDHAL_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA );
extern DWORD DDAPI DDThunk16_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA );

extern DWORD DDAPI _DDHAL_SetEntries( LPDDHAL_SETENTRIESDATA );
extern DWORD DDAPI DDThunk16_SetEntries( LPDDHAL_SETENTRIESDATA );

/*
 * Surface Object HAL fns
 */
extern DWORD DDAPI _DDHAL_DestroySurface( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );
extern DWORD DDAPI DDThunk16_DestroySurface( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );

extern DWORD DDAPI _DDHAL_Flip( LPDDHAL_FLIPDATA lpFlipData );
extern DWORD DDAPI DDThunk16_Flip( LPDDHAL_FLIPDATA lpFlipData );

extern DWORD DDAPI _DDHAL_Blt( LPDDHAL_BLTDATA lpBltData );
extern DWORD DDAPI DDThunk16_Blt( LPDDHAL_BLTDATA lpBltData );

extern DWORD DDAPI _DDHAL_Lock( LPDDHAL_LOCKDATA lpLockData );
extern DWORD DDAPI DDThunk16_Lock( LPDDHAL_LOCKDATA lpLockData );

extern DWORD DDAPI _DDHAL_Unlock( LPDDHAL_UNLOCKDATA lpUnlockData );
extern DWORD DDAPI DDThunk16_Unlock( LPDDHAL_UNLOCKDATA lpUnlockData );

extern DWORD DDAPI _DDHAL_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA lpAddAttachedSurfaceData );
extern DWORD DDAPI DDThunk16_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA lpAddAttachedSurfaceData );

extern DWORD DDAPI _DDHAL_SetColorKey( LPDDHAL_SETCOLORKEYDATA lpSetColorKeyData );
extern DWORD DDAPI DDThunk16_SetColorKey( LPDDHAL_SETCOLORKEYDATA lpSetColorKeyData );

extern DWORD DDAPI _DDHAL_SetClipList( LPDDHAL_SETCLIPLISTDATA lpSetClipListData );
extern DWORD DDAPI DDThunk16_SetClipList( LPDDHAL_SETCLIPLISTDATA lpSetClipListData );

extern DWORD DDAPI _DDHAL_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA lpUpdateOverlayData );
extern DWORD DDAPI DDThunk16_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA lpUpdateOverlayData );

extern DWORD DDAPI _DDHAL_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA lpSetOverlayPositionData );
extern DWORD DDAPI DDThunk16_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA lpSetOverlayPositionData );

extern DWORD DDAPI _DDHAL_SetPalette( LPDDHAL_SETPALETTEDATA lpSetPaletteData );
extern DWORD DDAPI DDThunk16_SetPalette( LPDDHAL_SETPALETTEDATA lpSetPaletteData );

extern DWORD DDAPI _DDHAL_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatusData );
extern DWORD DDAPI DDThunk16_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatusData );

extern DWORD DDAPI _DDHAL_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatusData );
extern DWORD DDAPI DDThunk16_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatusData );

/*
 * Execute Buffer Pseudo Object HAL fns
 *
 * NOTE: No DDThunk16 equivalents as these are just dummy place holders to keep
 * DOHALCALL happy.
 */
extern DWORD DDAPI _DDHAL_CanCreateExecuteBuffer( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData );
extern DWORD DDAPI _DDHAL_CreateExecuteBuffer( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData );
extern DWORD DDAPI _DDHAL_DestroyExecuteBuffer( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData );
extern DWORD DDAPI _DDHAL_LockExecuteBuffer( LPDDHAL_LOCKDATA lpLockData );
extern DWORD DDAPI _DDHAL_UnlockExecuteBuffer( LPDDHAL_UNLOCKDATA lpUnlockData );

/*
 * Video Port Pseudo Object HAL fns
 *
 * NOTE: No DDThunk16 equivalents as these are just dummy place holders to keep
 * DOHALCALL happy.
 */
extern DWORD DDAPI _DDHAL_GetVideoPortConnectInfo( LPDDHAL_GETVPORTCONNECTDATA lpGetTypeData );
extern DWORD DDAPI _DDHAL_CanCreateVideoPort( LPDDHAL_CANCREATEVPORTDATA lpCanCreateData );
extern DWORD DDAPI _DDHAL_CreateVideoPort( LPDDHAL_CREATEVPORTDATA lpCreateData );
extern DWORD DDAPI _DDHAL_DestroyVideoPort( LPDDHAL_DESTROYVPORTDATA lpDestroyData );
extern DWORD DDAPI _DDHAL_GetVideoPortInputFormats( LPDDHAL_GETVPORTINPUTFORMATDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_GetVideoPortOutputFormats( LPDDHAL_GETVPORTOUTPUTFORMATDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_GetVideoPortBandwidthInfo( LPDDHAL_GETVPORTBANDWIDTHDATA lpGetBandwidthData );
extern DWORD DDAPI _DDHAL_UpdateVideoPort( LPDDHAL_UPDATEVPORTDATA lpUpdateData );
extern DWORD DDAPI _DDHAL_GetVideoPortField( LPDDHAL_GETVPORTFIELDDATA lpGetFieldData );
extern DWORD DDAPI _DDHAL_GetVideoPortLine( LPDDHAL_GETVPORTLINEDATA lpGetLineData );
extern DWORD DDAPI _DDHAL_WaitForVideoPortSync( LPDDHAL_WAITFORVPORTSYNCDATA lpWaitSyncData );
extern DWORD DDAPI _DDHAL_FlipVideoPort( LPDDHAL_FLIPVPORTDATA lpFlipData );
extern DWORD DDAPI _DDHAL_GetVideoPortFlipStatus( LPDDHAL_GETVPORTFLIPSTATUSDATA lpFlipData );
extern DWORD DDAPI _DDHAL_GetVideoSignalStatus( LPDDHAL_GETVPORTSIGNALDATA lpData );
extern DWORD DDAPI _DDHAL_VideoColorControl( LPDDHAL_VPORTCOLORDATA lpData );

/*
 * Color Control Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_ColorControl( LPDDHAL_COLORCONTROLDATA lpColorData );
extern DWORD DDAPI DDThunk16_ColorControl( LPDDHAL_COLORCONTROLDATA lpColorData );

/*
 * Kernel Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_SyncSurfaceData( LPDDHAL_SYNCSURFACEDATA lpSyncData );
extern DWORD DDAPI _DDHAL_SyncVideoPortData( LPDDHAL_SYNCVIDEOPORTDATA lpSyncData );

/*
 * MotionComp Pseudo Object HAL fns
 */
extern DWORD DDAPI _DDHAL_GetMoCompGuids( LPDDHAL_GETMOCOMPGUIDSDATA lpGetGuidData );
extern DWORD DDAPI _DDHAL_GetMoCompFormats( LPDDHAL_GETMOCOMPFORMATSDATA lpGetFormatData );
extern DWORD DDAPI _DDHAL_CreateMoComp( LPDDHAL_CREATEMOCOMPDATA lpCreateData );
extern DWORD DDAPI _DDHAL_GetMoCompBuffInfo( LPDDHAL_GETMOCOMPCOMPBUFFDATA lpBuffData );
extern DWORD DDAPI _DDHAL_GetInternalMoCompInfo( LPDDHAL_GETINTERNALMOCOMPDATA lpInternalData );
extern DWORD DDAPI _DDHAL_DestroyMoComp( LPDDHAL_DESTROYMOCOMPDATA lpDestroyData );
extern DWORD DDAPI _DDHAL_BeginMoCompFrame( LPDDHAL_BEGINMOCOMPFRAMEDATA lpFrameData );
extern DWORD DDAPI _DDHAL_EndMoCompFrame( LPDDHAL_ENDMOCOMPFRAMEDATA lpFrameData );
extern DWORD DDAPI _DDHAL_RenderMoComp( LPDDHAL_RENDERMOCOMPDATA lpRenderData );
extern DWORD DDAPI _DDHAL_QueryMoCompStatus( LPDDHAL_QUERYMOCOMPSTATUSDATA lpStatusData );
#ifdef POSTPONED
extern DWORD DDAPI _DDHAL_CanOptimizeSurface( LPDDHAL_CANOPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_OptimizeSurface( LPDDHAL_OPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_UnOptimizeSurface( LPDDHAL_UNOPTIMIZESURFACEDATA);
extern DWORD DDAPI _DDHAL_CopyOptSurface( LPDDHAL_COPYOPTSURFACEDATA);
#endif
//#endif

#ifdef POSTPONED
    #ifdef IS_32
    /*
     * DirectDrawFactory2 implementation
     */
    typedef struct _DDFACTORY2
    {
        IDirectDrawFactory2Vtbl *lpVtbl;
        DWORD                   dwRefCnt;
        /* internal data */
    } DDFACTORY2, FAR * LPDDFACTORY2;
    #endif
#endif //POSTPONED

/*
 * Macros for checking interface versions
 */

#define LOWERTHANDDRAW7(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks || lpDD->lpVtbl == &dd4Callbacks )

#define LOWERTHANDDRAW4(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks)

#define LOWERTHANDDRAW3(lpDD) \
    (lpDD->lpVtbl == &ddCallbacks || lpDD->lpVtbl == &dd2Callbacks)

#define LOWERTHANSURFACE7(lpDDS) \
    (lpDDS->lpVtbl == &ddSurfaceCallbacks || lpDDS->lpVtbl == &ddSurface2Callbacks || \
     lpDDS->lpVtbl == &ddSurface3Callbacks || lpDDS->lpVtbl == &ddSurface4Callbacks )

#define LOWERTHANSURFACE4(lpDDS) \
    (lpDDS->lpVtbl == &ddSurfaceCallbacks || lpDDS->lpVtbl == &ddSurface2Callbacks || lpDDS->lpVtbl == &ddSurface3Callbacks )

/*
 * This macro allows testing an interface pointer to see if it's one that come from
 * our implementation of ddraw, or somebody else's
 */
#define IS_NATIVE_DDRAW_INTERFACE(ptr) \
        ( ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd2Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd4Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd7Callbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd2UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd4UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&dd5UninitCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddVideoPortContainerCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddKernelCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddMotionCompContainerCallbacks) || \
          ((IUnknownVtbl*)ptr->lpVtbl == (IUnknownVtbl*)&ddUninitCallbacks) )

/*
 * This macro tests if this ddraw interface is one for which child objects should take
 * a ref count on that interface and thus achieve immortality wrt that interface.
 */
#define CHILD_SHOULD_TAKE_REFCNT(dd_int) (!LOWERTHANDDRAW3(dd_int))

/*
 * macros for checking if surface as been lost due to mode change
 * NOTE: The flag for determining if a surface is lost or not is now
 * stored in the local than global object. This prevents the scenario
 * where a surface being shared by two processes is lost and restored
 * by one of them - giving the other no notification that the contents
 * of the surface are gone.
 */
#define SURFACE_LOST( lcl_ptr ) (((lcl_ptr)->dwFlags & DDRAWISURF_INVALID))

/*
 * Useful palette macros
 *
 * All these flags are really iritating to handle but but changing
 * to use a numeric palette size would require an API change and
 * internal structure mods (visible to the driver) so I am sticking
 * with flags.
 */
#define SIZE_PCAPS_TO_FLAGS( pcaps )                              \
    (((pcaps) & DDPCAPS_1BIT) ? DDRAWIPAL_2 :                     \
     (((pcaps) & DDPCAPS_2BIT) ? DDRAWIPAL_4 :                    \
      (((pcaps) & DDPCAPS_4BIT) ? DDRAWIPAL_16 : DDRAWIPAL_256)))

#define SIZE_FLAGS_TO_PCAPS( flags )                              \
    (((flags) & DDRAWIPAL_2) ? DDPCAPS_1BIT :                     \
     (((flags) & DDRAWIPAL_4) ? DDPCAPS_2BIT :                    \
      (((flags) & DDRAWIPAL_16) ? DDPCAPS_4BIT : DDPCAPS_8BIT)))

#define FLAGS_TO_SIZE( flags )                                    \
    (((flags) & DDRAWIPAL_2)  ? 2 :                               \
     (((flags) & DDRAWIPAL_4)  ? 4 :                              \
      (((flags) & DDRAWIPAL_16) ? 16 : 256)))

/*
 * has Direct3D been initialized for this DirectDraw driver object?
 */
#define D3D_INITIALIZED( lcl_ptr )  (( NULL != (lcl_ptr)->pD3DIUnknown)  && ( NULL != (lcl_ptr)->hD3DInstance ))

#if defined( _WIN32 ) && !defined( WINNT )
/*
 * Macros and types to support secondary (stacked) drivers.
 *
 * NOTE: This stuff is only relevant to 32-bit DirectDraw and the GUIDs
 * confuse DDRAW16.
 */
#define MAX_SECONDARY_DRIVERNAME              MAX_PATH
#define MAX_SECONDARY_ENTRYPOINTNAME          32UL
#define DEFAULT_SECONDARY_ENTRYPOINTNAME      "GetInfo"

#define REGSTR_PATH_SECONDARY                 "Software\\Microsoft\\DirectDraw\\Secondary"
#define REGSTR_VALUE_SECONDARY_ENTRYPOINTNAME "Entry"
#define REGSTR_VALUE_SECONDARY_DRIVERNAME     "Name"

typedef DWORD                    (WINAPI * LPSECONDARY_PATCHHALINFO)(
                                        LPDDHALINFO                lpDDHALInfo,
                                        LPDDHAL_DDCALLBACKS        lpDDCallbacks,
                                        LPDDHAL_DDSURFACECALLBACKS lpDDSurfaceCallbacks,
                                        LPDDHAL_DDPALETTECALLBACKS lpDDPaletteCallbacks,
                                        LPDDHAL_DDEXEBUFCALLBACKS  lpDDExeBufCallbacks);
typedef LPSECONDARY_PATCHHALINFO (WINAPI * LPSECONDARY_VALIDATE)(LPGUID lpGuid);

DEFINE_GUID( guidCertifiedSecondaryDriver, 0x8061d4e0,0xe895,0x11cf,0xa2,0xe0,0x00,0xaa,0x00,0xb9,0x33,0x56 );
#endif

#if defined( _WIN32 )
DEFINE_GUID( guidVoodoo1A, 0x3a0cfd01,0x9320,0x11cf,0xac,0xa1,0x00,0xa0,0x24,0x13,0xc2,0xe2 );
DEFINE_GUID( guidVoodoo1B, 0xaba52f41,0xf744,0x11cf,0xb4,0x52,0x00,0x00,0x1d,0x1b,0x41,0x26 );
#endif

/*
 * macros for validating pointers
 */
extern DIRECTDRAWCALLBACKS                      ddCallbacks;
extern DIRECTDRAWCALLBACKS                      ddUninitCallbacks;
extern DIRECTDRAW2CALLBACKS                     dd2UninitCallbacks;
extern DIRECTDRAW2CALLBACKS                     dd2Callbacks;
extern DIRECTDRAW4CALLBACKS                     dd4UninitCallbacks;
extern DIRECTDRAW4CALLBACKS                     dd4Callbacks;
extern DIRECTDRAW7CALLBACKS                     dd7UninitCallbacks;
extern DIRECTDRAW7CALLBACKS                     dd7Callbacks;
extern DIRECTDRAWSURFACECALLBACKS               ddSurfaceCallbacks;
extern DIRECTDRAWSURFACE2CALLBACKS              ddSurface2Callbacks;
extern DIRECTDRAWSURFACE3CALLBACKS              ddSurface3Callbacks;
extern DIRECTDRAWSURFACE4CALLBACKS              ddSurface4Callbacks;
extern DIRECTDRAWSURFACE7CALLBACKS              ddSurface7Callbacks;
extern DIRECTDRAWCLIPPERCALLBACKS               ddClipperCallbacks;
extern DIRECTDRAWCLIPPERCALLBACKS               ddUninitClipperCallbacks;
extern DIRECTDRAWPALETTECALLBACKS               ddPaletteCallbacks;
extern DDVIDEOPORTCONTAINERCALLBACKS            ddVideoPortContainerCallbacks;
extern DIRECTDRAWVIDEOPORTCALLBACKS             ddVideoPortCallbacks;
extern DIRECTDRAWVIDEOPORTNOTIFYCALLBACKS       ddVideoPortNotifyCallbacks;
extern DIRECTDRAWKERNELCALLBACKS                ddKernelCallbacks;
extern DIRECTDRAWSURFACEKERNELCALLBACKS         ddSurfaceKernelCallbacks;
extern DIRECTDRAWPALETTECALLBACKS               ddPaletteCallbacks;
extern DIRECTDRAWCOLORCONTROLCALLBACKS          ddColorControlCallbacks;
extern DIRECTDRAWGAMMACONTROLCALLBACKS          ddGammaControlCallbacks;
#ifdef POSTPONED
extern NONDELEGATINGUNKNOWNCALLBACKS            ddNonDelegatingUnknownCallbacks;
extern NONDELEGATINGUNKNOWNCALLBACKS            ddUninitNonDelegatingUnknownCallbacks;
extern LPVOID NonDelegatingIUnknownInterface;
extern LPVOID UninitNonDelegatingIUnknownInterface;
#endif
extern DDVIDEOACCELERATORCONTAINERCALLBACKS     ddMotionCompContainerCallbacks;
extern DIRECTDRAWVIDEOACCELERATORCALLBACKS      ddMotionCompCallbacks;

#ifdef POSTPONED
extern DDFACTORY2CALLBACKS                      ddFactory2Callbacks;
extern DIRECTDRAWPALETTE2CALLBACKS              ddPalette2Callbacks;
extern DIRECTDRAWPALETTEPERSISTCALLBACKS        ddPalettePersistCallbacks;
extern DIRECTDRAWPALETTEPERSISTSTREAMCALLBACKS  ddPalettePersistStreamCallbacks;
extern DIRECTDRAWSURFACEPERSISTCALLBACKS        ddSurfacePersistCallbacks;
extern DIRECTDRAWSURFACEPERSISTSTREAMCALLBACKS  ddSurfacePersistStreamCallbacks;
extern DIRECTDRAWOPTSURFACECALLBACKS            ddOptSurfaceCallbacks;
#endif

#ifndef DEBUG
#define FAST_CHECKING
#endif

/*
 * VALIDEX_xxx macros are the same for debug and retail
 */
#define VALIDEX_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )

#define VALIDEX_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
        (!IsBadCodePtr( (LPVOID) ptr ) )

#define VALIDEX_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_DIRECTDRAWFACTORY2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDFACTORY2 )) && \
        (ptr->lpVtbl == &ddFactory2Callbacks) )
#define VALIDEX_DIRECTDRAW_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DIRECTDRAW_INT )) && \
        ( (ptr->lpVtbl == &ddCallbacks) || \
          (ptr->lpVtbl == &dd2Callbacks) || \
          (ptr->lpVtbl == &dd4Callbacks) || \
          (ptr->lpVtbl == &dd7Callbacks) || \
          (ptr->lpVtbl == &dd2UninitCallbacks) || \
          (ptr->lpVtbl == &dd4UninitCallbacks) || \
          (ptr->lpVtbl == &dd7UninitCallbacks) || \
          (ptr->lpVtbl == &ddVideoPortContainerCallbacks) || \
          (ptr->lpVtbl == &ddKernelCallbacks) || \
          (ptr->lpVtbl == &ddMotionCompContainerCallbacks) || \
          (ptr->lpVtbl == &ddUninitCallbacks) ) )
#define VALIDEX_DIRECTDRAWSURFACE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWSURFACE_INT )) && \
        ( (ptr->lpVtbl == &ddSurfaceCallbacks ) || \
          (ptr->lpVtbl == &ddSurface7Callbacks ) || \
          (ptr->lpVtbl == &ddSurface4Callbacks ) || \
          (ptr->lpVtbl == &ddSurface3Callbacks ) || \
          (ptr->lpVtbl == &ddSurface2Callbacks ) || \
          (ptr->lpVtbl == &ddSurfaceKernelCallbacks ) || \
          (ptr->lpVtbl == &ddColorControlCallbacks ) || \
          (ptr->lpVtbl == &ddGammaControlCallbacks ) ) )
#define VALIDEX_DIRECTDRAWPALETTE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWPALETTE_INT )) && \
        (ptr->lpVtbl == &ddPaletteCallbacks) )
#define VALIDEX_DIRECTDRAWCLIPPER_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWCLIPPER_INT )) && \
        ( (ptr->lpVtbl == &ddClipperCallbacks) || \
          (ptr->lpVtbl == &ddUninitClipperCallbacks) ) )
#define VALIDEX_DDCOLORCONTROL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDCOLORCONTROL_INT )) && \
        (ptr->lpVtbl == &ddColorControlCallbacks) )
#define VALIDEX_DDDEVICEIDENTIFIER_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER )))
#define VALIDEX_DDDEVICEIDENTIFIER2_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof( DDDEVICEIDENTIFIER2 )))


/*
 * These macros validate the size (in debug and retail) of callback
 * tables.
 *
 * NOTE: It is essential that the comparison against the current
 * callback size expected by this DirectDraw the comparison operator
 * be >= rather than ==. This is to ensure that newer drivers can run
 * against older DirectDraws.
 */
#define VALIDEX_DDCALLBACKSSIZE( ptr )                       \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ( ptr )->dwSize == DDCALLBACKSSIZE_V1   )   || \
            ( ( ptr )->dwSize >= DDCALLBACKSSIZE      ) ) )

#define VALIDEX_DDSURFACECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDSURFACECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDPALETTECALLBACKSSIZE( ptr )                \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDPALETTECALLBACKSSIZE ) )

#define VALIDEX_DDEXEBUFCALLBACKSSIZE( ptr )                 \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDEXEBUFCALLBACKSSIZE ) )

#define VALIDEX_DDVIDEOPORTCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDVIDEOPORTCALLBACKSSIZE ) )

#define VALIDEX_DDMOTIONCOMPCALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMOTIONCOMPCALLBACKSSIZE ) )

#define VALIDEX_DDCOLORCONTROLCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDCOLORCONTROLCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUSCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUSCALLBACKSSIZE ) )

#define VALIDEX_DDMISCELLANEOUS2CALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDMISCELLANEOUS2CALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS2SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( (( ptr )->dwSize >= D3DHAL_CALLBACKS2SIZE ) ))

#define VALIDEX_D3DCOMMANDBUFFERCALLBACKSSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_COMMANDBUFFERCALLBACKSSIZE ) )

#define VALIDEX_D3DCALLBACKS3SIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= D3DHAL_CALLBACKS3SIZE ) )

#define VALIDEX_DDKERNELCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDKERNELCALLBACKSSIZE ) )

#define VALIDEX_DDUMODEDRVINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDHAL_DDUMODEDRVINFOSIZE ) )
#define VALIDEX_DDOPTSURFKMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEKMODEINFOSIZE ) )

#define VALIDEX_DDOPTSURFUMODEINFOSIZE( ptr )        \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDOPTSURFACEUMODEINFOSIZE ) )

#ifndef WIN95
#define VALIDEX_DDNTCALLBACKSSIZE( ptr )           \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDNTCALLBACKSSIZE ) )

#define VALIDEX_DDVPE2CALLBACKSSIZE( ptr )              \
        ( ( ( ( ptr )->dwSize % sizeof( LPVOID ) ) == 0 ) && \
          ( ( ptr )->dwSize >= DDVPE2CALLBACKSSIZE ) )
#endif

#ifndef FAST_CHECKING
#define VALID_DIRECTDRAW_PTR( ptr )        VALIDEX_DIRECTDRAW_PTR( ptr )
#define VALID_DIRECTDRAWFACTORY2_PTR( ptr )        VALIDEX_DIRECTDRAWFACTORY2_PTR( ptr )
#define VALID_DIRECTDRAWSURFACE_PTR( ptr ) VALIDEX_DIRECTDRAWSURFACE_PTR( ptr )
#define VALID_DIRECTDRAWPALETTE_PTR( ptr ) VALIDEX_DIRECTDRAWPALETTE_PTR( ptr )
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr ) VALIDEX_DIRECTDRAWCLIPPER_PTR( ptr )
#define VALID_DDSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC )))
#define VALID_DDSURFACEDESC2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC2 ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC2 )))
#define VALID_DDVIDEOPORTDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTDESC ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTDESC )) )
#define VALID_DDVIDEOPORTCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTCAPS ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTCAPS )) )
#define VALID_DDVIDEOPORTINFO_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTINFO ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTINFO )) )
#define VALID_DDVIDEOPORTBANDWIDTH_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTBANDWIDTH ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTBANDWIDTH )) )
#define VALID_DDVIDEOPORTSTATUS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTSTATUS ) ) && \
        (ptr->dwSize == sizeof( DDVIDEOPORTSTATUS )) )
#define VALID_DDVIDEOPORTNOTIFY_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDVIDEOPORTNOTIFY ) ) )
#define VALID_DDCOLORCONTROL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCOLORCONTROL ) ) && \
        (ptr->dwSize == sizeof( DDCOLORCONTROL )) )
#define VALID_DDKERNELCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDKERNELCAPS ) ) && \
        (ptr->dwSize == sizeof( DDKERNELCAPS )) )
#define VALID_DWORD_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) ))
#define VALID_BOOL_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_HDC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HDC ) ))
#define VALID_DDPIXELFORMAT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDPIXELFORMAT ) ) && \
        (ptr->dwSize == sizeof( DDPIXELFORMAT )) )
#define VALID_DDCOLORKEY_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCOLORKEY ) ) )
#define VALID_RGNDATA_PTR( ptr, size ) \
        (!IsBadWritePtr( ptr, size ) )
#define VALID_RECT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( RECT ) ) )
#define VALID_DDBLTFX_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDBLTFX ) ) && \
        (ptr->dwSize == sizeof( DDBLTFX )) )
#define VALID_DDBLTBATCH_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDBLTBATCH ) ) )
#define VALID_DDOVERLAYFX_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDOVERLAYFX ) ) && \
        (ptr->dwSize == sizeof( DDOVERLAYFX )) )
#define VALID_DDSCAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSCAPS ) ) )
#define VALID_DDSCAPS2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSCAPS2 ) ) )
#define VALID_PTR_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
        (!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( PALETTEENTRY ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DDCORECAPS_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDCORECAPS ) ) && \
         (ptr->dwSize == sizeof( DDCORECAPS ) ) )
#define VALID_DDCAPS_PTR( ptr )                          \
         ( ( !IsBadWritePtr( ptr, sizeof( DWORD ) ) ) && \
           ( !IsBadWritePtr( ptr, ptr->dwSize     ) ) && \
           ( ( ptr->dwSize == sizeof( DDCAPS_DX1 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX3 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX5 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX6 ) ) ||  \
             ( ptr->dwSize == sizeof( DDCAPS_DX7 ) ) ) )
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt ) \
        (!IsBadReadPtr( ptr, sizeof( DDSURFACEDESC ) * cnt ) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( DWORD ) * cnt ) )
#define VALID_GUID_PTR( ptr ) \
        (!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * cnt ) )
#define VALID_PTR( ptr, size ) \
        (!IsBadReadPtr( ptr, size) )
#define VALID_DDVIDEOPORT_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDVIDEOPORT_INT )) && \
        (   (ptr->lpVtbl == &ddVideoPortCallbacks) ||              \
            (ptr->lpVtbl == &ddVideoPortNotifyCallbacks)))
#define VALID_DDOPTSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDOPTSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDOPTSURFACEDESC )))
#define VALID_DDMOTIONCOMP_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDMOTIONCOMP_INT )) && \
        (ptr->lpVtbl == &ddMotionCompCallbacks) )

#else
#define VALID_PTR( ptr, size )          1
#define VALID_DIRECTDRAW_PTR( ptr )     1
#define VALID_DIRECTDRAWFACTORY2_PTR( ptr )     1
#define VALID_DIRECTDRAWSURFACE_PTR( ptr )      1
#define VALID_DIRECTDRAWPALETTE_PTR( ptr )      1
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr )      1
#define VALID_DDSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC ))
#define VALID_DDSURFACEDESC2_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC2 ))
#define VALID_DDVIDEOPORTDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTDESC ))
#define VALID_DDVIDEOPORTCAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTCAPS ))
#define VALID_DDVIDEOPORTINFO_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTINFO ))
#define VALID_DDVIDEOPORTBANDWIDTH_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTBANDWIDTH ))
#define VALID_DDVIDEOPORTSTATUS_PTR( ptr ) (ptr->dwSize == sizeof( DDVIDEOPORTSTATUS ))
#define VALID_DDVIDEOPORTNOTIFY_PTR( ptr ) 1
#define VALID_DDCOLORCONTROL_PTR( ptr ) (ptr->dwSize == sizeof( DDCOLORCONTROL ))
#define VALID_DDKERNELCAPS_PTR( ptr) (ptr->dwSize == sizeof( DDKERNELCAPS ))
#define VALID_DWORD_PTR( ptr )  1
#define VALID_BOOL_PTR( ptr )   1
#define VALID_HDC_PTR( ptr )    1
#define VALID_DDPIXELFORMAT_PTR( ptr ) (ptr->dwSize == sizeof( DDPIXELFORMAT ))
#define VALID_DDCOLORKEY_PTR( ptr )     1
#define VALID_RGNDATA_PTR( ptr )        1
#define VALID_RECT_PTR( ptr )   1
#define VALID_DDOVERLAYFX_PTR( ptr ) (ptr->dwSize == sizeof( DDOVERLAYFX ))
#define VALID_DDBLTFX_PTR( ptr ) (ptr->dwSize == sizeof( DDBLTFX ))
#define VALID_DDBLTBATCH_PTR( ptr )     1
#define VALID_DDMASK_PTR( ptr ) 1
#define VALID_DDSCAPS_PTR( ptr )        1
#define VALID_DDSCAPS2_PTR( ptr )       1
#define VALID_PTR_PTR( ptr )    1
#define VALID_IID_PTR( ptr )    1
#define VALID_HWND_PTR( ptr )   1
#define VALID_VMEM_PTR( ptr )   1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )    1
#define VALID_HANDLE_PTR( ptr ) 1
#define VALID_DDCORECAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCORECAPS )
#define VALID_DDCAPS_PTR( ptr )                  \
    ( ( ptr->dwSize == sizeof( DDCAPS_DX1 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX3 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX5 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX6 ) ) || \
      ( ptr->dwSize == sizeof( DDCAPS_DX7 ) ) )
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt )      1
#define VALID_DWORD_ARRAY( ptr, cnt )   1
#define VALID_GUID_PTR( ptr )   1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1
#define VALID_DDVIDEOPORT_PTR( ptr ) 1
#define VALID_DDOPTSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDOPTSURFACEDESC ))
#define VALID_DDMOTIONCOMP_PTR( ptr ) 1

#endif

/*
 * All global (i.e. cross-process) values now reside in an instance of the following structure.
 * This instance is in its own shared data section.
 */

#undef GLOBALS_IN_STRUCT

#ifdef GLOBALS_IN_STRUCT
    #define GLOBAL_STORAGE_CLASS
    typedef struct
    {
#else
    #define GLOBAL_STORAGE_CLASS extern
#endif

    /*
     * This member should stay at the top in order to guarantee that it be intialized to zero
     * -see dllmain.c 's instance of this structure
     */
GLOBAL_STORAGE_CLASS    DWORD               dwRefCnt;

GLOBAL_STORAGE_CLASS    DWORD                   dwLockCount;

GLOBAL_STORAGE_CLASS    DWORD                   dwFakeCurrPid;
GLOBAL_STORAGE_CLASS    DWORD                   dwGrimReaperPid;

GLOBAL_STORAGE_CLASS    LPDDWINDOWINFO      lpWindowInfo;  // the list of WINDOWINFO structures
GLOBAL_STORAGE_CLASS    LPDDRAWI_DIRECTDRAW_INT lpDriverObjectList;
GLOBAL_STORAGE_CLASS    LPDDRAWI_DIRECTDRAW_LCL lpDriverLocalList;
GLOBAL_STORAGE_CLASS    volatile DWORD      dwMarker;
    /*
     * This is the globally maintained list of clippers not owned by any
     * DirectDraw object. All clippers created with DirectDrawClipperCreate
     * are placed on this list. Those created by IDirectDraw_CreateClipper
     * are placed on the clipper list of thier owning DirectDraw object.
     *
     * The objects on this list are NOT released when an app's DirectDraw
     * object is released. They remain alive until explictly released or
     * the app. dies.
     */
GLOBAL_STORAGE_CLASS    LPDDRAWI_DDRAWCLIPPER_INT lpGlobalClipperList;

GLOBAL_STORAGE_CLASS    HINSTANCE                   hModule;
GLOBAL_STORAGE_CLASS    LPATTACHED_PROCESSES    lpAttachedProcesses;
GLOBAL_STORAGE_CLASS    BOOL                bFirstTime;

    #ifdef DEBUG
GLOBAL_STORAGE_CLASS        int             iDLLCSCnt;
GLOBAL_STORAGE_CLASS        int             iWin16Cnt;
    #endif

        /*
         * Winnt specific global statics
         */
        /*
         *Hel globals:
         */

    // used to count how many drivers are currently using the HEL
GLOBAL_STORAGE_CLASS    DWORD               dwHELRefCnt;
#ifdef WINNT
    GLOBAL_STORAGE_CLASS  LPDCISURFACEINFO  gpdci;
#endif

#ifdef DEBUG
        // these are used by myCreateSurface
    GLOBAL_STORAGE_CLASS        int                 gcSurfMem; // surface memory in bytes
    GLOBAL_STORAGE_CLASS        int                 gcSurf;  // number of surfaces
#endif

GLOBAL_STORAGE_CLASS    DWORD               dwHelperPid;

#ifdef WINNT
GLOBAL_STORAGE_CLASS    HANDLE              hExclusiveModeMutex;
GLOBAL_STORAGE_CLASS    HANDLE              hCheckExclusiveModeMutex;
#endif

#ifdef GLOBALS_IN_STRUCT

    } GLOBALS;

    /*
     * And this is the pointer to the globals. Each process has an instance (contained in dllmain.c)
     */
    //extern GLOBALS * gp;
    extern GLOBALS g_s;
#endif //globals in struct

/*
 * IMPORTANT NOTE: This function validates the HAL information passed to us from the driver.
 * It is vital that we code this check so that we will pass HAL information structures
 * larger than the ones we know about so that new drivers can work with old DirectDraws.
 */
#define VALIDEX_DDHALINFO_PTR( ptr )                         \
        ( ( ( ( ptr )->dwSize == sizeof( DDHALINFO_V1 ) ) || \
            ( ( ptr )->dwSize == DDHALINFOSIZE_V2 )       || \
            ( ( ptr )->dwSize >= sizeof( DDHALINFO ) ) ) &&  \
          !IsBadWritePtr( ( ptr ), ( UINT ) ( ( ptr )->dwSize ) ) )

#define VALIDEX_STR_PTR( ptr, len ) \
        (!IsBadReadPtr( ptr, 1 ) && (lstrlen( ptr ) <len) )
#define VALIDEX_DDSURFACEDESC_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC )) )
#define VALIDEX_DDSURFACEDESC2_PTR( ptr ) \
        (!IsBadWritePtr( ptr, sizeof( DDSURFACEDESC2 ) ) && \
        (ptr->dwSize == sizeof( DDSURFACEDESC2 )) )


// Internal flags required to create special DX8 surfaces

#define DX8SFLAG_DX8                0x00000001
#define DX8SFLAG_ISLOST             0x00000002
#define DX8SFLAG_ISLIGHTWEIGHT      0x00000004
#define DX8SFLAG_IMAGESURF          0x00000008

/* Turn on D3D stats collection for Debug builds HERE */
#define COLLECTSTATS    DBG

#ifdef __cplusplus
}       // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddrefrsh.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddrefrsh.c
 *  Content:	DirectDraw Refresh Rate support
 *
 *              On Win98, we don't have detailed information regarding what
 *              refresh rates the montor supports.  We can get some information
 *              from the monitor (EDID data), but we cannot absolutely rely on
 *              it, so we require that the user manually verify each refresh 
 *              rate before we allow it to be used.
 *		
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   02-apr-99	smac	Created it
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "edid.h"

#undef DPF_MODNAME
#define DPF_MODNAME "Refresh"

#ifdef WIN95

static WORD SupportedRefreshRates[] = {60, 75, 85, 100, 120};
#define NUM_SUPPORTED_REFRESH_RATES ( sizeof( SupportedRefreshRates ) / sizeof( WORD ) )


/*
 * GetEDIDData
 */
HRESULT GetEDIDData( LPDDRAWI_DIRECTDRAW_GBL pddd, VESA_EDID * pEDIDData )
{
    memset( pEDIDData, 0, sizeof( VESA_EDID ) );
    if( DD16_GetMonitorEDIDData( pddd->cDriverName, (LPVOID)pEDIDData) )
    {
        return DD_OK;
    }

    if( !( pddd->dwFlags & DDRAWI_DISPLAYDRV ) )
    {
        // HACK: Use primary display EDID data for passthrough devices
        if( DD16_GetMonitorEDIDData( g_szPrimaryDisplay, (LPVOID)pEDIDData) )
        {
            return DD_OK;
        }
    }

    return DDERR_UNSUPPORTED;
}


/*
 * CheckEdidBandiwdth
 *
 * Takes a resoltion/refrsh rate and calculates the bandwidth required for 
 * this, and then updates lpHighestRefresh and lpHighestBandwidth to keep
 * track of the highest refresh rate and badnwidth info that we've encountered.
 */
void CheckEdidBandwidth( DWORD dwWidth, DWORD dwHeight, DWORD dwRefreshRate,
                         LPDWORD lpHighestRefresh, LPDWORD lpHighestBandwidth )
{
    DWORD dwBandwidth;

    dwBandwidth = dwWidth * dwHeight * dwRefreshRate;
    if( dwBandwidth > *lpHighestBandwidth )
    {
        *lpHighestBandwidth = dwBandwidth;
    }
    if( dwRefreshRate > *lpHighestRefresh )
    {
        *lpHighestRefresh = dwRefreshRate;
    }
}
         

/*
 * StdTimeXRES
 */
int StdTimeXRES(WORD StdTime)
{
    if (StdTime == 0 || StdTime == 0x0101)
        return 0;
    else
        return ((StdTime & veStdTime_HorzResMask) + 31) * 8;
}


/*
 * StdTimeYRES
 */
int StdTimeYRES(WORD StdTime)
{
    if (StdTime == 0 || StdTime == 0x0101)
        return 0;

    switch (StdTime & veStdTime_AspectRatioMask)
    {
        case veStdTime_AspectRatio1to1:  return StdTimeXRES(StdTime);
        case veStdTime_AspectRatio4to3:  return StdTimeXRES(StdTime) * 3 / 4;
        case veStdTime_AspectRatio5to4:  return StdTimeXRES(StdTime) * 4 / 5;
        case veStdTime_AspectRatio16to9: return StdTimeXRES(StdTime) * 9 / 16;
    }
    return 0;
}


/*
 * StdTimeRATE
 */
int StdTimeRATE(WORD StdTime)
{
    if (StdTime == 0 || StdTime == 0x0101)
        return 0;
    else
        return ((StdTime & veStdTime_RefreshRateMask) >> 8) + 60;
}


__inline UINT DetTimeXRES(BYTE *DetTime)
{
    return (UINT)DetTime[2] + (((UINT)DetTime[4] & 0xF0) << 4);
}

__inline UINT DetTimeYRES(BYTE *DetTime)
{
    return (UINT)DetTime[5] + (((UINT)DetTime[7] & 0xF0) << 4);
}

__inline UINT DetTimeXBLANK(BYTE *DetTime)
{
    return (UINT)DetTime[3] + (((UINT)DetTime[4] & 0x0F) << 4);
}

__inline UINT DetTimeYBLANK(BYTE *DetTime)
{
    return (UINT)DetTime[6] + (((UINT)DetTime[7] & 0x0F) << 0);
}

int DetTimeRATE(BYTE *DetTime)
{
    ULONG clk;
    ULONG x;
    ULONG y;

    clk = *(WORD*)DetTime;
    x = DetTimeXRES(DetTime) + DetTimeXBLANK(DetTime);
    y = DetTimeYRES(DetTime) + DetTimeYBLANK(DetTime);

    if (clk == 0 || x == 0 || y == 0)
        return 0;

    return (int)((clk * 10000) / (x * y));
}


/*
 * GetDetailedTime
 */
void GetDetailedTime(BYTE *DetTime, LPDWORD lpHighestRefresh, LPDWORD lpHighestBandwidth )
{
    char ach[14];
    int i;
    DWORD dw;

    dw = *(DWORD *)DetTime;

    if( dw == 0xFD000000 )       // Monitor limits
    {
        if( (DWORD)(DetTime[6]) > *lpHighestRefresh )
        {
            *lpHighestRefresh = (DWORD)(DetTime[6]);
        }
    }
    else if (dw == 0xFA000000)       // more standard timings
    {
        WORD * StdTime = (WORD *)&DetTime[5];

        CheckEdidBandwidth( StdTimeXRES( StdTime[0] ),
            StdTimeYRES( StdTime[0] ),
            StdTimeRATE( StdTime[0] ),
            lpHighestRefresh, lpHighestBandwidth );
        CheckEdidBandwidth( StdTimeXRES( StdTime[1] ),
            StdTimeYRES( StdTime[1] ),
            StdTimeRATE( StdTime[1] ),
            lpHighestRefresh, lpHighestBandwidth );
        CheckEdidBandwidth( StdTimeXRES( StdTime[2] ),
            StdTimeYRES( StdTime[2] ),
            StdTimeRATE( StdTime[2] ),
            lpHighestRefresh, lpHighestBandwidth );
        CheckEdidBandwidth( StdTimeXRES( StdTime[3] ),
            StdTimeYRES( StdTime[3] ),
            StdTimeRATE( StdTime[3] ),
            lpHighestRefresh, lpHighestBandwidth );
        CheckEdidBandwidth( StdTimeXRES( StdTime[4] ),
            StdTimeYRES( StdTime[4] ),
            StdTimeRATE( StdTime[4] ),
            lpHighestRefresh, lpHighestBandwidth );
        CheckEdidBandwidth( StdTimeXRES( StdTime[5] ),
            StdTimeYRES( StdTime[5] ),
            StdTimeRATE( StdTime[5] ),
            lpHighestRefresh, lpHighestBandwidth );
    }
    else if( ( dw != 0xFF000000 ) &&      // Serial number
             ( dw != 0xFE000000 ) &&      // Monitor String
             ( dw != 0xFC000000 ) &&      // Monitor Name
             ( dw != 0xFB000000 ) &&      // ColorPoint data
             ( DetTimeRATE( DetTime) ) )
    {
        CheckEdidBandwidth( DetTimeXRES( DetTime ),
            DetTimeYRES( DetTime ),
            DetTimeRATE( DetTime ),
            lpHighestRefresh, lpHighestBandwidth );
    }
}


/*
 * EvaluateMonitor
 *
 * Determines the amount of bandwidth that the monitor can handle.
 */
void EvaluateMonitor( VESA_EDID *lpEdidData, DWORD *lpHighestRefresh, DWORD *lpHighestBandwidth )
{
    BYTE chk;
    int i;

    *lpHighestRefresh = 0;
    *lpHighestBandwidth = 0;

    /*
     * Do some sanity checking to make sure that the EDID data looks sane
     */

    for( chk = i = 0; i < 128; i++)
    {
        chk += ((BYTE *)lpEdidData)[i];
    }
    if (chk != 0)
    {
        // Bad checksum
        return;
    }

    /*
     * First get the bandwidth from the established timings
     */
    if( lpEdidData->veEstTime1 & veEstTime1_720x400x70Hz)
    {
        CheckEdidBandwidth( 720, 400, 70, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_720x400x88Hz)
    {
        CheckEdidBandwidth( 720, 400, 88, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_640x480x60Hz)
    {
        CheckEdidBandwidth( 640, 480, 60, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_640x480x67Hz)
    {
        CheckEdidBandwidth( 640, 480, 67, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_640x480x72Hz)
    {
        CheckEdidBandwidth( 640, 480, 72, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_640x480x75Hz)
    {
        CheckEdidBandwidth( 640, 480, 75, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime1 & veEstTime1_800x600x60Hz)
    {
        CheckEdidBandwidth( 800, 600, 60, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_800x600x72Hz)
    {
        CheckEdidBandwidth( 800, 600, 72, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_800x600x75Hz)
    {
        CheckEdidBandwidth( 800, 600, 75, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_1024x768x60Hz)
    {
        CheckEdidBandwidth( 1024, 768, 60, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_1024x768x70Hz)
    {
        CheckEdidBandwidth( 1024, 768, 70, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_1024x768x75Hz)
    {
        CheckEdidBandwidth( 1024, 768, 75, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime2 & veEstTime2_1280x1024x75Hz)
    {
        CheckEdidBandwidth( 1280, 1024, 75, lpHighestRefresh, lpHighestBandwidth );
    }
    if( lpEdidData->veEstTime3 & veEstTime3_1152x870x75Hz)
    {
        CheckEdidBandwidth( 1152, 870, 75, lpHighestRefresh, lpHighestBandwidth );
    }

    /*
     * Now get the bandwidth from the standard timings
     */
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID1 ),
        StdTimeYRES( lpEdidData->veStdTimeID1 ),
        StdTimeRATE( lpEdidData->veStdTimeID1 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID2 ),
        StdTimeYRES( lpEdidData->veStdTimeID2 ),
        StdTimeRATE( lpEdidData->veStdTimeID2 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID3 ),
        StdTimeYRES( lpEdidData->veStdTimeID3 ),
        StdTimeRATE( lpEdidData->veStdTimeID3 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID4 ),
        StdTimeYRES( lpEdidData->veStdTimeID4 ),
        StdTimeRATE( lpEdidData->veStdTimeID4 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID5 ),
        StdTimeYRES( lpEdidData->veStdTimeID5 ),
        StdTimeRATE( lpEdidData->veStdTimeID5 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID6 ),
        StdTimeYRES( lpEdidData->veStdTimeID6 ),
        StdTimeRATE( lpEdidData->veStdTimeID6 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID7 ),
        StdTimeYRES( lpEdidData->veStdTimeID7 ),
        StdTimeRATE( lpEdidData->veStdTimeID7 ),
        lpHighestRefresh, lpHighestBandwidth );
    CheckEdidBandwidth( StdTimeXRES( lpEdidData->veStdTimeID8 ),
        StdTimeYRES( lpEdidData->veStdTimeID8 ),
        StdTimeRATE( lpEdidData->veStdTimeID8 ),
        lpHighestRefresh, lpHighestBandwidth );

    /*
     * Now get the detailed timing information
     */
    GetDetailedTime( lpEdidData->veDetailTime1, lpHighestRefresh, lpHighestBandwidth );
    GetDetailedTime( lpEdidData->veDetailTime2, lpHighestRefresh, lpHighestBandwidth );
    GetDetailedTime( lpEdidData->veDetailTime3, lpHighestRefresh, lpHighestBandwidth );
    GetDetailedTime( lpEdidData->veDetailTime4, lpHighestRefresh, lpHighestBandwidth );
}


//=============================================================================
//
// Function Description:
//
//   Finds an item in a registry-based most recently used (MRU) list, and
//   either retrieves the contents of that item, or updates (add if it doesn't
//   exist) the item.
//
// Arguments:
//
//   [IN/OUT] item - Contains at least the unique portion of the item to
//                   search for [IN/OUT]. If writing the item, should contain
//                   the entire item [IN].
//   [IN] writeItem - Set to TRUE if updating/adding an item to the MRU list.
//
// Return Value:
//
//   TRUE - If writeItem is TRUE, then the item was written to the registry.
//          Otherwise the item was found and its contents stored in findItem.
//   FALSE - Failure; no more information available.
//
// Created:
//
//   04/08/1999 johnstep
//
//=============================================================================

//-----------------------------------------------------------------------------
// Define global MRU list values here, for simplicity:
//
//   gMruRegKey - Registry key where MRU list is stored
//   gMruRegOrderValue - Name of MRU list order value
//   gMruBaseChar - Base index into MRU list
//   gMruMaxChar - Maximum index into MRU list
//   gMruItemSize - Size of findItem.
//   gMruUniqueOffset - Offset of unique portion of item. This unique portion
//                      is what will be used to compare items.
//   gMruUniqueSize - Size of unique portion of item.
//-----------------------------------------------------------------------------

static const CHAR *gMruRegKey =
    REGSTR_PATH_DDRAW "\\" REGSTR_KEY_RECENTMONITORS;
static const CHAR *gMruRegOrderValue = REGSTR_VAL_DDRAW_MONITORSORDER;
#define gMruBaseChar '0'
#define gMruMaxChar '9'
#define gMruItemSize sizeof (DDMONITORINFO)
#define gMruUniqueOffset 0
#define gMruUniqueSize offsetof(DDMONITORINFO, Mode640x480)

BOOL
MruList(
    VOID *item,
    const BOOL writeItem
    )
{
    BOOL success = FALSE;
    HKEY hkey;

    // Create or open the root key, with permission to query and set values;
    // only continue if successful:
    
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, gMruRegKey,
        0, NULL, 0, KEY_QUERY_VALUE | KEY_SET_VALUE,
        NULL, &hkey, NULL) == ERROR_SUCCESS)
    {
        CHAR mruOrder[gMruMaxChar - gMruBaseChar + 2];
        DWORD type;
        DWORD count = sizeof mruOrder;
        UINT i;

        {
            CHAR temp[sizeof mruOrder];

            // If we read the order value successfully, copy the valid chars
            // into mruOrder, removing duplicates:
        
            if (RegQueryValueEx(hkey, gMruRegOrderValue, NULL, &type,
                (BYTE *) temp, &count) == ERROR_SUCCESS)
            {
                UINT j = 0;

                for (--count, i = 0; i < count; i++)
                {
                    if ((temp[i] >= gMruBaseChar) &&
                        (temp[i] <= gMruMaxChar))
                    {
                        UINT k;

                        for (k = 0; k < j; k++)
                        {
                            if (mruOrder[k] == temp[i])
                            {
                                break;
                            }
                        }
                        if (k == j)
                        {
                            mruOrder[j++] = temp[i];
                        }
                    }
                }
                count = j;
            }
            else
            {
                count = 0;
            }
        }

        // Only continue if we found at least one valid value in the order
        // list, or if we're writing the item:
        
        if ((count > 0) || writeItem)
        {
            CHAR regValue[2];
            BYTE regItem[gMruItemSize];

            regValue[1] = '\0';

            // Search for the item in the MRU list:
            
            for (i = 0; i < count; i++)
            {
                DWORD size = sizeof regItem;

                regValue[0] = mruOrder[i];

                if ((RegQueryValueEx(hkey, regValue, NULL, &type,
                    (BYTE *) &regItem, &size) == ERROR_SUCCESS) &&
                    (size == sizeof regItem))
                {
                    if (memcmp(
                        (BYTE *) &regItem + gMruUniqueOffset,
                        (BYTE *) item + gMruUniqueOffset,
                        gMruUniqueSize) == 0)
                    {
                        break;
                    }
                }
            }

            // Keep going if we found the item or in any case if we need to
            // write the item:
            
            if ((i < count) || writeItem)
            {
                UINT j;

                // If we didn't find the item, then we must be writing, so
                // adjust the index appropriately. If the list is already
                // full, we just use the last item (LRU item), otherwise, add
                // a new item:
                
                if (i == count)
                {
                    if (count == (gMruMaxChar - gMruBaseChar + 1))
                    {
                        i--;
                    }
                    else
                    {
                        // Adding a new item; search for the lowest unused
                        // valid char:

                        for (mruOrder[i] = gMruBaseChar;
                             mruOrder[i] < gMruMaxChar;
                             mruOrder[i]++)
                        {
                            for (j = 0; j < i; j++)
                            {
                                if (mruOrder[j] == mruOrder[i])
                                {
                                    break;
                                }
                            }
                            if (j == i)
                            {
                                break;
                            }
                        }
                        count++;
                    }
                }
            
                // Update the MRU order list if necessary. We update if we
                // found or are adding an item after the first, or if this is
                // the first item in the list:
                
                if (i > 0 || (count == 1))
                {
                    // Bubble found item to head of order list:

                    for (j = i; j > 0; j--)
                    {
                        CHAR temp = mruOrder[j];
                        mruOrder[j] = mruOrder[j - 1];
                        mruOrder[j - 1] = temp;
                    }

                    // Write the order list:
                    
                    mruOrder[count] = '\0';
                    RegSetValueEx(hkey, gMruRegOrderValue, 0,
                        REG_SZ, (BYTE *) mruOrder, count + 1);
                }

                // If we want to write the item, do it now. We will always
                // write to the first item in the order list. If not writing,
                // copy what was read from the registry into item:
                
                if (writeItem)
                {
                    regValue[0] = mruOrder[0];
                    if (RegSetValueEx(hkey, regValue, 0,
                        REG_BINARY, (BYTE *) item, sizeof regItem) ==
                        ERROR_SUCCESS)
                    {
                        success = TRUE;
                    }
                }
                else
                {
                    memcpy(
                        (BYTE *) item + gMruUniqueOffset,
                        regItem + gMruUniqueOffset,
                        sizeof regItem);

                    success = TRUE;
                }
            }
        }

        // Always close the registry key when finished:
        
        RegCloseKey(hkey);
    }

    return success;
}

//-----------------------------------------------------------------------------


/*
 * DDSaveMonitorInfo
 * 
 * Writes the monitor info to the registry.
 */
HRESULT DDSaveMonitorInfo( LPDDRAWI_DIRECTDRAW_INT lpDD_int )
{
    return MruList( (VOID *) lpDD_int->lpLcl->lpGbl->lpMonitorInfo, TRUE ) ?
        DD_OK : DDERR_GENERIC;
}


__inline IsValidRefreshRate( DWORD dwWidth, DWORD dwHeight, int refreshRate,
                             DWORD dwHighestBandwidth )
{
    return
        ( ( refreshRate >= 0 ) &&
        ( ( dwWidth * dwHeight * (DWORD) refreshRate ) <= dwHighestBandwidth ) );
}


/*
 * DDGetMonitorInfo
 * 
 * Reads the monitor info from the registry and verifies that it still applies.
 */
HRESULT DDGetMonitorInfo( 
                LPDDRAWI_DIRECTDRAW_INT lpDD_int )
{
    LPDDMONITORINFO pInfo;
    static DDDEVICEIDENTIFIER DeviceIdentifier;
    HRESULT hr;

    if( ( lpDD_int->lpVtbl == &dd7Callbacks ) &&
        ( lpDD_int->lpLcl->lpGbl->lpMonitorInfo == NULL ) )
    {
        VESA_EDID EDIDData;
        DWORD dwHighestRefresh;
        DWORD dwHighestBandwidth;
        HKEY hKey;
        BOOL bGotLastMonitor = FALSE;

        hr = GetEDIDData( lpDD_int->lpLcl->lpGbl, &EDIDData );
        if( hr != DD_OK )
        {
            // There is no EDID data
            return DDERR_GENERIC;
        }
        EvaluateMonitor( &EDIDData, &dwHighestRefresh, &dwHighestBandwidth );

        hr = DD_GetDeviceIdentifier( (LPDIRECTDRAW) lpDD_int, &DeviceIdentifier, 0 );
        if( hr != DD_OK )
        {
            // Failed to get device identifier for monitor info
            return hr;
        }

        pInfo = (LPDDMONITORINFO) MemAlloc( sizeof( DDMONITORINFO ) );
        if( pInfo == NULL )
        {
            // Out of memory allocating monitor info structure
            return DDERR_OUTOFMEMORY;
        }

        pInfo->Manufacturer = *(WORD *)&EDIDData.veManufactID[0];
        pInfo->Product = *(WORD *)&EDIDData.veProductCode[0];
        pInfo->SerialNumber = EDIDData.veSerialNbr;
        pInfo->DeviceIdentifier = DeviceIdentifier.guidDeviceIdentifier;

        // Read monitor information from registry, if available. We need to
        // compare this to the EDID data to see if the monitor or adapter
        // changed and verify the selected refresh rates are sane:
    
        if( MruList( (VOID *) pInfo, FALSE ) )
        {
            // Validate modes here against EDID data:

            if( !IsValidRefreshRate( 640, 480,
                pInfo->Mode640x480, dwHighestBandwidth ) )
            {
                pInfo->Mode640x480 = -1;
            }
    
            if( !IsValidRefreshRate( 800, 600,
                pInfo->Mode800x600, dwHighestBandwidth ) )
            {
                pInfo->Mode800x600 = -1;
            }
    
            if( !IsValidRefreshRate( 1024, 768,
                pInfo->Mode1024x768, dwHighestBandwidth ) )
            {
                pInfo->Mode1024x768 = -1;
            }
    
            if( !IsValidRefreshRate( 1280, 1024,
                pInfo->Mode1280x1024, dwHighestBandwidth ) )
            {
                pInfo->Mode1280x1024 = -1;
            }
    
            if( !IsValidRefreshRate( 1600, 1200,
                pInfo->Mode1600x1200, dwHighestBandwidth ) )
            {
                pInfo->Mode1600x1200 = -1;
            }
    
            bGotLastMonitor = TRUE;
        }
    
        if( !bGotLastMonitor )
        {
            pInfo->Mode640x480 = -1;
            pInfo->Mode800x600 = -1;
            pInfo->Mode1024x768 = -1;
            pInfo->Mode1280x1024 = -1;
            pInfo->Mode1600x1200 = -1;
        }

        pInfo->ModeReserved1 = -1;
        pInfo->ModeReserved2 = -1;
        pInfo->ModeReserved3 = -1;

        lpDD_int->lpLcl->lpGbl->lpMonitorInfo = pInfo;
    }
    return DD_OK;
}


/*
 * ExpandModeTable
 * 
 * On Win9X, drivers can specify their maximum refresh rate for each mode, 
 * allowing DDraw to add modes for each refresh rate that we care about.
 * This allows drivers to add refresh rate easily without having to 
 * maintain huge tables.  This also allows us to avoid regressions by allowing
 * us to only enumerate these refresh rates on newer interfaces.
 */
HRESULT ExpandModeTable( LPDDRAWI_DIRECTDRAW_GBL pddd )
{
    DWORD i;
    DWORD j;
    DWORD iNumModes = 0;
    LPDDHALMODEINFO pNewModeTable;
    DWORD iModeIndex;
    WORD wMaxRefresh;

    /*
     * Count the number of entries that we'll need
     */
    if( pddd->lpModeInfo != NULL )
    {
        for( i = 0; i < pddd->dwNumModes;  i++ )
        {
            iNumModes++;
            if( pddd->lpModeInfo[i].wFlags & DDMODEINFO_MAXREFRESH )
            {
                for( j = 0; j < NUM_SUPPORTED_REFRESH_RATES; j++ )
                {
                    if( SupportedRefreshRates[j] <= pddd->lpModeInfo[i].wRefreshRate )
                    {
                        iNumModes++;
                    }
                }
            }
        }

        if( iNumModes > pddd->dwNumModes )
        {
            /*
             * We do have to add modes and allocate a new table
             */
            pNewModeTable = (LPDDHALMODEINFO) MemAlloc( sizeof( DDHALMODEINFO ) * iNumModes );
            if( pNewModeTable == NULL )
            {
                /*
                 * Instead of failing here, we'll just clear all of the MAXREFRESHRATE
                 * flags and set the rate to 0.
                 */
                for( i = 0; i < pddd->dwNumModes; i++ )
                {
                    if( pddd->lpModeInfo[i].wFlags & DDMODEINFO_MAXREFRESH )
                    {
                        pddd->lpModeInfo[i].wFlags &= ~DDMODEINFO_MAXREFRESH;
                        pddd->lpModeInfo[i].wRefreshRate = 0;
                    }
                }
            }
            else
            {
                memcpy( pNewModeTable, pddd->lpModeInfo, pddd->dwNumModes * sizeof( DDHALMODEINFO ) );

                /*
                 * Now add the new refresh rates
                 */
                iModeIndex = pddd->dwNumModes;
                for( i = 0; i < pddd->dwNumModes; i++ )
                {
                    if( pddd->lpModeInfo[i].wFlags & DDMODEINFO_MAXREFRESH )
                    {
                        pNewModeTable[i].wFlags &= ~DDMODEINFO_MAXREFRESH;
                        wMaxRefresh = pNewModeTable[i].wRefreshRate;
                        pNewModeTable[i].wRefreshRate = 0;

                        for( j = 0; j < NUM_SUPPORTED_REFRESH_RATES; j++ )
                        {
                            if( SupportedRefreshRates[j] <= wMaxRefresh )
                            {
                                memcpy( &(pNewModeTable[iModeIndex]), &(pNewModeTable[i]), sizeof( DDHALMODEINFO ) );
                                pNewModeTable[iModeIndex].wFlags |= DDMODEINFO_DX7ONLY;
                                pNewModeTable[iModeIndex++].wRefreshRate = SupportedRefreshRates[j];
                            }
                        }
                    }
                }

                MemFree( pddd->lpModeInfo );
                pddd->lpModeInfo = pNewModeTable;
                pddd->dwNumModes = iModeIndex;
            }
        }
    }

    return DD_OK;
}


/*
 * CanMonitorHandleRefreshRate
 * 
 * Has the specified refresh rate been tested and verified that it works?
 */
BOOL CanMonitorHandleRefreshRate( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight, int wRefresh )
{
    if( wRefresh == 0 )
    {
        return TRUE;
    }

    if( pddd->lpMonitorInfo == NULL )
    {
        return FALSE;
    }

    /*
     * If we are setting this mode because we are testing it, then we should
     * allow it so the user can verify whether it worked or not.
     */
    if( pddd->dwFlags & DDRAWI_TESTINGMODES )
    {
        return TRUE;
    }

    if( ( dwWidth <= 640 ) && ( dwHeight <= 480 ) )
    {
        if( pddd->lpMonitorInfo->Mode640x480 >= wRefresh )
        {
            return TRUE;
        }
    }

    if( ( dwWidth <= 800 ) && ( dwHeight <= 600 ) )
    {
        if( pddd->lpMonitorInfo->Mode800x600 >= wRefresh )
        {
            return TRUE;
        }
    }

    if( ( dwWidth <= 1024 ) && ( dwHeight <= 768 ) )
    {
        if( pddd->lpMonitorInfo->Mode1024x768 >= wRefresh )
        {
            return TRUE;
        }
    }

    if( ( dwWidth <= 1280 ) && ( dwHeight <= 1024 ) )
    {
        if( pddd->lpMonitorInfo->Mode1280x1024 >= wRefresh )
        {
            return TRUE;
        }
    }

    if( ( dwWidth <= 1600 ) && ( dwHeight <= 1200 ) )
    {
        if( pddd->lpMonitorInfo->Mode1600x1200 >= wRefresh )
        {
            return TRUE;
        }
    }

    return FALSE;
}


/*
 * IsModeTested
 *
 * Determines if we already have data for the requested mode.
 */
BOOL IsModeTested( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight )
{
    if( pddd->lpMonitorInfo == NULL )
    {
        return FALSE;
    }

    if( ( dwWidth <= 640 ) && ( dwHeight <= 480 ) )
    {
        if( pddd->lpMonitorInfo->Mode640x480 != -1 )
        {
            return TRUE;
        }
    }

    else if( ( dwWidth <= 800 ) && ( dwHeight <= 600 ) )
    {
        if( pddd->lpMonitorInfo->Mode800x600 != -1 )
        {
            return TRUE;
        }
    }

    else if( ( dwWidth <= 1024 ) && ( dwHeight <= 768 ) )
    {
        if( pddd->lpMonitorInfo->Mode1024x768 != -1 )
        {
            return TRUE;
        }
    }

    else if( ( dwWidth <= 1280 ) && ( dwHeight <= 1024 ) )
    {
        if( pddd->lpMonitorInfo->Mode1280x1024 != -1 )
        {
            return TRUE;
        }
    }

    else if( ( dwWidth <= 1600 ) && ( dwHeight <= 1200 ) )
    {
        if( pddd->lpMonitorInfo->Mode1600x1200 != -1 )
        {
            return TRUE;
        }
    }

    return FALSE;
}


/*
 * UpdateMonitorInfo
 */
void UpdateMonitorInfo( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight, int iRefreshRate )
{
    if( pddd->lpMonitorInfo == NULL )
    {
        return;
    }

    if( ( dwWidth <= 640 ) && ( dwHeight <= 480 ) )
    {
        pddd->lpMonitorInfo->Mode640x480 = iRefreshRate;
    }

    else if( ( dwWidth <= 800 ) && ( dwHeight <= 600 ) )
    {
        pddd->lpMonitorInfo->Mode800x600 = iRefreshRate;
    }

    else if( ( dwWidth <= 1024 ) && ( dwHeight <= 768 ) )
    {
        pddd->lpMonitorInfo->Mode1024x768 = iRefreshRate;
    }

    else if( ( dwWidth <= 1280 ) && ( dwHeight <= 1024 ) )
    {
        pddd->lpMonitorInfo->Mode1280x1024 = iRefreshRate;
    }

    else if( ( dwWidth <= 1600 ) && ( dwHeight <= 1200 ) )
    {
        pddd->lpMonitorInfo->Mode1600x1200 = iRefreshRate;
    }
}


/*
 * GetModeToTest
 */
HRESULT GetModeToTest( DWORD dwInWidth, DWORD dwInHeight, 
                       LPDWORD lpdwOutWidth, LPDWORD lpdwOutHeight )
{
    if( ( dwInWidth <= 640 ) && ( dwInHeight <= 480 ) )
    {
        *lpdwOutWidth = 640;
        *lpdwOutHeight = 480;
    }

    else if( ( dwInWidth <= 800 ) && ( dwInHeight <= 600 ) )
    {
        *lpdwOutWidth = 800;
        *lpdwOutHeight = 600;
    }

    else if( ( dwInWidth <= 1024 ) && ( dwInHeight <= 768 ) )
    {
        *lpdwOutWidth = 1024;
        *lpdwOutHeight = 768;
    }

    else if( ( dwInWidth <= 1280 ) && ( dwInHeight <= 1024 ) )
    {
        *lpdwOutWidth = 1280;
        *lpdwOutHeight = 1024;
    }

    else if( ( dwInWidth <= 1600 ) && ( dwInHeight <= 1200 ) )
    {
        *lpdwOutWidth = 1600;
        *lpdwOutHeight = 1200;
    }
    else
    {
        return DDERR_GENERIC;
    }

    return DD_OK;
}


/*
 * GuestimateRefreshRate
 */
int GuestimateRefreshRate( LPDDRAWI_DIRECTDRAW_GBL pddd, DWORD dwWidth, DWORD dwHeight,
                           DWORD dwHighestRefresh, DWORD dwHighestBandwidth )
{
    int i;
    DWORD dwBandwidth;

    if( ( pddd->lpMonitorInfo == NULL ) ||
        ( dwHighestRefresh == 0 ) )
    {
        return 0;
    }

    // Sanity check to see if the monitor can handle the resolution

    if( !MonitorCanHandleMode( pddd, dwWidth, dwHeight, 0 ) )
    {
        return 0;
    }

    // If the monitor did not return any refresh rates higher than 60,
    // something is up so we'd better stick to it.

    if( dwHighestRefresh == 60 )
    {
        return 60;
    }

    // Likwise, we will only go after the 100+ refresh rates if the monitor
    // enumerated a refresh rate of at least 85hz.  This may be an unnecesary
    // restiction, but it seems safe.

    for( i = NUM_SUPPORTED_REFRESH_RATES - 1; i >= 0; i-- )
    {
        if( ( SupportedRefreshRates[i] <= 85 ) ||
            ( dwHighestRefresh >= 85 ) )
        {
            dwBandwidth = dwWidth * dwHeight * SupportedRefreshRates[i];
            if( dwBandwidth <= dwHighestBandwidth )
            {
                return SupportedRefreshRates[i];
            }
        }
    }

    return 0;
}


/*
 * SetTheMode
 */
HRESULT SetTheMode( LPDIRECTDRAW7 lpDD, LPMODETESTCONTEXT pContext )
{
    HRESULT hr;
    DWORD dwBPP;

    /*
     * We set an internal flag indicating that we are running a mode test.
     * This lets CanMonitorHandleRefreshRate know that the requested mode
     * should be used, even though it hasb't successfully been tested yet.
     */
    ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl->dwFlags |= DDRAWI_TESTINGMODES;

    //
    // There might be a case in which we decided that the lowest BPP the driver
    // could do for this mode was, say, 8bpp. But that didn't take into consideration
    // what rates the driver said it could do. E.g. if the driver (for whatever 
    // reason) doesn't advertise 8bpp at 60Hz, but DOES advertise 16bpp at 60Hz
    // then we can go ahead and use the 16bpp mode. We are here to test monitor
    // bandwidth, not the DAC. The monitor's bandwidth is entirely determined
    // by the spatial resolution and refresh rate. If we bump the driver to 
    // a higher BPP (one that it says it can do), then we are still testing 
    // the correct monitor setup.
    // We do this in a really dumb way: just keep cranking up from the lowest BPP
    // (which is in the context mode list) in steps of 8 until we succeed the
    // mode change, or exceed 32bpp.
    //
    dwBPP = pContext->lpModeList[pContext->dwCurrentMode].dwBPP;
    do
    {
        hr = DD_SetDisplayMode2( (LPDIRECTDRAW)lpDD,
                pContext->lpModeList[pContext->dwCurrentMode].dwWidth,
                pContext->lpModeList[pContext->dwCurrentMode].dwHeight,
                dwBPP,
                pContext->lpModeList[pContext->dwCurrentMode].dwRefreshRate,
                DDSDM_STANDARDVGAMODE );

        dwBPP += 8;
    } while(FAILED(hr) && (dwBPP <= 32) );

    ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl->dwFlags &= ~DDRAWI_TESTINGMODES;

    return hr;
}


/*
 * SetupNextTest
 */
void SetupNextTest( LPDIRECTDRAW7 lpDD, LPMODETESTCONTEXT pContext )
{
    int i;
    
    /*
     * Drop back to the next refrsh rate if there is one, otherwise
     * move on to the next mode.
     */
    for( i = NUM_SUPPORTED_REFRESH_RATES - 1; i >= 0; i-- )
    {
        if( SupportedRefreshRates[i] < 
            pContext->lpModeList[pContext->dwCurrentMode].dwRefreshRate )
        {
            pContext->lpModeList[pContext->dwCurrentMode].dwRefreshRate =
                SupportedRefreshRates[i];
            break;
        }
    }
    if( i < 0 )
    {
        // We've tried everything in this mode, so move on

        UpdateMonitorInfo( ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl, 
            pContext->lpModeList[pContext->dwCurrentMode].dwWidth,
            pContext->lpModeList[pContext->dwCurrentMode].dwHeight,
            0 );

        pContext->dwCurrentMode++;
    }
}


/*
 * RunNextTest
 */
HRESULT RunNextTest( LPDIRECTDRAW7 lpDD, LPMODETESTCONTEXT pContext )
{
    HRESULT hr;
    LPDDRAWI_DIRECTDRAW_GBL pddd;

    do
    {
        if( pContext->dwCurrentMode >= pContext->dwNumModes )
        {
            // Restore the mode if we've changed it

            pddd = ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl;
            if( pContext->dwOrigModeIndex != pddd->dwModeIndex )
            {
                DD_SetDisplayMode2( (LPDIRECTDRAW)lpDD,
                    pddd->lpModeInfo[pContext->dwOrigModeIndex].dwWidth,
                    pddd->lpModeInfo[pContext->dwOrigModeIndex].dwHeight,
                    pddd->lpModeInfo[pContext->dwOrigModeIndex].dwBPP,
                    pddd->lpModeInfo[pContext->dwOrigModeIndex].wRefreshRate,
                    0 );
            }

            DDSaveMonitorInfo( (LPDDRAWI_DIRECTDRAW_INT)lpDD );

            MemFree( pContext->lpModeList );
            MemFree( pContext );
            ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpModeTestContext = NULL;

            return DDERR_TESTFINISHED;
        }
        hr = SetTheMode( lpDD, pContext );
        if( hr != DD_OK )
        {
            SetupNextTest( lpDD, pContext );
        }
    } while( ( hr != DD_OK ) && (hr != DDERR_TESTFINISHED ) );

    if( hr != DDERR_TESTFINISHED )
    {
        pContext->dwTimeStamp =  GetTickCount();
    }

    return hr;
}


#endif

/*
 * DD_StartModeTest
 *
 * Indicates that the app wants to start testing a mode (or modes).
 */
HRESULT DDAPI DD_StartModeTest( LPDIRECTDRAW7 lpDD, LPSIZE lpModesToTest, DWORD dwNumEntries, DWORD dwFlags )
{
#ifdef WIN95
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    BOOL                        excl_exists;
    BOOL                        is_excl;
    LPMODETESTCONTEXT           pContext;
    DWORD                       i;
    DWORD                       j;
    HRESULT                     hr;
    DWORD                       dwRefreshRate;
    DWORD                       dwModeWidth;
    DWORD                       dwModeHeight;
    VESA_EDID                   EDIDData;
    DWORD                       dwHighestRefresh;
    DWORD                       dwHighestBandwidth;

    ENTER_DDRAW();
#endif


    DPF(2,A,"ENTERAPI: DD_StartModeTest");

#ifdef WINNT

    return DDERR_TESTFINISHED;

#else
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( this->lpMonitorInfo == NULL )
        {
            // There is no monitor info
            LEAVE_DDRAW();
            return DDERR_NOMONITORINFORMATION;
        }

        if( this_lcl->lpModeTestContext != NULL )
        {
            DPF_ERR( "Mode test already running" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }        

        if( dwFlags & ~DDSMT_VALID )
        {
            DPF_ERR( "Invalid Flags specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( ( dwFlags & DDSMT_ISTESTREQUIRED ) &&
            ( lpModesToTest == NULL ) )
        {
            DPF_ERR( "No modes specified to test" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        CheckExclusiveMode( this_lcl, &excl_exists, &is_excl, FALSE, NULL, FALSE);
        if( lpModesToTest != NULL )
        {
            if ( ( dwNumEntries == 0 ) ||
                 ( !VALID_BYTE_ARRAY( lpModesToTest, sizeof( SIZE ) * dwNumEntries ) ) )
            {
                DPF_ERR( "Invalid mode list specified" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
    
            /*
             * The app must own exclusive mode to test the modes
             */
            if ( !is_excl ||  !(this->dwFlags & DDRAWI_FULLSCREEN) )
            {
                DPF_ERR( "Must be in full-screen exclusive mode to test the modes" );
                LEAVE_DDRAW();
                return DDERR_NOEXCLUSIVEMODE;
            }
        }
        else
        {
            /*
             * There must not be another app running which owns exclusive mode
             */
            if( !excl_exists || is_excl )
            {
                this->lpMonitorInfo->Mode640x480 = -1;
                this->lpMonitorInfo->Mode800x600 = -1;
                this->lpMonitorInfo->Mode1024x768 = -1;
                this->lpMonitorInfo->Mode1280x1024 = -1;
                this->lpMonitorInfo->Mode1600x1200 = -1;
                this->lpMonitorInfo->ModeReserved1 = -1;
                this->lpMonitorInfo->ModeReserved2 = -1;
                this->lpMonitorInfo->ModeReserved3 = -1;
                
                hr = DDSaveMonitorInfo( this_int );
                LEAVE_DDRAW();
                return hr;
            }
            else
            {
                DPF_ERR( "Cannot reset monitor info; another app owns exclusive mode" );
                LEAVE_DDRAW();
                return DDERR_NOEXCLUSIVEMODE;
            }

        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * Get and evaluate the EDID data
     */
    hr = GetEDIDData( this, &EDIDData );
    if( hr != DD_OK )
    {
        // There is no EDID data
        LEAVE_DDRAW();
        return DDERR_NOMONITORINFORMATION;
    }
    EvaluateMonitor( &EDIDData, &dwHighestRefresh, &dwHighestBandwidth );

    for( i = 0; i < this->dwNumModes; i++ )
    {
        if( this->lpModeInfo[i].wRefreshRate > 0 )
        {
            break;
        }
    }
    if( i == this->dwNumModes )
    {
        // The driver does not enumerate display mode refresh rates.
        LEAVE_DDRAW();
        return DDERR_NODRIVERSUPPORT;
    }
    
    /*
     * Allocate a context for ourselves
     */
    pContext = (LPMODETESTCONTEXT) MemAlloc( sizeof( MODETESTCONTEXT ) );
    if( pContext == NULL )
    {
        DPF_ERR( "Insufficient memory" );
        LEAVE_DDRAW();
        return DDERR_OUTOFMEMORY;
    }
    pContext->dwNumModes = 0;
    pContext->dwCurrentMode = 0;
    pContext->lpModeList = (LPMODETESTDATA) MemAlloc( sizeof( MODETESTDATA ) * dwNumEntries );
    if( pContext->lpModeList == NULL )
    {
        MemFree( pContext );
        LEAVE_DDRAW();
        return DDERR_OUTOFMEMORY;
    }
    this_lcl->lpModeTestContext = pContext;
    
    /*
     * Guestimate which refresh rates we should try for each mode in the list
     * based on the EDID data
     */
    for( i = 0; i < dwNumEntries; i++ )
    {
        DWORD dwLowestBPP = 0xFFFFFFFF;
        /*
         * Verify that the driver understands the resolution
         */
        for( j = 0; j < this->dwNumModes; j++ )
        {
            if( ( this->lpModeInfo[j].dwHeight == (DWORD) lpModesToTest[i].cy ) &&
                ( this->lpModeInfo[j].dwWidth == (DWORD) lpModesToTest[i].cx ) )
            {
                if( this->lpModeInfo[j].dwBPP < dwLowestBPP )
                {
                    dwLowestBPP = this->lpModeInfo[j].dwBPP;
                }
            }
        }
        if( dwLowestBPP == 0xFFFFFFFF )
        {
            /*
             * The driver doesn't undestand this mode, so the app is dumb 
             * for not enumerating the modes first.
             */
            MemFree( pContext->lpModeList );
            MemFree( pContext );
            this_lcl->lpModeTestContext = NULL;
            DPF_ERR( "Invalid mode specified in mode list" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Get the actual mode to test.  For example, the app may want
         * to test 320x240, 640x400, and 640x480, but we treat all of these
         * modes the same so we only have to do a single test.
         */
        hr = GetModeToTest( lpModesToTest[i].cx, 
            lpModesToTest[i].cy,
            &dwModeWidth,
            &dwModeHeight );
        if( hr != DD_OK )
        {
            // They are testing a mode higher the 1600x1200
            continue;
        }
        for( j = 0; j < pContext->dwNumModes; j++ )
        {
            if( ( pContext->lpModeList[j].dwWidth == dwModeWidth ) &&
                ( pContext->lpModeList[j].dwHeight == dwModeHeight ) )
            {
                break;
            }
        }
        if( j < pContext->dwNumModes )
        {
            // Duplicate mode
            continue;
        }

        if( !IsModeTested( this, dwModeWidth, dwModeHeight ) )
        {
            dwRefreshRate = GuestimateRefreshRate( this, dwModeWidth, dwModeHeight, 
                dwHighestRefresh, dwHighestBandwidth );
        
            pContext->lpModeList[pContext->dwNumModes].dwWidth = dwModeWidth;
            pContext->lpModeList[pContext->dwNumModes].dwHeight = dwModeHeight;
            pContext->lpModeList[pContext->dwNumModes].dwBPP = dwLowestBPP;
            pContext->lpModeList[pContext->dwNumModes].dwRefreshRate = dwRefreshRate;
            pContext->dwNumModes++;
        }
    }

    /*
     * After all of that, do we still have any modes that need testing?  
     * If not, we can stop now
     */
    if( dwFlags & DDSMT_ISTESTREQUIRED )
    {
        hr = ( pContext->dwNumModes > 0 ) ? DDERR_NEWMODE : DDERR_TESTFINISHED;
        MemFree( pContext->lpModeList );
        MemFree( pContext );
        this_lcl->lpModeTestContext = NULL;
    }
    else
    {
        pContext->dwOrigModeIndex = this->dwModeIndex;
        hr = RunNextTest( lpDD, pContext );
    }

    LEAVE_DDRAW();
    return hr;
#endif
} 


/*
 * DD_EvaluateMode
 *
 * Called at high frequency while the mode test is being performed.  If the user has indicated
 * that a mode succeeded or failed, we move on to the next moe in the test; otherwise, we will 
 * simply check the 15 second timeout value and fail the mode when we hit it..
 */
HRESULT DDAPI DD_EvaluateMode( LPDIRECTDRAW7 lpDD, DWORD dwFlags, DWORD *pSecondsUntilTimeout)
{
#ifdef WIN95
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    BOOL                        excl_exists;
    BOOL                        is_excl;
    LPMODETESTCONTEXT           pContext;
    DWORD                       i;
    DWORD                       j;
    HRESULT                     hr = DD_OK;
    DWORD                       dwTick;

    ENTER_DDRAW();
#endif

    DPF(2,A,"ENTERAPI: DD_EvaluateMode");

#ifdef WINNT

    return DDERR_INVALIDPARAMS;

#else
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( this->lpMonitorInfo == NULL )
        {
            // There is no monitor info so we should not be here
            LEAVE_DDRAW();
            return DDERR_NOMONITORINFORMATION;
        }
        
    	pContext = this_lcl->lpModeTestContext;
        if( NULL == pContext )
    	{
            DPF_ERR( "Must call StartModeTest before EvaulateMode" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
    	}

        if( ( NULL != pSecondsUntilTimeout ) && 
            !VALID_BYTE_ARRAY( pSecondsUntilTimeout, sizeof( DWORD ) ) )
    	{
            DPF_ERR( "Invalid pointer to timeout counter" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
    	}

        if( dwFlags & ~DDEM_VALID )
        {
            DPF_ERR( "Invalid Flags specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( ( dwFlags & DDEM_MODEPASSED ) &&
            ( dwFlags & DDEM_MODEFAILED ) )
        {
            DPF_ERR( "Invalid Flags specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * If we lost exclusive mode, we should stop the test now
         */
        CheckExclusiveMode( this_lcl, &excl_exists, &is_excl, FALSE, NULL, FALSE);
        if (!is_excl ||  !(this->dwFlags & DDRAWI_FULLSCREEN) )
        {
            DPF_ERR( "Exclusive mode lost" );
            MemFree( pContext->lpModeList );
            MemFree( pContext );
            this_lcl->lpModeTestContext = NULL;
            LEAVE_DDRAW();
            return DDERR_TESTFINISHED;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if( dwFlags & DDEM_MODEPASSED )
    {
        // The current data is good, so save it

        UpdateMonitorInfo( this, 
            pContext->lpModeList[pContext->dwCurrentMode].dwWidth,
            pContext->lpModeList[pContext->dwCurrentMode].dwHeight,
            pContext->lpModeList[pContext->dwCurrentMode].dwRefreshRate );
            
        // Move on to the next test, if there is one
        
        pContext->dwCurrentMode++;
        hr = RunNextTest( lpDD, pContext );
        if( hr == DD_OK )
        {
            hr = DDERR_NEWMODE;
        }
    }
    else
    {
        // Has our timeout expired?

        dwTick = GetTickCount();
        if( dwTick - pContext->dwTimeStamp > 15000 )
        {
            dwFlags |= DDEM_MODEFAILED;
        }

        if( dwFlags & DDEM_MODEFAILED )
        {
            // Drop down to the next refresh rate or the next mode

            SetupNextTest( lpDD, pContext );
            hr = RunNextTest( lpDD, pContext );
            if( hr == DD_OK )
            {
                hr = DDERR_NEWMODE;
            }

            dwTick = GetTickCount();
        }
    }

    if( pSecondsUntilTimeout != NULL )
    {
        if( hr == DDERR_TESTFINISHED )
        {
            *pSecondsUntilTimeout = 0;
        }
        else
        {
            *pSecondsUntilTimeout = 15 - ( ( dwTick - pContext->dwTimeStamp) / 1000 );
        }
    }

    LEAVE_DDRAW();        
    return hr;
#endif
}


//
// This function is designed to allow DX7 apps to see some modes that would otherwise be
// incorrectly masked by the mode enumeration thing.
//
// If a driver exposes a list of modes with full-on refresh rates in EVERY entry in the mode table,
// then we will enum exactly NONE of them to the app, since any rate with a rate cannot be enumerated
// until the mode test has run. Apps that don't run the mode test will see NO modes at all.
//
// The s3 savage 4 is a case in point: it fills in the refresh rate for the current display mode,
// (and no other mode) and doesn't dupe the entry to one with a zero refresh rate.
//
// What we do is: every time we find an instance of a mode (size, bitdepth, masks) that has no 
// zero-rate entry, we append a zero-rate entry to the end of the mode list.
//

//No need to massage on winNT
#ifdef WIN95
void MassageModeTable(LPDDRAWI_DIRECTDRAW_GBL pddd)
{
    DWORD iMode, iCheckZero;
    if( pddd->lpModeInfo != NULL )
    {
RestartLoop:
        for( iMode = 0; iMode < pddd->dwNumModes;  iMode++ )
        {
            if (pddd->lpModeInfo[iMode].wRefreshRate != 0)
            {
                // Found a mode with non-zero rate. Check to see if the mode is also represented
                // by a zero-rate entry. If it is not, then append such an entry
                for( iCheckZero = 0; iCheckZero < pddd->dwNumModes;  iCheckZero++ )
                {
                    if( (pddd->lpModeInfo[iCheckZero].dwWidth    == pddd->lpModeInfo[iMode].dwWidth) &&
                        (pddd->lpModeInfo[iCheckZero].dwHeight   == pddd->lpModeInfo[iMode].dwHeight) &&
                        (pddd->lpModeInfo[iCheckZero].dwBPP      == pddd->lpModeInfo[iMode].dwBPP) &&
                        (pddd->lpModeInfo[iCheckZero].dwRBitMask == pddd->lpModeInfo[iMode].dwRBitMask) &&
                        (pddd->lpModeInfo[iCheckZero].dwGBitMask == pddd->lpModeInfo[iMode].dwGBitMask) &&
                        (pddd->lpModeInfo[iCheckZero].dwBBitMask == pddd->lpModeInfo[iMode].dwBBitMask))
                    {
                        // found a matching mode, in terms of size and depth.
                        // If the refresh rate is zero, then we can break out and go on to the next iMode
                        if (pddd->lpModeInfo[iCheckZero].wRefreshRate == 0)
                        {
                            goto NextMode;
                        }
                    }
                }
                // If we got here, then there was no entry in the mode list for this size+depth
                // that had a zero refresh rate. Append one now.
                // Note how expanding the mode list like this means that if the driver (as it typically
                // will) offers several rates for a given mode, we'll expand the table on the first
                // hit of that mode, but then the expanded table will satisfy us for every subsequent
                // rate of that mode (i.e. now there WILL be a zero-rated entry for that mode (since
                // we just added it)).
                {
                    LPDDHALMODEINFO pmi;

                    pmi = (LPDDHALMODEINFO) MemAlloc(sizeof(*pmi) * (pddd->dwNumModes+1));
                    if (pmi == NULL)
                    {
                        //oh just give up....
                        return;
                    }

                    memcpy(pmi, pddd->lpModeInfo, sizeof(*pmi)*pddd->dwNumModes );
                    MemFree(pddd->lpModeInfo);
                    pddd->lpModeInfo = pmi;

                    // Now put the zero-rated mode in there
                    memcpy( &pddd->lpModeInfo[pddd->dwNumModes], &pddd->lpModeInfo[iMode], sizeof(*pmi));
                    pddd->lpModeInfo[pddd->dwNumModes].wRefreshRate = 0;
                    pddd->lpModeInfo[pddd->dwNumModes].wFlags |= DDMODEINFO_DX7ONLY;

                    pddd->dwNumModes++;

                    //Now we have to restart the whole loop because we changed the lpModeInfo pointer:
                    goto RestartLoop;
                }
            }
NextMode:;
        }
    }
}
#endif //WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddrestor.c ===
//=============================================================================
//
//  Copyright (C) 1997 Microsoft Corporation. All rights reserved.
//
//     File:  ddrestor.c
//  Content:  DirectDraw persistent-content surfaces for Windows 9x
//
//  Date        By        Reason
//  ----------  --------  -----------------------------------------------------
//  09/30/1997  jeffno    Created
//  10/02/1997  johnstep  Initial implementation
//
//=============================================================================

#include "ddrawpr.h"
#include "dx8priv.h"

//
// MEM_SHARED is an undocumented flag for VirtualAlloc, taken from the Windows
// 9x source code.
//

#define MEM_SHARED	0x08000000	// make memory globally visible

//
// QWORD_MULTIPLE is used to compute the pitch of a dummy surface,
// based on its width, given that the pitch must be a QWORD multiple.
//

#define QWORD_MULTIPLE(x) (((x) + 7) & 0xFFFFFFF8)

//=============================================================================
//
//  Function: allocSurfaceContentsMemory
//
//=============================================================================

static HRESULT allocSurfaceContentsMemory(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPDDRAWI_DDRAWSURFACE_GBL       this_gbl;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE  this_gbl_more;
    DWORD                           size;
    LPVOID                          pvContents;
    LPDDPIXELFORMAT                 lpddpf;

    this_gbl = this_lcl->lpGbl;
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(this_gbl);

    this_gbl_more->pvContents = NULL;
    this_gbl_more->dwBackupStamp = 0;

    if (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        return DD_OK;
    }

    if (this_gbl->wHeight)
    {
        GET_PIXEL_FORMAT(this_lcl, this_gbl, lpddpf);
        size = QWORD_MULTIPLE((this_gbl->wWidth * lpddpf->dwRGBBitCount) >> 3) * this_gbl->wHeight;
    }
    else
    {
        size = this_gbl->dwLinearSize;
    }

    //
    // Use VirtualAlloc with the undocumented MEM_SHARED flag so the memory
    // is allcocated from the Windows 9x shared arena. We could change this to
    // use MemAlloc() and instead of VirtualFree, MemFree().
    //

    pvContents = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_SHARED, PAGE_READWRITE);

    if (!pvContents)
    {
        return DDERR_GENERIC;
    }

    this_gbl_more->pvContents = pvContents;

    return DD_OK;
}

//=============================================================================
//
//  Function: allocSurfaceAttachContents
//
//=============================================================================

static HRESULT allocSurfaceAttachContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPATTACHLIST                pattachList;
    LPDDRAWI_DDRAWSURFACE_INT   curr_int;
    LPDDRAWI_DDRAWSURFACE_LCL   curr_lcl;
    HRESULT                     ddrval;

    for (pattachList = this_lcl->lpAttachList; pattachList; pattachList = pattachList->lpLink)
    {
        curr_int = pattachList->lpIAttached;
        curr_lcl = curr_int->lpLcl;

        if (curr_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE)
        {
            ddrval = AllocSurfaceContents(curr_lcl);
            if (FAILED(ddrval))
            {
                return ddrval;
            }
        }
    }

    return DD_OK;
}

//=============================================================================
//
//  Function: AllocSurfaceContents
//
//=============================================================================

HRESULT AllocSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    HRESULT ddrval;

    ddrval = allocSurfaceContentsMemory(this_lcl);
    if (FAILED(ddrval))
    {
        return ddrval;
    }

    ddrval = allocSurfaceAttachContents(this_lcl);
    if (FAILED(ddrval))
    {
        return ddrval;
    }

    return DD_OK;
}

//=============================================================================
//
//  Function: FreeSurfaceContents
//
//=============================================================================

void FreeSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPDDRAWI_DDRAWSURFACE_GBL_MORE    this_gbl_more;

    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(this_lcl->lpGbl);

    VirtualFree(this_gbl_more->pvContents, 0, MEM_RELEASE);

    this_gbl_more->pvContents = NULL;
}

//=============================================================================
//
//  Function: createDummySurface
//
//=============================================================================

static LPDDRAWI_DDRAWSURFACE_INT createDummySurface(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPDDRAWI_DIRECTDRAW_INT pdrv_int;
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    DDSURFACEDESC2 ddsd;
    LPDIRECTDRAWSURFACE lpdds;
    HRESULT ddrval;

    pdrv_int = this_lcl->lpSurfMore->lpDD_int;
    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

    ZeroMemory(&ddsd, sizeof ddsd);
    ddsd.dwSize = sizeof ddsd;
    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    ddsd.dwWidth = 1;
    ddsd.dwHeight = 1;
    ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY;

    ddrval = InternalCreateSurface(pdrv_lcl, &ddsd, &lpdds, pdrv_int, NULL, 0);
    if (FAILED(ddrval))
    {
        return NULL;
    }

    return (LPDDRAWI_DDRAWSURFACE_INT) lpdds;
}

//=============================================================================
//
//  Function: BackupSurfaceContents
//
//  This function assumes that the surface passed in is a video memory
//  surface.
//
//=============================================================================

HRESULT BackupSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPDDRAWI_DDRAWSURFACE_GBL       this_gbl;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE  this_gbl_more;
    HRESULT                         ddrval;
    LPVOID                          pbits;
    LPDDRAWI_DDRAWSURFACE_INT       psurf_int;
    LPDDRAWI_DDRAWSURFACE_INT       pnew_int;
    LPDDRAWI_DIRECTDRAW_GBL         pdrv;
    DDSURFACEDESC2                  ddsd;
    DWORD                           bytes;
    LPBYTE                          psrc;
    LPBYTE                          pdst;
    DWORD                           y;
    LONG                            pitch;
    LPDDPIXELFORMAT                 lpddpf;

    this_gbl = this_lcl->lpGbl;
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(this_gbl);

    if (!this_gbl_more->dwBackupStamp &&
        (this_gbl_more->dwBackupStamp == this_gbl_more->dwContentsStamp))
    {
        DPF(3, "Contents unchanged, so not backing up again");
        return DD_OK;
    }

    if (!this_gbl_more->pvContents)
    {
        return DDERR_GENERIC;
    }

    pdrv = this_gbl->lpDD;

    GET_PIXEL_FORMAT(this_lcl, this_gbl, lpddpf);
    pitch = QWORD_MULTIPLE((this_gbl->wWidth * lpddpf->dwRGBBitCount) >> 3);

    psurf_int = createDummySurface(this_lcl);

    //
    // First try to blt, if that fails, we'll lock and copy memory
    //

    if (psurf_int)
    {
        ZeroMemory(&ddsd, sizeof ddsd);
        ddsd.dwSize = sizeof ddsd;
        ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH | DDSD_LPSURFACE | DDSD_PIXELFORMAT;
        ddsd.ddpfPixelFormat.dwSize = sizeof ddsd.ddpfPixelFormat;
        DD_Surface_GetPixelFormat((LPDIRECTDRAWSURFACE) psurf_int, &ddsd.ddpfPixelFormat);
        ddsd.dwWidth = this_gbl->wWidth;
        ddsd.dwHeight = this_gbl->wHeight;
        ddsd.lPitch = pitch;
        ddsd.lpSurface = this_gbl_more->pvContents;

        ddrval = DD_Surface_SetSurfaceDesc4((LPDIRECTDRAWSURFACE3) psurf_int, &ddsd, 0);
        if (SUCCEEDED(ddrval))
        {
            pnew_int = MemAlloc(sizeof (DDRAWI_DDRAWSURFACE_INT));
            if (pnew_int)
            {
                pnew_int->lpVtbl = &ddSurface4Callbacks;
                pnew_int->lpLcl = this_lcl;
                pnew_int->lpLink = pdrv->dsList;
                pdrv->dsList = pnew_int;
                pnew_int->dwIntRefCnt = 0;

                ddrval = ((LPDIRECTDRAWSURFACE) psurf_int)->lpVtbl->Blt(
                    (LPDIRECTDRAWSURFACE) psurf_int,
                    NULL,
                    (LPDIRECTDRAWSURFACE) pnew_int,
                    NULL,
                    DDBLT_WAIT,
                    NULL);

                pdrv->dsList = pnew_int->lpLink;
                MemFree(pnew_int);

                if (SUCCEEDED(ddrval))
                {
                    InternalSurfaceRelease(psurf_int, FALSE, FALSE);

                    this_gbl_more->dwBackupStamp = this_gbl_more->dwContentsStamp;

                    DPF(4, "BackupSurfaceContents Blt succeeded");

                    return DD_OK;
                }
            }
        }

        InternalSurfaceRelease(psurf_int, FALSE, FALSE);
    }

    //
    // Blt failed, so now we'll just lock and copy memory
    //

    ddrval = InternalLock(this_lcl, &pbits, NULL , DDLOCK_WAIT | DDLOCK_TAKE_WIN16);
    if (SUCCEEDED(ddrval))
    {
        psrc = pbits;
        pdst = this_gbl_more->pvContents;
        bytes = this_gbl->wWidth;
        bytes *= lpddpf->dwRGBBitCount;
        bytes >>= 3;

        for (y = 0; y < this_gbl->wHeight; ++y)
        {
            CopyMemory(pdst, psrc, bytes);
            psrc += this_gbl->lPitch;
            pdst += pitch;
        }

        InternalUnlock(this_lcl, NULL, NULL, DDLOCK_TAKE_WIN16);
        DPF(5, "BackupSurfaceContents CopyMemory succeeded");
    }
    else
    {
        FreeSurfaceContents(this_lcl);
        return ddrval;
    }

    return DD_OK;
}

//=============================================================================
//
//  Function: RestoreSurfaceContents
//
//=============================================================================

HRESULT RestoreSurfaceContents(LPDDRAWI_DDRAWSURFACE_LCL this_lcl)
{
    LPDDRAWI_DDRAWSURFACE_GBL       this_gbl;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE  this_gbl_more;
    HRESULT                         ddrval;
    LPVOID                          pbits;
    LPDDRAWI_DDRAWSURFACE_INT       psurf_int;
    LPDDRAWI_DDRAWSURFACE_INT       pnew_int;
    LPDDRAWI_DIRECTDRAW_GBL         pdrv;
    DDSURFACEDESC2                  ddsd;
    DWORD                           bytes;
    LPBYTE                          psrc;
    LPBYTE                          pdst;
    DWORD                           y;
    LONG                            pitch;
    LPDDPIXELFORMAT                 lpddpf;

    this_gbl = this_lcl->lpGbl;
    this_gbl_more = GET_LPDDRAWSURFACE_GBL_MORE(this_gbl);

    if (!this_gbl_more->pvContents)
    {
        return DDERR_GENERIC; // backup probably failed
    }

    pdrv = this_gbl->lpDD;

    GET_PIXEL_FORMAT(this_lcl, this_gbl, lpddpf);
    pitch = QWORD_MULTIPLE((this_gbl->wWidth * lpddpf->dwRGBBitCount) >> 3);

    psurf_int = createDummySurface(this_lcl);

    //
    // First try to blt, if that fails, we'll lock and copy memory
    //

    if (psurf_int)
    {
        ZeroMemory(&ddsd, sizeof ddsd);
        ddsd.dwSize = sizeof ddsd;
        ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH | DDSD_LPSURFACE | DDSD_PIXELFORMAT;
        ddsd.ddpfPixelFormat.dwSize = sizeof ddsd.ddpfPixelFormat;
        DD_Surface_GetPixelFormat((LPDIRECTDRAWSURFACE) psurf_int, &ddsd.ddpfPixelFormat);
        ddsd.dwWidth = this_gbl->wWidth;
        ddsd.dwHeight = this_gbl->wHeight;
        ddsd.lPitch = pitch;
        ddsd.lpSurface = this_gbl_more->pvContents;

        ddrval = DD_Surface_SetSurfaceDesc4((LPDIRECTDRAWSURFACE3) psurf_int, &ddsd, 0);
        if (SUCCEEDED(ddrval))
        {
            pnew_int = MemAlloc(sizeof (DDRAWI_DDRAWSURFACE_INT));
            if (pnew_int)
            {
                pnew_int->lpVtbl = &ddSurface4Callbacks;
                pnew_int->lpLcl = this_lcl;
                pnew_int->lpLink = pdrv->dsList;
                pdrv->dsList = pnew_int;
                pnew_int->dwIntRefCnt = 0;

                ddrval = ((LPDIRECTDRAWSURFACE) psurf_int)->lpVtbl->Blt(
                    (LPDIRECTDRAWSURFACE) pnew_int,
                    NULL,
                    (LPDIRECTDRAWSURFACE) psurf_int,
                    NULL,
                    DDBLT_WAIT,
                    NULL);

                this_gbl_more->dwBackupStamp = this_gbl_more->dwContentsStamp;

                pdrv->dsList = pnew_int->lpLink;
                MemFree(pnew_int);

                if (SUCCEEDED(ddrval))
                {
                    InternalSurfaceRelease(psurf_int, FALSE, FALSE);
                    DPF(5, "RestoreSurfaceContents Blt succeeded");

                    return DD_OK;
                }
            }
        }

        InternalSurfaceRelease(psurf_int, FALSE, FALSE);
    }

    //
    // Blt failed, so now we'll just lock and copy memory
    //

    ddrval = InternalLock(this_lcl, &pbits, NULL , DDLOCK_WAIT | DDLOCK_TAKE_WIN16);
    if (SUCCEEDED(ddrval))
    {
        psrc = this_gbl_more->pvContents;
        pdst = pbits;
        bytes = this_gbl->wWidth;
        bytes *= lpddpf->dwRGBBitCount;
        bytes >>= 3;

        for (y = 0; y < this_gbl->wHeight; ++y)
        {
            CopyMemory(pdst, psrc, bytes);
            psrc += pitch;
            pdst += this_gbl->lPitch;
        }

        InternalUnlock(this_lcl, NULL, NULL, DDLOCK_TAKE_WIN16);
        DPF(5, "RestoreSurfaceContents CopyMemory succeeded");

        this_gbl_more->dwBackupStamp = this_gbl_more->dwContentsStamp;
    }
    else
    {
        return ddrval;
    }

    return DD_OK;
}

//=============================================================================
//
//  Function: restoreSurfaces
//
//=============================================================================

static HRESULT restoreSurfaces(LPDDRAWI_DDRAWSURFACE_INT this_int, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl)
{
    HRESULT ddrval;

    if (this_int)
    {
        while (this_int &&
            ((this_int->lpLcl->lpSurfMore->lpDD_lcl != pdrv_lcl) ||
            (this_int->lpLcl->dwFlags & DDRAWISURF_IMPLICITCREATE)))
        {
            this_int = this_int->lpLink;
        }
        if (this_int)
        {
            ddrval = restoreSurfaces(this_int->lpLink, pdrv_lcl);
            if (SUCCEEDED(ddrval))
            {
                ddrval = DD_Surface_Restore((LPDIRECTDRAWSURFACE) this_int);
                if (FAILED(ddrval))
                {
                    return ddrval;
                }
            }
            else
            {
                return ddrval;
            }
        }
    }

    return DD_OK;
}

//=============================================================================
//
//  Function: DD_RestoreAllSurfaces
//
//  Restore all surfaces owned by the DirectDraw object.
//
//=============================================================================

HRESULT EXTERN_DDAPI DD_RestoreAllSurfaces(LPDIRECTDRAW lpDD)
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    HRESULT                 ddrval;


    ENTER_DDRAW()

    DPF(2,A,"ENTERAPI: DD_RestoreALlSurfaces");
    /*DPF(2, "RestoreAllSurfaces");*/

        TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if (!VALID_DIRECTDRAW_PTR(this_int))
        {
            LEAVE_DDRAW()
                return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("Exception encountered validating parameters");
        LEAVE_DDRAW()
            return DDERR_INVALIDPARAMS;
    }

    ddrval = restoreSurfaces(this_lcl->lpGbl->dsList, this_lcl);
    DPF(5, "RestoreAllSurfaces returns: %08x (%u)", ddrval, HRESULT_CODE(ddrval));
    LEAVE_DDRAW()

        return ddrval;
}

//=============================================================================
//
//  Function: BackupAllSurfaces
//
//  Backup all surfaces owned by the DirectDraw object.
//
//=============================================================================

void BackupAllSurfaces(LPDDRAWI_DIRECTDRAW_GBL this_gbl)
{
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;

    DPF(5, "BackupAllSurfaces: %08x", this_gbl);

    psurf_int = this_gbl->dsList;

    while (psurf_int)
    {
        if (!SURFACE_LOST(psurf_int->lpLcl) &&
            (psurf_int->lpLcl->lpSurfMore->lpDD_lcl->lpGbl == this_gbl) &&
            (psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
            (psurf_int->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS))
        {
            DPF(5, "BackupSurfaceContents: %08x", psurf_int->lpLcl);
            BackupSurfaceContents(psurf_int->lpLcl);
        }

        psurf_int = psurf_int->lpLink;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddsacc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsacc.c
 *  Content:    Direct Draw surface access support
 *              Lock & Unlock
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   10-jan-94	craige	initial implementation
 *   13-jan-95	craige	re-worked to updated spec + ongoing work
 *   22-jan-95	craige	made 32-bit + ongoing work
 *   31-jan-95	craige	and even more ongoing work...
 *   04-feb-95	craige	performance tuning, ongoing work
 *   27-feb-95	craige	new sync. macros
 *   02-mar-95	craige	use pitch (not stride)
 *   15-mar-95	craige	HEL
 *   19-mar-95	craige	use HRESULTs
 *   20-mar-95	craige	validate locking rectangle
 *   01-apr-95	craige	happy fun joy updated header file
 *   07-apr-95	craige	bug 2 - unlock should accept the screen ptr
 *			take/release Win16Lock when access GDI's surface
 *   09-apr-95	craige	maintain owner of Win16Lock so we can release it
 *			if someone forgets; remove locks from dead processes
 *   12-apr-95	craige	don't use GETCURRPID; fixed Win16 lock deadlock
 *			condition
 *   06-may-95	craige	use driver-level csects only
 *   12-jun-95	craige	new process list stuff
 *   18-jun-95	craige	allow duplicate surfaces
 *   25-jun-95	craige	one ddraw mutex; hold DDRAW lock when locking primary
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns
 *   03-jul-95	craige	YEEHAW: new driver struct; SEH
 *   07-jul-95	craige	added test for BUSY
 *   08-jul-95	craige	take Win16 lock always on surface lock
 *   09-jul-95	craige	win16 lock re-entrant, so count it!
 *   11-jul-95	craige	set busy bit when taking win16 lock to avoid GDI from
 *			drawing on the display.
 *   13-jul-95	craige	ENTER_DDRAW is now the win16 lock
 *   16-jul-95	craige	check DDRAWISURF_HELCB
 *   31-jul-95	craige	don't return error from HAL unlock if not handled;
 *			validate flags
 *   01-aug-95	craig	use bts for setting & testing BUSY bit
 *   04-aug-95	craige	added InternalLock/Unlock
 *   10-aug-95	toddla	added DDLOCK_WAIT flag
 *   12-aug-95	craige	bug 488: need to call tryDoneLock even after HAL call
 *			to Unlock
 *   18-aug-95	toddla	DDLOCK_READONLY and DDLOCK_WRITEONLY
 *   27-aug-95	craige	bug 723 - treat vram & sysmem the same when locking
 *   09-dec-95	colinmc Added execute buffer support
 *   11-dec-95	colinmc Added lightweight(-ish) Lock and Unlock for use by
 *			Direct3D (exported as private DLL API).
 *   02-jan-96	kylej	handle new interface structs.
 *   26-jan-96	jeffno	Lock/Unlock no longer special-case whole surface...
 *			You need to record what ptr was given to user since
 *			it will not be same as kernel-mode ptr
 *   01-feb-96	colinmc Fixed nasty bug causing Win16 lock to be released
 *			on surfaces explicitly created in system memory
 *			which did not take the lock in the first place
 *   12-feb-96	colinmc Surface lost flag moved from global to local object
 *   13-mar-96	jeffno	Do not allow lock on an NT emulated primary!
 *   18-apr-96	kylej	Bug 18546: Take bytes per pixel into account when
 *			calculating lock offset.
 *   20-apr-96	kylej	Bug 15268: exclude the cursor when a primary
 *			surface rect is locked.
 *   01-may-96	colinmc Bug 20005: InternalLock does not check for lost
 *			surfaces
 *   17-may-96	mdm	Bug 21499: perf problems with new InternalLock
 *   14-jun-96	kylej	NT Bug 38227: Added DDLOCK_FAILONVISRGNCHANGED so
 *			that InternalLock() can fail if the vis rgn is not
 *			current.  This flag is only used on NT.
 *   05-jul-96  colinmc Work Item: Remove requirement on taking Win16 lock
 *                      for VRAM surfaces (not primary)
 *   10-oct-96  colinmc Refinements of the Win16 locking stuff
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   23-mar-97  colinmc Hold Win16 lock for AGP surfaces for now
 *   24-mar-97  jeffno  Optimized Surfaces
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   19-dec-97 jvanaken IDDS4::Unlock now takes pointer to rectangle.
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
#include "ddrawgdi.h"
#endif

/*
 * Bit number of the VRAM flag in the PDEVICE dwFlags field.
 */
#define VRAM_BIT 15

/* doneBusyWin16Lock releases the win16 lock and busy bit.  It is used
 * in lock routines for failure cases in which we have not yet
 * incremented the win16 lock or taken the DD critical section a
 * second time.  It is also called by tryDoneLock.  */
static void doneBusyWin16Lock( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    #ifdef WIN95
        if( pdrv->dwWin16LockCnt == 0 )
        {
            *(pdrv->lpwPDeviceFlags) &= ~BUSY;
        }
        #ifdef WIN16_SEPARATE
            LEAVE_WIN16LOCK();
        #endif
    #endif
} /* doneBusyWin16Lock */

/* tryDoneLock releases the win16 lock and busy bit.  It is used in
 * unlock routines since it decrements the Win16 count in addition to
 * releasing the lock.  WARNING: This function does nothing and
 * returns no error if the win16 lock is not owned by the current DD
 * object. This will result in the lock being held and will probably
 * bring the machine to its knees. */
static void tryDoneLock( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, DWORD pid )
{
    LPDDRAWI_DIRECTDRAW_GBL pdrv = pdrv_lcl->lpGbl;

    if( pdrv->dwWin16LockCnt == 0 )
    {
        return;
    }
    pdrv->dwWin16LockCnt--;
        doneBusyWin16Lock( pdrv );
        LEAVE_DDRAW();
} /* tryDoneLock */

#ifdef USE_ALIAS
    /*
     * Undo an aliased lock.
     *
     * An aliased lock is one which required the PDEVICE VRAM bit
     * to be cleared to prevent the accelerator touching memory
     * at the same time as the locked surface.
     *
     * NOTE: The lock does not necessarily have to be on a VRAM
     * surface. Locks of implicit system memory surfaces also
     * clear the VRAM bit (to ensure similar behaviour for
     * system and video memory surfaces).
     */
    static void undoAliasedLock( LPDDRAWI_DIRECTDRAW_GBL pdrv )
    {
        DDASSERT( 0UL != pdrv->dwAliasedLockCnt );

        #ifdef WIN16_SEPARATE
            ENTER_WIN16LOCK();
        #endif

        pdrv->dwAliasedLockCnt--;
        if( 0UL == pdrv->dwAliasedLockCnt )
        {
            /*
             * That was the last outstanding aliased lock on this
             * device so put the VRAM bit in the PDEVICE back the
             * way it was.
             */
            if( pdrv->dwFlags & DDRAWI_PDEVICEVRAMBITCLEARED )
            {
                /*
                 * The VRAM bit was set when we took the first lock so
                 * we had to clear it. We must now set it again.
                 */
                DPF( 4, "PDevice was VRAM - restoring VRAM bit", pdrv );
                *(pdrv->lpwPDeviceFlags) |= VRAM;
                pdrv->dwFlags &= ~DDRAWI_PDEVICEVRAMBITCLEARED;
            }
        }
        #ifdef WIN16_SEPARATE
            LEAVE_WIN16LOCK();
        #endif
    }

#endif /* USE_ALIAS */

#ifdef WIN95
#define DONE_LOCK_EXCLUDE() \
    if( this_lcl->dwFlags & DDRAWISURF_LOCKEXCLUDEDCURSOR ) \
    { \
        DD16_Unexclude(pdrv->dwPDevice); \
        this_lcl->dwFlags &= ~DDRAWISURF_LOCKEXCLUDEDCURSOR; \
    }
#else
#define DONE_LOCK_EXCLUDE() ;
#endif


/*
 * The following two routines are used by D3D on NT to manipulate
 * the DDraw mutex exclusion mechanism
 */
void WINAPI AcquireDDThreadLock(void)
{
    ENTER_DDRAW();
}
void WINAPI ReleaseDDThreadLock(void)
{
    LEAVE_DDRAW();
}


HRESULT WINAPI DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits )
{
    return InternalLock(this_lcl, lpBits, NULL, DDLOCK_TAKE_WIN16_VRAM |
                                                DDLOCK_FAILLOSTSURFACES);
}

HRESULT WINAPI DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    BUMP_SURFACE_STAMP(this_lcl->lpGbl);
    return InternalUnlock(this_lcl, NULL, NULL, DDLOCK_TAKE_WIN16_VRAM);
}

#define DPF_MODNAME     "InternalLock"

#if !defined( WIN16_SEPARATE) || defined(WINNT)
#pragma message(REMIND("InternalLock not tested without WIN16_SEPARATE."))
#endif // WIN16_SEPARATE

/*
 * InternalLock provides the basics of locking for trusted clients.
 * No parameter validation is done and no ddsd is filled in.  The
 * client promises the surface is not lost and is otherwise well
 * constructed.  If caller does not pass DDLOCK_TAKE_WIN16 in dwFlags,
 * we assume the DDraw critical section, Win16 lock, and busy bit are
 * already entered/set. If caller does pass DDLOCK_TAKE_WIN16,
 * InternalLock will do so if needed. Note that passing
 * DDLOCK_TAKE_WIN16 does not necessarily result in the Win16 lock
 * being taken.  It is only taken if needed.
 */
HRESULT InternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID *pbits,
                      LPRECT lpDestRect, DWORD dwFlags )
{
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    DWORD                       this_lcl_caps;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    DWORD                       rc;
    DDHAL_LOCKDATA              ld;
    LPDDHALSURFCB_LOCK          lhalfn;
    LPDDHALSURFCB_LOCK          lfn;
    BOOL                        emulation;
    LPACCESSRECTLIST            parl;
    LPWORD                      pdflags = NULL;
    BOOL                        isvramlock = FALSE;
    #ifdef USE_ALIAS
        BOOL                        holdwin16lock;
    #endif /* USE_ALIAS */
    FLATPTR                     OldfpVidMem;        //Used to detect if driver moved surface on Lock call


    this = this_lcl->lpGbl;
    this_lcl_caps = this_lcl->ddsCaps.dwCaps;
    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;
    #ifdef WINNT
        // Update DDraw handle in driver GBL object.
        pdrv->hDD = pdrv_lcl->hDD;
    #endif

    ENTER_DDRAW();

    /*
     * If the surface was involved in a hardware op, we need to
     * probe the driver to see if it's done. NOTE this assumes
     * that only one driver can be responsible for a system memory
     * operation.
     * This operation is done at the API level Lock since the situation we
     * need to avoid is the CPU and the DMA/Busmaster hitting a surface
     * at the same time. We can trust the HAL driver to know it should not
     * try to DMA out of the same surface twice. This is almost certainly
     * enforced anyway by the likelihood that the hardware will have only
     * one context with which to perform the transfer: it has to wait.
     */
    if( this->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
    {
        WaitForDriverToFinishWithSurface(this_lcl->lpSurfMore->lpDD_lcl, this_lcl);
    }

    // The following code was added to keep all of the HALs from
    // changing their Lock() code when they add video port support.
    // If the video port was using this surface but was recently
    // flipped, we will make sure that the flip actually occurred
    // before allowing access.  This allows double buffered capture
    // w/o tearing.
    // ScottM 7/10/96
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT )
    {
        LPDDRAWI_DDVIDEOPORT_INT lpVideoPort;
        LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort_lcl;

        // Look at all video ports to see if any of them recently
        // flipped from this surface.
        lpVideoPort = pdrv->dvpList;
        while( NULL != lpVideoPort )
        {
            lpVideoPort_lcl = lpVideoPort->lpLcl;
            if( lpVideoPort_lcl->fpLastFlip == this->fpVidMem )
            {
                // This can potentially tear - check the flip status
                LPDDHALVPORTCB_GETFLIPSTATUS pfn;
                DDHAL_GETVPORTFLIPSTATUSDATA GetFlipData;
                LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;

                pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
                pfn = pdrv_lcl->lpDDCB->HALDDVideoPort.GetVideoPortFlipStatus;
                if( pfn != NULL )  // Will simply tear if function not supproted
                {
                    GetFlipData.lpDD = pdrv_lcl;
                    GetFlipData.fpSurface = this->fpVidMem;

            KeepTrying:
                    rc = DDHAL_DRIVER_NOTHANDLED;
                    DOHALCALL( GetVideoPortFlipStatus, pfn, GetFlipData, rc, 0 );
                    if( ( DDHAL_DRIVER_HANDLED == rc ) &&
                        ( DDERR_WASSTILLDRAWING == GetFlipData.ddRVal ) )
                    {
                        if( dwFlags & DDLOCK_WAIT)
                        {
                            goto KeepTrying;
                        }
                        LEAVE_DDRAW();
                        return DDERR_WASSTILLDRAWING;
                    }
                }
            }
            lpVideoPort = lpVideoPort->lpLink;
        }
    }

    // Check for VRAM access - if yes, we need to take the win16 lock
    // and the busy bit.  From the user API, we treat the vram and
    // implicit sysmemory cases the same because many developers were
    // treating them differently and then breaking when they actually
    // got vram.  Also, we only bother with this if the busy bit (and
    // Win16 lock) are currently available.

    /*
     * NOTE: The semantics are that for each VRAM (or simulated VRAM lock)
     * the Win16 lock and BUSY bit are held until we have called the
     * driver and are sure we can do an aliased lock (in which case we
     * release them). Otherwise, we keep holding them.
     *
     * IMPORTANT NOTE: Behaviour change. Previously we did not perform
     * the Win16 locking actions if this was not the first lock of this
     * surface. This no longer works as we can no longer ensure all the
     * necessary locking actions will happen on the first lock of the
     * surface. For example, the first lock on the surface may be
     * aliasable so we don't set the busy bit. A subsequent lock may
     * not be aliasable, however, so we need to take the lock on that
     * occassion. This should not, however, be much of a hit as the
     * really expensive actions only take place on the first
     * Win16 lock (0UL == pdrv->dwWin16LockCnt) so once someone has
     * taken the Win16 lock remaining locks should be cheap. Also,
     * multiple locks are unusual so, all in all, this should be pretty
     * low risk.
     */
    FlushD3DStates(this_lcl);
#if COLLECTSTATS
    if(this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
        ++this_lcl->lpSurfMore->lpDD_lcl->dwNumTexLocks;
#endif
    if( ( ((dwFlags & DDLOCK_TAKE_WIN16)      && !(this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED)) ||
          ((dwFlags & DDLOCK_TAKE_WIN16_VRAM) &&  (this_lcl_caps & DDSCAPS_VIDEOMEMORY)) )
        && (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
        DDASSERT(!(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) ||
                  !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE));
            
        DPF( 5, "Performing VRAM style lock for surface 0x%08x", this_lcl );

        /*
         * Lock of a VRAM surface (or a surface being treated like a VRAM surface)
         * with no outstanding locks pending. Take the Win16 lock.
         */
        isvramlock = TRUE;

        #ifdef WIN95
            // Don't worry about the busy bit for NT
            /*
             * We always take the Win16 lock while we mess with the driver's
             * busy bits. However, if we have a surface with an alias we
             * will release the Win16 lock before we exit this function.
             */

            #ifdef WIN16_SEPARATE
            ENTER_WIN16LOCK();
            #endif // WIN16_SEPARATE

            // If dwWin16LockCnt > 0 then we already set the busy bit, so
            // don't bother doing it again.  NOTE: this assumption may be
            // limiting.
            if( 0UL == pdrv->dwWin16LockCnt )
            {
                BOOL    isbusy;

                pdflags = pdrv->lpwPDeviceFlags;
                isbusy = 0;

                _asm
                {
                    mov eax, pdflags
                    bts word ptr [eax], BUSY_BIT
                    adc isbusy,0
                }

                if( isbusy )
                {
                    DPF( 2, "BUSY - Lock, dwWin16LockCnt = %ld, %04x, %04x (%ld)",
                         pdrv->dwWin16LockCnt, *pdflags, BUSY, BUSY_BIT );
                    #ifdef WIN16_SEPARATE
                        LEAVE_WIN16LOCK();
                    #endif // WIN16_SEPARATE
                    LEAVE_DDRAW();
                    return DDERR_SURFACEBUSY;
                } // isbusy
            } // ( 0UL == pdrv->dwWin16LockCnt )
        #endif // WIN95
    } // VRAM locking actions (Win16 lock, busy bit).

    // If we have been asked to check for lost surfaces do it NOW after
    // the Win16 locking code. This is essential as otherwise we may
    // lose the surface after the check but before we actually get round
    // to doing anything with the surface
    if( ( dwFlags & DDLOCK_FAILLOSTSURFACES ) && SURFACE_LOST( this_lcl ) )
    {
        DPF_ERR( "Surface is lost - can't lock" );
        #if defined( WIN16_SEPARATE) && !defined(WINNT)
           if( isvramlock )
               doneBusyWin16Lock( pdrv );
        #endif
        LEAVE_DDRAW();
        return DDERR_SURFACELOST;
    }

    // Make sure someone else has not already locked the part of the
    // surface we want. We don't need to worry about this for DX8
    // resource management. In fact, for vertex buffers, the following
    // code doesn't work because the Rect is actually a linear range.
    if(!(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) ||
       !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
    {
        BOOL hit = FALSE;

        if( lpDestRect != NULL )
        {
            // Caller has asked to lock a subsection of the surface.

            parl = this->lpRectList;

            // Run through all rectangles, looking for an intersection.
            while( parl != NULL )
            {
                RECT res;

                if( IntersectRect( &res, lpDestRect, &parl->rDest ) )
                {
                    hit = TRUE;
                    break;
                }
                parl = parl->lpLink;
            }
        }

        // Either (our rect overlaps with someone else's rect), or
        // (someone else has locked the entire surface), or
        // (someone locked part of the surface but we want to lock the whole thing).
        if( hit ||
            (this->lpRectList == NULL && this->dwUsageCount > 0) ||
            ((lpDestRect == NULL) && ((this->dwUsageCount > 0) || (this->lpRectList != NULL))) )
        {
            DPF(2,"Surface is busy: parl=0x%x, lpDestRect=0x%x, "
                "this->dwUsageCount=0x%x, this->lpRectList=0x%x, hit=%d",
                parl,lpDestRect,this->dwUsageCount,this->lpRectList,hit );
            #if defined( WIN16_SEPARATE) && !defined(WINNT)
            if( isvramlock )
            {
                doneBusyWin16Lock( pdrv );
            }
            #endif
            LEAVE_DDRAW();
            return DDERR_SURFACEBUSY;
        }

        // Create a rectangle access list member.  Note that for
        // performance, we don't do this on 95 if the user is locking
        // the whole surface.
        parl = NULL;
        if(lpDestRect)
        {
            parl = MemAlloc( sizeof( ACCESSRECTLIST ) );
            if( parl == NULL )
            {
            #if defined( WIN16_SEPARATE) && !defined(WINNT)
                if( isvramlock )
                {
                    doneBusyWin16Lock( pdrv );
                }
            #endif
                DPF(0,"InternalLock: Out of memory.");
                LEAVE_DDRAW();
                return DDERR_OUTOFMEMORY;
            }
            if(lpDestRect != NULL)
            {
                parl->lpLink = this->lpRectList;
                parl->rDest = *lpDestRect;
            }
            else
            {
                parl->lpLink        = NULL;
                parl->rDest.top     = 0;
                parl->rDest.left    = 0;
                parl->rDest.bottom  = (int) (DWORD) this->wHeight;
                parl->rDest.right   = (int) (DWORD) this->wWidth;
            }
            parl->lpOwner = pdrv_lcl;
            #ifdef USE_ALIAS
                parl->dwFlags = 0UL;
                parl->lpHeapAliasInfo = NULL;
            #endif /* USE_ALIAS */
            this->lpRectList = parl;
            //parl->lpSurfaceData is filled below, after HAL call

            /*
             * Add a rect to the region list if this is a managed surface and not a read only lock
             */
            if(IsD3DManaged(this_lcl) && !(dwFlags & DDLOCK_READONLY))
            {
                LPREGIONLIST lpRegionList = this_lcl->lpSurfMore->lpRegionList;
                if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                {
                    lpRegionList->rect[(lpRegionList->rdh.nCount)++] = *((LPRECTL)lpDestRect);
                    lpRegionList->rdh.nRgnSize += sizeof(RECT);
                    if((lpDestRect->left & 0xffff) < lpRegionList->rdh.rcBound.left)
                        lpRegionList->rdh.rcBound.left = lpDestRect->left & 0xffff;
                    if((lpDestRect->right & 0xfff)> lpRegionList->rdh.rcBound.right)
                        lpRegionList->rdh.rcBound.right = lpDestRect->right & 0xffff;
                    if(lpDestRect->top < lpRegionList->rdh.rcBound.top)
                        lpRegionList->rdh.rcBound.top = lpDestRect->top;
                    if(lpDestRect->bottom > lpRegionList->rdh.rcBound.bottom)
                        lpRegionList->rdh.rcBound.bottom = lpDestRect->bottom;
                }
            }
        }
        else
        {
            /*
             * We are locking the whole surface, so by setting nCount to the
             * max number of dirty rects allowed, we will force the cache
             * manager to update the entire surface
             */
            if(IsD3DManaged(this_lcl) && !(dwFlags & DDLOCK_READONLY))
            {
                this_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
            }
        }
    }
    else
    {
        parl = NULL;
        DDASSERT(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8);
        DDASSERT(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE);
    }

    // Increment the usage count of this surface.
    this->dwUsageCount++;
    CHANGE_GLOBAL_CNT( pdrv, this, 1 );

    // Is this an emulation surface or driver surface?
    //
    // NOTE: There are different HAL entry points for execute buffers
    // and conventional surfaces.
    if( (this_lcl_caps & DDSCAPS_SYSTEMMEMORY) ||
        (this_lcl->dwFlags & DDRAWISURF_HELCB) )
    {
        if( this_lcl_caps & DDSCAPS_EXECUTEBUFFER )
            lfn = pdrv_lcl->lpDDCB->HELDDExeBuf.LockExecuteBuffer;
        else
            lfn = pdrv_lcl->lpDDCB->HELDDSurface.Lock;
        lhalfn = lfn;
        emulation = TRUE;
    }
    else
    {
        if( this_lcl_caps & DDSCAPS_EXECUTEBUFFER )
        {
            lfn = pdrv_lcl->lpDDCB->HALDDExeBuf.LockExecuteBuffer;
            lhalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.LockExecuteBuffer;
        }
        else
        {
            lfn = pdrv_lcl->lpDDCB->HALDDSurface.Lock;
            lhalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Lock;
        }
        emulation = FALSE;
    }


#ifdef WIN95
        /*
         * exclude the mouse cursor if this is the display driver
         * and we are locking a rect on the primary surface.
         * and the driver is not using a HW cursor
         */
        if ( (pdrv->dwFlags & DDRAWI_DISPLAYDRV) && pdrv->dwPDevice &&
             (this_lcl_caps & DDSCAPS_PRIMARYSURFACE) && lpDestRect &&
            !(*pdrv->lpwPDeviceFlags & HARDWARECURSOR))
        {
            DD16_Exclude(pdrv->dwPDevice, (RECTL *)lpDestRect);
            this_lcl->dwFlags |= DDRAWISURF_LOCKEXCLUDEDCURSOR;
        }
#endif


    //Remember the old fpVidMem in case the driver changes is
    OldfpVidMem = this->fpVidMem;

        // See if the driver wants to say something...
    rc = DDHAL_DRIVER_NOTHANDLED;
    if( lhalfn != NULL )
    {
        DPF(4,"InternalLock: Calling driver Lock.");
        ld.Lock = lhalfn;
        ld.lpDD = pdrv;
        ld.lpDDSurface = this_lcl;
        #ifdef WIN95
        ld.dwFlags = dwFlags;
        #else
        #pragma message(REMIND("So far the s3 driver will only succeed if flags==0"))
        ld.dwFlags = dwFlags & (DDLOCK_READONLY | DDLOCK_WRITEONLY | DDLOCK_NOSYSLOCK | DDLOCK_DISCARDCONTENTS | DDLOCK_NOOVERWRITE);
        #endif
        if( lpDestRect != NULL )
        {
            ld.bHasRect = TRUE;
            ld.rArea = *(LPRECTL)lpDestRect;
        }
        else
        {
            ld.bHasRect = FALSE;
        }

    try_again:
        #ifdef WINNT
            do
            {
                if( this_lcl_caps & DDSCAPS_EXECUTEBUFFER )
                {
                    DOHALCALL( LockExecuteBuffer, lfn, ld, rc, emulation );
                }
                else
                {
                    DOHALCALL( Lock, lfn, ld, rc, emulation );

                    if ( (dwFlags & DDLOCK_FAILONVISRGNCHANGED) ||
                        !(rc == DDHAL_DRIVER_HANDLED && ld.ddRVal == DDERR_VISRGNCHANGED) )
                        break;

                    DPF(4,"Resetting VisRgn for surface %x", this_lcl);
                    DdResetVisrgn(this_lcl, (HWND)0);
                }
            }
            while (rc == DDHAL_DRIVER_HANDLED && ld.ddRVal == DDERR_VISRGNCHANGED);
        #else
            if( this_lcl_caps & DDSCAPS_EXECUTEBUFFER )
            {
                DOHALCALL( LockExecuteBuffer, lfn, ld, rc, emulation );
            }
            else
            {
                DOHALCALL( Lock, lfn, ld, rc, emulation );
            }
        #endif


    }

    if( rc == DDHAL_DRIVER_HANDLED )
    {
        if( ld.ddRVal == DD_OK )
        {
            DPF(5,"lpsurfdata is %08x",ld.lpSurfData);
            #ifdef WINNT
                if ( (ld.lpSurfData == (void*) ULongToPtr(0xffbadbad)) && (dwFlags & DDLOCK_FAILEMULATEDNTPRIMARY) )
                {
                    ld.ddRVal = DDERR_CANTLOCKSURFACE;
                }
            #endif
            *pbits = ld.lpSurfData;
        }
        else if( (dwFlags & DDLOCK_WAIT) && ld.ddRVal == DDERR_WASSTILLDRAWING )
        {
            DPF(4, "Waiting...");
            goto try_again;
        }

        if (ld.ddRVal != DD_OK)
        {
            // Failed!

            #ifdef DEBUG
            if( (ld.ddRVal != DDERR_WASSTILLDRAWING) && (ld.ddRVal != DDERR_SURFACELOST) )
            {
                DPF( 0, "Driver failed Lock request: %ld", ld.ddRVal );
            }
            #endif

            // Unlink the rect list item.
            if(parl)
            {
                this->lpRectList = parl->lpLink;
                MemFree( parl );
            }

            // Now unlock the surface and bail.
            this->dwUsageCount--;
            CHANGE_GLOBAL_CNT( pdrv, this, -1 );
            #if defined( WIN16_SEPARATE) && !defined(WINNT)
            if( isvramlock )
            {
                doneBusyWin16Lock( pdrv );
            }
            #endif
            DONE_LOCK_EXCLUDE();
            LEAVE_DDRAW();
            return ld.ddRVal;
        } // ld.ddRVal
    }
    else // DDHAL_DRIVER_HANDLED
    {
        #ifdef WINNT
            // If the driver fails the lock, we can't allow the app to scribble with
            // who knows what fpVidMem...
            *pbits = (LPVOID) ULongToPtr(0x80000000); // Illegal for user-mode, as is anything higher.
            DPF_ERR("Driver did not handle Lock call. App may Access Violate");

            // Unlink the rect list item.
            if( parl )
            {
                this->lpRectList = parl->lpLink;
                MemFree( parl );
            }

            // Now unlock the surface and bail.
            this->dwUsageCount--;
            CHANGE_GLOBAL_CNT( pdrv, this, -1 );
            DONE_LOCK_EXCLUDE();
            LEAVE_DDRAW();

            return DDERR_SURFACEBUSY;  //GEE: Strange error to use, but most appropriate
        #else // WIN95
            DPF(4,"Driver did not handle Lock call.  Figure something out.");

            // Get a pointer to the surface bits.
            if( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
            {
                *pbits = (LPVOID) pdrv->vmiData.fpPrimary;
            }
            else
            {
                *pbits = (LPVOID) this->fpVidMem;
            }

            if( ld.bHasRect)
            {
                DWORD   bpp;
                DWORD   byte_offset;
                DWORD   left = (DWORD) ld.rArea.left;

                // Make the surface pointer point to the first byte of the requested rectangle.
                if( ld.lpDDSurface->dwFlags & DDRAWISURF_HASPIXELFORMAT )
                {
                    bpp = ld.lpDDSurface->lpGbl->ddpfSurface.dwRGBBitCount;
                }
                else
                {
                    bpp = ld.lpDD->vmiData.ddpfDisplay.dwRGBBitCount;
                }
                if (ld.lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
                {
                    left &= 0xffff;
                }
                switch(bpp)
                {
                case 1:  byte_offset = left>>3;     break;
                case 2:  byte_offset = left>>2;     break;
                case 4:  byte_offset = left>>1;     break;
                case 8:  byte_offset = left;        break;
                case 16: byte_offset = left*2;      break;
                case 24: byte_offset = left *3;     break;
                case 32: byte_offset = left *4;     break;
                }
                *pbits = (LPVOID) ((DWORD)*pbits +
                                   (DWORD)ld.rArea.top * ld.lpDDSurface->lpGbl->lPitch +
                                   byte_offset);
                if (ld.lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
                {
                    ((BYTE*)*pbits) += (ld.rArea.left >> 16) * ld.lpDDSurface->lpGbl->lSlicePitch;
                }
            }
        #endif // WIN95
    } // !DDHAL_DRIVER_HANDLED

    if(!(dwFlags & DDLOCK_READONLY) && IsD3DManaged(this_lcl))
        MarkDirty(this_lcl);

    // Filled in, as promised above.
    if(parl)
    {
        parl->lpSurfaceData = *pbits;
    }

    //
    // At this point we are committed to the lock.
    //

    // stay holding the lock if needed
    if( isvramlock )
    {
#ifdef USE_ALIAS
            LPHEAPALIASINFO pheapaliasinfo;

            pheapaliasinfo = NULL;
            holdwin16lock = TRUE;

            #ifdef DEBUG
                /*
                 * Force or disable the Win16 locking behaviour
                 * dependent on the registry settings.
                 */
                if( dwRegFlags & DDRAW_REGFLAGS_DISABLENOSYSLOCK )
                    dwFlags &= ~DDLOCK_NOSYSLOCK;
                if( dwRegFlags & DDRAW_REGFLAGS_FORCENOSYSLOCK )
                    dwFlags |= DDLOCK_NOSYSLOCK;
            #endif /* DEBUG */
#endif
            DDASSERT(!(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) ||
                     !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE));

            if( dwFlags & DDLOCK_NOSYSLOCK )
            {
#ifdef WINNT
                if( NULL != parl )
                    parl->dwFlags |= ACCESSRECT_NOTHOLDINGWIN16LOCK;
                else
                    this->dwGlobalFlags |= DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK;
                LEAVE_DDRAW();
            }
            else
#endif /* WINNT */

#ifdef USE_ALIAS
                /*
                 * Remember that this was a VRAM style lock (need this when cleaning
                 * up).
                 */
                if( NULL != parl )
                    parl->dwFlags |= ACCESSRECT_VRAMSTYLE;
                else
                    this->dwGlobalFlags |= DDRAWISURFGBL_LOCKVRAMSTYLE;
                /*
                 * At this point we have a pointer to the non-aliased video memory which was
                 * either returned to us by the driver or which we computed ourselves. In
                 * either case, if this is a video memory style lock on a surface that is
                 * aliasable and the pointer computed lies in the range of one our aliased
                 * video memory heaps we wish to use that pointer instead of the real video
                 * memory pointer.
                 */
                if( ( this_lcl_caps & DDSCAPS_PRIMARYSURFACE ) )
                {
                    /*
                     * If we have a primary surface we need to hold the Win16 lock even
                     * though we have aliases. This is to prevent USER
                     * from coming in and changing clip lists or drawing all over our locked
                     * data.
                     */
                    DPF( 2, "Surface is primary. Holding the Win16 lock" );
                }
                else
                {
                    if( pdrv->dwFlags & DDRAWI_NEEDSWIN16FORVRAMLOCK )
                    {
                        /*
                         * For some reason this device needs the Win16 lock for VRAM surface
                         * locking. This is probably because its bankswitched or we have a
                         * DIB engine we don't understand.
                         */
                        DPF( 2, "Device needs to hold Win16 lock for VRAM surface locks" );
                    }
                    else
                    {
                        if( NULL == pdrv->phaiHeapAliases )
                        {
                            /*
                             * We don't have any heaps aliases but we are not a device which
                             * needs the Win16 lock. This means we must be an emulation or
                             * ModeX device. In which case we don't need to hold the Win16
                             * lock for the duration.
                             */
                            DDASSERT( ( pdrv->dwFlags & DDRAWI_NOHARDWARE ) || ( pdrv->dwFlags & DDRAWI_MODEX ) );
                            DPF( 2, "Emulation or ModeX device. No need to hold Win16 lock" );
                            holdwin16lock = FALSE;
                        }
                        else
                        {
                            if( this_lcl_caps & DDSCAPS_SYSTEMMEMORY )
                            {
                                /*
                                 * If the surface is an implicit system memory surface then we
                                 * take aliased style actions but we don't actually compute an alias.
                                 */
                                holdwin16lock = FALSE;
                            }
                            else
                            {
                                FLATPTR                        paliasbits;
                                LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

                                DDASSERT( this_lcl_caps & DDSCAPS_VIDEOMEMORY );

                                lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE( this );

                                // We use the cached alias if available and valid. We determine validity by comparing
                                // *pbits with the original fpVidMem that was used to compute the alias. If they match
                                // then it is safe to use the pointer.
                                // The reason we need to do this is that the driver can change the fpVidMem of the surface.
                                // This change can occur during any Lock calls or (in case of D3D Vertex / Command buffers)
                                // outside of lock (during DrawPrimitives2 DDI call). Thus we need to make sure the surface
                                // is pointing to the same memory as it was when we computed the alias. (anujg 8/13/99)
                                if( ( 0UL != lpGblMore->fpAliasedVidMem ) &&
                                    ( lpGblMore->fpAliasOfVidMem == (FLATPTR) *pbits ) )
                                {
                                    DPF( 4, "Lock vidmem pointer matches stored vidmem pointer - using cached alias" );
                                    paliasbits = lpGblMore->fpAliasedVidMem;
                                }
                                else
                                {
                                    DPF( 4, "Lock vidmem pointer does not match vidmem pointer - recomputing" );
                                    paliasbits = GetAliasedVidMem( pdrv_lcl, this_lcl, (FLATPTR) *pbits );
                                    // Store this value for future use...
                                    if (this->fpVidMem == (FLATPTR)*pbits)
                                    {
                                        lpGblMore->fpAliasedVidMem = paliasbits;
                                        lpGblMore->fpAliasOfVidMem = this->fpVidMem;
                                    }
                                }

                                if( 0UL != paliasbits )
                                {
                                    DPF( 5, "Got aliased pointer = 0x%08x", paliasbits );
                                    *pbits = (LPVOID) paliasbits;

                                    if( NULL != parl )
                                        parl->lpSurfaceData = *pbits;

                                    holdwin16lock = FALSE;
                                    pheapaliasinfo = pdrv->phaiHeapAliases;
                                }
                            }
                            /*
                             * If we have got this far for an execute buffer, it means that we have a
                             * pointer to system memory even though the DDSCAPS_SYSTEMMEMORY is not
                             * set. Thus it is ok to not hold the win16 lock, etc.
                             * Basically what this amounts to is that we never take the win16 lock
                             * for execute buffers. We first try and see if we can find an alias
                             * to the pointer, and if we can't we assume it is in system memory and
                             * not take the win16 lock in any case. (anujg 4/7/98)
                             */
                            if( this_lcl_caps & DDSCAPS_EXECUTEBUFFER )
                            {
                                holdwin16lock = FALSE;
                            }
                        }
                    }
                }
            }

            if( !holdwin16lock )
            {
                /*
                 * We have an aliased lock so we don't need to hold onto the Win16
                 * and busy bit. However, we do need to clear the VRAM bit in the
                 * PDEVICE (if we have not done this already). We also need to
                 * patch the DIB engine to correct the some of the problems we
                 * have in turning the VRAM bit off. Once that is done we can
                 * release the Win16 lock and BUSY bit.
                 *
                 * NOTE: We only need do this if there are no outstanding aliased
                 * locks off this device
                 *
                 * NOTE #2: We also do not need to do this for aliased locks to
                 * execute buffers as this is just trying to prevent DIB Engine
                 * from using HW accelleration when there is an outstanding aliased lock
                 * This is not necessary for the new HW which will be implementing EB
                 * in video memory
                 */
                if( 0UL == pdrv->dwAliasedLockCnt && !(this_lcl_caps & DDSCAPS_EXECUTEBUFFER))
                {
                    BOOL vrambitset;

                    pdflags = pdrv->lpwPDeviceFlags;

                    /*
                     * Clear the PDEVICE's VRAM bit and return its previous status
                     * in vrambit
                     */
                    vrambitset = 0;
                    _asm
                    {
                        mov eax, pdflags
                        btr word ptr [eax], VRAM_BIT
                        adc vrambitset,0
                    }

                    /*
                     * We use a global device object flag to remember the original
                     * state of the VRAM flag.
                     */
                    if( vrambitset )
                    {
                        /*
                         * The VRAM bit in the PDEVICE was set. Need to record the fact
                         * that it was cleared by a lock (so we can put the correct
                         * state back).
                         */
                        DPF( 4, "VRAM bit was cleared for lock of surface 0x%08x", this_lcl );
                        pdrv->dwFlags |= DDRAWI_PDEVICEVRAMBITCLEARED;
                    }
                    #ifdef DEBUG
                        else
                        {
                            /*
                             * NOTE: This can happen if we are running emulated.
                             */
                            DPF( 4, "VRAM bit was already clear on lock of surface 0x%08x", this_lcl );
                            DDASSERT( !( pdrv->dwFlags & DDRAWI_PDEVICEVRAMBITCLEARED ) );
                        }
                    #endif
                }

                /*
                 * Bump the count on the number of outstanding aliased locks.
                 */
                pdrv->dwAliasedLockCnt++;
                if(!(this_lcl_caps & DDSCAPS_EXECUTEBUFFER))
                {
                    // This is used to check if the graphics adapter is busy for Blts, Flips, etc
                    // instead of dwAliasedLockCnt. This enables Blts & Flips when we have an
                    // outstanding aliased lock to an exceute buffer since this will be common
                    // in D3D. We increment this is all other cases to preserve original behavior.
                    if( ( pdrv->lpDDKernelCaps == NULL ) ||
                        !( pdrv->lpDDKernelCaps->dwCaps  & DDKERNELCAPS_LOCK ) )
                    {
                        pdrv->dwBusyDueToAliasedLock++;
                    }
                }

                /*
                 * If we are a real video memory surface then we need to hold a
                 * reference to the heap aliases so they don't go away before we
                 * unlock.
                 */
                if( NULL != pheapaliasinfo )
                {
                    DDASSERT( this_lcl_caps & DDSCAPS_VIDEOMEMORY );
                    DDASSERT( pheapaliasinfo->dwFlags & HEAPALIASINFO_MAPPEDREAL );
                    pheapaliasinfo->dwRefCnt++;
                }

                /*
                 * Remember that this lock is using an alias and not holding the Win16 lock.
                 */
                if( NULL != parl )
                {
                    parl->lpHeapAliasInfo = pheapaliasinfo;
                    parl->dwFlags |= ACCESSRECT_NOTHOLDINGWIN16LOCK;
                }
                else
                {
                    this_lcl->lpSurfMore->lpHeapAliasInfo = pheapaliasinfo;
                    this->dwGlobalFlags |= DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK;
                }

                /*
                 * All has gone well so there is no need to hold the Win16 lock and busy
                 * bit. Release them now.
                 */
                doneBusyWin16Lock( pdrv );

                /*
                 * We do not hold the DirectDraw critical section across the lock
                 * either.
                 */
                LEAVE_DDRAW();

                DPF( 5, "Win16 lock not held for lock of surface 0x%08x", this_lcl );
            }
            else
        #endif /* USE_ALIAS */
        {
            /*
             * We don't LEAVE_DDRAW() to avoid race conditions (someone
             * could ENTER_DDRAW() and then wait on the Win16 lock but we
             * can't release it because we can't get in the critical
             * section).
             * Even though we don't take the Win16 lock under NT, we
             * continue to hold the DirectDraw critical section as
             * long as a vram surface is locked.
             */
            pdrv->dwWin16LockCnt++;

            DPF( 5, "Win16 lock was held for lock of surface 0x%08x", this_lcl );
        }
    }
    else
    {
        LEAVE_DDRAW();
    }
    return DD_OK;

} /* InternalLock */


/*
 * InternalUnlock
 */
HRESULT InternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID lpSurfaceData,
                        LPRECT lpDestRect, DWORD dwFlags )
{
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    DWORD                       rc;
    DDHAL_UNLOCKDATA            uld;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDHALSURFCB_UNLOCK        ulhalfn;
    LPDDHALSURFCB_UNLOCK        ulfn;
    BOOL                        emulation;
    LPACCESSRECTLIST            parl;
    DWORD                       caps;
    BOOL                        holdingwin16;
#ifdef USE_ALIAS
    LPHEAPALIASINFO             pheapaliasinfo;
    BOOL                        lockbroken = FALSE;
#endif /* USE_ALIAS */

    DDASSERT(lpSurfaceData == NULL || lpDestRect == NULL);

    this = this_lcl->lpGbl;
    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;
    caps = this_lcl->ddsCaps.dwCaps;

    if( this->dwUsageCount == 0 )
    {
        DPF_ERR( "ERROR: Surface not locked." );
        return DDERR_NOTLOCKED;
    }

    ENTER_DDRAW();

    /* under NT we cannot compare the locked ptr with fpPrimary since
     * a user-mode address may not necesarily match a kernel-mode
     * address. Now we allocate an ACCESSRECTLIST structure on every
     * lock, and store the user's vidmem ptr in that. The user's
     * vidmem ptr cannot change between a lock and an unlock because
     * the surface will be locked during that time (!) (even tho the
     * physical ram that's mapped at that address might change... that
     * win16lock avoidance thing).  This is a very very small
     * performance hit over doing it the old way. ah well. jeffno
     * 960122 */

    if( NULL != this->lpRectList )
    {
        DDASSERT(!(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) ||
                  !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE));
        /*
         * One or more locks are active on this surface.
         */
        if( NULL != lpDestRect || NULL != lpSurfaceData )
        {
            LPACCESSRECTLIST    last;
            BOOL                found;

            found = FALSE;

            /*
             * The locked region of the surface is specified by either a
             * dest rect or a surface pointer (but never both).  Find the
             * specified region in our list of locked regions on this surface.
             */
            last = NULL;
            parl = this->lpRectList;

            if( NULL != lpDestRect )
            {
                /*
                 * Locked region of surface is specified by dest rect.
                 */
                while( parl != NULL )
                {
                    if( !memcmp(&parl->rDest, lpDestRect, sizeof(RECT)) )
                    {
                        found = TRUE;
                        break;
                    }
                    last = parl;
                    parl = parl->lpLink;
                }
            }
            else
            {
                /*
                 * Locked region of surface is specified by surface ptr.
                 */
                while( parl != NULL )
                {
                    if( parl->lpSurfaceData == lpSurfaceData )
                    {
                        found = TRUE;
                        break;
                    }
                    last = parl;
                    parl = parl->lpLink;
                }
            }

            /*
             * did we find a match?
             */
            if( !found )
            {
                DPF_ERR( "Specified rectangle is not a locked area" );
                LEAVE_DDRAW();
                return DDERR_NOTLOCKED;
            }

            /*
             * make sure unlocking process is the one who locked it
             */
            if( pdrv_lcl != parl->lpOwner )
            {
                DPF_ERR( "Current process did not lock this rectangle" );
                LEAVE_DDRAW();
                return DDERR_NOTLOCKED;
            }

            /*
             * delete this rect
             */
            if( last == NULL )
            {
                this->lpRectList = parl->lpLink;
            }
            else
            {
                last->lpLink = parl->lpLink;
            }
        }
        else
        {
            // Both lpDestRect and lpSurfaceData are null, so there better be
            // only one lock on the surface - the whole thing.  Make sure that
            // if no rectangle was specified that there's only one entry in the
            // access list - the one that was made during lock.
            parl = this->lpRectList;
            if( parl->lpLink == NULL )
            {
                DPF(5,"--Unlock: parl->rDest really set to (L=%d,T=%d,R=%d,B=%d)",
                    parl->rDest.left, parl->rDest.top, parl->rDest.right, parl->rDest.bottom);

                /*
                 * make sure unlocking process is the one who locked it
                 */
                if( pdrv_lcl != parl->lpOwner )
                {
                    DPF_ERR( "Current process did not lock this rectangle" );
                    LEAVE_DDRAW();
                    return DDERR_NOTLOCKED; //what's a better error than this?
                }

                this->lpRectList = NULL;
            }
            else
            {
                DPF_ERR( "Multiple locks on surface -- you must specify a rectangle" );
                LEAVE_DDRAW();
                return DDERR_INVALIDRECT;
            }
        }
        DDASSERT( NULL != parl );
        if( parl->dwFlags & ACCESSRECT_NOTHOLDINGWIN16LOCK )
        {
            holdingwin16 = FALSE;
#ifdef USE_ALIAS
            /*
             * This flag should only be set for VRAM style locks.
             */
            DDASSERT( parl->dwFlags & ACCESSRECT_VRAMSTYLE );
            pheapaliasinfo = parl->lpHeapAliasInfo;
#endif /* USE_ALIAS */
        }
        else
        {
            holdingwin16 = TRUE;
        }
#ifdef USE_ALIAS
        if( parl->dwFlags & ACCESSRECT_BROKEN )
            lockbroken = TRUE;
#endif /* USE_ALIAS */
        MemFree( parl );
    }
    else
    {
        /*
         * Lock of the entire surface (no access rect). Determine whether
         * this lock held the Win16 lock by using global surface object
         * flags (as we have no access rect).
         */
        if( this->dwGlobalFlags & DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK )
        {
            holdingwin16 = FALSE;
#ifdef USE_ALIAS
            /*
             * This flag should only get set for VRAM style locks.
             */
            DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_LOCKVRAMSTYLE );
            pheapaliasinfo = this_lcl->lpSurfMore->lpHeapAliasInfo;
            this_lcl->lpSurfMore->lpHeapAliasInfo = NULL;
#endif /* USE_ALIAS */
        }
        else
        {
            holdingwin16 = TRUE;
        }
#ifdef USE_ALIAS
        if( this->dwGlobalFlags & DDRAWISURFGBL_LOCKBROKEN )
            lockbroken = TRUE;
#endif /* USE_ALIAS */
        this->dwGlobalFlags &= ~( DDRAWISURFGBL_LOCKVRAMSTYLE |
                                  DDRAWISURFGBL_LOCKBROKEN    |
                                  DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK );
    }

    #ifdef WINNT
        if (this->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED)
        {
            if (--dwNumLockedWhenModeSwitched == 0)
            {
                NotifyDriverOfFreeAliasedLocks();
            }
            this->dwGlobalFlags &= ~DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
        }
    #endif

    /*
     * remove one of the users...
     */
    this->dwUsageCount--;
    CHANGE_GLOBAL_CNT( pdrv, this, -1 );

    #ifdef USE_ALIAS
    /*
     * The semantics I have choosen for surfaces which are locked when they
     * get themselves invalidates is to make the application call unlock the
     * appropriate number of times (this for our housekeeping and also for
     * back compatability with existing applications which don't expect to
     * lose locked surfaces and so we be set up to call lock regardless.
     * However, in the case of surfaces that are released when locked we
     * break the locks but don't call the unlock method in the driver we
     * mirror that here. If a lock has been broken we don't call the HAL.
     */
    if( !lockbroken )
    {
    #endif /* USE_ALIAS */
        /*
         * Is this an emulation surface or driver surface?
         *
         * NOTE: Different HAL entry points for execute
         * buffers.
         */
        if( (caps & DDSCAPS_SYSTEMMEMORY) ||
            (this_lcl->dwFlags & DDRAWISURF_HELCB) )
        {
            if( caps & DDSCAPS_EXECUTEBUFFER )
                ulfn = pdrv_lcl->lpDDCB->HELDDExeBuf.UnlockExecuteBuffer;
            else
                ulfn = pdrv_lcl->lpDDCB->HELDDSurface.Unlock;
            ulhalfn = ulfn;
            emulation = TRUE;
        }
        else
        {
            if( caps & DDSCAPS_EXECUTEBUFFER )
            {
                ulfn = pdrv_lcl->lpDDCB->HALDDExeBuf.UnlockExecuteBuffer;
                ulhalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.UnlockExecuteBuffer;
            }
            else
            {
                ulfn = pdrv_lcl->lpDDCB->HALDDSurface.Unlock;
                ulhalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Unlock;
            }
            emulation = FALSE;
        }

        /*
         * Let the driver know about the unlock.
         */
        uld.ddRVal = DD_OK;
        if( ulhalfn != NULL )
        {
            uld.Unlock = ulhalfn;
            uld.lpDD = pdrv;
            uld.lpDDSurface = this_lcl;

            if( caps & DDSCAPS_EXECUTEBUFFER )
            {
                DOHALCALL( UnlockExecuteBuffer, ulfn, uld, rc, emulation );
            }
            else
            {
                DOHALCALL( Unlock, ulfn, uld, rc, emulation );
            }

            if( rc != DDHAL_DRIVER_HANDLED )
            {
                uld.ddRVal = DD_OK;
            }
        }
    #ifdef USE_ALIAS
        }
        else
        {
            DPF( 4, "Lock broken - not calling HAL on Unlock" );
            uld.ddRVal = DD_OK;
        }
    #endif /* USE_ALIAS */
    /* Release the win16 lock but only if the corresponding lock took
     * the win16 lock which in the case of the API level lock and
     * unlock calls is if the user requests it and the surface was not
     * explicitly allocated in system memory.
     *
     * IMPORTANT NOTE: Again we no longer only do this for the first lock
     * on a surface. This matches the code path for lock.
     */
    if( ( ((dwFlags & DDLOCK_TAKE_WIN16)      && !(this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED)) ||
          ((dwFlags & DDLOCK_TAKE_WIN16_VRAM) &&  (caps & DDSCAPS_VIDEOMEMORY)) )
        && (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
        DDASSERT(!(this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) ||
                  !(this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE));
        if( !holdingwin16 )
        {
#ifdef USE_ALIAS
            /*
             * Cleanup the PDEVICE's VRAM bit (if this is the last outstanding
             * VRAM lock.
             */
            undoAliasedLock( pdrv );
            if(!(caps & DDSCAPS_EXECUTEBUFFER))
            {
                // This is used to check if the graphics adapter is busy for Blts, Flips, etc
                // instead of dwAliasedLockCnt. Make sure we decrement it for everything but
                // execute buffers.
                if( ( pdrv->lpDDKernelCaps == NULL ) ||
                    !( pdrv->lpDDKernelCaps->dwCaps  & DDKERNELCAPS_LOCK ) )
                {
                    pdrv->dwBusyDueToAliasedLock--;
                }
            }


            /*
             * We don't need the aliases anymore.
             *
             * NOTE: We don't actually have to have an alias. If this is
             * a VRAM style lock of an implicit system memory surface then
             * no alias is actually used.
             */
            if( NULL != pheapaliasinfo )
            {
                DDASSERT( 0UL != pdrv_lcl->hDDVxd );
                ReleaseHeapAliases( (HANDLE) pdrv_lcl->hDDVxd, pheapaliasinfo );
            }
#endif /* USE_ALIAS */
        }
        else
        {
            tryDoneLock( pdrv_lcl, 0 );
        }
        /*
         * If it was a vram lock then we did not release the DirectDraw critical
         * section on the lock. We need to release it now.
         */
    }

    // Unexclude the cursor if it was excluded in Lock.
    DONE_LOCK_EXCLUDE();

    LEAVE_DDRAW();
    return uld.ddRVal;

} /* InternalUnlock */

#undef DPF_MODNAME
#define DPF_MODNAME     "Lock"

/*
 * DD_Surface_Lock
 *
 * Allows access to a surface.
 *
 * A pointer to the video memory is returned. The primary surface
 * can change from call to call, if page flipping is turned on.
 */

//#define ALLOW_COPY_ON_LOCK

#ifdef ALLOW_COPY_ON_LOCK
HDC hdcPrimaryCopy=0;
HBITMAP hbmPrimaryCopy=0;
#endif

HRESULT DDAPI DD_Surface_Lock(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    DWORD dwFlags,
    HANDLE hEvent )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    DWORD                       this_lcl_caps;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    HRESULT ddrval;
    LPVOID pbits;
    BOOL fastlock;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Lock %p", ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSurface)->lpLcl);
    if (lpDestRect != NULL)
        DPF(2,A,"Lock rectangle (%d, %d, %d, %d)", lpDestRect->left, lpDestRect->top, lpDestRect->right, lpDestRect->bottom);
    /* DPF_ENTERAPI(lpDDSurface); */

    /*
     * Problem: Under NT, there is no cross-process pointer to any given video-memory surface.
     * So how do you tell if an lpVidMem you passed back to the user is the same as the fpPrimaryOrig that
     * was previously stored in the ddraw gbl struct? You can't. Previously, we did a special case lock
     * when the user requested the whole surface (lpDestRect==NULL). Now we allocate a ACCESSRECTLIST
     * structure on every lock, and if lpDestRect==NULL, we put the top-left vidmemptr into that structure.
     * Notice we can guarantee that this ptr will be valid at unlock time because the surface remains
     * locked for all that time (obviously!).
     * This is a minor minor minor perf hit, but what the hey.
     * jeffno 960122
     */

    TRY
    {
        /*
     * validate parms
     */
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        this_lcl_caps = this_lcl->ddsCaps.dwCaps;
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
        pdrv = pdrv_lcl->lpGbl;

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        fastlock = (this_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7) &&
                    (NULL == pdrv_lcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus ||
                        !(this->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED)) &&
                    !(this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT) &&
                    (this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED) &&
                    (this_lcl_caps & DDSCAPS_TEXTURE);

#ifndef DEBUG
        if(!fastlock)
#endif
        {
            if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
            {
                DPF_ERR( "It is an optimized surface" );
                LEAVE_DDRAW();
                return DDERR_ISOPTIMIZEDSURFACE;
            }

            if( dwFlags & ~DDLOCK_VALID )
            {
                DPF_ERR( "Invalid flags" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }

            if (!LOWERTHANSURFACE7(this_int))
            {
                if (dwFlags & DDLOCK_DONOTWAIT)
                {
                    dwFlags &= ~DDLOCK_WAIT;
                }
                else
                {
                    dwFlags |= DDLOCK_WAIT;
                }
            }

            if( !VALID_DDSURFACEDESC_PTR( lpDDSurfaceDesc ) &&
                !VALID_DDSURFACEDESC2_PTR( lpDDSurfaceDesc ) )
            {
                DPF_ERR( "Invalid surface description ptr" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
            lpDDSurfaceDesc->lpSurface = NULL;

            /*
             * Make sure the process locking this surface is the one
             * that created it.
             */
            if( this_lcl->dwProcessId != GetCurrentProcessId() )
            {
                DPF_ERR( "Current process did not create this surface" );
                LEAVE_DDRAW();
                return DDERR_SURFACEBUSY;
            }

            /* Check out the rectangle, if any.
             *
             * NOTE: We don't allow the specification of a rectangle with an
             * execute buffer.
             */
            if( lpDestRect != NULL )
            {
                if( !VALID_RECT_PTR( lpDestRect ) || ( this_lcl_caps & DDSCAPS_EXECUTEBUFFER ) )
                {
                    DPF_ERR( "Invalid destination rectangle pointer" );
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPARAMS;
                } // valid pointer

                /*
                 * make sure rectangle is OK
                 */
                if( (lpDestRect->left < 0) ||
                    (lpDestRect->top < 0) ||
                    (lpDestRect->left > lpDestRect->right) ||
                    (lpDestRect->top > lpDestRect->bottom) ||
                    (lpDestRect->bottom > (int) (DWORD) this->wHeight) ||
                    (lpDestRect->right > (int) (DWORD) this->wWidth) )
                {
                    DPF_ERR( "Invalid rectangle given" );
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPARAMS;
                } // checking rectangle
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    if(fastlock)
    {
        DPF(4, "Performing fast lock");
        lpDDSurfaceDesc->lpSurface = NULL;
#ifdef DEBUG
        if(this->fpVidMem != (FLATPTR)NULL)
        {
            if(this->fpVidMem != (FLATPTR)0xFFBADBAD)
#endif
            {
                if(this->dwUsageCount == 0)
                {
                    FlushD3DStates(this_lcl);
#if COLLECTSTATS
                    if(this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)
                        ++this_lcl->lpSurfMore->lpDD_lcl->dwNumTexLocks;
#endif
                    if( lpDestRect != NULL )
                    {
                        DWORD   byte_offset;
                        /*
                         * Add a rect to the region list if this is a managed surface and not a read only lock
                         */
                        if(IsD3DManaged(this_lcl) && !(dwFlags & DDLOCK_READONLY))
                        {
                            LPREGIONLIST lpRegionList = this_lcl->lpSurfMore->lpRegionList;
                            if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                            {
                                lpRegionList->rect[(lpRegionList->rdh.nCount)++] = *((LPRECTL)lpDestRect);
                                lpRegionList->rdh.nRgnSize += sizeof(RECT);
                                if(lpDestRect->left < lpRegionList->rdh.rcBound.left)
                                    lpRegionList->rdh.rcBound.left = lpDestRect->left;
                                if(lpDestRect->right > lpRegionList->rdh.rcBound.right)
                                    lpRegionList->rdh.rcBound.right = lpDestRect->right;
                                if(lpDestRect->top < lpRegionList->rdh.rcBound.top)
                                    lpRegionList->rdh.rcBound.top = lpDestRect->top;
                                if(lpDestRect->bottom > lpRegionList->rdh.rcBound.bottom)
                                    lpRegionList->rdh.rcBound.bottom = lpDestRect->bottom;
                            }
                            MarkDirty(this_lcl);
                        }
                        // Make the surface pointer point to the first byte of the requested rectangle.
                        switch((this_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? this->ddpfSurface.dwRGBBitCount : pdrv->vmiData.ddpfDisplay.dwRGBBitCount)
                        {
                        case 1:  byte_offset = ((DWORD)lpDestRect->left)>>3;   break;
                        case 2:  byte_offset = ((DWORD)lpDestRect->left)>>2;   break;
                        case 4:  byte_offset = ((DWORD)lpDestRect->left)>>1;   break;
                        case 8:  byte_offset = (DWORD)lpDestRect->left;        break;
                        case 16: byte_offset = (DWORD)lpDestRect->left*2;      break;
                        case 24: byte_offset = (DWORD)lpDestRect->left*3;      break;
                        case 32: byte_offset = (DWORD)lpDestRect->left*4;      break;
                        }
                        pbits = (LPVOID) ((ULONG_PTR)this->fpVidMem + (DWORD)lpDestRect->top * this->lPitch + byte_offset);
                    }
                    else
                    {
                        /*
                         * We are locking the whole surface, so by setting nCount to the
                         * max number of dirty rects allowed, we will force the cache
                         * manager to update the entire surface
                         */
                        if(IsD3DManaged(this_lcl) && !(dwFlags & DDLOCK_READONLY))
                        {
                            this_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                            MarkDirty(this_lcl);
                        }
                        pbits = (LPVOID) this->fpVidMem;
                    }
                    // Increment the usage count of this surface.
                    this->dwUsageCount++;
                    // Reset hardware op status
                    this->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;
                    // Free cached RLE data
                    if( GET_LPDDRAWSURFACE_GBL_MORE(this)->dwHELReserved )
                    {
                        MemFree( (void *)(GET_LPDDRAWSURFACE_GBL_MORE(this)->dwHELReserved) );
                        GET_LPDDRAWSURFACE_GBL_MORE(this)->dwHELReserved = 0;
                    }
                    this->dwGlobalFlags |= DDRAWISURFGBL_FASTLOCKHELD;
                    ddrval = DD_OK;
                }
                else
                {
                    DPF_ERR("Surface already locked");
                    ddrval = DDERR_SURFACEBUSY;
                }
            }
#ifdef DEBUG
            else
            {
                this->dwGlobalFlags |= DDRAWISURFGBL_FASTLOCKHELD;
                ddrval = DD_OK;
            }
        }
        else
        {
            ddrval = DDERR_GENERIC;
        }
#endif
    }
    else
    {
        // Params are okay, so call InternalLock() to do the work.
        ddrval = InternalLock(this_lcl, &pbits, lpDestRect, dwFlags | DDLOCK_TAKE_WIN16 | DDLOCK_FAILEMULATEDNTPRIMARY);
    }

    if(ddrval != DD_OK)
    {
        if( (ddrval != DDERR_WASSTILLDRAWING) && (ddrval != DDERR_SURFACELOST) )//both useless as spew
        {
            DPF_ERR("InternalLock failed.");
        }
        LEAVE_DDRAW();
        return ddrval;
    }

    if (dwFlags & DDLOCK_READONLY)
        this->dwGlobalFlags |= DDRAWISURFGBL_READONLYLOCKHELD;
    else
        this->dwGlobalFlags &= ~DDRAWISURFGBL_READONLYLOCKHELD;


    FillEitherDDSurfaceDesc( this_lcl, (LPDDSURFACEDESC2) lpDDSurfaceDesc );
    lpDDSurfaceDesc->lpSurface = pbits;

    DPF_STRUCT(3,A,DDSURFACEDESC,lpDDSurfaceDesc);

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_Lock */

#undef DPF_MODNAME
#define DPF_MODNAME     "Unlock"


/*
 * Perform the parameter checking and surface unlocking for the
 * IDirectDrawSurface::Unlock API call.  This function is called
 * from both the DD_Surface_Unlock and DD_Surface_Unlock4 entry
 * points.  Argument lpSurfaceData is always NULL when the call
 * is from DD_SurfaceUnlock4, and argument lpDestRect is always
 * NULL when the call is from DD_Surface_Unlock.
 */
HRESULT unlockMain(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPVOID lpSurfaceData,
    LPRECT lpDestRect )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPACCESSRECTLIST            parl;
    HRESULT                     err;

    /*
     * validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
        pdrv = pdrv_lcl->lpGbl;

#ifndef DEBUG
        if(!(this->dwGlobalFlags & DDRAWISURFGBL_FASTLOCKHELD))
#endif
        {
            //
            // For now, if the current surface is optimized, quit
            //
            if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
            {
                DPF_ERR( "It is an optimized surface" );
                return DDERR_ISOPTIMIZEDSURFACE;
            }

            if (lpDestRect != NULL)
            {
                /*
                 * Make sure the specified rectangle pointer is valid.
                 */
                if (!VALID_RECT_PTR(lpDestRect))
                {
                    DPF_ERR( "Invalid destination rectangle pointer" );
                    return DDERR_INVALIDPARAMS;
                }
            }

            /*
             * make sure process accessed this surface
             */
            if( this_lcl->dwProcessId != GetCurrentProcessId() )
            {
                DPF_ERR( "Current process did not lock this surface" );
                return DDERR_NOTLOCKED;
            }

            /*
             * was surface accessed?
             */
            if( this->dwUsageCount == 0 )
            {
                return DDERR_NOTLOCKED;
            }

            /*
             * if the usage count is bigger than one, then you had better tell
             * me what region of the screen you were using...
             */
            if( this->dwUsageCount > 1 && lpSurfaceData == NULL && lpDestRect == NULL)
            {
                return DDERR_INVALIDRECT;
            }

            /*
             * We don't want apps to hold a DC when the surface is not locked,
             * but failing right now could cause regression issues, so we will
             * output a banner when we see this an fail on the new interfaces.
             */
            if( ( this_lcl->dwFlags & DDRAWISURF_HASDC ) &&
                !( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
            {
                DPF_ERR( "***************************************************" );
                DPF_ERR( "** Application called Unlock w/o releasing the DC!!" );
                DPF_ERR( "***************************************************" );

                if( ( this_int->lpVtbl != &ddSurfaceCallbacks ) &&
                    ( this_int->lpVtbl != &ddSurface2Callbacks ) )
                {
                    return DDERR_GENERIC;
                }
            }

            /*
             * if no rect list, no one has locked
             */
            parl = this->lpRectList;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if(this->dwGlobalFlags & DDRAWISURFGBL_FASTLOCKHELD)
    {
        DPF(4, "Performing fast unlock");
        --this->dwUsageCount;
        DDASSERT(this->dwUsageCount == 0);
        err = DD_OK;
        this->dwGlobalFlags &= ~DDRAWISURFGBL_FASTLOCKHELD;
    }
    else
    {
        err = InternalUnlock(this_lcl,lpSurfaceData,lpDestRect,DDLOCK_TAKE_WIN16);
    }

    //We only bump the surface stamp if the lock was NOT read only
    if ( (this->dwGlobalFlags & DDRAWISURFGBL_READONLYLOCKHELD) == 0)
    {
        DPF(4,"Bumping surface stamp");
        BUMP_SURFACE_STAMP(this);
    }
    this->dwGlobalFlags &= ~DDRAWISURFGBL_READONLYLOCKHELD;

    #ifdef WINNT
        if( SURFACE_LOST( this_lcl ) )
        {
            err = DDERR_SURFACELOST;
        }
    #endif

    return err;

} /* unlockMain */


/*
 * DD_Surface_Unlock
 *
 * Done accessing a surface.  This is the version used for interfaces
 * IDirectDrawSurface, IDirectDrawSurface2, and IDirectDrawSurface3.
 */
HRESULT DDAPI DD_Surface_Unlock(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPVOID lpSurfaceData )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    HRESULT                     ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Unlock %p", lpDDSurface);

    ddrval = unlockMain(lpDDSurface, lpSurfaceData, NULL);

    LEAVE_DDRAW();

    return (ddrval);

}  /* DD_Surface_Unlock */


/*
 * DD_Surface_Unlock4
 *
 * Done accessing a surface.  This is the version used for interfaces
 * IDirectDrawSurface4 and higher.
 */
HRESULT DDAPI DD_Surface_Unlock4(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect )
{
    HRESULT ddrval;
    RECT rDest;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Unlock4");

    ddrval = unlockMain(lpDDSurface, NULL, lpDestRect);

    LEAVE_DDRAW();

    return (ddrval);

}  /* DD_Surface_Unlock4 */


#ifdef USE_ALIAS
    /*
     * BreakSurfaceLocks
     *
     * Mark any locks held by a surface as broken. This is called when
     * invalidating a surface (due to a mode switch). The semantics are
     * that a surface destroy is an implict unlock on all locks on the
     * surface. Thus, we don't call the HAL unlock, only the HAL destroy.
     */
    void BreakSurfaceLocks( LPDDRAWI_DDRAWSURFACE_GBL this )
    {
        LPACCESSRECTLIST lpRect;

        DPF( 4, "Breaking locks on the surface 0x%08x", this );

        if( 0UL != this->dwUsageCount )
        {
            if( NULL != this->lpRectList )
            {
                for( lpRect = this->lpRectList; NULL != lpRect; lpRect = lpRect->lpLink )
                    lpRect->dwFlags |= ACCESSRECT_BROKEN;
            }
            else
            {
                DDASSERT( 1UL == this->dwUsageCount );

                this->dwGlobalFlags |= DDRAWISURFGBL_LOCKBROKEN;
            }
        }
    } /* BreakSurfaceLocks */
#endif /* USE_ALIAS */

/*
 * RemoveProcessLocks
 *
 * Remove all Lock calls made a by process on a surface.
 * assumes driver lock is taken
 */
void RemoveProcessLocks(
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl,
    LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
    DWORD pid )
{
    LPDDRAWI_DIRECTDRAW_GBL   pdrv=pdrv_lcl->lpGbl;
    LPDDRAWI_DDRAWSURFACE_GBL this=this_lcl->lpGbl;
    DWORD                     refcnt;
    LPACCESSRECTLIST          parl;
    LPACCESSRECTLIST          last;
    LPACCESSRECTLIST          next;

    /*
     * remove all rectangles we have accessed
     */
    refcnt = (DWORD) this->dwUsageCount;
    if( refcnt == 0 )
    {
        return;
    }
    parl = this->lpRectList;
    last = NULL;
    while( parl != NULL )
    {
        next = parl->lpLink;
        if( parl->lpOwner == pdrv_lcl )
        {
            DPF( 5, "Cleaning up lock to rectangle (%ld,%ld),(%ld,%ld) by pid %08lx",
                 parl->rDest.left,parl->rDest.top,
                 parl->rDest.right,parl->rDest.bottom,
                 pid );
            refcnt--;
            this->dwUsageCount--;
            CHANGE_GLOBAL_CNT( pdrv, this, -1 );
            #ifdef USE_ALIAS
                /*
                 * If this was a vram style lock and it didn't hold the Win16 lock
                 * then we need to decrement the number of aliased locks held.
                 */
                if( ( parl->dwFlags & ACCESSRECT_VRAMSTYLE ) &&
                    ( parl->dwFlags & ACCESSRECT_NOTHOLDINGWIN16LOCK ) )
                {
                    DDASSERT( 0UL != pdrv->dwAliasedLockCnt );
                    undoAliasedLock( pdrv );
                    if(!(this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                    {
                        // This is used to check if the graphics adapter is busy for Blts, Flips, etc
                        // instead of dwAliasedLockCnt. Make sure we decrement it for everything but
                        // execute buffers.
                        if( ( pdrv->lpDDKernelCaps == NULL ) ||
                            !( pdrv->lpDDKernelCaps->dwCaps  & DDKERNELCAPS_LOCK ) )
                        {
                            pdrv->dwBusyDueToAliasedLock--;
                        }
                    }

                    /*
                     * If we are holding a referenced to an aliased heap release it
                     * now.
                     */
                    if( NULL != parl->lpHeapAliasInfo )
                        ReleaseHeapAliases( GETDDVXDHANDLE( pdrv_lcl ) , parl->lpHeapAliasInfo );
                }
            #endif /* USE_ALIAS */
            if( last == NULL )
            {
                this->lpRectList = next;
            }
            else
            {
                last->lpLink = next;
            }
            MemFree( parl );
        }
        else
        {
            last = parl;
        }
        parl = next;
    }

    #ifdef USE_ALIAS
        /*
         * Was the entire surface locked with a video memory style
         * lock (but without the Win16 lock held)? If so then we
         * again need to decrement the aliased lock count.
         */
        if( ( this->dwGlobalFlags & DDRAWISURFGBL_LOCKVRAMSTYLE ) &&
            ( this->dwGlobalFlags & DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK ) )
        {
            DDASSERT( 0UL != pdrv->dwAliasedLockCnt );
            undoAliasedLock( pdrv );
            if(!(this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
            {
                // This is used to check if the graphics adapter is busy for Blts, Flips, etc
                // instead of dwAliasedLockCnt. Make sure we decrement it for everything but
                // execute buffers.
                if( ( pdrv->lpDDKernelCaps == NULL ) ||
                   !( pdrv->lpDDKernelCaps->dwCaps  & DDKERNELCAPS_LOCK ) )
                {
                    pdrv->dwBusyDueToAliasedLock--;
                }
            }

            /*
             * If we are holding a referenced to an aliased heap release it
             * now.
             */
            if( NULL != this_lcl->lpSurfMore->lpHeapAliasInfo )
            {
                ReleaseHeapAliases( GETDDVXDHANDLE( pdrv_lcl ), this_lcl->lpSurfMore->lpHeapAliasInfo );
                this_lcl->lpSurfMore->lpHeapAliasInfo = NULL;
            }
        }
    #endif /* USE_ALIAS */

    /*
     * remove the last of the refcnts we have
     */
    this->dwUsageCount -= (short) refcnt;
    CHANGE_GLOBAL_CNT( pdrv, this, -1*refcnt );

    /*
     * clean up the win16 lock
     *
     * NOTE: This is not surface related this just breaks the Win16
     * lock and device busy bits held by the device. You realy only
     * want to do this once not once per surface.
     */

    /*
    * blow away extra locks if the the process is still alive
    */
    if( pid == GetCurrentProcessId() )
    {
        DPF( 5, "Cleaning up %ld Win16 locks", pdrv->dwWin16LockCnt );
        while( pdrv->dwWin16LockCnt > 0 )
        {
            tryDoneLock( pdrv_lcl, pid );
        }
    }
    else
    {
        /*
        * !!! NOTE: Does not reset the BUSY bit!
        */
        DPF( 4, "Process dead, resetting Win16 lock cnt" );
        pdrv->dwWin16LockCnt = 0;
    }
    DPF( 5, "Cleaned up %ld locks taken by by pid %08lx", refcnt, pid );

} /* RemoveProcessLocks */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddsatch.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddsatch.c
 *  Content: 	DirectDraw attached surface support.
 *		AddAttachedSurface, DeleteAttachedSurface,
 *		EnumAttachedSurfaces, GetAttachedSurface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   14-jan-95	craige	initial implementation
 *   22-jan-95	craige	made 32-bit + ongoing work
 *   31-jan-95	craige	and even more ongoing work...
 *   27-feb-95	craige 	new sync. macros
 *   03-mar-95	craige	GetAttachedSurface code
 *   19-mar-95	craige	use HRESULTs
 *   23-mar-95	craige	expanded functionality
 *   01-apr-95	craige	happy fun joy updated header file
 *   12-apr-95	craige	proper csect call order
 *   06-may-95	craige	use driver-level csects only
 *   11-jun-95	craige	comment out fliplist code
 *   13-jun-95	kylej	added flippable chain side-effects for
 *			AddAttachedSurface and DeleteAttachedSurface
 *			added DeleteOneLink, added a cleanup parameter to
 *                      DeleteOneAttachment
 *   16-jun-95	craige	removed fpVidMemOrig
 *   17-jun-95	craige	new surface structure
 *   20-jun-95  kylej   prevent detachments of implicit attachments
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns
 *   04-jul-95	craige	YEEHAW: new driver struct; SEH
 *   31-jul-95	craige	validate flags
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consistency with Direct3D
 *   07-dec-95  colinmc added mip-map support
 *   18-dec-95  colinmc added ability to add system memory z-buffer as
 *                      attachement to video memory surface.
 *   18-dec-95  colinmc additional caps bit checking in GetAttachedSurface
 *   02-jan-96	kylej	handle new interface structs
 *   12-feb-96  colinmc surface lost flag moved from global to local object
 *   20-mar-96  colinmc Bug 13634: Unidirectional attached surfaces can
 *                      cause infinite loop on cleanup
 *   12-may-96  colinmc Bug 22401: Missing return from DeleteOneAttachment
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *
 ***************************************************************************/
#include "ddrawpr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateMipMapCount"

/*
 * UpdateMipMapCount
 *
 * When we add or remove levels from a mip-map the mip-map count changes for
 * those levels left in the original chain (as the mip-map count gives the
 * number of levels in the chain). Hence we need to recompute the mip-map
 * level count when a mip-map is added or removed from a chain.
 */
void UpdateMipMapCount( LPDDRAWI_DDRAWSURFACE_INT psurf_int )
{
    LPDDRAWI_DDRAWSURFACE_INT pparentsurf_int;
    DWORD                     dwLevels;

    /*
     * Find the top most level mip-map in the chain.
     */
    pparentsurf_int = psurf_int;
    while( pparentsurf_int != NULL )
    {
	psurf_int = pparentsurf_int;
	pparentsurf_int = FindParentMipMap( psurf_int );
    }
    pparentsurf_int = psurf_int;

    /*
     * We have the top most level in the mip-map chain. Lowe count
     * the levels in the chain.
     */
    dwLevels = 0UL;
    while( psurf_int != NULL )
    {
	dwLevels++;
	psurf_int = FindAttachedMipMap( psurf_int );
    }

    /*
     * Now update all the levels with their new mip-map count.
     */
    psurf_int = pparentsurf_int;
    while( psurf_int != NULL )
    {
	psurf_int->lpLcl->lpSurfMore->dwMipMapCount = dwLevels;
	dwLevels--;
	psurf_int = FindAttachedMipMap( psurf_int );
    }

    DDASSERT( dwLevels == 0UL );
} /* UpdateMipMapCount */

/*
 * AddAttachedSurface
 *
 * Add an attached surface to another.
 * Assumes that all parameters coming in are VALID!
 */
HRESULT AddAttachedSurface( LPDDRAWI_DDRAWSURFACE_INT psurf_from_int,
			    LPDDRAWI_DDRAWSURFACE_INT psurf_to_int,
			    BOOL implicit )
{
    LPATTACHLIST		pal_from;
    LPATTACHLIST		pal_to;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf_from;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_from_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf_to;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_to_lcl;

    psurf_from_lcl = psurf_from_int->lpLcl;
    psurf_from = psurf_from_lcl->lpGbl;
    psurf_to_lcl = psurf_to_int->lpLcl;
    psurf_to = psurf_to_lcl->lpGbl;

    /*
     * allocate attachment structures
     */
    pal_from = MemAlloc( sizeof( ATTACHLIST ) );
    if( pal_from == NULL )
    {
	return DDERR_OUTOFMEMORY;
    }
    pal_to = MemAlloc( sizeof( ATTACHLIST ) );
    if( pal_to == NULL )
    {
	MemFree( pal_from );
	return DDERR_OUTOFMEMORY;
    }

#ifdef WINNT
    /*
     * let the kernel know about the attachment
     * ...only if the driver isn't emulated
     */
    if ( psurf_from_lcl->lpSurfMore->lpDD_lcl->lpGbl->hDD )
    {
        if ( !DdAttachSurface(psurf_from_lcl, psurf_to_lcl) )
        {
            /*
             * ATTENTION
             * Hack o rama for NT5 b1. The kernel will fail this attach for the primary chain if
             * it ends up in system memory due to an out of vidmem. The kernel doesn't like
             * the user-mode address '0xffbadbad'. Wonder why?
             * For now, we'll just carry on regardless.
             */
            DPF(0,"DdAttachSurface failed!");
            //MemFree( pal_from );
            //MemFree( pal_to );
            //return DDERR_OUTOFMEMORY;
        }
    }
#endif

    /*
     * mark as implicit if created as part of an initial complex structure
     */
    if( implicit )
    {
	pal_from->dwFlags |= DDAL_IMPLICIT;
	pal_to->dwFlags |= DDAL_IMPLICIT;
    }
    else
    {
	//  The surface being attached to holds a reference count on the surface
	//  attached from if the attachment is not implicit.
	DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)psurf_to_int );
	DPF(3, "Attachment ADDREF %08lx", psurf_to_int);
    }

    /*
     * connect the surfaces
     */
    pal_from->lpIAttached = psurf_to_int;
    pal_from->lpAttached = psurf_to_lcl;
    pal_from->lpLink = psurf_from_lcl->lpAttachList;
    psurf_from_lcl->lpAttachList = pal_from;
    psurf_from_lcl->dwFlags |= DDRAWISURF_ATTACHED;

    pal_to->lpIAttached = psurf_from_int;
    pal_to->lpAttached = psurf_from_lcl;
    pal_to->lpLink = psurf_to_lcl->lpAttachListFrom;
    psurf_to_lcl->lpAttachListFrom = pal_to;
    psurf_to_lcl->dwFlags |= DDRAWISURF_ATTACHED_FROM;

    return DD_OK;
} /* AddAttachedSurface */

#undef DPF_MODNAME
#define DPF_MODNAME "AddAttachedSurface"

BOOL isImplicitAttachment( LPDDRAWI_DDRAWSURFACE_INT this_int,
		           LPDDRAWI_DDRAWSURFACE_INT pattsurf_int)
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	pattsurf_lcl;
    LPATTACHLIST		curr;

    this_lcl = this_int->lpLcl;
    pattsurf_lcl = pattsurf_int->lpLcl;

    /*
     * see if specified surface is attached
     */
    curr = this_lcl->lpAttachList;
    while( curr != NULL )
    {
	if( curr->lpIAttached == pattsurf_int )
	{
	    break;
	}
	curr = curr->lpLink;
    }

    if( (curr != NULL) && (curr->dwFlags & DDAL_IMPLICIT) )
	return TRUE;

    return FALSE;
}


/*
 * DD_Surface_AddAttachedSurface
 */
HRESULT DDAPI DD_Surface_AddAttachedSurface(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAWSURFACE lpDDAttachedSurface )
{
    LPDDRAWI_DDRAWSURFACE_INT       this_int;
    LPDDRAWI_DDRAWSURFACE_LCL       this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT       this_attached_int;
    LPDDRAWI_DDRAWSURFACE_LCL       this_attached_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL       this;
    LPDDRAWI_DDRAWSURFACE_GBL       this_attached;
    DWORD                           rc;
    LPATTACHLIST                    pal;
    LPATTACHLIST                    pal_next;
    LPDDHALSURFCB_ADDATTACHEDSURFACE    aasfn;
    LPDDHALSURFCB_ADDATTACHEDSURFACE    aashalfn;
    DDHAL_ADDATTACHEDSURFACEDATA        aasd;
    DWORD                           caps;
    DWORD                           hitcaps;
    LPDDRAWI_DIRECTDRAW_LCL         pdrv_lcl;
    BOOL                            emulation;
    BOOL                            was_implicit;
    BOOL                            has_excl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_AddAttachedSurface");

    /*
     * validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        this_attached_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDAttachedSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_attached_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_attached_lcl = this_attached_int->lpLcl;
        this = this_lcl->lpGbl;
        this_attached = this_attached_lcl->lpGbl;
        pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

        //
        // For DX7, we will DISALLOW any attachment that doesn't involve a z buffer.
        // The exact rule is: exactly one of the two surfaces must be a Z buffer, AND
        // exactly one of the two surfaces must NOT be a Z buffer.
        //
        if (!LOWERTHANSURFACE7(this_int))
        {
            DWORD dwBothCaps;

            dwBothCaps = this_lcl->ddsCaps.dwCaps ^ this_attached_lcl->ddsCaps.dwCaps;
            if (0 == (dwBothCaps & DDSCAPS_ZBUFFER) )
            {
                DPF(0,"You can only attach Z buffers in DX7. No other surface type can be attached.");
                DPF(0,"Mipmaps, flipping chains and cube maps must be created by ONE call to CreateSurface.");
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
            }
        }

        /*
         * Can't attach execute buffers to anything.
         *
         * !!! NOTE; Look into this. Would there be any value
         * in being able to attach execute buffers to each other.
         * Batch system to video memory transfer perhaps?
         */
        if( ( this_lcl->ddsCaps.dwCaps | this_attached_lcl->ddsCaps.dwCaps ) & DDSCAPS_EXECUTEBUFFER )
        {
            DPF_ERR( "Invalid surface types: can't attach surface" );
            LEAVE_DDRAW();
            return DDERR_CANNOTATTACHSURFACE;
        }

        /*
         * Cubemaps can't be attached. period
         */
        if( (( this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP ) && (0==(this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER)) ) )
        {
            DPF_ERR( "Can only attach zbuffers to cubemap surfaces" );
            LEAVE_DDRAW();
            return DDERR_CANNOTATTACHSURFACE;
        }

        //
        // If it is an Optimized surface, then continue only if:
        // 1) The current and the attached surface are non-empty
        // 2) Both are texture & mipmap
        // 3) Both have the same optimization caps
        //
        // For now, if the current surface is optimized, quit
        if ((this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED) ||
            (this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
        {
                DPF_ERR( "Cannot attach to an optimized surface" );
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
        }

        /*
         * Can't attach a backbuffer to a non-exclusive or non-fullscreen primary
         */
        CheckExclusiveMode(this_lcl->lpSurfMore->lpDD_lcl, NULL , &has_excl, FALSE, 
            NULL, FALSE);
        if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
            && ( (!has_excl)
                 || !(this->lpDD->dwFlags & DDRAWI_FULLSCREEN) ) )
        {
            DPF_ERR( "Must be in full-screen exclusive mode to create a flipping primary surface" );
            LEAVE_DDRAW();
            return DDERR_NOEXCLUSIVEMODE;
        }

        /*
         * same surface?
         */
        if( this_lcl == this_attached_lcl )
        {
            DPF_ERR( "Can't attach surface to itself" );
            LEAVE_DDRAW();
            return DDERR_CANNOTATTACHSURFACE;
        }

        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
        if( SURFACE_LOST( this_attached_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        /*
         * are the surfaces already attached?
         */
        pal = this_lcl->lpAttachList;
        while( pal != NULL )
        {
            if( pal->lpIAttached == this_attached_int )
            {
                DPF_ERR( "Surface already attached" );
                LEAVE_DDRAW();
                return DDERR_SURFACEALREADYATTACHED;
            }
            pal = pal->lpLink;
        }

        /*
         * BEHAVIOUR CHANGE FOR DX5
         *
         * We do not allow attaching surfaces created with different
         * DirectDraw objects.
         */
        if (this_lcl->lpSurfMore->lpDD_lcl->lpGbl != this_attached_lcl->lpSurfMore->lpDD_lcl->lpGbl)
        {
            /*
             * Don't check if either device isn't a display driver (i.e. 3dfx)
             * since that's a back-compat hole.
             */
            if ( (this->lpDD->dwFlags & DDRAWI_DISPLAYDRV) &&
                 (this_attached->lpDD->dwFlags & DDRAWI_DISPLAYDRV) )
            {
                DPF_ERR("Can't attach surfaces between different direct draw devices");
                LEAVE_DDRAW();
                return DDERR_DEVICEDOESNTOWNSURFACE;
            }
        }

        /*
         * Do sizes match?
         */
        if( ( ( this_lcl->ddsCaps.dwCaps & this_attached_lcl->ddsCaps.dwCaps ) & ( DDSCAPS_TEXTURE | DDSCAPS_MIPMAP ) ) ==
            ( DDSCAPS_TEXTURE | DDSCAPS_MIPMAP ) )
        {
            /*
             * If attaching a mip-map we ensure that the child is no bigger than the
             * parent. We don't insist on strict power of 2 smaller as a mip-map
             * may have missing levels.
             */
            if( ( this->wWidth  < this_attached->wWidth  ) ||
                ( this->wHeight < this_attached->wHeight ) )
            {
                DPF_ERR( "Attached mip-map must be no larger than parent map" );
                    LEAVE_DDRAW();
                    return DDERR_CANNOTATTACHSURFACE;
                }
            }
            else
            {
                if( !(!(this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) &&
                      (this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)) &&
                    !((this_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) &&
                      !(this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE)) )
                {
                    if( (this->wHeight != this_attached->wHeight) ||
                        (this->wWidth != this_attached->wWidth) )
                    {
                        DPF_ERR( "Can't attach surfaces of differing sizes" );
                        LEAVE_DDRAW();
                        return DDERR_CANNOTATTACHSURFACE;
                    }
                }
            }

        /*
         * don't allow multiple of the same type of surface to be attached to a surface
         */
        caps = this_attached_lcl->ddsCaps.dwCaps & (DDSCAPS_TEXTURE|DDSCAPS_MIPMAP|
                                                    DDSCAPS_ALPHA|DDSCAPS_ZBUFFER);
        if( caps )
        {
            pal = this_lcl->lpAttachList;
            while( pal != NULL )
            {
                hitcaps = pal->lpAttached->ddsCaps.dwCaps & caps;
                if( hitcaps )
                {
                    /*
                     * Horrible special case. We can attach more than one texture
                     * to a surface as long as one of them is a mip-map and the other
                     * isn't.
                     */
                    if( !( hitcaps & DDSCAPS_TEXTURE ) ||
                        !( ( pal->lpAttached->ddsCaps.dwCaps ^ caps ) & DDSCAPS_MIPMAP ) )
                    {
                        DPF_ERR( "Can't attach 2 or more of the same type of surface to one surface" );
                        LEAVE_DDRAW();
                        return DDERR_CANNOTATTACHSURFACE;
                    }
                }
                pal_next = pal->lpLink;
                pal = pal_next;
            }
        }

        /*
         * If the attached surface could be part of a flippable chain with the
         * original surface but it is already flippable, we cannot attach it.
         * (It would create a non-simple flipping chain).
         */
        if( ( this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP ) &&
            CanBeFlippable( this_lcl, this_attached_lcl ) )
        {
            DPF_ERR( "Can't attach a flippable surface to another flippable surface of the same type");
            LEAVE_DDRAW();
            return DDERR_CANNOTATTACHSURFACE;
        }

        /*
         * Don't allow an emulated surface to be attached to a non-emulated
         * surface.
         */
        if( ( (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
              !(this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)) ||
            (!(this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
             (this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) ) )
        {
            /*
             * Special case: We allow s system memory z-buffer to be attached to
             * a video memory surface. This to keep the software rendering people
             * happy. They want to use a video memory surface as rendering target
             * so they get the benefit from page flipping but they don't want to
             * have a z-buffer in VRAM as they have to read from it and thats
             * slooowwww... Its also really useful to have the z-buffer as an
             * attachment. So just to be nice...
             *
             * !!! NOTE: This means that we are going to invoke the
             * AddAttachedSurface HAL member with one system and one video
             * memory surface. What are the impliciations of this.
             */
            if( !( ( this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER ) &&
                   ( this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) ) )
            {
                DPF_ERR( "Can't attach an emulated surface to a non-emulated surface.");
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
            }
        }

        /*
         * Check to see if both surfaces are emulated or not
         */
        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
        {
            aasfn = pdrv_lcl->lpDDCB->HELDDSurface.AddAttachedSurface;
            aashalfn = aasfn;
            emulation = TRUE;
        }
        else
        {
            aashalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.AddAttachedSurface;
            aasfn = pdrv_lcl->lpDDCB->HALDDSurface.AddAttachedSurface;
            emulation = FALSE;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * ask driver if it is OK to attach these surfaces
     */
    if( aashalfn != NULL)
    {
        aasd.AddAttachedSurface = aashalfn;
        aasd.lpDD = pdrv_lcl->lpGbl;
        aasd.lpDDSurface = this_lcl;
        aasd.lpSurfAttached = this_attached_lcl;
        DOHALCALL( AddAttachedSurface, aasfn, aasd, rc, emulation );
        if( rc == DDHAL_DRIVER_HANDLED )
        {
            if( aasd.ddRVal != DD_OK )
            {
                LEAVE_DDRAW();
                return aasd.ddRVal;
            }
        }
    }

    // Check to see if we need to add this surface to a flippable chain
    // or if we need to form a new flippable chain.  If the attached
    // surface is already part of a flippable chain, we will attach it but
    // we won't try to form another flippable chain.
    if( !CanBeFlippable( this_lcl, this_attached_lcl ) ||
        ( this_attached_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP ) )
    {
        // no flippable chain can be formed.
        // go ahead and attach the surface
        AddAttachedSurface( this_int, this_attached_int, FALSE );
        DPF( 2, "Attached surface, no flippable chain formed" );

        if( this_attached_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
        {
            // This is a mip-map chain. We have added new levels so
            // we need to update the mip-map level count on each
            // level
            DPF( 2, "Updating mip-map level count" );
            UpdateMipMapCount( this_int );
        }
    }
    else
    {
        // These surfaces can be combined to form a flippable chain.
        // Check to see if this surface is already flippable
        if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP ) )
        {
            // neither surface is flippable.
            // attach the surfaces to form a two-member flippable chain
            rc = AddAttachedSurface( this_int, this_attached_int, FALSE );
            if( rc == DD_OK )
            {
                // We are performing this attachment for the app even though it
                // wasn't explicitly requested so make it implicit.
                rc = AddAttachedSurface( this_attached_int, this_int, TRUE );
            }
            if( rc != DD_OK )
            {
                DPF_ERR( "Unable to attach surface, AddAttachedSurface failed.");
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
            }

            // now decide which will be front and which will be back
            if( this_lcl->ddsCaps.dwCaps & DDSCAPS_BACKBUFFER )
            {
                // make attached surface the front buffer
                this_attached_lcl->ddsCaps.dwCaps |= DDSCAPS_FRONTBUFFER;
                this_attached_lcl->dwBackBufferCount = 1;
            }
            else
            {
                // make attached surface the back buffer
                this_attached_lcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
                this_lcl->ddsCaps.dwCaps |= DDSCAPS_FRONTBUFFER;
                this_lcl->dwBackBufferCount = 1;
            }
            this_lcl->ddsCaps.dwCaps |= DDSCAPS_FLIP;
            this_attached_lcl->ddsCaps.dwCaps |= DDSCAPS_FLIP;
            DPF( 2, "Attached surface, two surface flippable chain formed" );
        }
        else
        {
            // this_attached will be made part of the flippable chain
            // add this_attached to the flippable chain that the current
            // surface is already part of.  Find the next surface in the
            // chain after the current surface.
            LPDDRAWI_DDRAWSURFACE_INT   next_int;
            LPDDRAWI_DDRAWSURFACE_LCL   next_lcl;
            LPDDRAWI_DDRAWSURFACE_GBL   next;
            LPDDRAWI_DDRAWSURFACE_INT   front_int;
            LPDDRAWI_DDRAWSURFACE_LCL   front_lcl;
            LPDDRAWI_DDRAWSURFACE_GBL   front;
            LPDDRAWI_DDRAWSURFACE_INT   current_int;
            LPDDRAWI_DDRAWSURFACE_LCL   current_lcl;
            LPDDRAWI_DDRAWSURFACE_GBL   current;

            front_int = NULL;
            next_int = FindAttachedFlip( this_int );
            // traverse the flippable chain to find the front buffer
            for(current_int = next_int;
                current_int != NULL;
                current_int = FindAttachedFlip( current_int ) )
            {
                current_lcl = current_int->lpLcl;
                current = current_lcl->lpGbl;
                if( current_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER )
                {
                    front_int = current_int;
                    break;
                }
            }
            if( ( next_int == NULL ) || ( front_int == NULL ) )
            {
                DPF_ERR( "Invalid flippable chain, surface not attached" );
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
            }
            front_lcl = front_int->lpLcl;
            front = front_lcl->lpGbl;
            next_lcl = next_int->lpLcl;
            next = next_lcl->lpGbl;

            // get rid of any previous front or backbuffer caps.  They will
            // be restored when this surface is again removed from the chain.
            this_attached_lcl->ddsCaps.dwCaps &=
                ~( DDSCAPS_FRONTBUFFER | DDSCAPS_BACKBUFFER );

            // Find out where the new surface fits in the chain
            // if the surface we are attaching to is the back buffer or
            // a plain surface, then the attached surface is
            // a plain surface.  If the surface we are attaching
            // to is a frontbuffer then the attached surface becomes a
            // backbuffer and the previous backbuffer becomes a plain
            // surface.
            if( this_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER )
            {
                // this_attached becomes the backbuffer.  The previous
                // backbuffer becomes a plain offscreen surface
                this_attached_lcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
                next_lcl->ddsCaps.dwCaps &= ~DDSCAPS_BACKBUFFER;
            }
            this_attached_lcl->ddsCaps.dwCaps |= DDSCAPS_FLIP;
            front_lcl->dwBackBufferCount++;

            // detach the next surface from the current surface and then
            // insert the attached surface.
            was_implicit = isImplicitAttachment( this_int, next_int );
            /*
             * AddRef next_int so that it doesn't go away when we temporarily
             * disconnect it.
         */
            DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)next_int );
            rc = DeleteOneAttachment( this_int, next_int, FALSE, DOA_DELETEIMPLICIT );
            if( rc == DD_OK )
            {
                rc = AddAttachedSurface( this_int, this_attached_int, FALSE );
                if( rc == DD_OK )
                {
                    // if the attachment of next_int to this_int was implicit, make
                    // the attachment of next_int to this_attached_int implicit.
                    rc = AddAttachedSurface( this_attached_int, next_int, was_implicit );
                }
            }
            DD_Surface_Release( (LPDIRECTDRAWSURFACE)next_int );
            if( rc != DD_OK )
            {
                DPF_ERR( "Unable to attach surface, AddAttachedSurface failed.");
                LEAVE_DDRAW();
                return DDERR_CANNOTATTACHSURFACE;
            }
            DPF( 2, "Attached surface, flippable chain lengthened" );
        }
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_AddAttachedSurface */


#undef DPF_MODNAME
#define DPF_MODNAME "DeleteAttachedSurfaces"

/*
 * DeleteOneAttachment
 *
 * delete a single attachment from  surface.
 * performs flippable chain cleanup if the cleanup parameter is TRUE
 * ASSUMES DRIVER LOCK IS TAKEN!
 *
 * If delete_implicit is TRUE then DeleteOneAttachment will break
 * implicit attachments. Otherwise, it is an error to call this
 * function to delete an implicit attachment.
 */
HRESULT DeleteOneAttachment( LPDDRAWI_DDRAWSURFACE_INT this_int,
		             LPDDRAWI_DDRAWSURFACE_INT pattsurf_int,
                             BOOL cleanup,
			     BOOL delete_implicit )
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	pattsurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	pattsurf;
    LPATTACHLIST		curr;
    LPATTACHLIST		last;
    BOOL			addrefed_pattsurf = FALSE;
    BOOL			addrefed_this = FALSE;
    BOOL			addrefed_next = FALSE;
    HRESULT			rc;
    LPDDRAWI_DDRAWSURFACE_INT	next_int;

    DPF( 4, "DeleteOneAttachment: %08lx,%08lx", this_int, pattsurf_int );

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;
    pattsurf_lcl = pattsurf_int->lpLcl;
    pattsurf = pattsurf_lcl->lpGbl;
    if( pattsurf_lcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
    {
        if (dwHelperPid != GetCurrentProcessId())
        {
            if(pattsurf_lcl->lpSurfMore->lpDD_lcl->pD3DIUnknown)
                pattsurf_lcl->lpSurfMore->lpDD_lcl->pFlushD3DDevices2(pattsurf_lcl);
        }
    }

    /*
     * see if specified surface is attached
     */
    curr = this_lcl->lpAttachList;
    last = NULL;
    while( curr != NULL )
    {
	if( curr->lpIAttached == pattsurf_int )
	{
	    break;
	}
	last = curr;
	curr = curr->lpLink;
    }
    if( curr == NULL )
    {
	return DDERR_SURFACENOTATTACHED;
    }

    // don't allow implicitly created attachments to be detached.
    if( ( curr->dwFlags & DDAL_IMPLICIT ) && ( !delete_implicit ) )
    {
	DPF_ERR( "Cannot delete an implicit attachment" );
	return DDERR_CANNOTDETACHSURFACE;
    }

    if( cleanup )
    {
	LPDDRAWI_DDRAWSURFACE_INT	next_next_int;
        LPDDRAWI_DDRAWSURFACE_LCL	next_lcl;
        LPDDRAWI_DDRAWSURFACE_GBL	next;
	LPDDRAWI_DDRAWSURFACE_INT	front_int;
        LPDDRAWI_DDRAWSURFACE_LCL	front_lcl;
        LPDDRAWI_DDRAWSURFACE_GBL	front;
	LPDDRAWI_DDRAWSURFACE_INT	current_int;
	LPDDRAWI_DDRAWSURFACE_LCL	current_lcl;
	LPDDRAWI_DDRAWSURFACE_INT	prev_int;
	BOOL				was_implicit;

	front_int = NULL;
	next_int = FindAttachedFlip( this_int );
	// if next is not equal to pattsurf then this link is not part
	// of a flippable chain.  No other cleanup is necessary.
	if( next_int == pattsurf_int )
	{
	    // find the front buffer in the chain
	    next_int = FindAttachedFlip( pattsurf_int );
	    for(current_int = next_int;
               (current_int != NULL);
	       (current_int = FindAttachedFlip( current_int ) ) )
	    {
		current_lcl = current_int->lpLcl;
		if( current_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER )
		{
		    front_int = current_int;
		    front = front_int->lpLcl->lpGbl;
		}
		if( current_int == pattsurf_int )
		{
		    break;
		}
	        prev_int = current_int;
	    }
	    // if the frontbuffer was not found, don't do any cleanup
	    if( ( next_int != NULL ) && ( front_int != NULL ) )
	    {
		next_lcl = next_int->lpLcl;
		next = next_lcl->lpGbl;
		front_lcl = front_int->lpLcl;
		front_lcl->dwBackBufferCount--;
	        if( front_lcl->dwBackBufferCount == 0 )
	        {
		    // this detachment will destroy the flippable chain
		    next_lcl->ddsCaps.dwCaps &=
		        ~(DDSCAPS_FLIP | DDSCAPS_FRONTBUFFER | DDSCAPS_BACKBUFFER );
		    // restore BACKBUFFER CAP if it was originally created that way
		    if( next_lcl->dwFlags & DDRAWISURF_BACKBUFFER )
		    {
		        next_lcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
		    }
		    // restore FRONTBUFFER CAP if it was originally created that way
		    if( next_lcl->dwFlags & DDRAWISURF_FRONTBUFFER )
		    {
		        next_lcl->ddsCaps.dwCaps |= DDSCAPS_FRONTBUFFER;
		    }
		    addrefed_pattsurf = TRUE;
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)pattsurf_int );
		    addrefed_this = TRUE;
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)this_int );
		    // remove one of the links
		    DeleteOneLink( pattsurf_int, this_int );
	        }
	        else
		{
		    // create a link from the previous surface to the
		    // next surface, bypassing pattsurf
		    was_implicit = isImplicitAttachment( this_int, pattsurf_int );
		    AddAttachedSurface( prev_int, next_int, was_implicit );

		    addrefed_pattsurf = TRUE;
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)pattsurf_int );
		    addrefed_this = TRUE;
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)this_int );
		    addrefed_next = TRUE;
		    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)next_int );
		    // delete the link from pattsurf to next
		    DeleteOneLink( pattsurf_int, next_int );
		    // pattsurf will now be completely removed from the
		    // flippable chain once the final link is deleted.

		    // this detachment will reduce the flippable chain by one
		    // If pattsurf was a backbuffer, make the next surface
		    // in the chain a backbuffer.
		    if( pattsurf_lcl->ddsCaps.dwCaps & DDSCAPS_BACKBUFFER )
		    {
			next_lcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
		    }
		    // If pattsurf was a frontbuffer, make the next surface
		    // in the chain a frontbuffer, and the next surface a
		    // backbuffer.
		    else if( pattsurf_lcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER )
		    {
		        next_lcl->ddsCaps.dwCaps &= ~DDSCAPS_BACKBUFFER;
			next_lcl->ddsCaps.dwCaps |= DDSCAPS_FRONTBUFFER;
			next_lcl->dwBackBufferCount = front_lcl->dwBackBufferCount;
			next_next_int = FindAttachedFlip( next_int );
			if( next_next_int != NULL)
			{
			    next_next_int->lpLcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
			}
			front_lcl->dwBackBufferCount = 0;
		    }
		}
		// reset the flags on the detached surface to indicate
		// that it is no longer part of a flippable chain.
		pattsurf_lcl->ddsCaps.dwCaps &=
		    ~(DDSCAPS_FLIP | DDSCAPS_FRONTBUFFER | DDSCAPS_BACKBUFFER );
		// restore BACKBUFFER CAP if it was originally created that way
		if( pattsurf_lcl->dwFlags & DDRAWISURF_BACKBUFFER )
		{
		    pattsurf_lcl->ddsCaps.dwCaps |= DDSCAPS_BACKBUFFER;
		}
		// restore FRONTBUFFER CAP if it was originally created that way
		if( pattsurf_lcl->dwFlags & DDRAWISURF_FRONTBUFFER )
		{
		    pattsurf_lcl->ddsCaps.dwCaps |= DDSCAPS_FRONTBUFFER;
		}
	    }
	}
    }

    /*
     * delete the attached surface
     */
    rc = DeleteOneLink( this_int, pattsurf_int );


    if( addrefed_pattsurf )
	DD_Surface_Release( (LPDIRECTDRAWSURFACE)pattsurf_int);
    if( addrefed_this )
	DD_Surface_Release( (LPDIRECTDRAWSURFACE)this_int );
    if( addrefed_next )
	DD_Surface_Release( (LPDIRECTDRAWSURFACE)next_int );

    return rc;

} /* DeleteOneAttachment */

/*
 * DeleteOneLink
 *
 * delete a single attachment from  surface.
 * ASSUMES DRIVER LOCK IS TAKEN!
 */
HRESULT DeleteOneLink( LPDDRAWI_DDRAWSURFACE_INT this_int,
		       LPDDRAWI_DDRAWSURFACE_INT pattsurf_int )
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_LCL	pattsurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	pattsurf;
    LPATTACHLIST		curr;
    LPATTACHLIST		last;

    DPF( 4, "DeleteOneLink: %08lx,%08lx", this_int, pattsurf_int );

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;
    pattsurf_lcl = pattsurf_int->lpLcl;
    pattsurf = pattsurf_lcl->lpGbl;

    /*
     * see if specified surface is attached
     */
    curr = this_lcl->lpAttachList;
    last = NULL;
    while( curr != NULL )
    {
	if( curr->lpIAttached == pattsurf_int )
	{
	    break;
	}
	last = curr;
	curr = curr->lpLink;
    }
    if( curr == NULL )
    {
	return DDERR_SURFACENOTATTACHED;
    }

#ifdef WINNT
    /*
     * let the kernel know
     * ...only if there's a kernel ddraw object.
     */
    if ( this_lcl->lpSurfMore->lpDD_lcl->lpGbl->hDD )
    {
        DdUnattachSurface( this_lcl, pattsurf_lcl );
    }
#endif

    /*
     * delete the attached from link
     */
    if( last == NULL )
    {
        this_lcl->lpAttachList = curr->lpLink;
    }
    else
    {
        last->lpLink = curr->lpLink;
    }
    MemFree( curr );

    /*
     * remove the attached to link
     */
    curr = pattsurf_lcl->lpAttachListFrom;
    last = NULL;
    while( curr != NULL )
    {
	if( curr->lpIAttached == this_int )
	{
	    break;
	}
	last = curr;
	curr = curr->lpLink;
    }
    if( curr == NULL )
    {
	return DDERR_SURFACENOTATTACHED;
    }


    /*
     * delete the attached to link
     */
    if( last == NULL )
    {
	pattsurf_lcl->lpAttachListFrom = curr->lpLink;
    }
    else
    {
	last->lpLink = curr->lpLink;
    }

    if( !(curr->dwFlags & DDAL_IMPLICIT))
    {
	DD_Surface_Release( (LPDIRECTDRAWSURFACE)pattsurf_int );
    }

    MemFree( curr );

    return DD_OK;

} /* DeleteOneLink */

/*
 * DD_Surface_DeleteAttachedSurfaces
 */
HRESULT DDAPI DD_Surface_DeleteAttachedSurfaces(
		LPDIRECTDRAWSURFACE lpDDSurface,
		DWORD dwFlags,
		LPDIRECTDRAWSURFACE lpDDAttachedSurface )
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPDDRAWI_DDRAWSURFACE_INT	pattsurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	pattsurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	pattsurf;
    LPATTACHLIST		curr;
    LPATTACHLIST		next;
    HRESULT			ddrval;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_DeleteAttachedSurfaces");

    TRY
    {
	/*
	 * validate parameters
	 */
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;

	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}

	pattsurf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDAttachedSurface;
	if( pattsurf_int != NULL )
	{
	    if( !VALID_DIRECTDRAWSURFACE_PTR( pattsurf_int ) )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDOBJECT;
	    }
	    pattsurf_lcl = pattsurf_int->lpLcl;
	    pattsurf = pattsurf_lcl->lpGbl;
	    if( SURFACE_LOST( pattsurf_lcl ) )
	    {
		LEAVE_DDRAW();
		return DDERR_SURFACELOST;
	    }
	}
	else
	{
	    pattsurf_lcl = NULL;
	    pattsurf = NULL;
	}

        //
        // If it is an Optimized surface, then continue only if:
        // 1) The current and the attached surface are non-empty
        // 2) Both are texture & mipmap
        // 3) Both have the same optimization caps
        //
        // For now, if the current surface is optimized, quit
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }

	/*
	 * delete a single attachment
	 */
	if( pattsurf != NULL )
	{
	    ddrval = DeleteOneAttachment( this_int, pattsurf_int, TRUE, DOA_DONTDELETEIMPLICIT );
	    if( ddrval != DD_OK )
	    {
		LEAVE_DDRAW();
		return ddrval;
	    }
	}
	/*
	 * delete all attachments
	 */
	else
	{
	    curr = this_lcl->lpAttachList;
	    while( curr != NULL )
	    {
		next = curr->lpLink;
		ddrval = DeleteOneAttachment( this_int, curr->lpIAttached, TRUE, DOA_DONTDELETEIMPLICIT );
		if( ddrval != DD_OK )
		{
		    LEAVE_DDRAW();
		    return ddrval;
		}
		curr = next;
	    }
	}

	/*
	 * If the surface whose attachments were removed is a mip-map then
	 * it may have lost mip-map levels. Therefore we need to update its
	 * level count.
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
	    UpdateMipMapCount( this_int );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_DeleteAttachedSurfaces */

/*
 * DeleteAttachedSurfaceLists
 *
 * Delete all attached surface lists from a surface
 * Assumes that all parameters coming in are VALID!
 */
void DeleteAttachedSurfaceLists( LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl )
{
    LPATTACHLIST	curr;
    LPATTACHLIST	next;

    curr = psurf_lcl->lpAttachList;
    while( curr != NULL )
    {
	next = curr->lpLink;
	MemFree( curr );
	curr = next;
    }
    curr = psurf_lcl->lpAttachListFrom;
    while( curr != NULL )
    {
	next = curr->lpLink;
	MemFree( curr );
	curr = next;
    }

    psurf_lcl->lpAttachList = NULL;
    psurf_lcl->lpAttachListFrom = NULL;

} /* DeleteAttachedSurfaceLists */

/*
 * DD_Surface_EnumAttachedSurfaces
 */
HRESULT DDAPI DD_Surface_EnumAttachedSurfaces(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPVOID lpContext,
		LPDDENUMSURFACESCALLBACK lpEnumSurfacesCallback )
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPATTACHLIST		pal;
    DDSURFACEDESC2		dsd;
    DWORD			rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_EnumAttachedSurfaces");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALIDEX_CODE_PTR( lpEnumSurfacesCallback ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	/*
	 * take driver lock just in case callback comes into us
	 */
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
	if( SURFACE_LOST( this_lcl ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_SURFACELOST;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * run the attached list, calling the user's fn each time
     */
    pal = this_lcl->lpAttachList;
    while( pal != NULL )
    {
        LPDIRECTDRAWSURFACE4 intReturned = (LPDIRECTDRAWSURFACE4) pal->lpIAttached;

	FillDDSurfaceDesc2( pal->lpAttached, &dsd );
        if (LOWERTHANSURFACE4(this_int))
        {
            dsd.dwSize = sizeof(DDSURFACEDESC);
	    DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) pal->lpIAttached , & IID_IDirectDrawSurface, (void**) &intReturned );
        }
	else if (this_int->lpVtbl == &ddSurface4Callbacks)
	{
	    DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) pal->lpIAttached , & IID_IDirectDrawSurface4, (void**) &intReturned );
	}
        else
        {
	    DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) pal->lpIAttached , & IID_IDirectDrawSurface7, (void**) &intReturned );
        }

	rc = lpEnumSurfacesCallback( (LPDIRECTDRAWSURFACE) intReturned, (LPDDSURFACEDESC) &dsd, lpContext );
	if( rc == 0 )
	{
	    break;
	}
	pal = pal->lpLink;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_EnumAttachedSurfaces */



HRESULT DDAPI Internal_GetAttachedSurface(
    REFIID riid,
    LPDIRECTDRAWSURFACE4 lpDDSurface,
    LPDDSCAPS2 lpDDSCaps,
    LPVOID *lplpDDAttachedSurface)
{
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;

    LPATTACHLIST        pal;
    DWORD           caps;
    DWORD           testcaps;
    DWORD           ucaps;
    DWORD           caps2;
    DWORD           testcaps2;
    DWORD           ucaps2;
    DWORD           caps3;
    DWORD           testcaps3;
    DWORD           ucaps3;
    DWORD           caps4;
    DWORD           testcaps4;
    DWORD           ucaps4;
    BOOL            ok;

    this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;
    *lplpDDAttachedSurface = NULL;
    pdrv = this->lpDD;

    /*
     * look for the surface
     */
    pal = this_lcl->lpAttachList;
    testcaps = lpDDSCaps->dwCaps;
    testcaps2 = lpDDSCaps->dwCaps2;
    testcaps3 = lpDDSCaps->dwCaps3;
    testcaps4 = lpDDSCaps->dwCaps4;
    while( pal != NULL )
    {
        ok = TRUE;
        caps = pal->lpAttached->ddsCaps.dwCaps;
        caps2 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2;
        caps3 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps3;
        caps4 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps4;
        ucaps = caps & testcaps;
        ucaps2 = caps2 & testcaps2;
        ucaps3 = caps3 & testcaps3;
        ucaps4 = caps4 & testcaps4;
        if( ucaps | ucaps2 | ucaps3 | ucaps4 )
        {
            /*
             * there are caps in common, make sure that the caps to test
             * were all there
             */
            if( (ucaps & testcaps) == testcaps &&
                (ucaps2 & testcaps2) == testcaps2 &&
                (ucaps3 & testcaps3) == testcaps3 &&
                (ucaps4 & testcaps4) == testcaps4   )
            {
            }
            else
            {
                ok = FALSE;
            }
        }
        else
        {
            ok = FALSE;
        }


        if( ok )
        {
            /*
             * QI for the appropriate Surface interface and return it
             */
            DD_Surface_QueryInterface(
                (LPDIRECTDRAWSURFACE) pal->lpIAttached,
                riid,
                lplpDDAttachedSurface);

            // DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) pal->lpIAttached );
            // *lplpDDAttachedSurface = (LPDIRECTDRAWSURFACE) pal->lpIAttached;

            return DD_OK;
        }
        pal = pal->lpLink;
    }
    return DDERR_NOTFOUND;

} /* Internal_GetAttachedSurface */

HRESULT WINAPI DDGetAttachedSurfaceLcl(
    LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
    LPDDSCAPS2 lpDDSCaps,
    LPDDRAWI_DDRAWSURFACE_LCL *lplpDDAttachedSurfaceLcl)
{
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    LPDDRAWI_DDRAWSURFACE_GBL   this;

    LPATTACHLIST        pal;
    DWORD           caps;
    DWORD           testcaps;
    DWORD           ucaps;
    DWORD           caps2;
    DWORD           testcaps2;
    DWORD           ucaps2;
    DWORD           caps3;
    DWORD           testcaps3;
    DWORD           ucaps3;
    DWORD           caps4;
    DWORD           testcaps4;
    DWORD           ucaps4;
    BOOL            ok;

    this = this_lcl->lpGbl;
    *lplpDDAttachedSurfaceLcl = NULL;
    pdrv = this->lpDD;

    /*
     * look for the surface
     */
    pal = this_lcl->lpAttachList;
    testcaps = lpDDSCaps->dwCaps;
    testcaps2 = lpDDSCaps->dwCaps2;
    testcaps3 = lpDDSCaps->dwCaps3;
    testcaps4 = lpDDSCaps->dwCaps4;
    while( pal != NULL )
    {
        ok = TRUE;
        caps = pal->lpAttached->ddsCaps.dwCaps;
        caps2 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2;
        caps3 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps3;
        caps4 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps4;
        ucaps = caps & testcaps;
        ucaps2 = caps2 & testcaps2;
        ucaps3 = caps3 & testcaps3;
        ucaps4 = caps4 & testcaps4;
        if( ucaps | ucaps2 | ucaps3 | ucaps4 )
        {
            /*
             * there are caps in common, make sure that the caps to test
             * were all there
             */
            if( (ucaps & testcaps) == testcaps &&
                (ucaps2 & testcaps2) == testcaps2 &&
                (ucaps3 & testcaps3) == testcaps3 &&
                (ucaps4 & testcaps4) == testcaps4   )
            {
            }
            else
            {
                ok = FALSE;
            }
        }
        else
        {
            ok = FALSE;
        }


        if( ok )
        {
            *lplpDDAttachedSurfaceLcl = pal->lpAttached;
            return DD_OK;
        }
        pal = pal->lpLink;
    }
    return DDERR_NOTFOUND;

} /* DDGetAttachedSurfaceLcl */

/*
 * DD_Surface_GetAttachedSurface
 *
 * Search for an attached surface with a cap set.   The caps specified
 * all have to be in the caps of the surface (but the surface can have
 * additional caps)
 */
HRESULT DDAPI DD_Surface_GetAttachedSurface(
        LPDIRECTDRAWSURFACE lpDDSurface,
        LPDDSCAPS lpDDSCaps,
        LPDIRECTDRAWSURFACE FAR * lplpDDAttachedSurface)
{
    HRESULT  hr;
    DDSCAPS2 ddscaps2 = {0,0,0,0};
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetAttachedSurface");

    TRY
    {
        /*
         * Have to duplicate all error checks which come before the lpDDSCaps
         * checks because
         * otherwise we might pass different error returns to the app in error
         * conditions.
         */
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
        if( !VALID_DDSCAPS_PTR( lpDDSCaps ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        ddscaps2.dwCaps = lpDDSCaps->dwCaps;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Invalid DDSCAPS pointer" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    hr = Internal_GetAttachedSurface(
        &IID_IDirectDrawSurface,
        (LPDIRECTDRAWSURFACE4)lpDDSurface,
        &ddscaps2,
        (LPVOID *)lplpDDAttachedSurface
        );

    LEAVE_DDRAW();
    return hr;
}

/*
 * IDirectDrawSurface4::GetAttachedSurface
 */
HRESULT DDAPI DD_Surface_GetAttachedSurface4(
    LPDIRECTDRAWSURFACE4 lpDDSurface,
    LPDDSCAPS2 lpDDSCaps,
    LPDIRECTDRAWSURFACE4 FAR * lplpDDAttachedSurface)
{
    HRESULT  hr;
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    DDSCAPS2    ddsCaps2;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetAttachedSurface4");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
        if( !VALID_DDSCAPS2_PTR( lpDDSCaps ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( lpDDSCaps->dwCaps & ~DDSCAPS_VALID )
        {
            DPF_ERR( "Invalid caps specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }
        if( !VALID_PTR_PTR( lplpDDAttachedSurface ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *lplpDDAttachedSurface = NULL;
        ddsCaps2 = *lpDDSCaps;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    DDASSERT(this_int->lpVtbl == &ddSurface4Callbacks);

    /*
     * mistake in DX6: Internal_GetAttachedSurface never tested the extended caps.
     * To avoid regression in DX7, we have to make IGAS respond the same now that it does
     * test the extended caps. We do this by copying the app's caps and zeroing out the
     * extended ones. 
     */
    ddsCaps2.dwCaps2 = ddsCaps2.dwCaps3 = ddsCaps2.dwCaps4 = 0;
    hr = Internal_GetAttachedSurface(
        &IID_IDirectDrawSurface4,
        lpDDSurface,
        &ddsCaps2,
        (LPVOID *)lplpDDAttachedSurface
        );

    LEAVE_DDRAW();
    return hr;

} /* DD_Surface_GetAttachedSurface4 */

/*
 * IDirectDrawSurface7::GetAttachedSurface
 */
HRESULT DDAPI DD_Surface_GetAttachedSurface7(
    LPDIRECTDRAWSURFACE7 lpDDSurface,
    LPDDSCAPS2 lpDDSCaps,
    LPDIRECTDRAWSURFACE7 FAR * lplpDDAttachedSurface)
{
    HRESULT  hr;
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetAttachedSurface7");

    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( SURFACE_LOST( this_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
        if( !VALID_DDSCAPS2_PTR( lpDDSCaps ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( lpDDSCaps->dwCaps & ~DDSCAPS_VALID )
        {
            DPF_ERR( "Invalid caps specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }
        if( !VALID_PTR_PTR( lplpDDAttachedSurface ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *lplpDDAttachedSurface = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    DDASSERT(this_int->lpVtbl == &ddSurface7Callbacks);

    hr = Internal_GetAttachedSurface(
        &IID_IDirectDrawSurface7,
        (LPDIRECTDRAWSURFACE4)lpDDSurface,
        lpDDSCaps,
        (LPVOID *)lplpDDAttachedSurface
        );

    LEAVE_DDRAW();
    return hr;

} /* DD_Surface_GetAttachedSurface7 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddraw.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw.c
 *  Content:    DirectDraw object support
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   25-dec-94  craige  initial implementation
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   21-jan-95  craige  made 32-bit + ongoing work
 *   31-jan-95  craige  and even more ongoing work...
 *   21-feb-95  craige  disconnect anyone who forgot to do it themselves
 *   27-feb-95  craige  new sync. macros
 *   01-mar-95  craige  flags to Get/SetExclusiveMode
 *   03-mar-95  craige  DuplicateSurface
 *   08-mar-95  craige  GetFourCCCodes, FreeAllSurfaces, GarbageCollect
 *   19-mar-95  craige  use HRESULTs
 *   20-mar-95  craige  new CSECT work
 *   26-mar-95  craige  driver wide color keys for overlays
 *   28-mar-95  craige  added FlipToGDISurface; removed Get/SetColorKey
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  fill in free video memory
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   15-apr-95  craige  implement FlipToGDISurface
 *   06-may-95  craige  use driver-level csects only
 *   14-may-95  craige  disable CTRL_ALT_DEL if exclusive fullscreen
 *   19-may-95  craige  check DDSEMO_ALLOWREBOOT before disabling CAD
 *   22-may-95  craige  use MemAlloc16 for sel. allocation
 *   23-may-95  craige  have GetCaps return HEL caps
 *   28-may-95  craige  implement FreeAllSurfaces; unicode support;
 *                      HAL cleanup: entry for GetScanLine
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   07-jun-95  craige  added StartExclusiveMode
 *   12-jun-95  craige  new process list stuff
 *   16-jun-95  craige  removed fpVidMemOrig
 *   17-jun-95  craige  new surface structure
 *   18-jun-95  craige  new DuplicateSurface code
 *   20-jun-95  craige  need to check fpVidMemOrig for deciding to flip
 *   24-jun-95  craige  don't hide/show cursor - up to app
 *   25-jun-95  craige  pay attention to DDCKEY_COLORSPACE; allow NULL ckey;
 *                      one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  return num of 4cc codes if NULL array specified.
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   30-jun-95  kylej   use GetProcessPrimary instead of lpPrimarySurface,
 *                      invalid all primaries when starting exclusive mode
 *   30-jun-95  craige  turn off all hot keys
 *   01-jul-95  craige  require fullscreen for excl. mode
 *   03-jul-95  craige  YEEHAW: new driver struct; SEH
 *   05-jul-95  craige  added internal FlipToGDISurface
 *   06-jul-95  craige  added Initialize
 *   08-jul-95  craige  added FindProcessDDObject
 *   08-jul-95  kylej   Handle exclusive mode palettes correctly
 *   09-jul-95  craige  SetExclusiveMode->SetCooperativeLevel;
 *                      flush all service when exclusive mode set;
 *                      check style for SetCooperativeLevel
 *   16-jul-95  craige  hook hwnd always
 *   17-jul-95  craige  return unsupported from GetMonitorFrequency if not avail
 *   20-jul-95  craige  don't set palette unless palettized
 *   22-jul-95  craige  bug 230 - unsupported starting modes
 *   01-aug-95  craige  bug 286 - GetCaps should fail if both parms NULL
 *   13-aug-95  craige  new parms to flip
 *   13-aug-95  toddla  added DDSCL_DONTHOOKHWND
 *   20-aug-95  toddla  added DDSCL_ALLOWMODEX
 *   21-aug-95  craige  mode X support
 *   25-aug-95  craige  bug 671
 *   26-aug-95  craige  bug 717
 *   26-aug-95  craige  bug 738
 *   04-sep-95  craige  bug 895: toggle GetVerticalBlankStatus result in emul.
 *   22-sep-95  craige  bug 1275: return # of 4cc codes copied
 *   15-nov-95  jeffno  Initial NT changes: ifdef out all but last routine
 *   27-nov-95  colinmc new member to return the available vram of a given
 *                      type (defined by DDSCAPS).
 *   10-dec-95  colinmc added execute buffer support
 *   18-dec-95  colinmc additional surface caps checking for
 *                      GetAvailableVidMem member
 *   26-dec-95  craige  implement DD_Initialize
 *   02-jan-96  kylej   handle new interface structures
 *   26-jan-96  jeffno  Teensy change in DoneExclusiveMode: bug when only 1 mode avail.
 *   14-feb-96  kylej   Allow NULL hwnd for non-exclusive SetCooperativeLevel
 *   05-mar-96  colinmc Bug 11928: Fixed DuplicateSurface problem caused by
 *                      failing to initialize the back pointer to the
 *                      DirectDraw object
 *   13-mar-96  craige  Bug 7528: hw that doesn't have modex
 *   22-mar-96  colinmc Bug 13316: uninitialized interfaces
 *   10-apr-96  colinmc Bug 16903: HEL uses obsolete FindProcessDDObject
 *   13-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   14-apr-96  colinmc Bug 16855: Can't pass NULL to initialize
 *   03-may-96  kylej   Bug 19125: Preserve V1 SetCooperativeLevel behaviour
 *   27-may-96  colinmc Bug 24465: SetCooperativeLevel(..., DDSCL_NORMAL)
 *                      needs to ensure we are looking at the GDI surface
 *   01-oct-96  ketand  Use GetAvailDriverMemory to free/total vidmem estimates
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   21-jan-97  ketand  Deleted unused Get/SetColorKey. Put existing DDraw windowed
 *                      apps into emulation on multi-mon systems.
 *   30-jan-97  colinmc Work item 4125: Need time bomb for final
 *   29-jan-97  jeffno  Mode13 support. Just debugging changes.
 *   07-feb-97  ketand  Fix Multi-Mon when running EMULATION_ONLY and going full-screen
 *   08-mar-97  colinmc Support for DMA model AGP parts
 *   24-mar-97  jeffno  Optimized Surfaces
 *   30-sep-97  jeffno  IDirectDraw4
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"

/*
 * Caps bits that we don't allow to be specified when asking for
 * available video memory. These are bits which don't effect the
 * allocation of the surface in a vram heap.
 */
#define AVAILVIDMEM_BADSCAPS (DDSCAPS_BACKBUFFER   | \
                              DDSCAPS_FRONTBUFFER  | \
                              DDSCAPS_COMPLEX      | \
                              DDSCAPS_FLIP         | \
                              DDSCAPS_OWNDC        | \
                              DDSCAPS_PALETTE      | \
                              DDSCAPS_SYSTEMMEMORY | \
                              DDSCAPS_VISIBLE      | \
                              DDSCAPS_WRITEONLY)

extern BYTE szDeviceWndClass[];
extern ULONG WINAPI DeviceWindowProc( HWND, UINT, WPARAM, LPARAM );

#undef DPF_MODNAME
#define DPF_MODNAME "GetVerticalBlankStatus"

#if defined(WIN95) || defined(NT_FIX)

    __inline static BOOL IN_VBLANK( void )
    {
        BOOL    rc;
        _asm
        {
            xor eax,eax
            mov dx,03dah    ;status reg. port on color card
            in  al,dx       ;read the status
            and     al,8            ;test whether beam is currently in retrace
            mov rc,eax
        }
        return rc;
    }

    #define IN_DISPLAY() (!IN_VBLANK())

#endif

/*
 * DD_GetVerticalBlankStatus
 */
HRESULT DDAPI DD_GetVerticalBlankStatus(
                LPDIRECTDRAW lpDD,
                LPBOOL lpbIsInVB )
{
    LPDDRAWI_DIRECTDRAW_INT             this_int;
    LPDDRAWI_DIRECTDRAW_LCL             this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL             this;
    LPDDHAL_WAITFORVERTICALBLANK        wfvbhalfn;
    LPDDHAL_WAITFORVERTICALBLANK        wfvbfn;

    ENTER_DDRAW();

    /* Removed because too many: DPF(2,A,"ENTERAPI: DD_GetVerticalBlankStatus"); */

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        #ifdef WINNT
            // Update DDraw handle in driver GBL object.
            this->hDD = this_lcl->hDD;
        #endif //WINNT
        if( !VALID_BOOL_PTR( lpbIsInVB ) )
        {
            DPF_ERR( "Invalid BOOL pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * ask the driver test the VB status
     */
    #pragma message( REMIND( "Need HEL WaitForVerticalBlank (for NT too!)" ))
    #if defined (WIN95) || defined ( NT_FIX )
        if( this->dwFlags & DDRAWI_MODEX )
        {
            *lpbIsInVB = FALSE;
            if( IN_VBLANK() )
            {
                *lpbIsInVB = TRUE;
            }
            LEAVE_DDRAW();
            return DD_OK;
        }
        else
    #endif
    {
        wfvbfn = this_lcl->lpDDCB->HALDD.WaitForVerticalBlank;
        wfvbhalfn = this_lcl->lpDDCB->cbDDCallbacks.WaitForVerticalBlank;
        if( wfvbhalfn != NULL )
        {
            DDHAL_WAITFORVERTICALBLANKDATA      wfvbd;
            DWORD                               rc;

            wfvbd.WaitForVerticalBlank = wfvbhalfn;
            wfvbd.lpDD = this;
            wfvbd.dwFlags = DDWAITVB_I_TESTVB;
            wfvbd.hEvent = 0;
            DOHALCALL( WaitForVerticalBlank, wfvbfn, wfvbd, rc, FALSE );
            if( rc == DDHAL_DRIVER_HANDLED )
            {
                *lpbIsInVB = wfvbd.bIsInVB;
                LEAVE_DDRAW();
                return wfvbd.ddRVal;
            }
        }
    }

    /*
     * no hardware support, so just pretend it works
     */
    {
        static BOOL     bLast=FALSE;
        *lpbIsInVB = bLast;
        bLast = !bLast;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetVerticalBlankStatus */

#undef DPF_MODNAME
#define DPF_MODNAME "GetScanLine"

/*
 * DD_GetScanLine
 */
HRESULT DDAPI DD_GetScanLine(
                LPDIRECTDRAW lpDD,
                LPDWORD lpdwScanLine )
{
    LPDDRAWI_DIRECTDRAW_INT             this_int;
    LPDDRAWI_DIRECTDRAW_LCL             this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL             this;
    LPDDHAL_GETSCANLINE gslhalfn;
    LPDDHAL_GETSCANLINE gslfn;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetScanLine");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        #ifdef WINNT
            // Update DDraw handle in driver GBL object.
            this->hDD = this_lcl->hDD;
        #endif //WINNT
        if( !VALID_DWORD_PTR( lpdwScanLine ) )
        {
            DPF_ERR( "Invalid scan line pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * ask the driver to get the current scanline
     */
    #pragma message( REMIND( "Need HEL GetScanLine" ))
    gslfn = this_lcl->lpDDCB->HALDD.GetScanLine;
    gslhalfn = this_lcl->lpDDCB->cbDDCallbacks.GetScanLine;
    if( gslhalfn != NULL )
    {
        DDHAL_GETSCANLINEDATA   gsld;
        DWORD                   rc;

        gsld.GetScanLine = gslhalfn;
        gsld.lpDD = this;
        DOHALCALL( GetScanLine, gslfn, gsld, rc, FALSE );
        if( rc == DDHAL_DRIVER_HANDLED )
        {
            *lpdwScanLine = gsld.dwScanLine;
            LEAVE_DDRAW();
            return gsld.ddRVal;
        }
    }

    *lpdwScanLine = 0;
    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_GetScanLine */

#undef DPF_MODNAME
#define DPF_MODNAME "BuildDDCAPS"

/*
 * Build a fullsized, API visible DDCAPS structure from the multiple internal
 * caps structures in the global driver object.
 */
static void BuildDDCAPS( LPDDCAPS lpddcaps, LPDDRAWI_DIRECTDRAW_GBL pdrv, BOOL bHEL )
{
    LPDDCORECAPS           lpddcorecaps;
    LPDDNONLOCALVIDMEMCAPS lpddnlvcaps;
    LPDDMORECAPS           lpddmorecaps;
    LPDDSCAPSEX            lpddsExCaps;

    DDASSERT( NULL != lpddcaps );
    DDASSERT( NULL != pdrv );

    lpddcorecaps = ( bHEL ? &( pdrv->ddHELCaps ) : &( pdrv->ddCaps ) );
    lpddnlvcaps  = ( bHEL ? pdrv->lpddNLVHELCaps : pdrv->lpddNLVCaps );
    lpddmorecaps = ( bHEL ? pdrv->lpddHELMoreCaps : pdrv->lpddMoreCaps );
    lpddsExCaps  = ( bHEL ? &pdrv->ddsHELCapsMore : &pdrv->ddsCapsMore );

    memset( lpddcaps, 0, sizeof( DDCAPS ) );
    memcpy( lpddcaps, lpddcorecaps, sizeof( DDCORECAPS ) );
    if( NULL != lpddnlvcaps )
    {
        lpddcaps->dwNLVBCaps     = lpddnlvcaps->dwNLVBCaps;
        lpddcaps->dwNLVBCaps2    = lpddnlvcaps->dwNLVBCaps2;
        lpddcaps->dwNLVBCKeyCaps = lpddnlvcaps->dwNLVBCKeyCaps;
        lpddcaps->dwNLVBFXCaps   = lpddnlvcaps->dwNLVBFXCaps;
        memcpy( &( lpddcaps->dwNLVBRops[0] ), &( lpddnlvcaps->dwNLVBRops[0] ), DD_ROP_SPACE * sizeof( DWORD ) );
    }

    lpddcaps->ddsCaps.dwCaps = lpddcorecaps->ddsCaps.dwCaps;
    memcpy(&lpddcaps->ddsCaps.ddsCapsEx, lpddsExCaps, sizeof(lpddcaps->ddsCaps.ddsCapsEx) );

    if (lpddmorecaps != NULL)
    {
#ifdef POSTPONED2
        lpddcaps->dwAlphaCaps    = lpddmorecaps->dwAlphaCaps;
        lpddcaps->dwSVBAlphaCaps = lpddmorecaps->dwSVBAlphaCaps;
        lpddcaps->dwVSBAlphaCaps = lpddmorecaps->dwVSBAlphaCaps;
        lpddcaps->dwSSBAlphaCaps = lpddmorecaps->dwSSBAlphaCaps;

        lpddcaps->dwFilterCaps    = lpddmorecaps->dwFilterCaps;
        lpddcaps->dwSVBFilterCaps = lpddmorecaps->dwSVBFilterCaps;
        lpddcaps->dwVSBFilterCaps = lpddmorecaps->dwVSBFilterCaps;
        lpddcaps->dwSSBFilterCaps = lpddmorecaps->dwSSBFilterCaps;
        lpddcaps->dwTransformCaps    = lpddmorecaps->dwTransformCaps;
        lpddcaps->dwSVBTransformCaps = lpddmorecaps->dwSVBTransformCaps;
        lpddcaps->dwVSBTransformCaps = lpddmorecaps->dwVSBTransformCaps;
        lpddcaps->dwSSBTransformCaps = lpddmorecaps->dwSSBTransformCaps;

        lpddcaps->dwBltAffineMinifyLimit = lpddmorecaps->dwBltAffineMinifyLimit;
        lpddcaps->dwOverlayAffineMinifyLimit = lpddmorecaps->dwOverlayAffineMinifyLimit;
#endif //POSTPONED2
    }

    lpddcaps->dwSize = sizeof( DDCAPS );
} /* BuildDDCAPS */

#undef DPF_MODNAME
#define DPF_MODNAME "GetCaps"

/*
 * DD_GetCaps
 *
 * Retrieve all driver capabilites
 */
HRESULT DDAPI DD_GetCaps(
    LPDIRECTDRAW lpDD,
    LPDDCAPS lpDDDriverCaps,
    LPDDCAPS lpDDHELCaps )
{
    LPDDRAWI_DIRECTDRAW_INT this_int;
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL this;
    DWORD           dwSize;
    DDCAPS                      ddcaps;
    DDSCAPS                     ddscaps;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetCaps");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        if( (lpDDDriverCaps == NULL) && (lpDDHELCaps == NULL) )
        {
            DPF_ERR( "Must specify at least one of driver or emulation caps" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( lpDDDriverCaps != NULL )
        {
            if( !VALID_DDCAPS_PTR( lpDDDriverCaps ) )
            {
                DPF_ERR( "Invalid driver caps pointer" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
        }
        if( lpDDHELCaps != NULL )
        {
            if( !VALID_DDCAPS_PTR( lpDDHELCaps ) )
            {
                DPF_ERR( "Invalid hel caps pointer" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * fill in caps fields
     */
    if( lpDDDriverCaps != NULL)
    {
        /*
         * We now have to assemble the final, API visible caps from multiple
         * sub-components scattered through the driver object. To make the size
         * computation simple we just build a full, API sized DDCAPS and then
         * just copy the appropritate portion of it. Cheesy in that involves an
         * extra copy of the data but very simple. This should not be performance
         * critical code to start with.
         */
        BuildDDCAPS( &ddcaps, this, FALSE );

        dwSize = lpDDDriverCaps->dwSize;
        ZeroMemory( lpDDDriverCaps, dwSize);
        memcpy( lpDDDriverCaps, &ddcaps, dwSize );
        lpDDDriverCaps->dwSize = dwSize;

        /*
         * Execute buffers are invisible to the user level API
         * so mask that caps bit off.
         */
        if (dwSize >= sizeof(DDCAPS))
        {
            /*
             * Only mask off the extended caps if they were queried for.
             */
            lpDDDriverCaps->ddsCaps.dwCaps &= ~DDSCAPS_EXECUTEBUFFER;
        }
        lpDDDriverCaps->ddsOldCaps.dwCaps &= ~DDSCAPS_EXECUTEBUFFER;

        /*
         * get amount of free video memory
         * Yes, I know I'm ignoring the return code. This is a conscious choice not to engender any
         * regression risks by changing return codes.
         */
        ZeroMemory(&ddscaps,sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_VIDEOMEMORY;
        DD_GetAvailableVidMem( lpDD, &ddscaps, &lpDDDriverCaps->dwVidMemTotal, &lpDDDriverCaps->dwVidMemFree );
    }

    /*
     * fill in hel caps
     */
    if( lpDDHELCaps != NULL )
    {
        /*
         * We now have to assemble the final, API visible caps from multiple
         * sub-components scattered through the driver object. To make the size
         * computation simple we just build a full, API sized DDCAPS and then
         * just copy the appropritate portion of it. Cheesy in that involves an
         * extra copy of the data but very simple. This should not be performance
         * critical code to start with.
         */
        BuildDDCAPS( &ddcaps, this, TRUE );

        dwSize = lpDDHELCaps->dwSize;
        ZeroMemory( lpDDHELCaps, dwSize);
        memcpy( lpDDHELCaps, &ddcaps, dwSize );
        lpDDHELCaps->dwSize = dwSize;

        /*
         * Again, execute buffers are invisible to the user level API
         * so mask that caps bit off.
         */
        if (dwSize >= sizeof(DDCAPS))
        {
            /*
             * Only mask off the extended caps if they were queried for.
             */
            lpDDHELCaps->ddsCaps.dwCaps &= ~DDSCAPS_EXECUTEBUFFER;
        }
        lpDDHELCaps->ddsOldCaps.dwCaps &= ~DDSCAPS_EXECUTEBUFFER;

        lpDDHELCaps->dwVidMemFree = 0;
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetCaps */

#undef DPF_MODNAME
#define DPF_MODNAME "WaitForVerticalBlank"

/*
 * ModeX_WaitForVerticalBlank
 */
static void ModeX_WaitForVerticalBlank( DWORD dwFlags )
{
#if defined (WIN95) || defined ( NT_FIX )
    switch( dwFlags )
    {
    case DDWAITVB_BLOCKBEGIN:
        /*
         * if blockbegin is requested we wait until the vertical retrace
         * is over, and then wait for the display period to end.
         */
        while(IN_VBLANK());
        while(IN_DISPLAY());
        break;

    case DDWAITVB_BLOCKEND:
        /*
         * if blockend is requested we wait for the vblank interval to end.
         */
        if( IN_VBLANK() )
        {
            while( IN_VBLANK() );
        }
        else
        {
            while(IN_DISPLAY());
            while(IN_VBLANK());
        }
        break;
    }
#endif
} /* ModeX_WaitForVerticalBlank */

/*
 * DD_WaitForVerticalBlank
 */
HRESULT DDAPI DD_WaitForVerticalBlank(
                LPDIRECTDRAW lpDD,
                DWORD dwFlags,
                HANDLE hEvent )
{
    LPDDRAWI_DIRECTDRAW_INT             this_int;
    LPDDRAWI_DIRECTDRAW_LCL             this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL             this;
    LPDDHAL_WAITFORVERTICALBLANK        wfvbhalfn;
    LPDDHAL_WAITFORVERTICALBLANK        wfvbfn;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_WaitForVerticalBlank");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        #ifdef WINNT
            // Update DDraw handle in driver GBL object.
            this->hDD = this_lcl->hDD;
        #endif //WINNT

        if( (dwFlags & DDWAITVB_BLOCKBEGINEVENT) || (hEvent != NULL) )
        {
            DPF_ERR( "Event's not currently supported" );
            LEAVE_DDRAW();
            return DDERR_UNSUPPORTED;
        }

        if( (dwFlags != DDWAITVB_BLOCKBEGIN) && (dwFlags != DDWAITVB_BLOCKEND) )
        {
            DPF_ERR( "Invalid dwFlags" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * ask the driver to wait for the vertical blank
     */
    if( this->dwFlags & DDRAWI_MODEX )
    {
        ModeX_WaitForVerticalBlank( dwFlags );
    }
    else
    {
        #pragma message( REMIND( "Need HEL WaitForVerticalBlank" ))
        wfvbfn = this_lcl->lpDDCB->HALDD.WaitForVerticalBlank;
        wfvbhalfn = this_lcl->lpDDCB->cbDDCallbacks.WaitForVerticalBlank;
        if( wfvbhalfn != NULL )
        {
            DDHAL_WAITFORVERTICALBLANKDATA      wfvbd;
            DWORD                               rc;

            wfvbd.WaitForVerticalBlank = wfvbhalfn;
            wfvbd.lpDD = this;
            wfvbd.dwFlags = dwFlags;
            wfvbd.hEvent = (ULONG_PTR) hEvent;
            DOHALCALL( WaitForVerticalBlank, wfvbfn, wfvbd, rc, FALSE );
            if( rc == DDHAL_DRIVER_HANDLED )
            {
                LEAVE_DDRAW();
                return wfvbd.ddRVal;
            }
        }
    }

    LEAVE_DDRAW();
    return DDERR_UNSUPPORTED;

} /* DD_WaitForVerticalBlank */

#undef DPF_MODNAME
#define DPF_MODNAME "GetMonitorFrequency"

/*
 * DD_GetMonitorFrequency
 */
HRESULT DDAPI DD_GetMonitorFrequency(
                LPDIRECTDRAW lpDD,
                LPDWORD lpdwFrequency)
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetMonitorFrequency");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        if( !VALID_DWORD_PTR( lpdwFrequency ) )
        {
            DPF_ERR( "Invalid frequency pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( this->dwMonitorFrequency == 0 )
        {
            LEAVE_DDRAW();
            return DDERR_UNSUPPORTED;
        }
        *lpdwFrequency = this->dwMonitorFrequency;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetMonitorFrequency */

DWORD gdwSetIME = 0;

/*
 * DoneExclusiveMode
 */
void DoneExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    DDHAL_SETEXCLUSIVEMODEDATA  semd;
    LPDDHAL_SETEXCLUSIVEMODE    semfn;
    LPDDHAL_SETEXCLUSIVEMODE    semhalfn;
    HRESULT                     rc;

    DPF( 4, "DoneExclusiveMode" );
    pdrv = pdrv_lcl->lpGbl;
    if( (pdrv->dwFlags & DDRAWI_FULLSCREEN) &&
        (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
        DPF( 4, "Enabling error mode, hotkeys" );
        SetErrorMode( pdrv_lcl->dwErrorMode );

        if( !( pdrv_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER ) )
        {
            BOOL        old;
            SystemParametersInfo( SPI_SCREENSAVERRUNNING, FALSE, &old, 0 );
        }

        #ifdef WINNT
            // Restore cursor shadow coming out of fullscreen
            SystemParametersInfo( SPI_SETCURSORSHADOW, 0, (LPVOID)ULongToPtr(pdrv_lcl->dwCursorShadow), 0 );
        #endif

        // Restore reactive menus coming out of fullscreen:
        SystemParametersInfo( SPI_SETHOTTRACKING, 0, (LPVOID)ULongToPtr(pdrv_lcl->dwHotTracking), 0 );
        InterlockedExchange(&gdwSetIME, pdrv_lcl->dwIMEState + 1);
    }
    pdrv->dwFlags &= ~(DDRAWI_FULLSCREEN);

    /*
     * Driver is no longer flipped to GDI surface.
     * NOTE: This does not mean its not showing the GDI surface just that
     * its no longer showing the GDI surface as a result of a FlipToGDISurface
     */
    pdrv->dwFlags &= ~(DDRAWI_FLIPPEDTOGDI);

    // restore the GDI palette
    // we let GDI do this by calling SetSystemPaletteUse() this will send
    // the right (ie what GDI thinks...) colors down to the device
    // this also flushes GDIs palette xlat cache.

#ifdef WIN95
    if( pdrv->dwModeIndex != DDUNSUPPORTEDMODE && NULL != pdrv->lpModeInfo)
#else
    if (NULL != pdrv->lpModeInfo)
#endif
    {
        if( pdrv->lpModeInfo[ pdrv->dwModeIndex ].wFlags & DDMODEINFO_PALETTIZED )
        {
            HDC         hdc;

            if( pdrv->cMonitors > 1 )
            {
                SetSystemPaletteUse( (HDC) (pdrv_lcl->hDC), SYSPAL_STATIC);
                DPF(4,"SetSystemPaletteUse STATICS ON (DoneExclusiveMode)");
            }
            else
            {
                hdc = GetDC(NULL);
                SetSystemPaletteUse(hdc, SYSPAL_STATIC);
                DPF(4,"SetSystemPaletteUse STATICS ON (DoneExclusiveMode)");
                ReleaseDC(NULL, hdc);
            }

            // if we have a primary
            if (pdrv_lcl->lpPrimary)
            {
                if (pdrv_lcl->lpPrimary->lpLcl->lpDDPalette) //if that primary has a palette
                {
                    pdrv_lcl->lpPrimary->lpLcl->lpDDPalette->lpLcl->lpGbl->dwFlags &= ~DDRAWIPAL_EXCLUSIVE;
                    DPF(5,"Setting non-exclusive for palette %08x",pdrv_lcl->lpPrimary->lpLcl->lpDDPalette->lpLcl);
                }
            }
        }

        #ifdef WINNT
            // this fixes DOS Box colors on NT.  We need to do this even in non-
            // palettized modes.
            PostMessage(HWND_BROADCAST, WM_PALETTECHANGED, (WPARAM)pdrv_lcl->hWnd, 0);
        #endif
    }

    /*
     * Restore the display mode in case it was changed while
     * in exclusive mode.
     * Only do this if we are not adhering to the v1 behaviour
     */
    if( !(pdrv_lcl->dwLocalFlags & DDRAWILCL_V1SCLBEHAVIOUR) )
    {
        RestoreDisplayMode( pdrv_lcl, TRUE );
    }

    /*
     * If the primary has a gamma ramp associated w/ it, set it now
     */
    if( ( pdrv_lcl->lpPrimary != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->lpSurfMore->lpOriginalGammaRamp != NULL ) )
    {
        RestoreGamma( pdrv_lcl->lpPrimary->lpLcl, pdrv_lcl );
    }

    /*
     * Notify the driver that we are leaving exclusive mode.
     * NOTE: This is a HAL only call - the HEL does not get to
     * see it.
     * NOTE: We don't allow the driver to fail this call. This is
     * a notification callback only.
     */
    semfn    = pdrv_lcl->lpDDCB->HALDD.SetExclusiveMode;
    semhalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.SetExclusiveMode;
    if( NULL != semhalfn )
    {
        semd.SetExclusiveMode = semhalfn;
        semd.lpDD             = pdrv;
        semd.dwEnterExcl      = FALSE;
        semd.dwReserved       = 0UL;
        DOHALCALL( SetExclusiveMode, semfn, semd, rc, FALSE );
        //
        // This assert has fired and confused many devs. Seems like the 3dfx and the pvr both
        // bounce us a failure code. It's clearly not serving its original purpose of making
        // driver devs return an ok code, so let's yank it.
        //
        //DDASSERT( ( DDHAL_DRIVER_HANDLED == rc ) && ( !FAILED( semd.ddRVal ) ) );
    }

    pdrv->lpExclusiveOwner = NULL;

    /*
     * changes to lpExclusiveOwner can only be made while the exclusive mode mutex is owned by this process
     */
    RELEASE_EXCLUSIVEMODE_MUTEX;

    ClipTheCursor(pdrv_lcl, NULL);

    // If we are going into window'ed mode and we are
    // emulated then we might need to turn on the VirtualDesktop flag.
    // We don't do this for 3Dfx, and we don't do this if the app
    // has chosen a monitor explicitly.
    if( ( pdrv->cMonitors > 1 ) &&
        (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
        pdrv->dwFlags |= DDRAWI_VIRTUALDESKTOP;

        // We need to update our device rect
        UpdateRectFromDevice( pdrv );
    }

} /* DoneExclusiveMode */

/*
 * StartExclusiveMode
 */
void StartExclusiveMode( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, DWORD dwFlags, DWORD pid )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    DDHAL_SETEXCLUSIVEMODEDATA  semd;
    LPDDHAL_SETEXCLUSIVEMODE    semfn;
    LPDDHAL_SETEXCLUSIVEMODE    semhalfn;
    DWORD                       dwWaitResult;
    HRESULT                     rc;

    DPF( 4, "StartExclusiveMode" );
    pdrv = pdrv_lcl->lpGbl;

#if _WIN32_WINNT >= 0x0501
    {
        //Turn off ghosting for any exclusive-mode app
        //(Whistler onwards only)
        typedef void (WINAPI *PFN_NOGHOST)( void );
        HINSTANCE hInst = NULL;
        hInst = LoadLibrary( "user32.dll" );
        if( hInst )
        {
            PFN_NOGHOST pfnNoGhost = NULL;
            pfnNoGhost = (PFN_NOGHOST)GetProcAddress( (HMODULE)hInst, "DisableProcessWindowsGhosting" );
            if( pfnNoGhost )
            {
                pfnNoGhost();
            }
            FreeLibrary( hInst );
        }
    }
#endif // _WIN32_WINNT >= 0x0501


    /*
     * Preceeding code should have taken this mutex already.
     */

#if defined(WINNT) && defined(DEBUG)
    dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, 0);
    DDASSERT(dwWaitResult == WAIT_OBJECT_0);
    ReleaseMutex(hExclusiveModeMutex);
#endif

    pdrv->lpExclusiveOwner = pdrv_lcl;

    if( (pdrv->dwFlags & DDRAWI_FULLSCREEN) &&
        (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
        pdrv_lcl->dwErrorMode = SetErrorMode( SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );
        {
            BOOL        old;

            /*
             * Don't send kepyboard events while the screen saver is running
             * or else USER gets confused
             */
            if( !( pdrv_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER ) )
            {
#ifdef WIN95
                // If the user has just switched to us, and then quickly
                // switched away from us, we may be in the Alt+Tab switch box.
                // If we are, then we need to get out of it or the user will
                // be forced to reboot the system. So we check to see if the
                // Alt key is down, and if so, force it up. Hacking is fun.
                if (GetAsyncKeyState(VK_MENU) & 0x80000000)
                {
                    keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);
                }
#endif
                SystemParametersInfo( SPI_SCREENSAVERRUNNING, TRUE, &old, 0 );
            }

            #ifdef WINNT
                // Save current cursor shadow setting
                SystemParametersInfo( SPI_GETCURSORSHADOW, 0, (LPVOID) &(pdrv_lcl->dwCursorShadow), 0 );
                SystemParametersInfo( SPI_SETCURSORSHADOW, 0, 0, 0 );
            #endif

            // Save current hot-tracking setting
            SystemParametersInfo( SPI_GETHOTTRACKING, 0, (LPVOID) &(pdrv_lcl->dwHotTracking), 0 );
            SystemParametersInfo( SPI_GETSHOWIMEUI, 0, (LPVOID) &(pdrv_lcl->dwIMEState), 0 );

            //And turn it off as we go into exclusive mode
            SystemParametersInfo( SPI_SETHOTTRACKING, 0, 0, 0 );
            InterlockedExchange(&gdwSetIME, FALSE + 1);
            #ifdef WIN95
                if( dwFlags & DDSCL_ALLOWREBOOT )
                {
                    /*
                     * re-enable reboot after SPI_SCREENSAVERRUNNING, it disables it
                     */
                    DD16_EnableReboot( TRUE );
                }
            #endif
        }
    }

    /*
     * invalidate all primary surfaces.  This includes the primary surface
     * for the current process if it was created before exclusive mode was
     * entered.
     *
     * we must invalidate ALL surfaces in case the app doesn't switch the
     * mode. - craige 7/9/95
     */
    InvalidateAllSurfaces( pdrv, (HANDLE) pdrv_lcl->hDDVxd, TRUE );

    /*
     * If the primary has a gamma ramp associated w/ it, set it now
     */
    if( ( pdrv_lcl->lpPrimary != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) )
    {
        SetGamma( pdrv_lcl->lpPrimary->lpLcl, pdrv_lcl );
    }

    /*
     * Notify the driver that we are entering exclusive mode.
     * NOTE: This is a HAL only call - the HEL does not get to
     * see it.
     * NOTE: We don't allow the driver to fail this call. This is
     * a notification callback only.
     */
    semfn    = pdrv_lcl->lpDDCB->HALDD.SetExclusiveMode;
    semhalfn = pdrv_lcl->lpDDCB->cbDDCallbacks.SetExclusiveMode;
    if( NULL != semhalfn )
    {
        semd.SetExclusiveMode = semhalfn;
        semd.lpDD             = pdrv;
        semd.dwEnterExcl      = TRUE;
        semd.dwReserved       = 0UL;
        DOHALCALL( SetExclusiveMode, semfn, semd, rc, FALSE );
        //
        // This assert has fired and confused many devs. Seems like the 3dfx and the pvr both
        // bounce us a failure code. It's clearly not serving its original purpose of making
        // driver devs return an ok code, so let's yank it.
        //
        //DDASSERT( ( DDHAL_DRIVER_HANDLED == rc ) && ( !FAILED( semd.ddRVal ) ) );
    }

    // If we are going into fullscreen mode
    // Then we might need to turn off the VirtualDesktop flag
    if( pdrv->cMonitors > 1 )
    {
        pdrv->dwFlags &= ~DDRAWI_VIRTUALDESKTOP;

        // We need to update our device rect
        UpdateRectFromDevice( pdrv );
    }

} /* StartExclusiveMode */

#undef DPF_MODNAME
#define DPF_MODNAME     "SetCooperativeLevel"

/*
 * DD_SetCooperativeLevel
 */
HRESULT DDAPI DD_SetCooperativeLevel(
                LPDIRECTDRAW lpDD,
                HWND hWnd,
                DWORD dwFlags )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       pid;
    HRESULT                     ddrval;
    DWORD                       style;
    HWND                        old_hwnd;
    HWND                        hTemp;
    BOOL                        excl_exists;
    BOOL                        is_excl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_SetCooperativeLevel");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( dwFlags & ~DDSCL_VALID )
        {
            DPF_ERR( "Invalid flags specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if ((dwFlags & DDSCL_FPUSETUP) && (dwFlags & DDSCL_FPUPRESERVE))
        {
            DPF_ERR( "Only one DDSCL_FPU* flag can be specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }


        /*
         * If the device isn't attached to the desktop, we don't want
         * to mess w/ it's window because we'll get it wrong.
         */
        if( !( this->dwFlags & DDRAWI_ATTACHEDTODESKTOP ) )
        {
            dwFlags |= DDSCL_NOWINDOWCHANGES;
        }

        if( !(dwFlags & (DDSCL_EXCLUSIVE|DDSCL_NORMAL) ) &&
            !(dwFlags & DDSCL_SETFOCUSWINDOW ) )
        {
            DPF_ERR( "Must specify one of EXCLUSIVE or NORMAL" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( (dwFlags & DDSCL_EXCLUSIVE) && !(dwFlags & DDSCL_FULLSCREEN) )
        {
            DPF_ERR( "Must specify fullscreen for exclusive mode" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( (dwFlags & DDSCL_ALLOWMODEX) && !(dwFlags & DDSCL_FULLSCREEN) )
        {
            DPF_ERR( "Must specify fullscreen for modex" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( (hWnd != NULL) && !IsWindow( hWnd ) )
        {
            DPF_ERR( "Hwnd passed is not a valid window" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( (dwFlags & DDSCL_DONTHOOKHWND) && (dwFlags & DDSCL_EXCLUSIVE) )
        {
            DPF_ERR( "we must hook the window in exclusive mode" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( dwFlags & DDSCL_SETFOCUSWINDOW )
        {
            if( !( dwFlags & DDSCL_CREATEDEVICEWINDOW) &&
                ( dwFlags & ~(DDSCL_SETFOCUSWINDOW | DDSCL_ALLOWMODEX
                  | DDSCL_DX8APP | DDSCL_NOWINDOWCHANGES) ) )
            {
                DPF_ERR( "Flags invalid with DDSCL_SETFOCUSWINDOW" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
            if( this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE )
            {
                DPF_ERR( "Cannot reset focus window while exclusive mode is owned" );
                LEAVE_DDRAW();
                return DDERR_HWNDALREADYSET;
            }
        }

        if( dwFlags & DDSCL_SETDEVICEWINDOW )
        {
            if( dwFlags & (DDSCL_SETFOCUSWINDOW | DDSCL_CREATEDEVICEWINDOW) )
            {
                DPF_ERR( "Flags invalid with DDSCL_SETDEVICEWINDOW" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
            if( hWnd != NULL )
            {
                if( this_lcl->hFocusWnd == 0 )
                {
                    DPF_ERR( "Focus window has not been set" );
                    LEAVE_DDRAW();
                    return DDERR_NOFOCUSWINDOW;
                }
            }
        }

        if( ( dwFlags & DDSCL_CREATEDEVICEWINDOW ) &&
            ( this_lcl->hWnd != 0 ) &&
            !( this_lcl->dwLocalFlags & DDRAWILCL_CREATEDWINDOW ) )
        {
            DPF_ERR( "HWND already set - DDSCL_CREATEDEVICEWINDOW flag not valid" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( ( dwFlags & DDSCL_CREATEDEVICEWINDOW ) &&
            !( dwFlags & DDSCL_EXCLUSIVE ) )
        {
            DPF_ERR( "DDSCL_CREATEDEVICEWINDOW only valid with DDSCL_EXCLUSIVE" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        if( ( dwFlags & DDSCL_CREATEDEVICEWINDOW ) &&
            ( this_lcl->hWnd == 0 ) )
        {
            if( !( dwFlags & DDSCL_SETFOCUSWINDOW ) )
            {
                if( hWnd != NULL )
                {
                    DPF_ERR( "hWnd specified with DDSCL_CREATEDEVICEWINDOW" );
                    LEAVE_DDRAW();
                    return DDERR_INVALIDPARAMS;
                }
                if( this_lcl->hFocusWnd == 0 )
                {
                    DPF_ERR( "Focus window has not been set" );
                    LEAVE_DDRAW();
                    return DDERR_NOFOCUSWINDOW;
                }
            }
        }

        if( ( dwFlags & DDSCL_EXCLUSIVE ) &&
            !( dwFlags & DDSCL_CREATEDEVICEWINDOW ) )
        {
            if( NULL == hWnd )
            {
                DPF_ERR( "Hwnd must be specified for exclusive mode" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
            if( (GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD) )
            {
                DPF_ERR( "Hwnd must be a top level window" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
        }

        pid = GETCURRPID();

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * In v1, we allowed an app to set the mode while in exclusive mode but
     * we didn't restore the mode if the app lost exclusive mode.  We have
     * changed this behaviour in v2 to cause the display mode to be restored
     * when exclusive mode is lost.  If the v1 SetCooperativeLevel is ever
     * called then we revert back to the v1 behaviour to avoid breaking
     * existing apps.
     */
    if( this_int->lpVtbl == &ddCallbacks )
    {
        // This is the V1 SetCooperativeLevel
        this_lcl->dwLocalFlags |= DDRAWILCL_V1SCLBEHAVIOUR;
    }

    /*
     * don't mess with dialogs, this is a hack for DDTEST and DDCAPS.
     * Don't do this if the app specified the
     * SETDEVICEWINDOW/CREATEDEVICEWINDOW flags.
     */
    if( ( NULL != hWnd ) &&
        !( dwFlags & (DDSCL_SETDEVICEWINDOW|DDSCL_CREATEDEVICEWINDOW) ) )
    {
        style = GetWindowLong(hWnd, GWL_STYLE);
        if ((style & WS_CAPTION) == WS_DLGFRAME)
        {
            DPF( 2, "setting DDSCL_NOWINDOWCHANGES for caller" );
            dwFlags |= DDSCL_NOWINDOWCHANGES;
        }
    }

    if( dwFlags & DDSCL_EXCLUSIVE )
    {
        /*
         * This is one of exactly two cases where we keep the exclusive mode mutex (the other is
         * in dddefwp, wherein we are activated by alt-tab). We have to be careful to release the
         * mutex properly in failure modes.
         */
        if( !( dwFlags & DDSCL_SETFOCUSWINDOW ) )
        {
            hTemp = (HWND) this_lcl->hFocusWnd;
        }
        else
        {
            hTemp = hWnd;
        }
        CheckExclusiveMode(this_lcl, &excl_exists, &is_excl, TRUE, hTemp, TRUE );

        if( (excl_exists) &&
            (!is_excl) )
        {
            if( ( dwFlags & DDSCL_CREATEDEVICEWINDOW ) &&
                ( this_lcl->hWnd == 0 ) &&
                ( hWnd ) )
            {
                DestroyWindow(hWnd);
            }
            LEAVE_DDRAW();
            return DDERR_EXCLUSIVEMODEALREADYSET;
        }
    }

    /*
     * If we are only setting the focus window, save it now
     */
    if( dwFlags & DDSCL_SETFOCUSWINDOW )
    {
        this_lcl->hFocusWnd = (ULONG_PTR) hWnd;
        if( ( this_lcl->hWnd != 0 ) &&
            ( this_lcl->dwLocalFlags & DDRAWILCL_CREATEDWINDOW ) &&
            IsWindow( (HWND) this_lcl->hWnd ) )
        {
            SetWindowLongPtr( (HWND) this_lcl->hWnd, 0, (LONG_PTR) hWnd );
        }
        if( !( dwFlags & DDSCL_CREATEDEVICEWINDOW ) )
        {
            if (dwFlags & DDSCL_MULTITHREADED)
                this_lcl->dwLocalFlags |= DDRAWILCL_MULTITHREADED;
            if (dwFlags & DDSCL_FPUSETUP)
                this_lcl->dwLocalFlags |= DDRAWILCL_FPUSETUP;
            if (dwFlags & DDSCL_FPUPRESERVE)
                this_lcl->dwLocalFlags |= DDRAWILCL_FPUPRESERVE;

            /*
             * It's ok to always release the mutex here, because the only way we can get here is if we just took
             * exclusive mode, i.e. we didn't already have exclusive mode before this SetCoop call was made.
             */
            if( dwFlags & DDSCL_EXCLUSIVE )
            {
                RELEASE_EXCLUSIVEMODE_MUTEX;
            }

            LEAVE_DDRAW();
            return DD_OK;
        }
    }

    /*
     * Create the window now if we need to
     */
    if( ( dwFlags & DDSCL_CREATEDEVICEWINDOW ) &&
        ( this_lcl->hWnd == 0 ) )
    {
        WNDCLASS        cls;

        if( !GetClassInfo( hModule, szDeviceWndClass, &cls ) )
        {
            cls.lpszClassName  = szDeviceWndClass;
            cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
            cls.hInstance      = hModule;
            cls.hIcon          = NULL;
            cls.hCursor        = NULL;
            cls.lpszMenuName   = NULL;
            cls.style          = CS_DBLCLKS;
            cls.lpfnWndProc    = (WNDPROC)DeviceWindowProc;
            cls.cbWndExtra     = sizeof( INT_PTR );
            cls.cbClsExtra     = 0;
            if( RegisterClass(&cls) == 0 )
            {
                DPF_ERR( "RegisterClass failed" );
                RELEASE_EXCLUSIVEMODE_MUTEX;
                LEAVE_DDRAW();
                return DDERR_GENERIC;
            }
        }

        hWnd = CreateWindow(
            szDeviceWndClass,
            szDeviceWndClass,
            WS_OVERLAPPED|WS_POPUP|WS_VISIBLE,
            this->rectDevice.left,
            this->rectDevice.top,
            this->rectDevice.right - this->rectDevice.left,
            this->rectDevice.bottom - this->rectDevice.top,
            (HWND)this_lcl->hFocusWnd, NULL,
            hModule,
            (LPVOID) (this_lcl->hFocusWnd) );
        if( hWnd == NULL )
        {
            DPF_ERR( "Unable to create the device window" );
            RELEASE_EXCLUSIVEMODE_MUTEX;
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }

    // Destroy the old window if we created it ourselves
    if( ( hWnd != (HWND) this_lcl->hWnd ) &&
        IsWindow( (HWND) this_lcl->hWnd ) &&
        ( this_lcl->dwLocalFlags & DDRAWILCL_CREATEDWINDOW ) )
    {
        DestroyWindow( (HWND) this_lcl->hWnd );
        this_lcl->hWnd = 0;
        this_lcl->dwLocalFlags &= ~DDRAWILCL_CREATEDWINDOW;
    }

    // Save the hwnd in the local object for later reference
    old_hwnd = (HWND)this_lcl->hWnd;
    if( dwFlags & (DDSCL_SETDEVICEWINDOW | DDSCL_CREATEDEVICEWINDOW) )
    {
        (HWND) this_lcl->hWnd = hWnd;
        if( dwFlags & DDSCL_CREATEDEVICEWINDOW )
        {
            this_lcl->dwLocalFlags |= DDRAWILCL_CREATEDWINDOW;
        }
    }
    else
    {
        (HWND) this_lcl->hWnd = hWnd;
        (HWND) this_lcl->hFocusWnd = hWnd;
    }

    /*
     * allow modex modes?
     */
    if( (dwFlags & DDSCL_ALLOWMODEX) &&
        !( this->dwFlags & DDRAWI_MODEXILLEGAL ) )
    {
        DPF( 2, "*********** ALLOWING MODE X AND VGA MODES" );
        this_lcl->dwLocalFlags |= DDRAWILCL_ALLOWMODEX;
    }
    else
    {
        DPF( 2, "*********** NOT!! ALLOWING MODE X AND VGA MODES" );
        this_lcl->dwLocalFlags &= ~DDRAWILCL_ALLOWMODEX;
    }

    /*
     * exclusive mode?
     */
    if( dwFlags & DDSCL_EXCLUSIVE )
    {
        if( dwFlags & DDSCL_FULLSCREEN )
        {
            this->dwFlags |= DDRAWI_FULLSCREEN;
            this_lcl->dwLocalFlags |= DDRAWILCL_ISFULLSCREEN;
        }

        // Only hook if exclusive mode requested
        if( !(dwFlags & DDSCL_DONTHOOKHWND) )
        {
            ddrval = SetAppHWnd( this_lcl, hWnd, dwFlags );

            if( ddrval != DD_OK )
            {
                DPF( 1, "Could not hook HWND!" );
                //We don't release the exclusive mode mutex here, because we are already committed to owning
                //it by the lines just above.
                LEAVE_DDRAW();
                return ddrval;
            }
            this_lcl->dwLocalFlags |= DDRAWILCL_HOOKEDHWND;
        }

        if( !is_excl )
        {
            StartExclusiveMode( this_lcl, dwFlags, pid );
            this_lcl->dwLocalFlags |= DDRAWILCL_ACTIVEYES;
            this_lcl->dwLocalFlags &=~DDRAWILCL_ACTIVENO;
            if( hWnd != NULL )
            {
                extern void InternalSetForegroundWindow(HWND hWnd);
                InternalSetForegroundWindow(hWnd);
            }
            this_lcl->dwLocalFlags |= DDRAWILCL_HASEXCLUSIVEMODE;
            ClipTheCursor(this_lcl, &(this->rectDevice));
        }
    }
    /*
     * no, must be regular
     */
    else
    {
        if( this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE )
        {
            /*
             * If we are leaving exclusive mode ensure we are
             * looking at the GDI surface.
             */
            DD_FlipToGDISurface( lpDD );

            DoneExclusiveMode( this_lcl );
            this_lcl->dwLocalFlags &= ~(DDRAWILCL_ISFULLSCREEN |
                                        DDRAWILCL_ALLOWMODEX |
                                        DDRAWILCL_HASEXCLUSIVEMODE);

            // Lost exclusive mode, need to remove window hook?
            if( this_lcl->dwLocalFlags & DDRAWILCL_HOOKEDHWND )
            {
                ddrval = SetAppHWnd( this_lcl, NULL, dwFlags );

                if( ddrval != DD_OK )
                {
                    DPF( 1, "Could not unhook HWND!" );
                    //No need to release excl mutex here, since DoneExclusiveMode does it.
                    LEAVE_DDRAW();
                    HIDESHOW_IME();     //Show/hide the IME OUTSIDE of the ddraw critsect.
                    return ddrval;
                }
                this_lcl->dwLocalFlags &= ~DDRAWILCL_HOOKEDHWND;
            }

            /*
             * make the window non-topmost
             */
            if (!(dwFlags & DDSCL_NOWINDOWCHANGES) && (IsWindow(old_hwnd)))
            {
                SetWindowPos(old_hwnd, HWND_NOTOPMOST,
                    0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
            }
        }

        // If we are going into window'ed mode and we are
        // emulated then we might need to turn on the VirtualDesktop flag.
        // We don't do this for 3Dfx, and we don't do this if the app
        // has chosen a monitor explicitly.
        if( ( this->cMonitors > 1 ) &&
            (this->dwFlags & DDRAWI_DISPLAYDRV) )
        {
            this->dwFlags |= DDRAWI_VIRTUALDESKTOP;

            // We need to update our device rect
            UpdateRectFromDevice( this );
        }
    }

    // Allow other DD objects to be created now.
    this_lcl->dwLocalFlags |= DDRAWILCL_SETCOOPCALLED;

    if (dwFlags & DDSCL_MULTITHREADED)
        this_lcl->dwLocalFlags |= DDRAWILCL_MULTITHREADED;
    if (dwFlags & DDSCL_FPUSETUP)
        this_lcl->dwLocalFlags |= DDRAWILCL_FPUSETUP;
    if (dwFlags & DDSCL_FPUPRESERVE)
        this_lcl->dwLocalFlags |= DDRAWILCL_FPUPRESERVE;
    LEAVE_DDRAW();
    HIDESHOW_IME();     //Show/hide the IME OUTSIDE of the ddraw critsect.
    return DD_OK;

} /* DD_SetCooperativeLevel */

#undef DPF_MODNAME
#define DPF_MODNAME     "DuplicateSurface"

/*
 * DD_DuplicateSurface
 *
 * Create a duplicate surface from an existing one.
 * The surface will have the same properties and point to the same
 * video memory.
 */
HRESULT DDAPI DD_DuplicateSurface(
                LPDIRECTDRAW lpDD,
                LPDIRECTDRAWSURFACE lpDDSurface,
                LPDIRECTDRAWSURFACE FAR *lplpDupDDSurface )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_LCL   orig_surf_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL   new_surf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT   orig_surf_int;
    LPDDRAWI_DDRAWSURFACE_INT   new_surf_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_DuplicateSurface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        orig_surf_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( orig_surf_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }

        orig_surf_lcl = orig_surf_int->lpLcl;
        if( SURFACE_LOST( orig_surf_lcl ) )
        {
            LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }

        if( !VALID_PTR_PTR( lplpDupDDSurface ) )
        {
            DPF_ERR( "Invalid dup surface pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        *lplpDupDDSurface = NULL;

        /*
         * make sure we can duplicate this baby
         */
        if( orig_surf_lcl->ddsCaps.dwCaps & (DDSCAPS_PRIMARYSURFACE) )
        {
            DPF_ERR( "Can't duplicate primary surface" );
            LEAVE_DDRAW();
            return DDERR_CANTDUPLICATE;
        }

        if( orig_surf_lcl->dwFlags & (DDRAWISURF_IMPLICITCREATE) )
        {
            DPF_ERR( "Can't duplicate implicitly created surfaces" );
            LEAVE_DDRAW();
            return DDERR_CANTDUPLICATE;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * go make ourselves a new interface for this surface...
     */
    new_surf_lcl = NewSurfaceLocal( orig_surf_lcl, orig_surf_int->lpVtbl );
    if( NULL == new_surf_lcl )
    {
        LEAVE_DDRAW();
        return DDERR_OUTOFMEMORY;
    }

    /*
     * NewSurfaceLocal does not initialize the lpDD_lcl field of the
     * local surface object's lpSurfMore data structure. Need to do
     * this here as it is needed by Release.
     */
    new_surf_lcl->lpSurfMore->lpDD_lcl = this_lcl;
    new_surf_lcl->lpSurfMore->lpDD_int = this_int;

    new_surf_int = NewSurfaceInterface( new_surf_lcl, orig_surf_int->lpVtbl );
    if( new_surf_int == NULL )
    {
        MemFree(new_surf_lcl);
        LEAVE_DDRAW();
        return DDERR_OUTOFMEMORY;
    }
    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE)new_surf_int );

    if( new_surf_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
    {
        new_surf_lcl->dbnOverlayNode.object = new_surf_lcl;
        new_surf_lcl->dbnOverlayNode.object_int = new_surf_int;
    }

    LEAVE_DDRAW();

    *lplpDupDDSurface = (LPDIRECTDRAWSURFACE) new_surf_int;
    return DD_OK;

} /* DD_DuplicateSurface */

#undef DPF_MODNAME
#define DPF_MODNAME     "GetGDISurface"

/*
 * DD_GetGDISurface
 *
 * Get the current surface associated with GDI
 */
HRESULT DDAPI DD_GetGDISurface(
                LPDIRECTDRAW lpDD,
                LPDIRECTDRAWSURFACE FAR *lplpGDIDDSurface )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf;
    LPDDRAWI_DDRAWSURFACE_INT   next_int;
    LPDDRAWI_DDRAWSURFACE_LCL   next_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   next;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetGDISurface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        if( !VALID_PTR_PTR( lplpGDIDDSurface ) )
        {
            DPF_ERR( "Invalid gdi surface pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        *lplpGDIDDSurface = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * go find the surface. start at the primary, look at all attached...
     */
    psurf_int = this_lcl->lpPrimary;
    if( psurf_int != NULL )
    {
        psurf_lcl = psurf_int->lpLcl;
        psurf = psurf_lcl->lpGbl;
        if( !(psurf->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) ) //psurf->fpVidMem != this->fpPrimaryOrig )
        {
            next_int = FindAttachedFlip( psurf_int );
            if( next_int != NULL && next_int != psurf_int )
            {
                next_lcl = next_int->lpLcl;
                next = next_lcl->lpGbl;
                do
                {
                    if( next->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE ) //next->fpVidMem == this->fpPrimaryOrig )
                    {
                        /*
                         * DirectDraw's COM behavior has changed with IDD4:
                         * IDD4 returns IDDSurface4 and IDD5 returns IDDSurface7.
                         * Create the new surface interface object only if we need to.
                         */
                        if ( !LOWERTHANDDRAW4(this_int) )
                        {
                            // This is IDD4 or above. Assume IDD4 initially:
                            LPVOID pddSurfCB = &ddSurface4Callbacks;

                            if (this_int->lpVtbl == &dd7Callbacks)
                            {
                                // This is IDD7, so we must return IDDSurface7.
                                pddSurfCB = &ddSurface7Callbacks;
                            }
                            if (next_int->lpVtbl != pddSurfCB)
                            {
                                // Need to make IDDSurface? level match IDD? level.
                                next_int = NewSurfaceInterface( next_lcl, pddSurfCB );
                            }
                        }

                        DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) next_int );
                        *lplpGDIDDSurface = (LPDIRECTDRAWSURFACE) next_int;
                        LEAVE_DDRAW();
                        return DD_OK;
                    }
                    next_int = FindAttachedFlip( next_int );
                } while( next_int != psurf_int );
            }
            DPF_ERR( "Not found" );
        }
        else
        {
            /*
             * DirectDraw's COM behavior has changed with IDD4:
             * IDD4 returns IDDSurface4 and IDD7 returns IDDSurface7.
             * Create the new surface interface object only if we need to.
             */
            if ( !LOWERTHANDDRAW4(this_int) )
            {
                // This is IDD4 or above. Assume IDD4 initially:
                LPVOID pddSurfCB = &ddSurface4Callbacks;

                if (this_int->lpVtbl == &dd7Callbacks)
                {
                    // This is IDD7, so we must return IDDSurface7.
                    pddSurfCB = &ddSurface7Callbacks;
                }
                if (psurf_int->lpVtbl != pddSurfCB)
                {
                    // Need to make IDDSurface? level match IDD? level.
                    psurf_int = NewSurfaceInterface( psurf_lcl, pddSurfCB );
                }
            }

            DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) psurf_int );
            *lplpGDIDDSurface = (LPDIRECTDRAWSURFACE) psurf_int;
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
    else
    {
        DPF_ERR( "No Primary Surface" );
    }
    LEAVE_DDRAW();
    return DDERR_NOTFOUND;

} /* DD_GetGDISurface */

#undef DPF_MODNAME
#define DPF_MODNAME     "FlipToGDISurface"


/*
 * FlipToGDISurface
 */
HRESULT FlipToGDISurface( LPDDRAWI_DIRECTDRAW_LCL   pdrv_lcl,
                          LPDDRAWI_DDRAWSURFACE_INT psurf_int) //, FLATPTR fpprim )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_INT   attached_int;
    DDHAL_FLIPTOGDISURFACEDATA  ftgsd;
    LPDDHAL_FLIPTOGDISURFACE    ftgsfn;
    LPDDHAL_FLIPTOGDISURFACE    ftgshalfn;
    HRESULT                     ddrval;

    pdrv = pdrv_lcl->lpGbl;

    psurf_lcl = psurf_int->lpLcl;
    if( psurf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
        return DD_OK;

    /*
     * Notify the driver that we are about to flip to GDI
     * surface.
     * NOTE: This is a HAL only call - it means nothing to the
     * HEL.
     * NOTE: If the driver handles this call then we do not
     * attempt to do the actual flip. This is to support cards
     * which do not have GDI surfaces. If the driver does not
     * handle the call we will continue on and do the flip.
     */
    ftgsfn     = pdrv_lcl->lpDDCB->HALDD.FlipToGDISurface;
    ftgshalfn  = pdrv_lcl->lpDDCB->cbDDCallbacks.FlipToGDISurface;
    if( NULL != ftgshalfn )
    {
        ftgsd.FlipToGDISurface = ftgshalfn;
        ftgsd.lpDD             = pdrv;
        ftgsd.dwToGDI          = TRUE;
        ftgsd.dwReserved       = 0UL;
        DOHALCALL( FlipToGDISurface, ftgsfn, ftgsd, ddrval, FALSE );
        if( DDHAL_DRIVER_HANDLED == ddrval )
        {
            if( !FAILED( ftgsd.ddRVal ) )
            {
                /*
                 * The driver is not showing the GDI surface as a
                 * result of a flip to GDI operation.
                 */
                pdrv->dwFlags |= DDRAWI_FLIPPEDTOGDI;
                DPF( 4, "Driver handled FlipToGDISurface" );
                return ftgsd.ddRVal;
            }
            else
            {
                DPF_ERR( "Driver failed FlipToGDISurface" );
                return ftgsd.ddRVal;
            }
        }
    }

    /*
     * We used to only call this function if the flip was actaully needed,
     * but 3DFX requested that we always call them, so now this fucntion
     * is always called.  If we make it this far, it's not a 3DFX and we don't
     * need to do anything more if the GDI surface is already visible.
     */
    if( psurf_lcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE)
    {
        return DD_OK;
    }

    /*
     * No HAL entry point. If this is not a GDI driver we will
     * fail the call with NOGDI.
     */
    if( ( NULL == ftgshalfn ) && !( pdrv->dwFlags & DDRAWI_DISPLAYDRV ) )
    {
        DPF( 0, "Not a GDI driver" );
        return DDERR_NOGDI;
    }

    /*
     * Driver did not handle FlipToGDISurface so do the default action
     * (the actual flip).
     *
     * go find our partner in the attachment list
     */
    attached_int = FindAttachedFlip( psurf_int );
    if( attached_int == NULL )
    {
        return DDERR_NOTFOUND;
    }
    while( attached_int != psurf_int )
    {
        if( attached_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) //->lpGbl->fpVidMem == fpprim )
        {
            break;
        }
        attached_int = FindAttachedFlip( attached_int );
    }

    /*
     * flip between the two buddies
     */
    ddrval = DD_Surface_Flip( (LPDIRECTDRAWSURFACE) psurf_int,
            (LPDIRECTDRAWSURFACE) attached_int, DDFLIP_WAIT );
    if( ddrval != DD_OK )
    {
        DPF_ERR( "Couldn't do the flip!" );
        DPF( 5, "Error = %08lx (%ld)", ddrval, LOWORD( ddrval ) );
    }

    /*
     * The driver is now showing the GDI surface as a result of a
     * FlipToGDISurface operation.
     */
    pdrv->dwFlags |= DDRAWI_FLIPPEDTOGDI;

    return ddrval;

} /* FlipToGDISurface */

/*
 * DD_FlipToGDISurface
 *
 * Get the current surface associated with GDI
 */
HRESULT DDAPI DD_FlipToGDISurface( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf;
    HRESULT                     ddrval;
//    FLATPTR                     fpprim;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_FlipToGDISurface");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    psurf_int = this_lcl->lpPrimary;
    if( psurf_int == NULL )
    {
        DPF(2, "No Primary Surface" );
        LEAVE_DDRAW();
        return DDERR_NOTFOUND;
    }

    psurf_lcl = psurf_int->lpLcl;
    psurf = psurf_lcl->lpGbl;
    if( !(psurf_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP) )
    {
        DPF_ERR( "Primary surface isn't flippable" );
        LEAVE_DDRAW();
        return DDERR_NOTFLIPPABLE;
    }

    /*
     * Always call FlipToGDISurface because it benefits 3DFX
     */
//    fpprim = this->fpPrimaryOrig;
    ddrval = FlipToGDISurface( this_lcl, psurf_int); //, fpprim );

    LEAVE_DDRAW();
    return ddrval;

} /* DD_FlipToGDISurface */

#undef DPF_MODNAME
#define DPF_MODNAME "GetFourCCCodes"

/*
 * DD_GetFourCCCodes
 */
HRESULT DDAPI DD_GetFourCCCodes(
                LPDIRECTDRAW lpDD,
                DWORD FAR *lpNumCodes,
                DWORD FAR *lpCodes )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    int                         numcodes;
    int                         i;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetFourCCCodes");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        if( !VALID_DWORD_PTR( lpNumCodes ) )
        {
            DPF_ERR( "Invalid number of codes pointer" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( (*lpNumCodes > 0) && (lpCodes != NULL) )
        {
            if( !VALID_DWORD_ARRAY( lpCodes, *lpNumCodes ) )
            {
                DPF_ERR( "Invalid array of codes" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }
        }
        if( lpCodes == NULL )
        {
            *lpNumCodes = this->dwNumFourCC;
        }
        else
        {
            numcodes = min( *lpNumCodes, this->dwNumFourCC );
            *lpNumCodes = numcodes;
            for( i=0;i<numcodes;i++ )
            {
                lpCodes[i] = this->lpdwFourCC[i];
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetFourCCCodes */

#undef DPF_MODNAME
#define DPF_MODNAME "Compact"

/*
 * DD_Compact
 */
HRESULT DDAPI DD_Compact( LPDIRECTDRAW lpDD )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Compact");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( this->lpExclusiveOwner != this_lcl )
        {
            LEAVE_DDRAW();
            return DDERR_NOEXCLUSIVEMODE;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    #pragma message( REMIND( "Compact not implemented in Rev 1" ) )


    LEAVE_DDRAW();
    return DD_OK;

}/* DD_Compact */

#undef DPF_MODNAME
#define DPF_MODNAME "GetAvailableVidMem"

/*
 * DD_GetAvailableVidMem
 */
HRESULT DDAPI DD_GetAvailableVidMem( LPDIRECTDRAW lpDD, LPDDSCAPS lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DDSCAPS2                    ddscaps2 = {0,0,0,0};
    HRESULT                     hr=DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetAvailableVidMem");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        /*
         * This call only considers vram so if running in emulation
         * only there really is no point.
         */
        if( this->dwFlags & DDRAWI_NOHARDWARE )
        {
            DPF_ERR( "No video memory - running emulation only" );
            LEAVE_DDRAW();
            return DDERR_NODIRECTDRAWHW;
        }

        ddscaps2.dwCaps = lpDDSCaps->dwCaps;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Invalid DDSCAPS pointer" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    hr = DD_GetAvailableVidMem4(lpDD, & ddscaps2, lpdwTotal, lpdwFree);
    LEAVE_DDRAW();

    return hr;
}

HRESULT DDAPI DD_GetAvailableVidMem4( LPDIRECTDRAW lpDD, LPDDSCAPS2 lpDDSCaps, LPDWORD lpdwTotal, LPDWORD lpdwFree )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       dwLocalFree;
    DWORD                       dwNonLocalFree;
    DWORD                       dwLocalTotal;
    DWORD                       dwNonLocalTotal;
#ifndef WINNT
    LPVIDMEM                    pvm;
    int                         i;
#endif

    LPDDHAL_GETAVAILDRIVERMEMORY gadmfn;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_GetAvailableVidMem4");

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;
        #ifdef WINNT
            // Update DDraw handle in driver GBL object.
            this->hDD = this_lcl->hDD;
        #endif //WINNT

        /*
         * This call only considers vram so if running in emulation
         * only there really is no point.
         */
        if( this->dwFlags & DDRAWI_NOHARDWARE )
        {
            DPF_ERR( "No video memory - running emulation only" );
            LEAVE_DDRAW();
            return DDERR_NODIRECTDRAWHW;
        }

        if( !VALID_DDSCAPS2_PTR( lpDDSCaps ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Check for generically bogus caps.
         */
        if( lpDDSCaps->dwCaps & ~DDSCAPS_VALID )
        {
            DPF_ERR( "Invalid surface caps specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }

        if( lpDDSCaps->dwCaps2 & ~DDSCAPS2_VALID )
        {
            DPF_ERR( "Invalid surface caps2 specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }

        if( lpDDSCaps->dwCaps3 & ~DDSCAPS3_VALID )
        {
            DPF_ERR( "Invalid surface caps3 specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }

        if( lpDDSCaps->dwCaps4 & ~DDSCAPS4_VALID )
        {
            DPF_ERR( "Invalid surface caps4 specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDCAPS;
        }

        /*
         * !!! NOTE: Consider using the capability checking code
         * of CreateSurface here to ensure no strange bit combinations
         * are passed in.
         */
        if( lpDDSCaps->dwCaps & AVAILVIDMEM_BADSCAPS )
        {
            DPF_ERR( "Invalid surface capability bits specified" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * The caller can pass NULL for lpdwTotal or lpdwFree if
         * they are not interested in that info. However, they
         * can't pass NULL for both.
         */
        if( ( lpdwTotal == NULL ) && ( lpdwFree == NULL ) )
        {
            DPF_ERR( "Can't specify NULL for both total and free memory" );
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( ( lpdwTotal != NULL ) && !VALID_DWORD_PTR( lpdwTotal ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( ( lpdwFree != NULL ) && !VALID_DWORD_PTR( lpdwFree ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    // Initialize values
    dwLocalFree  = 0UL;
    dwNonLocalFree = 0UL;
    dwLocalTotal = 0UL;
    dwNonLocalTotal = 0UL;

    if( lpdwTotal != NULL )
    {
        *lpdwTotal = 0UL;
    }
    if( lpdwFree != NULL )
    {
        *lpdwFree = 0UL;
    }

    DPF(5,"GetAvailableVidmem called for:");
    DPF_STRUCT(5,V,DDSCAPS2,lpDDSCaps);

#ifndef WINNT
    for( i=0;i<(int)this->vmiData.dwNumHeaps;i++ )
    {

        pvm = &this->vmiData.pvmList[i];

        /*
         * We use ddsCapsAlt as we wish to return the total amount
         * of memory of the given type it is possible to allocate
         * regardless of whether is is desirable to allocate that
         * type of memory from a given heap or not.
         * We need to keep a separate count of what's in nonlocal,
         * since we may need to cap that amount to respect the commit policy.
         */
        if( (lpDDSCaps->dwCaps & pvm->ddsCapsAlt.dwCaps) == 0 )
        {
            if ( pvm->dwFlags & VIDMEM_ISNONLOCAL )
            {
                DPF(5,V,"Heap number %d adds %08x (%d) free bytes of nonlocal",i,VidMemAmountFree( pvm->lpHeap ),VidMemAmountFree( pvm->lpHeap ));
                DPF(5,V,"Heap number %d adds %08x (%d) allocated bytes of nonlocal",i,VidMemAmountAllocated( pvm->lpHeap ),VidMemAmountAllocated( pvm->lpHeap ));
                dwNonLocalFree += VidMemAmountFree( pvm->lpHeap );
                dwNonLocalTotal += VidMemAmountAllocated( pvm->lpHeap );
            }
            else
            {
                DPF(5,V,"Heap number %d adds %08x free bytes of local",i,VidMemAmountFree( pvm->lpHeap ));
                DPF(5,V,"Heap number %d adds %08x (%d) allocated bytes of local",i,VidMemAmountAllocated( pvm->lpHeap ),VidMemAmountAllocated( pvm->lpHeap ));
                dwLocalFree += VidMemAmountFree( pvm->lpHeap );
                dwLocalTotal += VidMemAmountAllocated( pvm->lpHeap );
            }
        }
    }
    dwLocalTotal += dwLocalFree;
    dwNonLocalTotal += dwNonLocalFree;
#endif //not WINNT

    // Try asking the driver
    gadmfn     = this_lcl->lpDDCB->HALDDMiscellaneous.GetAvailDriverMemory;
    /*
     * Only ask the driver about nonlocal vidmem if it understands the concept.
     */
    if( (gadmfn != NULL) &&
        (((lpDDSCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM) == 0) || (this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM))
        )
    {
        DDHAL_GETAVAILDRIVERMEMORYDATA  gadmd;
        DWORD                           rc;

        DDASSERT( VALIDEX_CODE_PTR( gadmfn ) );

        gadmd.lpDD = this;
        gadmd.DDSCaps.dwCaps = lpDDSCaps->dwCaps;
        gadmd.ddsCapsEx = lpDDSCaps->ddsCapsEx;

        DOHALCALL( GetAvailDriverMemory, gadmfn, gadmd, rc, FALSE );

        if( rc == DDHAL_DRIVER_HANDLED )
        {
            if( lpDDSCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM )
            {
                DPF(5,V,"Driver adds %08x private free nonlocal bytes",gadmd.dwFree);
                DPF(5,V,"Driver adds %08x private total nonlocal bytes",gadmd.dwTotal);
                dwNonLocalFree += gadmd.dwFree;
                dwNonLocalTotal += gadmd.dwTotal;
            }
            else
            {
                DPF(5,V,"Driver adds %08x (%d) private free local bytes",gadmd.dwFree,gadmd.dwFree);
                DPF(5,V,"Driver adds %08x (%d) private total local bytes",gadmd.dwTotal,gadmd.dwTotal);
                dwLocalFree += gadmd.dwFree;
                dwLocalTotal += gadmd.dwTotal;
            }
        }
        else
        {
            DPF_ERR( "GetAvailDriverMemory failed!" );
        }
    }

    if( lpdwFree != NULL )
    {
        *lpdwFree = dwLocalFree;
        if (lpDDSCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            //report nonlocal if it was asked for
            *lpdwFree += dwNonLocalFree;
        }
        else if ( ((this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS) == 0) ||
                  ((this_lcl->lpGbl->lpD3DGlobalDriverData) &&
                   (this_lcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURENONLOCALVIDMEM ) &&
                    (lpDDSCaps->dwCaps & DDSCAPS_TEXTURE) )
                )
        {
            //If nonlocal wasn't asked for, then report it only if it's either execute model, or the app is asking
            //for textures, and the part can texture nonlocal
            *lpdwFree += dwNonLocalFree;
        }
    }

    if( lpdwTotal != NULL )
    {
        *lpdwTotal = dwLocalTotal;
        if (lpDDSCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            //report nonlocal if it was asked for
            *lpdwTotal += dwNonLocalTotal;
        }
        else if ( ((this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS) == 0) ||
                  ((this_lcl->lpGbl->lpD3DGlobalDriverData) &&
                   (this_lcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURENONLOCALVIDMEM ) &&
                    (lpDDSCaps->dwCaps & DDSCAPS_TEXTURE) )
                )
        {
            //If nonlocal wasn't asked for, then report it only if it's either execute model, or the app is asking
            //for textures, and the part can texture nonlocal
            *lpdwTotal += dwNonLocalTotal;
        }
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_GetAvailableVidMem */

#undef DPF_MODNAME
#define DPF_MODNAME "DD_Initialize"

/*
 * DD_Initialize
 *
 * Initialize a DirectDraw object that was created via the class factory
 */
HRESULT DDAPI DD_Initialize( LPDIRECTDRAW lpDD, GUID FAR * lpGUID )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    HRESULT                     hr;
    LPDIRECTDRAW                tmplpdd;
    LPVOID                      lpOldCallbacks;
    IUnknown                    *lpOldIUnknown=NULL;
    BOOL                        bDX7=FALSE;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Initialize");
    /* DPF_ENTERAPI(lpDD); */

    DPF( 5, "****** DirectDraw::Initialize( 0x%08lx ) ******", lpGUID );
    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        if( this_lcl->lpGbl != NULL )
        {
            DPF_ERR( "Already initialized." );
            LEAVE_DDRAW();
            return DDERR_ALREADYINITIALIZED;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * If the object is uninitialized put the real vtable in place.
     */
    lpOldCallbacks = NULL;
    if( this_int->lpVtbl == &ddUninitCallbacks )
    {
        lpOldCallbacks = this_int->lpVtbl;
        this_int->lpVtbl = &ddCallbacks;
    }
    else if( this_int->lpVtbl == &dd2UninitCallbacks )
    {
        lpOldCallbacks = this_int->lpVtbl;
        this_int->lpVtbl = &dd2Callbacks;
    }
    else if( this_int->lpVtbl == &dd4UninitCallbacks )
    {
        lpOldCallbacks = this_int->lpVtbl;
        this_int->lpVtbl = &dd4Callbacks;
    }
    else if( this_int->lpVtbl == &dd7UninitCallbacks )
    {
        lpOldCallbacks = this_int->lpVtbl;
        this_int->lpVtbl = &dd7Callbacks;
        bDX7=TRUE;
    }
    /*
     * Note that a call to Initialize off of the uninitnondelegatingiunknown vtbl
     * is not possible, since the Initialize method doesn't exist in that interface
     */

#ifdef POSTPONED
    /*
     * Also need to fix up the owning unknown to point to the initialized non delegating unknown
     * This is the non-aggregated case. In the aggregated case, the owning IUnknown will
     * not have our vtable, and we also don't need to mess with it.
     */
    lpOldIUnknown = this_int->lpLcl->pUnkOuter;
    if (this_int->lpLcl->pUnkOuter ==  (IUnknown*) &UninitNonDelegatingIUnknownInterface )
    {
        this_int->lpLcl->pUnkOuter =  (IUnknown*) &NonDelegatingIUnknownInterface;
    }
#endif

    hr = InternalDirectDrawCreate( (GUID *)lpGUID, &tmplpdd, this_int, bDX7 ? DDRAWILCL_DIRECTDRAW7 : 0UL, NULL );
    if( FAILED( hr ) && ( lpOldCallbacks != NULL ) )
    {
        /*
         * As initialization has failed put the vtable and the owner back the way it was
         * before.
         */
        this_int->lpVtbl = lpOldCallbacks;
#ifdef POSTPONED
        this_int->lpLcl->pUnkOuter = lpOldIUnknown;
#endif
    }

    LEAVE_DDRAW();
    return hr;

} /* DD_Initialize */


#ifdef WINNT
BOOL IsWinlogonThread (void)
 
{
    BOOL    fResult = FALSE;
    DWORD   dwLengthNeeded;
    TCHAR   szThreadDesktopName[256];
 
    if (GetUserObjectInformation(GetThreadDesktop(GetCurrentThreadId()),
                                 UOI_NAME,
                                 szThreadDesktopName, 
                                 sizeof(szThreadDesktopName), 
                                 &dwLengthNeeded))
    {
        fResult = (BOOL)(lstrcmpi(szThreadDesktopName, TEXT("winlogon")) == 0);
        if (fResult)
            DPF(0,"Is winlogon thread");
    }
    return fResult;
}
#endif

BOOL DesktopIsVisible()
{
#ifdef WINNT
    BOOL retval=FALSE;

    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        HRGN hrgn = CreateRectRgn(0, 0, 0, 0);
        if (hrgn)
        {
            if (GetRandomRgn(hdc, hrgn, SYSRGN) == 1)
            {
                RECT rect;
                retval = (BOOL) (GetRgnBox(hrgn, &rect) != NULLREGION);

                if (!retval)
                {
                    if (IsWinlogonThread())
                    {
                        //We must be on winlogon's process... so desktop IS visible...
                        retval = TRUE;
                    }
                }
            }
            DeleteObject(hrgn);
        }
        ReleaseDC(NULL, hdc);
    }
    return retval;
#else
    return TRUE;
#endif
}

HRESULT DDAPI DD_TestCooperativeLevel(LPDIRECTDRAW lpDD)
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    HRESULT                     hr;
    BOOL                        has_excl;
    BOOL                        excl_exists;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_TestCooperativeLevel");


    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        /*
         * If we're in a fullscreen DOS box, we need to let them know that
         * they don't have it and that they can't get it.
         */
        if( *(this->lpwPDeviceFlags) & BUSY )
        {
            if ( this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE )
            {
                hr = DDERR_NOEXCLUSIVEMODE;
            }
            else
            {
                hr = DDERR_EXCLUSIVEMODEALREADYSET;
            }
            LEAVE_DDRAW();
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    CheckExclusiveMode(this_lcl, &excl_exists, &has_excl, FALSE, NULL, FALSE);

    if ( this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE )
    {
        /*
         * Either the app has exclusive mode or it does not
         */
        if ( has_excl && DesktopIsVisible() )
        {
            hr = DD_OK;
        }
        else
        {
            hr = DDERR_NOEXCLUSIVEMODE;
        }
    }
    else
    {
        if ( excl_exists || !DesktopIsVisible() )
        {
            hr = DDERR_EXCLUSIVEMODEALREADYSET;
        }
        else
        {
#ifdef WIN95
            if ( this->dwModeIndex == this_lcl->dwPreferredMode )
#else
            if (EQUAL_DISPLAYMODE(this->dmiCurrent, this_lcl->dmiPreferred))
#endif
            {
                hr = DD_OK;
            }
            else
            {
                hr = DDERR_WRONGMODE;
            }
        }
    }

    LEAVE_DDRAW();
    return hr;

} /* DD_TestCooperativeLevel */


#ifdef DEBUG
    /*
     * These are the DPF structure dumpers.
     * If you want to dump a structure, add a function with the prototype
     *      void DUMP_<structure-name> (DWORD level, DWORD topic, LP<structure-name> lpStruct);
     *
     */

    /*
     * Dump a DDPIXELFORMAT
     */
    void DUMP_DDPIXELFORMAT (DWORD level, DWORD topic, LPDDPIXELFORMAT lpDDPF)
    {
        if (!lpDDPF)
        {
            DPF(level,topic,"   DDPIXELFORMAT NULL");
            return;
        }

        DPF(level,topic,"Flags:");
        if (lpDDPF->dwFlags & DDPF_ALPHAPIXELS )
            DPF(level,topic,"   DDPF_ALPHAPIXELS");
        if (lpDDPF->dwFlags & DDPF_ALPHA   )
            DPF(level,topic,"   DDPF_ALPHA ");
        if (lpDDPF->dwFlags & DDPF_FOURCC   )
            DPF(level,topic,"   DDPF_FOURCC = %08x",lpDDPF->dwFourCC);
        if (lpDDPF->dwFlags & DDPF_PALETTEINDEXED4  )
            DPF(level,topic,"   DDPF_PALETTEINDEXED4  ");
        if (lpDDPF->dwFlags & DDPF_PALETTEINDEXEDTO8)
            DPF(level,topic,"   DDPF_PALETTEINDEXEDTO8");
        if (lpDDPF->dwFlags & DDPF_PALETTEINDEXED8  )
            DPF(level,topic,"   DDPF_PALETTEINDEXED8  ");
        if (lpDDPF->dwFlags & DDPF_RGB        )
            DPF(level,topic,"   DDPF_RGB              ");
        if (lpDDPF->dwFlags & DDPF_COMPRESSED         )
            DPF(level,topic,"   DDPF_COMPRESSED       ");
        if (lpDDPF->dwFlags & DDPF_RGBTOYUV           )
            DPF(level,topic,"   DDPF_RGBTOYUV         ");
        if (lpDDPF->dwFlags & DDPF_YUV        )
            DPF(level,topic,"   DDPF_YUV              ");
        if (lpDDPF->dwFlags & DDPF_ZBUFFER            )
            DPF(level,topic,"   DDPF_ZBUFFER          ");
        if (lpDDPF->dwFlags & DDPF_PALETTEINDEXED1  )
            DPF(level,topic,"   DDPF_PALETTEINDEXED1  ");
        if (lpDDPF->dwFlags & DDPF_PALETTEINDEXED2  )
            DPF(level,topic,"   DDPF_PALETTEINDEXED2  ");
        if (lpDDPF->dwFlags & DDPF_ZPIXELS            )
            DPF(level,topic,"   DDPF_ZPIXELS          ");
        if (lpDDPF->dwFlags & DDPF_STENCILBUFFER        )
            DPF(level,topic,"   DDPF_STENCILBUFFER    ");

        DPF(level,topic,"   BitCount:%d",lpDDPF->dwRGBBitCount);
        DPF(level,topic,"   Bitmasks: R/Y/StencDepth:%08x, G/U/ZMask:%08x, B/V/StencMask:%08x, Alpha/Z:%08x",
            lpDDPF->dwRBitMask,
            lpDDPF->dwGBitMask,
            lpDDPF->dwBBitMask,
            lpDDPF->dwRGBAlphaBitMask);
    }

    /*
     * Dump a ddscaps
     */
    void DUMP_DDSCAPS (DWORD level, DWORD topic, LPDDSCAPS lpDDSC)
    {
        if (!lpDDSC)
        {
            DPF(level,topic,"   DDSCAPS NULL");
            return;
        }

        if (lpDDSC->dwCaps & DDSCAPS_ALPHA)
            DPF(level,topic,"   DDSCAPS_ALPHA");
        if (lpDDSC->dwCaps & DDSCAPS_BACKBUFFER)
            DPF(level,topic,"   DDSCAPS_BACKBUFFER");
        if (lpDDSC->dwCaps & DDSCAPS_COMPLEX)
            DPF(level,topic,"   DDSCAPS_COMPLEX");
        if (lpDDSC->dwCaps & DDSCAPS_FLIP)
            DPF(level,topic,"   DDSCAPS_FLIP");
        if (lpDDSC->dwCaps & DDSCAPS_FRONTBUFFER)
            DPF(level,topic,"   DDSCAPS_FRONTBUFFER");
        if (lpDDSC->dwCaps & DDSCAPS_OFFSCREENPLAIN)
            DPF(level,topic,"   DDSCAPS_OFFSCREENPLAIN");
        if (lpDDSC->dwCaps & DDSCAPS_OVERLAY)
            DPF(level,topic,"   DDSCAPS_OVERLAY");
        if (lpDDSC->dwCaps & DDSCAPS_PALETTE)
            DPF(level,topic,"   DDSCAPS_PALETTE");
        if (lpDDSC->dwCaps & DDSCAPS_PRIMARYSURFACE)
            DPF(level,topic,"   DDSCAPS_PRIMARYSURFACE");
        if (lpDDSC->dwCaps & DDSCAPS_PRIMARYSURFACELEFT)
            DPF(level,topic,"   DDSCAPS_PRIMARYSURFACELEFT");
        if (lpDDSC->dwCaps & DDSCAPS_SYSTEMMEMORY)
            DPF(level,topic,"   DDSCAPS_SYSTEMMEMORY");
        if (lpDDSC->dwCaps & DDSCAPS_TEXTURE)
            DPF(level,topic,"   DDSCAPS_TEXTURE");
        if (lpDDSC->dwCaps & DDSCAPS_3DDEVICE)
            DPF(level,topic,"   DDSCAPS_3DDEVICE");
        if (lpDDSC->dwCaps & DDSCAPS_VIDEOMEMORY)
            DPF(level,topic,"   DDSCAPS_VIDEOMEMORY");
        if (lpDDSC->dwCaps & DDSCAPS_VISIBLE)
            DPF(level,topic,"   DDSCAPS_VISIBLE");
        if (lpDDSC->dwCaps & DDSCAPS_WRITEONLY)
            DPF(level,topic,"   DDSCAPS_WRITEONLY");
        if (lpDDSC->dwCaps & DDSCAPS_ZBUFFER)
            DPF(level,topic,"   DDSCAPS_ZBUFFER");
        if (lpDDSC->dwCaps & DDSCAPS_OWNDC)
            DPF(level,topic,"   DDSCAPS_OWNDC");
        if (lpDDSC->dwCaps & DDSCAPS_LIVEVIDEO)
            DPF(level,topic,"   DDSCAPS_LIVEVIDEO");
        if (lpDDSC->dwCaps & DDSCAPS_HWCODEC)
            DPF(level,topic,"   DDSCAPS_HWCODEC");
        if (lpDDSC->dwCaps & DDSCAPS_MODEX)
            DPF(level,topic,"   DDSCAPS_MODEX");
        if (lpDDSC->dwCaps & DDSCAPS_MIPMAP)
            DPF(level,topic,"   DDSCAPS_MIPMAP");
#ifdef SHAREDZ
        if (lpDDSC->dwCaps & DDSCAPS_SHAREDZBUFFER)
            DPF(level,topic,"   DDSCAPS_SHAREDZBUFFER");
        if (lpDDSC->dwCaps & DDSCAPS_SHAREDBACKBUFFER)
            DPF(level,topic,"   DDSCAPS_SHAREDBACKBUFFER");
#endif
        if (lpDDSC->dwCaps & DDSCAPS_ALLOCONLOAD)
            DPF(level,topic,"   DDSCAPS_ALLOCONLOAD");
        if (lpDDSC->dwCaps & DDSCAPS_VIDEOPORT)
            DPF(level,topic,"   DDSCAPS_VIDEOPORT");
        if (lpDDSC->dwCaps & DDSCAPS_LOCALVIDMEM)
            DPF(level,topic,"   DDSCAPS_LOCALVIDMEM");
        if (lpDDSC->dwCaps & DDSCAPS_NONLOCALVIDMEM)
            DPF(level,topic,"   DDSCAPS_NONLOCALVIDMEM");
        if (lpDDSC->dwCaps & DDSCAPS_STANDARDVGAMODE)
            DPF(level,topic,"   DDSCAPS_STANDARDVGAMODE");
        if (lpDDSC->dwCaps & DDSCAPS_OPTIMIZED)
            DPF(level,topic,"   DDSCAPS_OPTIMIZED");
    }

    /*
     * Dump a DDSCAPS2
     */
    void DUMP_DDSCAPS2 (DWORD level, DWORD topic, LPDDSCAPS2 lpDDSC)
    {
        DUMP_DDSCAPS(level,topic,(LPDDSCAPS)lpDDSC);
        //no more to dump yet
    }

    /*
     * Dump a DDSURFACEDESC
     */
    void DUMP_DDSURFACEDESC (DWORD level, DWORD topic, LPDDSURFACEDESC lpDDSD)
    {
        if (!lpDDSD)
        {
            DPF(level,topic,"   DDSURFACEDESC NULL");
            return;
        }

        if (lpDDSD->dwFlags & DDSD_HEIGHT)
            DPF(level,topic,"   DDSURFACEDESC->dwHeight = %d",lpDDSD->dwHeight);
        if (lpDDSD->dwFlags & DDSD_WIDTH)
            DPF(level,topic,"   DDSURFACEDESC->dwWidth  = %d",lpDDSD->dwWidth);
        if (lpDDSD->dwFlags & DDSD_PITCH)
            DPF(level,topic,"   DDSURFACEDESC->lPitch   = %d",lpDDSD->lPitch);

        if (lpDDSD->dwFlags & DDSD_BACKBUFFERCOUNT)
            DPF(level,topic,"   DDSURFACEDESC->dwBackBufferCount  = %d",lpDDSD->dwBackBufferCount);
        if (lpDDSD->dwFlags & DDSD_ZBUFFERBITDEPTH)
            DPF(level,topic,"   DDSURFACEDESC->dwZBufferBitDepth  = %d",lpDDSD->dwZBufferBitDepth);
        if (lpDDSD->dwFlags & DDSD_MIPMAPCOUNT)
            DPF(level,topic,"   DDSURFACEDESC->dwMipMapCount      = %d",lpDDSD->dwMipMapCount);
        if (lpDDSD->dwFlags & DDSD_REFRESHRATE)
            DPF(level,topic,"   DDSURFACEDESC->dwRefreshRate      = %d",lpDDSD->dwRefreshRate);

        /*if (lpDDSD->dwFlags & DDSD_LPSURFACE)*/
            DPF(level,topic,"   DDSURFACEDESC->lpSurface = %08x",lpDDSD->lpSurface);

        if (lpDDSD->dwFlags & DDSD_PIXELFORMAT)
            DUMP_DDPIXELFORMAT(level,topic, &lpDDSD->ddpfPixelFormat);

        if (lpDDSD->dwFlags & DDSD_CAPS)
            DUMP_DDSCAPS(level,topic, &lpDDSD->ddsCaps);
    }

    /*
     * Dump a DDSURFACEDESC2
     */
    void DUMP_DDSURFACEDESC2 (DWORD level, DWORD topic, LPDDSURFACEDESC2 lpDDSD)
    {
        if (!lpDDSD)
        {
            DPF(level,topic,"   DDSURFACEDESC2 NULL");
            return;
        }

        if (lpDDSD->dwFlags & DDSD_HEIGHT)
            DPF(level,topic,"   DDSURFACEDESC2->dwHeight = %d",lpDDSD->dwHeight);
        if (lpDDSD->dwFlags & DDSD_WIDTH)
            DPF(level,topic,"   DDSURFACEDESC2->dwWidth  = %d",lpDDSD->dwWidth);
        if (lpDDSD->dwFlags & DDSD_PITCH)
            DPF(level,topic,"   DDSURFACEDESC2->lPitch   = %d",lpDDSD->lPitch);

        if (lpDDSD->dwFlags & DDSD_BACKBUFFERCOUNT)
            DPF(level,topic,"   DDSURFACEDESC2->dwBackBufferCount  = %d",lpDDSD->dwBackBufferCount);

        if (lpDDSD->dwFlags & DDSD_MIPMAPCOUNT)
            DPF(level,topic,"   DDSURFACEDESC2->dwMipMapCount      = %d",lpDDSD->dwMipMapCount);
        if (lpDDSD->dwFlags & DDSD_REFRESHRATE)
            DPF(level,topic,"   DDSURFACEDESC2->dwRefreshRate      = %d",lpDDSD->dwRefreshRate);

        /*if (lpDDSD->dwFlags & DDSD_LPSURFACE)*/
            DPF(level,topic,"   DDSURFACEDESC2->lpSurface = %08x",lpDDSD->lpSurface);

        if (lpDDSD->dwFlags & DDSD_PIXELFORMAT)
            DUMP_DDPIXELFORMAT(level,topic, &lpDDSD->ddpfPixelFormat);

        if (lpDDSD->dwFlags & DDSD_CAPS)
            DUMP_DDSCAPS2(level,topic, &lpDDSD->ddsCaps);
    }

    /*
     * Dump a DDOPTSURFACEDESC
     */
    void DUMP_DDOPTSURFACEDESC (DWORD level, DWORD topic, LPDDOPTSURFACEDESC lpDDSD)
    {
        if (!lpDDSD)
        {
            DPF(level,topic,"   DDOPTSURFACEDESC NULL");
            return;
        }

#if 0
        if (lpDDSD->dwFlags & DDOSD_GUID)
            DPF(level,topic,"   DDOPTSURFACEDESC->guid = %08x, %08x, %08x, %08x",lpDDSD->dwHeight);
#endif
        if (lpDDSD->dwFlags & DDOSD_COMPRESSION_RATIO)
            DPF(level,topic,"   DDOPTSURFACEDESC->dwCompressionRatio  = %d",lpDDSD->dwCompressionRatio);
    }
#endif //def DEBUG


/*
 * GetInternalPointer
 * This function can be called with a ULONG_PTR ordinal value, and will return
 * a ULONG_PTR value.
 */

ULONG_PTR __stdcall GetOLEThunkData(ULONG_PTR dwOrdinal)
{
    extern DWORD dwLastFrameRate;
    switch(dwOrdinal)
    {
    case 0x1:
        return dwLastFrameRate;
    case 0x2:
        return (ULONG_PTR) lpDriverObjectList;
    case 0x3:
        return (ULONG_PTR) lpAttachedProcesses;
    case 0x4:
        return 0;
    case 0x5:
        return (ULONG_PTR) CheckExclusiveMode;
    case 6:
        RELEASE_EXCLUSIVEMODE_MUTEX;
        return 0;
    }

    return 0;
}


/*
 * Check if exclusive mode is owned, and if so if it is owned by this ddraw local.
 * This routine only works if the calling thread owns the ddraw critical section (which is assumed
 * to at least own ddraw for all threads in this process.)
 *
 * We are only allowed to test for this ddraw object owning exclusive mode if this process
 * owns the exclusive mode mutex. If it does, then the ddraw csect allows us to know that
 * this thread can check the lpExclusiveOwner in the ddraw gbl thread-safely.
 *
 * The routine can optionally hold the exclusive mode mutex. This is done when the caller wishes to
 * change the state of the ddraw gbl lpExclusiveOwner.
 *
 * Note that this routine will ONLY take the mutex if it's possible that this local can own exclusive mode.
 * This means that callers only need to worry about releasing the mutex if
 */
void CheckExclusiveMode(LPDDRAWI_DIRECTDRAW_LCL this_lcl, LPBOOL pbExclusiveExists, LPBOOL pbThisLclOwnsExclusive, BOOL bKeepMutex, HWND hwnd, BOOL bCanGetIt)
{
    LPDDRAWI_DIRECTDRAW_GBL this_gbl;
    DWORD dwWaitResult;

    this_gbl = this_lcl->lpGbl;

#ifdef WINNT
    WaitForSingleObject( hCheckExclusiveModeMutex, INFINITE );

    dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, 0);

    if (dwWaitResult == WAIT_OBJECT_0)
    {
#endif
        /*
         * OK, so this process owns the exlusive mode object,
         * are we the process (really the ddraw lcl) with exclusive mode?
         */
        if (pbExclusiveExists)
            *pbExclusiveExists = (BOOL)( NULL != this_gbl->lpExclusiveOwner );
        if (pbThisLclOwnsExclusive)
            *pbThisLclOwnsExclusive = (BOOL) ( this_gbl->lpExclusiveOwner == this_lcl );

        /*
         * It is possible that another app has set exclusive mode
         * on another monitor, or that the same app is calling w/o first
         */
        if( pbExclusiveExists )
        {
            if( !( *pbExclusiveExists ) )
            {
                LPDDRAWI_DIRECTDRAW_INT pdrv_int;

                pdrv_int = lpDriverObjectList;
                while (pdrv_int != NULL )
                {
                    if( ( pdrv_int->lpLcl->lpGbl != this_gbl ) &&
                        ( pdrv_int->lpLcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE ) &&
                        ( pdrv_int->lpLcl->lpGbl->lpExclusiveOwner == pdrv_int->lpLcl ) )
                    {
                        if( bCanGetIt )
                        {
                            if( ( pdrv_int->lpLcl->hFocusWnd != PtrToUlong(hwnd) ) &&
                                ( pdrv_int->lpLcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV ) &&
                                ( this_gbl->dwFlags & DDRAWI_DISPLAYDRV ) )
                            {
                                *pbExclusiveExists = TRUE;
                                break;
                            }
                        }
                        else
                        {
                            *pbExclusiveExists = TRUE;
                            break;
                        }
                    }
                    pdrv_int = pdrv_int->lpLink;
                }
            }
        }

#ifdef WINNT
        /*
         * Undo the temporary ref we just took on the mutex to check its state, if we're not actually
         * taking ownership. We are not taking ownership if we already have ownership. This means this routine
         * doesn't allow more than one ref on the exclusive mode mutex.
         */
        if (!bKeepMutex || *pbThisLclOwnsExclusive)
        {
            ReleaseMutex( hExclusiveModeMutex );
        }
    }
    else if (dwWaitResult == WAIT_TIMEOUT)
    {
        /*
         * Some other thread owns the exclusive mode mutex. If that other thread took the mutex
         * on this_lcl as well, then the current thread owns excl. mode.
         *
         * We can still check if the exclusive owner is us, because all we're doing is checking
         * pointers that can only be set by whoever owns the mutex. The owner pointer will be 0
         * until it becomes (until the mutex is released) some pointer. Thus we will never get
         * a false positive when this thread asks if it owns excl. mode here.
         */
        if (this_gbl->lpExclusiveOwner == this_lcl)
        {
            if (pbExclusiveExists)
                *pbExclusiveExists = TRUE;
            if (pbThisLclOwnsExclusive)
                *pbThisLclOwnsExclusive = TRUE;
        }
        else
        {
            if (pbExclusiveExists)
                *pbExclusiveExists = TRUE;
            if (pbThisLclOwnsExclusive)
                *pbThisLclOwnsExclusive = FALSE;
        }
    }
    else if (dwWaitResult == WAIT_ABANDONED)
    {
        /*
         * Some other thread lost exclusive mode. We have now picked it up.
         */
        if (pbExclusiveExists)
            *pbExclusiveExists = FALSE;
        if (pbThisLclOwnsExclusive)
            *pbThisLclOwnsExclusive = FALSE;
        /*
         * Undo the temporary ref we just took on the mutex to check its state, if we're not actually
         * taking ownership.
         */
        if (!bKeepMutex)
        {
            ReleaseMutex( hExclusiveModeMutex );
        }
    }
    else
    {
        DPF(0, "Unexpected return from WaitForSingleObject.");
        DDASSERT(FALSE);
        if (pbExclusiveExists)
            *pbExclusiveExists = TRUE;
        if (pbThisLclOwnsExclusive)
            *pbThisLclOwnsExclusive = FALSE;
    }

    ReleaseMutex( hCheckExclusiveModeMutex );

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddsiunk.c ===
/*==========================================================================
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddsiunk.c
 *  Content:	DirectDraw surface IUnknown interface
 *		Implements QueryInterface, AddRef, and Release
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   12-mar-95	craige	split out of ddsurf.c; enhanced
 *   19-mar-95	craige	use HRESULTs
 *   28-mar-95	craige	use GETCURRPID
 *   01-apr-95	craige	happy fun joy updated header file
 *   07-apr-95	craige	bug 14 - check GUID ptr in QI
 *   09-apr-95	craige	release Win16Lock
 *   06-may-95	craige	use driver-level csects only
 *   12-may-95	craige	check for real guids in QI
 *   19-may-95	craige	free surface memory at the right time
 *   23-may-95	craige	no longer use MapLS_Pool
 *   24-may-95  kylej   add dirty rect when emulated overlay is released
 *   02-jun-95	craige	redraw primary whenever a process does last release
 *   12-jun-95	craige	new process list stuff
 *   16-jun-95	craige	new surface structure
 *   18-jun-95	craige	allow duplicate surfaces; creation of new interfaces
 *   20-jun-95	craige	need to check fpVidMemOrig for deciding to flip
 *   21-jun-95	craige	new streaming interface; work around compiler bug
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns; hide overlays
 *			when destroyed if they're still visible
 *   30-jun-95  kylej   don't free primary surface vidmem
 *   01-jul-95	craige	removed streaming & composition stuff
 *   02-jul-95	craige	fleshed out NewSurfaceInterface
 *   04-jul-95	craige	YEEHAW: new driver struct; SEH
 *   08-jul-95	craige	track invalid vs free
 *   19-jul-95	craige	need to allow AddRef of lost surfaces
 *   17-aug-95	craige	bug 557 - always turn off primay ptr in ddraw object
 *   05-sep-95	craige	bug 902: only remove locks if lclrefcnt hits zero
 *   10-sep-95	craige	bug 828: random vidmem heap free
 *   19-sep-95	craige	bug 1205: free first vidmem destroyed
 *   10-nov-95  colinmc support for shared, AddRef'd palettes
 *   23-nov-95  colinmc now supports aggregatable Direct3D textures and
 *                      devices
 *   09-dec-95  colinmc added execute buffer support
 *   17-dec-95  colinmc added shared back and z buffer support
 *   22-dec-95  colinmc Direct3D support no longer conditional
 *   02-jan-96	kylej	Handle new interface structs.
 *   10-jan-96  colinmc aggregated IUnknowns now maintained as a list
 *   13-jan-96  colinmc temporary hack to workround problem with Direct3D
 *                      cleanup
 *   26-jan-96  jeffno	NT kernel object cleanup, FlipToGDISurface only 1 arg
 *   29-jan-96  colinmc Aggregated IUnknowns now contained in additional
 *                      surface local data structure
 *   08-feb-96	colinmc	New D3D interface
 *   09-feb-96  colinmc Surface invalid flag moved from global to local
 *                      object
 *   13-mar-96  colinmc Added IID validation to QueryInterface
 *   16-mar-96  colinmc Fixed palette release problem (bug 13512)
 *   20-mar-96  colinmc Bug 13634: unidirectional attachments cause infinite
 *                      loop on cleanup
 *   23-mar-96  colinmc Bug 12252: Direct3D not cleaned up properly on
 *                      application termination
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   09-apr-96  colinmc Bug 16370: QueryInterface can fail with multiple
 *                      DirectDraw objects per process
 *   13-apr-96  colinmc Bug 17736: No notification to driver of flip to GDI
 *                      surface
 *   16-apr-96	kylej	Bug 18103: Apps which use overlays can fault in
 *			ProcessSurfaceCleanup
 *   29-apr-96  colinmc Bug 19954: Must query for Direct3D before textures
 *                      devices
 *   05-jul-96  colinmc Work Item: Remove requirement on taking Win16 lock
 *                      for VRAM surfaces (not primary)
 *   13-jan-97 jvanaken Basic support for IDirectDrawSurface3 interface
 *   29-jan-97  smac	Update video port struct when surface is released
 *   22-feb-97  colinmc Enabled OWNDC for explicit system memory surfaces
 *   03-mar-97  smac    Added kernel mode interface
 *   08-mar-97  colinmc Added function to allow surface pointer to be
 *                      overridden
 *   10-mar-97  smac	Fixed bug 5211 by hiding overlays in DestroySurface
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   05-nov-97 jvanaken Support for master sprite list in SetSpriteDisplayList
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif

// function in ddsprite.c to remove invalid surface from master sprite list
extern void RemoveSpriteSurface(LPDDRAWI_DIRECTDRAW_GBL, LPDDRAWI_DDRAWSURFACE_INT);

#ifdef REFTRACKING

void AddRefTrack(LPVOID * p)
{
    LPDDRAWI_DDRAWSURFACE_INT pInt = (LPDDRAWI_DDRAWSURFACE_INT) *p;
    LPDDRAWI_REFTRACKNODE pNode;

    pInt->RefTrack.pLastAddref = *(p-1);    //This pulls the return address off the stack

    //Now store this addref in the linked list of addrefs/releases
    //Step 1: Search for previously existing addref/release with this ret address
    pNode = pInt->RefTrack.pHead;
    while (pNode)
    {
        if ( pNode->pReturnAddress == *(p-1) )
        {
            break;
        }
        pNode = pNode->pNext;
    }
    if (!pNode)
    {
        pNode = (LPDDRAWI_REFTRACKNODE) MemAlloc(sizeof(DDRAWI_REFTRACKNODE));
        pNode->pReturnAddress = *(p-1);
        pNode->pNext = pInt->RefTrack.pHead;
        pInt->RefTrack.pHead = pNode;
    }

    pNode->dwAddrefCount++;
}
void ReleaseTrack(LPVOID * p)
{
    LPDDRAWI_DDRAWSURFACE_INT pInt = (LPDDRAWI_DDRAWSURFACE_INT) *p;
    LPDDRAWI_REFTRACKNODE pNode;

    pInt->RefTrack.pLastRelease = *(p-1);    //This pulls the return address off the stack
    //Now store this release in the linked list of addrefs/releases
    //Step 1: Search for previously existing addref/release with this ret address
    pNode = pInt->RefTrack.pHead;
    while (pNode)
    {
        if ( pNode->pReturnAddress == *(p-1) )
        {
            break;
        }
        pNode = pNode->pNext;
    }
    if (!pNode)
    {
        pNode = (LPDDRAWI_REFTRACKNODE) MemAlloc(sizeof(DDRAWI_REFTRACKNODE));
        pNode->pReturnAddress = *(p-1);
        pNode->pNext = pInt->RefTrack.pHead;
        pInt->RefTrack.pHead = pNode;
    }
    pNode->dwReleaseCount++;
}
void DumpRefTrack(LPVOID p)
{
    LPDDRAWI_DDRAWSURFACE_INT pInt = (LPDDRAWI_DDRAWSURFACE_INT) p;
    LPDDRAWI_REFTRACKNODE pNode;
    char msg[100];

    wsprintf(msg,"Interface %08x:\r\n  LastAddRef:%08x\r\n  Last Release:%08x\r\n",
        pInt,
        pInt->RefTrack.pLastAddref,
        pInt->RefTrack.pLastRelease);
    OutputDebugString(msg);
    pNode = pInt->RefTrack.pHead;
    while (pNode)
    {
        wsprintf(msg,"   Address %08x had %d Addrefs and %d Releases\r\n",
            pNode->pReturnAddress,
            pNode->dwAddrefCount,
            pNode->dwReleaseCount);
        OutputDebugString(msg);
        pNode = pNode->pNext;
    }
}

#endif //REFTRACKING
/*
 * FindIUnknown
 *
 * Locate an aggredate IUnknown with the given IID (or NULL if no such
 * interface exists).
 */
static IUnknown FAR *FindIUnknown(LPDDRAWI_DDRAWSURFACE_LCL pThisLCL, REFIID riid)
{
    LPIUNKNOWN_LIST lpIUnknownNode;

    lpIUnknownNode = pThisLCL->lpSurfMore->lpIUnknowns;
    while( lpIUnknownNode != NULL )
    {
	if( IsEqualIID( riid, lpIUnknownNode->lpGuid ) )
	    return lpIUnknownNode->lpIUnknown;
	lpIUnknownNode = lpIUnknownNode->lpLink;
    }

    return NULL;
}

/*
 * InsertIUnknown
 *
 * Insert a new IUnknown with its associated IID into the IUnknown list of the
 * given surface.
 */
static LPIUNKNOWN_LIST InsertIUnknown(
			    LPDDRAWI_DDRAWSURFACE_LCL pThisLCL,
			    REFIID riid,
			    IUnknown FAR *lpIUnknown)
{
    LPIUNKNOWN_LIST lpIUnknownNode;

    DPF( 4, "Adding aggregated IUnknown %x", lpIUnknown );

    lpIUnknownNode = ( LPIUNKNOWN_LIST ) MemAlloc( sizeof( IUNKNOWN_LIST ) );
    if( lpIUnknownNode == NULL )
	return NULL;
    lpIUnknownNode->lpGuid = ( GUID FAR * ) MemAlloc( sizeof( GUID ) );
    if( lpIUnknownNode->lpGuid == NULL )
    {
	MemFree( lpIUnknownNode );
	return NULL;
    }
    memcpy( lpIUnknownNode->lpGuid, riid, sizeof( GUID ) );
    lpIUnknownNode->lpLink            = pThisLCL->lpSurfMore->lpIUnknowns;
    lpIUnknownNode->lpIUnknown        = lpIUnknown;
    pThisLCL->lpSurfMore->lpIUnknowns = lpIUnknownNode;

    return lpIUnknownNode;
}

/*
 * FreeIUnknowns
 *
 * Free all the nodes in the IUnknown list of the given local
 * surface object and NULL out the object's IUnknown list. If
 * fRelease is TRUE then release will be called on the IUnknown
 * interfaces.
 */
static void FreeIUnknowns( LPDDRAWI_DDRAWSURFACE_LCL pThisLCL, BOOL fRelease )
{
    LPIUNKNOWN_LIST lpIUnknownNode;
    LPIUNKNOWN_LIST lpLink;

    lpIUnknownNode = pThisLCL->lpSurfMore->lpIUnknowns;
    while( lpIUnknownNode != NULL )
    {
	lpLink = lpIUnknownNode->lpLink;
	if( fRelease )
	{
	    DPF( 4, "Releasing aggregated IUnknown %x", lpIUnknownNode->lpIUnknown );
	    lpIUnknownNode->lpIUnknown->lpVtbl->Release( lpIUnknownNode->lpIUnknown );
	}
	MemFree( lpIUnknownNode->lpGuid );
	MemFree( lpIUnknownNode );
	lpIUnknownNode = lpLink;
    }
    pThisLCL->lpSurfMore->lpIUnknowns = NULL;
}

/*
 * NewSurfaceLocal
 *
 * Construct a new surface local object.
 */
//Note: lpVtbl doesnt, seem to be used
LPDDRAWI_DDRAWSURFACE_LCL NewSurfaceLocal( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID lpvtbl )
{
    LPDDRAWI_DDRAWSURFACE_LCL	pnew_lcl;
    DWORD			surf_size_lcl;
    DWORD			surf_size;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;

    /*
     * NOTE: This single allocation can allocate space for local surface
     * structure (DDRAWI_DDRAWSURFACE_LCL) and the additional local surface
     * structure (DDRAWI_DDRAWSURFACE_MORE). As the local object can be
     * variable sized this can get pretty complex. The layout of the
     * various objects in the allocation is as follows:
     *
     * +-----------------+---------------+
     * | SURFACE_LCL     | SURFACE_MORE  |
     * | (variable)      |               |
     * +-----------------+---------------+
     * <- surf_size_lcl ->
     * <- surf_size --------------------->
     */
    if( this_lcl->dwFlags & DDRAWISURF_HASOVERLAYDATA )
    {
	DPF( 4, "OVERLAY DATA SPACE" );
	surf_size_lcl = sizeof( DDRAWI_DDRAWSURFACE_LCL );
    }
    else
    {
	surf_size_lcl = offsetof( DDRAWI_DDRAWSURFACE_LCL, ddckCKSrcOverlay );
    }

    surf_size = surf_size_lcl + sizeof( DDRAWI_DDRAWSURFACE_MORE );

    pnew_lcl = MemAlloc( surf_size );
    if( pnew_lcl == NULL )
    {
	return NULL;
    }
    pdrv = this_lcl->lpGbl->lpDD;

    /*
     * set up local data
     */
    pnew_lcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE) (((LPSTR) pnew_lcl) + surf_size_lcl);
    pnew_lcl->lpGbl = this_lcl->lpGbl;
    pnew_lcl->lpAttachList = NULL;
    pnew_lcl->lpAttachListFrom = NULL;
    pnew_lcl->dwProcessId = GetCurrentProcessId();
    pnew_lcl->dwLocalRefCnt = 0;
    pnew_lcl->dwFlags = this_lcl->dwFlags;
    pnew_lcl->ddsCaps = this_lcl->ddsCaps;
    pnew_lcl->lpDDPalette = NULL;
    pnew_lcl->lpDDClipper = NULL;
    pnew_lcl->lpSurfMore->lpDDIClipper = NULL;
    pnew_lcl->dwBackBufferCount = 0;
    pnew_lcl->ddckCKDestBlt.dwColorSpaceLowValue = 0;
    pnew_lcl->ddckCKDestBlt.dwColorSpaceHighValue = 0;
    pnew_lcl->ddckCKSrcBlt.dwColorSpaceLowValue = 0;
    pnew_lcl->ddckCKSrcBlt.dwColorSpaceHighValue = 0;
    pnew_lcl->dwReserved1 = this_lcl->dwReserved1;

    /*
     * set up overlay specific data
     */
    if( this_lcl->dwFlags & DDRAWISURF_HASOVERLAYDATA )
    {
	pnew_lcl->ddckCKDestOverlay.dwColorSpaceLowValue = 0;
	pnew_lcl->ddckCKDestOverlay.dwColorSpaceHighValue = 0;
	pnew_lcl->ddckCKSrcOverlay.dwColorSpaceLowValue = 0;
	pnew_lcl->ddckCKSrcOverlay.dwColorSpaceHighValue = 0;
	pnew_lcl->lpSurfaceOverlaying = NULL;
	pnew_lcl->rcOverlaySrc.top = 0;
	pnew_lcl->rcOverlaySrc.left = 0;
	pnew_lcl->rcOverlaySrc.bottom = 0;
	pnew_lcl->rcOverlaySrc.right = 0;
	pnew_lcl->rcOverlayDest.top = 0;
	pnew_lcl->rcOverlayDest.left = 0;
	pnew_lcl->rcOverlayDest.bottom = 0;
	pnew_lcl->rcOverlayDest.right = 0;
	pnew_lcl->dwClrXparent = 0;
	pnew_lcl->dwAlpha = 0;

	/*
	 * if this is an overlay, link it in
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
	{
	    pnew_lcl->dbnOverlayNode.next = pdrv->dbnOverlayRoot.next;
	    pnew_lcl->dbnOverlayNode.prev = (LPVOID)(&(pdrv->dbnOverlayRoot));
	    pdrv->dbnOverlayRoot.next = (LPVOID)(&(pnew_lcl->dbnOverlayNode));
	    pnew_lcl->dbnOverlayNode.next->prev = (LPVOID)(&(pnew_lcl->dbnOverlayNode));
//	    pnew_lcl->dbnOverlayNode.object = pnew_int;
	}
    }

    /*
     * turn off flags that aren't valid
     */
    pnew_lcl->dwFlags &= ~(DDRAWISURF_ATTACHED |
			   DDRAWISURF_ATTACHED_FROM |
			   DDRAWISURF_HASCKEYDESTOVERLAY |
			   DDRAWISURF_HASCKEYDESTBLT |
			   DDRAWISURF_HASCKEYSRCOVERLAY |
			   DDRAWISURF_HASCKEYSRCBLT |
			   DDRAWISURF_SW_CKEYDESTOVERLAY |
			   DDRAWISURF_SW_CKEYDESTBLT |
			   DDRAWISURF_SW_CKEYSRCOVERLAY |
			   DDRAWISURF_SW_CKEYSRCBLT |
			   DDRAWISURF_HW_CKEYDESTOVERLAY |
			   DDRAWISURF_HW_CKEYDESTBLT |
			   DDRAWISURF_HW_CKEYSRCOVERLAY |
			   DDRAWISURF_HW_CKEYSRCBLT |
			   DDRAWISURF_FRONTBUFFER |
			   DDRAWISURF_BACKBUFFER );

    /*
     * Additional local surface data.
     */
    pnew_lcl->lpSurfMore->dwSize      = sizeof( DDRAWI_DDRAWSURFACE_MORE );
    pnew_lcl->lpSurfMore->lpIUnknowns = NULL;
    pnew_lcl->lpSurfMore->lpDD_lcl = NULL;
    pnew_lcl->lpSurfMore->dwMipMapCount = 0UL;
#ifdef WIN95
    pnew_lcl->dwModeCreatedIn = this_lcl->dwModeCreatedIn;
#else
    pnew_lcl->lpSurfMore->dmiCreated = this_lcl->lpSurfMore->dmiCreated;
#endif

    return pnew_lcl;

} /* NewSurfaceLocal */


/*
 * NewSurfaceInterface
 *
 * Construct a new surface interface and local object.
 */
LPDDRAWI_DDRAWSURFACE_INT NewSurfaceInterface( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID lpvtbl )
{
    LPDDRAWI_DDRAWSURFACE_INT   pnew_int;
    LPDDRAWI_DDRAWSURFACE_INT   curr_int;
    LPDDRAWI_DDRAWSURFACE_INT   last_int;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;

    pdrv = this_lcl->lpGbl->lpDD;

    /*
     * try recycle the surface from list of all free interfeaces
     */
    curr_int = pdrv->dsFreeList;
    last_int = NULL;
    pnew_int = NULL;
    while( curr_int )
    {
        DDASSERT(0 == curr_int->dwIntRefCnt);
        if ( curr_int->lpLcl == this_lcl && curr_int->lpVtbl == lpvtbl)
        {
            pnew_int = curr_int;
            if (last_int)
            {
                last_int->lpLink = curr_int->lpLink;
            }
            else
            {
                pdrv->dsFreeList = curr_int->lpLink;
            }
	    break;
        }
        last_int = curr_int;
        curr_int = curr_int->lpLink;
    }
    if ( NULL == pnew_int)
    {
        pnew_int = MemAlloc( sizeof( DDRAWI_DDRAWSURFACE_INT ) );
        if( NULL == pnew_int )
            return NULL;

        /*
         * set up interface data
         */
        pnew_int->lpVtbl = lpvtbl;
        pnew_int->lpLcl = this_lcl;
    }
    pnew_int->lpLink = pdrv->dsList;
    pdrv->dsList = pnew_int;
    pnew_int->dwIntRefCnt = 0;

    return pnew_int;

} /* NewSurfaceInterface */

#undef DPF_MODNAME
#define DPF_MODNAME	"QueryInterface"

/*
 * getDDSInterface
 */
LPDDRAWI_DDRAWSURFACE_INT getDDSInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv,
                                           LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
                                           LPVOID lpddcb )
{
    LPDDRAWI_DDRAWSURFACE_INT curr_int;

    for( curr_int = pdrv->dsList; curr_int != NULL; curr_int = curr_int->lpLink )
    {
        if( (curr_int->lpLcl == this_lcl) &&
            (curr_int->lpVtbl == lpddcb) )
        {
            break;
        }
    }
    if( NULL == curr_int )
    {
        // Couldn't find an existing interface, create one.
        curr_int = NewSurfaceInterface( this_lcl, lpddcb );
    }
    return curr_int;
}

/*
 * DD_Surface_QueryInterface
 */
HRESULT DDAPI DD_Surface_QueryInterface(
		LPDIRECTDRAWSURFACE lpDDSurface,
		REFIID riid,
		LPVOID FAR * ppvObj )
{
    LPDDRAWI_DIRECTDRAW_GBL		pdrv;
    LPDDRAWI_DDRAWSURFACE_INT		this_int;
    LPDDRAWI_DDRAWSURFACE_LCL		this_lcl;
    #ifdef STREAMING
	LPDDRAWI_DDRAWSURFACE_GBLSTREAMING	psurf_streaming;
    #endif
    LPDDRAWI_DDRAWSURFACE_GBL		this;
    LPDDRAWI_DIRECTDRAW_LCL		pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_INT		pdrv_int;
    D3DCreateTextProc                   lpfnD3DCreateTextProc;
    D3DCreateDeviceProc                 lpfnD3DCreateDeviceProc;
    HRESULT                             rval;
    IUnknown                            FAR* lpIUnknown;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_QueryInterface");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF_ERR( "Invalid surface interface pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
	pdrv_int = this_lcl->lpSurfMore->lpDD_int;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * asking for IDirectDrawSurfaceNew?
     * Internal only: called by D3D after creating a vertex buffer so we 
     * don't have to run the surface list only - which is pointless since we've just 
     * created the surface
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurfaceNew) )
    {
	if( this_int->lpVtbl == (LPVOID) &ddSurfaceCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) NewSurfaceInterface( this_int->lpLcl, &ddSurfaceCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IUnknown?
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawSurface) )
    {
	/*
	 * Our IUnknown interface is the same as our V1
	 * interface.  We must always return the V1 interface
	 * if IUnknown is requested.
	 */
	if( this_int->lpVtbl == &ddSurfaceCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurfaceCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawSurface2?
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurface2) )
    {
	/*
	 * if this is already an IDirectDrawSurface2 interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurface2Callbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurface2Callbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawSurface3?
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurface3) )
    {
	/*
	 * if this is already an IDirectDrawSurface3 interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurface3Callbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurface3Callbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawSurface4?
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurface4) )
    {
	/*
	 * if this is already an IDirectDrawSurface4 interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurface4Callbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurface4Callbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawSurface7?
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurface7) )
    {
	/*
	 * if this is already an IDirectDrawSurface7 interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurface7Callbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurface7Callbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawColorControl
     */
    if( IsEqualIID(riid, &IID_IDirectDrawColorControl) )
    {
	/*
	 * Color controls only work for an overlay/primary surface
	 */
    	if( this_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
    	{
    	    if( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_COLORCONTROLPRIMARY ) )
	    {
	    	LEAVE_DDRAW();
	    	return E_NOINTERFACE;
	    }
    	}
        else if( this_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
        {
    	    if( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_COLORCONTROLOVERLAY ) )
	    {
	    	LEAVE_DDRAW();
	    	return E_NOINTERFACE;
	    }
    	}
    	else
    	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}

	/*
	 * if this is already an IDirectDrawColorControl interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddColorControlCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddColorControlCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawGammaControl
     */
    if( IsEqualIID(riid, &IID_IDirectDrawGammaControl) )
    {
	/*
         * if this is already an IDirectDrawGammaControl interface, just
	 * addref and return
	 */
        if( this_int->lpVtbl == (LPVOID) &ddGammaControlCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
            *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddGammaControlCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawSurfaceKernel
     */
    if( IsEqualIID(riid, &IID_IDirectDrawSurfaceKernel) )
    {
	/*
	 * Don't create the interface if the VDD didn't load or if we
	 * don't have the DisplayDeviceHandle.
	 */
	if( !IsKernelInterfaceSupported( pdrv_lcl ) )
    	{
	    DPF( 0, "Kernel Mode interface not supported" );
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
    	}

	/*
	 * if this is already an IDirectDrawSurfaceKernel interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurfaceKernelCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurfaceKernelCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

#ifdef POSTPONED
    /*
     * asking for IPersist
     */
    if( IsEqualIID(riid, &IID_IPersist) )
    {
	/*
	 * if this is already an IID_IPersist interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurfacePersistCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurfacePersistCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IPersistStream
     */
    if( IsEqualIID(riid, &IID_IPersistStream) )
    {
	/*
	 * if this is already an IID_IPersist interface, just
	 * addref and return
	 */
	if( this_int->lpVtbl == (LPVOID) &ddSurfacePersistStreamCallbacks )
	    *ppvObj = (LPVOID) this_int;
	else
	    *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl, &ddSurfacePersistStreamCallbacks );

	if( NULL == *ppvObj )
	{
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
	else
	{
	    DD_Surface_AddRef( *ppvObj );
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    }

    /*
     * asking for IDirectDrawOptSurface
     */
    if( IsEqualIID(riid, &IID_IDirectDrawOptSurface) )
    {
        /*
         * if this is already an IID_IDirectDrawOptSurface interface, just
         * addref and return
         */
        if( this_int->lpVtbl == (LPVOID) &ddOptSurfaceCallbacks )
            *ppvObj = (LPVOID) this_int;
        else
            *ppvObj = (LPVOID) getDDSInterface( pdrv, this_int->lpLcl,
                                                &ddOptSurfaceCallbacks );
        if( NULL == *ppvObj )
        {
            LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        else
        {
            DD_Surface_AddRef( *ppvObj );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }
#endif //POSTPONED

    #ifdef STREAMING
	/*
	 * asking for IDirectDrawSurfaceStreaming?
	 */
	if( IsEqualIID(riid, &IID_IDirectDrawSurfaceStreaming) )
	{
	    /*
	     * if this is already an IDirectDrawSurfaceStreaming interface,
	     * just addref and return
	     */
	    if( this_int->lpVtbl == (LPVOID) &ddSurfaceStreamingCallbacks )
	    {
		DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) this_int );
		*ppvObj = (LPVOID) this_int;
	    }
	    /*
	     * not an IDirectDrawSurfaceStreaming interface, so we need to
	     * create one
	     */
	    else
	    {
		psurf_streaming = NewSurfaceInterface( this_lcl, &ddSurfaceStreamingCallbacks );
		if( psurf_streaming == NULL )
		{
		    LEAVE_DDRAW();
		    return DDERR_OUTOFMEMORY;
		}
		*ppvObj = (LPVOID) psurf_streaming;
	    }
	    LEAVE_DDRAW();
	    return DD_OK;
	}
    #endif

    #ifdef COMPOSITION
	/*
	 * asking for IDirectDrawSurfaceComposition?
	 */
	if( IsEqualIID(riid, &IID_IDirectDrawSurfaceComposition) )
	{
	}
    #endif

    DPF( 4, "IID not understood by Surface QueryInterface - trying Direct3D" );

    /*
     * We maintain a list of IUnknowns aggregated by each surface.
     * These IUnknowns are lazily evaluated, i.e., we only create
     * the underlying aggregated object when someone requests the
     * the IUnknown via QueryInterface.
     *
     * We could just hardcode the Direct3D interfaces, check for
     * them here and create the appropriate interface but that's
     * inflexible and we would have to track new interfaces added
     * to Direct3D (a particularly big problem as there are likely
     * to be many Direct3DDevice interfaces for different device
     * types). So instead, we probe Direct3D but trying its create
     * functions with the IID we have been passed and seeing if
     * it suceeds or not.
     */

    /*
     * Do we have an existing aggregated IUnknown for this IID?
     */
    lpIUnknown = FindIUnknown( this_lcl, riid );
    if( lpIUnknown == NULL )
    {
        if (DDRAWILCL_DIRECTDRAW7 & pdrv_lcl->dwLocalFlags)
        {
            DPF(0,"running %s, no texture interface for Query", D3DDX7_DLLNAME);
	    LEAVE_DDRAW();
            return E_NOINTERFACE;
        }
        
        if( !D3D_INITIALIZED( pdrv_lcl ) )
	{
	    /*
	     * Direct3D is not yet initialized. Before we can attempt
	     * to query for the texture or device interface we must
	     * initialize it.
	     *
	     * NOTE: Currently if initialization fails for any reason
	     * we fail the QueryInterface() with the error returned
	     * by InitD3D()  (which will be E_NOINTERFACE if Direct3D
	     * is not properly installed). If we ever end up aggregating
	     * anything else then this is going to be WRONG as we may
	     * end up failing a query for a completely unrelated
	     * interface just because Direct3D failed to initialize.
	     * Hence, we must rethink this if we end up aggregating
	     * anything else.
	     */
	    rval = InitD3D( pdrv_int );
	    if( FAILED( rval ) )
	    {
		DPF_ERR( "Could not initialize Direct3D" );
		LEAVE_DDRAW();
		return rval;
	    }
	}

	DDASSERT( D3D_INITIALIZED( pdrv_lcl ) );

	/*
	 * No matching interface yet - is it a Direct3D texture IID?
	 */
        lpfnD3DCreateTextProc = (D3DCreateTextProc) GetProcAddress( pdrv_lcl->hD3DInstance, D3DCREATETEXTURE_PROCNAME );
        if( lpfnD3DCreateTextProc != NULL )
        {
            DPF( 4, "Attempting to create Direct3D Texture interface" );
            rval = (*lpfnD3DCreateTextProc)( riid, lpDDSurface, &lpIUnknown, (LPUNKNOWN)lpDDSurface );
	    if( rval == DD_OK )
	    {
		/*
		 * Found the interface. Add it to our list.
		 */
		if( InsertIUnknown( this_lcl, riid, lpIUnknown ) == NULL )
		{
		    /*
		     * Insufficient memory. Discard the interface and fail.
		     */
		    DPF_ERR( "Insufficient memory to aggregate the Direct3D Texture interface" );
		    lpIUnknown->lpVtbl->Release( lpIUnknown );
		    LEAVE_DDRAW();
		    return DDERR_OUTOFMEMORY;
		}
	    }
            else if ( rval != E_NOINTERFACE )
            {
                /*
                 * The CreateTexture call understood the IID but failed for some
                 * other reason. Fail the QueryInterface.
                 */
                DPF_ERR( "Direct3D CreateTexture with valid IID" );
                LEAVE_DDRAW();
                return rval;
            }
        }
        else
        {
            DPF( 0, "Could not locate the Direct3D CreateTexture entry point!" );
        }
    }
    if( lpIUnknown == NULL )
    {
	/*
	 * Still no matching interface - is it a Direct3D device IID?
	 */

	/*
	 * NOTE: Don't need to verify that Direct3D is initialized. If we
	 * got to here it must have been initialized (when we tried the
	 * texture interface).
	 */
	DDASSERT( D3D_INITIALIZED( pdrv_lcl ) );

	lpfnD3DCreateDeviceProc = (D3DCreateDeviceProc) GetProcAddress( pdrv_lcl->hD3DInstance, D3DCREATEDEVICE_PROCNAME );
	if( lpfnD3DCreateDeviceProc != NULL )
	{
	    DPF( 4, "Attempting to create Direct3D Device interface" );
	    rval = (*lpfnD3DCreateDeviceProc)( riid,
					       pdrv_lcl->pD3DIUnknown,
					       lpDDSurface, &lpIUnknown,
					       (LPUNKNOWN)lpDDSurface, 1);
	    if( rval == DD_OK )
	    {
		/*
		 * Found the interface. Add it to our list.
		 */
		if( InsertIUnknown( this_lcl, riid, lpIUnknown ) == NULL )
		{
		    /*
		     * Insufficient memory. Discard the interface and fail.
		     */
		    DPF_ERR( "Insufficient memory to aggregate the Direct3D Device interface" );
		    lpIUnknown->lpVtbl->Release( lpIUnknown );
		    LEAVE_DDRAW();
		    return DDERR_OUTOFMEMORY;
		}
	    }
	    else if ( rval != E_NOINTERFACE )
	    {
		/*
		 * The CreateDevice call understood the IID but failed for some
		 * other reason. Fail the QueryInterface.
		 */
		DPF_ERR( "Direct3D CreateDevice with valid IID" );
		LEAVE_DDRAW();
		return rval;
 	    }
	}
	else
	{
	    DPF( 0, "Could not locate the Direct3D CreateDevice entry point!" );
	}
    }

    if( lpIUnknown != NULL )
    {
	/*
	 * We have found an aggregated IID - pass the QueryInterface off
	 * on to it.
	 */
        DPF( 4, "Passing query to aggregated (Direct3D) interface" );
        rval = lpIUnknown->lpVtbl->QueryInterface( lpIUnknown, riid, ppvObj );
        if( rval == DD_OK )
        {
            DPF( 4, "Aggregated (Direct3D) QueryInterface successful" );
            LEAVE_DDRAW();
            return DD_OK;
        }
    }

    DPF_ERR( "IID not understood by DirectDraw" );

    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_Surface_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME	"AddRef"

/*
 * DD_Surface_AddRef
 */
ULONG DDAPI DD_Surface_AddRef( LPDIRECTDRAWSURFACE lpDDSurface )
{
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    DWORD			rcnt;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_AddRef");

    TRY
    {
	/*
	 * validate parms
	 */
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface pointer" );
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;

   	// need to allow lost surfaces
   	#if 0
	    if( SURFACE_LOST( this_lcl ) )
	    {
		LEAVE_DDRAW();
		return 0;
	    }
	#endif

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }
    /*
     * If this surface is already being freed, immediately return to
     * prevent recursion.
     */

    if( this_lcl->dwFlags & DDRAWISURF_ISFREE )
    {
	DPF(4, "Leaving AddRef early to prevent recursion" );
	LEAVE_DDRAW();
	return 0;
    }


    /*
     * update surface reference count
     */
    this->dwRefCnt++;
    this_lcl->dwLocalRefCnt++;
    this_int->dwIntRefCnt++;
    ADDREFTRACK(lpDDSurface);
    rcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;

    DPF( 5, "DD_Surface_AddRef, Reference Count: Global = %ld Local = %ld Int = %ld",
         this->dwRefCnt, rcnt, this_int->dwIntRefCnt );

    LEAVE_DDRAW();
    return this_int->dwIntRefCnt;

} /* DD_Surface_AddRef */

/*
 * DestroySurface
 *
 * destroys a DirectDraw surface.   does not unlink or free the surface struct.
 * The driver object MUST be locked while making this call
 */
extern void ReleaseSurfaceHandle(LPDWLIST   lpSurfaceHandleList,DWORD handle);
void DestroySurface( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    LPDDRAWI_DDRAWSURFACE_GBL		this;
    DDHAL_DESTROYSURFACEDATA		dsd;
    DWORD				rc;
    BOOL				free_vmem;
    LPDDHALSURFCB_DESTROYSURFACE	dsfn;
    LPDDHALSURFCB_DESTROYSURFACE	dshalfn;
    BOOL				emulation;
    DWORD                               caps;
    LPDDRAWI_DIRECTDRAW_LCL		pdrv_lcl;

    this = this_lcl->lpGbl;
    caps = this_lcl->ddsCaps.dwCaps;
    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;


    /*
     * Wait for driver to finish with any pending DMA operations
     */
    if( this->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED )
    {
        WaitForDriverToFinishWithSurface(pdrv_lcl, this_lcl);
    }

    /*
     * Turn off video port hardware.  It should already be off if it
     * was called due by Release, but not if it was called by
     * InvalidateSurface.
     */
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT )
    {
    	LPDDRAWI_DDVIDEOPORT_LCL lpVP_lcl;
    	LPDDRAWI_DDVIDEOPORT_INT lpVP_int;

	/*
	 * search all video ports to see if any are using this surface
	 */
        lpVP_lcl = this_lcl->lpSurfMore->lpVideoPort;
	lpVP_int = pdrv_lcl->lpGbl->dvpList;
	while( lpVP_int != NULL )
	{
	    if( ( lpVP_int->lpLcl == lpVP_lcl ) &&
                !( lpVP_int->dwFlags & DDVPCREATE_NOTIFY) )
	    {
                if( lpVP_int->dwFlags & DDVPCREATE_VBIONLY )
                {
                    if( ( lpVP_lcl->lpVBISurface != NULL ) &&
                        ( lpVP_lcl->lpVBISurface->lpLcl == this_lcl ) )
                    {
                        DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT)lpVP_int );
                        if( ( lpVP_lcl->lpVBISurface != NULL ) &&
                            ( lpVP_lcl->lpVBISurface->dwIntRefCnt > 0 ) )
                        {
                            DecrementRefCounts( lpVP_lcl->lpVBISurface );
                        }
                        lpVP_lcl->lpVBISurface = NULL;
                    }
		}
                else if( lpVP_int->dwFlags & DDVPCREATE_VIDEOONLY )
                {
                    if( ( lpVP_lcl->lpSurface != NULL ) &&
                        ( lpVP_lcl->lpSurface->lpLcl == this_lcl ) )
                    {
                        DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT)lpVP_int );
                        if( ( lpVP_lcl->lpSurface != NULL ) &&
                            ( lpVP_lcl->lpSurface->dwIntRefCnt > 0 ) )
                        {
                            DecrementRefCounts( lpVP_lcl->lpSurface );
                        }
                        lpVP_lcl->lpSurface = NULL;
                    }
		}
                else if( ( lpVP_lcl->lpSurface != NULL ) &&
                    ( lpVP_lcl->lpSurface->lpLcl == this_lcl ) )
		{
		    DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT)lpVP_int );
		    if( ( lpVP_lcl->lpSurface != NULL ) &&
		        ( lpVP_lcl->lpSurface->dwIntRefCnt > 0 ) )
		    {
			DecrementRefCounts( lpVP_lcl->lpSurface );
		    }
		    lpVP_lcl->lpSurface = NULL;
		    if( ( lpVP_lcl->lpVBISurface != NULL ) &&
		        ( lpVP_lcl->lpVBISurface->dwIntRefCnt > 0 ) )
		    {
			DecrementRefCounts( lpVP_lcl->lpVBISurface );
		    }
		    lpVP_lcl->lpVBISurface = NULL;
		}
	    }
	    lpVP_int = lpVP_int->lpLink;
	}
    }

    /*
     * Release the kernel handle if one has been allocated
     */
    InternalReleaseKernelSurfaceHandle( this_lcl, TRUE );

    /*
     * Restore the color controls if they were changed.
     */
    ReleaseColorControl( this_lcl );
    RestoreGamma( this_lcl, pdrv_lcl );

    /*
     * Turn off the overlay.  If this function was called by Release,
     * the ovelray should already be off by now; however, it will not
     * if called because the surface was lost.
     */
    if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
	(this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE) &&
	(this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) )
    {
	LPDDHALSURFCB_UPDATEOVERLAY	uohalfn;
	LPDDHALSURFCB_UPDATEOVERLAY	uofn;
	DWORD			rc;
	DDHAL_UPDATEOVERLAYDATA	uod;

	uofn = pdrv_lcl->lpDDCB->HALDDSurface.UpdateOverlay;
	uohalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.UpdateOverlay;
	DDASSERT( uohalfn != NULL );
	DPF( 2, "Turning off hardware overlay" );
	uod.UpdateOverlay = uohalfn;
	uod.lpDD = this_lcl->lpSurfMore->lpDD_lcl->lpGbl;
	uod.lpDDSrcSurface = this_lcl;
	uod.lpDDDestSurface = this_lcl->lpSurfaceOverlaying->lpLcl;
	uod.dwFlags = DDOVER_HIDE;
	DOHALCALL( UpdateOverlay, uofn, uod, rc, FALSE );
	DDASSERT( ( rc == DDHAL_DRIVER_HANDLED ) && 
            (( uod.ddRVal == DD_OK ) || ( uod.ddRVal == DDERR_SURFACELOST )) );
	this_lcl->ddsCaps.dwCaps &= ~DDSCAPS_VISIBLE;
    }

    /*
     * see if we need to free video memory
     *
     * We don't if its already free, if it was allocated by the client (and
     * the client didn't specifically make DDraw responsible for freeing it),
     * or if it is the video memory GDI surface.
     */
#if 0 // DDRAWISURFGBL_DDFREESCLIENTMEM is gone
    if((this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE) ||
       (this->dwGlobalFlags & DDRAWISURFGBL_ISCLIENTMEM	&&
       !(this->dwGlobalFlags & DDRAWISURFGBL_DDFREESCLIENTMEM)) ||
       ((this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) &&         //((this->fpVidMem == this->lpDD->fpPrimaryOrig) &&
	(this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) ) )
#else
#ifdef WINNT
    // On Win2K we don't see any reason why the video memory primary
    // should not be freed. Actually, we don't see any reason on Win9x
    // as well, but we are not going to touch Win9x given that this is
    // March 2001.
    if((this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE))
#else
    if((this->dwGlobalFlags & DDRAWISURFGBL_MEMFREE) ||
       ((this->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) &&         //((this->fpVidMem == this->lpDD->fpPrimaryOrig) &&
	(this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) ) )
#endif // WINNT
#endif // 0
    {
	free_vmem = FALSE;
    }
    else
    {
	free_vmem = TRUE;
    }

    if( free_vmem )
    {
	/*
	 * ask the driver to free its video memory...
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
	{
            if( caps & DDSCAPS_EXECUTEBUFFER )
	        dsfn = pdrv_lcl->lpDDCB->HELDDExeBuf.DestroyExecuteBuffer;
            else
	        dsfn = pdrv_lcl->lpDDCB->HELDDSurface.DestroySurface;
	    dshalfn = dsfn;
	    emulation = TRUE;
	}
	else
	{
            if( caps & DDSCAPS_EXECUTEBUFFER )
            {
	        dsfn = pdrv_lcl->lpDDCB->HALDDExeBuf.DestroyExecuteBuffer;
	        dshalfn = pdrv_lcl->lpDDCB->cbDDExeBufCallbacks.DestroyExecuteBuffer;
            }
            else
            {
	        dsfn = pdrv_lcl->lpDDCB->HALDDSurface.DestroySurface;
	        dshalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.DestroySurface;
            }
	    emulation = FALSE;
	}
	rc = DDHAL_DRIVER_NOTHANDLED;
	if( dshalfn != NULL )
	{
            DWORD save;
	    dsd.DestroySurface = dshalfn;
	    dsd.lpDD = this->lpDD;
	    dsd.lpDDSurface = this_lcl;

            if(this_lcl->dwFlags & DDRAWISURF_DRIVERMANAGED)
            {
                save = this_lcl->dwFlags & DDRAWISURF_INVALID;
                this_lcl->dwFlags &= ~DDRAWISURF_INVALID;
            }

	    /*
	     * NOTE: THE DRIVER _CANNOT_ FAIL THIS CALL. ddrval is ignored.
	     */
            if( caps & DDSCAPS_EXECUTEBUFFER )
            {
	        DOHALCALL( DestroyExecuteBuffer, dsfn, dsd, rc, emulation );
            }
            else
            {
	        DOHALCALL( DestroySurface, dsfn, dsd, rc, emulation );
            }

            if(this_lcl->dwFlags & DDRAWISURF_DRIVERMANAGED)
            {
                this_lcl->dwFlags |= save;
            }
	}

	/*
	 * free the video memory ourselves
	 */
	if( rc == DDHAL_DRIVER_NOTHANDLED )
	{
	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
	    {
#ifndef WINNT
		if( this->lpVidMemHeap != NULL )
		{
		    VidMemFree( this->lpVidMemHeap, this->fpVidMem );
		}
#endif
	    }
	}
	this->lpVidMemHeap = NULL;
	this->fpVidMem = 0;
	this->dwGlobalFlags |= DDRAWISURFGBL_MEMFREE;
    }

} /* DestroySurface */

#undef DPF_MODNAME
#define DPF_MODNAME	"LooseManagedSurface"

/*
 * LooseManagedSurface
 *
 */
void LooseManagedSurface( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    LPDDRAWI_DDRAWSURFACE_GBL		this;
    DDHAL_DESTROYSURFACEDATA		dsd;
    DWORD				rc;
    LPDDHALSURFCB_DESTROYSURFACE	dsfn;
    LPDDHALSURFCB_DESTROYSURFACE	dshalfn;
    BOOL				emulation;
    LPDDRAWI_DIRECTDRAW_LCL		pdrv_lcl;
    DWORD                               save;

    this = this_lcl->lpGbl;
    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;

    dsfn = pdrv_lcl->lpDDCB->HALDDSurface.DestroySurface;
    dshalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.DestroySurface;
    emulation = FALSE;
    rc = DDHAL_DRIVER_NOTHANDLED;

    dsd.DestroySurface = dshalfn;
    dsd.lpDD = this->lpDD;
    dsd.lpDDSurface = this_lcl;

    save = this_lcl->dwFlags & DDRAWISURF_INVALID;
    this_lcl->dwFlags |= DDRAWISURF_INVALID;

    /*
     * NOTE: THE DRIVER _CANNOT_ FAIL THIS CALL. ddrval is ignored.
     */
    DOHALCALL( DestroySurface, dsfn, dsd, rc, emulation );

    this_lcl->dwFlags &= ~DDRAWISURF_INVALID;
    this_lcl->dwFlags |= save;
    
} /* LooseManagedSurface */

#undef DPF_MODNAME
#define DPF_MODNAME	"Release"


/*
 * NOTE: These two functions are hacks to get around a compiler bug
 * that caused an infinite loop.
 */
LPVOID GetAttachList( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    return this_lcl->lpAttachList;

}
LPVOID GetAttachListFrom( LPDDRAWI_DDRAWSURFACE_LCL this_lcl )
{
    return this_lcl->lpAttachListFrom;
}

/*
 * findOtherInterface
 *
 * Finds another interface to the lcl surface object different than this_int.
 * Returns NULL if no other interface is found.
 *
 */
LPDDRAWI_DDRAWSURFACE_INT findOtherInterface(LPDDRAWI_DDRAWSURFACE_INT this_int,
					     LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
					     LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    LPDDRAWI_DDRAWSURFACE_INT psurf = pdrv->dsList;

    while(psurf != NULL)
    {
	if( (psurf != this_int) && (psurf->lpLcl == this_lcl) )
	{
	    return psurf;
	}

	psurf = psurf->lpLink;
    }

    return NULL;
}

/*
 * InternalSurfaceRelease
 *
 * Done with a surface.	  if no one else is using it, then we can free it.
 * Also called by ProcessSurfaceCleanup, EnumSurfaces and DD_Release.
 *
 * Assumes the lock is taken on the driver.
 */
DWORD InternalSurfaceRelease( LPDDRAWI_DDRAWSURFACE_INT this_int, BOOL bLightweight, BOOL bDX8 )
{
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	this;
    LPATTACHLIST		pattachlist;
    DWORD			intrefcnt;
    DWORD			lclrefcnt;
    DWORD			gblrefcnt;
    DWORD			pid;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL 	pdrv;
    BOOL			root_object_deleted;
    BOOL			do_free;
    DWORD                       caps;
    IUnknown *                  pOwner = NULL;
    LPDDRAWI_DDRAWSURFACE_INT	curr_int;
    LPDDRAWI_DDRAWSURFACE_INT	last_int;
    BOOL                        bPrimaryChain = FALSE;

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;

    if (this_lcl->dwFlags & DDRAWISURF_PARTOFPRIMARYCHAIN)
    {
        bPrimaryChain = TRUE;
    }

    /*
     * check owner of surface
     */
    pid = GETCURRPID();
    /*
     * don't allow someone to free an implicitly created surface
     */
    if( (this->dwRefCnt == 1) && (this_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE) )
    {
	DPF_ERR( "Cannot free an implicitly created surface" );
	return 0;
    }

    /*
     * remove locks taken on this surface by the current process
     */

    pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    pdrv = pdrv_lcl->lpGbl;
    if( (this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT) == 1 )
    {
	RemoveProcessLocks( pdrv_lcl, this_lcl, pid );
    }

    /*
     * decrement the reference count.  if it hits zero, free the surface
     */
    this->dwRefCnt--;
    gblrefcnt = this->dwRefCnt;
    this_lcl->dwLocalRefCnt--;
    lclrefcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;
    this_int->dwIntRefCnt--;
    intrefcnt = this_int->dwIntRefCnt;

    DPF( 5, "DD_Surface_Release, Reference Count: Global = %ld Local = %ld Int = %ld",
         gblrefcnt, lclrefcnt, intrefcnt );

#ifdef POSTPONED2
    /*
     * If the reference count on the interface object has now gone to
     * zero and that object is referenced in the master sprite list,
     * remove the reference to that object from the master sprite list.
     */
    if (intrefcnt == 0 && this_lcl->dwFlags & DDRAWISURF_INMASTERSPRITELIST)
    {
	RemoveSpriteSurface(pdrv, this_int);
    }
#endif //POSTPONED2

    /*
     * local object at zero?
     */
    root_object_deleted = FALSE;
    if ( 0 == lclrefcnt )
    {
	LPDDRAWI_DDRAWSURFACE_INT	curr_int;
	LPDDRAWI_DDRAWSURFACE_LCL	curr_lcl;
	LPDDRAWI_DDRAWSURFACE_GBL	curr;
	DWORD				refcnt;

        // Do not call FlushD3DStates on DDHelp thread; if the app has died, then
        // D3DIM will be gone.

        if (dwHelperPid != GetCurrentProcessId())
        {
            FlushD3DStates(this_lcl);

            /* If there exists a D3D texture object, then we need to kill it */
            if(this_lcl->lpSurfMore->lpTex)
            {
                DDASSERT(pdrv_lcl->pD3DDestroyTexture);
                pdrv_lcl->pD3DDestroyTexture(this_lcl->lpSurfMore->lpTex);
            }
        }

	/*
	 * see if we are deleting the root object
	 */
	if( this_lcl->dwLocalRefCnt & OBJECT_ISROOT )
	{
	    root_object_deleted = TRUE;
	}


	/*
	 * reset if primary surface is the one being released
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
	{

	    /*
	     * restore GDI stuff if this is the GDI driver
	     */
	    if( pdrv->dwFlags & DDRAWI_DISPLAYDRV )
	    {
		if( !SURFACE_LOST( this_lcl ) )
		{
		    DPF( 2, "Resetting primary surface");

		    /*
		     * flip to the original primary surface if not emulated
		     */
                    if( !(this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
		    {
			FlipToGDISurface( pdrv_lcl, this_int ); //, pdrv->fpPrimaryOrig );
		    }
		}

		/*
		 * Cause the GDI surface to be redrawn if the mode was ever changed.
		 */
                if (pdrv_lcl->dwLocalFlags & DDRAWILCL_MODEHASBEENCHANGED)
         		RedrawWindow( NULL, NULL, NULL, RDW_INVALIDATE | RDW_ERASE |
				 RDW_ALLCHILDREN );
	    }
	}

       	/*
	 * hide a hardware overlay...
	 */
	if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
	    (this_lcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE) &&
	    (this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) )
	{
	    LPDDHALSURFCB_UPDATEOVERLAY	uohalfn;
	    LPDDHALSURFCB_UPDATEOVERLAY	uofn;
	    DWORD			rc;
	    DDHAL_UPDATEOVERLAYDATA	uod;

	    uofn = pdrv_lcl->lpDDCB->HALDDSurface.UpdateOverlay;
	    uohalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.UpdateOverlay;
	    if( (uohalfn != NULL) && (NULL != this_lcl->lpSurfaceOverlaying) )
	    {
		DPF( 2, "Turning off hardware overlay" );
		uod.UpdateOverlay = uohalfn;
		uod.lpDD = pdrv;
		uod.lpDDSrcSurface = this_lcl;
		uod.lpDDDestSurface = this_lcl->lpSurfaceOverlaying->lpLcl;
		uod.dwFlags = DDOVER_HIDE;
		DOHALCALL( UpdateOverlay, uofn, uod, rc, FALSE );
	        this_lcl->ddsCaps.dwCaps &= ~DDSCAPS_VISIBLE;
	    }
	}

	/*
	 * if an overlay, remove surface from the overlay Z order list
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
	{
	    // Remove surface from doubly linked list
	    this_lcl->dbnOverlayNode.prev->next = this_lcl->dbnOverlayNode.next;
	    this_lcl->dbnOverlayNode.next->prev = this_lcl->dbnOverlayNode.prev;

            // If this surface is overlaying an emulated surface, we must notify
            // the HEL that it needs to eventually update the part of the surface
            // touched by this overlay.
            if( this_lcl->lpSurfaceOverlaying != NULL )
            {
		LPDIRECTDRAWSURFACE lpTempSurface;
        	// We have a pointer to the surface being overlayed, check to
        	// see if it is being emulated.
        	if( this_lcl->lpSurfaceOverlaying->lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY )
        	{
        	    // Mark the destination region of this overlay as dirty.
        	    DD_Surface_AddOverlayDirtyRect(
        		(LPDIRECTDRAWSURFACE)(this_lcl->lpSurfaceOverlaying),
			&(this_lcl->rcOverlayDest) );
        	}
                lpTempSurface = (LPDIRECTDRAWSURFACE)(this_lcl->lpSurfaceOverlaying);
		this_lcl->lpSurfaceOverlaying = NULL;
		DD_Surface_Release( lpTempSurface );
            }
	}

	if( (this_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
	    ( this_lcl->lpSurfMore->lpddOverlayFX != NULL ) )
	{
	    MemFree( this_lcl->lpSurfMore->lpddOverlayFX );
	    this_lcl->lpSurfMore->lpddOverlayFX = NULL;
	}

	/*
	 * turn off video port hardware...
	 */
	if( this_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT )
	{
    	    LPDDRAWI_DDVIDEOPORT_INT lpVideoPort;
    	    LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort_lcl;

	    /*
	     * search all video ports to see if any are using this surface
	     */
	    lpVideoPort = pdrv->dvpList;
	    while( ( NULL != lpVideoPort ) &&
	           !( lpVideoPort->dwFlags & DDVPCREATE_NOTIFY ) )
	    {
		lpVideoPort_lcl = lpVideoPort->lpLcl;
		if( lpVideoPort_lcl->lpSurface == this_int )
		{
		    DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT)lpVideoPort );
		    lpVideoPort_lcl->lpSurface = NULL;
		}
		if( lpVideoPort_lcl->lpVBISurface == this_int )
		{
		    DD_VP_StopVideo( (LPDIRECTDRAWVIDEOPORT)lpVideoPort );
		    lpVideoPort_lcl->lpVBISurface = NULL;
		}
		lpVideoPort = lpVideoPort->lpLink;
	    }
	}

        /*
         * If is has a gamma ramp, release it now
         */
        ReleaseGammaControl( this_lcl );

    /*
     * Free the nodes in the IUnknown list and release all the interfaces.
     */
	FreeIUnknowns( this_lcl, TRUE );
	/*
	 * release all implicitly created attached surfaces
	 */
	pattachlist = GetAttachList( this_lcl );
	this_lcl->dwFlags |= DDRAWISURF_ISFREE;
	while( pattachlist != NULL )
	{
	    BOOL    was_implicit;
	    /*
	     * break all attachments
	     */
	    curr_int = pattachlist->lpIAttached;
	    if( pattachlist->dwFlags & DDAL_IMPLICIT )
		was_implicit = TRUE;
	    else
		was_implicit = FALSE;

	    DPF(5, "Deleting attachment from %08lx to %08lx (implicit = %d)",
		curr_int, this_int, was_implicit);
       	    DeleteOneAttachment( this_int, curr_int, TRUE, DOA_DELETEIMPLICIT );
	    // If the attachment was not implicit then curr_int may possibly have
	    // been destroyed as a result of DeleteOneAttachment.
	    if( was_implicit )
	    {
		curr_lcl = curr_int->lpLcl;
		curr = curr_lcl->lpGbl;

		/*
		 * release an implicitly created surface
		 */
		if( !(curr_lcl->dwFlags & DDRAWISURF_ISFREE) )
		{
		    if( curr_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE )
		    {
			refcnt = curr_int->dwIntRefCnt;
			curr_lcl->dwFlags &= ~DDRAWISURF_IMPLICITCREATE;
			while( refcnt > 0 )
			{
			    InternalSurfaceRelease( curr_int, bLightweight, bDX8 );
			    refcnt--;
			}
		    }
		}
	    }
	    /*
	     * start again at the beginning of the list because
	     * DeleteOneAttachment may have modified the attachment list.
	     * HACKHACK:  this fn call is needed to get around a compiler bug
	     */
	    pattachlist = GetAttachList( this_lcl );
	}

		/* at this point all D3DDevice must have detached themselves
                   unless if this is being called by DDHELP */
#if DBG
        if(dwHelperPid != GetCurrentProcessId())
        {
	    DDASSERT(NULL == this_lcl->lpSurfMore->lpD3DDevIList);
        }
#endif

        /*
	 * If a palette is attached to this surface remove it (and, as a
	 * side effect, release it). Use SetPaletteAlways just in case the 
         * surface has been lost.
	 */
	if( this_lcl->lpDDPalette )
	    SetPaletteAlways( this_int, NULL );

        /*
         * Release the attached clipper (if any).
         */
        if( this_lcl->lpSurfMore->lpDDIClipper )
            DD_Clipper_Release( (LPDIRECTDRAWCLIPPER)this_lcl->lpSurfMore->lpDDIClipper );

	/*
	 * remove all attachments to us from other surfaces
	 */
	pattachlist = this_lcl->lpAttachListFrom;
	while( pattachlist != NULL )
	{
	    curr_int = pattachlist->lpIAttached;
	    DPF( 5, "Deleting attachment from %08lx", curr_int );
	    DeleteOneAttachment( curr_int, this_int, TRUE, DOA_DELETEIMPLICIT );
	    /*
	     * start again at the beginning of the list because
	     * DeleteOneAttachment may have modified the attachment list.
	     * HACKHACK:  this fn call is needed to get around a compiler bug
	     */
	    pattachlist = GetAttachListFrom( this_lcl );
	}

	/*
	 *  Remove any association with a DC. This will tend to mean
	 *  that someone has orphaned a windows DC.
	 */
	if( this_lcl->dwFlags & DDRAWISURF_HASDC )
	{
	    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_OWNDC )
	    {
		HRESULT ddrval;
		DDASSERT( this->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED );
		DDASSERT( this_lcl->hDC != 0UL );
		/*
		 * If this is an OWNDC surface the HDC lives as long as the surface
		 * so release it now.
		 */
		ddrval = InternalReleaseDC( this_lcl, (HDC)this_lcl->hDC
#ifdef WIN95
                , TRUE
#endif  //WIN95
                 );
		DDASSERT( !FAILED(ddrval) );
	    }
	    else
	    {
		/*
		 * If its not an OWNDC surface then the HDC should have been released before
		 * we ever got here.
		 */
		DPF( 1, "HDC Leaked! Surface should only be released after DC is released" );
		// Remove DC from the list
		InternalRemoveDCFromList( NULL, this_lcl );
		// Clear flags
		this_lcl->dwFlags &= ~(DDRAWISURF_HASDC | DDRAWISURF_GETDCNULL);
	    }
	}

        /*
         * Remove private data
         */
        FreeAllPrivateData( &this_lcl->lpSurfMore->pPrivateDataHead );

        /*
        * Region lists should be freed
        */
        if(IsD3DManaged(this_lcl))
        {
            MemFree(this_lcl->lpSurfMore->lpRegionList);
        }

        /*
         * If the ddraw interface which created this surface caused the surface to addref the ddraw
         * object, then we need to release that addref now.
         * We don't release ddraw object for implicitly created surfaces, since
         * that surface never took an addref.
         */
        if (this_lcl->lpSurfMore->lpDD_int)
        {
            pOwner = this_lcl->lpSurfMore->pAddrefedThisOwner;
        }

        if (!bLightweight)
        {
            MemFree(this_lcl->lpSurfMore->pCreatedDDSurfaceDesc2);
            MemFree(this_lcl->lpSurfMore->slist);
        }

	this_lcl->dwFlags &= ~DDRAWISURF_ISFREE;
    }

    /*
     * root object at zero?
     */
    do_free = FALSE;
    if( gblrefcnt == 0 )
    {
#ifdef WINNT
        if (this->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED)
        {
            if (--dwNumLockedWhenModeSwitched == 0)
            {
                NotifyDriverOfFreeAliasedLocks();
            }
            this->dwGlobalFlags &= ~DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
        }
#endif

	/*
	 * get rid of all memory associated with this surface
	 */
	DestroySurface( this_lcl );

        if (0 != this_lcl->lpSurfMore->dwSurfaceHandle)
        {
#ifdef WIN95
            // need to notify the driver that this system memory surface is not associated to
            // this surface handle anymore
            if (this_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
            {
                DDASSERT(0UL == this->fpVidMem);
                // For now, simply warn that the driver failed to associate the surface with the 
                // token and continue
                DDASSERT( pdrv_lcl == this_lcl->lpSurfMore->lpDD_lcl);
                createsurfaceEx(this_lcl);
            }
#endif  
            ReleaseSurfaceHandle(&SURFACEHANDLELIST(pdrv_lcl),this_lcl->lpSurfMore->dwSurfaceHandle);
            //DPF(0,"Release lpSurfMore->dwSurfaceHandle=%08lx",this_lcl->lpSurfMore->dwSurfaceHandle);
            this_lcl->lpSurfMore->dwSurfaceHandle=0;
        }

	this_lcl->dwFlags |= DDRAWISURF_INVALID;
	do_free = TRUE;

#ifdef WIN95
    //
    // Free persistent-content memory, if any
    //

    if (this_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS)
    {
        FreeSurfaceContents(this_lcl);
    }
#endif

    /*
	 * if this was the final delete, but this wasn't the root object,
	 * then we need to delete the dangling object
	 */
	if( !root_object_deleted )
	{
	    LPDDRAWI_DDRAWSURFACE_LCL	root_lcl;

	    /*
	     * Get the start of the root global data object.  Since the
	     * global data always follows the local data, we just need
	     * to back up the size of the local data to get the start of
	     * the allocated block.
	     *
	     * NOTE: The local surface allocation now includes the
	     * additional local surface structure (DDRAWI_DDRAWSURFACE_MORE).
	     * So we need to back up by the size of that structure also.
	     * And also need to move back 4 bytes for the extra pointer
	     * to the GBL_MORE.
	     *
	     * Since all duplicated surfaces have the same local data,
	     * we just need to test this surface for overlay data to determine
	     * if the root object had overlay data.
	     */
	    if( this_lcl->dwFlags & DDRAWISURF_HASOVERLAYDATA )
	    {
		root_lcl = (LPVOID) (((LPSTR) this) - ( sizeof( DDRAWI_DDRAWSURFACE_LCL ) +
		                                        sizeof( DDRAWI_DDRAWSURFACE_MORE ) +
							sizeof( LPDDRAWI_DDRAWSURFACE_GBL_MORE ) ) );
	    }
	    else
	    {
		root_lcl = (LPVOID) (((LPSTR) this) - ( offsetof( DDRAWI_DDRAWSURFACE_LCL, ddckCKSrcOverlay ) +
		                                        sizeof( DDRAWI_DDRAWSURFACE_MORE ) +
							sizeof( LPDDRAWI_DDRAWSURFACE_GBL_MORE ) ) );
	    }

            if (!bLightweight)
            {
	        MemFree( root_lcl );
            }
	}
    }
    else if( lclrefcnt == 0 )
    {
	/*
	 * only remove the object if it wasn't the root.   if it
	 * was the root, we must leave it dangling until the last
	 * object referencing it goes away.
	 */
	if( !root_object_deleted )
	{
	    do_free = TRUE;
	}
    }

    caps = this_lcl->ddsCaps.dwCaps;
    /*
     * If we are releasing an interface to a primary surface, update the pointer to the primary
     * surface stored in the local driver object.  If another interface to the primary surface exists,
     * store that one.  Otherwise, set the pointer to NULL.
     */
    if( intrefcnt == 0 )
    {
	/*
	 * If the video port is using this interface, make it stop
	 */
    	if( ( this_lcl->lpSurfMore->lpVideoPort != NULL ) &&
    	    ( this_lcl->lpSurfMore->lpVideoPort->lpSurface == this_int ) )
    	{
    	    this_lcl->lpSurfMore->lpVideoPort->lpSurface = NULL;
	}

	/*
	 * The following code is to work around a design flaw.
	 * The implicitly created surfaces are not freed until the LCL is
	 * freed, but the attached list references the INT.  Therefore, we
	 * can release an INT now and then try to reference it later when
	 * releasing the LCL.  This happens most often when a second
	 * interface is created for the same LCL, such as ColorControl,
	 * Kernel, Surface2, etc.
	 */
	if( ( lclrefcnt > 0 ) &&
	    ( ( GetAttachList( this_lcl ) != NULL ) ||
            ( GetAttachListFrom( this_lcl ) != NULL ) ) )
	{
	    LPDDRAWI_DDRAWSURFACE_INT new_int;
	    LPATTACHLIST ptr1, ptr2;

	    /*
	     * Find the other INT that is using the LCL
	     */
	    new_int = findOtherInterface(this_int, this_lcl, pdrv);
	    DDASSERT( new_int != NULL );

	    /*
	     * Update the surfaces attachements.
	     * We first go to all interfaces we are attached to and change
	     * their AttachListFrom to reference our new interface.
	     */
	    ptr1 = GetAttachList( this_lcl );
	    while( ptr1 != NULL )
	    {
		DDASSERT( ptr1->lpIAttached != this_int );
		ptr2 = ptr1->lpAttached->lpAttachListFrom;
		while( ptr2 != NULL )
		{
		    if( ptr2->lpIAttached == this_int )
		    {
		    	ptr2->lpIAttached = new_int;
		    }
		    ptr2 = ptr2->lpLink;
		}
		ptr1 = ptr1->lpLink;
	    }

	    /*
	     * We now go to all interfaces we are attached from and change
	     * their AttachList to reference our new interface.
	     */
	    ptr1 = this_lcl->lpAttachListFrom;
	    while( ptr1 != NULL )
	    {
		DDASSERT( ptr1->lpIAttached != this_int );
		ptr2 = GetAttachList( ptr1->lpAttached );
		while( ptr2 != NULL )
		{
		    if( ptr2->lpIAttached == this_int )
		    {
		    	ptr2->lpIAttached = new_int;
		    }
		    ptr2 = ptr2->lpLink;
		}
		ptr1 = ptr1->lpLink;
	    }
	}

	if( caps & DDSCAPS_PRIMARYSURFACE )
	{
	    LPDDRAWI_DDRAWSURFACE_INT temp_int;

	    if( this_lcl->lpSurfMore->lpDD_lcl )
	    {
		this_lcl->lpSurfMore->lpDD_lcl->lpPrimary = findOtherInterface(this_int, this_lcl, pdrv);
	    }

	    /*
	     * If an overlay is overlaying this surface, either make it use
	     * a new primary surface int or turn it off
	     */
	    temp_int = pdrv->dsList;
	    while( temp_int != NULL )
	    {
		if( temp_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
		{
		    if( temp_int->lpLcl->lpSurfaceOverlaying == this_int )
		    {
			if( lclrefcnt > 0 )
			{
			    temp_int->lpLcl->lpSurfaceOverlaying =
			    	findOtherInterface(this_int, this_lcl, pdrv);
			    DDASSERT( temp_int != NULL );
			}
			else
			{
			    temp_int->lpLcl->lpSurfaceOverlaying = NULL;
			}
			if( ( temp_int->lpLcl->lpSurfaceOverlaying == NULL ) &&
			    ( temp_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_VISIBLE ))
			{
			    LPDDHALSURFCB_UPDATEOVERLAY	uohalfn;
			    LPDDHALSURFCB_UPDATEOVERLAY	uofn;
			    DWORD			rc;
			    DDHAL_UPDATEOVERLAYDATA	uod;

			    /*
			     * Turn off the overlay
			     */
			    uofn = pdrv_lcl->lpDDCB->HALDDSurface.UpdateOverlay;
			    uohalfn = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.UpdateOverlay;
			    DDASSERT( uohalfn != NULL );
			    DPF( 2, "Turning off hardware overlay" );
			    uod.UpdateOverlay = uohalfn;
			    uod.lpDD = pdrv;
			    uod.lpDDSrcSurface = temp_int->lpLcl;
			    uod.lpDDDestSurface = NULL;
			    uod.dwFlags = DDOVER_HIDE;
			    DOHALCALL( UpdateOverlay, uofn, uod, rc, FALSE );
			    temp_int->lpLcl->ddsCaps.dwCaps &= ~DDSCAPS_VISIBLE;
			}
		    }
		}
		temp_int = temp_int->lpLink;
	    }
	}
#ifdef SHAREDZ
	if( caps & DDSCAPS_SHAREDBACKBUFFER )
	{
	    if( this_lcl->lpSurfMore->lpDD_lcl )
	    {
		this_lcl->lpSurfMore->lpDD_lcl->lpSharedBack = findOtherInterface(this_int, this_lcl, pdrv);
	    }
	}
	if( caps & DDSCAPS_SHAREDZBUFFER )
	{
	    if( this_lcl->lpSurfMore->lpDD_lcl )
	    {
		this_lcl->lpSurfMore->lpDD_lcl->lpSharedZ = findOtherInterface(this_int, this_lcl, pdrv);
	    }
	}
#endif
    }

    /*
     * free the object if needed
     */
    if( do_free && !bLightweight )
    {
	this_lcl->lpGbl = NULL;

        #ifdef WINNT
        /*
         * Free the associated NT kernel-mode object only if it is a vram surface, it is not
	 * an execute buffer, and it has not yet been freed in the kernel
         */
        if (!(caps & (DDSCAPS_SYSTEMMEMORY) ) && this_lcl->hDDSurface )
        {
            DPF(5,"Deleting NT kernel-mode object handle %08x",this_lcl->hDDSurface);
            if (!DdDeleteSurfaceObject(this_lcl))
                DPF(5,"DdDeleteSurfaceObject failed");
        }
        #endif
        MemFree( this_lcl );
    }

    /*
     * interface at zero?
     */
    if(( intrefcnt == 0) && (!bDX8 || bPrimaryChain))
    {
	/*
	 * remove surface from list of all surfaces
	 */
	curr_int = pdrv->dsList;
	last_int = NULL;
	while( curr_int != this_int )
	{
	    last_int = curr_int;
	    curr_int = curr_int->lpLink;
	    if( curr_int == NULL )
	    {
		DPF_ERR( "Surface not in list!" );
		return 0;
	    }
	}
	if( last_int == NULL )
	{
	    pdrv->dsList = pdrv->dsList->lpLink;
	}
	else
	{
	    last_int->lpLink = curr_int->lpLink;
	}
        curr_int->lpLink = pdrv->dsFreeList;
        pdrv->dsFreeList = curr_int;
        DUMPREFTRACK(this_int);
    }

    if (( 0 == lclrefcnt) && !bLightweight )
    {    
        if (!bDX8 || bPrimaryChain)
        {
            /*
	     * remove surface from list of all surfaces
	     */
	    curr_int = pdrv->dsFreeList;
	    last_int = NULL;
	    while( curr_int )
	    {
                LPDDRAWI_DDRAWSURFACE_INT   temp_int = curr_int->lpLink;
                DDASSERT(0 == curr_int->dwIntRefCnt);
                if (curr_int->lpLcl == this_lcl)
                {
	            if( last_int == NULL )
	            {
	                pdrv->dsFreeList = temp_int;
	            }
	            else
	            {
	                last_int->lpLink = temp_int;
	            }
	            /*
	             * just in case someone comes back in with this pointer, set
	             * an invalid vtbl & data ptr.
	             */
                    curr_int->lpVtbl = NULL;
	            curr_int->lpLcl = NULL;
	            MemFree( curr_int );
                }
                else
                {
	            last_int = curr_int;
                }
                curr_int = temp_int;
	    }

        }
        else
        {
            this_int->lpVtbl = NULL;
	    this_int->lpLcl = NULL;
	    MemFree( this_int );
        }
    }

    /*
     * If the surface took a ref count on the ddraw object that created it,
     * release that ref now as the very last thing.
     * We don't want to do this on ddhelp's thread cuz it really mucks up the
     * process cleanup stuff.
     */
    if (pOwner && (dwHelperPid != GetCurrentProcessId()) )
    {
        pOwner->lpVtbl->Release(pOwner);
    }

    return intrefcnt;

} /* InternalSurfaceRelease */

/*
 * DD_Surface_Release
 *
 * Done with a surface.	  if no one else is using it, then we can free it.
 */
ULONG DDAPI DD_Surface_Release( LPDIRECTDRAWSURFACE lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    DWORD			rc;
    LPDDRAWI_DIRECTDRAW_GBL	pdrv;
    LPDDRAWI_DDRAWSURFACE_INT	pparentsurf_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_Release");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALIDEX_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface pointer" );
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;
	pdrv = this_lcl->lpGbl->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * If this surface is already being freed, immediately return to
     * prevent recursion.
     */

    if( this_lcl->dwFlags & DDRAWISURF_ISFREE )
    {
	DPF(4, "Leaving Release early to prevent recursion" );
	LEAVE_DDRAW();
	return 0;
    }

    if ( this_int->dwIntRefCnt == 0 )
    {
        DPF_ERR( "Interface pointer has 0 ref count!" );
        LEAVE_DDRAW();
        return 0;
    }

    /*
     * If this surface is part of a mip-map chain then we will need
     * to update its parent map's mip-map count.
     */
    pparentsurf_int = NULL;
    if( this_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
	pparentsurf_int = FindParentMipMap( this_int );

    rc = InternalSurfaceRelease( this_int, FALSE, FALSE );

#ifdef REFTRACKING
    if (rc)
    {
        RELEASETRACK(lpDDSurface);
    }
#endif

    /*
     * Update the parent's mip-map count if necessary
     * (if the surface really has gone and if the mip-map
     * has a parent).
     */
    if( ( rc == 0UL ) &&  ( pparentsurf_int != NULL ) )
	UpdateMipMapCount( pparentsurf_int );


    LEAVE_DDRAW();
    return rc;

} /* DD_Surface_Release */

/*
 * ProcessSurfaceCleanup
 *
 * A process is done, clean up any surfaces that it may have locked.
 *
 * NOTE: we enter with a lock taken on the DIRECTDRAW object.
 */
void ProcessSurfaceCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf;
    LPDDRAWI_DDRAWSURFACE_INT	psnext_int;
    DWORD			rcnt;
    ULONG			rc;

    /*
     * run through all surfaces owned by the driver object, and find ones
     * that have been accessed by this process.  If the pdrv_lcl parameter
     * is non-null, only delete surfaces created by that local driver object.
     */
    psurf_int = pdrv->dsList;
    DPF( 4, "ProcessSurfaceCleanup" );
    while( psurf_int != NULL )
    {
	psurf_lcl = psurf_int->lpLcl;
	psurf = psurf_lcl->lpGbl;
	psnext_int = psurf_int->lpLink;
	rc = 1;
	if( ( psurf_lcl->dwProcessId == pid ) &&
	    ( (NULL == pdrv_lcl) || (psurf_lcl->lpSurfMore->lpDD_lcl == pdrv_lcl) ) )
	{
	    if( NULL == pdrv_lcl )
	    {
	        /*
		 * If no local driver object is passed in then we are being called
		 * due to process termination. In this case we can't release
		 * the Direct3D objects as they no longer exist (Direct3D is a
		 * local DLL and dies with the application along with its objects)
		 * Hence, free all the nodes on the IUnknown list and NULL the
		 * list out to prevent InternalSurfaceRelease() from trying to
		 * free them.
	         */
		DPF( 4, "Discarding Direct3D surface interfaces - process terminated" );
	        FreeIUnknowns( psurf_lcl, FALSE );
	    }

	    /*
	     * release the references by this process
	     */
	    rcnt = psurf_int->dwIntRefCnt;
	    DPF( 5, "Process %08lx had %ld accesses to surface %08lx", pid, rcnt, psurf_int );
	    while( rcnt >  0 )
	    {
		if(!(psurf_lcl->dwFlags & DDRAWISURF_IMPLICITCREATE) )
		{
		    rc = InternalSurfaceRelease( psurf_int, FALSE, FALSE );
		    // Multiple surfaces may be released in the call to InternalSurfaceRelease
		    // so we must start again at the beginning of the list.
		    psnext_int = pdrv->dsList;
		    if( rc == 0 )
		    {
			break;
		    }
		}
		rcnt--;
	    }
	}
	else
	{
	    DPF( 5, "Process %08lx had no accesses to surface %08lx", pid, psurf_int );
	}
	psurf_int = psnext_int;
    }
    DPF( 4, "Leaving ProcessSurfaceCleanup");

} /* ProcessSurfaceCleanup */

void FreeD3DSurfaceIUnknowns( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int = pdrv->dsList;
    while( psurf_int != NULL )
    {
	LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl = psurf_int->lpLcl;
	LPDDRAWI_DDRAWSURFACE_INT   psnext_int = psurf_int->lpLink;
	if( ( psurf_lcl->dwProcessId == pid ) &&
	    (psurf_lcl->lpSurfMore->lpDD_lcl == pdrv_lcl) )
	{
	    DPF( 4, "Release Direct3D surface interfaces" );
            FreeIUnknowns( psurf_lcl, TRUE );
	}
        psurf_int = psnext_int;
    }
} /* FreeD3DSurfaceIUnknowns */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\dd\ddraw\main\ddsover.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddsover.c
 *  Content:	DirectDraw Surface overlay support:
 *		UpdateOverlay
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27-jan-95	craige	split out of ddsurf.c, enhanced
 *   31-jan-95	craige	and even more ongoing work...
 *   03-feb-95	craige	performance tuning, ongoing work
 *   27-feb-95	craige	new sync. macros
 *   08-mar-95	craige	new APIs: GetOverlayPosition, GetOverlayZOrder
 *			SetOverlayZOrder, SetOverlayPosition
 *   19-mar-95	craige	use HRESULTs
 *   01-apr-95	craige	happy fun joy updated header file
 *   03-apr-95	craige	made update overlay work again
 *   06-may-95	craige	use driver-level csects only
 *   14-may-95	craige	cleaned out obsolete junk
 *   15-may-95	kylej	deleted GetOverlayZOrder, SetOverlayZOrder,
 *			InsertOverlayZOrder.  Added UpdateOverlayZOrder
 *			and EnumOverlayZOrders.
 *   17-jun-95	craige	new surface structure
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns; tweaks in UpdateOverlay;
 *			verify stretching; disabled alpha
 *   30-jun-95	craige	small bug fixes; verify rectangle alignment
 *   04-jul-95	craige	YEEHAW: new driver struct; SEH
 *   10-jul-95	craige	support Get/SetOverlayPosition
 *   10-jul-95  kylej   mirroring caps and flags
 *   13-jul-95	craige	changed Get/SetOverlayPosition to use LONG
 *   31-jul-95	craige	validate flags
 *   19-aug-95 davidmay don't check rectangles when hiding overlay
 *   10-dec-95  colinmc added execute buffer support
 *   02-jan-96	kylej	handle new interface structs
 *   12-feb-96  colinmc surface lost flag moved from global to local object
 *   23-apr-96	kylej	use dwMinOverlayStretch and dwMaxOverlayStretch
 *			validate that entire dest rect is in overlayed surface
 *   29-jan-97	smac	Removed old ring 0 code
 *   03-mar-97	smac	Added kernel mode interface
 *   19-nov-98 jvanaken Overlays with alpha blending
 *
 ***************************************************************************/
#include "ddrawpr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "UpdateOverlay"

/*
 * checkOverlayStretching
 *
 * check and see if we can stretch or not
 */
HRESULT checkOverlayStretching(
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		DWORD dest_height,
		DWORD dest_width,
		DWORD src_height,
		DWORD src_width,
		DWORD src_caps,
		BOOL emulate )
{
    DWORD		caps;
    DWORD		basecaps;
    BOOL		fail;
    DWORD		dwMinStretch;
    DWORD		dwMaxStretch;

    fail = FALSE;

    if( emulate )
    {
	basecaps = pdrv->ddHELCaps.dwCaps;
	caps = pdrv->ddHELCaps.dwFXCaps;
	if( src_caps & DDSCAPS_LIVEVIDEO )
	{
	    dwMinStretch = pdrv->ddHELCaps.dwMinLiveVideoStretch;
	    dwMaxStretch = pdrv->ddHELCaps.dwMaxLiveVideoStretch;
	}
	else if( src_caps & DDSCAPS_HWCODEC )
	{
	    dwMinStretch = pdrv->ddHELCaps.dwMinHwCodecStretch;
	    dwMaxStretch = pdrv->ddHELCaps.dwMaxHwCodecStretch;
	}
	else
	{
	    dwMinStretch = pdrv->ddHELCaps.dwMinOverlayStretch;
	    dwMaxStretch = pdrv->ddHELCaps.dwMaxOverlayStretch;
	}
    }
    else
    {
	basecaps = pdrv->ddCaps.dwCaps;
	caps = pdrv->ddCaps.dwFXCaps;
	if( src_caps & DDSCAPS_LIVEVIDEO )
	{
	    dwMinStretch = pdrv->ddCaps.dwMinLiveVideoStretch;
	    dwMaxStretch = pdrv->ddCaps.dwMaxLiveVideoStretch;
	}
	else if( src_caps & DDSCAPS_HWCODEC )
	{
	    dwMinStretch = pdrv->ddCaps.dwMinHwCodecStretch;
	    dwMaxStretch = pdrv->ddCaps.dwMaxHwCodecStretch;
	}
	else
	{
	    dwMinStretch = pdrv->ddCaps.dwMinOverlayStretch;
	    dwMaxStretch = pdrv->ddCaps.dwMaxOverlayStretch;
	}
    }

    /*
     * Check against dwMinOverlayStretch
     */
    if( src_width*dwMinStretch > dest_width*1000 )
    {
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Check against dwMaxOverlayStretch
     */
    if( (dwMaxStretch != 0) && (src_width*dwMaxStretch < dest_width*1000) )
    {
	return DDERR_INVALIDPARAMS;
    }


    if( (src_height == dest_height) && (src_width == dest_width) )
    {
	// not stretching.
	return DD_OK;
    }

    /*
     * If we are here, we must be trying to stretch.
     * can we even stretch at all?
     */
    if( !(basecaps & DDCAPS_OVERLAYSTRETCH))
    {
	return DDERR_NOSTRETCHHW;
    }

    /*
     * verify height
     */
    if( src_height != dest_height )
    {
	if( src_height > dest_height )
	{
	    /*
	     * can we shrink Y arbitrarily?
	     */
	    if( !(caps & DDFXCAPS_OVERLAYSHRINKY) )
	    {
		/*
		 * see if this is a non-integer shrink
		 */
		if( (src_height % dest_height) != 0 )
		{
		    return DDERR_NOSTRETCHHW;
		/*
		 * see if we can integer shrink
		 */
		}
		else if( !(caps & DDFXCAPS_OVERLAYSHRINKYN) )
		{
		    return DDERR_NOSTRETCHHW;
		}
	    }
	}
	else
	{
	    if( !(caps & DDFXCAPS_OVERLAYSTRETCHY) )
	    {
		/*
		 * see if this is a non-integer stretch
		 */
		if( (dest_height % src_height) != 0 )
		{
		    return DDERR_NOSTRETCHHW;
		/*
		 * see if we can integer stretch
		 */
		}
		else if( !(caps & DDFXCAPS_OVERLAYSTRETCHYN) )
		{
		    return DDERR_NOSTRETCHHW;
		}
	    }
	}
    }

    /*
     * verify width
     */
    if( src_width != dest_width )
    {
	if( src_width > dest_width )
	{
	    if( !(caps & DDFXCAPS_OVERLAYSHRINKX) )
	    {
		/*
		 * see if this is a non-integer shrink
		 */
		if( (src_width % dest_width) != 0 )
		{
		    return DDERR_NOSTRETCHHW;
		/*
		 * see if we can integer shrink
		 */
		}
		else if( !(caps & DDFXCAPS_OVERLAYSHRINKXN) )
		{
		    return DDERR_NOSTRETCHHW;
		}
	    }
	}
	else
	{
	    if( !(caps & DDFXCAPS_OVERLAYSTRETCHX) )
	    {
		/*
		 * see if this is a non-integer stretch
		 */
		if( (dest_width % src_width) != 0 )
		{
		    return DDERR_NOSTRETCHHW;
		}
		if( !(caps & DDFXCAPS_OVERLAYSTRETCHXN) )
		{
		    return DDERR_NOSTRETCHHW;
		}
	    }
	}
    }

    return DD_OK;

} /* checkOverlayStretching */

/*
 * checkOverlayFlags
 */
static HRESULT checkOverlayFlags(
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		LPDWORD lpdwFlags,
		LPDDRAWI_DDRAWSURFACE_INT this_src_int,
		LPDDRAWI_DDRAWSURFACE_LCL this_dest_lcl,
		LPDDHAL_UPDATEOVERLAYDATA puod,
		LPDDOVERLAYFX lpDDOverlayFX,
		BOOL emulate )
{
    LPDDRAWI_DDRAWSURFACE_LCL this_src_lcl;
    DWORD		basecaps;
    DWORD		baseckeycaps;
    DWORD		dwFlags;

    this_src_lcl = this_src_int->lpLcl;
    dwFlags= * lpdwFlags;

    if( emulate )
    {
	basecaps = pdrv->ddHELCaps.dwCaps;
	baseckeycaps = pdrv->ddHELCaps.dwCKeyCaps;
    }
    else
    {
	basecaps = pdrv->ddCaps.dwCaps;
	baseckeycaps = pdrv->ddCaps.dwCKeyCaps;
    }

    /*
     * Handle auto-flipping
     */
    if( dwFlags & DDOVER_AUTOFLIP )
    {
	DWORD rc;

	rc = IsValidAutoFlipSurface( this_src_int );
	if( rc == IVAS_NOAUTOFLIPPING )
	{
	    DPF_ERR( "AUTOFLIPPING not valid" );
	    return DDERR_INVALIDPARAMS;
	}
	else if( rc == IVAS_SOFTWAREAUTOFLIPPING )
	{
	    /*
	     * Software autoflipping only
	     */
	    this_src_lcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SOFTWAREAUTOFLIP;
	}
    }

    /*
     * Handle bob
     */
    if( dwFlags & DDOVER_BOB )
    {
	/*
	 * Fail if bob caps not specified
	 */
	if( dwFlags & DDOVER_INTERLEAVED )
	{
	    if( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_CANBOBINTERLEAVED ) )
	    {
	    	DPF_ERR( "Device doesn't support DDOVER_BOB while interleaved!" );
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    if( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED ) )
	    {
	    	DPF_ERR( "Device doesn't support DDOVER_BOB!" );
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Is the surface fed by a video port?
	 */
	if( ( this_src_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT ) &&
	    ( this_src_lcl->lpSurfMore->lpVideoPort != NULL ) )
	{
	    /*
	     * Yes - fail (at least for DX5) if they are bobbing and not
	     * autofliiping.  This is because this support is broken in DX5.
	     */
	    if( !( dwFlags & ( DDOVER_AUTOFLIP | DDOVER_INTERLEAVED ) ) )
	    {
	    	DPF_ERR( "DDOVER_BOB specified without autoflip or interleaved!" );
		return DDERR_INVALIDPARAMS;
	    }
	    if( MustSoftwareBob( this_src_int ) )
	    {
		dwFlags &= ~DDOVER_BOBHARDWARE;
	    }
	    else
	    {
		dwFlags |= DDOVER_BOBHARDWARE;
	    }
	}
	else
	{
	    /*
	     * Don't allow non-VPE clients to use bob unless the
	     * driver can handle it.
	     */
	    if( !( pdrv->ddCaps.dwCaps2 & DDCAPS2_CANFLIPODDEVEN ) )
	    {
		DPF_ERR( "Device does not support DDCAPS2_CANFLIPODDEVEN" );
		return DDERR_INVALIDPARAMS;
	    }
	    if( dwFlags & DDOVER_BOBHARDWARE )
	    {
		DPF_ERR( "DDOVER_BOBHARDWARE only valid when used with a video port" );
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
    else if( dwFlags & DDOVER_BOBHARDWARE )
    {
	DPF_ERR( "DDOVER_BOBHARDWARE specified w/o DDOVER_BOB" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * ALPHA DISABLED FOR REV 1
     */
    #pragma message( REMIND( "Alpha disabled for rev 1" ) )
    #ifdef USE_ALPHA
    /*
     * verify alpha
     */
    if( dwFlags & DDOVER_ANYALPHA )
    {
	/*
	 * dest
	 */
	if( dwFlags & DDOVER_ALPHADEST )
	{
	    if( dwFlags & (DDOVER_ALPHASRC |
			     DDOVER_ALPHADESTCONSTOVERRIDE |
			     DDOVER_ALPHADESTSURFACEOVERRIDE) )
	    {
		DPF_ERR( "ALPHADEST and other alpha sources specified" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf_lcl = FindAttached( this_dest_lcl, DDSCAPS_ALPHA );
	    if( psurf_lcl == NULL )
	    {
		DPF_ERR( "ALPHADEST requires an attached alpha to the dest" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf = psurf_lcl->lpGbl;
	    dwFlags &= ~DDOVER_ALPHADEST;
	    dwFlags |= DDOVER_ALPHADESTSURFACEOVERRIDE;
	    puod->overlayFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) psurf;
	}
	else if( dwFlags & DDOVER_ALPHADESTCONSTOVERRIDE )
	{
	    if( dwFlags & ( DDOVER_ALPHADESTSURFACEOVERRIDE) )
	    {
		DPF_ERR( "ALPHADESTCONSTOVERRIDE and other alpha sources specified" );
		return DDERR_INVALIDPARAMS;
	    }
	    puod->overlayFX.dwConstAlphaDestBitDepth =
			    lpDDOverlayFX->dwConstAlphaDestBitDepth;
	    puod->overlayFX.dwConstAlphaDest = lpDDOverlayFX->dwConstAlphaDest;
	}
	else if( dwFlags & DDOVER_ALPHADESTSURFACEOVERRIDE )
	{
	    psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDOverlayFX->lpDDSAlphaDest;
	    if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_lcl ) )
	    {
		DPF_ERR( "ALPHASURFACEOVERRIDE requires surface ptr" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf = psurf_lcl->lpGbl;
	    if( SURFACE_LOST( psurf_lcl ) )
	    {
		return DDERR_SURFACELOST;
	    }
	    puod->overlayFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) psurf;
	}

	/*
	 * source
	 */
	if( dwFlags & DDOVER_ALPHASRC )
	{
	    if( dwFlags & (DDOVER_ALPHASRC |
			     DDOVER_ALPHASRCCONSTOVERRIDE |
			     DDOVER_ALPHASRCSURFACEOVERRIDE) )
	    {
		DPF_ERR( "ALPHASRC and other alpha sources specified" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf_lcl = FindAttached( this_dest_lcl, DDSCAPS_ALPHA );
	    if( psurf_lcl == NULL )
	    {
		DPF_ERR( "ALPHASRC requires an attached alpha to the dest" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf = psurf_lcl->lpGbl;
	    dwFlags &= ~DDOVER_ALPHASRC;
	    dwFlags |= DDOVER_ALPHASRCSURFACEOVERRIDE;
	    puod->overlayFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) psurf;
	}
	else if( dwFlags & DDOVER_ALPHASRCCONSTOVERRIDE )
	{
	    if( dwFlags & ( DDOVER_ALPHASRCSURFACEOVERRIDE) )
	    {
		DPF_ERR( "ALPHASRCCONSTOVERRIDE and other alpha sources specified" );
		return DDERR_INVALIDPARAMS;
	    }
	    puod->overlayFX.dwConstAlphaSrcBitDepth =
			    lpDDOverlayFX->dwConstAlphaSrcBitDepth;
	    puod->overlayFX.dwConstAlphaSrc = lpDDOverlayFX->dwConstAlphaSrc;
	}
	else if( dwFlags & DDOVER_ALPHASRCSURFACEOVERRIDE )
	{
	    psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) lpDDOverlayFX->lpDDSAlphaSrc;
	    if( !VALID_DIRECTDRAWSURFACE_PTR( psurf_lcl ) )
	    {
		DPF_ERR( "ALPHASURFACEOVERRIDE requires surface ptr" );
		return DDERR_INVALIDPARAMS;
	    }
	    psurf = psurf_lcl->lpGbl;
	    if( SURFACE_LOST( psurf_lcl ) )
	    {
		return DDERR_SURFACELOST;
	    }
	    puod->overlayFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) psurf;
	}
    }
    #endif

    /*
     * verify color key overrides
     */
    if( dwFlags & (DDOVER_KEYSRCOVERRIDE|DDOVER_KEYDESTOVERRIDE) )
    {
	if( !(basecaps & DDCAPS_COLORKEY) )
	{
	    DPF_ERR( "KEYOVERRIDE specified, colorkey not supported" );
	    return DDERR_NOCOLORKEYHW;
	}
	if( dwFlags & DDOVER_KEYSRCOVERRIDE )
	{
	    if( !(baseckeycaps & DDCKEYCAPS_SRCOVERLAY) )
	    {
		DPF_ERR( "KEYSRCOVERRIDE specified, not supported" );
		return DDERR_NOCOLORKEYHW;
	    }
	    puod->overlayFX.dckSrcColorkey = lpDDOverlayFX->dckSrcColorkey;
	}
	if( dwFlags & DDOVER_KEYDESTOVERRIDE )
	{
	    if( !(baseckeycaps & DDCKEYCAPS_DESTOVERLAY) )
	    {
		DPF_ERR( "KEYDESTOVERRIDE specified, not supported" );
		return DDERR_NOCOLORKEYHW;
	    }
	    puod->overlayFX.dckDestColorkey = lpDDOverlayFX->dckDestColorkey;
	}
    }

    /*
     * verify src color key
     */
    if( dwFlags & DDOVER_KEYSRC )
    {
	if( dwFlags & DDOVER_KEYSRCOVERRIDE )
	{
	    DPF_ERR( "KEYSRC specified with KEYSRCOVERRIDE" );
	    return DDERR_INVALIDPARAMS;
	}
	if( !(this_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCOVERLAY) )
	{
	    DPF_ERR( "KEYSRC specified, but no color key" );
	    return DDERR_INVALIDPARAMS;
	}
	puod->overlayFX.dckSrcColorkey = this_src_lcl->ddckCKSrcOverlay;
	dwFlags &= ~DDOVER_KEYSRC;
	dwFlags |= DDOVER_KEYSRCOVERRIDE;
    }

    /*
     * verify dest color key
     */
    if( dwFlags & DDOVER_KEYDEST )
    {
	if( dwFlags & DDOVER_KEYDESTOVERRIDE )
	{
	    DPF_ERR( "KEYDEST specified with KEYDESTOVERRIDE" );
	    return DDERR_INVALIDPARAMS;
	}
	if( !(this_dest_lcl->dwFlags & DDRAWISURF_HASCKEYDESTOVERLAY) )
	{
	    DPF_ERR( "KEYDEST specified, but no color key" );
	    return DDERR_INVALIDPARAMS;
	}
	puod->overlayFX.dckDestColorkey = this_dest_lcl->ddckCKDestOverlay;
	dwFlags &= ~DDOVER_KEYDEST;
	dwFlags |= DDOVER_KEYDESTOVERRIDE;
    }

    *lpdwFlags = dwFlags;
    return DD_OK;

} /* checkOverlayFlags */

/*
 * flags we need to call checkOverlayFlags for
 */
#define FLAGS_TO_CHECK \
    (DDOVER_KEYSRCOVERRIDE| DDOVER_KEYDESTOVERRIDE | \
     DDOVER_KEYSRC | DDOVER_KEYDEST | DDOVER_OVERRIDEBOBWEAVE | \
     DDOVER_AUTOFLIP | DDOVER_BOB )


/*
 * Return a pointer to the DDPIXELFORMAT structure that
 * describes the specified surface's pixel format.
 */
static DWORD getPixelFormatFlags(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    if (surf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
	// surface contains explicitly defined pixel format
	return surf_lcl->lpGbl->ddpfSurface.dwFlags;
    }

    // surface's pixel format is implicit -- same as primary's
    return surf_lcl->lpSurfMore->lpDD_lcl->lpGbl->vmiData.ddpfDisplay.dwFlags;

}  /* getPixelFormatFlags */

#if 0
/*
 * checkOverlayAlpha -- See if we can do specified alpha-blending operation.
 */
static HRESULT checkOverlayAlpha(
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		LPDWORD lpdwFlags,
		LPDDRAWI_DDRAWSURFACE_LCL src_surf_lcl,
                LPDDHAL_UPDATEOVERLAYDATA puod,
		LPDDOVERLAYFX lpDDOverlayFX,
		BOOL emulate )
{
    DDARGB argb = { 255, 255, 255, 255 };
    DWORD fxcaps = 0;
    DWORD alphacaps = 0;
    DWORD pfflags = getPixelFormatFlags(src_surf_lcl);
    DWORD dwFlags = *lpdwFlags;

    if( emulate )
    {
        fxcaps = pdrv->ddHELCaps.dwFXCaps;
        if (pdrv->lpddHELMoreCaps)
        {
            alphacaps = pdrv->lpddHELMoreCaps->dwAlphaCaps;
        }
    }
    else
    {
        fxcaps = pdrv->ddCaps.dwFXCaps;
        if (pdrv->lpddMoreCaps)
        {
            alphacaps = pdrv->lpddMoreCaps->dwAlphaCaps;
        }
    }
	
    // Is any type of alpha blending required for this overlay?
    if (!(pfflags & DDPF_ALPHAPIXELS) && !(dwFlags & DDOVER_ARGBSCALEFACTORS))
    {
        return DD_OK;	 // no alpha blending is needed
    }

    // Yes, verify that the driver supports alpha blending.
    if (!(fxcaps & DDFXCAPS_OVERLAYALPHA))
    {
        DPF_ERR("Driver can't do alpha blending on overlays");
        return DDERR_NOALPHAHW;
    }

    // Is dest color keying also enabled for this overlay?
    if ((dwFlags & (DDOVER_KEYDEST | DDOVER_KEYDESTOVERRIDE)) &&
        !(alphacaps &DDALPHACAPS_OVERLAYALPHAANDKEYDEST))
    {
        DPF_ERR("Driver can't do alpha blending and dest color key on same overlay");
        return DDERR_UNSUPPORTED;
    }

    // Get ARGB scaling factors from DDOVERLAYFX structure.
    *(LPDWORD)&argb = ~0;    // default = ARGB scaling disabled (all ones)
    if (dwFlags & DDOVER_ARGBSCALEFACTORS)
    {
        if( !(*lpdwFlags & DDOVER_DDFX) )
        {
            DPF_ERR("Must specify DDOVER_DDFX with DDOVER_ARGBSCALEFACTORS");
            return DDERR_INVALIDPARAMS;
        }
        argb = lpDDOverlayFX->ddargbScaleFactors;   // ARGB scaling enabled
    }

    // Does the source surface have an alpha channel?
    if (pfflags & DDPF_ALPHAPIXELS)
    {
        /*
         * Yes, verify that the driver can handle an alpha channel.
         * (This check is a bit redundant since the driver has already blessed
         * the format of this overlay surface by allowing it to be created.)
         */ 
        if (!(alphacaps & DDALPHACAPS_OVERLAYALPHAPIXELS))
        {
            DPF_ERR("Driver can't handle source surface's alpha channel");
            return DDERR_NOALPHAHW;
        }

        // Ignore source color key flags if source has alpha channel.
        if (dwFlags & (DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE))
        {
            *lpdwFlags &= ~(DDOVER_KEYSRC | DDOVER_KEYSRCOVERRIDE);
        }

        /*
         * Are we asking the driver to handle both ARGB scaling and
         * an alpha channel when it can't do both at the same time?
         */
        if (*(LPDWORD)&argb != ~0 &&
            !(alphacaps & DDALPHACAPS_OVERLAYALPHAANDARGBSCALING))
        {
            if (!(dwFlags & DDOVER_DEGRADEARGBSCALING))
            {
                DPF_ERR("Driver can't handle alpha channel and ARGB scaling at same time");
                return DDERR_INVALIDPARAMS;
            }
            // We're allowed to degrade ARGB scaling, so turn it off.
            *(LPDWORD)&argb = ~0;
        }

        /*
         * Are color components in pixel format premultiplied by the
         * alpha component or not?  In either case, verify that the
         * driver supports the specified alpha format.
         */
        if (pfflags & DDPF_ALPHAPREMULT)
        {
            // Source pixel format uses premultiplied alpha.
            if (!(alphacaps & DDALPHACAPS_OVERLAYPREMULT))
            {
                DPF_ERR("No driver support for premultiplied alpha");
                return DDERR_NOALPHAHW;
            }
        }
        else
        {
            // Source pixel format uses NON-premultiplied alpha.
            if (!(alphacaps & DDALPHACAPS_OVERLAYNONPREMULT))
            {
                DPF_ERR("No driver support for non-premultiplied alpha");
                return DDERR_NOALPHAHW;
            }

            /*
             * We allow only one-factor ARGB scaling with a source surface
             * that has a non-premultiplied alpha pixel format.
             * The following code enforces this rule.
             */
            if (*(LPDWORD)&argb != ~0)
            {
                // ARGB scaling is enabled.  Check for one-factor scaling.
                DWORD val = 0x01010101UL*argb.alpha;

                if (*(LPDWORD)&argb != val)
                {
                    // Uh-oh.  This is NOT one-factor ARGB scaling.
                    if (!(dwFlags & DDABLT_DEGRADEARGBSCALING))
                    {
                        DPF_ERR("Can't do 2- or 4-mult ARGB scaling if source has non-premultiplied alpha");
                        return DDERR_INVALIDPARAMS;
                    }
                    // We're allowed to degrade to one-factor scaling.
                    *(LPDWORD)&argb = val;
                }
            }
        }
    }

    // Is ARGB scaling is enabled?
    if (*(LPDWORD)&argb != ~0UL)
    {
        // Yes, ARGB scaling is enabled.  Is DEGRADESCALEFACTORS flag set?
        if (dwFlags & DDOVER_DEGRADEARGBSCALING)
        {
            /*
             * Yes, if necessary, we are permitted to degrade the ARGB
             * scaling factors to values the driver can handle.
             */
            if (!(alphacaps & (DDALPHACAPS_OVERLAYARGBSCALE1F |
                DDALPHACAPS_OVERLAYARGBSCALE2F |
                DDALPHACAPS_OVERLAYARGBSCALE4F)))
            {
                /*
                 * Driver can't do any kind of ARGB scaling at all, so just
                 * disable ARGB scaling by setting all four factors to 255.
                 */
                *(LPDWORD)&argb = ~0UL;
            }
            else if (!(alphacaps & (DDALPHACAPS_OVERLAYARGBSCALE2F |
                DDALPHACAPS_OVERLAYARGBSCALE4F)))
            {
                /*
                 * The driver can do only one-factor ARGB scaling, so set the
                 * three color factors to the same value as the alpha factor.
                 */
                *(LPDWORD)&argb = 0x01010101UL*argb.alpha;
            }
            else if (!(alphacaps & DDALPHACAPS_OVERLAYARGBSCALE4F))
            {
                /*
                 * Driver can do only 2-factor ARGB scaling, so make sure
                 * all three color factors are set to the same value.
                 */
                if ((argb.red != argb.green) || (argb.red != argb.blue))
                {
                    /*
                     * Set all three color factors to value "fact", which is the
                     * weighted average of their specified values (Fr,Fg,Fb):
                     *     fact = .299*Fr + .587*Fg + .114*Fb
                     */
                    DWORD fact = 19595UL*argb.red + 38470UL*argb.green +
                        7471UL*argb.blue;

                    argb.red =
                    argb.green =
                    argb.blue = (BYTE)(fact >> 16);
                }
	    }
            /*
             * Does driver use saturated arithmetic to do alpha blending?
             */
            if (!(alphacaps & DDALPHACAPS_OVERLAYSATURATE))
            {
                /*
                 * The driver can't do saturated arithmetic, so ensure that none
                 * of the color factors exceeds the value of the alpha factor.
                 */
                if (argb.red > argb.alpha)
                {
                    argb.red = argb.alpha;
                }
                if (argb.green > argb.alpha)
                {
                    argb.green = argb.alpha;
                }
                if (argb.blue > argb.alpha)
                {
                    argb.blue = argb.alpha;
                }
            }
        }
        else    
        {
            /*
             * We are not permitted to degrade the ARGB scaling factors, so if
             * the driver can't handle them as specified, the call must fail.
             * We permit a color factor to be larger than the alpha factor
             * only if the hardware uses saturated arithmetic.  (Otherwise, we
             * would risk integer overflow when we calculate the color values.)
             */
            if (!(alphacaps & DDALPHACAPS_OVERLAYSATURATE) &&
                ((argb.red > argb.alpha) || (argb.green > argb.alpha) ||
                (argb.blue > argb.alpha)))
            {
                DPF_ERR("Driver can't handle specified ARGB scaling factors");
                return DDERR_NOALPHAHW;
            }

            // Can the driver handle any ARGB scaling at all?
            if (!(alphacaps & (DDALPHACAPS_OVERLAYARGBSCALE1F |
                DDALPHACAPS_OVERLAYARGBSCALE2F |
                DDALPHACAPS_OVERLAYARGBSCALE4F)))
            {
                DPF_ERR("Driver can't handle any ARGB scaling at all");
                return DDERR_NOALPHAHW;
            }

            if ((argb.red != argb.green) || (argb.red != argb.blue))
            {
                /*
                 * Driver must be capable of doing 4-factor ARGB scaling.
                 */
                if (!(alphacaps & DDALPHACAPS_OVERLAYARGBSCALE4F))
                {
                    DPF_ERR("Driver can't handle 4-factor ARGB scaling");
                    return DDERR_NOALPHAHW;
                }
            }
            else if (argb.red != argb.alpha)
            {
                /*
                 * Driver must be capable of doing 2-factor ARGB scaling.
                 */
                if (!(alphacaps & (DDALPHACAPS_OVERLAYARGBSCALE2F |
                    DDALPHACAPS_OVERLAYARGBSCALE4F)))
  