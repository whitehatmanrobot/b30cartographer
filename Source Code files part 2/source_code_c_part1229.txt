 LONG        max_Yscreen;    //Visible screen boundary.
    LONG        Hres;           //current mode horizontal piexl.
    LONG        Vres;           //current mode vertical piexl.
//myf1, end
    SHORT       bBlockSwitch;   //display switch block flag     //myf12
    SHORT       bDisplaytype;   //display type, 0:LCD, 1:CRT, 2:SIM  //myf12

    STATUS      flStatus;               // Status flags
    BOOL        bEnabled;               // In graphics mode (not full-screen)

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF*      pdsurfScreen;           // Our private DSURF for the screen

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyMemory;               // Height of Video RAM
    ULONG       ulMemSize;              // Amount of video Memory
    ULONG       ulMode;                 // Mode the mini-port driver is in.
    LONG        lDelta;                 // Distance from one scan to the next.

    FLONG       flHooks;                // What we're hooking from GDI
    LONG        cBitsPerPixel;          // 8 if 8bpp, 16 if 16bpp, 32 if 32bpp
    LONG        cBpp;                   // 1 if 8bpp,  2 if 16bpp, 3 if 24bpp, etc.

    //
    // The compiler should maintain DWORD alignment for the values following
    // the BYTE jModeColor.  There will be an ASSERT to guarentee this.
    //

    BYTE        jModeColor;             // HW flag for current color depth

    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    VOID*       pvTmpBuffer;            // General purpose temporary buffer,
                                        //   TMP_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)
    LONG        lXferBank;
    ULONG*      pulXfer;

    ////////// Low-level blt function pointers:

    FNFILL*     pfnFillSolid;
    FNFILL*     pfnFillPat;
    FNXFER*     pfnXfer1bpp;
    FNXFER*     pfnXfer4bpp;
    FNXFER*     pfnXferNative;
    FNCOPY*     pfnCopyBlt;
    FNFASTPATREALIZE* pfnFastPatRealize;
    FNBITS*     pfnGetBits;
    FNBITS*     pfnPutBits;
#if LINETO
    FNLINETO*   pfnLineTo;
#endif

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed

//
// chu01 : GAMMACORRECT
//
    PALETTEENTRY* pCurrentPalette ;     // The global palette for gamma
                                        // correction.

    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields

    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap
    SURFOBJ*    psoPunt;                // Wrapper surface for having GDI draw
                                        //   on off-screen bitmaps
    SURFOBJ*    psoPunt2;               // Another one for off-screen to off-
                                        //   screen blts
    OH*         pohScreen;              // Allocation structure for the screen

    ////////// Banking stuff:

    ULONG       ulBankShiftFactor;
    BOOL        bLinearMode;            // True if the framebuffer is linear
    LONG        cjBank;                 // Size of a bank, in bytes
    LONG        cPower2ScansPerBank;    // Used by 'bBankComputePower2'
    LONG        cPower2BankSizeInBytes; // Used by 'bBankComputePower2'
    CLIPOBJ*    pcoBank;                // Clip object for banked call backs
    SURFOBJ*    psoBank;                // Surface object for banked call backs
    SURFOBJ*    psoFrameBuffer;         // Surface object for non-banked call backs
    VOID*       pvBankData;             // Points to aulBankData[0]
    ULONG       aulBankData[BANK_DATA_SIZE / 4];
                                        // Private work area for downloaded
                                        //   miniport banking code

    FNBANKMAP*          pfnBankMap;
    FNBANKSELECTMODE*   pfnBankSelectMode;
    FNBANKCOMPUTE*      pfnBankCompute;

    ////////// Pointer stuff:

    LONG        xPointerHot;            // xHot of current hardware pointer
    LONG        yPointerHot;            // yHot of current hardware pointer
    LONG        xPointerShape;          // xPos of current hardware pointer
    LONG        yPointerShape;          // yPos of current hardware pointer
    SIZEL       sizlPointer;            // Size of current hardware pointer
//ms923    LONG        lDeltaPointer;      // Row offset for hardware pointer
    FLONG       flPointer;              // Flags reflecting pointer state
    PBYTE       pjPointerAndMask;
    PBYTE       pjPointerXorMask;
    LONG        iPointerBank;           // Bank containing pointer shape
    VOID*       pvPointerShape;         // Points to pointer shape when bank
                                        //   is mapped in
    LONG        cjPointerOffset;        // Byte offset from start of frame
                                        //   buffer to off-screen memory where
                                        //   we stored the pointer shape
//pat04, for NT 3.51 software cursor, begin
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL
    OH*         pjCBackground;
    OH*         pjPointerAndCMask;
    OH*         pjPointerCBitmap ;
    LONG        xcount;
    LONG        ppScanLine;
    LONG        oldx;                   // old x cordinate
    LONG        oldy;                   // old y cordinate
    LONG        globdat;
#endif
#endif
//pat04, for NT 3.51 software cursor, end

    FNSHOWPOINTER*      pfnShowPointer;
    FNMOVEPOINTER*      pfnMovePointer;
    FNSETPOINTERSHAPE*  pfnSetPointerShape;
    FNENABLEPOINTER*    pfnEnablePointer;

    ////////// Brush stuff:

    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    BRUSHENTRY  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache
    ULONG       ulSolidColorOffset;
    ULONG       ulAlignedPatternOffset;

#if 1 // New brush caches.
    LONG         iDitherCache;                  // Index to next dither cache entry.
    DITHERCACHE  aDithers[NUM_DITHERS];         // Dither cache.

    LONG         iPatternCache;                 // Index to next pattern cache entry.
    PATTERNCACHE aPatterns[NUM_PATTERNS];
                                                // Pattern cache.

    LONG         iMonochromeCache;              // Index to next monochrome cache entry.
    MONOCACHE    aMonochromes[NUM_MONOCHROMES];
                                                // Monochrome cache.
#endif

    ////////// DCI stuff:

    BOOL        bSupportDCI;            // True if miniport supports DCI

#if DIRECTDRAW
    ////////// DirectDraw stuff:

    FLIPRECORD  flipRecord;             // Used to track VBlank status
    OH*         pohDirectDraw;          // Off-screen heap allocation for use by
                                        //   DirectDraw
    ULONG       ulCR1B;                 // Contents of CR1B register.
    ULONG       ulCR1D;                 // Contents of CR1D register.
    DWORD       dwLinearCnt;            // Number of locks on surface.

// crus
#if 1 // OVERLAY #sge
    PDD_SURFACE_LOCAL lpHardwareOwner;
    PDD_SURFACE_LOCAL lpColorSurface;
    PDD_SURFACE_LOCAL lpSrcColorSurface;
    OVERLAYWINDOW     sOverlay1;
    DWORD   dwPanningFlag;
    WORD    wColorKey;
    DWORD   dwSrcColorKeyLow;
    DWORD   dwSrcColorKeyHigh;
    RECTL   rOverlaySrc;
    RECTL   rOverlayDest;
    BOOL    bDoubleClock;
    LONG    lFifoThresh;
    BYTE    VertStretchCode[MAX_STRETCH_SIZE];
    BYTE    HorStretchCode[MAX_STRETCH_SIZE];
    FLATPTR fpVisibleOverlay;
    FLATPTR fpBaseOverlay;
    LONG    lBusWidth;
    LONG    lMCLKPeriod;
    LONG    lRandom;
    LONG    lPageMiss;
    LONG    OvlyCnt;
    LONG    PlanarCnt;
    DWORD   dwVsyncLine;
    FLATPTR fpVidMem_gbls;      // ptr to video memory, myf33
    LONG    lPitch_gbls;        //pitch of surface, myf33

    FNREGINITVIDEO*     pfnRegInitVideo;
    FNREGMOVEVIDEO*        pfnRegMoveVideo;
    FNBANDWIDTHEQ*        pfnIsSufficientBandwidth;
    FNDISABLEOVERLAY*   pfnDisableOverlay;
    FNCLEARALTFIFO*     pfnClearAltFIFOThreshold;
#endif // OVERLAY

#endif

#if 1 // Font cache.
    ////////// Font cache stuff:
    ULONG       ulFontCacheID;          // Font cache ID.
    FONTCACHE*  pfcChain;               // Pointer to chain of FONTCACHE
                                        //   structures.
#endif

#if 1 // D5480
    FNGLYPHOUT* pfnGlyphOut;
    FNGLYPHOUTCLIP* pfnGlyphOutClip;
    // Command List Stuff:
    ULONG_PTR*      pCommandList;
    ULONG_PTR*      pCLFirst;
    ULONG_PTR*      pCLSecond;
#endif // endif D5480

    FnREAD_PORT_UCHAR   pfnREAD_PORT_UCHAR;
    FnREAD_PORT_USHORT  pfnREAD_PORT_USHORT;
    FnREAD_PORT_ULONG   pfnREAD_PORT_ULONG;
    FnWRITE_PORT_UCHAR  pfnWRITE_PORT_UCHAR;
    FnWRITE_PORT_USHORT pfnWRITE_PORT_USHORT;
    FnWRITE_PORT_ULONG  pfnWRITE_PORT_ULONG;

    ULONG       ulLastField;            // This must remain the last field in
                                        // this structure.

    // Added to support GetAvailDriverMemory callback in DDraw
    ULONG ulTotalAvailVideoMemory;

} PDEV, *PPDEV;


/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
VOID vImageTransfer(PDEV*, BYTE*, LONG, LONG, LONG);

#ifdef PANNING_SCROLL
VOID CirrusLaptopViewPoint(PDEV*, PVIDEO_MODE_INFORMATION);   //myf17
#endif

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*);

extern BYTE gajHwMixFromMix[];
extern BYTE gaRop3FromMix[];
extern BYTE gajHwMixFromRop2[];
extern ULONG gaulLeftClipMask[];
extern ULONG gaulRightClipMask[];
#if 1 // D5480
extern DWORD gajHwPackedMixFromRop2[];
extern DWORD gajHwPackedMixFromMix[];
#endif // endif D5480

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// PELS_TO_BYTES - converts a pel count to a byte count
// BYTES_TO_PELS - converts a byte count to a pel count

#define PELS_TO_BYTES(cPels) ((cPels) * ppdev->cBpp)
#define BYTES_TO_PELS(cPels) ((cPels) / ppdev->cBpp)

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

/////////////////////////////////////////////////////////////////////////
// SWAP - Swaps the value of two variables, using a temporary variable

#define SWAP32(a, b)            \
{                               \
    register ULONG tmp;         \
    tmp = (ULONG)(a);           \
    (ULONG)(a) = (ULONG)(b);    \
    (ULONG)(b) = tmp;           \
}

#define SWAP(a, b, tmp) { (tmp) = (a); (a) = (b); (b) = (tmp); }

/////////////////////////////////////////////////////////////////////////
// BSWAP - "byte swap" reverses the bytes in a DWORD

#ifdef  _X86_

    #define BSWAP(ul)\
    {\
        _asm    mov     eax,ul\
        _asm    bswap   eax\
        _asm    mov     ul,eax\
    }

#else

    #define BSWAP(ul)\
    {\
        ul = ((ul & 0xff000000) >> 24) |\
             ((ul & 0x00ff0000) >> 8)  |\
             ((ul & 0x0000ff00) << 8)  |\
             ((ul & 0x000000ff) << 24);\
    }

#endif



// These Dbg prototypes are thunks for debugging:

ULONG   DbgGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  DbgEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    DbgCompletePDEV(DHPDEV, HDEV);
HSURF   DbgEnableSurface(DHPDEV);
BOOL    DbgStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    DbgFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    DbgBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    DbgDisablePDEV(DHPDEV);
VOID    DbgDisableSurface(DHPDEV);
#if (NT_VERSION < 0x0400)       //myf19
VOID    DbgAssertMode(DHPDEV, BOOL);
#else
BOOL    DbgAssertMode(DHPDEV, BOOL);
#endif          //myf19
VOID    DbgMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   DbgSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   DbgDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    DbgSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    DbgCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    DbgTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    DbgDestroyFont(FONTOBJ*);
BOOL    DbgPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    DbgRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP DbgCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    DbgDeleteDeviceBitmap(DHSURF);
BOOL    DbgStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);
#if 1 // Font cache
VOID    DbgDestroyFont(FONTOBJ* pfo);
#endif
#if LINETO
BOOL    DbgLineTo(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, LONG, LONG, LONG, LONG,
                  RECTL*, MIX);
#endif
#if DIRECTDRAW
BOOL    DbgGetDirectDrawInfo(DHPDEV, DD_HALINFO*, DWORD*, VIDEOMEMORY*, DWORD*,
                                                         DWORD*);
BOOL    DbgEnableDirectDraw(DHPDEV, DD_CALLBACKS*, DD_SURFACECALLBACKS*,
                            DD_PALETTECALLBACKS*);
VOID    DbgDisableDirectDraw(DHPDEV);
#endif

//
// chu01 : GAMMACORRECT
//
typedef struct _PGAMMA_VALUE
{

    UCHAR value[4] ;

} GAMMA_VALUE, *PGAMMA_VALUE, *PCONTRAST_VALUE ;

//myf32 begin
//#define  CL754x       0x1000
//#define  CL755x       0x2000
#define  CL7541       0x1000
#define  CL7542       0x2000
#define  CL7543       0x4000
#define  CL7548       0x8000
#define  CL754x       (CL7541 | CL7542 | CL7543 | CL7548)
#define  CL7555       0x10000
#define  CL7556       0x20000
#define  CL755x       (CL7555 | CL7556)
#define  CL756x       0x40000
// crus
#define  CL6245       0x80000
//myf32 end

#define  CL7542_ID    0x2C
#define  CL7541_ID    0x34
#define  CL7543_ID    0x30
#define  CL7548_ID    0x38
#define  CL7555_ID    0x40
#define  CL7556_ID    0x4C

//#define  CHIP754X
//#define  CHIP755X
//myf32 end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\gamma.c ===
/*++

Copyright (c) 1996-1997  Cirrus Logic, Inc.
Copyright (c) 1996-1997  Microsoft Corporation.

Module Name:

    G    A    M    M    A  .  C

Abstract:

    While the DAC may generate a linear relationship between the value of a
    color and the visual appearence of that color, the human eyes do not work
    in the same manner. The process done by this module manipulates the
    meaning of colors to get the visual linearity effect.

    We cannot use float or double data type in the display driver; therefore,
    we need implement our MATH functions. Also, the driver binary size will
    increase around 30KB if we use the math functions.

    Registry subdirectory : System\CurrentControlSet\Services\cirrus\Device0
    Keys                  : "G Gamma", and "G Contrast"

Environment:

    Kernel mode only

Notes:
*
*
*   chu01  12-16-96  Enable color correction, Start coding
*   myf29  02-12-97  Support Gamma correction for 755x
*
*
--*/


//---------------------------------------------------------------------------
// HEADER FILES
//---------------------------------------------------------------------------

#include "precomp.h"


#ifdef GAMMACORRECT

BOOL bEnableGammaCorrect(PPDEV ppdev);

//---------------------------------------------------------------------------
// MACRO DEFINITION
//---------------------------------------------------------------------------

#define FIXEDPREC       10
#define FIXEDFUDGE      (0x01L << FIXEDPREC)
#define FIXEDIMASK      (0xFFFFFFFFL << FIXEDPREC)
#define FIXEDFMASK      (~FIXEDIMASK)
#define FixedSign(x)    (((x) < 0x00000000) ? -1L : 1L)
#define FixedAbs(x)     (((x) < 0x00000000) ? -(x) : (x))
#define FixedMakeInt(x) (((long) x)*FIXEDFUDGE)
#define FixedTrunc(x)   ((long) ((x) & FIXEDIMASK))
#define FixedRound(x)   (FixedTrunc((x) + (FIXEDFUDGE >> 1)))
#define FixedInt(x)     ((x) /FIXEDFUDGE)
#define FixedFract(x)   ((((FixedAbs(x)) - FixedTrunc(FixedAbs(x)))*1000)/FIXEDFUDGE)
#define FixedAdd(x,y)   ((x) + (y))
#define FixedSub(x,y)   ((x) - (y))
#define FixedMul(x,y)   ((((x) * (y))+(FIXEDFUDGE >> 1))/FIXEDFUDGE)
#define FixedDiv(x,y)   (long) ((y==0) ? 0x7FFFFFFFL : ((x)*FIXEDFUDGE) / (y))

//---------------------------------------------------------------------------
// VARABLES
//---------------------------------------------------------------------------

PGAMMA_VALUE    GammaFactor    ; // gamma facter for All, Blue, Green, Red
PCONTRAST_VALUE ContrastFactor ; // contrast facter for All, Blue, Green, Red


//------------------------------------------------------------------------------
//
// Function: UCHAR GammaCorrect(UCHAR gamma, UCHAR v)
// {
//     UCHAR dv;
//     dv = (UCHAR)(256 * pow(v/256.0, pow(10, (gamma - 128)/128.0)));
//     return dv;
// }
//
// Input:
//     gamma: new gamma factor from 0 to 255
//     color: color value for Red, Green, or Blue
//
// Output:
//     dv: new color value after gamma correction
//
//------------------------------------------------------------------------------
UCHAR GammaCorrect(UCHAR gamma, UCHAR v)
{
    UCHAR dv ;
    long Color, GammaF, Result ;

    DISPDBG((4, "GammaCorrect")) ;

    if ((gamma == 128) ||
        (gamma == 127) ||
        (gamma == 126))
        return v ;

    Color = FixedDiv(v, 256) ;                             // old color value

    if (Color == 0L)      // in case then we don't need go though calculation
        return 0 ;

    GammaF      = FixedDiv(gamma-128, 128) ;              // new gamma factor
    Result      = Power(Color, Power(FixedMake(10, 0, 1000), GammaF)) ;
    Result      = (long)FixedInt(FixedMul(FixedMake(256, 0, 1000), Result)) ;
    dv          = (UCHAR)Result ;

    return dv ;

} // GammaCorrect


//------------------------------------------------------------------------------
// Function:long Power(long Base, long Exp)
//
// Input:
//     Base: base number of power function
//     Exp: exponential number
//
// Output:
//     20 bits format of integer and fraction number
//      0 = not use(or sign),
//      i = integer portion,
//      f = fraction portion
//      0 + i + f = 32 bits
//      format = 000000000000iiiiiiiiiiiiiiiiiiiffffffffffffffffffff
//
//------------------------------------------------------------------------------
long Power(long Base, long Exp)
{
    int i, iSignExp;
    long    lResult, lResultFract, lRoot;

    iSignExp = FixedSign(Exp);        // get sing bit
    Exp = FixedAbs(Exp);                // convert to positive

    // calculate integer expression
    lResult = FixedMakeInt(1);
    for(i = 0; i < FixedInt(Exp); i++)
        lResult = FixedMul(lResult,Base);

    // calculate fraction expression and add to integer result
    if(FixedFract(Exp) != 0) {
        lResultFract = FixedMakeInt(1);
        lRoot = FixedAbs(Base);
        for(i = 0x0; i < FIXEDPREC; i++) {
            lRoot = FixedSqrt(lRoot);
            if(((0x01L << (FIXEDPREC - 1 - i)) & Exp) != 0) {
                lResultFract = FixedMul(lResultFract, lRoot);
            }
        }
        lResult = FixedMul(lResult, lResultFract);
    }
    if(iSignExp == -1)
        lResult = FixedDiv(FixedMakeInt(1), lResult);
    return(lResult);
} // Power


//------------------------------------------------------------------------------
//
// Function:long FixedMake(long x, long y, long z)
//
// Input:
//     x: integer portion of the number
//     y: fraction portion of the number
//     z: precison after decimal
//
// Output:
//     20 bits format of integer and fraction number
//      0 = not use(or sign),
//      i = integer portion,
//      f = fraction portion
//      0 + i + f = 32 bits
//      format = 000000000000iiiiiiiiiiiiiiiiiiiffffffffffffffffffff
//
//------------------------------------------------------------------------------
long FixedMake(long x, long y, long z)
{

    DISPDBG((4, "FixedMake")) ;
    if (x == 0)
        return((y * FIXEDFUDGE) / z);
    else
        return(FixedSign(x) * ((FixedAbs(x)*FIXEDFUDGE) | (((y * FIXEDFUDGE)/ z) & FIXEDFMASK)));
} // FixedMake

//------------------------------------------------------------------------------
//
// Function:long FixedSqrt(long Root)
//
// Input:
//     Root: number to square
//
// Output:
//     20 bits format of integer and fraction number
//      0 = not use(or sign),
//      i = integer portion,
//      f = fraction portion
//      0 + i + f = 32 bits
//      format = 000000000000iiiiiiiiiiiiiiiiiiiffffffffffffffffffff
//
//------------------------------------------------------------------------------
long FixedSqrt(long Root)
{
    long    lApprox;
    long    lStart;
    long    lEnd;

    if(FixedSign(Root) != 1)
        return(0);

    lStart = (long) FixedMakeInt(1);
    lEnd   = Root;
    if(Root < lStart) {
        lEnd   = lStart;
        lStart = Root;
    }

    lApprox = (lStart + lEnd) / 2;
    while(lStart != lEnd) {
        lApprox = (lStart + lEnd) / 2;
        if ((lApprox == lStart) || (lApprox == lEnd)) {
            lStart = lEnd = lApprox;
        }
        else {
            if(FixedMul(lApprox, lApprox) < Root) {
                lStart = lApprox;
            }
            else {
                lEnd = lApprox;
            }
        }
    }    // end of while
    return(lApprox);
}


//
//  C  O  N  T  R  A  S  T    F  A  C  T  O  R
//

//------------------------------------------------------------------------------
//
// Function:long CalcContrast(UCHAR contrast, UCHAR v)
//
// Input:
//
// Output:
//
//------------------------------------------------------------------------------
UCHAR CalcContrast(UCHAR contrast, UCHAR v)
{
    int dv;
    dv = ((((int)v - 128) * (int)contrast) / 128) + 128 ;
    if(dv < 0) dv = 0;
    if(dv > 255) dv = 255;
    return (unsigned char)dv;
} // CalcContrast


//
//  G  A  M  M  A    F  A  C  T  O  R
//

//---------------------------------------------------------------------------
//
// Routine Description:
//
// Arguments:
//
//    Palette: Pointer to palette array
//    NumberOfEntryes: Number of palette entries need modified
//
// Return Value:
//
//    None
//
//---------------------------------------------------------------------------

VOID CalculateGamma(
    PDEV*    ppdev,
    PVIDEO_CLUT pScreenClut,
    long NumberOfEntries )
{

    UCHAR         GammaRed, GammaGreen, GammaBlue, Red, Green, Blue ;
    UCHAR         Contrast, ContrastRed, ContrastGreen, ContrastBlue ;
    UCHAR         Brightness ;
    int           PalSegment, PalOffset, i ;
    int           iGamma ;

    PALETTEENTRY* ppalSrc  ;
    PALETTEENTRY* ppalDest ;
    PALETTEENTRY* ppalEnd  ;

    DISPDBG((2, "CalculateGamma")) ;

    Brightness = (LONG) GammaFactor >> 24 ;
    GammaBlue  = (LONG) GammaFactor >> 16 ;
    GammaGreen = (LONG) GammaFactor >> 8  ;
    GammaRed   = (LONG) GammaFactor >> 0  ;

    iGamma     = (int)(Brightness - 128) + (int)GammaRed ;
    GammaRed   = (UCHAR)iGamma ;
    if (iGamma < 0)
        GammaRed = 0 ;
    if (iGamma > 255)
        GammaRed = 255 ;

    iGamma     = (int)(Brightness - 128) + (int)GammaGreen ;
    GammaGreen = (UCHAR)iGamma ;
    if (iGamma < 0)
        GammaGreen = 0 ;
    if (iGamma > 255)
        GammaGreen = 255 ;

    iGamma     = (int)(Brightness - 128) + (int)GammaBlue ;
    GammaBlue  = (UCHAR)iGamma ;
    if (iGamma < 0)
        GammaBlue = 0 ;
    if (iGamma > 255)
        GammaBlue = 255 ;

    Contrast   = (LONG) ContrastFactor >> 0 ;

    ppalDest = (PALETTEENTRY*) pScreenClut->LookupTable;
    ppalEnd  = &ppalDest[NumberOfEntries];


    i = 0 ;
    for (; ppalDest < ppalEnd; ppalDest++, i++)
    {

        Red   = ppalDest->peRed   ;
        Green = ppalDest->peGreen ;
        Blue  = ppalDest->peBlue  ;

        Red   = GammaCorrect(GammaRed, Red)     ;
        Green = GammaCorrect(GammaGreen, Green) ;
        Blue  = GammaCorrect(GammaBlue, Blue)   ;

        Red   = CalcContrast(Contrast, Red)   ;
        Green = CalcContrast(Contrast, Green) ;
        Blue  = CalcContrast(Contrast, Blue)  ;

        if (ppdev->iBitmapFormat == BMF_8BPP)
        {
            ppalDest->peRed    = Red   >> 2 ;
            ppalDest->peGreen  = Green >> 2 ;
            ppalDest->peBlue   = Blue  >> 2 ;
        }
        else if ((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_24BPP))
        {
            ppalDest->peRed    = Red   ;
            ppalDest->peGreen  = Green ;
            ppalDest->peBlue   = Blue  ;
        }

    }
    return ;

} // CalulateGamma


/******************************************************************************\
*
* Function:     bEnableGammaCorrect
*
* Enable GammaTable. Called from DrvEnableSurface.
*
* Parameters:   ppdev        Pointer to phsyical device.
*
* Returns:      TRUE : successful; FALSE: fail
*
\******************************************************************************/
BOOL bEnableGammaCorrect(PDEV* ppdev)
{

    BYTE  srIndex, srData ;
    BYTE* pjPorts = ppdev->pjPorts ;
    int   i ;

    DISPDBG((4, "bEnableGammaCorrect")) ;

    //
    // Enable Gamma correction. If needed; Otherwise, turn it off.
    //
    srIndex = CP_IN_BYTE(pjPorts, SR_INDEX) ;   // i 3c4 srIndex
    CP_OUT_BYTE(pjPorts, SR_INDEX, 0x12) ;      // o 3c4 12
    srData = CP_IN_BYTE(pjPorts, SR_DATA) ;     // i 3c5 srData

    if (ppdev->flCaps & CAPS_GAMMA_CORRECT)
    {
        if ((ppdev->iBitmapFormat == BMF_16BPP) ||
            (ppdev->iBitmapFormat == BMF_24BPP))
            srData |= 0x40 ;                        // 3c5.12.D6 = 1
        else
            srData &= 0xBF ;                        // 3c5.12.D6 = 0
    }
    else
        srData &= 0xBF ;                            // 3c5.12.D6 = 0

    CP_OUT_BYTE(pjPorts, SR_DATA, srData) ;     // o 3c5 srData
    CP_OUT_BYTE(pjPorts, SR_INDEX, srIndex) ;   // o 3c4 srIndex

    if ( srData & 0x40 )
    {
        return TRUE ;
    }
    else
    {
        return FALSE ;
    }

} // bEnableGammaCorrect


//myf29 : for 755x Gamma Correct support begin
/******************************************************************************\
*
* Function:     bEnableGamma755x
*
* Enable Graphic GammaTable. Called from DrvAssertMode/DrvEscape
*
* Parameters:   ppdev        Pointer to phsyical device.
*
* Returns:      TRUE : successful; FALSE: fail
*
\******************************************************************************/
BOOL bEnableGamma755x(PDEV* ppdev)
{

    BYTE  crIndex, crData ;
    BYTE* pjPorts = ppdev->pjPorts ;
    BOOL  status;

    DISPDBG((4, "bEnableGamma755x")) ;

    //
    // Enable Gamma correction. If needed; Otherwise, turn it off.
    //
    crIndex = CP_IN_BYTE(pjPorts, CRTC_INDEX) ;   // i 3d4 crIndex

    status = FALSE;

    if (ppdev->flCaps & CAPS_GAMMA_CORRECT)
    {
        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x8E);      // CR8E[2]=0
        crData = CP_IN_BYTE(pjPorts, CRTC_DATA);
        if ((ppdev->iBitmapFormat == BMF_16BPP) ||
            (ppdev->iBitmapFormat == BMF_24BPP))
        {
            crData &= 0xFB ;                        // CR8E[2] = 0
            status = TRUE;
        }
        else
            crData |= 0x04 ;                        // CR8E[2] = 1
        CP_OUT_BYTE(pjPorts, CRTC_DATA, crData) ;   // o 3d5 crData
    }

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, crIndex) ;   // o 3d4 crIndex

    return(status);

} // bEnableGamma755x

/******************************************************************************\
*
* Function:     bEnableGammaVideo755x
*
* Enable Video GammaTable. Called from DrvAssertMode/DrvEscape
*
* Parameters:   ppdev        Pointer to phsyical device.
*
* Returns:      TRUE : successful; FALSE: fail
*
\******************************************************************************/
BOOL bEnableGammaVideo755x(PDEV* ppdev)
{

    BYTE  crIndex, crData ;
    BYTE* pjPorts = ppdev->pjPorts ;
    BOOL  status;

    DISPDBG((4, "bEnableGammaVideo755x")) ;

    //
    // Enable Gamma correction. If needed; Otherwise, turn it off.
    //
    crIndex = CP_IN_BYTE(pjPorts, CRTC_INDEX) ;   // i 3d4 crIndex

    status = FALSE;

    if (ppdev->flCaps & CAPS_GAMMA_CORRECT)
    {
        CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x36);    // CR36[6]=1:enable VW LUT
        crData = CP_IN_BYTE(pjPorts, CRTC_DATA);

//      if ((ppdev->iBitmapFormat == BMF_16BPP) ||
//          (ppdev->iBitmapFormat == BMF_24BPP))
        {
            crData |= 0x40 ;                        // CR36[6] = 1
            CP_OUT_BYTE(pjPorts, CRTC_DATA, crData);
            CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x3F) ;    // CR3F[4]=1:select VW
            crData = CP_IN_BYTE(pjPorts, CRTC_DATA);
            crData |= 0x10 ;                        // CR3F[4] = 1
            CP_OUT_BYTE(pjPorts, CRTC_DATA, crData);
            status = TRUE;
        }
    }

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, crIndex) ;   // o 3d4 crIndex

    return(status);

} // bEnableGammaVideo755x

//myf29 end
#endif // GAMMACORRECT

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\escape.c ===
/******************************************************************************\
*
* $Workfile:   ESCAPE.C  $
*
* Cirrus Logic Escapes.
*
* Copyright (c) 1996-1997 Microsoft Corporation.
* Copyright (c) 1993-1997 Cirrus Logic, Inc.,
*
* $Log:   V:/CirrusLogic/CL5446/NT40/Archive/Display/ESCAPE.C_v  $
*
*    Rev 1.0   24 Jun 1996 16:21:18   frido
* Initial revision.
*
* myf17 11-04-96  Added special escape code must be use 11/5/96 later NTCTRL,
*                 and added Matterhorn LF Device ID==0x4C
* myf18 11-04-96  Fixed PDR #7075,
* myf19 11-06-96  Fixed Vinking can't work problem, because DEVICEID = 0x30
*                 is different from data book (CR27=0x2C)
* chu01 12-16-96  Enable color correction.
* pat01 :11-22-96 : Fix panning-scrolling bugs.
*                   (1) Screen messes up when switch to simulscan(with panning)
*                   (2) Software cursor problem in panning scrolling mode
* pat07 :         : Take care of disappering hardware cursor during simulscan
* myf29 02-12-97  Support 755x gamma collection.
* chu02 02-13-97  More thorough checking for color correction.
* jl01  02-24-97  Implement Feature Connector's functions.
*
\******************************************************************************/

#include "precomp.h"

//
// chu01
//
#ifdef GAMMACORRECT

#include "string.h"
#include "stdio.h"

extern PGAMMA_VALUE GammaFactor    ;
extern PGAMMA_VALUE ContrastFactor ;

#endif // GAMMACORRECT

extern

/******************************Public*Routine******************************\
* DrvEscape
*
* Processes the private ESCAPE's for this driver
*
\**************************************************************************/

ULONG DrvEscape(
SURFOBJ  *pso,
ULONG    iEsc,
ULONG    cjIn,
VOID     *pvIn,
ULONG    cjOut,
VOID     *pvOut)
{
   ULONG returnLength;
   PPDEV ppdev = (PPDEV) pso->dhpdev;
   DHPDEV dhpdev = (DHPDEV) pso->dhpdev;     //myf17

   ULONG ulMode;                             //myf17
   BYTE* pjPorts;                            //myf17
   VIDEO_MODE_INFORMATION  VideoModeInfo;    //myf17
   SHORT i;     //myf17
   unsigned char savePaletteR[256];          //pat01
   unsigned char savePaletteG[256];          //pat01
   unsigned char savePaletteB[256];          //pat01
   unsigned char R,G,B;                      //pat01
   unsigned char palettecounter;             //pat01
   LONG savex, savey  ;                      //pat07

UCHAR TempByte;                           //jl01

//
// chu01
//
#ifdef GAMMACORRECT

    PVIDEO_CLUT    pScreenClut ;
    BYTE           ajClutSpace[MAX_CLUT_SIZE] ;
    PALETTEENTRY*  ppalSrc ;
    PALETTEENTRY*  ppalDest ;
    PALETTEENTRY*  ppalEnd ;
    UCHAR          GammaRed, GammaGreen, GammaBlue, Brightness ;
    ULONG          ulReturnedDataLength ;
    UCHAR          tempB ;
    ULONG          *Signature ;
    BOOL           status;      //myf29
    UCHAR*         pvLUT;       //myf29

#endif // GAMMACORRECT

    DISPDBG((2, "---- DrvEscape"));

    DISPDBG((4, "cjIn = %d, cjOut = %d, pvIn = 0x%lx, pvOut = 0x%lx",
        cjIn, cjOut, pvIn, pvOut));


   pjPorts = ppdev->pjPorts;
   DISPDBG((2, "CIRRUS:DrvEscape: entered DrvEscape\n"));
   if (iEsc == QUERYESCSUPPORT) {
      if ( ((*(ULONG *)pvIn) == CIRRUS_PRIVATE_ESCAPE) ||
//myf17 begin
           ((*(ULONG *)pvIn) == CLESCAPE_CRT_CONNECTION) ||
           ((*(ULONG *)pvIn) == CLESCAPE_SET_VGA_OUTPUT) ||
           ((*(ULONG *)pvIn) == CLESCAPE_GET_VGA_OUTPUT) ||
           ((*(ULONG *)pvIn) == CLESCAPE_GET_PANEL_SIZE) ||
           ((*(ULONG *)pvIn) == CLESCAPE_PANEL_MODE)) {
//myf17 end
            return TRUE;
      }

//
// chu01
//
#ifdef GAMMACORRECT
      else if ((*(USHORT *)pvIn) == CLESCAPE_GET_CHIPID)
      {
            return TRUE;
      }
#endif // GAMMACORRECT

      else
      {
            return FALSE;
      }
   }
   else if (iEsc == CIRRUS_PRIVATE_ESCAPE)
   {
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_PRIVATE_BIOS_CALL,
                    pvIn,
                    cjIn,
                    pvIn,
                    cjIn,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed private BIOS call.\n"));
          return FALSE;
      }
      else {
         DISPDBG((2, "CIRRUS:DrvEscape: private BIOS call GOOD.\n"));
         // copy the result to the output buffer
         *(VIDEO_X86_BIOS_ARGUMENTS *)pvOut = *(VIDEO_X86_BIOS_ARGUMENTS *)pvIn;

//myf33 begin for TV on bug
         if (((*(ULONG *)pvIn & 0x120F) != 0x1200) &&
             ((*( ((ULONG *)pvIn)+1) & 0x01B0) == 0x01B0))
         {
//           bAssertModeHardware((PDEV *) dhpdev, TRUE);
    DWORD                   ReturnedDataLength;
    ULONG                   ulReturn;
    VIDEO_MODE_INFORMATION  VideoModeInfo;

             IOCONTROL(ppdev->hDriver,
                            IOCTL_VIDEO_QUERY_CURRENT_MODE,
                            NULL,
                            0,
                            &VideoModeInfo,
                            sizeof(VideoModeInfo),
                            &ReturnedDataLength);
#ifdef PANNING_SCROLL
             if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
                 (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) ||
                 (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))
             {
                 CirrusLaptopViewPoint(ppdev,  &VideoModeInfo);
             }
#endif
         }
//myf33 end
         return TRUE;
      }
   }
   else if (iEsc == CLESCAPE_CRT_CONNECTION)    //myf17
   {

      *(ULONG *)pvOut = (ULONG)0x1200;
      *( ((ULONG *)pvOut)+1) = 0xA1;
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_CRT_CONNECTION,
                    pvOut,
                    cjOut,
                    pvOut,
                    cjOut,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed CRT CONNECTION.\n"));
          return FALSE;
      }
      else {
         DISPDBG((2, "CIRRUS:DrvEscape: CRT CONNECTION GOOD.\n"));
         return TRUE;
      }
   }
   else if (iEsc == CLESCAPE_GET_VGA_OUTPUT)    //myf17
   {

      *(ULONG *)pvOut = (ULONG)0x1200;
      *( ((ULONG *)pvOut)+1) = 0x9A;
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_GET_VGA_OUTPUT,
                    pvOut,
                    cjOut,
                    pvOut,
                    cjOut,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed GET VGA OUTPUT.\n"));
          return FALSE;
      }
      else {
         DISPDBG((2, "CIRRUS:DrvEscape: GET VGA OUTPUT GOOD.\n"));
         return TRUE;
      }
   }
   else if (iEsc == CLESCAPE_GET_PANEL_SIZE)    //myf17
   {

      *(ULONG *)pvOut = (ULONG)0x1280;
      *( ((ULONG *)pvOut)+1) = 0x9C;
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_CRT_CONNECTION,
                    pvOut,
                    cjOut,
                    pvOut,
                    cjOut,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed CRT CONNECTION.\n"));
          return FALSE;
      }
      else {
         DISPDBG((2, "CIRRUS:DrvEscape: CRT CONNECTION GOOD.\n"));
         return TRUE;
      }
   }
   else if (iEsc == CLESCAPE_PANEL_MODE)        //myf17
   {

      *(ULONG *)pvOut = *(ULONG *)pvIn;
      *(ULONG *)pvOut |= (ULONG)0x1200;
      *( ((ULONG *)pvOut)+1) = 0xA0;
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_PANEL_MODE,
                    pvOut,
                    cjOut,
                    pvOut,
                    cjOut,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed PANEL MODE.\n"));
          return FALSE;
      }
      else {
         DISPDBG((2, "CIRRUS:DrvEscape: PANEL MODE GOOD.\n"));
         return TRUE;
      }
   }
   else if (iEsc == CLESCAPE_SET_VGA_OUTPUT)
   {
//pat01, begin
#ifdef PANNING_SCROLL
   #if (_WIN32_WINNT < 0x0400)  // #pat1

     if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
         (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
         (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))
     {
          palettecounter = 255;
          // Save DAC values
          while (palettecounter --) {
             CP_OUT_BYTE(ppdev->pjPorts, DAC_PEL_READ_ADDR, palettecounter);
             savePaletteR[palettecounter] =  CP_IN_BYTE(ppdev->pjPorts, DAC_PEL_DATA);
             savePaletteG[palettecounter] =  CP_IN_BYTE(ppdev->pjPorts, DAC_PEL_DATA);
             savePaletteB[palettecounter] =  CP_IN_BYTE(ppdev->pjPorts, DAC_PEL_DATA);
          }// while
          // preserver icons + previous bitmaps
          bAssertModeOffscreenHeap(ppdev,FALSE);
     }

  #endif
#endif
//pat01, end

      *(ULONG *)pvOut = *(ULONG *)pvIn;
      *(ULONG *)pvOut |= (ULONG)0x1200;
      *( ((ULONG *)pvOut)+1) = 0x92;
      if (!IOCONTROL(ppdev->hDriver,
                    IOCTL_CIRRUS_SET_VGA_OUTPUT,
                    pvOut,
                    cjOut,
                    pvOut,
                    cjOut,
                    &returnLength))
      {
          DISPDBG((2, "CIRRUS:DrvEscape: failed SET VGA OUTPUT.\n"));
          return FALSE;
      }
      else {
          DISPDBG((2, "CIRRUS:DrvEscape: SET VGA OUTPUT GOOD.\n"));

//#pat01 <start>

#if (_WIN32_WINNT < 0x0400)   // #pat01
    #ifdef PANNING_SCROLL
        // check cursor status
     if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
         (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
         (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))
     {
         if (ppdev->flCaps & CAPS_SW_POINTER) {
              bAssertModeHardware(ppdev, TRUE);
              vAssertModeText(ppdev, TRUE);
              vAssertModeBrushCache(ppdev,TRUE);
              // bEnablePointer(ppdev); // pat07
              ppdev->flCaps |= CAPS_SW_POINTER; // reset to HW. why???
         } else {
              // #pat07  start
              CP_OUT_BYTE(pjPorts, SR_INDEX,0x10);
              savex = CP_IN_BYTE(pjPorts, SR_DATA);
              CP_OUT_BYTE(pjPorts, SR_INDEX,0x11);
              savey = CP_IN_BYTE(pjPorts, SR_DATA);
              //pat07 end
              bAssertModeHardware(ppdev, TRUE);
//pat07       vAssertModePointer(ppdev,TRUE);
              vAssertModeText(ppdev, TRUE);
              vAssertModeBrushCache(ppdev,TRUE);
              bEnablePointer(ppdev);
              //pat07 begin
              CP_OUT_BYTE(pjPorts, SR_INDEX,0x10);
              CP_OUT_BYTE(pjPorts, SR_DATA, savex);
              CP_OUT_BYTE(pjPorts, SR_INDEX,0x11);
              CP_OUT_BYTE(pjPorts, SR_DATA, savey);
              CP_PTR_ENABLE(ppdev, pjPorts);
              // #pat07 end
         }


         palettecounter = 255;

         // Restore DAC values
         while (palettecounter-- ) {

           CP_OUT_BYTE(ppdev->pjPorts, DAC_PEL_WRITE_ADDR, palettecounter);
           CP_OUT_BYTE(ppdev->pjPorts, DAC_PEL_DATA, savePaletteR[palettecounter]);
           CP_OUT_BYTE(ppdev->pjPorts, DAC_PEL_DATA, savePaletteG[palettecounter]);
           CP_OUT_BYTE(ppdev->pjPorts, DAC_PEL_DATA, savePaletteB[palettecounter]);

          }// while
     }

  #endif
#else           //NT 4.0 code
//ppp begin
          palettecounter = 255;
          while (palettecounter--)
          {
              CP_OUT_BYTE(ppdev->pjPorts,DAC_PEL_READ_ADDR,palettecounter);
              savePaletteR[palettecounter] =
                  CP_IN_BYTE(ppdev->pjPorts,DAC_PEL_DATA);
              savePaletteG[palettecounter] =
                  CP_IN_BYTE(ppdev->pjPorts,DAC_PEL_DATA);
              savePaletteB[palettecounter] =
                  CP_IN_BYTE(ppdev->pjPorts,DAC_PEL_DATA);
          }

          bAssertModeHardware((PDEV *) dhpdev, TRUE);

          palettecounter = 255;
          while (palettecounter--)
          {
              CP_OUT_BYTE(ppdev->pjPorts,DAC_PEL_WRITE_ADDR,palettecounter);
              CP_OUT_BYTE(ppdev->pjPorts,DAC_PEL_DATA,
                          savePaletteR[palettecounter]);
              CP_OUT_BYTE(ppdev->pjPorts,DAC_PEL_DATA,
                          savePaletteG[palettecounter]);
              CP_OUT_BYTE(ppdev->pjPorts,DAC_PEL_DATA,
                          savePaletteB[palettecounter]);
          }
          bEnablePointer(ppdev);

//ppp end
#endif
//pat01, end
          return TRUE;

      }
   }

//
// chu01
//
#ifdef GAMMACORRECT
    else if (iEsc == CLESCAPE_GAMMA_CORRECT)                         // 9000
    {
        if (!(ppdev->flCaps & CAPS_GAMMA_CORRECT))
            return ;

        Signature      = *((ULONG *)pvIn+0) ;
        GammaFactor    = *((ULONG *)pvIn+1) ;
        ContrastFactor = *((ULONG *)pvIn+2) ;

        //
        // Is signature "CRUS" ?
        //
        if (Signature != 0x53555243)
            return TRUE ;

        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        ppalSrc  = ppdev->pCurrentPalette;
        ppalDest = (PALETTEENTRY*) pScreenClut->LookupTable;
        ppalEnd  = &ppalDest[256];

        for (; ppalDest < ppalEnd; ppalSrc++, ppalDest++)
        {
           ppalDest->peRed   = ppalSrc->peRed   ;
           ppalDest->peGreen = ppalSrc->peGreen ;
           ppalDest->peBlue  = ppalSrc->peBlue  ;
           ppalDest->peFlags = 0 ;
        }

//myf29 begin
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27) ;
        tempB = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        if (tempB == 0xBC)
            status = bEnableGammaCorrect(ppdev) ;
        else if ((tempB == 0x40) || (tempB == 0x4C))
            status = bEnableGamma755x(ppdev);
//myf29 end

        CalculateGamma(ppdev, pScreenClut, 256) ;

        // Set palette registers:

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_SET_COLOR_REGISTERS,
                       pScreenClut,
                       MAX_CLUT_SIZE,
                       NULL,
                       0,
                       &ulReturnedDataLength))
        {
            DISPDBG((2, "Failed bEnablePalette"));
            return FALSE ;
        }
        return TRUE ;
    }
    else if (iEsc == CLESCAPE_GET_CHIPID)                            // 9001
    {

        //
        // Return chip ID, graphics and video info
        //
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27) ;
        tempB = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        if (tempB == 0xBC)                                  //myf29
            *(DWORD *)pvOut = ((DWORD)tempB) | 0x00000100 ; //for Graphic LUT
        else if ((tempB == 0x40) || (tempB == 0x4C))        //myf29
            *(DWORD *)pvOut = ((DWORD)tempB) | 0x00010100;  //myf29  Video LUT
        else                                                //myf29
            *(DWORD *)pvOut = ((DWORD)tempB);               //myf29 non gamma
        return TRUE ;
    }

//myf29 :02-12-97 add 7555 gamma correction begin
    else if (iEsc == CLESCAPE_WRITE_VIDEOLUT)                // 9010
    {
        if (!(ppdev->flCaps & CAPS_GAMMA_CORRECT))
            return ;

        pvLUT  = (ULONG *)pvIn+0;

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        ppalDest = (PALETTEENTRY*) pScreenClut->LookupTable;
        ppalEnd  = &ppalDest[256];

        for (; ppalDest < ppalEnd; ppalDest++)
        {
           ppalDest->peRed   = *pvLUT++;
           ppalDest->peGreen = *pvLUT++;
           ppalDest->peBlue  = *pvLUT++;
           ppalDest->peFlags = 0 ;
        }

        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27) ;
        tempB = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        if ((tempB == 0x40) || (tempB == 0x4C))
            status = bEnableGammaVideo755x(ppdev);
//      if (!status)
//      {
//          DISPDBG((2, "Failed bEnableGAmmaVodeoCorrect"));
//          return FALSE ;
//      }

        // Set palette registers:

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_SET_COLOR_REGISTERS,
                       pScreenClut,
                       MAX_CLUT_SIZE,
                       NULL,
                       0,
                       &ulReturnedDataLength))
        {
            //restore register

            CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3F) ;
            tempB = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
            CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (tempB & 0xEF)) ;

            DISPDBG((2, "Failed bEnablePalette"));
            return FALSE ;
        }

        //restore register

        CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x3F) ;
        tempB = CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) ;
        CP_OUT_BYTE(ppdev->pjPorts, CRTC_DATA, (tempB & 0xEF)) ;

        return TRUE ;
    }
//myf29 :02-12-97 add 7555 gamma correction end
#endif // GAMMACORRECT

#if 1  // jl01 Implement Feature Connector's functions.
    else if (iEsc == CLESCAPE_FC_Cap)                                 // 9002
    {
        if ((ppdev->ulChipID == 0xAC)	|| (ppdev->ulChipID == 0xB8))
            return TRUE;
        return FALSE;
    }
    else if (iEsc == CLESCAPE_FC_Status)                              // 9003
    {
        if (ppdev->ulChipID == 0xAC)                                  // 5436
        {
            CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x08);
            TempByte = CP_IN_BYTE(ppdev->pjPorts, SR_DATA);
            if ((TempByte & 0x20) == 0) 
                return TRUE;
            else 
                return FALSE;
        }
        else if (ppdev->ulChipID == 0xB8)                             // 5446
        {
            CP_OUT_BYTE(ppdev->pjPorts, INDEX_REG, 0x17);
            TempByte = CP_IN_BYTE(ppdev->pjPorts, DATA_REG);
            if ((TempByte & 0x08) == 0) 
                return TRUE;
            else
                return FALSE;
         }
         else    return FALSE;
    }
    else if (iEsc == CLESCAPE_FC_SetOrReset)                          // 9004
    {
        if (ppdev->ulChipID == 0xAC)                                  // 5436
        {
            CP_OUT_BYTE(ppdev->pjPorts, SR_INDEX, 0x08);
            TempByte = CP_IN_BYTE(ppdev->pjPorts, SR_DATA);
            if (*(UCHAR *)pvIn)
                TempByte &= ~0x20;
            else
                TempByte |= 0x20;
            CP_OUT_BYTE(ppdev->pjPorts, SR_DATA, TempByte);
        }
        else if (ppdev->ulChipID == 0xB8)                             // 5446
        {
            CP_OUT_BYTE(ppdev->pjPorts, INDEX_REG, 0x17);
            TempByte = CP_IN_BYTE(ppdev->pjPorts, DATA_REG);
            if (*(UCHAR *)pvIn)
                TempByte &= ~0x08;
            else
                TempByte |= 0x08;
            CP_OUT_BYTE(ppdev->pjPorts, DATA_REG, TempByte);
        }
        else return TRUE;
    }
#endif  // jl01 Implement Feature Connector's functions.

    else if (iEsc == CLESCAPE_IsItCLChips)                            // 9005
    {
        return TRUE;
    }
    else
        return 0xffffffff;

    /* we should never be here */
    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\lines.c ===
/*************************************************************************\
* Module Name: Lines.c
*
* Contains the code for drawing short fractional endpoint lines and
* longer lines with strips.  There is also a separate x86 Asm version
* of this code.
*
* Copyright (c) 1990-1995 Microsoft Corporation
* Copyright (c) 1992      Digital Equipment Corporation
\**************************************************************************/

#include "precomp.h"

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};


/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing NT Lines Right
* --------------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Styled lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code (or if your display is a frame
*    buffer, fall back to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the
*    'bHardwareLine' routine for an example.
*
\**************************************************************************/

BOOL bLines(
PDEV*      ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart)     // Flags for each line, which is a combination of:
                        //      FL_SIMPLE_CLIP
                        //      FL_COMPLEX_CLIP
                        //      FL_STYLED
                        //      FL_LAST_PEL_INCLUSIVE
                        //        - Should be set only for all integer lines,
                        //          and can't be used with FL_COMPLEX_CLIP
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
            ULONG M1 = FXFRAC(M0 + dM);

            x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

        strip.ptlStart = ptlStart;

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\misc.c ===
/******************************Module*Header*******************************\
* Module Name: misc.c
*
* Miscellaneous common routines.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Table********************************\
* BYTE gaulHwMixFromRop2[]
*
* Table to convert from a Source and Destination Rop2 to the hardware's
* mix.
\**************************************************************************/

BYTE gajHwMixFromRop2[] = {
    HW_0,                           // 00 -- 0      BLACKNESS
    HW_DPon,                        // 11 -- DSon   NOTSRCERASE
    HW_DPna,                        // 22 -- DSna
    HW_Pn,                          // 33 -- Sn     NOSRCCOPY
    HW_PDna,                        // 44 -- SDna   SRCERASE
    HW_Dn,                          // 55 -- Dn     DSTINVERT
    HW_DPx,                         // 66 -- DSx    SRCINVERT
    HW_DPan,                        // 77 -- DSan
    HW_DPa,                         // 88 -- DSa    SRCAND
    HW_DPxn,                        // 99 -- DSxn
    HW_D,                           // AA -- D
    HW_DPno,                        // BB -- DSno   MERGEPAINT
    HW_P,                           // CC -- S      SRCCOPY
    HW_PDno,                        // DD -- SDno
    HW_DPo,                         // EE -- DSo    SRCPAINT
    HW_1                            // FF -- 1      WHITENESS
};


/******************************Public*Table********************************\
* BYTE gajHwMixFromMix[]
*
* Table to convert from a GDI mix value to the hardware's mix.
*
* Ordered so that the mix may be calculated from gajHwMixFromMix[mix & 0xf]
* or gajHwMixFromMix[mix & 0xff].
\**************************************************************************/

BYTE gajHwMixFromMix[] = {
    HW_1,                           // 0  -- 1
    HW_0,                           // 1  -- 0
    HW_DPon,                        // 2  -- DPon
    HW_DPna,                        // 3  -- DPna
    HW_Pn,                          // 4  -- Pn
    HW_PDna,                        // 5  -- PDna
    HW_Dn,                          // 6  -- Dn
    HW_DPx,                         // 7  -- DPx
    HW_DPan,                        // 8  -- DPan
    HW_DPa,                         // 9  -- DPa
    HW_DPxn,                        // 10 -- DPxn
    HW_D,                           // 11 -- D
    HW_DPno,                        // 12 -- DPno
    HW_P,                           // 13 -- P
    HW_PDno,                        // 14 -- PDno
    HW_DPo,                         // 15 -- DPo
    HW_1                            // 16 -- 1
};

#if 1 // D5480
/******************************Public*Table********************************\
* DWORD gaulHwPackedMixFromRop2_Packed[]
*
* Table to convert from a Source and Destination Rop2 to the hardware's
* mix in DWORD packed mode.
\**************************************************************************/

DWORD gajHwPackedMixFromRop2[] = {
    HW_PACKED_0,                           // 00 -- 0      BLACKNESS
    HW_PACKED_DPon,                        // 11 -- DSon   NOTSRCERASE
    HW_PACKED_DPna,                        // 22 -- DSna
    HW_PACKED_Pn,                          // 33 -- Sn     NOSRCCOPY
    HW_PACKED_PDna,                        // 44 -- SDna   SRCERASE
    HW_PACKED_Dn,                          // 55 -- Dn     DSTINVERT
    HW_PACKED_DPx,                         // 66 -- DSx    SRCINVERT
    HW_PACKED_DPan,                        // 77 -- DSan
    HW_PACKED_DPa,                         // 88 -- DSa    SRCAND
    HW_PACKED_DPxn,                        // 99 -- DSxn
    HW_PACKED_D,                           // AA -- D
    HW_PACKED_DPno,                        // BB -- DSno   MERGEPAINT
    HW_PACKED_P,                           // CC -- S      SRCCOPY
    HW_PACKED_PDno,                        // DD -- SDno
    HW_PACKED_DPo,                         // EE -- DSo    SRCPAINT
    HW_PACKED_1                            // FF -- 1      WHITENESS
};

/******************************Public*Table********************************\
* DWORD gajHwPackedMixFromMix[]
*
* Table to convert from a GDI mix value to the hardware's mix.
*
* Ordered so that the mix may be calculated from 
* gajHwPackedMixFromMix[mix & 0xf] or gajHwPackedMixFromMix[mix & 0xff].
\**************************************************************************/

DWORD gajHwPackedMixFromMix[] = {
    HW_PACKED_1,                           // 0  -- 1
    HW_PACKED_0,                           // 1  -- 0
    HW_PACKED_DPon,                        // 2  -- DPon
    HW_PACKED_DPna,                        // 3  -- DPna
    HW_PACKED_Pn,                          // 4  -- Pn
    HW_PACKED_PDna,                        // 5  -- PDna
    HW_PACKED_Dn,                          // 6  -- Dn
    HW_PACKED_DPx,                         // 7  -- DPx
    HW_PACKED_DPan,                        // 8  -- DPan
    HW_PACKED_DPa,                         // 9  -- DPa
    HW_PACKED_DPxn,                        // 10 -- DPxn
    HW_PACKED_D,                           // 11 -- D
    HW_PACKED_DPno,                        // 12 -- DPno
    HW_PACKED_P,                           // 13 -- P
    HW_PACKED_PDno,                        // 14 -- PDno
    HW_PACKED_DPo,                         // 15 -- DPo
    HW_PACKED_1                            // 16 -- 1
};

#endif // endif D5480

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaRop3FromMix[] =
{
    R3_WHITENESS,   // R2_WHITE       - Allow rop = gaRop3FromMix[mix & 0x0f]
    R3_BLACKNESS,   // R2_BLACK
    0x05,           // R2_NOTMERGEPEN
    0x0A,           // R2_MASKNOTPEN
    0x0F,           // R2_NOTCOPYPEN
    0x50,           // R2_MASKPENNOT
    R3_DSTINVERT,   // R2_NOT
    R3_PATINVERT,   // R2_XORPEN
    0x5F,           // R2_NOTMASKPEN
    0xA0,           // R2_MASKPEN
    0xA5,           // R2_NOTXORPEN
    R3_NOP,         // R2_NOP
    0xAF,           // R2_MERGENOTPEN
    R3_PATCOPY,     // R2_COPYPEN
    0xF5,           // R2_MERGEPENNOT
    0xFA,           // R2_MERGEPEN
    R3_WHITENESS    // R2_WHITE       - Allow rop = gaRop3FromMix[mix & 0xff]
};

/******************************Public*Data*********************************\
* Edge masks for clipping DWORDS
*
* Masks off unwanted bits.
*
\**************************************************************************/

ULONG   gaulLeftClipMask[] =
{
    0xFFFFFFFF, 0xFFFFFF7F, 0xFFFFFF3F, 0xFFFFFF1F,
    0xFFFFFF0F, 0xFFFFFF07, 0xFFFFFF03, 0xFFFFFF01,
    0xFFFFFF00, 0xFFFF7F00, 0xFFFF3F00, 0xFFFF1F00,
    0xFFFF0F00, 0xFFFF0700, 0xFFFF0300, 0xFFFF0100,
    0xFFFF0000, 0xFF7F0000, 0xFF3F0000, 0xFF1F0000,
    0xFF0F0000, 0xFF070000, 0xFF030000, 0xFF010000,
    0xFF000000, 0x7F000000, 0x3F000000, 0x1F000000,
    0x0F000000, 0x07000000, 0x03000000, 0x01000000
};

ULONG   gaulRightClipMask[] =
{
    0xFFFFFFFF, 0xFEFFFFFF, 0xFCFFFFFF, 0xF8FFFFFF,
    0xF0FFFFFF, 0xE0FFFFFF, 0xC0FFFFFF, 0x80FFFFFF,
    0x00FFFFFF, 0x00FEFFFF, 0x00FCFFFF, 0x00F8FFFF,
    0x00F0FFFF, 0x00E0FFFF, 0x00C0FFFF, 0x0080FFFF,
    0x0000FFFF, 0x0000FEFF, 0x0000FCFF, 0x0000F8FF,
    0x0000F0FF, 0x0000E0FF, 0x0000C0FF, 0x000080FF,
    0x000000FF, 0x000000FE, 0x000000FC, 0x000000F8,
    0x000000F0, 0x000000E0, 0x000000C0, 0x00000080
};

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* VOID vImageTransfer
*
* This routine transfers a bitmap image via the data transfer
* area in video memory.
*
\**************************************************************************/

VOID vImageTransfer(        // Type FNIMAGETRANSFER
PDEV*   ppdev,
BYTE*   pjSrc,              // Source pointer
LONG    lDelta,             // Delta from start of scan to start of next
LONG    cjSrc,              // Number of bytes to be output on every scan
LONG    cScans)             // Number of scans
{
    ULONG*  pulXfer = ppdev->pulXfer;
    LONG    cdSrc;
    LONG    cjEnd;
    ULONG   d;

    ASSERTDD(cScans > 0, "Can't handle non-positive count of scans");

    cdSrc = cjSrc >> 2;
    cjEnd = cdSrc << 2;

    switch (cjSrc & 3)
    {
    case 3:
        do {
            if (cdSrc > 0)
            {
                TRANSFER_DWORD(ppdev, pulXfer, pjSrc, cdSrc);
            }

            d = (ULONG) (*(pjSrc + cjEnd))          |
                        (*(pjSrc + cjEnd + 1) << 8) |
                        (*(pjSrc + cjEnd + 2) << 16);
            TRANSFER_DWORD(ppdev, pulXfer, &d, 1);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;

    case 2:
        do {
            if (cdSrc > 0)
            {
                TRANSFER_DWORD(ppdev, pulXfer, pjSrc, cdSrc);
            }

            d = (ULONG) (*(pjSrc + cjEnd))          |
                        (*(pjSrc + cjEnd + 1) << 8);
            TRANSFER_DWORD(ppdev, pulXfer, &d, 1);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;

    case 1:
        do {
            if (cdSrc > 0)
            {
                TRANSFER_DWORD(ppdev, pulXfer, pjSrc, cdSrc);
            }

            d = (ULONG) (*(pjSrc + cjEnd));
            TRANSFER_DWORD(ppdev, pulXfer, &d, 1);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;

    case 0:
        do {
            TRANSFER_DWORD(ppdev, pulXfer, pjSrc, cdSrc);
            pjSrc += lDelta;

        } while (--cScans != 0);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\hw.h ===
/******************************************************************************\
*
* $Workfile:   hw.h  $
*
* All the hardware specific driver file stuff.  Parts are mirrored in
* 'hw.inc'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/HW.H_V  $
 * 
 *    Rev 1.4   10 Jan 1997 15:40:14   PLCHU
 *  
 * 
 *    Rev 1.3   Nov 07 1996 16:48:02   unknown
 *  
 * 
 *    Rev 1.1   Oct 10 1996 15:37:46   unknown
 *  
* 
*    Rev 1.3   12 Aug 1996 16:48:16   frido
* Cleaned up source.
* 
*    Rev 1.2   29 Jul 1996 12:28:38   frido
* Added WriteMask register.
* 
*    Rev 1.1   03 Jul 1996 13:38:42   frido
* Added DirectDraw support.
*
*   sge01   10-23-96    Add second aperture flag
*
*   sge02   10-29-96    Merge port and register access for 
*                       VGA relocatable and MMIO registers.
*
\******************************************************************************/


#define CP_TRACK()                                                               \
(                                                                               \
    DISPDBG((100, "CP access - File(%s)  line(%d)", __FILE__, __LINE__))       \
)

////////////////////////////////////////////////////////////////////////////////
//                                      Ports                                      //
////////////////////////////////////////////////////////////////////////////////

#define SR_INDEX                0x3C4   // Sequencer Registers
#define SR_DATA                 0x3C5

#define DAC_PEL_READ_ADDR       0x3C7
#define DAC_PEL_WRITE_ADDR      0x3C8
#define DAC_PEL_DATA            0x3C9

#define INDEX_REG               0x3CE   // Graphics Controler Registers
#define DATA_REG                0x3CF

#if 1 // extra defines
#define CRTC_INDEX                0x3D4    // CRT Controller Registers
#define CRTC_DATA                0x3D5

#define STATUS_1                0x3DA    // Input Status Register 1
#define DISPLAY_MODE_INACTIVE    0x01
#define VBLANK_ACTIVE            0x08
#endif

////////////////////////////////////////////////////////////////////////////////
// Alpha and PowerPC considerations
//
// Both the Alpha and the PowerPC do not guarantee that I/O to separate
// addresses will be executed in order. The Alpha and PowerPC differ, however,
// in that the PowerPC guarantees that output to the same address will be
// executed in order, while the Alpha may cache and 'collapse' consecutive
// output to become only one output.
//
// Consequently, we use the following synchronization macros. They are
// relatively expensive in terms of performance, so we try to avoid them
// whereever possible.
//
// CP_EIEIO() 'Ensure In-order Execution of I/O'
//    - Used to flush any pending I/O in situations where we wish to avoid
//      out-of-order execution of I/O to separate addresses.
//
// CP_MEMORY_BARRIER()
//    - Used to flush any pending I/O in situations where we wish to avoid
//      out-of-order execution or 'collapsing' of I/O to the same address. On
//      the PowerPC, this will be defined as a null operation.

#if defined(_PPC_)

    // On PowerPC, CP_MEMORY_BARRIER doesn't do anything.

    #define CP_EIEIO()              MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER()     0

#elseif defined(_ALPHA_)

    // On Alpha, CP_EIEIO() is the same thing as a CP_MEMORY_BARRIER().

    #define CP_EIEIO()              MEMORY_BARRIER()
    #define CP_MEMORY_BARRIER()     MEMORY_BARRIER()

#else

    // On i386 and MIPS, there is nu such thing as MEMORY_BARRIER.

    #define CP_EIEIO()                0
    #define CP_MEMORY_BARRIER()        0

#endif

//
// Merge port and register access for VGA relocatable and MMIO registers.
//

#define CL_READ_PORT_UCHAR(Port)           ppdev->pfnREAD_PORT_UCHAR(Port)
#define CL_READ_PORT_USHORT(Port)          ppdev->pfnREAD_PORT_USHORT(Port)
#define CL_READ_PORT_ULONG(Port)           ppdev->pfnREAD_PORT_ULONG(Port)
#define CL_WRITE_PORT_UCHAR(Port, Value)   ppdev->pfnWRITE_PORT_UCHAR(Port, Value)
#define CL_WRITE_PORT_USHORT(Port, Value)  ppdev->pfnWRITE_PORT_USHORT(Port, Value)
#define CL_WRITE_PORT_ULONG(Port, Value)   ppdev->pfnWRITE_PORT_ULONG(Port, Value)

////////////////////////////////////////////////////////////////////////////////
//                               Port access macros                              //
////////////////////////////////////////////////////////////////////////////////

#define CP_OUT_DWORD(pjBase, cjOffset, ul)                                       \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_WRITE_PORT_ULONG((BYTE*) (pjBase) + (cjOffset), (DWORD) (ul)),               \
    CP_EIEIO()                                                                   \
)

#define CP_OUT_WORD(pjBase, cjOffset, w)                                       \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_WRITE_PORT_USHORT((BYTE*) (pjBase) + (cjOffset), (WORD) (w)),               \
    CP_EIEIO()                                                                   \
)
                                                                            
#define CP_OUT_BYTE(pjBase, cjOffset, j)                                       \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_WRITE_PORT_UCHAR((BYTE*) (pjBase) + (cjOffset), (BYTE) (j)),               \
    CP_EIEIO()                                                                   \
)

#define CP_IN_DWORD(pjBase, cjOffset)                                           \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_READ_PORT_ULONG((BYTE*) (pjBase) + (cjOffset))                               \
)

#define CP_IN_WORD(pjBase, cjOffset)                                           \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_READ_PORT_USHORT((BYTE*) (pjBase) + (cjOffset))                               \
)

#define CP_IN_BYTE(pjBase, cjOffset)                                           \
(                                                                               \
    CP_TRACK(),                                                                   \
    CL_READ_PORT_UCHAR((BYTE*) (pjBase) + (cjOffset))                               \
)

////////////////////////////////////////////////////////////////////////////////
//                      Memory mapped register access macros                      //
////////////////////////////////////////////////////////////////////////////////

#define CP_WRITE_ULONG(pjBase, cjOffset, ul)                                   \
(                                                                               \
    CP_TRACK(),                                                                   \
    WRITE_REGISTER_ULONG((ULONG*)((BYTE*)(pjBase) + (cjOffset)), (DWORD)(ul))          \
)

#define CP_WRITE_USHORT(pjBase, cjOffset, w)                                   \
(                                                                               \
    CP_TRACK(),                                                                   \
    WRITE_REGISTER_USHORT((BYTE*) (pjBase) + (cjOffset), (WORD) (w))           \
)

#define CP_WRITE_UCHAR(pjBase, cjOffset, j)                                       \
(                                                                               \
    CP_TRACK(),                                                                   \
    WRITE_REGISTER_UCHAR((BYTE*) (pjBase) + (cjOffset), (BYTE) (j))               \
)

#define CP_READ_ULONG(pjBase, cjOffset)                                           \
(                                                                               \
    CP_TRACK(),                                                                   \
    READ_REGISTER_ULONG((BYTE*) (pjBase) + (cjOffset))                           \
)

#define CP_READ_USHORT(pjBase, cjOffset)                                       \
(                                                                               \
    CP_TRACK(),                                                                   \
    READ_REGISTER_USHORT((BYTE*) (pjBase) + (cjOffset))                           \
)

#define CP_READ_UCHAR(pjBase, cjOffset)                                           \
(                                                                               \
    CP_TRACK(),                                                                   \
    READ_REGISTER_UCHAR((BYTE*) (pjBase) + (cjOffset))                           \
)

////////////////////////////////////////////////////////////////////////////////
//                      Blt engine MM register access macros                      //
////////////////////////////////////////////////////////////////////////////////

#define CP_MM_ACL_STAT(ppdev, pjBase)                                           \
(                                                                               \
    CP_READ_UCHAR(pjBase, MM_BLT_START_STATUS_REG)                               \
)

#define CP_MM_ROP(ppdev, pjBase, val)                                           \
{                                                                               \
    CP_WRITE_UCHAR(pjBase, MM_BLT_ROP, val);                                   \
}                                                                               \

#define CP_MM_SRC_Y_OFFSET(ppdev, pjBase, val)                                   \
{                                                                               \
    CP_WRITE_USHORT(pjBase, MM_BLT_SRC_PITCH, val);                               \
}

#define CP_MM_DST_Y_OFFSET(ppdev, pjBase, val)                                   \
{                                                                               \
    CP_WRITE_USHORT(pjBase, MM_BLT_DST_PITCH, val);                               \
}

#define CP_MM_SRC_ADDR(ppdev, pjBase, val)                                       \
{                                                                               \
    CP_WRITE_ULONG(pjBase, MM_BLT_SRC_ADDR, val);                               \
}

#define CP_MM_DST_WRITE_MASK(ppdev, pjBase, val)                               \
{                                                                               \
    CP_WRITE_UCHAR(pjBase, MM_BLT_DST_WRITE_MASK, val);                           \
}

#define CP_MM_BLT_MODE(ppdev, pjBase, val)                                       \
{                                                                               \
    CP_WRITE_UCHAR(pjBase, MM_BLT_MODE, val);                                   \
    CP_WRITE_UCHAR(pjBase, MM_BLT_EXT, 0); \
}

#define CP_MM_START_REG(ppdev, pjBase, val)                                       \
{                                                                               \
    CP_WRITE_UCHAR(pjBase, MM_BLT_START_STATUS_REG, val);                       \
}

#define CP_MM_FG_COLOR(ppdev, pjBase, val)                                       \
{                                                                               \
    CP_WRITE_ULONG(pjBase, MM_BLT_FG_COLOR, val);                               \
}

#define CP_MM_BG_COLOR(ppdev, pjBase, val)                                       \
{                                                                               \
    CP_WRITE_ULONG(pjBase, MM_BLT_BG_COLOR, val);                               \
}

#define CP_MM_XCNT(ppdev, pjBase, val)                                           \
{                                                                               \
    CP_WRITE_USHORT(pjBase, MM_BLT_WIDTH, val);                                   \
}

#define CP_MM_YCNT(ppdev, pjBase, val)                                           \
{                                                                               \
    CP_WRITE_USHORT(pjBase, MM_BLT_HEIGHT, val);                               \
}

#define CP_MM_DST_ADDR(ppdev, pjBase, relval)                                   \
{                                                                               \
    CP_WRITE_ULONG(pjBase, MM_BLT_DST_ADDR, (relval) + ppdev->xyOffset);       \
}

#define CP_MM_DST_ADDR_ABS(ppdev, pjBase, val)                                   \
{                                                                               \
    CP_WRITE_ULONG(pjBase, MM_BLT_DST_ADDR, val);                               \
}

#define CP_MM_BLT_EXT_MODE(ppdev, pjBase, val)                                   \
{                                                                               \
    CP_WRITE_UCHAR(pjBase, MM_BLT_EXT, val);                                   \
}

#if 1 // D5480
#define CP_MM_BLT_MODE_PACKED(ppdev, pjBase, val)                              \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_MODE, val);                                  \
}

// Note: The PACKXY_FAST macro is unsafe with negative coordinates
#define PACKXY(x, y)        (((y) << 16) | ((x) & 0xffff))
#define PACKXY_FAST(x, y)   (((y) << 16) | (x))

#define CP_MM_DST_XY_SAFE(ppdev, pjBase, x, y)                                 \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_DST_X, PACKXY((x), (y)));                    \
}

#define CP_MM_DST_XY(ppdev, pjBase, x, y)                                      \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_DST_X, PACKXY_FAST((x), (y)));               \
}

#define CP_MM_DST_X(ppdev, pjBase, x)                                          \
{                                                                              \
    CP_WRITE_USHORT(pjBase, MM_BLT_DST_X, (x));                                \
}

#define CP_MM_DST_Y(ppdev, pjBase, y)                                          \
{                                                                              \
    CP_WRITE_USHORT(pjBase, MM_BLT_DST_Y, (y));                                \
}

#define CP_MM_SRC_XY_SAFE(ppdev, pjBase, x, y)                                 \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_SRC_X, PACKXY((x), (y)));                    \
}

#define CP_MM_SRC_XY(ppdev, pjBase, x, y)                                      \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_SRC_X, PACKXY_FAST((x), (y)));               \
}

#define CP_MM_SRC_XY_PACKED(ppdev, pjBase, xy)                                 \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_SRC_X, xy);                                  \
}

#define CP_MM_CLIP_ULXY_SAFE(ppdev, pjBase, x, y)                              \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_CLIP_ULX, PACKXY((x), (y)));                 \
}

#define CP_MM_CLIP_ULXY(ppdev, pjBase, x, y)                                   \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_CLIP_ULX, PACKXY_FAST((x), (y)));            \
}

#define CP_MM_CLIP_LRXY_SAFE(ppdev, pjBase, x, y)                              \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_CLIP_LRX, PACKXY((x), (y)));                 \
}

#define CP_MM_CLIP_LRXY(ppdev, pjBase, x, y)                                   \
{                                                                              \
    CP_WRITE_ULONG(pjBase, MM_BLT_CLIP_LRX, PACKXY_FAST((x), (y)));            \
}
#endif // endif D5480
////////////////////////////////////////////////////////////////////////////////
//                      Blt engine IO register access macros                      //
////////////////////////////////////////////////////////////////////////////////

#define CP_IO_ACL_STAT(ppdev, pjPorts)                                           \
(                                                                               \
    CP_OUT_BYTE(pjPorts, INDEX_REG, IO_BLT_START_STATUS_REG),                   \
    CP_IN_BYTE(pjPorts, DATA_REG)                                               \
)

#define CP_IO_ROP(ppdev, pjPorts, val)                                           \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG, IO_BLT_ROP | ((val) << 8));                   \
}

#define CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_SRC_PITCH_HIGH | ((val) & 0xff00));                       \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_SRC_PITCH_LOW  | (((val) & 0x00ff) << 8));               \
}

#define CP_IO_DST_Y_OFFSET(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_PITCH_HIGH | ((val) & 0xff00));                       \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_PITCH_LOW  | (((val) & 0x00ff) << 8));               \
}

#define CP_IO_SRC_ADDR(ppdev, pjPorts, val)                                       \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_SRC_ADDR_HIGH | (((val) & 0xff0000) >> 8));               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_SRC_ADDR_MID  | (((val) & 0x00ff00)));                   \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_SRC_ADDR_LOW  | (((val) & 0x0000ff) << 8));               \
}

#define CP_IO_BLT_MODE(ppdev, pjPorts, val)                                       \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG, IO_BLT_MODE | ((val) << 8));               \
}

#define CP_IO_START_REG(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_START_STATUS_REG | ((val) << 8));                       \
}

#define CP_IO_FG_COLOR(ppdev, pjPorts, val)                                       \
{                                                                               \
    if (ppdev->flCaps & CAPS_TRUE_COLOR)                                       \
    {                                                                           \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                           \
                    IO_BLT_FG_COLOR_BYTE_3 | (((val) & 0xff000000) >> 16));       \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                           \
                    IO_BLT_FG_COLOR_BYTE_2 | (((val) & 0x00ff0000) >> 8));       \
    }                                                                           \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_FG_COLOR_BYTE_1 | ((val) & 0x0000ff00));                   \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_FG_COLOR_BYTE_0 | (((val) & 0x000000ff) << 8));           \
}

#define CP_IO_BG_COLOR(ppdev, pjPorts, val)                                       \
{                                                                               \
    if (ppdev->flCaps & CAPS_TRUE_COLOR)                                       \
    {                                                                           \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                           \
                    IO_BLT_BG_COLOR_BYTE_3 | (((val) & 0xff000000) >> 16));       \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                           \
                    IO_BLT_BG_COLOR_BYTE_2 | (((val) & 0x00ff0000) >> 8));       \
    }                                                                           \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_BG_COLOR_BYTE_1 | ((val) & 0x0000ff00));                   \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_BG_COLOR_BYTE_0 | (((val) & 0x000000ff) << 8));           \
}

#define CP_IO_XCNT(ppdev, pjPorts, val)                                           \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_WIDTH_HIGH | ((val) & 0xff00));                           \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_WIDTH_LOW  | (((val) & 0x00ff) << 8));                   \
}

#define CP_IO_YCNT(ppdev, pjPorts, val)                                           \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_HEIGHT_HIGH | ((val) & 0xff00));                           \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_HEIGHT_LOW  | (((val) & 0x00ff) << 8));                   \
}

#define CP_IO_DST_ADDR(ppdev, pjPorts, relval)                                   \
{                                                                               \
    LONG val = ((relval) + ppdev->xyOffset);                                   \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_HIGH | (((val) & 0xff0000) >> 8));               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_MID  | ((val) & 0x00ff00));                       \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_LOW  | (((val) & 0x0000ff) << 8));               \
}

#define CP_IO_DST_ADDR_ABS(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_HIGH | (((val) & 0xff0000) >> 8));               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_MID  | ((val) & 0x00ff00));                       \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                IO_BLT_DST_ADDR_LOW  | (((val) & 0x0000ff) << 8));               \
}

#if 1 // D5480
#define CP_IO_BLT_EXT_MODE(ppdev, pjPorts, val)                                \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG, (IO_BLT_EXT_MODE | ((val)<<8)));           \
}

#define CP_IO_DST_XY(ppdev, pjPorts, x, y)                                     \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_X_HIGH | ((x) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_X_LOW  | (((x) & 0x0000ff) << 8));                  \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_Y_HIGH | ((y) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_Y_LOW  | (((y) & 0x0000ff) << 8));                  \
}

#define CP_IO_DST_X(ppdev, pjPorts, x)                                         \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_X_HIGH | ((x) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_X_LOW  | (((x) & 0x0000ff) << 8));                  \
}

#define CP_IO_DST_Y(ppdev, pjPorts, y)                                         \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_Y_HIGH | ((y) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_DST_Y_LOW  | (((y) & 0x0000ff) << 8));                  \
}

#define CP_IO_SRC_XY(ppdev, pjPorts, x, y)                                     \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_SRC_X_HIGH | ((x) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_SRC_X_LOW  | (((x) & 0x0000ff) << 8));                  \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_SRC_Y_HIGH | ((y) & 0x00ff00));                         \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_SRC_Y_LOW  | (((y) & 0x0000ff) << 8));                  \
}

#define CP_IO_CLIP_ULXY(ppdev, pjPorts, x, y)                                  \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_ULX_HIGH | ((x) & 0x00ff00));                      \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_ULX_LOW  | (((x) & 0x0000ff) << 8));               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_ULY_HIGH | ((y) & 0x00ff00));                      \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_ULY_LOW  | (((y) & 0x0000ff) << 8));               \
}

#define CP_IO_CLIP_LRXY(ppdev, pjPorts, x, y)                                  \
{                                                                              \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_LRX_HIGH | ((x) & 0x00ff00));                      \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_LRX_LOW  | (((x) & 0x0000ff) << 8));               \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_LRY_HIGH | ((y) & 0x00ff00));                      \
    CP_OUT_WORD(pjPorts, INDEX_REG,                                            \
                IO_BLT_CLIP_LRY_LOW  | (((y) & 0x0000ff) << 8));               \
}
#endif // endif D5480
////////////////////////////////////////////////////////////////////////////////
//                               Hardware registers                              //
////////////////////////////////////////////////////////////////////////////////

#if 1 // D5480
#define ENABLE_SOLID_FILL_PACKED        0x04000000
#define INVERT_SOURCE_PACKED            0x02000000
#define SOURCE_GRANULARITY_PACKED       0x01000000
#define ENABLE_COMMAND_LIST_PACKED      0x80000000
#define ENABLE_XY_POSITION_PACKED       0x40000000
#define ENABLE_CLIP_RECT_PACKED         0x20000000
#endif // endif D5480

#if 1 // D5480
#define ENABLE_COMMAND_LIST             0x80
#define ENABLE_XY_POSITION              0x40
#define ENABLE_CLIP_RECT                0x20
#endif // endif D5480

#define ENABLE_COLOR_EXPAND             0x80
#define ENABLE_8x8_PATTERN_COPY         0x40
#define SET_16BPP_COLOR                 0x10
#define SET_24BPP_COLOR                 0x20
#define SET_32BPP_COLOR                 0x30
#define ENABLE_TRANSPARENCY_COMPARE     0x08
#define SRC_CPU_DATA                    0x04
#define DST_CPU_DATA                    0x02
#define DECREMENT_BLT_ADDRESS           0x01

#define ENABLE_SOLID_FILL               0x04
#define INVERT_SOURCE                   0x02
#define SOURCE_GRANULARITY              0x01

#define IO_BLT_XPAR_COLOR_LOW           0x34
#define IO_BLT_XPAR_COLOR_HIGH          0x35
#define IO_BLT_XPAR_COLOR_MASK_LOW      0x38
#define IO_BLT_XPAR_COLOR_MASK_HIGH     0x39

#define IO_BLT_BG_COLOR_BYTE_0          0x00
#define IO_BLT_BG_COLOR_BYTE_1          0x10
#define IO_BLT_BG_COLOR_BYTE_2          0x12
#define IO_BLT_BG_COLOR_BYTE_3          0x14
#define IO_BLT_FG_COLOR_BYTE_0          0x01
#define IO_BLT_FG_COLOR_BYTE_1          0x11
#define IO_BLT_FG_COLOR_BYTE_2          0x13
#define IO_BLT_FG_COLOR_BYTE_3          0x15
#define IO_BLT_WIDTH_LOW                0x20
#define IO_BLT_WIDTH_HIGH               0x21
#define IO_BLT_HEIGHT_LOW               0x22
#define IO_BLT_HEIGHT_HIGH              0x23
#define IO_BLT_DST_PITCH_LOW            0x24
#define IO_BLT_DST_PITCH_HIGH           0x25
#define IO_BLT_SRC_PITCH_LOW            0x26
#define IO_BLT_SRC_PITCH_HIGH           0x27
#define IO_BLT_DST_ADDR_LOW             0x28
#define IO_BLT_DST_ADDR_MID             0x29
#define IO_BLT_DST_ADDR_HIGH            0x2A
#define IO_BLT_SRC_ADDR_LOW             0x2C
#define IO_BLT_SRC_ADDR_MID             0x2D
#define IO_BLT_SRC_ADDR_HIGH            0x2E
#define IO_BLT_MODE                     0x30
#define IO_BLT_ROP                      0x32
#define IO_BLT_START_STATUS_REG         0x31
#if 1 // D5480
#define IO_BLT_EXT_MODE                 0x33
#define IO_BLT_DST_X_LOW                0x40    
#define IO_BLT_DST_X_HIGH               0x41
#define IO_BLT_DST_Y_LOW                0x42
#define IO_BLT_DST_Y_HIGH               0x43
#define IO_BLT_SRC_X_LOW                0x44
#define IO_BLT_SRC_X_HIGH               0x45
#define IO_BLT_SRC_Y_LOW                0x46
#define IO_BLT_SRC_Y_HIGH               0x47
#define IO_BLT_CLIP_ULX_LOW             0x48
#define IO_BLT_CLIP_ULX_HIGH            0x49
#define IO_BLT_CLIP_ULY_LOW             0x4A
#define IO_BLT_CLIP_ULY_HIGH            0x4B
#define IO_BLT_CLIP_LRX_LOW             0x4C
#define IO_BLT_CLIP_LRX_HIGH            0x4D
#define IO_BLT_CLIP_LRY_LOW             0x4E
#define IO_BLT_CLIP_LRY_HIGH            0x4F
#endif // endif D5480

#define MM_BLT_BG_COLOR                 0x00
#define MM_BLT_FG_COLOR                 0x04
#define MM_BLT_WIDTH                    0x08
#define MM_BLT_HEIGHT                   0x0A
#define MM_BLT_DST_PITCH                0x0C
#define MM_BLT_SRC_PITCH                0x0E
#define MM_BLT_DST_ADDR                 0x10
#define MM_BLT_SRC_ADDR                 0x14
#define MM_BLT_DST_WRITE_MASK            0x17
#define MM_BLT_MODE                     0x18
#define MM_BLT_ROP                      0x1A
#define MM_BLT_EXT                      0x1B
#define MM_BLT_COLOR_KEY                0x1C
#define MM_BLT_START_STATUS_REG         0x40
#if 1 // D5480
#define MM_BLT_DST_X                    0x28
#define MM_BLT_DST_Y                    0x2A
#define MM_BLT_SRC_X                    0x2C
#define MM_BLT_SRC_Y                    0x2E
#define MM_BLT_CLIP_ULX                 0x30
#define MM_BLT_CLIP_LRX                 0x34
#endif // endif D5480

#define DIR_TBLR                        0x00    // Top-Bottom, Left-Right
#define DIR_BTRL                        0x01    // Bottom-Top, Right-Left

#define BLT_AUTO_START                  0x80
#define BLT_SECOND_APERTURE                0x40    // second aperture, sge01
#define BLT_PROGRESS_STATUS             0x08
#define BLT_RESET                       0x04
#define BLT_START                       0x02
#define BLT_SUSPEND                     0x02
#define BLT_STATUS                      0x01

////////////////////////////////////////////////////////////////////////////////
//                     Some handy clipping control structures                      //
////////////////////////////////////////////////////////////////////////////////

typedef struct {
    ULONG   c;
    RECTL   arcl[8];
} ENUMRECTS8, *PENUMRECTS8;

//
// The following two macros touch registers which are only available
// on the 5446 and 5480.  Only set these registers if we are on one
// of these chips.
//

#define CP_IO_XPAR_COLOR(ppdev, pjPorts, val)                                   \
{                                                                               \
    if (ppdev->flCaps & CAPS_TRANSPARENCY) {  \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                    IO_BLT_XPAR_COLOR_HIGH | ((val) & 0xff00));                       \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                    IO_BLT_XPAR_COLOR_LOW  | (((val) & 0x00ff) << 8));               \
    }  \
}

#define CP_IO_XPAR_COLOR_MASK(ppdev, pjPorts, val)                               \
{                                                                                \
    if (ppdev->flCaps & CAPS_TRANSPARENCY) {  \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                    IO_BLT_XPAR_COLOR_MASK_HIGH | ((val) & 0xff00));               \
        CP_OUT_WORD(pjPorts, INDEX_REG,                                               \
                    IO_BLT_XPAR_COLOR_MASK_LOW  | (((val) & 0x00ff) << 8));           \
    }  \
}

////////////////////////////////////////////////////////////////////////////////
//                                 MM IO settings                                  //
////////////////////////////////////////////////////////////////////////////////

#define CP_SET_MM_IO_FLAGS(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, SR_INDEX, (0x17  | (val << 8)));                       \
}

#define CP_GET_MM_IO_FLAGS(ppdev, pjPorts)                                       \
(                                                                               \
    CP_OUT_BYTE(pjPorts, SR_INDEX, 0x17),                                       \
    CP_IN_BYTE(pjPorts, SR_DATA)                                               \
)

#define CP_ENABLE_MM_IO(ppdev, pjPorts)                                           \
{                                                                               \
    BYTE jAttr;                                                                   \
    ppdev->flCaps |= CAPS_MM_IO;                                               \
    jAttr = CP_GET_MM_IO_FLAGS(ppdev, pjPorts);                                   \
    jAttr |= 0x4;                                                               \
    jAttr &= ~0x40;                                                              \
    CP_SET_MM_IO_FLAGS(ppdev, pjPorts, jAttr);                                   \
}

#define CP_DISABLE_MM_IO(ppdev, pjPorts)                                       \
{                                                                               \
    BYTE jAttr;                                                                   \
    if (ppdev->flCaps & CAPS_MM_IO)                                               \
    {                                                                           \
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, ppdev->pjBase);                       \
    }                                                                           \
    else                                                                       \
    {                                                                           \
        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);                           \
    }                                                                           \
    ppdev->flCaps &= ~CAPS_MM_IO;                                               \
    jAttr = CP_GET_MM_IO_FLAGS(ppdev, pjPorts);                                   \
    jAttr &= ~0x4;                                                               \
    CP_SET_MM_IO_FLAGS(ppdev, pjPorts, jAttr);                                   \
}

#define WAIT_COUNT 0x100000

// #if DBG //DBG
#if (DBG_STRESS_FAILURE || DBG)

    #define WAIT_BUSY_BLT(ppdev, pjBase)                                     \
    {                                                                        \
        ULONG ul = 0;                                                        \
        do                                                                   \
        {                                                                    \
            ul++;                                                            \
            if (ul >= WAIT_COUNT)                                            \
            {                                                                \
                DISPDBG((0, "WAIT_BUSY_BLT timeout"                          \
                            " file(%s) line(%d)", __FILE__, __LINE__));      \
                DISPDBG((0, "Last start blt was at file(%s) line(%d)",       \
                         glpszLastBltFile, gulLastBltLine));                 \
                DISPDBG((0, "press 'g' to continue...")); EngDebugBreak();   \
                ul = 0;                                                      \
            }                                                                \
        } while (CP_MM_ACL_STAT(ppdev, pjBase) & 0x10);                      \
    }
    
    extern ULONG   gulLastBltLine;
    extern CHAR *  glpszLastBltFile;
    extern BOOL    gbResetOnTimeout;

    ////////////////////////////////////////////////////////////////////////////
    //                 Wait for the Blt Operation to Complete                 //
    ////////////////////////////////////////////////////////////////////////////

    #define CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts)                           \
    {                                                                           \
        ULONG ul = 0;                                                           \
        do                                                                       \
        {                                                                       \
            ul++;                                                               \
            if (ul >= WAIT_COUNT)                                               \
            {                                                                   \
                DISPDBG((0, "WAIT_FOR_BLT_COMPLETE timeout"                       \
                            " file(%s) line(%d)", __FILE__, __LINE__));           \
                DISPDBG((0,"Last start blt was at file(%s) line(%d)",           \
                           glpszLastBltFile, gulLastBltLine));                   \
                DISPDBG((0, "press 'g' to continue...")); EngDebugBreak(); \
                ul = 0;                                                           \
                if (gbResetOnTimeout)                                           \
                {                                                               \
                    CP_IO_START_REG(ppdev, pjPorts, BLT_RESET);                   \
                }                                                               \
            }                                                                  \
        } while (CP_IO_ACL_STAT(ppdev, pjPorts) & BLT_STATUS);                    \
    }

    #define CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase)                            \
    {                                                                          \
        ULONG ul = 0;                                                            \
        do                                                                     \
        {                                                                      \
            ul++;                                                              \
            if (ul >= WAIT_COUNT)                                              \
            {                                                                  \
                DISPDBG((0, "WAIT_FOR_BLT_COMPLETE timeout"                       \
                            " file(%s) line(%d)", __FILE__, __LINE__));           \
                DISPDBG((0, "Last start blt was at file(%s) line(%d)",           \
                         glpszLastBltFile, gulLastBltLine));                   \
                DISPDBG((0, "press 'g' to continue...")); EngDebugBreak(); \
                ul = 0;                                                           \
                if (gbResetOnTimeout)                                           \
                {                                                               \
                    CP_MM_START_REG(ppdev, pjBase, BLT_RESET);                    \
                }                                                               \
            }                                                                  \
        } while (CP_MM_ACL_STAT(ppdev, pjBase) & BLT_STATUS);                    \
    }

    ////////////////////////////////////////////////////////////////////////////
    //               Start the Blt Operation - save debug info                //
    ////////////////////////////////////////////////////////////////////////////

    #define CP_IO_START_BLT(ppdev, pjPorts)                                    \
    {                                                                          \
        DISPDBG((5, "START_BLT file(%s) line(%d)", __FILE__, __LINE__));       \
        gulLastBltLine = __LINE__;                                             \
        glpszLastBltFile = __FILE__;                                           \
        CP_IO_START_REG(ppdev, pjPorts, BLT_START);                            \
    }

    #define CP_MM_START_BLT(ppdev, pjBase)                                        \
    {                                                                          \
        DISPDBG((5, "START_BLT file(%s) line(%d)", __FILE__, __LINE__));       \
        gulLastBltLine = __LINE__;                                             \
        glpszLastBltFile = __FILE__;                                           \
        if (!(ppdev->flCaps & CAPS_AUTOSTART))                                   \
        {                                                                      \
            CP_MM_START_REG(ppdev, pjBase, BLT_START);                            \
        }                                                                      \
    }

#else

    #define WAIT_BUSY_BLT(ppdev, pjBase)                                     \
    while (CP_MM_ACL_STAT(ppdev, pjBase) & 0x10)


    ////////////////////////////////////////////////////////////////////////////
    //                 Wait for the Blt Operation to Complete                 //
    ////////////////////////////////////////////////////////////////////////////

    #define CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts)                     \
    {                                                                       \
        while (CP_IO_ACL_STAT(ppdev, pjPorts) & BLT_STATUS);                \
    }

    #define CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase)                      \
    {                                                                       \
        while (CP_MM_ACL_STAT(ppdev, pjBase) & BLT_STATUS);                 \
    }

    ////////////////////////////////////////////////////////////////////////////
    //                        Start the Blt Operation                         //
    ////////////////////////////////////////////////////////////////////////////

    #define CP_IO_START_BLT(ppdev, pjPorts)                                    \
    {                                                                          \
        CP_IO_START_REG(ppdev, pjPorts, BLT_START);                            \
    }

    #define CP_MM_START_BLT(ppdev, pjBase)                                     \
    {                                                                           \
        if (!(ppdev->flCaps & CAPS_AUTOSTART))                                   \
        {                                                                      \
            CP_MM_START_REG(ppdev, pjBase, BLT_START);                         \
        }                                                                       \
    }

#endif


////////////////////////////////////////////////////////////////////////////////
//                                 TRANSFER_DWORD                                  //
//     32-bit transfers to host transfer buffer, the source has to be aligned      //
////////////////////////////////////////////////////////////////////////////////

#define TRANSFER_DWORD_ALIGNED(ppdev, pulXfer, p, c)                           \
{                                                                              \
    ULONG  mcd    = (ULONG)(c);                                                        \
    ULONG* mpdSrc = (ULONG*) (p);                                                \
    ASSERTDD((((ULONG_PTR) p) & 3) == 0, "Transfer not dword aligned");         \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                     \
                                                                               \
    CP_EIEIO();                                                                \
    do {                                                                       \
        CP_MEMORY_BARRIER();                                                   \
        /* *pulXfer = *mpdSrc++; */                                            \
        WRITE_REGISTER_ULONG((PULONG)(pulXfer), *mpdSrc);                      \
        mpdSrc++;                                                              \
    } while (--mcd);                                                           \
}

////////////////////////////////////////////////////////////////////////////////
//                                 TRANSFER_DWORD                                  //
// 32-bit transfers to host transfer buffer, the source has not to be aligned //
////////////////////////////////////////////////////////////////////////////////

#define TRANSFER_DWORD(ppdev, pulXfer, p, c)                                   \
{                                                                              \
    ULONG mcd               = (c);                                                \
    ULONG UNALIGNED* mpdSrc = (ULONG*) (p);                                       \
    ASSERTDD((c) > 0, "Can't have a zero transfer count");                     \
                                                                               \
    CP_EIEIO();                                                                \
    do {                                                                       \
        CP_MEMORY_BARRIER();                                                   \
        /* *pulXfer = *mpdSrc++; */                                            \
        WRITE_REGISTER_ULONG((PULONG)(pulXfer), *mpdSrc);                      \
        mpdSrc++;                                                              \
    } while (--mcd);                                                           \
}

#if 1 // D5480
////////////////////////////////////////////////////////////////////////////////
//                                  Command List stuff                                  //
////////////////////////////////////////////////////////////////////////////////

#define COMMAND_TOTAL_PACKETS        127             // We support 128 packets.
#define COMMAND_BUFFER_SIZE          4096
#define COMMAND_BUFFER_ALIGN          255

#define COMMAND_LAST_PACKET         0x80000000
#define COMMAND_DISCARD_SRC         0x40000000
#define COMMAND_FOURTH_NOTHING      0x30000000
#define COMMAND_FOURTH_BLT_ROP      0x10000000
#define COMMAND_FOURTH_DST_SRC      0x00000000
#define COMMAND_NOSRC_NOTHING       0x70000000


#define CP_MM_CL_SWITCH(ppdev)                                                 \
{                                                                              \
    if( ppdev->pCommandList == ppdev->pCLFirst )                               \
        ppdev->pCommandList = ppdev->pCLSecond;                                \
    else                                                                       \
        ppdev->pCommandList = ppdev->pCLFirst;                                 \
}
#endif // endif D5480

////////////////////////////////////////////////////////////////////////////////
//                                  Pointer stuff                                  //
////////////////////////////////////////////////////////////////////////////////

#define SPRITE_BUFFER_SIZE              256

#define POINTER_X_POSITION              0x10
#define POINTER_Y_POSITION              0x11
#define POINTER_ATTRIBUTES              0x12
#define POINTER_OFFSET                  0x13

#define ENABLE_POINTER                  0x01
#define ALLOW_DAC_ACCESS_TO_EXT_COLORS  0x02
#define POINTER_SIZE_64x64              0x04
#define OVERSCAN_COLOR_PROTECT          0x80

#define POINTER_X_SHIFT                 0x01
#define POINTER_Y_SHIFT                 0x02
#define POINTER_SHAPE_RESET             0x04
#define POINTER_DISABLED                0x08

#define CP_PTR_XY_POS(ppdev, pjPorts, x, y)                                       \
{                                                                               \
    DISPDBG((10, "\t CP_PTR_XY_POS (%d,%d)", x, y));                           \
    CP_OUT_WORD(pjPorts, SR_INDEX,                                               \
                (POINTER_Y_POSITION | ((y & 0x7) << 5)) | ((y & 0x7f8) << 5)); \
    CP_OUT_WORD(pjPorts, SR_INDEX,                                               \
                (POINTER_X_POSITION | ((x & 0x7) << 5)) | ((x & 0x7f8) << 5)); \
    /* [HWBUG] - must set position twice */                                       \
    CP_OUT_WORD(pjPorts, SR_INDEX,                                               \
                (POINTER_Y_POSITION | ((y & 0x7) << 5)) | ((y & 0x7f8) << 5)); \
    CP_OUT_WORD(pjPorts, SR_INDEX,                                               \
                (POINTER_X_POSITION | ((x & 0x7) << 5)) | ((x & 0x7f8) << 5)); \
}

#define CP_PTR_SET_FLAGS(ppdev, pjPorts, val)                                   \
{                                                                               \
    CP_OUT_WORD(pjPorts, SR_INDEX, POINTER_ATTRIBUTES | (val << 8));           \
}

#define CP_PTR_GET_FLAGS(ppdev, pjPorts)                                       \
(                                                                               \
    CP_OUT_BYTE(pjPorts, SR_INDEX, POINTER_ATTRIBUTES),                           \
    CP_IN_BYTE(pjPorts, SR_DATA)                                               \
)

#define CP_PTR_ADDR(ppdev, pjPorts, val)                                       \
{                                                                               \
    CP_OUT_WORD(pjPorts, SR_INDEX, POINTER_OFFSET | (val << 8));               \
}

#define CP_PTR_ENABLE(ppdev, pjPorts)                                           \
{                                                                               \
    BYTE jAttr;                                                                   \
    DISPDBG((10, "\t CP_PTR_ENABLE"));                                           \
    if (ppdev->flPointer & POINTER_DISABLED)                                   \
    {                                                                           \
        ppdev->flPointer &= ~POINTER_DISABLED;                                   \
        jAttr = CP_PTR_GET_FLAGS(ppdev, pjPorts);                               \
        jAttr |= ENABLE_POINTER;                                               \
        CP_PTR_SET_FLAGS(ppdev, pjPorts, jAttr);                               \
        DISPDBG((10, "\t CP_PTR_ENABLE - done"));                               \
    }                                                                           \
}

#define CP_PTR_DISABLE(ppdev, pjPorts)                                           \
{                                                                               \
    BYTE jAttr;                                                                   \
    DISPDBG((10, "\t CP_PTR_DISABLE"));                                           \
    if (!(ppdev->flPointer & POINTER_DISABLED))                                   \
    {                                                                           \
        ppdev->flPointer |= POINTER_DISABLED;                                   \
        jAttr = CP_PTR_GET_FLAGS(ppdev, pjPorts);                               \
        jAttr &= ~ENABLE_POINTER;                                               \
        CP_PTR_SET_FLAGS(ppdev, pjPorts, jAttr);                               \
        CP_PTR_XY_POS(ppdev, pjPorts, 2047, 2047);                               \
        DISPDBG((10, "\t CP_PTR_DISABLE - done"));                               \
    }                                                                           \
}

////////////////////////////////////////////////////////////////////////////////
//                        ROP definitions for the hardware                      //
////////////////////////////////////////////////////////////////////////////////

#define R3_BLACKNESS                0x00    // dest = BLACK
#define R3_NOTSRCERASE              0x11    // dest = (NOT src) AND (NOT dest)
#define R3_NOTSRCCOPY               0x33    // dest = (NOT source)
#define R3_SRCERASE                 0x44    // dest = source AND (NOT dest )
#define R3_DSTINVERT                0x55    // dest = (NOT dest)
#define R3_PATINVERT                0x5A    // dest = pattern XOR dest
#define R3_SRCINVERT                0x66    // dest = source XOR dest
#define R3_SRCAND                   0x88    // dest = source AND dest
#define R3_NOP                      0xAA    // dest = dest
#define R3_MERGEPAINT               0xBB    // dest = (NOT source) OR dest
#define R3_MERGECOPY                0xC0    // dest = (source AND pattern)
#define R3_SRCCOPY                  0xCC    // dest = source
#define R3_SRCPAINT                 0xEE    // dest = source OR dest
#define R3_PATCOPY                  0xF0    // dest = pattern
#define R3_PATPAINT                 0xFB    // dest = DPSnoo
#define R3_WHITENESS                0xFF    // dest = WHITE

#define R4_BLACKNESS                0x0000  // dest = BLACK
#define R4_NOTSRCERASE              0x1111  // dest = (NOT src) AND (NOT dest)
#define R4_NOTSRCCOPY               0x3333  // dest = (NOT source)
#define R4_SRCERASE                 0x4444  // dest = source AND (NOT dest )
#define R4_DSTINVERT                0x5555  // dest = (NOT dest)
#define R4_PATINVERT                0x5A5A  // dest = pattern XOR dest
#define R4_SRCINVERT                0x6666  // dest = source XOR dest
#define R4_SRCAND                   0x8888  // dest = source AND dest
#define R4_MERGEPAINT               0xBBBB  // dest = (NOT source) OR dest
#define R4_MERGECOPY                0xC0C0  // dest = (source AND pattern)
#define R4_SRCCOPY                  0xCCCC  // dest = source
#define R4_SRCPAINT                 0xEEEE  // dest = source OR dest
#define R4_PATCOPY                  0xF0F0  // dest = pattern
#define R4_PATPAINT                 0xFBFB  // dest = DPSnoo
#define R4_WHITENESS                0xFFFF  // dest = WHITE


#define HW_0                        0x00
#define HW_1                        0x0E
#define HW_P                        0x0D
#define HW_D                        0x06
#define HW_Pn                       0xD0
#define HW_Dn                       0x0B
#define HW_DPa                      0x05
#define HW_PDna                     0x09
#define HW_DPna                     0x50
#define HW_DPon                     0x90
#define HW_DPo                      0x6D
#define HW_PDno                     0xAD
#define HW_DPno                     0xD6
#define HW_DPan                     0xDA
#define HW_DPx                      0x59
#define HW_DPxn                     0x95

#define CL_BLACKNESS                HW_0
#define CL_WHITENESS                HW_1
#define CL_SRC_COPY                 HW_P
#define CL_DST                      HW_D
#define CL_NOT_SRC_COPY             HW_Pn
#define CL_DST_INVERT               HW_Dn
#define CL_SRC_AND                  HW_DPa
#define CL_SRC_ERASE                HW_PDna
#define CL_NOT_SRC_OR_DST           HW_DPna
#define CL_NOT_SRC_ERASE            HW_DPon
#define CL_SRC_PAINT                HW_DPo
#define CL_SRC_AND_NOT_DST          HW_PDno
#define CL_MERGE_PAINT              HW_DPno
#define CL_NOT_SRC_AND_NOT_DST      HW_DPan
#define CL_SRC_INVERT               HW_DPx
#define CL_NOT_SRC                  HW_PDxn

#if 1 // D5480
#define HW_PACKED_0                 0x000000    
#define HW_PACKED_1                 0x0E0000
#define HW_PACKED_P                 0x0D0000
#define HW_PACKED_D                 0x060000
#define HW_PACKED_Pn                0xD00000
#define HW_PACKED_Dn                0x0B0000
#define HW_PACKED_DPa               0x050000
#define HW_PACKED_PDna              0x090000
#define HW_PACKED_DPna              0x500000
#define HW_PACKED_DPon              0x900000
#define HW_PACKED_DPo               0x6D0000
#define HW_PACKED_PDno              0xAD0000
#define HW_PACKED_DPno              0xD60000
#define HW_PACKED_DPan              0xDA0000
#define HW_PACKED_DPx               0x590000
#define HW_PACKED_DPxn              0x950000

#define CL_PACKED_BLACKNESS             HW_PACKED_0
#define CL_PACKED_WHITENESS             HW_PACKED_1
#define CL_PACKED_SRC_COPY              HW_PACKED_P
#define CL_PACKED_DST                   HW_PACKED_D
#define CL_PACKED_NOT_SRC_COPY          HW_PACKED_Pn
#define CL_PACKED_DST_INVERT            HW_PACKED_Dn
#define CL_PACKED_SRC_AND               HW_PACKED_DPa
#define CL_PACKED_SRC_ERASE             HW_PACKED_PDna
#define CL_PACKED_NOT_SRC_OR_DST        HW_PACKED_DPna
#define CL_PACKED_NOT_SRC_ERASE         HW_PACKED_DPon
#define CL_PACKED_SRC_PAINT             HW_PACKED_DPo
#define CL_PACKED_SRC_AND_NOT_DST       HW_PACKED_PDno
#define CL_PACKED_MERGE_PAINT           HW_PACKED_DPno
#define CL_PACKED_NOT_SRC_AND_NOT_DST   HW_PACKED_DPan
#define CL_PACKED_SRC_INVERT            HW_PACKED_DPx
#define CL_PACKED_NOT_SRC               HW_PACKED_PDxn

#endif // endif D5480
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\heap.c ===
/******************************************************************************\
*
* $Workfile:   heap.c  $
*
* This module contains the routines for a 2-d heap.  It is used primarily
* for allocating space for device-format-bitmaps in off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* The heap algorithm employed herein attempts to solve an unsolvable
* problem: the problem of keeping arbitrary sized bitmaps as packed as
* possible in a 2-d space, when the bitmaps can come and go at random.
*
* This problem is due entirely to the nature of the hardware for which this
* driver is written: the hardware treats everything as 2-d quantities.  If
* the hardware bitmap pitch could be changed so that the bitmaps could be
* packed linearly in memory, the problem would be infinitely easier (it is
* much easier to track the memory, and the accelerator can be used to re-pack
* the heap to avoid segmentation).
*
* If your hardware can treat bitmaps as one dimensional quantities (as can
* the XGA and ATI), by all means please implement a new off-screen heap.
*
* When the heap gets full, old allocations will automatically be punted
* from off-screen and copied to DIBs, which we'll let GDI draw on.
*
* Note that this heap manages reverse-L shape off-screen memory
* configurations (where the scan pitch is longer than the visible screen,
* such as happens at 800x600 when the scan length must be a multiple of
* 1024).
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1993-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/heap.c_v  $
 * 
 *    Rev 1.3   Apr 03 1997 15:38:54   unknown
 *  
 *
 *    Rev 1.2   28 Mar 1997 16:08:50   PLCHU
 *
 *
 *    Rev 1.1   Oct 10 1996 15:37:42   unknown
 *
*
*    Rev 1.8   12 Aug 1996 17:11:22   frido
* hp#1 - Commented new heap stuff.
* hp#2 - Keep enough memory for WinBench bitmap.
*
*    Rev 1.7   12 Aug 1996 16:53:30   frido
* Added NT 3.5x/4.0 auto detection.
*
*    Rev 1.6   23 Jul 1996 17:48:38   frido
* Removed creation of small device bitmaps.
* Never reject the WinBench bitmap!
*
*    Rev 1.5   16 Jul 1996 18:55:52   frido
* Changed splitting of new block to cause less fragmentation.
*
* pat04: 12-20-96 : Supported NT3.51 software cursor with panning scrolling
* pat08: 04-01-97 : SW cursor problem due to code merge. Frido had turned
*                   of allocation of small device bitmaps for optimization,
*                   --- winnt to return a null ptr to a color bitmap mask.
*
\******************************************************************************/

#include "precomp.h"

#define OH_ALLOC_SIZE   4000        // Do all memory allocations in 4k chunks
#define OH_QUANTUM      8           // The minimum dimension of an allocation
#define CXCY_SENTINEL   0x7fffffff  // The sentinel at the end of the available
                                    //  list has this very large 'cxcy' value

// This macro results in the available list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

#if DBG
    BOOL gbEnableDFB = TRUE;
#endif

/******************************Public*Routine******************************\
* OH* pohNewNode
*
* Allocates a basic memory unit in which we'll pack our data structures.
*
* Since we'll have a lot of OH nodes, most of which we will be
* occasionally traversing, we do our own memory allocation scheme to
* keep them densely packed in memory.
*
* It would be the worst possible thing for the working set to simply
* call EngAllocMem(sizeof(OH)) every time we needed a new node.  There
* would be no locality; OH nodes would get scattered throughout memory,
* and as we traversed the available list for one of our allocations,
* it would be far more likely that we would hit a hard page fault.
\**************************************************************************/

OH* pohNewNode(
PDEV*   ppdev)
{
    LONG     i;
    LONG     cOhs;
    OHALLOC* poha;
    OH*      poh;

    if (ppdev->heap.pohFreeList == NULL)
    {
        // We zero-init to initialize all the OH flags, and to help in
        // debugging (we can afford to do this since we'll be doing this
        // very infrequently):

        poha = ALLOC(OH_ALLOC_SIZE);
        if (poha == NULL)
            return(NULL);

        // Insert this OHALLOC at the begining of the OHALLOC chain:

        poha->pohaNext  = ppdev->heap.pohaChain;
        ppdev->heap.pohaChain = poha;

        // This has a '+ 1' because OHALLOC includes an extra OH in its
        // structure declaration:

        cOhs = (OH_ALLOC_SIZE - sizeof(OHALLOC)) / sizeof(OH) + 1;

        // The big OHALLOC allocation is simply a container for a bunch of
        // OH data structures in an array.  The new OH data structures are
        // linked together and added to the OH free list:

        poh = &poha->aoh[0];
        for (i = cOhs - 1; i != 0; i--)
        {
            poh->pohNext = poh + 1;
            poh          = poh + 1;
        }

        poh->pohNext      = NULL;
        ppdev->heap.pohFreeList = &poha->aoh[0];
    }

    poh = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh->pohNext;

    return(poh);
}

/******************************Public*Routine******************************\
* VOID vOhFreeNode
*
* Frees our basic data structure allocation unit by adding it to a free
* list.
*
\**************************************************************************/

VOID vOhFreeNode(
PDEV*   ppdev,
OH*     poh)
{
    if (poh == NULL)
        return;

    poh->pohNext            = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh;
    poh->ofl                = 0;
}

/******************************Public*Routine******************************\
* OH* pohFree
*
* Frees an off-screen heap allocation.  The free space will be combined
* with any adjacent free spaces to avoid segmentation of the 2-d heap.
*
* Note: A key idea here is that the data structure for the upper-left-
*       most node must be kept at the same physical CPU memory so that
*       adjacency links are kept correctly (when two free spaces are
*       merged, the lower or right node can be freed).
*
\**************************************************************************/

OH* pohFree(
PDEV*   ppdev,
OH*     poh)
{
    ULONG cxcy;
    OH*   pohBeside;
    OH*   pohNext;
    OH*   pohPrev;
#if 1 //hp#1
    BOOL  bUpdate;
#endif

    if (poh == NULL)
        return(NULL);

#if 1 //hp#1
    bUpdate = (poh->ofl & OFL_PERMANENT) != 0;
#endif

    DISPDBG((4, "Freeing %d x %d at (%d, %d)", poh->cx, poh->cy, poh->x,
             poh->y));

    #if DEBUG_HEAP
    {
        RECTL           rclBitmap;
        RBRUSH_COLOR    rbc;
        LONG            xOffset;
        LONG            yOffset;
        LONG            xyOffset;

        rclBitmap.left   = poh->x;
        rclBitmap.top    = poh->y;
        rclBitmap.right  = poh->x + poh->cx;
        rclBitmap.bottom = poh->y + poh->cy;

        xOffset  = ppdev->xOffset;
        yOffset  = ppdev->yOffset;
        xyOffset = ppdev->xyOffset;

        ppdev->xOffset  = 0;
        ppdev->yOffset  = 0;
        ppdev->xyOffset = 0;

        ppdev->pfnFillSolid(ppdev, 1, &rclBitmap, 0x0, rbc, NULL);

        ppdev->xOffset  = xOffset;
        ppdev->yOffset  = yOffset;
        ppdev->xyOffset = xyOffset;
    }
    #endif

    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:

    ppdev->iHeapUniq++;

MergeLoop:

#if 0 //hp#1
    ASSERTDD(!(poh->ofl & OFL_PERMANENT), "Can't free permanents for now");
#endif

    // Try merging with the right sibling:

    pohBeside = poh->pohRight;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cy      == poh->cy)         &&
        (pohBeside->pohUp   == poh->pohUp)      &&
        (pohBeside->pohDown == poh->pohDown)    &&
        (pohBeside->pohRight->pohLeft != pohBeside))
    {
        // Add the right rectangle to ours:

        poh->cx      += pohBeside->cx;
        poh->pohRight = pohBeside->pohRight;

        // Remove 'pohBeside' from the ??? list and free it:

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the lower sibling:

    pohBeside = poh->pohDown;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown->pohUp != pohBeside))
    {
        poh->cy     += pohBeside->cy;
        poh->pohDown = pohBeside->pohDown;

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the left sibling:

    pohBeside = poh->pohLeft;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cy       == poh->cy)        &&
        (pohBeside->pohUp    == poh->pohUp)     &&
        (pohBeside->pohDown  == poh->pohDown)   &&
        (pohBeside->pohRight == poh)            &&
        (poh->pohRight->pohLeft != poh))
    {
        // We add our rectangle to the one to the left:

        pohBeside->cx      += poh->cx;
        pohBeside->pohRight = poh->pohRight;

        // Remove 'poh' from the ??? list and free it:

        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev->pohNext = poh->pohNext;

        vOhFreeNode(ppdev, poh);

        poh = pohBeside;
        goto MergeLoop;
    }

    // Try merging with the upper sibling:

    pohBeside = poh->pohUp;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown  == poh)            &&
        (poh->pohDown->pohUp != poh))
    {
        pohBeside->cy      += poh->cy;
        pohBeside->pohDown  = poh->pohDown;

        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev->pohNext = poh->pohNext;

        vOhFreeNode(ppdev, poh);

        poh = pohBeside;
        goto MergeLoop;
    }

    // Remove the node from the ???list if it was in use (we wouldn't
    // want to do this for a OFL_PERMANENT node that had been freed):

    poh->pohNext->pohPrev = poh->pohPrev;
    poh->pohPrev->pohNext = poh->pohNext;

    cxcy = CXCY(poh->cx, poh->cy);

    // Insert the node into the available list:

    pohNext = ppdev->heap.ohAvailable.pohNext;
    while (pohNext->cxcy < cxcy)
    {
        pohNext = pohNext->pohNext;
    }
    pohPrev = pohNext->pohPrev;

    pohPrev->pohNext = poh;
    pohNext->pohPrev = poh;
    poh->pohPrev     = pohPrev;
    poh->pohNext     = pohNext;
    poh->ofl         = OFL_AVAILABLE;
    poh->cxcy        = cxcy;

#if 1 //hp#1
    if (bUpdate)
    {
        vCalculateMaximum(ppdev);
    }
#endif

    // Return the node pointer for the new and improved available rectangle:
    return(poh);
}

/******************************Public*Routine******************************\
* OH* pohAllocate
*
* Allocates space for an off-screen rectangle.  It will attempt to find
* the smallest available free rectangle, and will allocate the block out
* of its upper-left corner.  The remaining two rectangles will be placed
* on the available free space list.
*
* If the rectangle would have been large enough to fit into off-screen
* memory, but there is not enough available free space, we will boot
* bitmaps out of off-screen and into DIBs until there is enough room.
*
\**************************************************************************/

OH* pohAllocate(
PDEV*   ppdev,
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLOH    floh)               // Allocation flags
{
    ULONG cxcyThis;         // Width and height search key
    OH*   pohThis;          // Points to found available rectangle we'll use
    ULONG cxcy;             // Temporary versions
    OH*   pohNext;
    OH*   pohPrev;

    LONG  cxRem;
    LONG  cyRem;

    OH*   pohBelow;
    LONG  cxBelow;
    LONG  cyBelow;

    OH*   pohBeside;
    LONG  cxBeside;
    LONG  cyBeside;

    DISPDBG((4, "Allocating %d x %d...", cxThis, cyThis));

    ASSERTDD((cxThis > 0) && (cyThis > 0), "Illegal allocation size");

    // Increase the width to get the proper alignment (thus ensuring that all
    // allocations will be properly aligned):

    cxThis = (cxThis + (HEAP_X_ALIGNMENT - 1)) & ~(HEAP_X_ALIGNMENT - 1);

    // We can't succeed if the requested rectangle is larger than the
    // largest possible available rectangle:

    if ((cxThis > ppdev->heap.cxMax) || (cyThis > ppdev->heap.cyMax))
    {
#if 1 //hp#2
        if ((cxThis != 400) && (cyThis != 90))
#endif
        {
            DISPDBG((4, "Failing pohAllocate... rectangle is larger than max allowed"));
            DISPDBG((4, "max = (%d,%d)", ppdev->heap.cxMax, ppdev->heap.cyMax));
            DISPDBG((4, "req = (%d,%d)", cxThis, cyThis));
            return(NULL);
        }
    }

    // Find the first available rectangle the same size or larger than
    // the requested one:

    cxcyThis = CXCY(cxThis, cyThis);
    pohThis  = ppdev->heap.ohAvailable.pohNext;
    while (pohThis->cxcy < cxcyThis)
    {
        pohThis = pohThis->pohNext;
    }

    while (pohThis->cy < cyThis)
    {
        pohThis = pohThis->pohNext;
    }

    if (pohThis->cxcy == CXCY_SENTINEL)
    {
        // There was no space large enough...

        if (floh & FLOH_ONLY_IF_ROOM)
        {
            DISPDBG((4, "Failing pohAllocate... no space large enough"));
            DISPDBG((4, "req = (%d,%d)", cxThis, cyThis));
            return(NULL);
        }

        // We couldn't find an available rectangle that was big enough
        // to fit our request.  So throw things out of the heap until we
        // have room:

        do {
            pohThis = ppdev->heap.ohDfb.pohPrev;  // Least-recently blitted

            ASSERTDD(pohThis != &ppdev->heap.ohDfb, "Ran out of in-use entries");

#if 1 //hp#1
            while (pohThis->ofl == OFL_PERMANENT)
            {
                pohThis = pohThis->pohPrev;
                if (pohThis == &ppdev->heap.ohDfb)
                {
                    DISPDBG((4, "Failing pohAllocate... not enough memory"));
                    DISPDBG((4, "req = (%d,%d)", cxThis, cyThis));
                    return(NULL);
                }
            }
#endif
            // We can safely exit here if we have to:

            pohThis = pohMoveOffscreenDfbToDib(ppdev, pohThis);
            if (pohThis == NULL)
            {
                DISPDBG((4, "Failing pohAllocate... failed to eject a dfb"));
                DISPDBG((4, "req = (%d,%d)", cxThis, cyThis));
                return(NULL);
            }

        } while ((pohThis->cx < cxThis) || (pohThis->cy < cyThis));
    }

    // We've now found an available rectangle that is the same size or
    // bigger than our requested rectangle.  We're going to use the
    // upper-left corner of our found rectangle, and divide the unused
    // remainder into two rectangles which will go on the available
    // list.

    // Compute the width of the unused rectangle to the right, and the
    // height of the unused rectangle below:

    cyRem = pohThis->cy - cyThis;
    cxRem = pohThis->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow  = cyRem;
    cxBeside = cxRem;

#if 1 //hp#1
    if ((cxRem <= cyRem) || (pohThis->cx >= ppdev->cxScreen))
#else
    if (cxRem <= cyRem)
#endif
    {
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
    else
    {
        cxBelow  = cxThis;
        cyBeside = cyThis + cyRem;
    }

    // We only make new available rectangles of the unused right and bottom
    // portions if they're greater in dimension than OH_QUANTUM (it hardly
    // makes sense to do the book-work to keep around a 2-pixel wide
    // available space, for example):

    pohBeside = NULL;
    if (cxBeside >= OH_QUANTUM)
    {
        pohBeside = pohNewNode(ppdev);
        if (pohBeside == NULL)
            return(NULL);
    }

    pohBelow = NULL;
    if (cyBelow >= OH_QUANTUM)
    {
        pohBelow = pohNewNode(ppdev);
        if (pohBelow == NULL)
        {
            vOhFreeNode(ppdev, pohBeside);
            return(NULL);
        }

        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBelow, cyBelow);
        pohNext = ppdev->heap.ohAvailable.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext  = pohBelow;
        pohNext->pohPrev  = pohBelow;
        pohBelow->pohPrev = pohPrev;
        pohBelow->pohNext = pohNext;

        // Now update the adjacency information:

        pohBelow->pohLeft  = pohThis->pohLeft;
        pohBelow->pohUp    = pohThis;
        pohBelow->pohRight = pohThis->pohRight;
        pohBelow->pohDown  = pohThis->pohDown;

        // Update the rest of the new node information:

        pohBelow->cxcy = cxcy;
        pohBelow->ofl  = OFL_AVAILABLE;

        pohBelow->x    = pohThis->x;
        pohBelow->y    = pohThis->y + cyThis;
        pohBelow->xy   = PELS_TO_BYTES(pohBelow->x)
                       + (pohBelow->y * ppdev->lDelta);

        pohBelow->cx   = cxBelow;
        pohBelow->cy   = cyBelow;

        // Modify the current node to reflect the changes we've made:

        pohThis->cy = cyThis;
    }

    if (cxBeside >= OH_QUANTUM)
    {
        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBeside, cyBeside);
        pohNext = ppdev->heap.ohAvailable.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext   = pohBeside;
        pohNext->pohPrev   = pohBeside;
        pohBeside->pohPrev = pohPrev;
        pohBeside->pohNext = pohNext;

        // Now update the adjacency information:

        pohBeside->pohUp    = pohThis->pohUp;
        pohBeside->pohLeft  = pohThis;
        pohBeside->pohDown  = pohThis->pohDown;
        pohBeside->pohRight = pohThis->pohRight;

        // Update the rest of the new node information:

        pohBeside->cxcy = cxcy;
        pohBeside->ofl  = OFL_AVAILABLE;

        pohBeside->x    = pohThis->x + cxThis;
        pohBeside->y    = pohThis->y;
        pohBeside->xy   = PELS_TO_BYTES(pohBeside->x)
                        + (pohBeside->y * ppdev->lDelta);

        pohBeside->cx   = cxBeside;
        pohBeside->cy   = cyBeside;

        // Modify the current node to reflect the changes we've made:

        pohThis->cx = cxThis;
    }

    if (pohBelow != NULL)
    {
        pohThis->pohDown = pohBelow;
        if ((pohBeside != NULL) && (cyBeside == pohThis->cy))
            pohBeside->pohDown = pohBelow;
    }
    if (pohBeside != NULL)
    {
        pohThis->pohRight = pohBeside;
        if ((pohBelow != NULL) && (cxBelow == pohThis->cx))
            pohBelow->pohRight  = pohBeside;
    }

    pohThis->ofl    = OFL_INUSE;
    pohThis->cxcy   = CXCY(pohThis->cx, pohThis->cy);
    pohThis->pdsurf = NULL; // Caller is responsible for setting this field

    // Remove this from the available list:

    pohThis->pohPrev->pohNext = pohThis->pohNext;
    pohThis->pohNext->pohPrev = pohThis->pohPrev;

    // Now insert this at the head of the DFB list:

    pohThis->pohNext                   = ppdev->heap.ohDfb.pohNext;
    pohThis->pohPrev                   = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.pohNext->pohPrev = pohThis;
    ppdev->heap.ohDfb.pohNext          = pohThis;

    DISPDBG((4, "   Allocated at (%d, %d)", pohThis->x, pohThis->y));

    // Calculate the effective start address for this bitmap in off-
    // screen memory:

    pohThis->pvScan0 = ppdev->pjScreen + (pohThis->y * ppdev->lDelta)
                                       + PELS_TO_BYTES(pohThis->x);
    return(pohThis);
}

/******************************Public*Routine******************************\
* VOID vCalculateMaxmimum
*
* Traverses the list of in-use and available rectangles to find the one
* with the maximal area.
*
\**************************************************************************/
VOID vCalculateMaximum(
PDEV*   ppdev)
{
    OH*     poh;
    OH*     pohSentinel;
    LONG    lArea;
    LONG    lMaxArea;
    LONG    cxMax;
    LONG    cyMax;
    LONG    i;

    lMaxArea = 0;
    cxMax    = 0;
    cyMax    = 0;

    // First time through, loop through the list of available rectangles:

    pohSentinel = &ppdev->heap.ohAvailable;

    for (i = 2; i != 0; i--)
    {
        for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
        {
#if 1 //hp#1
            if (poh->ofl & OFL_PERMANENT)
            {
                continue;
            }
#else
            ASSERTDD(!(poh->ofl & OFL_PERMANENT),
                     "Permanent in available/DFB chain?");
#endif

            // We don't have worry about this multiply overflowing
            // because we are dealing in physical screen coordinates,
            // which will probably never be more than 15 bits:

            lArea = poh->cx * poh->cy;
            if (lArea > lMaxArea)
            {
                cxMax    = poh->cx;
                cyMax    = poh->cy;
                lMaxArea = lArea;
            }
        }

        // Second time through, loop through the list of in-use rectangles:

        pohSentinel = &ppdev->heap.ohDfb;
    }

    // All that we are interested in is the dimensions of the rectangle
    // that has the largest possible available area (and remember that
    // there might not be any possible available area):

    ppdev->heap.cxMax = cxMax;
    ppdev->heap.cyMax = cyMax;

    DISPDBG((1, "Maximum heap: %d x %d", cxMax, cyMax));
}

/******************************Public*Routine******************************\
* OH* pohAllocatePermanent
*
* Allocates an off-screen rectangle that can never be booted of the heap.
* It's the caller's responsibility to manage the rectangle, which includes
* what to do with the memory in DrvAssertMode when the display is changed
* to full-screen mode.
*
\**************************************************************************/

OH* pohAllocatePermanent(
PDEV*   ppdev,
LONG    cx,
LONG    cy)
{
    OH*     poh;

    poh = pohAllocate(ppdev, cx, cy, 0);
    if (poh != NULL)
    {
        // Mark the rectangle as permanent:

        poh->ofl = OFL_PERMANENT;

#if 0 //hp#1
        // Remove the node from the most-recently blitted list:

        poh->pohPrev->pohNext = poh->pohNext;
        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev = NULL;
        poh->pohNext = NULL;
#endif

        // Now calculate the new maximum size rectangle available in the
        // heap:
        vCalculateMaximum(ppdev);
    }

    return(poh);
}

/******************************Public*Routine******************************\
* BOOL bMoveDibToOffscreenDfbIfRoom
*
* Converts the DIB DFB to an off-screen DFB, if there's room for it in
* off-screen memory.
*
* Returns: FALSE if there wasn't room, TRUE if successfully moved.
*
\**************************************************************************/

BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)
{
    OH*         poh;
    SURFOBJ*    pso;
    RECTL       rclDst;
    POINTL      ptlSrc;
    HSURF       hsurf;

    ASSERTDD(pdsurf->dt == DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    DISPDBG((4, "Trying to reload %d x %d surface", pdsurf->sizl.cx,
             pdsurf->sizl.cy));

    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:

    if (!ppdev->bEnabled)
        return(FALSE);

    poh = pohAllocate(ppdev, pdsurf->sizl.cx, pdsurf->sizl.cy,
                      FLOH_ONLY_IF_ROOM);
    if (poh == NULL)
    {
        // There wasn't any free room.

        return(FALSE);
    }

    // 'pdsurf->sizl' is the actual bitmap dimension, not 'poh->cx' or
    // 'poh->cy'.

    rclDst.left   = poh->x;
    rclDst.top    = poh->y;
    rclDst.right  = rclDst.left + pdsurf->sizl.cx;
    rclDst.bottom = rclDst.top  + pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    ppdev->pfnPutBits(ppdev, pdsurf->pso, &rclDst, &ptlSrc);

    // Update the data structures to reflect the new off-screen node:

    pso           = pdsurf->pso;
    pdsurf->dt    = DT_SCREEN;
    pdsurf->poh   = poh;
    poh->pdsurf   = pdsurf;

    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):

    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMoveOffscreenDfbToDib
*
* Converts the DFB from being off-screen to being a DIB.
*
* Note: The caller does NOT have to call 'pohFree' on 'poh' after making
*       this call.
*
* Returns: NULL if the function failed (due to a memory allocation).
*          Otherwise, it returns a pointer to the coalesced off-screen heap
*          node that has been made available for subsequent allocations
*          (useful when trying to free enough memory to make a new
*          allocation).
\**************************************************************************/

OH* pohMoveOffscreenDfbToDib(
PDEV*   ppdev,
OH*     poh)
{
    DSURF*   pdsurf;
    HBITMAP  hbmDib;
    SURFOBJ* pso;
    RECTL    rclDst;
    POINTL   ptlSrc;

    DISPDBG((4, "Throwing out %li x %li at (%li, %li)!",
                 poh->cx, poh->cy, poh->x, poh->y));

#if 1 //hp#1
    if (poh->ofl & OFL_PERMANENT)
    {
        return(NULL);
    }
#endif

    pdsurf = poh->pdsurf;

    ASSERTDD((poh->x != 0) || (poh->y != 0),
            "Can't make the visible screen into a DIB");
    ASSERTDD(pdsurf->dt != DT_DIB,
            "Can't make a DIB into even more of a DIB");

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                rclDst.left   = 0;
                rclDst.top    = 0;
                rclDst.right  = pdsurf->sizl.cx;
                rclDst.bottom = pdsurf->sizl.cy;

                ptlSrc.x      = poh->x;
                ptlSrc.y      = poh->y;

                ppdev->pfnGetBits(ppdev, pso, &rclDst, &ptlSrc);

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;

                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:

                return(pohFree(ppdev, poh));
            }
        }

        // Fail case:

        EngDeleteSurface((HSURF) hbmDib);
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* BOOL bMoveEverythingFromOffscreenToDibs
*
* This function is used when we're about to enter full-screen mode, which
* would wipe all our off-screen bitmaps.  GDI can ask us to draw on
* device bitmaps even when we're in full-screen mode, and we do NOT have
* the option of stalling the call until we switch out of full-screen.
* We have no choice but to move all the off-screen DFBs to DIBs.
*
* Returns TRUE if all DSURFs have been successfully moved.
*
\**************************************************************************/

BOOL bMoveAllDfbsFromOffscreenToDibs(
PDEV*   ppdev)
{
    OH*  poh;
    OH*  pohNext;
    BOOL bRet;

    bRet = TRUE;
    poh  = ppdev->heap.ohDfb.pohNext;
    while (poh != &ppdev->heap.ohDfb)
    {
        pohNext = poh->pohNext;

        // If something's already a DIB, we shouldn't try to make it even
        // more of a DIB:

#if 1 //hp#1
        if (!(poh->ofl & OFL_PERMANENT) && (poh->pdsurf->dt == DT_SCREEN))
#else
        if (poh->pdsurf->dt == DT_SCREEN)
#endif
        {
            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
                bRet = FALSE;
        }

        poh = pohNext;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Function called by GDI to create a device-format-bitmap (DFB).  We will
* always try to allocate the bitmap in off-screen; if we can't, we simply
* fail the call and GDI will create and manage the bitmap itself.
*
* Note: We do not have to zero the bitmap bits.  GDI will automatically
*       call us via DrvBitBlt to zero the bits (which is a security
*       consideration).
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)
{
    PDEV*   ppdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;

    ppdev = (PDEV*) dhpdev;

    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.

    if (!ppdev->bEnabled)
        return(0);

#if DBG
    if(!gbEnableDFB)
        return(0);
#endif

#if (_WIN32_WINNT >= 0x0400) //#pat08

#if 1 //hp#2
    if ((sizl.cx < 20) || ((sizl.cx >= 32) && (sizl.cx < 100)))
    {
        return(0);
    }
#endif
//pat08 begin
#else
    if ((ppdev->ulChipID != CL7541_ID) && (ppdev->ulChipID == CL7543_ID) &&
        (ppdev->ulChipID != CL7542_ID) && (ppdev->ulChipID == CL7548_ID) &&
        (ppdev->ulChipID != CL7555_ID) && (ppdev->ulChipID == CL7556_ID))
    {
#if 1 //hp#2
         if ((sizl.cx < 20) || ((sizl.cx >= 32) && (sizl.cx < 100)))
         {
             return(0);
         }
#endif
    }
#endif
//pat08 end

    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.

    if (iFormat != ppdev->iBitmapFormat)
        return(0);

    // We don't want anything 8x8 or smaller -- they're typically brush
    // patterns which we don't particularly want to stash in off-screen
    // memory:

    if ((sizl.cx <= 8) && (sizl.cy <= 8))
        return(0);

    poh = pohAllocate(ppdev, sizl.cx, sizl.cy, 0);
    if (poh != NULL)
    {
        pdsurf = ALLOC(sizeof(DSURF));
        if (pdsurf != NULL)
        {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                                        ppdev->flHooks))
                {
                    pdsurf->dt    = DT_SCREEN;
                    pdsurf->poh   = poh;
                    pdsurf->sizl  = sizl;
                    pdsurf->ppdev = ppdev;
                    poh->pdsurf   = pdsurf;

                    return(hbmDevice);
                }

                EngDeleteSurface((HSURF) hbmDevice);
            }
            FREE(pdsurf);
        }
        pohFree(ppdev, poh);
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap
*
* Deletes a DFB.
*
\**************************************************************************/

VOID DrvDeleteDeviceBitmap(
DHSURF  dhsurf)
{
    DSURF*   pdsurf;
    PDEV*    ppdev;
    SURFOBJ* psoDib;
    HSURF    hsurfDib;

    pdsurf = (DSURF*) dhsurf;
    ppdev  = pdsurf->ppdev;

    if (pdsurf->dt == DT_SCREEN)
    {
        pohFree(ppdev, pdsurf->poh);
    }
    else
    {
        ASSERTDD(pdsurf->dt == DT_DIB, "Expected DIB type");

        psoDib = pdsurf->pso;

        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):

        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }

    FREE(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeOffscreenHeap
*
* This function is called whenever we switch in or out of full-screen
* mode.  We have to convert all the off-screen bitmaps to DIBs when
* we switch to full-screen (because we may be asked to draw on them even
* when in full-screen, and the mode switch would probably nuke the video
* memory contents anyway).
*
\**************************************************************************/

BOOL bAssertModeOffscreenHeap(
PDEV*   ppdev,
BOOL    bEnable)
{
    BOOL b;

    b = TRUE;

    if (!bEnable)
    {
        b = bMoveAllDfbsFromOffscreenToDibs(ppdev);
    }

    return(b);
}

/******************************Public*Routine******************************\
* VOID vDisableOffscreenHeap
*
* Frees any resources allocated by the off-screen heap.
*
\**************************************************************************/

VOID vDisableOffscreenHeap(
PDEV*   ppdev)
{
    OHALLOC* poha;
    OHALLOC* pohaNext;
    SURFOBJ* psoPunt;
    HSURF    hsurf;

    psoPunt = ppdev->psoPunt;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    psoPunt = ppdev->psoPunt2;
    if (psoPunt != NULL)
    {
        hsurf = psoPunt->hsurf;
        EngUnlockSurface(psoPunt);
        EngDeleteSurface(hsurf);
    }

    poha = ppdev->heap.pohaChain;
    while (poha != NULL)
    {
        pohaNext = poha->pohaNext;  // Grab the next pointer before it's freed
        FREE(poha);
        poha = pohaNext;
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableOffscreenHeap
*
* Initializes the off-screen heap using all available video memory,
* accounting for the portion taken by the visible screen.
*
* Input: ppdev->cxScreen
*        ppdev->cyScreen
*        ppdev->cxMemory
*        ppdev->cyMemory
*
\**************************************************************************/

BOOL bEnableOffscreenHeap(
PDEV*   ppdev)
{
    OH*         poh;
    SIZEL       sizl;
    HSURF       hsurf;
    static      onetimealloc = 0;               //pat04
    FLONG       flPuntSurfaceHooks = ppdev->flHooks & ~HOOK_SYNCHRONIZE;

    DISPDBG((5, "Screen: %li x %li  Memory: %li x %li",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory));

    ppdev->heap.pohaChain   = NULL;
    ppdev->heap.pohFreeList = NULL;

    // Initialize the available list, which will be a circular
    // doubly-linked list kept in ascending 'cxcy' order, with a
    // 'sentinel' at the end of the list:

    poh = pohNewNode(ppdev);
    if (poh == NULL)
        goto ReturnFalse;

    // The first node describes the entire video memory size:

    poh->pohNext  = &ppdev->heap.ohAvailable;
    poh->pohPrev  = &ppdev->heap.ohAvailable;
    poh->ofl      = OFL_AVAILABLE;
    poh->x        = 0;
    poh->y        = 0;
    poh->xy       = 0;
    poh->cx       = ppdev->cxMemory;
    poh->cy       = ppdev->cyMemory;
    poh->cxcy     = CXCY(ppdev->cxMemory, ppdev->cyMemory);
    poh->pohLeft  = &ppdev->heap.ohAvailable;
    poh->pohUp    = &ppdev->heap.ohAvailable;
    poh->pohRight = &ppdev->heap.ohAvailable;
    poh->pohDown  = &ppdev->heap.ohAvailable;
    poh->pvScan0  = ppdev->pjScreen;

    // The second node is our available list sentinel:

    ppdev->heap.ohAvailable.pohNext = poh;
    ppdev->heap.ohAvailable.pohPrev = poh;
    ppdev->heap.ohAvailable.cxcy    = CXCY_SENTINEL;
    ppdev->heap.ohAvailable.cx      = 0x7fffffff;
    ppdev->heap.ohAvailable.cy      = 0x7fffffff;
    ppdev->heap.ohAvailable.ofl     = OFL_PERMANENT;
    ppdev->heap.ohDfb.pohLeft       = NULL;
    ppdev->heap.ohDfb.pohUp         = NULL;
    ppdev->heap.ohDfb.pohRight      = NULL;
    ppdev->heap.ohDfb.pohDown       = NULL;

    // Initialize the most-recently-blitted DFB list, which will be
    // a circular doubly-linked list kept in order, with a sentinel at
    // the end.  This node is also used for the screen-surface, for its
    // offset:

    ppdev->heap.ohDfb.pohNext  = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.pohPrev  = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.ofl      = OFL_PERMANENT;

    // For the moment, make the max really big so that the first
    // allocation we're about to do will succeed:

    ppdev->heap.cxMax = 0x7fffffff;
    ppdev->heap.cyMax = 0x7fffffff;

    // Reserve the upper-left corner for the screen.

    poh = pohAllocatePermanent(ppdev, ppdev->cxScreen, ppdev->cyScreen);

    ppdev->pohScreen = poh;

    ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == 0),
             "We assumed allocator would use the upper-left corner");

    // Allocate a 'punt' SURFOBJ we'll use when the device-bitmap is in
    // off-screen memory, but we want GDI to draw to it directly as an
    // engine-managed surface:

    sizl.cx = ppdev->cxMemory;
    sizl.cy = ppdev->cyMemory;

    // We want to create it with exactly the same hooks, capabilities,
    // and screen delta as our primary surface:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    ppdev->lDelta,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    ppdev->pjScreen);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, flPuntSurfaceHooks)) ||
        (!(ppdev->psoPunt = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    // We need another for doing DrvBitBlt and DrvCopyBits when both
    // surfaces are off-screen bitmaps:

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    ppdev->lDelta,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    ppdev->pjScreen);

    if ((hsurf == 0)                                                  ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, flPuntSurfaceHooks)) ||
        (!(ppdev->psoPunt2 = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed punt surface creation"));

        EngDeleteSurface(hsurf);
        goto ReturnFalse;
    }

    DISPDBG((5, "Passed bEnableOffscreenHeap"));

// pat04 : for NT 3.51 S/W cursor, begin
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL

    if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
        (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
        (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))
    {
        if (poh != NULL) {
            if (onetimealloc == 0)
            {
                onetimealloc = 1;
                ppdev->pjPointerAndCMask =
                       pohAllocatePermanent(ppdev, 32 * ppdev->cBpp, 32);
                ppdev->pjCBackground =
                      pohAllocatePermanent (ppdev, 32 * ppdev->cBpp, 32);
                ppdev->pjPointerCBitmap =
                      pohAllocatePermanent (ppdev, 32 * ppdev->cBpp, 32);
            }

            return(TRUE);
        }
    }
    else
    {
        if (poh != NULL)
            return(TRUE);
    }
#else           //myf-pat
    if (poh != NULL)
        return(TRUE);
#endif          //myf-pat
#else  // NT4.0 code
//pat04, end
    if (poh != NULL)
        return(TRUE);
#endif                  //pat04


ReturnFalse:

    DISPDBG((0, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\lineto.c ===
/******************************************************************************\
*
* $Workfile:   LineTo.c  $
*
* Contents:
* This file contains the DrvLineTo function and simple line drawing code.
*
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   V:/CirrusLogic/CL54xx/NT40/Archive/Display/LineTo.c_v  $
*
*    Rev 1.4   12 Aug 1996 16:53:50   frido
* Added NT 3.5x/4.0 auto detection.
*
*    Rev 1.3   29 Jul 1996 12:23:04   frido
* Fixed bug in drawing horizontal lines from right to left.
*
*    Rev 1.2   15 Jul 1996 15:56:12   frido
* Changed DST_ADDR into DST_ADDR_ABS.
*
*    Rev 1.1   12 Jul 1996 16:02:06   frido
* Redefined some macros that caused irratic line drawing on device bitmaps.
*
*    Rev 1.0   10 Jul 1996 17:53:40   frido
* New code.
*
\******************************************************************************/

#include "PreComp.h"
#if LINETO

#define LEFT    0x01
#define TOP             0x02
#define RIGHT   0x04
#define BOTTOM  0x08

bIoLineTo(
PDEV* ppdev,
LONG  x1,
LONG  y1,
LONG  x2,
LONG  y2,
ULONG ulSolidColor,
MIX   mix,
ULONG ulDstAddr)
{
        BYTE* pjPorts = ppdev->pjPorts;
        LONG  lDelta = ppdev->lDelta;
        LONG  dx, dy;
        LONG  cx, cy;

        if (ulSolidColor != (ULONG) -1)
        {
                if (ppdev->cBpp == 1)
                {
                        ulSolidColor |= ulSolidColor << 8;
                        ulSolidColor |= ulSolidColor << 16;
                }
                else if (ppdev->cBpp == 2)
                {
                        ulSolidColor |= ulSolidColor << 16;
                }

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                CP_IO_ROP(ppdev, pjPorts, gajHwMixFromMix[mix & 0x0F]);
                CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->ulSolidColorOffset);
                CP_IO_BLT_MODE(ppdev, pjPorts, ENABLE_COLOR_EXPAND     |
                                                                           ENABLE_8x8_PATTERN_COPY |
                                                                           ppdev->jModeColor);
                CP_IO_FG_COLOR(ppdev, pjPorts, ulSolidColor);
        }

        // Calculate deltas.
        dx = x2 - x1;
        dy = y2 - y1;

        // Horizontal lines.
        if (dy == 0)
        {
                if (dx < 0)
                {
                        // From right to left.
                        ulDstAddr += PELS_TO_BYTES(x2 - 1) + (y2 * lDelta);
                        cx = PELS_TO_BYTES(-dx) - 1;
                }
                else if (dx > 0)
                {
                        // From left to right.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cx = PELS_TO_BYTES(dx) - 1;
                }
                else
                {
                        // Nothing to do here!
                        return(TRUE);
                }

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                CP_IO_XCNT(ppdev, pjPorts, cx);
                CP_IO_YCNT(ppdev, pjPorts, 0);
                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                CP_IO_START_BLT(ppdev, pjPorts);

                return(TRUE);
        }

        // Vertical lines.
        else if (dx == 0)
        {
                if (dy < 0)
                {
                        // From bottom to top.
                        ulDstAddr += PELS_TO_BYTES(x2) + ((y2 + 1) * lDelta);
                        cy = -dy - 1;
                }
                else
                {
                        // From top to bottom.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cy = dy - 1;
                }

                cx = PELS_TO_BYTES(1) - 1;

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                CP_IO_XCNT(ppdev, pjPorts, cx);
                CP_IO_YCNT(ppdev, pjPorts, cy);
                CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                CP_IO_START_BLT(ppdev, pjPorts);

                return(TRUE);
        }

        // Diagonal lines.
        else if ((dx == dy) || (dx == -dy))
        {
                if (dy < 0)
                {
                        if (dx < 0)
                        {
                                // Diagonal line from bottom-right to upper-left.
                                ulDstAddr += PELS_TO_BYTES(x2 + 1);
                        }
                        else
                        {
                                // Diagonal line from bottom-left to upper-right.
                                ulDstAddr += PELS_TO_BYTES(x2 - 1);
                        }
                        ulDstAddr += (y2 + 1) * lDelta;
                        cy = -dy - 1;
                }
                else
                {
                        // Diagonal line from top to bottom, either from left to right or
                        // right to left.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cy = dy - 1;
                }

                if (dx == dy)
                {
                        // Diagonal line from top-left to bottom-right or vice versa.
                        lDelta += PELS_TO_BYTES(1);
                }
                else
                {
                        // Diagonal line from top-right to bottom-left or vice versa.
                        lDelta -= PELS_TO_BYTES(1);
                }

                cx = PELS_TO_BYTES(1) - 1;

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                CP_IO_XCNT(ppdev, pjPorts, cx);
                CP_IO_YCNT(ppdev, pjPorts, cy);
                CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);
                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                CP_IO_START_BLT(ppdev, pjPorts);

                return(TRUE);
        }

        // All other lines.
        if (dx < 0)
        {
                dx = -dx;
        }
        if (dy < 0)
        {
                dy = -dy;
        }
        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);

        // Horizontal major.
        if (dx > dy)
        {
                LONG run = dy;

                cy = (y1 > y2) ? -lDelta : lDelta;

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

                //
                // We would like to set the YCNT register once
                // here (outside the loops below).  However, on
                // the CL5428, this register does not hold its value
                // after one iteration through the loop.  So, I'll
                // have to set it inside the loop.
                //

                if (x1 < x2)
                {
                        while (x1 < x2)
                        {
                                cx = 1 + (dx - run) / dy;
                                if ((x1 + cx) < x2)
                                {
                                        run += cx * dy - dx;
                                }
                                else
                                {
                                        cx = x2 - x1;
                                }
                                x1 += cx;
                                cx = PELS_TO_BYTES(cx);

                                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                                CP_IO_YCNT(ppdev, pjPorts, 0);
                                CP_IO_XCNT(ppdev, pjPorts, cx - 1);
                                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                                CP_IO_START_BLT(ppdev, pjPorts);

                                ulDstAddr += cx + cy;
                        }
                }
                else
                {
                        cy -= PELS_TO_BYTES(1);

                        while (x1 > x2)
                        {
                                cx = 1 + (dx - run) / dy;
                                if ((x1 - cx) > x2)
                                {
                                        run += cx * dy - dx;
                                }
                                else
                                {
                                        cx = x1 - x2;
                                }
                                ulDstAddr -= PELS_TO_BYTES(cx - 1);
                                x1 -= cx;
                                cx = PELS_TO_BYTES(cx);

                                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                                CP_IO_YCNT(ppdev, pjPorts, 0);
                                CP_IO_XCNT(ppdev, pjPorts, cx - 1);
                                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                                CP_IO_START_BLT(ppdev, pjPorts);

                                ulDstAddr += cy;
                        }
                }
        }

        // Vertical major.
        else
        {
                LONG run = dx;

                cx = (x1 > x2) ? PELS_TO_BYTES(-1) : PELS_TO_BYTES(1);

                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                CP_IO_XCNT(ppdev, pjPorts, PELS_TO_BYTES(1) - 1);
                CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);

                if (y1 < y2)
                {
                        while (y1 < y2)
                        {
                                cy = 1 + (dy - run) / dx;
                                if ((y1 + cy) < y2)
                                {
                                        run += cy * dx - dy;
                                }
                                else
                                {
                                        cy = y2 - y1;
                                }
                                y1 += cy;

                                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                                CP_IO_YCNT(ppdev, pjPorts, cy - 1);
                                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                                CP_IO_START_BLT(ppdev, pjPorts);

                                ulDstAddr += cx + cy * lDelta;
                        }
                }
                else
                {
                        cx -= lDelta;

                        while (y1 > y2)
                        {
                                cy = 1 + (dy - run) / dx;
                                if ((y1 - cy) > y2)
                                {
                                        run += cy * dx - dy;
                                }
                                else
                                {
                                        cy = y1 - y2;
                                }
                                ulDstAddr -= (cy - 1) * lDelta;
                                y1 -= cy;

                                CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
                                CP_IO_YCNT(ppdev, pjPorts, cy - 1);
                                CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ulDstAddr);
                                CP_IO_START_BLT(ppdev, pjPorts);

                                ulDstAddr += cx;
                        }
                }
        }

        return(TRUE);
}

bMmLineTo(
PDEV* ppdev,
LONG  x1,
LONG  y1,
LONG  x2,
LONG  y2,
ULONG ulSolidColor,
MIX   mix,
ULONG ulDstAddr)
{
        BYTE* pjBase = ppdev->pjBase;
        LONG  lDelta = ppdev->lDelta;
        LONG  dx, dy;
        LONG  cx, cy;

        if (ulSolidColor != (ULONG) -1)
        {
                if (ppdev->cBpp == 1)
                {
                        ulSolidColor |= ulSolidColor << 8;
                        ulSolidColor |= ulSolidColor << 16;
                }
                else if (ppdev->cBpp == 2)
                {
                        ulSolidColor |= ulSolidColor << 16;
                }

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_ROP(ppdev, pjBase, gajHwMixFromMix[mix & 0x0F]);
                CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
                CP_MM_BLT_MODE(ppdev, pjBase, ENABLE_COLOR_EXPAND     |
                                                                          ENABLE_8x8_PATTERN_COPY |
                                                                          ppdev->jModeColor);
                CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);

//              if (ppdev->flCaps & CAPS_IS_5436)
                if (ppdev->flCaps & CAPS_AUTOSTART)
                {
                        CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
                }
        }

        // Calculate deltas.
        dx = x2 - x1;
        dy = y2 - y1;

        // Horizontal lines.
        if (dy == 0)
        {
                if (dx < 0)
                {
                        // From right to left.
                        ulDstAddr += PELS_TO_BYTES(x2 + 1) + (y2 * lDelta);
                        cx = PELS_TO_BYTES(-dx) - 1;
                }
                else if (dx > 0)
                {
                        // From left to right.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cx = PELS_TO_BYTES(dx) - 1;
                }
                else
                {
                        // Nothing to do here!
                        return(TRUE);
                }

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_XCNT(ppdev, pjBase, cx);
                CP_MM_YCNT(ppdev, pjBase, 0);
                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                CP_MM_START_BLT(ppdev, pjBase);

                return(TRUE);
        }

        // Vertical lines.
        else if (dx == 0)
        {
                if (dy < 0)
                {
                        // From bottom to top.
                        ulDstAddr += PELS_TO_BYTES(x2) + ((y2 + 1) * lDelta);
                        cy = -dy - 1;
                }
                else
                {
                        // From top to bottom.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cy = dy - 1;
                }

                cx = PELS_TO_BYTES(1) - 1;

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_XCNT(ppdev, pjBase, cx);
                CP_MM_YCNT(ppdev, pjBase, cy);
                CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                CP_MM_START_BLT(ppdev, pjBase);

                return(TRUE);
        }

        // Diagonal lines.
        else if ((dx == dy) || (dx == -dy))
        {
                if (dy < 0)
                {
                        if (dx < 0)
                        {
                                // Diagonal line from bottom-right to upper-left.
                                ulDstAddr += PELS_TO_BYTES(x2 + 1);
                        }
                        else
                        {
                                // Diagonal line from bottom-left to upper-right.
                                ulDstAddr += PELS_TO_BYTES(x2 - 1);
                        }
                        ulDstAddr += (y2 + 1) * lDelta;
                        cy = -dy - 1;
                }
                else
                {
                        // Diagonal line from top to bottom, either from left to right or
                        // right to left.
                        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);
                        cy = dy - 1;
                }

                if (dx == dy)
                {
                        // Diagonal line from top-left to bottom-right or vice versa.
                        lDelta += PELS_TO_BYTES(1);
                }
                else
                {
                        // Diagonal line from top-right to bottom-left or vice versa.
                        lDelta -= PELS_TO_BYTES(1);
                }

                cx = PELS_TO_BYTES(1) - 1;

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_XCNT(ppdev, pjBase, cx);
                CP_MM_YCNT(ppdev, pjBase, cy);
                CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                CP_MM_START_BLT(ppdev, pjBase);

                return(TRUE);
        }

        // All other lines.
        if (dx < 0)
        {
                dx = -dx;
        }
        if (dy < 0)
        {
                dy = -dy;
        }
        ulDstAddr += PELS_TO_BYTES(x1) + (y1 * lDelta);

        // Horizontal major.
        if (dx > dy)
        {
                LONG run = dy;

                cy = (y1 > y2) ? -lDelta : lDelta;

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_YCNT(ppdev, pjBase, 0);

                if (x1 < x2)
                {
                        while (x1 < x2)
                        {
                                cx = 1 + (dx - run) / dy;
                                if ((x1 + cx) < x2)
                                {
                                        run += cx * dy - dx;
                                }
                                else
                                {
                                        cx = x2 - x1;
                                }
                                x1 += cx;
                                cx = PELS_TO_BYTES(cx);

                                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                                CP_MM_XCNT(ppdev, pjBase, cx - 1);
                                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                                CP_MM_START_BLT(ppdev, pjBase);

                                ulDstAddr += cx + cy;
                        }
                }
                else
                {
                        cy -= PELS_TO_BYTES(1);

                        while (x1 > x2)
                        {
                                cx = 1 + (dx - run) / dy;
                                if ((x1 - cx) > x2)
                                {
                                        run += cx * dy - dx;
                                }
                                else
                                {
                                        cx = x1 - x2;
                                }
                                ulDstAddr -= PELS_TO_BYTES(cx - 1);
                                x1 -= cx;
                                cx = PELS_TO_BYTES(cx);

                                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                                CP_MM_XCNT(ppdev, pjBase, cx - 1);
                                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                                CP_MM_START_BLT(ppdev, pjBase);

                                ulDstAddr += cy;
                        }
                }
        }

        // Vertical major.
        else
        {
                LONG run = dx;

                cx = (x1 > x2) ? PELS_TO_BYTES(-1) : PELS_TO_BYTES(1);

                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(1) - 1);
                CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);

                if (y1 < y2)
                {
                        while (y1 < y2)
                        {
                                cy = 1 + (dy - run) / dx;
                                if ((y1 + cy) < y2)
                                {
                                        run += cy * dx - dy;
                                }
                                else
                                {
                                        cy = y2 - y1;
                                }
                                y1 += cy;

                                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                                CP_MM_YCNT(ppdev, pjBase, cy - 1);
                                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                                CP_MM_START_BLT(ppdev, pjBase);

                                ulDstAddr += cx + cy * lDelta;
                        }
                }
                else
                {
                        cx -= lDelta;

                        while (y1 > y2)
                        {
                                cy = 1 + (dy - run) / dx;
                                if ((y1 - cy) > y2)
                                {
                                        run += cy * dx - dy;
                                }
                                else
                                {
                                        cy = y1 - y2;
                                }
                                ulDstAddr -= (cy - 1) * lDelta;
                                y1 -= cy;

                                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                                CP_MM_YCNT(ppdev, pjBase, cy - 1);
                                CP_MM_DST_ADDR_ABS(ppdev, pjBase, ulDstAddr);
                                CP_MM_START_BLT(ppdev, pjBase);

                                ulDstAddr += cx;
                        }
                }
        }

        return(TRUE);
}

BOOL bClipLine(LONG x1, LONG y1, LONG x2, LONG y2, RECTL* prcl)
{
        ULONG ulCode1, ulCode2;
        RECTL rclClip1, rclClip2;
        LONG  dx, dy;

        // Set clipping rectangles.
        rclClip1.left   = prcl->left;
        rclClip1.top    = prcl->top;
        rclClip1.right  = prcl->right - 1;
        rclClip1.bottom = prcl->bottom - 1;

        rclClip2.left   = prcl->left - 1;
        rclClip2.top    = prcl->top - 1;
        rclClip2.right  = prcl->right;
        rclClip2.bottom = prcl->bottom;

        // Set line deltas.
        dx = x2 - x1;
        dy = y2 - y1;

        // Set line flags.
        ulCode1 = 0;
        if (x1 < rclClip1.left)   ulCode1 |= LEFT;
        if (y1 < rclClip1.top)    ulCode1 |= TOP;
        if (x1 > rclClip1.right)  ulCode1 |= RIGHT;
        if (y1 > rclClip1.bottom) ulCode1 |= BOTTOM;

        ulCode2 = 0;
        if (x2 < rclClip2.left)   ulCode2 |= LEFT;
        if (y2 < rclClip2.top)    ulCode2 |= TOP;
        if (x2 > rclClip2.right)  ulCode2 |= RIGHT;
        if (y2 > rclClip2.bottom) ulCode2 |= BOTTOM;

        if ((ulCode1 & ulCode2) != 0)
        {
                // The line is completly clipped.
                return(FALSE);
        }

        // Vertical lines.
        if (dx == 0)
        {
                if (dy == 0)
                {
                        return(FALSE);
                }

                if (ulCode1 & TOP)
                {
                        y1 = rclClip1.top;
                }
                else if (ulCode1 & BOTTOM)
                {
                        y1 = rclClip1.bottom;
                }

                if (ulCode2 & TOP)
                {
                        y2 = rclClip2.top;
                }
                else if (ulCode2 & BOTTOM)
                {
                        y2 = rclClip2.bottom;
                }

                goto ReturnTrue;
        }

        // Horizontal lines.
        if (dy == 0)
        {
                if (ulCode1 & LEFT)
                {
                        x1 = rclClip1.left;
                }
                else if (ulCode1 & RIGHT)
                {
                        x1 = rclClip1.right;
                }

                if (ulCode2 & LEFT)
                {
                        x2 = rclClip2.left;
                }
                else if (ulCode2 & RIGHT)
                {
                        x2 = rclClip2.right;
                }

                goto ReturnTrue;
        }

        // Clip start point.
        if (x1 < rclClip1.left)
        {
                y1 += dy * (rclClip1.left - x1) / dx;
                x1  = rclClip1.left;
        }
        else if (x1 > rclClip1.right)
        {
                y1 += dy * (rclClip1.right - x1) / dx;
                x1  = rclClip1.right;
        }
        if (y1 < rclClip1.top)
        {
                x1 += dx * (rclClip1.top - y1) / dy;
                y1  = rclClip1.top;
        }
        else if (y1 > rclClip1.bottom)
        {
                x1 += dx * (rclClip1.bottom - y1) / dy;
                y1  = rclClip1.bottom;
        }
        if ((x1 < rclClip1.left) || (y1 < rclClip1.top) || (x1 > rclClip1.right) ||
            (y1 > rclClip1.bottom))
        {
                // Start point fully clipped.
                return(FALSE);
        }

        // Clip end point.
        if (x2 < rclClip2.left)
        {
                y2 += dy * (rclClip2.left - x2) / dx;
                x2  = rclClip2.left;
        }
        else if (x2 > rclClip2.right)
        {
                y2 += dy * (rclClip2.right - x2) / dx;
                x2  = rclClip2.right;
        }
        if (y2 < rclClip2.top)
        {
                x2 += dx * (rclClip2.top - y2) / dy;
                y2  = rclClip2.top;
        }
        else if (y2 > rclClip2.bottom)
        {
                x2 += dx * (rclClip2.bottom - y2) / dy;
                y2  = rclClip2.bottom;
        }
        if ((x2 < rclClip2.left) || (y2 < rclClip2.top) || (x2 > rclClip2.right) ||
            (y2 > rclClip2.bottom))
        {
                // End point fully clipped.
                return(FALSE);
        }

ReturnTrue:
        prcl->left       = x1;
        prcl->top        = y1;
        prcl->right      = x2;
        prcl->bottom = y2;
        return(TRUE);
}

/******************************************************************************\
*
* Function:     DrvLineTo
*
* This function draws a line between any two points. This function only draws
* lines in solod color and that are just 1 pixel wide. The end-point is not
* drawn.
*
* Parameters:   pso                     Pointer to surface.
*               pco                     Pointer to CLIPOBJ.
*               pbo                     Pointer to BRUSHOBJ.
*               x1                      Starting x-coordinate.
*               y1                      Starting y-coordinate.
*               x2                      Ending x-coordinate.
*               y2                      Ending y-coordinate.
*               prclBounds      Pointer to an unclipped bounding rectangle.
*               mix                     Mix to perform on the destination.
*
* Returns:      TRUE if the line has been drawn, FALSE oftherwise.
*
\******************************************************************************/
BOOL DrvLineTo(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
LONG      x1,
LONG      y1,
LONG      x2,
LONG      y2,
RECTL*    prclBounds,
MIX       mix)
{
        PDEV*  ppdev = (PPDEV)pso->dhpdev;
        DSURF* pdsurf = (DSURF *)pso->dhsurf;
        OH*    poh;
        BOOL   bMore;

        // If the device bitmap is a DIB, let GDI handle it.
        if (pdsurf->dt == DT_DIB)
        {
                return(EngLineTo(pdsurf->pso, pco, pbo, x1, y1, x2, y2, prclBounds,
                                 mix));
        }

        // Get the off-screen node.
        poh = pdsurf->poh;

        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
                // No clipping.
                return(ppdev->pfnLineTo(ppdev, x1, y1, x2, y2, pbo->iSolidColor, mix,
                                        poh->xy));
        }

        else if (pco->iDComplexity == DC_RECT)
        {
                // Clipped rectangle.
                RECTL rcl;

                rcl = pco->rclBounds;
                if (bClipLine(x1, y1, x2, y2, &rcl))
                {
                        return(ppdev->pfnLineTo(ppdev, rcl.left, rcl.top, rcl.right,
                                                                        rcl.bottom, pbo->iSolidColor, mix,
                                                                        poh->xy));
                }
                return(TRUE);
        }

        // Complex clipping.
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do
        {
                CLIPENUM ce;
                RECTL* prcl;

                bMore = CLIPOBJ_bEnum(pco, sizeof(ce), &ce.c);

                prcl = ce.arcl;
                while (ce.c--)
                {
                        if (bClipLine(x1, y1, x2, y2, prcl))
                        {
                                if (!ppdev->pfnLineTo(ppdev, prcl->left, prcl->top, prcl->right,
                                                                          prcl->bottom, pbo->iSolidColor, mix,
                                                                          poh->xy))
                                {
                                        return(FALSE);
                                }
                        }
                        prcl++;
                }
        } while (bMore);

        return(TRUE);
}

#endif // LINETO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;             // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);

// Strip drawers:

VOID vIoSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vIoSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vIoSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vIoSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vIoStyledHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vIoStyledVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vMmSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmStyledHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmStyledVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vInvalidStrip(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

#if 1 // D5480 chu01
VOID vMmSolidHorizontal80(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vMmSolidVertical80(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
#endif // D5480 chu01

// External calls:

BOOL bLines(PDEV*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP apfn[], FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\overlay.c ===
/******************************************************************************\
*
* $Workfile:   OVERLAY.C  $
*
* Copyright (c) 1996-1997 Microsoft Corporation
* Copyright (c) 1996-1997 Cirrus Logic, Inc.
*
* $Log:   V:/CirrusLogic/CL54xx/NT40/Archive/Display/OVERLAY.C_v  $
*
\******************************************************************************/

#include "precomp.h"

#include "debug.h"
#include "panflags.h"
#include "dispint.h"

#if DIRECTDRAW
#include "overlay.h"


#ifdef DEBUG

#define DPF             Msg

extern void __cdecl Msg( LPSTR szFormat, ... );

#else

#define DPF             1 ? (void)0 : (void)

#endif // DEBUG


/* bandwidth matrix --------------------------------------*/



/* inline functions --------------------------------------*/

//static int __inline DrawEngineBusy(void)
//{
//    _outp(0x3ce,0x31);
//    return _inpw(0x3ce) & 0x100; /* Input a word -- test high byte. */
//}


/* defines -----------------------------------------------*/

#define MAX_STRETCH_SIZE     1024

#define IN_VBLANK            (_inp(0x3da) & 8)
#define CRTINDEX             0x3d4
#define DRAW_ENGINE_BUSY     (DrawEngineBusy())

#define PAKJR_GET_U(x) ((x & 0x00000FC0) >> 6)
#define PAKJR_GET_V(x) (x & 0x0000003F)

#define AVG_3_TO_1(u1, u2) ((u1 + ((u2 << 1) + u2)) >> 2) & 0x0000003F
#define AVG_2_TO_2(u1, u2) (((u1 << 1) + (u2 << 1)) >> 2) & 0x0000003F
#define AVG_1_2(u1,u2) u1
#define AVG_1_2_1(u1, u2, u3) ((u1 + (u2 << 1) + u3) >> 2) & 0x0000003F

#define MERGE_3_1(src, dst) (src & 0xFFFE0000) | (dst & 0x0001F000) | \
                            ((AVG_3_TO_1(PAKJR_GET_U(dst), PAKJR_GET_U(src))) << 6) | \
                            (AVG_3_TO_1(PAKJR_GET_V(dst), PAKJR_GET_V(src)))

#define MERGE_2_2(src, dst) (src & 0xFFC00000) | (dst & 0x003FF000) | \
                            ((AVG_2_TO_2(PAKJR_GET_U(dst), PAKJR_GET_U(src))) << 6) | \
                            (AVG_2_TO_2(PAKJR_GET_V(dst), PAKJR_GET_V(src)))

#define MERGE_1_3(src, dst) (src & 0xF8000000) | (dst & 0x07FFF000) | \
                            ((AVG_3_TO_1(PAKJR_GET_U(src), PAKJR_GET_U(dst))) << 6) | \
                            (AVG_3_TO_1(PAKJR_GET_V(src), PAKJR_GET_V(dst)))


#define MERGE_1_2_1(src1, src2, dst) ((src2 & 0x0001F000) << 15) | \
                                     ((src1 & 0x07FE0000) >> 5) | \
                                     ((dst &  0x0001F000)) | \
                                     ((AVG_1_2_1(PAKJR_GET_U(dst), PAKJR_GET_U(src1), PAKJR_GET_U(src2))) << 6) | \
                                     (AVG_1_2( PAKJR_GET_V(dst), PAKJR_GET_V(src1)))


#define MERGE_1_1_2(src1, src2, dst) ((src2 & 0x003FF000) << 10) | \
                                     ((src1 & 0xFE000000) >> 10) | \
                                     ((dst & 0xF8000000) >> 15) |  \
                                     ((AVG_1_2_1(PAKJR_GET_U(dst), PAKJR_GET_U(src2), PAKJR_GET_U(src1))) << 6) | \
                                     (AVG_1_2_1(PAKJR_GET_V(dst), PAKJR_GET_V(src2), PAKJR_GET_V(src1)))

#define MERGE_2_1_1(src1, src2, dst) ((src2 & 0x0001F000) << 15) | \
                                     ((src1 & 0xFE000000) >> 5) | \
                                     ((dst & 0x003FF000)) | \
                                     ((AVG_1_2_1(PAKJR_GET_U(src1), PAKJR_GET_U(dst), PAKJR_GET_U(src2))) << 6) | \
                                     (AVG_1_2_1(PAKJR_GET_V(src1), PAKJR_GET_V(dst), PAKJR_GET_V(src2)))

VOID NEAR PASCAL PackJRSpecialEnd_0_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_0_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_0_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_0_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_1_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_1_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_1_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_2_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_2_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_2_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_3_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_3_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);
VOID NEAR PASCAL PackJRSpecialEnd_3_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth);

/* global data -------------------------------------------*/

typedef void (NEAR PASCAL *NPALIGN)(LPDWORD, LPDWORD, DWORD, DWORD, WORD, WORD);
typedef void (NEAR PASCAL *NPEND)(LPDWORD , LPDWORD, WORD);
DWORD dwFOURCCs[5];

static NPEND npEnd[4][4] = {
                               (&PackJRSpecialEnd_0_0),
                               (&PackJRSpecialEnd_0_1),
                               (&PackJRSpecialEnd_0_2),
                               (&PackJRSpecialEnd_0_3),
                               (&PackJRSpecialEnd_0_0),
                               (&PackJRSpecialEnd_1_1),
                               (&PackJRSpecialEnd_1_2),
                               (&PackJRSpecialEnd_1_3),
                               (&PackJRSpecialEnd_0_0),
                               (&PackJRSpecialEnd_2_1),
                               (&PackJRSpecialEnd_2_2),
                               (&PackJRSpecialEnd_2_3),
                               (&PackJRSpecialEnd_0_0),
                               (&PackJRSpecialEnd_3_1),
                               (&PackJRSpecialEnd_3_2),
                               (&PackJRSpecialEnd_3_3),
                           };

/**********************************************************
*
*       Name:  PackJRBltAlignEnd
*
*       Module Abstract:
*       ----------------
*       Blts the last few PackJR pixels that are not properly
*       aligned (so it can't use the hardware BLTer).
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author:
*       Date:   10/06/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID PackJRBltAlignEnd (LPBYTE dwSrcStart, LPBYTE dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
DWORD dwHeightLoop;

   switch (dwWidth)
   {
      case  1:
         for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
         {
            *dwDstStart = MERGE_3_1(*dwDstStart, *dwSrcStart);
            (ULONG_PTR)dwSrcStart += wSrcPitch;
            (ULONG_PTR)dwDstStart += wDstPitch;
         }
         break;
      case 2:
         for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
         {
            *dwDstStart = MERGE_2_2(*dwDstStart, *dwSrcStart);
            (ULONG_PTR)dwSrcStart += wSrcPitch;
            (ULONG_PTR)dwDstStart += wDstPitch;
         }
         break;
      case 3:
         for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
         {
            *dwDstStart = MERGE_1_3(*dwDstStart, *dwSrcStart);
            (ULONG_PTR)dwSrcStart += wSrcPitch;
            (ULONG_PTR)dwDstStart += wDstPitch;
         }
         break;
   }
}


/**********************************************************
*
*       Name:  PackJRSpecialEnd functions
*
*       Module Abstract:
*       ----------------
*       Blts the last few PackJR pixels that are not properly
*       aligned (so it can't use the hardware BLTer).
*
*       There are 12 of these functions, based on alignment
*       and width
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author:
*       Date:   10/06/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID NEAR PASCAL PackJRSpecialEnd_0_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   //this should neverbe called
   return;
}


VOID NEAR PASCAL PackJRSpecialEnd_0_1(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart = MERGE_3_1(*dwDstStart, *dwSrcStart);
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_0_2(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart = MERGE_2_2(*dwDstStart, *dwSrcStart);
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_0_3(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart = MERGE_1_3(*dwDstStart, *dwSrcStart);
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_1_1(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0x07C00000) >>10) |
                     ((*dwDstStart & 0xFFFE0000)) |
                     ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                     (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_1_2(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0x07FFE000) >> 5) |
                     ((*dwDstStart & 0xFFC00000)) |
                     ((AVG_2_TO_2(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                     (AVG_2_TO_2(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_1_3(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0x07FFF000)) |
                     ((*dwDstStart & 0xF1000000)) |
                     ((AVG_3_TO_1(PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                     (AVG_3_TO_1(PAKJR_GET_V(*dwDstStart), PAKJR_GET_V(*dwSrcStart)));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_2_1(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0x0003E000) >> 5) |
                     ((*dwDstStart & 0xFFFE0000)) |
                     ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                     (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));

   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_2_2(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0xFFC00000) >> 10) |
                     ((*dwDstStart & 0xFFC00000)) |
                     ((AVG_2_TO_2(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                     (AVG_2_TO_2(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_2_3(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0xFFC00000) >> 10) |
                     ((*(dwSrcStart + 1) & 0x0001F000) << 10) |
                     ((*dwDstStart & 0xF1000000)) |
                     ((AVG_1_2_1(PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                     (AVG_1_2_1(PAKJR_GET_V(*dwDstStart), PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*(dwSrcStart+1))));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_3_1(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0xF1000000) >> 15) |
                     ((*dwDstStart & 0xFFFE0000)) |
                     ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                     (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_3_2(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0xF1000000) >> 15) |
                     ((*(dwSrcStart + 1) & 0x0001F000) << 5) |
                     ((*dwDstStart & 0xFFC00000)) |
                     ((AVG_1_2_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                     (AVG_1_2_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart), PAKJR_GET_V(*(dwSrcStart+1))));
   return;
}

VOID NEAR PASCAL PackJRSpecialEnd_3_3(LPDWORD dwSrcStart, LPDWORD dwDstStart, WORD wWidth)
{
   *dwDstStart++ =   ((*dwSrcStart & 0xF1000000) >> 15) |
                     ((*(dwSrcStart + 1) & 0x003FF000) << 5) |
                     ((*dwDstStart & 0xF1000000)) |
                     ((AVG_1_2_1(PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                     (AVG_1_2_1(PAKJR_GET_V(*dwDstStart), PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
   return;
}

/**********************************************************
*
*       Name:  PackJRAlign functions
*
*       Module Abstract:
*       ----------------
*       These functions handle bliting unaligned PackJR
*       data
*
*       There are 12 of these functions, based on alignment
*       of source and destination
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author:
*       Date:   10/06/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID NEAR PASCAL PackJRAlign_1_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_3_1(*dwSrcStart, *dwDstStart);
         dwWidthLoop-=3;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
            *dwDstStart++ = *dwSrcStart++;
         dwWidthLoop&=3;
      }
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}



VOID NEAR PASCAL PackJRAlign_1_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{


   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ =   ((*dwSrcStart & 0x07FE0000) << 5) |
                           ((*dwDstStart & 0x003FF000)) |
                            ((AVG_2_TO_2(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                            (AVG_2_TO_2(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
         dwWidthLoop-=2;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xF8000000) >> 15) |
                              ((*(dwSrcStart + 1) & 0x07FFF000) << 5) |
                              ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                              (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*(dwSrcStart+1))));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=3;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }
}

VOID NEAR PASCAL PackJRAlign_1_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ =   ((*dwSrcStart & 0x003E0000) << 10) |
                           ((*dwDstStart & 0x07FFF000)) |
                            ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                            (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
         dwWidthLoop--;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xFFC0000) >> 10) |
                              ((*(dwSrcStart+1) & 0x003FF000) << 10) |
                              ((AVG_2_TO_2(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                              (AVG_2_TO_2(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=2;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }


}

VOID NEAR PASCAL PackJRAlign_1_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
           *dwDstStart++ =   ((*dwSrcStart & 0xFFFE0000) >> 5) |
                             ((*(dwSrcStart+1) & 0x0001E000) << 15) |
                             ((AVG_3_TO_1(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                             (AVG_3_TO_1(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=1;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }
}

VOID NEAR PASCAL PackJRAlign_2_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_1_2_1(*dwSrcStart, *(dwSrcStart+1), *dwDstStart);
         dwWidthLoop-=3;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xFFFE0000) >> 5) |
                              ((*(dwSrcStart+1) & 0x0001F000) << 15) |
                              ((AVG_3_TO_1(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                              (AVG_3_TO_1(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=1;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_2_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_2_2(*dwSrcStart, *dwDstStart);
         dwWidthLoop-=2;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
            *dwDstStart++ = *dwSrcStart++;
         dwWidthLoop&=3;
      }
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_2_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ =   ((*dwSrcStart & 0x003E0000) << 10) |
                           ((*dwDstStart & 0x07FFF000)) |
                           ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                           (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
         dwWidthLoop--;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xF8000000) >> 15) |
                              ((*(dwSrcStart + 1) & 0x07FFF000) << 5) |
                              ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                              (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*(dwSrcStart+1))));
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=3;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_2_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
           *dwDstStart++ =   ((*dwSrcStart & 0xFFC00000) >> 10) |
                             ((*(dwSrcStart+1) & 0x003FF000) << 10) |
                             ((AVG_2_TO_2(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                             (AVG_2_TO_2(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=2;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }


}

VOID NEAR PASCAL PackJRAlign_3_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_1_1_2(*dwSrcStart, *(dwSrcStart+1), *dwDstStart);
         dwWidthLoop-=3;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
           *dwDstStart++ =   ((*(dwSrcStart+1) & 0x003FF000) << 10) |
                             ((*dwSrcStart & 0xFFC00000) >> 10) |
                             ((AVG_2_TO_2(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                             (AVG_2_TO_2(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=2;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }


}

VOID NEAR PASCAL PackJRAlign_3_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_2_1_1(*dwSrcStart, *(dwSrcStart+1), *dwDstStart);
         dwWidthLoop-=2;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
             *dwDstStart++ =   ((*dwSrcStart & 0xFFFE0000) >> 5) |
                               ((*(dwSrcStart+1) & 0x0001F000) << 15) |
                               ((AVG_3_TO_1(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                               (AVG_3_TO_1(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
             dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=1;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }


}

VOID NEAR PASCAL PackJRAlign_3_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ = MERGE_1_3(*dwSrcStart, *dwDstStart);
         dwWidthLoop-=1;
         dwSrcStart++;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
            *dwDstStart++ = *dwSrcStart++;
         dwWidthLoop&=3;
      }
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }


}

VOID NEAR PASCAL PackJRAlign_3_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xF8000000) >> 15) |
                              ((*(dwSrcStart + 1) & 0x07FFF000) << 5) |
                              ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                              (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*(dwSrcStart+1))));
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=3;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_0_1 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
          *dwDstStart++ =   ((*dwDstStart & 0x0001F000) >> 15) |
                            ((*dwSrcStart & 0x07FFF000) << 5) |
                            ((AVG_3_TO_1(PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                            (AVG_3_TO_1(PAKJR_GET_V(*dwDstStart), PAKJR_GET_V(*dwSrcStart)));
          dwWidthLoop-=3;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*dwSrcStart & 0xF8000000) >> 15) |
                              ((*(dwSrcStart + 1) & 0x07FFF000) << 5) |
                              ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*(dwSrcStart+1)))) << 6) | \
                              (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*(dwSrcStart+1))));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=3;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_0_2 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;


   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ =   ((*dwDstStart & 0x003FF000)) |
                           ((*dwSrcStart & 0x003FF000) << 10) |
                           ((AVG_2_TO_2(PAKJR_GET_U(*dwDstStart), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                           (AVG_2_TO_2(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwSrcStart)));
         dwWidthLoop-=2;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
            *dwDstStart++ =   ((*(dwSrcStart+1) & 0x003FF000) << 10) |
                              ((*dwSrcStart & 0xFFC00000) >> 10) |
                              ((AVG_2_TO_2(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                              (AVG_2_TO_2(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
            dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=2;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}

VOID NEAR PASCAL PackJRAlign_0_3 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

   DWORD dwHeightLoop, dwWidthLoop, i;

   for(dwHeightLoop = 0; dwHeightLoop < dwHeight; dwHeightLoop++)
   {
      dwWidthLoop = dwWidth;
      if (dwWidthLoop > 3)
      {
         *dwDstStart++ =   ((*dwDstStart & 0x07FFF000)) |
                           ((*dwSrcStart & 0x0001F000) << 15) |
                           ((AVG_3_TO_1(PAKJR_GET_U(*dwSrcStart), PAKJR_GET_U(*dwDstStart))) << 6) | \
                           (AVG_3_TO_1(PAKJR_GET_V(*dwSrcStart), PAKJR_GET_V(*dwDstStart)));
         dwWidthLoop--;
      }
      if (dwWidthLoop > 3)
      {
         for (i=0; i < (dwWidthLoop >> 2); i++)
         {
             *dwDstStart++ =   ((*dwSrcStart & 0xFFFE0000) >> 5) |
                               ((*(dwSrcStart+1) & 0x0001F000) << 15) |
                               ((AVG_3_TO_1(PAKJR_GET_U(*(dwSrcStart+1)), PAKJR_GET_U(*dwSrcStart))) << 6) | \
                               (AVG_3_TO_1(PAKJR_GET_V(*(dwSrcStart+1)), PAKJR_GET_V(*dwSrcStart)));
             dwSrcStart++;
         }
         dwWidthLoop&=3;
      }
      (ULONG_PTR)dwSrcStart+=1;
      if (dwWidthLoop != 0)
         npEnd[LOWORD((ULONG_PTR)dwSrcStart & 3)][LOWORD(dwWidthLoop)]
            (dwSrcStart, dwDstStart, LOWORD(dwWidthLoop));

      (ULONG_PTR)dwSrcStart+= (wSrcPitch - dwWidth + dwWidthLoop);
      (ULONG_PTR)dwDstStart+= (wDstPitch - dwWidth + dwWidthLoop);
   }

}


VOID NEAR PASCAL PackJRAlign_0_0 (LPDWORD dwSrcStart, LPDWORD dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{
   //This function should never be reached
   return;
}


/**********************************************************
*
*       Name:  PackJRBltAlign
*
*       Module Abstract:
*       ----------------
*       Blts PackJR data that is not DWORD aligned (so it
*       can't use the hardware BLTer).
*
*       Output Parameters:
*       ------------------
*       none
*
***********************************************************
*       Author:
*       Date:   10/06/96
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
*********************************************************/

VOID PackJRBltAlign (LPBYTE dwSrcStart, LPBYTE dwDstStart, DWORD dwWidth,
                     DWORD dwHeight, WORD wSrcPitch, WORD wDstPitch)
{

static NPALIGN npAlign[4][4] = {
                                   (&PackJRAlign_0_0),
                                   (&PackJRAlign_0_1),
                                   (&PackJRAlign_0_2),
                                   (&PackJRAlign_0_3),
                                   (&PackJRAlign_1_0),
                                   (&PackJRAlign_1_1),
                                   (&PackJRAlign_1_2),
                                   (&PackJRAlign_1_3),
                                   (&PackJRAlign_2_0),
                                   (&PackJRAlign_2_1),
                                   (&PackJRAlign_2_2),
                                   (&PackJRAlign_2_3),
                                   (&PackJRAlign_3_0),
                                   (&PackJRAlign_3_1),
                                   (&PackJRAlign_3_2),
                                   (&PackJRAlign_3_3),
                               };

   npAlign[LOWORD((ULONG_PTR)dwSrcStart) & 3][LOWORD((ULONG_PTR)dwDstStart & 3)]
         ((LPDWORD)((ULONG_PTR)dwSrcStart & 0xFFFFFFFC),
          (LPDWORD)((ULONG_PTR)dwDstStart & 0xFFFFFFFC),
          dwWidth, dwHeight, wSrcPitch, wDstPitch);

   return;

}

/**********************************************************
*
*       Name:  PanOverlay1_7555
*
*       Module Abstract:
*       ----------------
*       Save data for panning overlay window one.
*       Clip lpVideoRect to panning viewport.
*
*       Output Parameters:
*       ------------------
*       lpVideoRect is clipped to panning viewport.
*
***********************************************************
*       Author: Rita Ma
*       Date:   04/01/97
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
**********************************************************/
BOOL PanOverlay1_7555(
PDEV* ppdev,
LPRECTL lpVideoRect)
{
    BYTE*   pjPorts;

    pjPorts = ppdev->pjPorts;

    // Update panning viewport for the 32 bits DLL

    // return false if no overlay enable
//  if (ppdev->dwPanningFlag & OVERLAY_OLAY_SHOW)
//      return(FALSE);

    ppdev->rOverlaySrc.left = ppdev->sOverlay1.rSrc.left;
    ppdev->rOverlaySrc.top = ppdev->sOverlay1.rSrc.top;
    ppdev->rOverlaySrc.right = ppdev->sOverlay1.rSrc.right;
    ppdev->rOverlaySrc.bottom = ppdev->sOverlay1.rSrc.bottom;

    ppdev->rOverlayDest.left = ppdev->sOverlay1.rDest.left;
    ppdev->rOverlayDest.top = ppdev->sOverlay1.rDest.top;
    ppdev->rOverlayDest.right = ppdev->sOverlay1.rDest.right;
    ppdev->rOverlayDest.bottom = ppdev->sOverlay1.rDest.bottom;

    lpVideoRect->left = ppdev->sOverlay1.rDest.left;
    lpVideoRect->top = ppdev->sOverlay1.rDest.top;
    lpVideoRect->right = ppdev->sOverlay1.rDest.right;
    lpVideoRect->bottom = ppdev->sOverlay1.rDest.bottom;

    lpVideoRect->left -= ppdev->min_Xscreen;
    lpVideoRect->right -= ppdev->min_Xscreen;
    lpVideoRect->top -= ppdev->min_Yscreen;
    lpVideoRect->bottom -= ppdev->min_Yscreen;

    srcLeft_clip = ppdev->rOverlaySrc.left;
    srcTop_clip = ppdev->rOverlaySrc.top;

    bTop_clip = 0;

    //
    // clip lpVideoRect to panning viewport
    //
    if (lpVideoRect->left < 0)
    {
        srcLeft_clip = (LONG)ppdev->min_Xscreen - ppdev->rOverlayDest.left;
        bLeft_clip = 1;
        DISPDBG((0, "srcLeft_clip:%x", srcLeft_clip));
        lpVideoRect->left = 0;
    }
    if (lpVideoRect->top < 0)
    {
        srcTop_clip = (LONG)ppdev->min_Yscreen - ppdev->rOverlayDest.top;
        bTop_clip = 1;
        DISPDBG((0, "srcTop_clip:%x", srcTop_clip));
        lpVideoRect->top = 0;
    }
    if (lpVideoRect->right > (ppdev->max_Xscreen - ppdev->min_Xscreen)+1)
    {
        lpVideoRect->right = (ppdev->max_Xscreen - ppdev->min_Xscreen)+1;
    }
    if (lpVideoRect->bottom > (ppdev->max_Yscreen - ppdev->min_Yscreen)+1)
    {
        lpVideoRect->bottom =(ppdev->max_Yscreen - ppdev->min_Yscreen)+1;
    }

    return (TRUE);
} // VOID PanOverlay1_Init


/**********************************************************
*
*       Name:  PanOverlay1_Init
*
*       Module Abstract:
*       ----------------
*       Save data for panning overlay window one.
*       Clip lpVideoRect to panning viewport.
*
*       Output Parameters:
*       ------------------
*       lpVideoRect is clipped to panning viewport.
*
***********************************************************
*       Author: Rita Ma
*       Date:   04/01/97
*
*       Revision History:
*       -----------------
*       WHO             WHEN     WHAT/WHY/HOW
*       ---             ----     ------------
*
**********************************************************/
VOID PanOverlay1_Init(PDEV* ppdev,PDD_SURFACE_LOCAL lpSurface,
       LPRECTL lpVideoRect, LPRECTL lpOverlaySrc, LPRECTL lpOverlayDest,
       DWORD dwFourcc, WORD wBitCount)
{

    //
    // save these for panning code to use
    //
    ppdev->lPitch_gbls = lpSurface->lpGbl->lPitch;
    ppdev->fpVidMem_gbls = lpSurface->lpGbl->fpVidMem;
//    ppdev->dwReserved1_lcls = lpSurface->dwReserved1;
    ppdev->sOverlay1.dwFourcc = dwFourcc;
    ppdev->sOverlay1.wBitCount= wBitCount;
    ppdev->sOverlay1.lAdjustSource = 0L;
    ppdev->dwPanningFlag |= OVERLAY_OLAY_SHOW;

    ppdev->sOverlay1.rDest.left  = lpOverlayDest->left;
    ppdev->sOverlay1.rDest.right = lpOverlayDest->right;
    ppdev->sOverlay1.rDest.top   = lpOverlayDest->top;
    ppdev->sOverlay1.rDest.bottom= lpOverlayDest->bottom;

    ppdev->sOverlay1.rSrc.left   = lpOverlaySrc->left;
    ppdev->sOverlay1.rSrc.right  = lpOverlaySrc->right;
    ppdev->sOverlay1.rSrc.top    = lpOverlaySrc->top;
    ppdev->sOverlay1.rSrc.bottom = lpOverlaySrc->bottom;

    lpVideoRect->left   = lpOverlayDest->left;
    lpVideoRect->right  = lpOverlayDest->right;
    lpVideoRect->top    = lpOverlayDest->top;
    lpVideoRect->bottom = lpOverlayDest->bottom;

    //
    // adjust to panning viewport
    //
    lpVideoRect->left   -= (LONG)ppdev->min_Xscreen;
    lpVideoRect->right  -= (LONG)ppdev->min_Xscreen;
    lpVideoRect->top    -= (LONG)ppdev->min_Yscreen;
    lpVideoRect->bottom -= (LONG)ppdev->min_Yscreen;

    srcLeft_clip = lpOverlaySrc->left;
    srcTop_clip = lpOverlaySrc->top;
    bLeft_clip = 0;
    bTop_clip = 0;

    //
    // clip lpVideoRect to panning viewport
    //
    if (lpVideoRect->left < 0)
    {
        srcLeft_clip = (LONG)ppdev->min_Xscreen - lpOverlayDest->left;
        bLeft_clip = 1;
        DISPDBG((0, "srcLeft_clip:%x", srcLeft_clip));
        lpVideoRect->left = 0;
    }
    if (lpVideoRect->top < 0)
    {
        srcTop_clip = (LONG)ppdev->min_Yscreen - lpOverlayDest->top;
        bTop_clip = 1;
        DISPDBG((0, "srcTop_clip:%x", srcTop_clip));
        lpVideoRect->top = 0;
    }
    if (lpVideoRect->right > (ppdev->max_Xscreen - ppdev->min_Xscreen)+1)
    {
        lpVideoRect->right = (ppdev->max_Xscreen - ppdev->min_Xscreen)+1;
    }
    if (lpVideoRect->bottom > (ppdev->max_Yscreen - ppdev->min_Yscreen)+1)
    {
        lpVideoRect->bottom =(ppdev->max_Yscreen - ppdev->min_Yscreen)+1;
    }

} // VOID PanOverlay1_Init


#endif // endif DIRECTDRAW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\overlay.h ===
/******************************************************************************\
*
* Copyright (c) 1996-1997  Microsoft Corporation.
* Copyright (c) 1996-1997  Cirrus Logic, Inc.
*
* Module Name:
*
*    O    V    E    R    L    A    Y  .  H
*
* This module contains common function prototypes and defines needed for
* overlay support
*
* Revision History:
*
* tao1    10-22-96  Added direct draw support for CL-GD7555
* myf1    03-12-97  Change new bandwidth check for CL-GD755X
* myf2    03-31-97  Added direct draw support VPE
* chu01   03-26-97  Bandwidth equation for the CL-GD5480
* chu02   04-02-97  More overlay capabilities
*
\******************************************************************************/


/* FOURCC definitions ------------------------------------*/

#define FOURCC_YUY2         '2YUY'              // YUY2
#define FOURCC_YUV422       'YVYU'              // UYVY
#define FOURCC_PACKJR       'RJLC'              // CLJR
#define FOURCC_YUVPLANAR    'LPLC'              // CLPL
#define FOURCC_YUV420       'LPLC'              // CLPL


/* surface flags -----------------------------------------*/

#define OVERLAY_FLG_BEGIN_ACCESS      (DWORD)0x00000001
#define OVERLAY_FLG_ENABLED           (DWORD)0x00000002
#define OVERLAY_FLG_CONVERT_PACKJR    (DWORD)0x00000004
#define OVERLAY_FLG_MUST_RASTER       (DWORD)0x00000008
#define OVERLAY_FLG_TWO_MEG           (DWORD)0x00000010
#define OVERLAY_FLG_CHECK             (DWORD)0x00000020
#define OVERLAY_FLG_COLOR_KEY         (DWORD)0x00000040
#define OVERLAY_FLG_INTERPOLATE       (DWORD)0x00000080
#define OVERLAY_FLG_OVERLAY           (DWORD)0x00000100
#define OVERLAY_FLG_YUV422            (DWORD)0x00000200
#define OVERLAY_FLG_PACKJR            (DWORD)0x00000400
#define OVERLAY_FLG_USE_OFFSET        (DWORD)0x00000800
#define OVERLAY_FLG_YUVPLANAR         (DWORD)0x00001000
#define OVERLAY_FLG_SRC_COLOR_KEY     (DWORD)0x00002000
#define OVERLAY_FLG_DECIMATE          (DWORD)0x00004000
#define OVERLAY_FLG_CAPTURE           (DWORD)0x00008000           //myf2, VPE

// chu02
#define OVERLAY_FLG_DECIMATE4         (DWORD)0x00008000  
#define OVERLAY_FLG_YUY2              (DWORD)0x00010000
#define OVERLAY_FLG_VW_PRIMARY        (DWORD)0x00020000
#define OVERLAY_FLG_VW_SECONDARY      (DWORD)0x00040000  
#define OVERLAY_FLG_TWO_VIDEO         (DWORD)0x00200000  

/* display types (for portables) -------------------------*/

#define DTYPE_UNKNOWN                  (int)-1
#define DTYPE_640_COLOR_SINGLE_STN     0
#define DTYPE_640_MONO_DUAL_STN        1
#define DTYPE_640_COLOR_DUAL_STN       2
#define DTYPE_640_COLOR_SINGLE_TFT     3
#define DTYPE_640_COLOR_DUAL_STN_SHARP 4
#define DTYPE_800_COLOR_DUAL_STN       6
#define DTYPE_800_COLOR_SINGLE_TFT     7
#define DTYPE_CRT                      32767

//myf32 #define MIN_OLAY_WIDTH  4      //minium overlay window width

#define OVERLAY_OLAY_SHOW       0x100     //overlay is hidden iff bit not set
#define OVERLAY_OLAY_REENABLE   0x200     //overlay was fully clipped, need reenabling


VOID GetFormatInfo(PDEV* ppdev, LPDDPIXELFORMAT lpFormat, LPDWORD lpFourcc,
                   LPWORD lpBitCount);
VOID RegInitVideo(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface);
VOID DisableOverlay_544x(PDEV* ppdev);
VOID EnableOverlay_544x(PDEV* ppdev);
VOID RegMoveVideo(PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface);
VOID CalculateStretchCode (LONG srcLength, LONG dstLength, LPBYTE code);
BYTE GetThresholdValue(VOID);
BOOL MustLineReplicate (PDEV* ppdev, PDD_SURFACE_LOCAL lpSurface, WORD wVideoDepth);
BOOL IsSufficientBandwidth(PDEV* ppdev, WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags);
LONG GetVCLK(PDEV* ppdev);
VOID EnableStartAddrDoubleBuffer(PDEV* ppdev);
DWORD GetCurrentVLine(PDEV* ppdev);
VOID ClearAltFIFOThreshold_544x(PDEV * ppdev);

// chu01
BOOL Is5480SufficientBandwidth(PDEV* ppdev, WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags);

// curs //tao1
typedef struct _BWREGS
{
     BYTE bSR2F;
     BYTE bSR32;
     BYTE bSR34;
     BYTE bCR42;

     BYTE bCR51;
     BYTE bCR5A;
     BYTE bCR5D;
     BYTE bCR5F;

}BWREGS, FAR *LPBWREGS;

BWREGS Regs;    //myf33

//myf33 for panning scrolling enable & DirectDraw overlay use
DWORD srcLeft_clip;
DWORD srcTop_clip;
BOOL  bLeft_clip;
BOOL  bTop_clip;
//myf33 end

VOID RegInit7555Video (PDEV *,PDD_SURFACE_LOCAL);
VOID RegMove7555Video (PDEV *,PDD_SURFACE_LOCAL);
VOID DisableVideoWindow    (PDEV * );
VOID EnableVideoWindow     (PDEV * );
VOID ClearAltFIFOThreshold (PDEV * );
BOOL Is7555SufficientBandwidth(PDEV* ppdev, WORD wVideoDepth, LPRECTL lpSrc, LPRECTL lpDest, DWORD dwFlags);
DWORD Get7555MCLK (PDEV *);
BOOL IsDSTN(PDEV * );
BOOL IsXGA (PDEV * );
VOID PanOverlay1_Init(PDEV *,PDD_SURFACE_LOCAL, LPRECTL, LPRECTL, LPRECTL,
        DWORD, WORD);           //myf33, DD init overlay data
VOID PanOverlay7555 (PDEV *,LONG ,LONG);        //myf33
BOOL PanOverlay1_7555(PDEV *,LPRECTL);          //myf33, PanOverlay7555 call

//      end curs         //tao1

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\precomp.h ===
/******************************************************************************\
*
* $Workfile:   precomp.h  $
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/precomp.h_v  $
 * 
 *    Rev 1.2   18 Dec 1996 13:44:12   PLCHU
 *  
 * 
 *    Rev 1.1   Oct 10 1996 15:38:50   unknown
 *  
* 
*    Rev 1.2   12 Aug 1996 16:48:28   frido
* Added NT 3.5x/4.0 auto detection.
* 
*    Rev 1.1   03 Jul 1996 13:50:42   frido
* Added WINERROR.H include file.
*
*    chu01  12-16-96   Enable color correction
*
\******************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#if (_WIN32_WINNT >= 0x0400)
    #include <windef.h>
    #include <winerror.h>
    #include <wingdi.h>
#else
    #include <windows.h>
    #include <memory.h>
    #include <stdio.h>
    #include <stdlib.h>
#endif
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>

#include <math.h>

#define  ENABLE_BIOS_ARGUMENTS

//
// DBG_STRESS_FAILURE turns on debugging code related to the stress failure
//
#define  DBG_STRESS_FAILURE 0

//
// chu01 : GAMMACORRECT
//
#include "clioctl.h"         

#include "lines.h"
#include "hw.h"
#include "driver.h"
#include "debug.h"

//
// chu01 : GAMMACORRECT
//
//#define  GAMMACORRECT      1     // 1 : Enable; 0 : Disable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\pointer.c ===
/******************************************************************************\
*
* $Workfile:   pointer.c  $
*
* Contains the pointer management functions.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/pointer.c_v  $
 *
 *    Rev 1.5   07 Apr 1997 11:38:16   PLCHU
 *
 *
 *    Rev 1.4   Apr 03 1997 15:39:00   unknown
 *
 *
 *    Rev 1.3   28 Mar 1997 16:09:20   PLCHU
 *
*
*    Rev 1.2   12 Aug 1996 16:54:36   frido
* Added NT 3.5x/4.0 auto detection.
* Removed unaccessed local variables.
*
*    Rev 1.1   08 Aug 1996 12:54:54   frido
*       bank#1  Removed banking in memory mapped I/O which is always linear.
*    bank#1    Removed banking in memory mapped I/O which is always linear.
*
* myf0 : 08-19-96  added 85hz supported
* myf1 : 08-20-96  supported panning scrolling
* myf2 : 08-20-96 : fixed hardware save/restore state bug for matterhorn
* myf3 : 09-01-96 : Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4 : 09-01-96 : patch Viking BIOS bug, PDR #4287, begin
* myf5 : 09-01-96 : Fixed PDR #4365 keep all default refresh rate
* myf6 : 09-17-96 : Merged Desktop SRC1001 & MINI102
* myf7 : 09-19-96 : Fixed exclude 60Hz refresh rate selected
* myf8 :*09-21-96*: May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9 : 09-21-96 : 8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809:09-25-96 : fixed dstn panel icon corrupted
* ms923 :09-25-96 : merge MS-923 Disp.zip code
* myf10 :09-26-96 : Fixed DSTN reserved half-frame buffer bug.
* myf11 :09-26-96 : Fixed 755x CE chip HW bug, access ramdac before disable HW
*                   icons and cursor
* myf12 :10-01-96 : Supported Hot Key switch display
* myf13 :10-02-96 : Fixed Panning scrolling (1280x1024x256) bug y < ppdev->miny
* myf14 :10-15-96 : Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15 :10-16-96 : Fixed disable memory mapped IO for 754x, 755x
* myf16 :10-22-96 : Fixed PDR #6933,panel type set different demo board setting
* tao1 : 10-21-96 : Added 7555 flag for Direct Draw support.
* smith :10-22-96 : Disable Timer event, because sometimes creat PAGE_FAULT or
*                   IRQ level can't handle
* myf17 :11-04-96 : Added special escape code must be use 11/5/96 later NTCTRL,
*                   and added Matterhorn LF Device ID==0x4C
* myf18 :11-04-96 : Fixed PDR #7075,
* myf19 :11-06-96 : Fixed Vinking can't work problem, because DEVICEID = 0x30
*                   is different from data book (CR27=0x2C)
* pat04: 12-20-96 : Supported NT3.51 software cursor with panning scrolling
* pat07:          : Take care of disappearing hardware cursor during modeset
* myf31 :02-24-97 : Fixed enable HW Video, panning scrolling enable,screen move
*                   video window have follow moving
* myf33 :03-06-97 : Fixed switch S/W cursor, have 2 cursor shape, PDR#8781,8804
* myf32 :03-13-97 : Fixed panning screen moving strength problem, PDR#8873
* pat08 :04-01-97 : Corrected SWcursor bugs due to code-merge. See also
*                   PDR #8949 & #8910
*
\******************************************************************************/

#include "precomp.h"
//crus begin
//myf17    #define PANNING_SCROLL           //myf1

#define LCD_type        1    //myf12
#define CRT_type        2    //myf12
#define SIM_type        3    //myf12

#if (_WIN32_WINNT >= 0x0400)

VOID PanOverlay7555 (PDEV *,LONG ,LONG);        //myf33
#endif
//crus end

ULONG SetMonoHwPointerShape(
    SURFOBJ    *pso,
    SURFOBJ    *psoMask,
    SURFOBJ    *psoColor,
    XLATEOBJ   *pxlo,
    LONG        xHot,
    LONG        yHot,
    LONG        x,
    LONG        y,
    RECTL      *prcl,
    FLONG       fl);


VOID vSetPointerBits(
PPDEV   ppdev,
LONG    xAdj,
LONG    yAdj)
{
    volatile PULONG  pulXfer;
    volatile PULONG  pul;

//ms923  LONG   lDelta = ppdev->lDeltaPointer;
    LONG    lDelta = 4;
    BYTE    ajAndMask[32][4];
    BYTE    ajXorMask[32][4];
    BYTE    ajHwPointer[256];
    PBYTE   pjAndMask;
    PBYTE   pjXorMask;

    LONG    cx;
    LONG    cy;
    LONG    cxInBytes;

    LONG    ix;
    LONG    iy;
    LONG    i;
    LONG    j;

#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    // Clear the buffers that will hold the shifted masks.

    DISPDBG((2,"vSetPointerBits\n "));
    memset(ajAndMask, 0xff, 128);
    memset(ajXorMask, 0, 128);

    cx = ppdev->sizlPointer.cx;
    cy = ppdev->sizlPointer.cy - yAdj;

    cxInBytes = cx / 8;

    // Copy the AND Mask into the shifted bits AND buffer.
    // Copy the XOR Mask into the shifted bits XOR buffer.

    yAdj *= lDelta;

    pjAndMask  = (ppdev->pjPointerAndMask + yAdj);
    pjXorMask  = (ppdev->pjPointerXorMask + yAdj);

    for (iy = 0; iy < cy; iy++)
    {
        // Copy over a line of the masks.

        for (ix = 0; ix < cxInBytes; ix++)
        {
            ajAndMask[iy][ix] = pjAndMask[ix];
            ajXorMask[iy][ix] = pjXorMask[ix];
        }

        // point to the next line of the masks.

        pjAndMask += lDelta;
        pjXorMask += lDelta;
    }

    // At this point, the pointer is guaranteed to be a single
    // dword wide.

    if (xAdj != 0)
    {
        ULONG ulAndFillBits;
        ULONG ulXorFillBits;

        ulXorFillBits = 0xffffffff << xAdj;
        ulAndFillBits = ~ulXorFillBits;

        //
        // Shift the pattern to the left (in place)
        //

        DISPDBG((2, "xAdj(%d)", xAdj));

        for (iy = 0; iy < cy; iy++)
        {
            ULONG   ulTmpAnd = *((PULONG) (&ajAndMask[iy][0]));
            ULONG   ulTmpXor = *((PULONG) (&ajXorMask[iy][0]));

            BSWAP(ulTmpAnd);
            BSWAP(ulTmpXor);

            ulTmpAnd <<= xAdj;
            ulTmpXor <<= xAdj;

            ulTmpAnd |= ulAndFillBits;
            ulTmpXor &= ulXorFillBits;

            BSWAP(ulTmpAnd);
            BSWAP(ulTmpXor);

            *((PULONG) (&ajAndMask[iy][0])) = ulTmpAnd;
            *((PULONG) (&ajXorMask[iy][0])) = ulTmpXor;
        }
    }

    //
    // Convert the masks to the hardware pointer format
    //

    i = 0;      // AND mask
    j = 128;    // XOR mask

    for (iy = 0; iy < 32; iy++)
    {
        for (ix = 0; ix < 4; ix++)
        {
            ajHwPointer[j++] = ~ajAndMask[iy][ix];
            ajHwPointer[i++] =  ajXorMask[iy][ix];
        }
    }

    //
    // Download the pointer
    //

    if (ppdev->flCaps & CAPS_MM_IO)
    {
        BYTE * pjBase = ppdev->pjBase;

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, 4);

//pat04, begin
//#if 0
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL
     if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
         (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
         (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))
        CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
#endif
#endif
//#endif  //0
//pat04, end

        CP_MM_XCNT(ppdev, pjBase, (4 - 1));
        CP_MM_YCNT(ppdev, pjBase, (64 - 1));
        CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA);
        CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->cjPointerOffset);
        CP_MM_START_BLT(ppdev, pjBase);
    }
    else
    {
        BYTE * pjPorts = ppdev->pjPorts;

#if BANKING //bank#1
                ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif
        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        CP_IO_DST_Y_OFFSET(ppdev, pjPorts, 4);
        CP_IO_XCNT(ppdev, pjPorts, (4 - 1));
        CP_IO_YCNT(ppdev, pjPorts, (64 - 1));
        CP_IO_BLT_MODE(ppdev, pjPorts, SRC_CPU_DATA);
        CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
        CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ppdev->cjPointerOffset);
        CP_IO_START_BLT(ppdev, pjPorts);
    }

    pulXfer = ppdev->pulXfer;
    pul = (PULONG) ajHwPointer;

    //
    // Disable the pointer (harmless if it already is)
    //

    for (i = 0; i < 64; i++)
    {
        CP_MEMORY_BARRIER();
        WRITE_REGISTER_ULONG(pulXfer, *pul);    // [ALPHA - sparse]
        pulXfer++;
        pul++;
        //*pulXfer++ = *pul++;
    }
    CP_EIEIO();
}

//crus begin
/***********************************************************\
* CirrusPanning
*
* caculate x, y
\************************************************************/
//myf1, begin
#ifdef PANNING_SCROLL
VOID CirrusPanning(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PPDEV   ppdev = (PPDEV) pso->dhpdev;
    PBYTE   pjPorts = ppdev->pjPorts;

    UCHAR   CR13, CR1B, CR1D, CR17;
    UCHAR   Sflag = FALSE;      //myf31
    ULONG   Mem_addr;
    USHORT  h_pitch, X_shift;

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x13);
    CR13 = CP_IN_BYTE(pjPorts, CRTC_DATA);
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1B);
    CR1B = CP_IN_BYTE(pjPorts, CRTC_DATA);

    //myf32 : fixed PDR #8873, panning enable, move mouse across max_Yscreen,
    // screen moving is strength
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x17);             //myf32
    CR17 = CP_IN_BYTE(pjPorts, CRTC_DATA) & 0x40;       //myf32
    h_pitch = (USHORT)((((CR1B & 0x10) << 4) + CR13));  //myf32
//  if (CR17 == 0)
        h_pitch <<= 1;

    if (ppdev->cBitsPerPixel == 8)
       X_shift = 2;             // (div 4)
    else if (ppdev->cBitsPerPixel == 16)
       X_shift = 1;             // (div 2)
    else if (ppdev->cBitsPerPixel == 24)
       X_shift = 4;             // (div 16)
    else if (ppdev->cBitsPerPixel == 32)
       X_shift = 0;             // (div 1)

    if ((y > ppdev->max_Yscreen))
    {
       Sflag = TRUE;            //myf31
       ppdev->min_Yscreen = y - (ppdev->Vres - 1);
       ppdev->max_Yscreen = y;
       if (x < ppdev->min_Xscreen)
       {
          ppdev->min_Xscreen = x;
          ppdev->max_Xscreen = x + (ppdev->Hres - 1);
       }
       if (x > ppdev->max_Xscreen)
       {
          ppdev->min_Xscreen = x - (ppdev->Hres - 1);
          ppdev->max_Xscreen = x;
       }
    DISPDBG((4,"CURSOR DOWN : (%x, %x),\t %x, %x, %x, %x\n",
         x, y,  ppdev->min_Xscreen, ppdev->max_Xscreen,
         ppdev->min_Yscreen, ppdev->max_Yscreen));
    }
    else if ((y < ppdev->min_Yscreen))
    {
       Sflag = TRUE;            //myf31
       ppdev->min_Yscreen = y;
//myf13   ppdev->max_Yscreen = (ppdev->Vres - 1) - y;
       ppdev->max_Yscreen = (ppdev->Vres - 1) + y;      //myf13
       if (x < ppdev->min_Xscreen)  //left
       {
          ppdev->min_Xscreen = x;
          ppdev->max_Xscreen = x + (ppdev->Hres - 1);
       }
       if (x > ppdev->max_Xscreen)
       {
          ppdev->min_Xscreen = x - (ppdev->Hres - 1);
          ppdev->max_Xscreen = x;
       }
    DISPDBG((4,"CURSOR DOWN : (%x, %x),\t %x, %x, %x, %x\n",
         x, y,  ppdev->min_Xscreen, ppdev->max_Xscreen,
         ppdev->min_Yscreen, ppdev->max_Yscreen));
    }
    else if ((y >= ppdev->min_Yscreen) && (y <= ppdev->max_Yscreen))
    {
       if (x < ppdev->min_Xscreen)
       {
          ppdev->min_Xscreen = x;
          ppdev->max_Xscreen = x + (ppdev->Hres - 1);
          Sflag = TRUE;            //myf31
       }
       if (x > ppdev->max_Xscreen)
       {
          ppdev->min_Xscreen = x - (ppdev->Hres - 1);
          ppdev->max_Xscreen = x;
          Sflag = TRUE;            //myf31
       }
    }
    DISPDBG((4,"CURSOR DOWN : (%x, %x),\t %x, %x, %x, %x\n",
         x, y,  ppdev->min_Xscreen, ppdev->max_Xscreen,
         ppdev->min_Yscreen, ppdev->max_Yscreen));

    if (ppdev->cBitsPerPixel == 24)
    {
        Mem_addr = ((ULONG)(h_pitch * ppdev->min_Yscreen)) +
                    (((ULONG)(ppdev->min_Xscreen >> X_shift)) * 12);
    }
    else
    {
        Mem_addr = ((ULONG)(h_pitch * ppdev->min_Yscreen)) +
                    (ULONG)(ppdev->min_Xscreen >> X_shift);
    }

    CR13 = (UCHAR)((Mem_addr >> 16) & 0x00FF);
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1D);
    CR1D = CP_IN_BYTE(pjPorts, CRTC_DATA) & 0x7F;

    CR1D |= ((CR13 << 4) & 0x80);
    CR1B &= 0xF2;
    CR13 &= 0x07;
    CR1B |= (CR13 & 0x01);
    CR1B |= ((CR13 << 1) & 0x0C);

//myf32 for visibile bug, change the output reg sequence
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1B);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, (UCHAR)(CR1B));
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x1D);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, (UCHAR)(CR1D));

    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x0C);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, (UCHAR)(Mem_addr >> 8));
    CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x0D);
    CP_OUT_BYTE(pjPorts, CRTC_DATA, (UCHAR)(Mem_addr & 0xFF));

    x -= ppdev->min_Xscreen;
    y -= ppdev->min_Yscreen;

#if (_WIN32_WINNT >= 0x0400)
    if (Sflag)                                  //myf31
        PanOverlay7555(ppdev,x,y);              //myf31
#endif

}
#endif          //ifdef PANNING_SCROLL
//myf1, end
//crus end

//pat04, begin

// Set Color Pointer Bits

//#if 0   //0, pat04
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL
// #if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
//      (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
//      (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID)) )

VOID vSetCPointerBits(
PPDEV   ppdev,
LONG    xAdj,
LONG    yAdj)
{
    volatile PULONG  pulXfer;
    volatile PULONG  pul;

    LONG    lDelta = 4;
    BYTE    ajAndMask[32][4];
    BYTE    ajXorMask[32][4];
    BYTE    ajHwPointer[256];
    PBYTE   pjAndMask;
    PBYTE   pjXorMask;

    LONG    cx;
    LONG    cy;
    LONG    cxInBytes;

    LONG    ix;
    LONG    iy;
    LONG    i;
    LONG    j;
    BYTE * pjPorts = ppdev->pjPorts; //ppp

    // Clear the buffers that will hold the shifted masks.

    DISPDBG((2,"vSetCPointerBits\n "));
    memset(ajAndMask, 0xff, 128);

    cx = ppdev->sizlPointer.cx;
    cy = ppdev->sizlPointer.cy - yAdj;

    cxInBytes = cx / 8;

    // Copy the AND Mask into the shifted bits AND buffer.


    yAdj *= lDelta;

    pjAndMask  = (ppdev->pjPointerAndMask + yAdj);
    pjXorMask  = (ppdev->pjPointerXorMask + yAdj);

    for (iy = 0; iy < cy; iy++)
    {
        // Copy over a line of the masks.

        for (ix = 0; ix < cxInBytes; ix++)
            ajAndMask[iy][ix] = pjAndMask[ix];

        pjAndMask += lDelta;

    }

    // At this point, the pointer is guaranteed to be a single
    // dword wide.


    //
    // Convert the masks to the hardware pointer format
    //


    j = 0;

    for (iy = 0; iy < 32; iy++)
    {
        for (ix = 0; ix < 4; ix++)
           ajHwPointer[j++] = ~ajAndMask[iy][ix];

    }

    //
    // Download the pointer
    //



   if (ppdev->flCaps & CAPS_MM_IO) {

        BYTE * pjBase = ppdev->pjBase;

        // if !24bit. 24bit color expand requires 2 pass (for 7555)
        if (ppdev->cBpp != 3) {
          CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
          CP_MM_FG_COLOR(ppdev, pjBase, 0x00000000);
          CP_MM_BG_COLOR(ppdev, pjBase, 0xFFFFFFFF);
          CP_MM_DST_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
          CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
          CP_MM_YCNT(ppdev, pjBase, 31);
          CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA | DIR_TBLR | ENABLE_COLOR_EXPAND | ppdev->jModeColor);
          CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
          CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjPointerAndCMask->xy);
          CP_MM_START_BLT(ppdev, pjBase);
        } // if (ppdev->cBpp != 3)

        else { // 24bit stuff

          // Save 1 pass, since we are generating monocrome masks.
          CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
          CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
          CP_MM_ROP(ppdev,pjBase, CL_WHITENESS);
          CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
          CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
          CP_MM_YCNT(ppdev, pjBase, 31);
          CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjPointerAndCMask->xy);
          CP_MM_START_BLT(ppdev, pjBase);

          CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
          CP_MM_FG_COLOR(ppdev, pjBase, 0x00000000);
          CP_MM_BG_COLOR(ppdev, pjBase, 0xFFFFFFFF);
          CP_MM_DST_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
          CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
          CP_MM_YCNT(ppdev, pjBase, 31);
          CP_MM_BLT_MODE(ppdev, pjBase, SRC_CPU_DATA | DIR_TBLR | ENABLE_COLOR_EXPAND | ppdev->jModeColor | ENABLE_TRANSPARENCY_COMPARE);
          CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
          CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjPointerAndCMask->xy);
          CP_MM_START_BLT(ppdev, pjBase);
        } // else

       pulXfer = ppdev->pulXfer;
       pul = (PULONG) ajHwPointer;


       for (i = 0; i < 32; i++)
       {
         CP_MEMORY_BARRIER();
         WRITE_REGISTER_ULONG(pulXfer, *pul);
         pulXfer++;
         pul++;

       }

       CP_EIEIO();

    } // if MMIO

    else { // IO stuff (754x stuff)


       // 7548 HW BUG ?
       // system->screen with color expand will sometimes cause
       // the system to hang. Break it into 2 pass, and the problem
       // went away

       ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
       CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
       CP_IO_DST_Y_OFFSET(ppdev, pjPorts, 4);
       CP_IO_XCNT(ppdev, pjPorts, (4 - 1));
       CP_IO_YCNT(ppdev, pjPorts, (32 - 1));
       CP_IO_BLT_MODE(ppdev, pjPorts, SRC_CPU_DATA);
       CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
       CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ppdev->cjPointerOffset);
       CP_IO_START_BLT(ppdev, pjPorts);

       pulXfer = ppdev->pulXfer;
       pul = (PULONG) ajHwPointer;

       for (i = 0; i < 32; i++) {

         CP_MEMORY_BARRIER();
         WRITE_REGISTER_ULONG(pulXfer, *pul);    // [ALPHA - sparse]
         pulXfer++;
         pul++;
      }

      CP_EIEIO();

      // Color Expand monocrome data into x-y DBB.

      CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
      CP_IO_FG_COLOR(ppdev, pjPorts, 0x00000000);
      CP_IO_BG_COLOR(ppdev, pjPorts, 0xFFFFFFFF);
      CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, 4); //
      CP_IO_DST_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine);
      CP_IO_XCNT(ppdev, pjPorts, ppdev->xcount);
      CP_IO_YCNT(ppdev, pjPorts, 31);
      CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
      CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR | ENABLE_COLOR_EXPAND | ppdev->jModeColor);
      CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->cjPointerOffset);
      CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ppdev->pjPointerAndCMask->xy);
      CP_IO_START_BLT(ppdev, pjPorts);
      CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

  } // else

} // vSetCPointerBits( )


#endif
#endif
//#endif  //0

//pat04, end

/******************************Public*Routine******************************\
* DrvMovePointer
*
* Move the HW pointer to a new location on the screen.
\**************************************************************************/

VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PPDEV   ppdev = (PPDEV) pso->dhpdev;
    PBYTE   pjPorts = ppdev->pjPorts;

    FLONG   fl;
    LONG    xAdj = 0;
    LONG    yAdj = 0;

//crus
    LONG    deltaX;             //myf15
    LONG    deltaY;             //myf15

//pat04, begin
//#if 0
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL
    BYTE  * pjBase = ppdev->pjBase;
    static  specialcase = 0;
    LONG    tmpaddress;
    LONG    clipping  ;
    LONG    clippingy ;
    UCHAR   ChipID;
#endif
#endif
//#endif  //0
//pat04, end

    DISPDBG((4,"DrvMovePointer to (%d,%d)", x, y));

//crus
#if 0
    BYTE    SR0A, SR14, savSEQidx;      //myf12
    SHORT   Displaytype;                //myf12


    if (!(ppdev->bBlockSwitch))            //not block switch
    {
        savSEQidx = CP_IN_BYTE(pjPorts, SR_INDEX);
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x14);
        SR14 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_INDEX, (SR14 | 0x04));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0x09);
        SR0A = CP_IN_BYTE(pjPorts, SR_DATA);

        Displaytype = ((SR14 & 0x02) | (SR0A & 0x01));
        if (Displaytype == 0)
            Displaytype = LCD_type;
        else if (Displaytype == 1)
            Displaytype = CRT_type;
        else if (Displaytype == 3)
            Displaytype = SIM_type;

        if (ppdev->bDisplaytype != Displaytype)
        {
            ppdev->bDisplaytype = Displaytype;
//          SwitchDisplayDevice();
/*
            savCRTidx = CP_IN_BYTE(pjPorts, CRTC_INDEX);
            if (ppdev->ulChipID & CL754x)
            {
                CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x20);
                lcd = CP_IN_BYTE(pjPorts, CRTC_DATA);
            }
            else if (ppdev->ulChipID & CL755x)
            {
                CP_OUT_BYTE(pjPorts, CRTC_INDEX, 0x80);
                lcd = CP_IN_BYTE(pjPorts, CRTC_DATA);
            }
            CP_OUT_BYTE(pjPorts, CRTC_INDEX, savCRTidx);
*/
        }
        CP_OUT_BYTE(pjPorts, SR_INDEX, savSEQidx);
    }
#endif

//pat04, begin
//#if   0 //0
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL

//if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
//    (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
//    (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))

  if (ppdev->flCaps & CAPS_SW_POINTER) {

    y -= ppdev->yPointerHot;
    if (y < 0) y = 0;

    // Get Chip ID
    CP_OUT_BYTE(ppdev->pjPorts, CRTC_INDEX, 0x27);
    ChipID = (CP_IN_BYTE(ppdev->pjPorts, CRTC_DATA) & 0xFC) >> 2;


    // If x == -1 (invisible cursor)

    if (x < 0 )  {

      specialcase = 1;
      x = 0;
      y = 0;

      // if old coordinate is not negative ...
      if (ppdev->oldx >= 0) {
        if (ppdev->flCaps & CAPS_MM_IO) {
          CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
          CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
          CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
          CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
          CP_MM_XCNT(ppdev, pjBase, ppdev->xcount );
          CP_MM_YCNT(ppdev, pjBase, 31);
          CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->pjCBackground->xy);
          CP_MM_DST_ADDR_ABS(ppdev, pjBase, ((ppdev->oldy * ppdev->cxScreen * ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
          CP_MM_START_BLT(ppdev, pjBase);
        } //  if (ppdev->flCaps & CAPS_MM_IO)

        else {
          CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
          CP_IO_BLT_MODE(ppdev,pjPorts, DIR_TBLR);
          CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
          CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine );
          CP_IO_XCNT(ppdev, pjPorts, ppdev->xcount);
          CP_IO_YCNT(ppdev, pjPorts, 31);
          CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->pjCBackground->xy);
          CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ((ppdev->oldy * ppdev->cxScreen * ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
          CP_IO_START_BLT(ppdev, pjPorts);
        } // else
      }
      return;
    }


    x -= ppdev->xPointerHot;

    // cheap clipping ....
    if (x < 0) x = 0;

    clippingy = 31;

    if ((y + 32) > ppdev->cyScreen) {
       clippingy += (ppdev->cyScreen - y - 32);
    }


    clipping = 31;
    if ((x + 32) > ppdev->cxScreen)
    {
      clipping += (ppdev->cxScreen - x - 32); // negative value
    }

    clipping *= ppdev->cBpp;


    if (!specialcase) {

      if (ppdev->flCaps & CAPS_MM_IO) {
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
        CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
        CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
        CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
        CP_MM_YCNT(ppdev, pjBase, 31);
        CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->pjCBackground->xy);
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, ((ppdev->oldy * ppdev->cxScreen * ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
        CP_MM_START_BLT(ppdev, pjBase);
      }

      else {

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
        CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
        CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine );
        CP_IO_XCNT(ppdev, pjPorts, ppdev->xcount);
        CP_IO_YCNT(ppdev, pjPorts, 31);
        CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->pjCBackground->xy);
        CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ((ppdev->oldy * ppdev->cxScreen * ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
        CP_IO_START_BLT(ppdev, pjPorts);
      } // else

     } // specialcase

     specialcase = 0; // no specialcase
     tmpaddress = (y * ppdev->cxScreen * ppdev->cBpp) + (x * ppdev->cBpp);
     ppdev->oldy = y;
     ppdev->oldx = x;

     if (ppdev->flCaps & CAPS_MM_IO) {
       CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
       CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
       CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
       CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
       CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
       CP_MM_YCNT(ppdev, pjBase, 31);
       CP_MM_SRC_ADDR(ppdev, pjBase, tmpaddress);
       CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjCBackground->xy);
       CP_MM_START_BLT(ppdev, pjBase);
     } // MMIO

     else {
       CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
       CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
       CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine );
       CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
       CP_IO_XCNT(ppdev, pjPorts, ppdev->xcount);
       CP_IO_YCNT(ppdev, pjPorts, 31);
       CP_IO_SRC_ADDR(ppdev, pjPorts, tmpaddress);
       CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ppdev->pjCBackground->xy);
       CP_IO_START_BLT(ppdev, pjPorts);
     }


     if (clipping > 0) {

       if (ppdev->flCaps & CAPS_MM_IO)  {

         // And AND MASK
         CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
         CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
         CP_MM_XCNT(ppdev, pjBase, clipping );
         CP_MM_YCNT(ppdev, pjBase, clippingy );
         //CP_MM_YCNT(ppdev, pjBase, 31);
         CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
         CP_MM_ROP(ppdev, pjBase, CL_SRC_AND);
         CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->pjPointerAndCMask->xy);
         CP_MM_DST_ADDR_ABS(ppdev, pjBase, tmpaddress );
         CP_MM_START_BLT(ppdev, pjBase);

         // OR COLOR MASK
         CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
         CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
         CP_MM_ROP(ppdev,pjBase, CL_SRC_PAINT);
         CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
         CP_MM_XCNT(ppdev, pjBase, clipping );
         CP_MM_YCNT(ppdev, pjBase, clippingy );
         //CP_MM_YCNT(ppdev, pjBase, 31);
         CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->pjPointerCBitmap->xy);
         CP_MM_DST_ADDR_ABS(ppdev, pjBase, tmpaddress );
         CP_MM_START_BLT(ppdev, pjBase);
       }

       else {

         // AND AND MASK
         CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
         CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine );
         CP_IO_XCNT(ppdev, pjPorts, clipping );
         CP_IO_YCNT(ppdev, pjPorts, clippingy);
         //CP_IO_YCNT(ppdev, pjPorts, 31);
         CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
         CP_IO_ROP(ppdev, pjPorts, CL_SRC_AND);
         CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->pjPointerAndCMask->xy);
         CP_IO_DST_ADDR_ABS(ppdev, pjPorts, tmpaddress );
         CP_IO_START_BLT(ppdev, pjPorts);

         // OR COLOR MASK
         CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
         CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
         CP_IO_ROP(ppdev, pjPorts, CL_SRC_PAINT);
         CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine);
         CP_IO_XCNT(ppdev, pjPorts, clipping );
         CP_IO_YCNT(ppdev, pjPorts, clippingy);
         //CP_IO_YCNT(ppdev, pjPorts, 31);
         CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->pjPointerCBitmap->xy);
         CP_IO_DST_ADDR_ABS(ppdev, pjPorts, tmpaddress );
         CP_IO_START_BLT(ppdev, pjPorts);
         CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

       } // else

    }  // if clipping

    // Bounding rectangle for software cursor
    prcl->left =  x;
    prcl->right = x + 32;
    prcl->top =  y;
    prcl->bottom = y + 32;



    if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
        (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) || //myf19
        (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))   //myf17
    {
        CirrusPanning(pso, x, y, prcl);
        x -= ppdev->min_Xscreen;
        y -= ppdev->min_Yscreen;
    }

    return;
  }
//}     //if chipID == laptop chip
#endif          //PANNING_SCROLL
#endif          //_WIN32_WINNT < 0400
//#endif  //0
//pat04, end


    //
    // If x is -1 then take down the cursor.
    //

    if (x == -1)
    {
        // Move the hardware pointer off-screen so that when it gets
        // turned back on, it won't flash in the old position:

        CP_PTR_DISABLE(ppdev, pjPorts);
        return;
    }


//crus begin
//myf1, begin
#ifdef PANNING_SCROLL
//  if (ppdev->flCaps & CAPS_PANNING)
    if (y < 0)
        y = y + pso->sizlBitmap.cy;
//    DISPDBG((2,"DrvMovePointer to (%d,%d)", x, y));
//  else
//      y = -y;
    if ((ppdev->ulChipID == 0x38) || (ppdev->ulChipID == 0x2C) ||
        (ppdev->ulChipID == 0x30) || (ppdev->ulChipID == 0x34) || //myf19
        (ppdev->ulChipID == 0x40) || (ppdev->ulChipID == 0x4C))   //myf17
    {
        CirrusPanning(pso, x, y, prcl);
        x -= ppdev->min_Xscreen;
        y -= ppdev->min_Yscreen;
    }

#endif          //ifdef PANNING_SCROLL
//myf1, end
//crus end

    //myf33 begin
#if (_WIN32_WINNT >= 0x0400)
#ifdef PANNING_SCROLL
    // set CAPS_PANNING flag so must be check ppdev->flCaps flag,
    // disable display both shape(S/W & H/W)
    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        CP_PTR_DISABLE(ppdev, pjPorts);
        return;
    }
#endif
#endif
    //myf33 end


    // Adjust the actual pointer position depending upon
    // the hot spot.

    x -= ppdev->xPointerHot;
    y -= ppdev->yPointerHot;

    fl = 0;

    if (x < 0)
    {
        xAdj = -x;
        x = 0;
        fl |= POINTER_X_SHIFT;
    }

    if (y < 0)
    {
        yAdj = -y;
        y = 0;
        fl |= POINTER_Y_SHIFT;
    }

    if ((fl == 0) && (ppdev->flPointer & (POINTER_Y_SHIFT | POINTER_X_SHIFT)))
    {
        fl |= POINTER_SHAPE_RESET;
    }

    CP_PTR_XY_POS(ppdev, pjPorts, x, y);

    if (fl != 0)
    {
        vSetPointerBits(ppdev, xAdj, yAdj);
    }

    CP_PTR_ENABLE(ppdev, pjPorts);

    // record the flags.

    ppdev->flPointer = fl;
    return;
}

#if (_WIN32_WINNT < 0x0400)              //pat04
//if ((ppdev->ulChipID == CL7541_ID) || (ppdev->ulChipID == CL7543_ID) ||
//    (ppdev->ulChipID == CL7542_ID) || (ppdev->ulChipID == CL7548_ID) ||
//    (ppdev->ulChipID == CL7555_ID) || (ppdev->ulChipID == CL7556_ID))

/******************************Public*Routine******************************\
* DrvSetPointerShape
*
* Sets the new pointer shape.
\**************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ    *pso,
SURFOBJ    *psoMask,
SURFOBJ    *psoColor,
XLATEOBJ   *pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL      *prcl,
FLONG       fl)
{
    PPDEV   ppdev = (PPDEV) pso->dhpdev;
    PBYTE   pjPorts = ppdev->pjPorts;
    ULONG   ulRet = SPS_DECLINE;
    LONG    cx;
    LONG    cy;

    BYTE  * pjBase = ppdev->pjBase;
    static  poh    = 0;
    volatile PULONG  pul;
    ULONG counter = 0;
    DSURF* pdsurfColor;         //myf32

    DISPDBG((2,"DrvSetPointerShape : (%x, %x)---%x\n", x, y,ppdev->flCaps));

    // Is the cursor a color cursor ?

#ifdef PANNING_SCROLL

    if (psoColor != NULL) {

      // Let GDI handle color cursor at these resolutions
      if ((ppdev->cxScreen == 640) ||
          ((ppdev->cxScreen == 800) & (ppdev->cBpp == 3)) ) {
//         CP_PTR_DISABLE(ppdev, pjPorts);
//         goto ReturnStatus;
           goto DisablePointer;         //myf33
      }

      // if the 3 permenent spaces cannot be allocated ...
      if ( (ppdev->pjPointerAndCMask == NULL) || (ppdev->pjCBackground == NULL)
          || (ppdev->pjPointerCBitmap == NULL) ) {
//        CP_PTR_DISABLE(ppdev, pjPorts);
//        goto ReturnStatus;
          goto DisablePointer;         //myf33
      }


      ppdev->xPointerHot = xHot;
      ppdev->yPointerHot = yHot;
      ppdev->ppScanLine = ppdev->cxScreen * ppdev->cBpp;
      ppdev->xcount     = 31 * ppdev->cBpp;


      if (!(ppdev->flCaps & CAPS_SW_POINTER)) {
        ppdev->flCaps |= CAPS_SW_POINTER;       //myfxx
        CP_PTR_DISABLE(ppdev, pjPorts);
      }


      // specialcase to init for first time
       if ((poh == 0) || (ppdev->globdat == 0)) {

   // if (poh == 0)  {

          if (x >= 0) {
            poh = 0;
            ppdev->oldx = x;
            ppdev->oldy = y;
            ppdev->globdat = 1;

           // Save background in xy DBB format
           if (ppdev->flCaps & CAPS_MM_IO) {
             CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
             CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
             CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
             CP_MM_DST_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
             CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
             CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
             CP_MM_YCNT(ppdev, pjBase, 31);
             CP_MM_SRC_ADDR(ppdev, pjBase, ((y * ppdev->cxScreen * ppdev->cBpp) + (x * ppdev->cBpp)) );
             CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjCBackground->xy);
             CP_MM_START_BLT(ppdev, pjBase);
           } // if MMIO

           else {
             CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev,  pjPorts);
             CP_IO_FG_COLOR(ppdev, pjPorts, 0);
             CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
             CP_IO_SRC_Y_OFFSET(ppdev,  pjPorts, ppdev->ppScanLine);
             CP_IO_DST_Y_OFFSET(ppdev,  pjPorts, ppdev->ppScanLine);
             CP_IO_ROP(ppdev,   pjPorts, CL_SRC_COPY);
             CP_IO_XCNT(ppdev,  pjPorts, ppdev->xcount);
             CP_IO_YCNT(ppdev,  pjPorts, 31);
             CP_IO_SRC_ADDR(ppdev,  pjPorts, ((y * ppdev->cxScreen * ppdev->cBpp) + (x * ppdev->cBpp)) );
             CP_IO_DST_ADDR_ABS(ppdev,  pjPorts, ppdev->pjCBackground->xy);
             CP_IO_START_BLT(ppdev,  pjPorts);

           } // ELSE
         }

      } // if poh == 0



      SetMonoHwPointerShape(pso, psoMask, psoColor, pxlo,
                           xHot, yHot, x, y, prcl, fl);

//myf32 added
      pdsurfColor = (DSURF*)psoColor->dhsurf;
      // if color bitmap resides in system memory, bring it into offscreen
      if ((pdsurfColor != NULL) && (pdsurfColor->poh->ofl == 0)) {
          bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfColor);
      }  // OH resides as DIB
//myf32 end


      // Get the color bitmap and save it, since it will be destroyed later
      if (ppdev->flCaps & CAPS_MM_IO) {

        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
        CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine);
        CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
        CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
        CP_MM_YCNT(ppdev, pjBase, 31);
        CP_MM_SRC_ADDR(ppdev, pjBase, ((DSURF *) (psoColor->dhsurf))->poh->xy);
        CP_MM_DST_ADDR_ABS(ppdev, pjBase, ppdev->pjPointerCBitmap->xy);
        CP_MM_START_BLT(ppdev, pjBase);

      }  // if MMIO


      else  {

       // if no space in offscreen, and color bitmap still resides in
       // system memory, then blt directly to the preallocated
       // permanent buffer

//myf32    if (  ((DSURF *) (psoColor->dhsurf))->poh->ofl != 0) {
           if ((pdsurfColor != NULL) && (pdsurfColor->poh->ofl != 0)) {
               CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev,  pjPorts);
               CP_IO_BLT_MODE(ppdev,      pjPorts, DIR_TBLR);
               CP_IO_SRC_Y_OFFSET(ppdev,  pjPorts, ppdev->ppScanLine);
               CP_IO_ROP(ppdev,   pjPorts, CL_SRC_COPY);
               CP_IO_XCNT(ppdev,  pjPorts, ppdev->xcount);
               CP_IO_YCNT(ppdev,  pjPorts, 31);
               CP_IO_SRC_ADDR(ppdev,  pjPorts, ((DSURF *) (psoColor->dhsurf))->poh->xy);
               CP_IO_DST_ADDR_ABS(ppdev,  pjPorts, ppdev->pjPointerCBitmap->xy);
               CP_IO_START_BLT(ppdev,  pjPorts);
           }

           else { // not enough offscreen memory. so directly blt to video

               RECTL  rclDst;
               POINTL ptlSrc;
               rclDst.left   = ppdev->pjPointerCBitmap->x;
               rclDst.top    = ppdev->pjPointerCBitmap->y;
               rclDst.right  = rclDst.left +  ppdev->xcount;
               rclDst.bottom = rclDst.top +  32;
               ptlSrc.x = 0;
               ptlSrc.y = 0;
               ppdev->pfnPutBits(ppdev, ((DSURF *) (psoColor->dhsurf))->pso, &rclDst, &ptlSrc);

           }

     } // else

     prcl->left =  x;
     prcl->right = x + 32;
     prcl->top =  y;
     prcl->bottom = y + 32;

     DrvMovePointer(pso, x, y, NULL);

     if (poh == 0) {
       poh = 1;
       vAssertModeBrushCache(ppdev, TRUE);
     }

     ulRet = SPS_ACCEPT_EXCLUDE;


     // HW BUG ....
     //
     //    hardware (bootup) -> hardware -> software will mess the brush
     //  cache. Something to do with the BLTer. Marked off all the system
     //  -> video BLTS (in vSetCPointer()), but problem still exists.
     //  so I just restore them back. Only happens during bootup ...


     goto ReturnStatus;

   };


   if ((ppdev->flCaps & CAPS_SW_POINTER) && (ppdev->cxScreen == 640)) {
      goto ReturnStatus;
   }; //ppp  //if monocrome + software pointer

   if (ppdev->flCaps & CAPS_SW_POINTER)
   {
       ppdev->flCaps &=  ~CAPS_SW_POINTER;
       ppdev->globdat = 0;

     // repaint stuff back on screen !
       if (ppdev->flCaps & CAPS_MM_IO)
       {
           CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
           CP_MM_BLT_MODE(ppdev,pjBase, DIR_TBLR);
           CP_MM_ROP(ppdev,pjBase, CL_SRC_COPY);
           CP_MM_SRC_Y_OFFSET(ppdev, pjBase, ppdev->ppScanLine );
           CP_MM_XCNT(ppdev, pjBase, ppdev->xcount);
           CP_MM_YCNT(ppdev, pjBase, 31);
           CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->pjCBackground->xy);
           CP_MM_DST_ADDR_ABS(ppdev, pjBase, ((ppdev->oldy * ppdev->cxScreen *
                     ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
           CP_MM_START_BLT(ppdev, pjBase);
       }

       else {
           CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
           CP_IO_BLT_MODE(ppdev, pjPorts, DIR_TBLR);
           CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
           CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, ppdev->ppScanLine );
           CP_IO_XCNT(ppdev, pjPorts, ppdev->xcount);
           CP_IO_YCNT(ppdev, pjPorts, 31);
           CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->pjCBackground->xy);
           CP_IO_DST_ADDR_ABS(ppdev, pjPorts, ((ppdev->oldy * ppdev->cxScreen *
                     ppdev->cBpp) + (ppdev->oldx * ppdev->cBpp)) );
           CP_IO_START_BLT(ppdev, pjPorts);
       } // else

      // #pat07
      bEnablePointer(ppdev); // #pat07
      CP_PTR_ENABLE(ppdev, pjPorts); // #pat07
   }

#endif

    cx = psoMask->sizlBitmap.cx;
    cy = psoMask->sizlBitmap.cy / 2;

    DISPDBG((2,"DrvSetPtrShape %dx%d at (%d,%d), flags: %x, psoColor: %x",
                cx, cy, x, y, fl, psoColor));   //4

    if ((cx > 32) ||
        (cy > 32) ||
        (psoColor != NULL))
    {
        //
        // We only handle monochrome pointers that are 32x32 or less
        //

        goto DisablePointer;
    }

#if 0 //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    //
    // Save the hot spot and dimensions of the cursor in the PDEV
    //

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    ulRet = SetMonoHwPointerShape(pso, psoMask, psoColor, pxlo,
                                  xHot, yHot, x, y, prcl, fl);

    if (ulRet != SPS_DECLINE)
    {
        goto ReturnStatus;
    }

DisablePointer:
    CP_PTR_DISABLE(ppdev, pjPorts);

ReturnStatus:
    return (ulRet);
}

#else                   //pat04

/******************************Public*Routine******************************\
* DrvSetPointerShape
*
* Sets the new pointer shape.
\**************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ    *pso,
SURFOBJ    *psoMask,
SURFOBJ    *psoColor,
XLATEOBJ   *pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL      *prcl,
FLONG       fl)
{
    PPDEV   ppdev = (PPDEV) pso->dhpdev;
    PBYTE   pjPorts = ppdev->pjPorts;
    ULONG   ulRet = SPS_DECLINE;
    LONG    cx;
    LONG    cy;

    DISPDBG((2,"DrvSetPointerShape : (%x, %x)\n", x, y));

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        goto DisablePointer;    //myf33
//      goto ReturnStatus;
    }

    cx = psoMask->sizlBitmap.cx;
    cy = psoMask->sizlBitmap.cy / 2;

    DISPDBG((2,"DrvSetPtrShape %dx%d at (%d,%d), flags: %x, psoColor: %x",
                cx, cy, x, y, fl, psoColor));   //4

    if ((cx > 32) ||
        (cy > 32) ||
        (psoColor != NULL))
    {
        //
        // We only handle monochrome pointers that are 32x32 or less
        //
        ppdev->flCaps |= CAPS_SW_POINTER;       //myf33,
        DISPDBG((2, "It is a  64 x 64 cursor"));

        goto DisablePointer;
    }

#if BANKING //bank#1
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);
#endif

    //
    // Save the hot spot and dimensions of the cursor in the PDEV
    //

    ppdev->xPointerHot = xHot;
    ppdev->yPointerHot = yHot;

    ulRet = SetMonoHwPointerShape(pso, psoMask, psoColor, pxlo,
                                  xHot, yHot, x, y, prcl, fl);

    if (ulRet != SPS_DECLINE)
    {
        goto ReturnStatus;
    }

DisablePointer:
    CP_PTR_DISABLE(ppdev, pjPorts);

ReturnStatus:
    return (ulRet);
}
#endif          //pat04

/****************************************************************************\
* SetMonoHwPointerShape
*
*  Truth Table
*
*      MS                  Cirrus
*  ----|----               ----|----
*  AND | XOR               P0  |  P1
*   0  | 0     Black        0  |  1
*   0  | 1     White        1  |  1
*   1  | 0     Transparent  0  |  0
*   1  | 1     Inverse      1  |  0
*
*  So, in order to translate from the MS convention to the Cirrus convention
*  we had to invert the AND mask, then down load the XOR as plane 0 and the
*  the AND mask as plane 1.
\****************************************************************************/

ULONG SetMonoHwPointerShape(
SURFOBJ     *pso,
SURFOBJ     *psoMask,
SURFOBJ     *psoColor,
XLATEOBJ    *pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL       *prcl,
FLONG       fl)
{

    INT     i,
            j,
            cxMask,
            cyMask,
            cy,
            cx;

    PBYTE   pjAND,
            pjXOR;

    INT     lDelta;

    PPDEV   ppdev   = (PPDEV) pso->dhpdev;
    PBYTE   pjPorts = ppdev->pjPorts;
    PBYTE   pjAndMask;
    PBYTE   pjXorMask;

    // Init the AND and XOR masks, for the cirrus chip
    DISPDBG((2,"SetMonoHWPointerShape\n "));

    pjAndMask = ppdev->pjPointerAndMask;
    pjXorMask = ppdev->pjPointerXorMask;

    memset (pjAndMask, 0, 128);
    memset (pjXorMask, 0, 128);

    // Get the bitmap dimensions.

    cxMask = psoMask->sizlBitmap.cx;
    cyMask = psoMask->sizlBitmap.cy;

    cy = cyMask / 2;
    cx = cxMask / 8;

    // Set up pointers to the AND and XOR masks.

    lDelta = psoMask->lDelta;
    pjAND  = psoMask->pvScan0;
    pjXOR  = pjAND + (cy * lDelta);

//ms923    ppdev->lDeltaPointer  = lDelta;
    ppdev->sizlPointer.cx = cxMask;
    ppdev->sizlPointer.cy = cyMask / 2;

    // Copy the masks

    for (i = 0; i < cy; i++)
    {
        for (j = 0; j < cx; j++)
        {
            pjAndMask[(i*4)+j] = pjAND[j];
            pjXorMask[(i*4)+j] = pjXOR[j];
        }

        // point to the next line of the AND mask.

        pjAND += lDelta;
        pjXOR += lDelta;
    }

//pat04, begin
//#if  0  //0
#if (_WIN32_WINNT < 0x0400)
#ifdef PANNING_SCROLL
    if (psoColor != NULL) {
        vSetCPointerBits(ppdev, 0, 0);
        return (SPS_ACCEPT_EXCLUDE); //ppp
    }
#endif
#endif
//#endif  //0
//pat04, end

    vSetPointerBits(ppdev, 0, 0);

    // The previous call left the pointer disabled (at our request).  If we
    // were told to disable the pointer, then set the flag and exit.
    // Otherwise, turn it back on.

    if (x != -1)
    {
        CP_PTR_ENABLE(ppdev, pjPorts);
        DrvMovePointer(pso, x, y, NULL);
    }
    else
    {
        CP_PTR_DISABLE(ppdev, pjPorts);
    }

    return (SPS_ACCEPT_NOEXCLUDE);
}

/******************************Public*Routine******************************\
* VOID vDisablePointer
*
\**************************************************************************/

VOID vDisablePointer(
    PDEV*   ppdev)
{
    DISPDBG((2,"vDisablePointer\n "));
    FREE(ppdev->pjPointerAndMask);
    FREE(ppdev->pjPointerXorMask);
}


//crus begin
//myf11, begin fixed M1 H/W bug
/******************************Public*Routine******************************\
* BOOL vAsserthwiconcurorsor
*
\**************************************************************************/

VOID vAssertHWiconcursor(
PDEV*   ppdev,
BOOL    Access_flag)
{
    PBYTE   pjPorts = ppdev->pjPorts;
    UCHAR   savSEQidx;

    savSEQidx = CP_IN_BYTE(pjPorts, SR_INDEX);
    if (Access_flag)            //enable HW cursor, icons
    {
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X12);
        CP_OUT_BYTE(pjPorts, SR_DATA, HWcur);

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2A);
        CP_OUT_BYTE(pjPorts, SR_DATA, HWicon0);

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2B);
        CP_OUT_BYTE(pjPorts, SR_DATA, HWicon1);

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2C);
        CP_OUT_BYTE(pjPorts, SR_DATA, HWicon2);

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2D);
        CP_OUT_BYTE(pjPorts, SR_DATA, HWicon3);

    }
    else                        //disable HW cursor, icons
    {
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X12);
        HWcur = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWcur & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2A);
        HWicon0 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon0 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2B);
        HWicon1 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon1 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2C);
        HWicon2 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon2 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2D);
        HWicon3 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon3 & 0xFE));

    }
    CP_OUT_BYTE(pjPorts, SR_INDEX, savSEQidx);

}

//myf11, end
//crus end


/******************************Public*Routine******************************\
* VOID vAssertModePointer
*
\**************************************************************************/

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)
{
    PBYTE   pjPorts = ppdev->pjPorts;
//crus
    UCHAR       savSEQidx;      //myf11

    DISPDBG((2,"vAssertModePointer\n"));
    if (DRIVER_PUNT_ALL ||
        DRIVER_PUNT_PTR ||
        (ppdev->pulXfer == NULL) ||
        (ppdev->pjPointerAndMask == NULL) ||
        (ppdev->pjPointerXorMask == NULL))
    {
        //
        // Force SW cursor
        //

        ppdev->flCaps |= CAPS_SW_POINTER;
    }

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        goto Leave;
    }

    if (bEnable)
    {
        BYTE    jSavedDac_0_0;
        BYTE    jSavedDac_0_1;
        BYTE    jSavedDac_0_2;
        BYTE    jSavedDac_F_0;
        BYTE    jSavedDac_F_1;
        BYTE    jSavedDac_F_2;

        // Enable access to the extended DAC colors.

//crus
//      vAsserthwiconcursor(ppdev, 0);       //myf11
/*  {
    savSEQidx = CP_IN_BYTE(pjPorts, SR_INDEX);
        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X12);
        HWcur = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWcur & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2A);
        HWicon0 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon0 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2B);
        HWicon1 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon1 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2C);
        HWicon2 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon2 & 0xFE));

        CP_OUT_BYTE(pjPorts, SR_INDEX, 0X2D);
        HWicon3 = CP_IN_BYTE(pjPorts, SR_DATA);
        CP_OUT_BYTE(pjPorts, SR_DATA, (HWicon3 & 0xFE));

    CP_OUT_BYTE(pjPorts, SR_INDEX, savSEQidx);
    }
*/

        CP_PTR_SET_FLAGS(ppdev, pjPorts, 0);

        CP_OUT_BYTE(pjPorts, DAC_PEL_READ_ADDR, 0);
            jSavedDac_0_0 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
            jSavedDac_0_1 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
            jSavedDac_0_2 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);

        CP_OUT_BYTE(pjPorts, DAC_PEL_READ_ADDR, 0xf);
            jSavedDac_F_0 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
            jSavedDac_F_1 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);
            jSavedDac_F_2 = CP_IN_BYTE(pjPorts, DAC_PEL_DATA);

        //
        // The following code maps DAC locations 256 and 257 to locations
        // 0 and 15 respectively, and then initializes them.  They are
        // used by the cursor.
        //

        CP_PTR_SET_FLAGS(ppdev, pjPorts, ALLOW_DAC_ACCESS_TO_EXT_COLORS);

        CP_OUT_BYTE(pjPorts, DAC_PEL_WRITE_ADDR, 0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0);

        CP_OUT_BYTE(pjPorts, DAC_PEL_WRITE_ADDR, 0xf);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0xff);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0xff);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, 0xff);

        // Disable access to the extended DAC registers.
        // We are using a 32 X 32 pointer in last position in video memory.

        CP_PTR_SET_FLAGS(ppdev, pjPorts, 0);

        //
        // The following code restores the data at DAC locations 0 and 15
        // because it looks like the previous writes destroyed them.
        // That is a bug in the chip.
        //

        CP_OUT_BYTE(pjPorts, DAC_PEL_WRITE_ADDR, 0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_0_0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_0_1);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_0_2);

        CP_OUT_BYTE(pjPorts, DAC_PEL_WRITE_ADDR, 0xf);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_F_0);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_F_1);
            CP_OUT_BYTE(pjPorts, DAC_PEL_DATA, jSavedDac_F_2);

        //
        // Set HW pointer to use last HW pattern location
        //

        CP_PTR_ADDR(ppdev, ppdev->pjPorts, 0x3f);
//crus
//      vAsserthwiconcursor(ppdev, 1);       //myf11
    }
    else
    {
        CP_PTR_DISABLE(ppdev, pjPorts);
    }

Leave:
    return;
}

/******************************Public*Routine******************************\
* BOOL bEnablePointer
*
\**************************************************************************/

BOOL bEnablePointer(
PDEV*   ppdev)
{
    PBYTE   pjPorts = ppdev->pjPorts;
    DISPDBG((2,"bEnablePointer\n "));

    ///////////////////////////////////////////////////////////////////////
    // Note: flCaps is overwritten during an vAsserModeHardware.  So, any
    // failures that disable the pointer need to be re-checked during
    // vAssertModePointer so that we can re-set the CAPS_SW_POINTER flag.

    if (DRIVER_PUNT_ALL || DRIVER_PUNT_PTR || (ppdev->pulXfer == NULL))
    {
        //
        // Force SW cursor
        //

        ppdev->flCaps |= CAPS_SW_POINTER;
    }

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        goto ReturnSuccess;
    }

    ppdev->pjPointerAndMask = ALLOC(128);
    if (ppdev->pjPointerAndMask == NULL)
    {
        DISPDBG((0, "bEnablePointer: Failed - EngAllocMem (pjAndMask)"));
        ppdev->flCaps |= CAPS_SW_POINTER;
        goto ReturnSuccess;
    }

    ppdev->pjPointerXorMask = ALLOC(128);
    if (ppdev->pjPointerXorMask == NULL)
    {
        DISPDBG((0, "bEnablePointer: Failed - EngAllocMem (pjXorMask)"));
        ppdev->flCaps |= CAPS_SW_POINTER;
        goto ReturnSuccess;
    }

    ppdev->flPointer = POINTER_DISABLED;

    vAssertModePointer(ppdev, TRUE);

ReturnSuccess:

    if (ppdev->flCaps & CAPS_SW_POINTER)
    {
        DISPDBG((2, "Using software pointer"));
    }
    else
    {
        DISPDBG((2, "Using hardware pointer"));
    }

    return(TRUE);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\stretch.c ===
/******************************************************************************\
*
* $Workfile:   stretch.c  $
*
* DrvStretchBlt function.
*
* Copyright (c) 1993-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/STRETCH.C_V  $
 *
 *    Rev 1.3   10 Jan 1997 15:40:16   PLCHU
 *
 *
 *    Rev 1.2   Nov 07 1996 16:48:04   unknown
 *
 *
 *    Rev 1.1   Oct 10 1996 15:39:02   unknown
 *
*
*    Rev 1.1   12 Aug 1996 16:55:00   frido
* Removed unaccessed local variables.
*
*  chu01  : 01-02-97   5480 BitBLT enhancement
*
\******************************************************************************/

#include "precomp.h"

#define STRETCH_MAX_EXTENT 32767

typedef DWORDLONG ULONGLONG;

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8Narrow
*
* Routine Description:
*
*   Stretch blt 8->8 when the width is 7 or less
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8Narrow(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    ULONG   xAccum;
    ULONG   xTmp;

    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;
    ULONG   yInt        = 0;

    yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;

    //
    // Narrow blt
    //

    do {

        ULONG  yTmp = yAccum + yFrac;
        BYTE   jSrc0;
        BYTE*  pjDstEndNarrow = pjDst + WidthX;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        do {
            jSrc0    = *pjSrc;
            xTmp     = xAccum + xFrac;
            pjSrc    = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum   = xTmp;
        } while (pjDst != pjDstEndNarrow);

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;
        pjDst += lDstStride;

    } while (--yCount);

}

/******************************Public*Routine******************************\
*
* Routine Description:
*
*   StretchBlt using integer math. Must be from one surface to another
*   surface of the same format.
*
* Arguments:
*
*   ppdev           -   PDEV for device
*   pvDst           -   Pointer to start of dst bitmap
*   lDeltaDst       -   Bytes from start of dst scan line to start of next
*   DstCx           -   Width of Dst Bitmap in pixels
*   DstCy           -   Height of Dst Bitmap in pixels
*   prclDst         -   Pointer to rectangle of Dst extents
*   pvSrc           -   Pointer to start of Src bitmap
*   lDeltaSrc       -   Bytes from start of Src scan line to start of next
*   SrcCx           -   Width of Src Bitmap in pixels
*   SrcCy           -   Height of Src Bitmap in pixels
*   prclSrc         -   Pointer to rectangle of Src extents
*   prclSClip       -   Clip Dest to this rect
*
* Return Value:
*
*   Status
*
\**************************************************************************/

BOOL bStretchDIB(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    STR_BLT StrBlt;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
    LONG    LeftClipDistance;
    LONG    TopClipDistance;
    BOOL    bStretch;

    union {
        LARGE_INTEGER   large;
        ULONGLONG       li;
    } liInit;

    PFN_DIRSTRETCH      pfnStr;

    //
    // Calculate exclusive start and end points:
    //

    LONG    WidthDst  = prclDst->right  - prclDst->left;
    LONG    HeightDst = prclDst->bottom - prclDst->top;
    LONG    WidthSrc  = prclSrc->right  - prclSrc->left;
    LONG    HeightSrc = prclSrc->bottom - prclSrc->top;

    LONG    XSrcStart = prclSrc->left;
    LONG    XSrcEnd   = prclSrc->right;
    LONG    XDstStart = prclDst->left;
    LONG    XDstEnd   = prclDst->right;
    LONG    YSrcStart = prclSrc->top;
    LONG    YSrcEnd   = prclSrc->bottom;
    LONG    YDstStart = prclDst->top;
    LONG    YDstEnd   = prclDst->bottom;

    //
    // Validate parameters:
    //

    ASSERTDD(pvDst != (VOID*)NULL, "Bad destination bitmap pointer");
    ASSERTDD(pvSrc != (VOID*)NULL, "Bad source bitmap pointer");
    ASSERTDD(prclDst != (RECTL*)NULL, "Bad destination rectangle");
    ASSERTDD(prclSrc != (RECTL*)NULL, "Bad source rectangle");
    ASSERTDD((WidthDst > 0) && (HeightDst > 0) &&
             (WidthSrc > 0) && (HeightSrc > 0),
             "Can't do mirroring or empty rectangles here");
    ASSERTDD((WidthDst  <= STRETCH_MAX_EXTENT) &&
             (HeightDst <= STRETCH_MAX_EXTENT) &&
             (WidthSrc  <= STRETCH_MAX_EXTENT) &&
             (HeightSrc <= STRETCH_MAX_EXTENT), "Stretch exceeds limits");
    ASSERTDD(prclClip != NULL, "Bad clip rectangle");

    //
    // Calculate X Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*WidthSrc)/WidthDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*WidthSrc -1) / WidthDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liWidthSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = WidthSrc - 1;
        liWidthSrc = liInit.li;

        liQuo = liWidthSrc / (ULONGLONG) WidthDst;

        ulXDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulXDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulXDstToSrcFracCeil + 1;

        ulXDstToSrcIntCeil += (ulTemp < ulXDstToSrcFracCeil);
        ulXDstToSrcFracCeil = ulTemp;
    }

    //
    // Calculate Y Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*HeightSrc)/HeightDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*HeightSrc -1) / HeightDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liHeightSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = HeightSrc - 1;
        liHeightSrc = liInit.li;

        liQuo = liHeightSrc / (ULONGLONG) HeightDst;

        ulYDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulYDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulYDstToSrcFracCeil + 1;

        ulYDstToSrcIntCeil += (ulTemp < ulYDstToSrcFracCeil);
        ulYDstToSrcFracCeil = ulTemp;
    }

    //
    // Now clip Dst in X, and/or calc src clipping effect on dst
    //
    // adjust left and right edges if needed, record
    // distance adjusted for fixing the src
    //

    if (XDstStart < prclClip->left)
    {
        XDstStart = prclClip->left;
    }

    if (XDstEnd > prclClip->right)
    {
        XDstEnd = prclClip->right;
    }

    //
    // Check for totally clipped out destination:
    //

    if (XDstEnd <= XDstStart)
    {
        return(TRUE);
    }

    LeftClipDistance = XDstStart - prclDst->left;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        ulTempInt  = (ulXDstToSrcIntCeil >> 1);

        XSrcStart += ulTempInt;
        ulXFracAccumulator = ulTempFrac;

        if (LeftClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulXDstToSrcFracCeil, LeftClipDistance);

            ulTmp = ulXFracAccumulator;
            ulXFracAccumulator += (ULONG) (ullFraction);
            if (ulXFracAccumulator < ulTmp)
                XSrcStart++;

            XSrcStart += (ulXDstToSrcIntCeil * LeftClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Now clip Dst in Y, and/or calc src clipping effect on dst
    //
    // adjust top and bottom edges if needed, record
    // distance adjusted for fixing the src
    //

    if (YDstStart < prclClip->top)
    {
        YDstStart = prclClip->top;
    }

    if (YDstEnd > prclClip->bottom)
    {
        YDstEnd = prclClip->bottom;
    }

    //
    // Check for totally clipped out destination:
    //

    if (YDstEnd <= YDstStart)
    {
        return(TRUE);
    }

    TopClipDistance = YDstStart - prclDst->top;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        ulTempInt  = ulYDstToSrcIntCeil >> 1;

        YSrcStart += (LONG)ulTempInt;
        ulYFracAccumulator = ulTempFrac;

        if (TopClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulYDstToSrcFracCeil, TopClipDistance);

            ulTmp = ulYFracAccumulator;
            ulYFracAccumulator += (ULONG) (ullFraction);
            if (ulYFracAccumulator < ulTmp)
                YSrcStart++;

            YSrcStart += (ulYDstToSrcIntCeil * TopClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Warm up the hardware if doing an expanding stretch in 'y':
    //

    bStretch = (HeightDst > HeightSrc);
    if (bStretch)
    {
        //
        // Set up the info that is constant during the StretchBlt
        //

        ppdev->pfnBankSelectMode(ppdev, BANK_ON);

        //
        // BankSelectMode(BANK_ON) guarentees that the last
        // blt is completed.  We don't need to wait.
        //

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            BYTE*   pjBase  = ppdev->pjBase;

            CP_MM_BLT_MODE(ppdev, pjBase, 0);                   // GR30
            CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);              // GR32
            CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lDeltaDst);       // GR26, GR27
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDeltaDst);       // GR24, GR25
        }
        else
        {
            BYTE*   pjPorts  = ppdev->pjPorts;

            CP_IO_BLT_MODE(ppdev, pjPorts, 0);
            CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
            CP_IO_SRC_Y_OFFSET(ppdev, pjPorts, lDeltaDst);
            CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDeltaDst);
        }
    }

    //
    // Fill out blt structure, then call format-specific stretch code
    //

    StrBlt.ppdev     = ppdev;
    StrBlt.XDstEnd   = XDstEnd;
    StrBlt.YDstStart = YDstStart;
    StrBlt.YDstCount = YDstEnd - YDstStart;

    if (StrBlt.YDstCount > 0)
    {
        //
        // Caclulate starting scan line address.  Since the inner loop
        // routines are format dependent, they must add XDstStart/XSrcStart
        // to pjDstScan/pjSrcScan to get the actual starting pixel address.
        //

        StrBlt.pjSrcScan           = (BYTE*) pvSrc + (YSrcStart * lDeltaSrc);
        StrBlt.pjDstScan           = (BYTE*) pvDst + (YDstStart * lDeltaDst);

        StrBlt.lDeltaSrc           = lDeltaSrc;
        StrBlt.XSrcStart           = XSrcStart;
        StrBlt.XDstStart           = XDstStart;
        StrBlt.lDeltaDst           = lDeltaDst;
        StrBlt.ulXDstToSrcIntCeil  = ulXDstToSrcIntCeil;
        StrBlt.ulXDstToSrcFracCeil = ulXDstToSrcFracCeil;
        StrBlt.ulYDstToSrcIntCeil  = ulYDstToSrcIntCeil;
        StrBlt.ulYDstToSrcFracCeil = ulYDstToSrcFracCeil;
        StrBlt.ulXFracAccumulator  = ulXFracAccumulator;
        StrBlt.ulYFracAccumulator  = ulYFracAccumulator;

// chu01
        if ((ppdev->flCaps & CAPS_COMMAND_LIST) && (ppdev->pCommandList != NULL))
        {
            if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                if ((XDstEnd - XDstStart) < 7)
                    pfnStr = vDirectStretch8Narrow;
                else
                    pfnStr = vDirectStretch8_80;
            }
            else if (ppdev->iBitmapFormat == BMF_16BPP)
            {
                pfnStr = vDirectStretch16_80;
            }
            else
            {
                ASSERTDD(ppdev->iBitmapFormat == BMF_24BPP,
                         "Only handle stretches at 8/16/24bpp");
                pfnStr = vDirectStretch24_80;
            }
        }
        else
        {
            if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                if ((XDstEnd - XDstStart) < 7)
                    pfnStr = vDirectStretch8Narrow;
                else
                    pfnStr = vDirectStretch8;
            }
            else if (ppdev->iBitmapFormat == BMF_16BPP)
            {
                pfnStr = vDirectStretch16;
            }
            else
            {
                ASSERTDD(ppdev->iBitmapFormat == BMF_24BPP,
                         "Only handle stretches at 8/16/24bpp");
                pfnStr = vDirectStretch24;
            }
        }

        (*pfnStr)(&StrBlt);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bBankedStretch
*
\**************************************************************************/

BOOL bBankedStretch(
PDEV*   ppdev,
VOID*   pvDst,
LONG    lDeltaDst,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    BANK    bnk;
    BOOL    b;
    RECTL   rclDst;

    b = TRUE;
    if (bIntersect(prclDst, prclClip, &rclDst))
    {
        vBankStart(ppdev, &rclDst, NULL, &bnk);

        do {
            b &= bStretchDIB(ppdev,
                             bnk.pso->pvScan0,
                             lDeltaDst,
                             prclDst,
                             pvSrc,
                             lDeltaSrc,
                             prclSrc,
                             &bnk.pco->rclBounds);

        } while (bBankEnum(&bnk));
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL DrvStretchBlt
*
\**************************************************************************/

BOOL DrvStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    PDEV*   ppdev;
    OH*     poh;

    // GDI guarantees us that for a StretchBlt the destination surface
    // will always be a device surface, and not a DIB:

    ppdev = (PDEV*) psoDst->dhpdev;

    if (!DIRECT_ACCESS(ppdev))
    {
        goto Punt_It;
    }

    // It's quicker for GDI to do a StretchBlt when the source surface
    // is not a device-managed surface, because then it can directly
    // read the source bits without having to allocate a temporary
    // buffer and call DrvCopyBits to get a copy that it can use.

    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_SCREEN)
        {
            goto Punt_It;
        }

        ASSERTDD(pdsurfSrc->dt == DT_DIB, "Can only handle DIB DFBs here");

        psoSrc = pdsurfSrc->pso;
    }

    pdsurfDst = (DSURF*) psoDst->dhsurf;
    if (pdsurfDst->dt == DT_DIB)
    {
        // The destination was a device bitmap that we just converted
        // to a DIB:

        psoDst = pdsurfDst->pso;
        goto Punt_It;
    }

    poh             = pdsurfDst->poh;
    ppdev->xOffset  = poh->x;
    ppdev->yOffset  = poh->y;
    ppdev->xyOffset = poh->xy;

    {
        RECTL       rclClip;
        RECTL*      prclClip;
        ULONG       cxDst;
        ULONG       cyDst;
        ULONG       cxSrc;
        ULONG       cySrc;
        BOOL        bMore;
        CLIPENUM    ce;
        LONG        c;
        LONG        i;

        if ((psoSrc->iType == STYPE_BITMAP) &&
            (psoMsk == NULL) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
            ((psoSrc->iBitmapFormat == ppdev->iBitmapFormat)) &&
            (ppdev->iBitmapFormat <= BMF_24BPP))
        {
            cxDst = prclDst->right - prclDst->left;
            cyDst = prclDst->bottom - prclDst->top;
            cxSrc = prclSrc->right - prclSrc->left;
            cySrc = prclSrc->bottom - prclSrc->top;

            // Our 'bStretchDIB' routine requires that the stretch be
            // non-inverting, within a certain size, to have no source
            // clipping, and to have no empty rectangles (the latter is the
            // reason for the '- 1' on the unsigned compare here):

            if (((cxSrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cySrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cxDst - 1) < STRETCH_MAX_EXTENT)         &&
                ((cyDst - 1) < STRETCH_MAX_EXTENT)         &&
                (prclSrc->left   >= 0)                     &&
                (prclSrc->top    >= 0)                     &&
                (prclSrc->right  <= psoSrc->sizlBitmap.cx) &&
                (prclSrc->bottom <= psoSrc->sizlBitmap.cy))
            {
                // Our snazzy routine only does COLORONCOLOR.  But for
                // stretching blts, BLACKONWHITE and WHITEONBLACK are also
                // equivalent to COLORONCOLOR:

                if ((iMode == COLORONCOLOR) ||
                    ((iMode < COLORONCOLOR) && (cxSrc <= cxDst) && (cySrc <= cyDst)))
                {

                    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                    {
                        rclClip.left   = LONG_MIN;
                        rclClip.top    = LONG_MIN;
                        rclClip.right  = LONG_MAX;
                        rclClip.bottom = LONG_MAX;
                        prclClip = &rclClip;

                    StretchSingleClipRect:

                        if (bBankedStretch(ppdev,
                                        NULL,
                                        ppdev->lDelta,
                                        prclDst,
                                        psoSrc->pvScan0,
                                        psoSrc->lDelta,
                                        prclSrc,
                                        prclClip))
                        {
                            return(TRUE);
                        }
                    }
                    else if (pco->iDComplexity == DC_RECT)
                    {
                        prclClip = &pco->rclBounds;
                        goto StretchSingleClipRect;
                    }
                    else
                    {
                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                        do {
                            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                            c = cIntersect(prclDst, ce.arcl, ce.c);

                            if (c != 0)
                            {
                                for (i = 0; i < c; i++)
                                {
                                    if (!bBankedStretch(ppdev,
                                                     NULL,
                                                     ppdev->lDelta,
                                                     prclDst,
                                                     psoSrc->pvScan0,
                                                     psoSrc->lDelta,
                                                     prclSrc,
                                                     &ce.arcl[i]))
                                    {
                                        goto Punt_It;
                                    }
                                }
                            }

                        } while (bMore);

                        return(TRUE);
                    }
                }
            }
        }
    }

Punt_It:

    // GDI is nice enough to handle the cases where 'psoDst' and/or 'psoSrc'
    // are device-managed surfaces, but it ain't gonna be fast...

    return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                         prclDst, prclSrc, pptlMsk, iMode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\palette.c ===
/******************************************************************************\
*
* $Workfile:   palette.c  $
*
* Palette support.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/palette.c_v  $
 *
 *    Rev 1.2   18 Dec 1996 13:44:10   PLCHU
 *
*
*    Rev 1.1   Oct 10 1996 15:38:38   unknown
*
*
*    Rev 1.1   12 Aug 1996 16:54:26   frido
*
* Added NT 3.5x/4.0 auto detection.
*
*    chu01  12-16-96   Enable color correction
*    myf29  02-12-97   Support Gamma Correction for 755x
*
\******************************************************************************/

#include "precomp.h"

//
// chu01
//
#ifdef GAMMACORRECT

static BOOL bGammaInit = FALSE ;

BOOL bInitGlobalDefPaletteTable = FALSE ;

//
// gamma facter for All, Blue, Green, Red
// contrast facter for All, Blue, Green, Red
//
extern PGAMMA_VALUE    GammaFactor    ;
extern PCONTRAST_VALUE ContrastFactor ;

#endif // GAMMACORRECT

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

//
// chu01
//
#ifdef GAMMACORRECT

    PALETTEENTRY*   pGpal;
    PALETTEENTRY*   ppalFrom;
    PALETTEENTRY*   ppalTo;
    PALETTEENTRY*   ppalEnd;
    int             i;

#endif // GAMMACORRECT

    DISPDBG((2, "bInitializePalette"));

//
// chu01 : Sorry VideoPort_xxxx functions do not work here.
//
#ifdef GAMMACORRECT
    if ((ppdev->iBitmapFormat == BMF_8BPP) ||
        (ppdev->ulChipID == 0x40) ||    //myf29
        (ppdev->ulChipID == 0x4C) ||    //myf29
        (ppdev->ulChipID == 0xBC))
#else
    if (ppdev->iBitmapFormat == BMF_8BPP)
#endif // GAMMACORRECT
    {
        // Allocate our palette:

        ppal = (PALETTEENTRY*) ALLOC(sizeof(PALETTEENTRY) * 256);
        if (ppal == NULL)
            goto ReturnFalse;

        ppdev->pPal = ppal;

//
// chu01
//
#ifdef GAMMACORRECT
        pGpal = (PALETTEENTRY*) ALLOC(sizeof(PALETTEENTRY) * 256) ;
        if (pGpal == NULL)
            goto ReturnFalse ;
        ppdev->pCurrentPalette = pGpal ;
#endif // GAMMACORRECT

        // Generate 256 (8*4*4) RGB combinations to fill the palette

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;

//
// chu01
//
#ifdef GAMMACORRECT
        if ((ppdev->ulChipID == 0xBC) ||
            (ppdev->ulChipID == 0x40) ||    //myf29
            (ppdev->ulChipID == 0x4C))      //myf29
        {
            if ((ppdev->iBitmapFormat == BMF_16BPP) ||
                (ppdev->iBitmapFormat == BMF_24BPP))
            {
                i = 0 ;
                for (ulLoop = 256; ulLoop != 0; ulLoop--)
                {
                    ppalTmp->peRed   = i ;
                    ppalTmp->peGreen = i ;
                    ppalTmp->peBlue  = i ;
                    ppalTmp->peFlags = 0 ;
                    ppalTmp++;
                    i++ ;
                }
                goto bInitPal ;
            }
        }
#endif // GAMMACORRECT


        for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
                if (!(jGre += 32))
                    jBlu += 64;
        }

        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            // First 10

            ppal[ulLoop]       = gapalBase[ulLoop];

            // Last 10

            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }


//
// chu01
//
#ifdef GAMMACORRECT

bInitPal:

        if (!bInitGlobalDefPaletteTable)
        {
            ppalFrom = (PALETTEENTRY*) ppal   ;
            ppalTo   = ppdev->pCurrentPalette ;
            ppalEnd  = &ppalTo[256]           ;

            for (; ppalTo < ppalEnd; ppalFrom++, ppalTo++)
            {
                ppalTo->peRed   = ppalFrom->peRed   ;
                ppalTo->peGreen = ppalFrom->peGreen ;
                ppalTo->peBlue  = ppalFrom->peBlue  ;
                ppalTo->peFlags = 0                 ;
            }
            bInitGlobalDefPaletteTable = TRUE ;
        }

#endif // GAMMACORRECT


        // Create handle for palette.

#ifndef GAMMACORRECT
        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
#else
        if (ppdev->iBitmapFormat == BMF_8BPP)
            hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
        else
            hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                    ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
#endif // !GAMMACORRECT

    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_24BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This case handles only 16, 24 or 32bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        FREE(ppdev->pPal);
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    PALETTEENTRY* ppalFrom;
    PALETTEENTRY* ppalTo;
    PALETTEENTRY* ppalEnd;

//
// chu01
//
#ifdef GAMMACORRECT
    PALETTEENTRY* ppalSrc;
    PALETTEENTRY* ppalDest;
    PALETTEENTRY* ppalLength;
    BOOL status;        //myf29
#endif // GAMMACORRECT

    DISPDBG((2, "bEnablePalette"));
//
// chu01
//
#ifdef GAMMACORRECT
    if ((ppdev->iBitmapFormat == BMF_8BPP) ||
        (ppdev->ulChipID == 0x40) ||    //myf29
        (ppdev->ulChipID == 0x4C) ||    //myf29
        (ppdev->ulChipID == 0xBC))
#else
    if (ppdev->iBitmapFormat == BMF_8BPP)
#endif // GAMMACORRECT
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy Colors in.

        ppalFrom = ppdev->pPal;
        ppalTo   = (PALETTEENTRY*) pScreenClut->LookupTable;
        ppalEnd  = &ppalTo[256];

        for (; ppalTo < ppalEnd; ppalFrom++, ppalTo++)
        {
//
// chu01
//
#ifndef GAMMACORRECT
           ppalTo->peRed   = ppalFrom->peRed   >> 2 ;
           ppalTo->peGreen = ppalFrom->peGreen >> 2 ;
           ppalTo->peBlue  = ppalFrom->peBlue  >> 2 ;
           ppalTo->peFlags = 0 ;
#else
           ppalTo->peRed   = ppalFrom->peRed   ;
           ppalTo->peGreen = ppalFrom->peGreen ;
           ppalTo->peBlue  = ppalFrom->peBlue  ;
           ppalTo->peFlags = 0 ;
#endif // !GAMMACORRECT
        }

//
// chu01
//
#ifdef GAMMACORRECT
        if (!bGammaInit)
        {
            if (ppdev->flCaps & CAPS_GAMMA_CORRECT)
            {
                //
                // Get Gamma factor from registry
                //
                if (!IOCONTROL(ppdev->hDriver,
                               IOCTL_CIRRUS_GET_GAMMA_FACTOR,
                               NULL, ,
                               0,
                               &GammaFactor,
                               sizeof(GammaFactor),
                               &ulReturnedDataLength))
                {
                    DISPDBG((0, "Failed to access Gamma factor from registry"));
                }
                else
                {
                    DISPDBG((0, "G Gamma = %lx", GammaFactor)) ;
                }

                //
                // Get Contrast factor from registry
                //
                if (!IOCONTROL(ppdev->hDriver,
                               IOCTL_CIRRUS_GET_CONTRAST_FACTOR,
                               NULL, ,
                               0,
                               &ContrastFactor,
                               sizeof(ContrastFactor),
                               &ulReturnedDataLength))
                {
                    DISPDBG((0, "Failed to access Contrast factor from registry"));
                }
                else
                {
                    DISPDBG((0, "G Contrast = %lx", ContrastFactor)) ;
                }
            }
            else
            {
                GammaFactor    = 0x7f7f7f7f ;
                ContrastFactor = 0x80 ;
                DISPDBG((0, "G Gamma = %lx", GammaFactor)) ;
                DISPDBG((0, "G Contrast = %lx", ContrastFactor)) ;
            }

            bGammaInit = TRUE ;
        }

        //
        // Save the new palette values
        //
        ppalFrom = (PALETTEENTRY*) pScreenClut->LookupTable;

        ppalTo   = ppdev->pCurrentPalette;
        ppalEnd  = &ppalTo[256];
        for (; ppalTo < ppalEnd; ppalFrom++, ppalTo++)
        {
            ppalTo->peRed   = ppalFrom->peRed   ;
            ppalTo->peGreen = ppalFrom->peGreen ;
            ppalTo->peBlue  = ppalFrom->peBlue  ;
            ppalTo->peFlags = 0 ;
        }

//myf29 begin
        if (ppdev->ulChipID == 0xBC)
            status = bEnableGammaCorrect(ppdev) ;
        else if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID ==0x4C))
            status = bEnableGamma755x(ppdev) ;
//myf29 end

        CalculateGamma( ppdev, pScreenClut, 256 ) ;
#endif // GAMMACORRECT

        // Set palette registers:

        if (!IOCONTROL(ppdev->hDriver,
                       IOCTL_VIDEO_SET_COLOR_REGISTERS,
                       pScreenClut,
                       MAX_CLUT_SIZE,
                       NULL,
                       0,
                       &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE          ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT   pScreenClut;
    PALETTEENTRY* ppal;
    PALETTEENTRY* ppalFrom;
    PALETTEENTRY* ppalTo;
    PALETTEENTRY* ppalEnd;
    BOOL status;                //myf29

    PDEV*         ppdev;

    UNREFERENCED_PARAMETER(fl);

    DISPDBG((2, "---- DrvSetPalette"));

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    ppal = (PPALETTEENTRY) (pScreenClut->LookupTable);

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors, (ULONG*) ppal))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        goto ReturnFalse;
    }

    // Set the high reserved byte in each palette entry to 0.

//
// chu01
//
#ifndef GAMMACORRECT
    for (ppalEnd = &ppal[cColors]; ppal < ppalEnd; ppal++)
    {
        ppal->peRed   >>= 2;
        ppal->peGreen >>= 2;
        ppal->peBlue  >>= 2;
        ppal->peFlags = 0;
    }
#endif // !GAMMACORRECT

    // Set palette registers

    ppdev = (PDEV*) dhpdev;

//
// chu01
//
#ifdef GAMMACORRECT
    //
    // Save the new palette values
    //

    ppalFrom = (PALETTEENTRY*) pScreenClut->LookupTable;
    ppalTo   = ppdev->pCurrentPalette;
    ppalEnd  = &ppalTo[256];
    for (; ppalTo < ppalEnd; ppalFrom++, ppalTo++)
    {
        ppalTo->peRed   = ppalFrom->peRed   ;
        ppalTo->peGreen = ppalFrom->peGreen ;
        ppalTo->peBlue  = ppalFrom->peBlue  ;
        ppalTo->peFlags = 0 ;
    }

//myf29 begin
    if (ppdev->ulChipID == 0xBC)
        status = bEnableGammaCorrect(ppdev) ;
    else if ((ppdev->ulChipID == 0x40) || (ppdev->ulChipID ==0x4C))
        status = bEnableGamma755x(ppdev) ;
//myf29 end

    CalculateGamma( ppdev, pScreenClut, 256 ) ;
#endif // GAMMACORRECT

    if (!IOCONTROL(ppdev->hDriver,
                   IOCTL_VIDEO_SET_COLOR_REGISTERS,
                   pScreenClut,
                   MAX_CLUT_SIZE,
                   NULL,
                   0,
                   &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl\n"));
        goto ReturnFalse;
    }

    return(TRUE);

ReturnFalse:

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\panflags.h ===
//----------------------------Module-Header------------------------------
// Module Name: PANDEF.INC
//
// Panning flags definitions.
//
// Copyright (c) 1996  Cirrus Logic, Inc.
//
//-----------------------------------------------------------------------
// #ew1 02/22/96 created
//-----------------------------------------------------------------------

#ifdef _5446
#define MIN_OLAY_WIDTH  4     //minium overlay window width
#endif

#ifdef _5440
#define MIN_OLAY_WIDTH  12    //minium overlay window width
#endif

#define MAX_STRETCH_SIZE    1024  //in overlay.c


// wVDTflag's and sData.dwPanningFlag values

#define PAN_SUPPORTED   1         //panning is supported
#define PAN_ON          2         //enable panning, bit off = disable

#define OLAY_SHOW       0x100     //overlay is hidden iff bit not set
#define OLAY_REENABLE   0x200     //overlay was fully clipped, need reenabling
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\str.c ===
/******************************************************************************\
*
* $Workfile:   str.c  $
*
* Copyright (c) 1993-1997 Microsoft Corporation
* Copyright (c) 1996-1997 Cirrus Logic, Inc.,
*
* $Log:   S:/projects/drivers/ntsrc/display/STR.C_V  $
 * 
 *    Rev 1.3   10 Jan 1997 15:40:16   PLCHU
 *  
 * 
 *    Rev 1.2   Nov 01 1996 16:52:02   unknown
 * 
 *    Rev 1.1   Oct 10 1996 15:38:58   unknown
* 
*    Rev 1.1   12 Aug 1996 16:54:52   frido
* Removed unaccessed local variables.
* 
*    sge01  : 11-01-96  Fix 24bpp stretch address calculation problem
*    chu01  : 01-02-97  5480 BitBLT enhacement
*  
\******************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8
*
* Routine Description:
*
*   Stretch blt 8->8
*
* NOTE: This routine doesn't handle cases where the blt stretch starts
*       and ends in the same destination dword!  vDirectStretchNarrow
*       is expected to have been called for that case.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yDst        = pStrBlt->YDstStart; // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = xDst;
    LONG    WidthXBytes = WidthX;

    WidthXAln = WidthX - EndAln - ((- (LONG) StartAln) & 0x03);

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    do {
        BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
        ULONG   yTmp;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pjDst = (pjDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pjDst = (pjDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //

            if (ppdev->flCaps & CAPS_MM_IO)
            {
                CP_MM_XCNT(ppdev, pjBase, (WidthXBytes - 1));
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1));

                CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_MM_DST_ADDR(ppdev, pjBase, ((yDst * lDelta) + xDstBytes));

                CP_MM_START_BLT(ppdev, pjBase);

            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch16
*
* Routine Description:
*
*   Stretch blt 16->16
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch16(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    USHORT* pusSrc;
    USHORT* pusDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + xSrc * 2;
    USHORT* pusDst      = (USHORT*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart; // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pusDst & 0x02) >> 1;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)(((ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 2 * WidthX;
    ULONG   yInt        = 0;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = xDst * 2;
    LONG    WidthXBytes = WidthX * 2;

    WidthXAln = WidthX - EndAln - StartAln;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {
        USHORT  usSrc0,usSrc1;
        ULONG   yTmp;

        pusSrc  = (USHORT*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt + (xTmp < xAccum);

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt + (xAccum < xTmp);

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(ULONG*)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pusDst = (USHORT*) ((BYTE*) pusDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pusDst = (USHORT*) ((BYTE*) pusDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //

            if (ppdev->flCaps & CAPS_MM_IO)
            {
                CP_MM_XCNT(ppdev, pjBase, (WidthXBytes - 1)); 
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1));

                CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_MM_DST_ADDR(ppdev, pjBase, ((yDst * lDelta) + xDstBytes));

                CP_MM_START_BLT(ppdev, pjBase);

            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch24
*
* Routine Description:
*
*   Stretch blt 24->24
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch24(
STR_BLT* pStrBlt)
{
    BYTE*   pbSrc;
    BYTE*   pbDstEnd; 
    LONG    WidthXAln;
    ULONG   xAccum;
    ULONG   xTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;
    ULONG   ulSrc0;
    BYTE    bDst0,bDst1,bDst2;
    ULONG   xBits;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + (xSrc << 1) + xSrc;                      // 3 bytes per pixel
    BYTE*   pbDST       = (pStrBlt->pjDstScan) + (xDst << 1) + xDst;                      
    LONG    yDst        = pStrBlt->YDstStart;                                                   // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - (WidthX << 1) -  WidthX;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = (xDst << 1) +  xDst;

    LONG    WidthXBytes = (WidthX << 1) +  WidthX;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)                       // enlargement ?
    {                                                                                                                   // yes.
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {

        ULONG   yTmp;

        pbSrc  = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (ppdev->flCaps & CAPS_MM_IO)                                         // Blt Engine Ready?
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        pbDstEnd  = pbDST + WidthXBytes - 3;

        while (pbDST < pbDstEnd)
        {
            ulSrc0 = *((ULONG*)pbSrc);
            bDst0  = (BYTE) (ulSrc0 & 0xff);
            bDst1  = (BYTE) ((ulSrc0 >> 8) & 0xff);
            bDst2  = (BYTE) ((ulSrc0 >> 16) & 0xff);
            xTmp   = xAccum + xFrac;
            xBits  = xInt + (xTmp < xAccum); 
            xAccum = xTmp;
            pbSrc  += (xBits << 1) + xBits;

            *pbDST++ = bDst0;
            *pbDST++ = bDst1;
            *pbDST++ = bDst2;
        }
        
        //
        // do the last pixel using bye
        //
        *pbDST++  = *pbSrc++;
        *pbDST++  = *pbSrc++;
        *pbDST++  = *pbSrc++;


        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pbDST += lDstStride;
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pbDST += pStrBlt->lDeltaDst;
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //

            if (ppdev->flCaps & CAPS_MM_IO)
            {
                CP_MM_XCNT(ppdev, pjBase, (WidthXBytes - 1));
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1));

                CP_MM_SRC_ADDR(ppdev, pjBase, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_MM_DST_ADDR(ppdev, pjBase, ((yDst * lDelta) + xDstBytes));

                CP_MM_START_BLT(ppdev, pjBase);

            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);
}

// chu01
/******************************Public*Routine******************************\
*
*     B i t B L T   E n h a n c e m e n t   F o r   C L - G D 5 4 8 0
*
\**************************************************************************/

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch8_80
*
* Routine Description:
*
*   Stretch blt 8->8
*   This is for BLT enhancement only, such CL-GD5480.
*
* NOTE: This routine doesn't handle cases where the blt stretch starts
*       and ends in the same destination dword!  vDirectStretchNarrow
*       is expected to have been called for that case.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch8_80(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yDst        = pStrBlt->YDstStart; // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = xDst;
    LONG    WidthXBytes = WidthX;

    WidthXAln = WidthX - EndAln - ((- (LONG) StartAln) & 0x03);

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    //
    // loop drawing each scan line
    //
    //
    // at least 7 wide (DST) blt
    //

    do {
        BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
        ULONG   yTmp;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        //
        // a single src scan line is being written
        //

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt + (xAccum < xTmp);

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pjDst = (pjDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pjDst = (pjDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //
            if (ppdev->flCaps & CAPS_MM_IO)
            {
                // GR33
                CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION) ;

                // GR20, GR21
                CP_MM_XCNT(ppdev, pjBase, (WidthX - 1)) ;

                // GR22, GR23
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1)) ;

                // GR2C, GR2D, GR2E
                CP_MM_SRC_ADDR(ppdev, pjBase, xyOffset) ;

                // GR44, GR45, GR46, GR47
                CP_MM_SRC_XY(ppdev, pjBase, xDst, (yDst - 1)) ;

                // GR28, GR29, GR2A
                CP_MM_DST_ADDR(ppdev, pjBase, 0) ;

                // GR42, GR43
                CP_MM_DST_Y(ppdev, pjBase, yDst) ;

                // GR40, GR41
                CP_MM_DST_X(ppdev, pjBase, xDst) ;
            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);

    // GR33
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0) ;

} // vDirectStretch8_80

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch16_80
*
* Routine Description:
*
*   Stretch blt 16->16
*   This is for BLT enhancement only, such CL-GD5480.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch16_80(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    USHORT* pusSrc;
    USHORT* pusDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    LONG    cyDuplicate;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + xSrc * 2;
    USHORT* pusDst      = (USHORT*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart; // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = ((ULONG)((ULONG_PTR)pusDst & 0x02)) >> 1;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)(((ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 2 * WidthX;
    ULONG   yInt        = 0;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = xDst * 2;
    LONG    WidthXBytes = WidthX * 2;

    WidthXAln = WidthX - EndAln - StartAln;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)
    {
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {
        USHORT  usSrc0,usSrc1;
        ULONG   yTmp;

        pusSrc  = (USHORT*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (ppdev->flCaps & CAPS_MM_IO)
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd  = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {

            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt + (xTmp < xAccum);

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt + (xAccum < xTmp);

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(ULONG*)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt + (xTmp < xAccum);
            *pusDst++ = usSrc0;
        }

        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pusDst = (USHORT*) ((BYTE*) pusDst + lDstStride);
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pusDst = (USHORT*) ((BYTE*) pusDst + pStrBlt->lDeltaDst);
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //
            if (ppdev->flCaps & CAPS_MM_IO)
            {
                // GR33
                CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION) ;

                // GR20, GR21
                CP_MM_XCNT(ppdev, pjBase, ((WidthX << 1) - 1)) ;

                // GR22, GR23
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1)) ;

                // GR2C, GR2D, GR2E
                CP_MM_SRC_ADDR(ppdev, pjBase, xyOffset) ;

                // GR44, GR45, GR46, GR47
                CP_MM_SRC_XY(ppdev, pjBase, xDst << 1, (yDst - 1)) ;

                // GR28, GR29, GR2A
                CP_MM_DST_ADDR(ppdev, pjBase, 0) ;

                // GR42, GR43
                CP_MM_DST_Y(ppdev, pjBase, yDst) ;

                // GR40, GR41
                CP_MM_DST_X(ppdev, pjBase, xDst << 1) ;
            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);

    // GR33
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0) ;

} // vDirectStretch16_80

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDirectStretch24_80
*
* Routine Description:
*
*   Stretch blt 24->24.
*   This is for BLT enhancement only, such CL-GD5480.
*
* Arguments:
*
*   pStrBlt - contains all params for blt
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID vDirectStretch24_80(
STR_BLT* pStrBlt)
{
    BYTE*   pbSrc;
    BYTE*   pbDstEnd; 
    LONG    WidthXAln;
    ULONG   xAccum;
    ULONG   xTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;
    ULONG   ulSrc0;
    BYTE    bDst0,bDst1,bDst2;
    ULONG   xBits;

    PDEV*   ppdev       = pStrBlt->ppdev;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + (xSrc << 1) + xSrc;                      // 3 bytes per pixel
    BYTE*   pbDST       = (pStrBlt->pjDstScan) + (xDst << 1) + xDst;                      
    LONG    yDst        = pStrBlt->YDstStart;                                                   // + ppdev->yOffset;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;
    LONG    lDstStride  = pStrBlt->lDeltaDst - (WidthX << 1) -  WidthX;

    BYTE*   pjPorts     = ppdev->pjPorts;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    lDelta      = ppdev->lDelta;
    LONG    xyOffset    = ppdev->xyOffset;
    LONG    xDstBytes   = (xDst << 1) +  xDst;

    LONG    WidthXBytes = (WidthX << 1) +  WidthX;

    //
    // if this is a shrinking blt, calc src scan line stride
    //

    if (pStrBlt->ulYDstToSrcIntCeil != 0)                       // enlargement ?
    {                                                                                                                   // yes.
        yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;
    }

    // Loop stretching each scan line

    do {

        ULONG   yTmp;

        pbSrc  = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        // A single source scan line is being written:

        if (ppdev->flCaps & CAPS_MM_IO)                                         // Blt Engine Ready?
        {
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
        }
        else
        {
            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
        }

        pbDstEnd  = pbDST + WidthXBytes - 3;

        while (pbDST < pbDstEnd)
        {
            ulSrc0 = *((ULONG*)pbSrc);
            bDst0  = (BYTE) (ulSrc0 & 0xff);
            bDst1  = (BYTE) ((ulSrc0 >> 8) & 0xff);
            bDst2  = (BYTE) ((ulSrc0 >> 16) & 0xff);
            xTmp   = xAccum + xFrac;
            xBits  = xInt + (xTmp < xAccum); 
            xAccum = xTmp;
            pbSrc  += (xBits << 1) + xBits;

            *pbDST++ = bDst0;
            *pbDST++ = bDst1;
            *pbDST++ = bDst2;
        }
        
        //
        // do the last pixel using bye
        //
        *pbDST++  = *pbSrc++;
        *pbDST++  = *pbSrc++;
        *pbDST++  = *pbSrc++;


        pjOldScan = pjSrcScan;
        pjSrcScan += yInt;

        yTmp = yAccum + yFrac;
        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }
        yAccum = yTmp;

        pbDST += lDstStride;
        yDst++;
        yCount--;

        if ((yCount != 0) && (pjSrcScan == pjOldScan))
        {
            // It's an expanding stretch in 'y'; the scan we just laid down
            // will be copied at least once using the hardware:

            cyDuplicate = 0;
            do {
                cyDuplicate++;
                pjSrcScan += yInt;

                yTmp = yAccum + yFrac;
                if (yTmp < yAccum)
                {
                    pjSrcScan += pStrBlt->lDeltaSrc;
                }
                yAccum = yTmp;

                pbDST += pStrBlt->lDeltaDst;
                yCount--;

            } while ((yCount != 0) && (pjSrcScan == pjOldScan));

            // The scan is to be copied 'cyDuplicate' times using the
            // hardware.

            //
            // We don't need to WAIT_FOR_BLT_COMPLETE since we did it above.
            //

            if (ppdev->flCaps & CAPS_MM_IO)
            {
                // GR33
                CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION) ;

                // GR20, GR21
                CP_MM_XCNT(ppdev, pjBase, (WidthX * 3 - 1)) ;

                // GR22, GR23
                CP_MM_YCNT(ppdev, pjBase, (cyDuplicate - 1)) ;

                // GR2C, GR2D, GR2E
                CP_MM_SRC_ADDR(ppdev, pjBase, xyOffset) ;

                // GR44, GR45, GR46, GR47
                CP_MM_SRC_XY(ppdev, pjBase, xDst * 3, (yDst - 1)) ;

                // GR28, GR29, GR2A
                CP_MM_DST_ADDR(ppdev, pjBase, 0) ;

                // GR42, GR43
                CP_MM_DST_Y(ppdev, pjBase, yDst) ;

                // GR40, GR41
                CP_MM_DST_X(ppdev, pjBase, xDst * 3) ;
            }
            else
            {
                CP_IO_XCNT(ppdev, pjPorts, (WidthXBytes - 1));
                CP_IO_YCNT(ppdev, pjPorts, (cyDuplicate - 1));

                CP_IO_SRC_ADDR(ppdev, pjPorts, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
                CP_IO_DST_ADDR(ppdev, pjPorts, ((yDst * lDelta) + xDstBytes));
                CP_IO_START_BLT(ppdev, pjPorts);
            }

            yDst += cyDuplicate;
        }
    } while (yCount != 0);

    // GR33
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION) ;

} // vDirectStretch24_80
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\stripio.c ===
/******************************************************************************\
*
* $Workfile:   stripio.c  $
*
* Do what you can with no line support.
*
* I implemented the horizontal and vertical strip functions using
* solid fills, and removed the usage of diagonal strips.  With a little
* effort you could implement diagonal strips by doing solid fills while
* playing with lDelta.  This is probably not worth the trouble.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/stripio.c_v  $
 * 
 *    Rev 1.1   Oct 10 1996 15:39:12   unknown
 *  
* 
*    Rev 1.1   12 Aug 1996 16:55:04   frido
* Removed unaccessed local variables.
*
\******************************************************************************/

#include "precomp.h"

#define IO_DRAW_HORZ_STRIP(xy, cx, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy;\
\
    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);\
    CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(cx) - 1));\
    CP_IO_YCNT(ppdev, pjPorts, 0);\
    CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);\
    CP_IO_START_BLT(ppdev, pjPorts);\
}

#define IO_DRAW_VERT_STRIP(xy, cy, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy;\
\
    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);\
    CP_IO_XCNT(ppdev, pjPorts, (cBpp - 1));\
    CP_IO_YCNT(ppdev, pjPorts, (cy - 1));\
    CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);\
    CP_IO_START_BLT(ppdev, pjPorts);\
}

#define IO_DRAW_VERT_STRIP_FLIPPED(xy, cy, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy - ((cy - 1) * lDelta);\
\
    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);\
    CP_IO_XCNT(ppdev, pjPorts, (cBpp - 1));\
    CP_IO_YCNT(ppdev, pjPorts, (cy - 1));\
    CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);\
    CP_IO_START_BLT(ppdev, pjPorts);\
}

/******************************Public*Routine******************************\
* VOID vIoSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using solid fills.
*
* Assumes fgRop, BgRop, and Color are already set correctly.
*
\**************************************************************************/

VOID vIoSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjPorts  = ppdev->pjPorts;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG    yInc     = 1;
    LONG    i;

    DISPDBG((2,"vIoSolidHorizontal"));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //
        // Horizontal strips ->
        //                     ->
        //

        for (i = 0; i < cStrips; i++)
        {
            IO_DRAW_HORZ_STRIP(xy, *pStrips, lDelta, cBpp);
            x += *pStrips;
            xy += PELS_TO_BYTES(*pStrips);  // x+
            xy += lDelta;                   // y+
            pStrips++;
        }
        y += cStrips;
    }
    else
    {
        //
        //                     ->
        // Horizontal strips ->
        //

        for (i = 0; i < cStrips; i++)
        {
            IO_DRAW_HORZ_STRIP(xy, *pStrips, lDelta, cBpp);
            x += *pStrips;
            xy += PELS_TO_BYTES(*pStrips);  // x+
            xy -= lDelta;                   // y+
            pStrips++;
        }
        y -= cStrips;
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vIoSolidVertical
*
* Draws left-to-right y-major near-vertical lines using solid fills.
*
\**************************************************************************/

VOID vIoSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjPorts  = ppdev->pjPorts;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG    i;

    DISPDBG((2,"vIoSolidVertical"));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //
        //                  |
        // Vertical strips  v
        //                   |
        //                   v
        //

        for (i = 0; i < cStrips; i++)
        {
            IO_DRAW_VERT_STRIP(xy, *pStrips, lDelta, cBpp);
            y += *pStrips;
            xy += cBpp;                 // x+
            xy += (*pStrips * lDelta);  // y+
            pStrips++;
        }
    }
    else
    {
        //
        //                   ^
        // Vertical strips   |
        //                  ^
        //                  |
        //

        for (i = 0; i < cStrips; i++)
        {
            IO_DRAW_VERT_STRIP_FLIPPED(xy, *pStrips, lDelta, cBpp);
            y -= *pStrips;
            xy += cBpp;                 // x+
            xy -= (*pStrips * lDelta);  // y-
            pStrips++;
        }
    }
    x += cStrips;

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vIoStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vIoStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjPorts  = ppdev->pjPorts;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    x        = pstrip->ptlStart.x;   // x position of start of first strip
    LONG    y        = pstrip->ptlStart.y;   // y position of start of first strip
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG*   plStrip  = pstrip->alStrips;     // Points to current strip
    LONG    cStrips  = pstrip->cStrips;      // Total number of strips we'll do
    LONG    dy;
    LONG    dylDelta;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy = -1;
        dylDelta = -lDelta;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy = 1;
        dylDelta = lDelta;
    }

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;
        xy += dylDelta;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;
        xy += PELS_TO_BYTES(cThis);

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;
        xy += dylDelta;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        IO_DRAW_HORZ_STRIP(xy, cThis, lDelta, cBpp);

        x += cThis;
        xy += PELS_TO_BYTES(cThis); // x+

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vIoStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vIoStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjPorts  = ppdev->pjPorts;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    x        = pstrip->ptlStart.x;   // x position of start of first strip
    LONG    y        = pstrip->ptlStart.y;   // y position of start of first strip
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG*   plStrip  = pstrip->alStrips;     // Points to current strip
    LONG    cStrips  = pstrip->cStrips;      // Total number of strips we'll do
    LONG    dy;
    LONG    dylDelta;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dy = -1;
        dylDelta = -lDelta;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dy = 1;
        dylDelta = lDelta;
    }

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        xy += cBpp;
        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        if (dy > 0)
        {
            y += cThis;
            xy += (cThis * lDelta);
        }
        else
        {
            y -= cThis;
            xy -= (cThis * lDelta);
        }

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        xy += cBpp;
        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        if (dy <= 0)
        {
            IO_DRAW_VERT_STRIP_FLIPPED(xy, cThis, lDelta, cBpp);
            y -=  cThis;                // y-
            xy -=  (cThis * lDelta);    // y-
        }
        else
        {
            IO_DRAW_VERT_STRIP(xy, cThis, lDelta, cBpp);
            y +=  cThis;                // y+
            xy +=  (cThis * lDelta);    // y+
        }


        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\stripmm.c ===
/******************************************************************************\
*
* $Workfile:   stripmm.c  $
*
* Do what you can with no line support.
*
* I implemented the horizontal and vertical strip functions using
* solid fills, and removed the usage of diagonal strips.  With a little
* effort you could implement diagonal strips by doing solid fills while
* playing with lDelta.  This is probably not worth the trouble.
*
* Copyright (c) 1992-1997 Microsoft Corporation
* Copyright (c) 1996-1997 Cirrus Logic, Inc.,
*
* $Log:   S:/projects/drivers/ntsrc/display/STRIPMM.C_V  $
 * 
 *    Rev 1.2   10 Jan 1997 15:40:18   PLCHU
 *  
* 
*    Rev 1.1   Oct 10 1996 15:39:22   unknown
*  
* 
*    Rev 1.1   12 Aug 1996 16:55:04   frido
* Removed unaccessed local variables.
*
*    chu01  : 01-02-97  5480 BitBLT enhancement 
*    chu02  : 01-09-97  Macro redefinition
*
\******************************************************************************/

#include "precomp.h"

#define count COMMAND_TOTAL_PACKETS

#define MM_DRAW_HORZ_STRIP(xy, cx, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy;\
\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_XCNT(ppdev, pjBase, (PELS_TO_BYTES(cx) - 1));\
    CP_MM_YCNT(ppdev, pjBase, 0);\
    CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);\
    CP_MM_START_BLT(ppdev, pjBase);\
}

#define MM_DRAW_VERT_STRIP(xy, cy, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy;\
\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_XCNT(ppdev, pjBase, (cBpp - 1));\
    CP_MM_YCNT(ppdev, pjBase, (cy - 1));\
    CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);\
    CP_MM_START_BLT(ppdev, pjBase);\
}

#define MM_DRAW_VERT_STRIP_FLIPPED(xy, cy, lDelta, cBpp)\
{\
    ULONG   ulDstAddr;\
\
    ulDstAddr = xy - ((cy - 1) * lDelta);\
\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_XCNT(ppdev, pjBase, (cBpp - 1));\
    CP_MM_YCNT(ppdev, pjBase, (cy - 1));\
    CP_MM_DST_ADDR(ppdev, pjBase, ulDstAddr);\
    CP_MM_START_BLT(ppdev, pjBase);\
}

// chu01, chu02
#define MM_DRAW_HORZ_STRIP80(x, y, cx)\
{\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION);\
    CP_MM_XCNT(ppdev, pjBase, (cx - 1));\
    CP_MM_YCNT(ppdev, pjBase, 0);\
    CP_MM_DST_ADDR(ppdev, pjBase, 0);\
    CP_MM_DST_Y(ppdev, pjBase, y);\
    CP_MM_DST_X(ppdev, pjBase, x);\
}

#define MM_DRAW_VERT_STRIP80(x, y, cy)\
{\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION);\
    CP_MM_XCNT(ppdev, pjBase, 0);\
    CP_MM_YCNT(ppdev, pjBase, (cy - 1));\
    CP_MM_DST_ADDR(ppdev, pjBase, 0);\
    CP_MM_DST_Y(ppdev, pjBase, y);\
    CP_MM_DST_X(ppdev, pjBase, x);\
}

#define MM_DRAW_VERT_STRIP_FLIPPED80(x, y, cy)\
{\
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);\
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_XY_POSITION);\
    CP_MM_XCNT(ppdev, pjBase, 0);\
    CP_MM_YCNT(ppdev, pjBase, (cy - 1));\
    CP_MM_DST_ADDR(ppdev, pjBase, 0);\
    CP_MM_DST_Y(ppdev, pjBase, ((y - cy) + 1));\
    CP_MM_DST_X(ppdev, pjBase, x);\
}

/******************************Public*Routine******************************\
* VOID vMmSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using solid fills.
*
* Assumes fgRop, BgRop, and Color are already set correctly.
*
\**************************************************************************/

VOID vMmSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG    yInc     = 1;
    LONG    i;

    DISPDBG((2, "vMmSolidHorizontal"));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //
        // Horizontal strips ->
        //                     ->
        //

        for (i = 0; i < cStrips; i++)
        {
            MM_DRAW_HORZ_STRIP(xy, *pStrips, lDelta, cBpp);
            x += *pStrips;
            xy += PELS_TO_BYTES(*pStrips);  // x+
            xy += lDelta;                   // y+
            pStrips++;
        }
        y += cStrips;
    }
    else
    {
        //
        //                     ->
        // Horizontal strips ->
        //

        for (i = 0; i < cStrips; i++)
        {
            MM_DRAW_HORZ_STRIP(xy, *pStrips, lDelta, cBpp);
            x += *pStrips;
            xy += PELS_TO_BYTES(*pStrips);  // x+
            xy -= lDelta;                   // y+
            pStrips++;
        }
        y -= cStrips;
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmSolidVertical
*
* Draws left-to-right y-major near-vertical lines using solid fills.
*
\**************************************************************************/

VOID vMmSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    cStrips  = pStrip->cStrips;
    PLONG   pStrips  = pStrip->alStrips;
    LONG    x        = pStrip->ptlStart.x;
    LONG    y        = pStrip->ptlStart.y;
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG    i;

    DISPDBG((2, "vMmSolidVertical"));

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //
        //                  |
        // Vertical strips  v
        //                   |
        //                   v
        //

        for (i = 0; i < cStrips; i++)
        {
            MM_DRAW_VERT_STRIP(xy, *pStrips, lDelta, cBpp);
            y += *pStrips;
            xy += cBpp;                 // x+
            xy += (*pStrips * lDelta);  // y+
            pStrips++;
        }
    }
    else
    {
        //
        //                   ^
        // Vertical strips   |
        //                  ^
        //                  |
        //

        for (i = 0; i < cStrips; i++)
        {
            MM_DRAW_VERT_STRIP_FLIPPED(xy, *pStrips, lDelta, cBpp);
            y -= *pStrips;
            xy += cBpp;                 // x+
            xy -= (*pStrips * lDelta);  // y-
            pStrips++;
        }
    }
    x += cStrips;

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vMmStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    x        = pstrip->ptlStart.x;   // x position of start of first strip
    LONG    y        = pstrip->ptlStart.y;   // y position of start of first strip
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG*   plStrip  = pstrip->alStrips;     // Points to current strip
    LONG    cStrips  = pstrip->cStrips;      // Total number of strips we'll do
    LONG    dy;
    LONG    dylDelta;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    DISPDBG((2, "vMmStyledHorizontal"));

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy = -1;
        dylDelta = -lDelta;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy = 1;
        dylDelta = lDelta;
    }

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;
        xy += dylDelta;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;
        xy += PELS_TO_BYTES(cThis);

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;
        xy += dylDelta;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        MM_DRAW_HORZ_STRIP(xy, cThis, lDelta, cBpp);

        x += cThis;
        xy += PELS_TO_BYTES(cThis); // x+

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vMmStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjBase   = ppdev->pjBase;
    LONG    cBpp     = ppdev->cBpp;
    LONG    lDelta   = ppdev->lDelta;
    LONG    x        = pstrip->ptlStart.x;   // x position of start of first strip
    LONG    y        = pstrip->ptlStart.y;   // y position of start of first strip
    LONG    xy       = PELS_TO_BYTES(x) + (lDelta * y);
    LONG*   plStrip  = pstrip->alStrips;     // Points to current strip
    LONG    cStrips  = pstrip->cStrips;      // Total number of strips we'll do
    LONG    dy;
    LONG    dylDelta;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    DISPDBG((2, "vMmStyledVertical")) ;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dy = -1;
        dylDelta = -lDelta;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dy = 1;
        dylDelta = lDelta;
    }

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        xy += cBpp;
        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        if (dy > 0)
        {
            y += cThis;
            xy += (cThis * lDelta);
        }
        else
        {
            y -= cThis;
            xy -= (cThis * lDelta);
        }

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        xy += cBpp;
        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        if (dy <= 0)
        {
            MM_DRAW_VERT_STRIP_FLIPPED(xy, cThis, lDelta, cBpp);
            y -=  cThis;                // y-
            xy -=  (cThis * lDelta);    // y-
        }
        else
        {
            MM_DRAW_VERT_STRIP(xy, cThis, lDelta, cBpp);
            y +=  cThis;                // y+
            xy +=  (cThis * lDelta);    // y+
        }


        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vInvalidStrip
*
* Put this in the function table for entries that shouldn't get hit.
*
\**************************************************************************/

VOID vInvalidStrip(
PDEV*       ppdev,          // unused
STRIP*      pStrip,         // unused
LINESTATE*  pLineState)     // unused
{

    RIP("vInvalidStrip called");
    return;
}

// chu01
/******************************Public*Routine******************************\
*
*     B i t B L T   E n h a n c e m e n t   F o r   C L - G D 5 4 8 0
*
\**************************************************************************/

VOID vMmSolidHorizontal80(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase      = ppdev->pjBase ;
    LONG    cBpp        = ppdev->cBpp ;
    LONG    lDelta      = ppdev->lDelta ;
    LONG    cStrips     = pStrip->cStrips ;
    PLONG   pStrips     = pStrip->alStrips ;   // cx for each stroke
    LONG    x           = pStrip->ptlStart.x ; // X-position
    LONG    y           = pStrip->ptlStart.y ; // Y-position
    LONG    yOrg        = y ;
    LONG    yInc        = 1 ;
    LONG    x0, y0, cx ;

    ULONG   ulDstOffset = 0 ;
    ULONG_PTR* ulCLStart ;
    ULONG   ulWidthHeight ;

    LONG    i           = 0 ;
    BYTE    MM1B ;

    DISPDBG((2, "vMmSolidHorizontal80")) ;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //                          
        // Horizontal strips ->     1.
        //                     ->       2.
        //
        if (cStrips != 1)
        {
            MM1B = ENABLE_COMMAND_LIST | ENABLE_XY_POSITION | SRC_CPU_DATA ;
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, MM1B) ;
Loop_H1:
            ulCLStart = ppdev->pCommandList ;
            ulDstOffset = (ULONG)(((ULONG_PTR)ulCLStart
                                 - (ULONG_PTR)ppdev->pjScreen) << 14) ;
            CP_MM_CL_SWITCH(ppdev) ;

            // First strip
            x0 = x ;
            y0 = y ;
            cx = *pStrips ;
            i++ ;

            // Next strip
            y++ ;
            x += cx ; 
            pStrips++ ;

            while (TRUE)
            {
                // GR20, GR21, GR22, GR23
                ulWidthHeight = PACKXY_FAST((*pStrips - 1), 0) ;
                ulWidthHeight |= COMMAND_NOSRC_NOTHING ;

                // GR40, GR41, GR42, GR43
                *(ulCLStart + 1) = PACKXY_FAST(x, y) ;

                // GR2C, GR2D, GR2E
                *(ulCLStart + 2) = 0 ;

                i++ ;

                if ((i == cStrips) || ((i % count) == 0))
                {
                    // Last Command
                    ulWidthHeight |= COMMAND_LAST_PACKET ;
                    *ulCLStart = ulWidthHeight ;
                    break ;
                }
                *ulCLStart = ulWidthHeight ;

                // Next strip
                y++ ;
                x += *pStrips ; 
                pStrips++ ;
                ulCLStart += 4 ;
            }

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
            CP_MM_XCNT(ppdev, pjBase, (cx - 1)) ;
            CP_MM_YCNT(ppdev, pjBase, 0) ;
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset) ;
            CP_MM_DST_Y(ppdev, pjBase, y0) ;
            CP_MM_DST_X(ppdev, pjBase, x0) ;

            if (i == cStrips)
                x += *pStrips ; 
            else if ((i % count) == 0)
            {
                // 
                // Resume a new command list
                //
                y++ ;
                cx = *pStrips ;
                x += cx ; 
                pStrips++ ; 
                if (i != (cStrips - 1))
                {
                    goto Loop_H1 ;
                }
                else
                {
                    MM_DRAW_HORZ_STRIP80(x, y, *pStrips) ;
                    x += *pStrips ;
                    pStrips++;
                }
            }
        }
        else
        {
            MM_DRAW_HORZ_STRIP80(x, y, *pStrips) ;
            x += *pStrips ;
            pStrips++;
        }
        yOrg += cStrips;
    }
    else
    {
        //
        //                     ->     2.
        // Horizontal strips ->     1.
        //
        if (cStrips != 1)
        {
            MM1B = ENABLE_COMMAND_LIST | ENABLE_XY_POSITION | SRC_CPU_DATA ;
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, MM1B) ;
Loop_H2:
            ulCLStart = ppdev->pCommandList;
            ulDstOffset = (ULONG)(((ULONG_PTR)ulCLStart
                                 - (ULONG_PTR)ppdev->pjScreen) << 14) ;
            CP_MM_CL_SWITCH(ppdev) ;

            // First strip
            x0 = x ;
            y0 = y ;
            cx = *pStrips ;
            i++ ;

            // Next strip
            y-- ;
            x += cx ; 
            pStrips++ ;

            while (TRUE)
            {
                // GR20, GR21, GR22, GR23
                ulWidthHeight = PACKXY_FAST((*pStrips - 1), 0) ;
                ulWidthHeight |= COMMAND_NOSRC_NOTHING ;

                // GR40, GR41, GR42, GR43
                *(ulCLStart + 1) = PACKXY_FAST(x, y) ;

                // GR2C, GR2D, GR2E
                *(ulCLStart + 2) = 0 ;

                i++ ;

                if ((i == cStrips) || ((i % count) == 0))
                {
                    // Last Command
                    ulWidthHeight |= COMMAND_LAST_PACKET ;
                    *ulCLStart = ulWidthHeight ;
                    break ;
                }
                *ulCLStart = ulWidthHeight ;

                // Next strip
                y-- ;
                x += *pStrips ; 
                pStrips++ ;
                ulCLStart += 4 ;
            }

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
            CP_MM_XCNT(ppdev, pjBase, (cx - 1)) ;
            CP_MM_YCNT(ppdev, pjBase, 0) ;
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset) ;
            CP_MM_DST_Y(ppdev, pjBase, y0) ;
            CP_MM_DST_X(ppdev, pjBase, x0) ;

            if (i == cStrips)
                x += *pStrips ; 
            else if ((i % count) == 0) 
            {
                // 
                // Resume a new command list
                //
                y-- ;
                cx = *pStrips ;
                x += cx ; 
                pStrips++ ; 
                if (i != (cStrips - 1))
                {
                    goto Loop_H2 ;
                }
                else
                {
                    MM_DRAW_HORZ_STRIP80(x, y, *pStrips) ;
                    x += *pStrips ;
                    pStrips++;
                }
            }
        }
        else
        {
            MM_DRAW_HORZ_STRIP80(x, y, *pStrips) ;
            x += *pStrips ;
            pStrips++;
        }
        yOrg -= cStrips;
    }

    pStrip->ptlStart.x = x    ;
    pStrip->ptlStart.y = yOrg ;

}

/******************************Public*Routine******************************\
* VOID vMmSolidVertical80
*
* Draws left-to-right y-major near-vertical lines using solid fills.
*
\**************************************************************************/

VOID vMmSolidVertical80(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase      = ppdev->pjBase ;
    LONG    cBpp        = ppdev->cBpp ;
    LONG    lDelta      = ppdev->lDelta ;
    LONG    cStrips     = pStrip->cStrips ;
    PLONG   pStrips     = pStrip->alStrips ;
    LONG    x           = pStrip->ptlStart.x ;
    LONG    y           = pStrip->ptlStart.y ;
    LONG    xOrg        = x ;
    LONG    x0, y0, cy ;

    ULONG   ulDstOffset = 0 ;
    ULONG_PTR* ulCLStart ;
    ULONG   ulWidthHeight ;

    LONG    i           = 0 ;
    BYTE    MM1B ;

    DISPDBG((2, "vMmSolidVertical80")) ;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        //
        //                  |     1.
        // Vertical strips  v
        //                   |     2.
        //                   v
        //
        if (cStrips != 1)
        {
            MM1B = ENABLE_COMMAND_LIST | ENABLE_XY_POSITION | SRC_CPU_DATA ;
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, MM1B) ;
Loop_V1:
            ulCLStart = ppdev->pCommandList ;
            ulDstOffset = (ULONG)(((ULONG_PTR)ulCLStart
                                 - (ULONG_PTR)ppdev->pjScreen) << 14) ;
            CP_MM_CL_SWITCH(ppdev) ;

            // First strip
            x0 = x ; 
            y0 = y ;
            cy = *pStrips ;
            i++ ;

            // Next strip
            x++ ; 
            y += cy ; 
            pStrips++ ;

            while (TRUE)
            {
                // GR20, GR21, GR22, GR23
                ulWidthHeight = PACKXY_FAST(0, (*pStrips - 1)) ;
                ulWidthHeight |= COMMAND_NOSRC_NOTHING ;

                // GR40, GR41, GR42, GR43
                *(ulCLStart + 1) = PACKXY_FAST(x, y) ;

                // GR2C, GR2D, GR2E
                *(ulCLStart + 2) = 0 ;

                i++ ;

                if ((i == cStrips) || ((i % count) == 0))
                {
                    // Last Command
                    ulWidthHeight |= COMMAND_LAST_PACKET ;
                    *ulCLStart = ulWidthHeight ;
                    break ;
                }
                *ulCLStart = ulWidthHeight ;

                // Next strip
                x++ ;
                y += *pStrips ; 
                pStrips++ ;
                ulCLStart += 4 ;
            }
            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
            CP_MM_XCNT(ppdev, pjBase, 0) ;
            CP_MM_YCNT(ppdev, pjBase, (cy - 1)) ;
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset) ;
            CP_MM_DST_Y(ppdev, pjBase, y0) ;
            CP_MM_DST_X(ppdev, pjBase, x0) ;

            if (i == cStrips)
                y += *pStrips ; 
            else if ((i % count) == 0) 
            {
                // 
                // Resume a new command list
                //
                x++ ;
                cy = *pStrips ;
                y += cy ; 
                pStrips++ ; 
                if (i != (cStrips - 1))
                {
                    goto Loop_V1 ;
                }
                else
                {
                    MM_DRAW_VERT_STRIP80(x, y, *pStrips) ;
                    y += *pStrips ;
                    pStrips++;
                }
            }
        }
        else
        {
            MM_DRAW_VERT_STRIP80(x, y, *pStrips) ;
            y += *pStrips ;
            pStrips++;
        }
    }
    else
    {
        //
        //                   ^
        // Vertical strips   |     2.
        //                  ^
        //                  |     1.
        //

        if (cStrips != 1)
        {
            MM1B = ENABLE_COMMAND_LIST | ENABLE_XY_POSITION | SRC_CPU_DATA ;
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, MM1B) ;
Loop_V2:
            ulCLStart = ppdev->pCommandList ;
            ulDstOffset = (ULONG)(((ULONG_PTR)ulCLStart
                                 - (ULONG_PTR)ppdev->pjScreen) << 14) ;
            CP_MM_CL_SWITCH(ppdev) ;

            // First strip
            x0 = x ;
            cy = *pStrips ;
            y -= (cy - 1) ;
            y0 = y ;

            i++ ;
            pStrips++ ;

            // Next strip
            x++ ;
            y -= *pStrips ;

            while (TRUE)
            {
                // GR20, GR21, GR22, GR23
                ulWidthHeight = PACKXY_FAST(0, (*pStrips - 1)) ;
                ulWidthHeight |= COMMAND_NOSRC_NOTHING ;

                // GR40, GR41, GR42, GR43
                *(ulCLStart + 1) = PACKXY_FAST(x, y) ;

                // GR2C, GR2D, GR2E
                *(ulCLStart + 2) = 0 ;

                i++ ;

                if ((i == cStrips) || ((i % count) == 0))
                {
                    // Last Command
                    ulWidthHeight |= COMMAND_LAST_PACKET ;
                    *ulCLStart = ulWidthHeight ;
                    break ;
                }
                *ulCLStart = ulWidthHeight ;

                // Next strip
                x++ ;
                pStrips++ ;
                y -= *pStrips ; 

                ulCLStart += 4 ;
            }

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
            CP_MM_XCNT(ppdev, pjBase, 0) ;
            CP_MM_YCNT(ppdev, pjBase, (cy - 1)) ;
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset) ;
            CP_MM_DST_Y(ppdev, pjBase, y0) ;
            CP_MM_DST_X(ppdev, pjBase, x0);

            if (i == cStrips)
                y -= *pStrips ; 
            else if ((i % count) == 0)
            {
                // 
                // Resume a new command list
                //
                x++ ;
                y-- ; 
                pStrips++ ; 

                if (i != (cStrips - 1))
                {
                    goto Loop_V2 ;
                }
                else
                {
                    MM_DRAW_VERT_STRIP80(x, y, *pStrips) ;
                    y -= *pStrips ;
                    pStrips++;
                }
            }
        }
        else
        {
            MM_DRAW_VERT_STRIP_FLIPPED80(x, y, *pStrips) ;
            y -= *pStrips ;
            pStrips++;
        }
    }

    xOrg += cStrips ;
    pStrip->ptlStart.x = xOrg ;
    pStrip->ptlStart.y = y    ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\stroke.c ===
/******************************************************************************\
*
* $Workfile:   stroke.c  $
*
* DrvStrokePath for the display driver.
*
* Copyright (c) 1992-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/STROKE.C_V  $
 *
 *    Rev 1.3   10 Jan 1997 15:40:18   PLCHU
 *
 *
 *    Rev 1.2   Nov 07 1996 16:48:06   unknown
 *
 *
 *    Rev 1.1   Oct 10 1996 15:39:26   unknown
 *
*
*    Rev 1.1   12 Aug 1996 16:55:06   frido
* Removed unaccessed local variables.
*
*    chu01  : 01-02-97  5480 BitBLT enhancement
*
*
\******************************************************************************/

#include "precomp.h"

VOID (*gapfnStripMm[])(PDEV*, STRIP*, LINESTATE*) = {
    vMmSolidHorizontal,
    vMmSolidVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vMmSolidHorizontal,
    vMmSolidVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vMmStyledHorizontal,
    vMmStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

    vMmStyledHorizontal,
    vMmStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal
};

VOID (*gapfnStripIo[])(PDEV*, STRIP*, LINESTATE*) = {
    vIoSolidHorizontal,
    vIoSolidVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vIoSolidHorizontal,
    vIoSolidVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vIoStyledHorizontal,
    vIoStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

    vIoStyledHorizontal,
    vIoStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal
};

// chu01
VOID (*gapfnPackedStripMm[])(PDEV*, STRIP*, LINESTATE*) = {
    vMmSolidHorizontal80,
    vMmSolidVertical80,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vMmSolidHorizontal80,
    vMmSolidVertical80,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vMmStyledHorizontal,
    vMmStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal

    vMmStyledHorizontal,
    vMmStyledVertical,
    vInvalidStrip,              // Diagonal
    vInvalidStrip,              // Diagonal
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

BOOL bPuntStrokePath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pbo,
POINTL    *pptlBrushOrg,
LINEATTRS *plineattrs,
MIX        mix);


/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    PDEV    *ppdev = (PDEV*) pso->dhpdev;
    DSURF   *pdsurf;
    OH*      poh;
    LONG     cBpp;
    BYTE     jHwRop;
    BYTE     jMode;
    ULONG    ulSolidColor;

    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    RECTL     arclClip[4];                  // For rectangular clipping

    if ((mix & 0xf) != 0x0d) DISPDBG((3,"Line with mix(%x)", mix));

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    poh   = pdsurf->poh;
    cBpp  = ppdev->cBpp;

    ppdev->xOffset  = poh->x;
    ppdev->yOffset  = poh->y;
    ppdev->xyOffset = poh->xy;

    if ((DRIVER_PUNT_ALL) || (DRIVER_PUNT_LINES))
    {
        return bPuntStrokePath(pso,ppo,pco,pxo,pbo,pptlBrush,pla,mix);
    }

    //
    // Get the device ready:
    //

    jHwRop = gajHwMixFromMix[mix & 0xf];

    // Get the color expanded to a DWORD in the blt parameters.
    // replicate the color from a byte to a dword.
    // NOTE: this is pixel depth specific.

    jMode = ENABLE_COLOR_EXPAND |
            ENABLE_8x8_PATTERN_COPY |
            ppdev->jModeColor;

    ulSolidColor = pbo->iSolidColor;

    if (cBpp == 1)
    {
        ulSolidColor |= ulSolidColor << 8;
        ulSolidColor |= ulSolidColor << 16;
    }
    else if (cBpp == 2)
    {
        ulSolidColor |= ulSolidColor << 16;
    }

//
// chu01
//
    if ((ppdev->flCaps & CAPS_COMMAND_LIST) && (ppdev->pCommandList != NULL))
    {
        ULONG    jULHwRop                 ;
        DWORD    jExtMode = 0             ;
        BYTE*    pjBase   = ppdev->pjBase ;

        jULHwRop = gajHwPackedMixFromMix[mix & 0xf] ;
        jExtMode = (ENABLE_XY_POSITION_PACKED | ENABLE_COLOR_EXPAND |
                     ENABLE_8x8_PATTERN_COPY | ppdev->jModeColor) ;
        CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase) ;
        CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset) ;
        CP_MM_DST_Y_OFFSET(ppdev, pjBase, ppdev->lDelta) ;
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode | jULHwRop) ;
        CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor) ;
    }
    else
    {
        if (ppdev->flCaps & CAPS_MM_IO)
        {
            BYTE * pjBase = ppdev->pjBase;

            CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
            CP_MM_ROP(ppdev, pjBase, jHwRop);
            CP_MM_SRC_ADDR(ppdev, pjBase, ppdev->ulSolidColorOffset);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, ppdev->lDelta);
            CP_MM_BLT_MODE(ppdev, pjBase, jMode);
            CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);
        }
        else
        {
            BYTE * pjPorts = ppdev->pjPorts;

            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
            CP_IO_ROP(ppdev, pjPorts, jHwRop);
            CP_IO_SRC_ADDR(ppdev, pjPorts, ppdev->ulSolidColorOffset);
            CP_IO_DST_Y_OFFSET(ppdev, pjPorts, ppdev->lDelta);
            CP_IO_BLT_MODE(ppdev, pjPorts, jMode);
            CP_IO_FG_COLOR(ppdev, pjPorts, ulSolidColor);
        }
     }

    fl = 0;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_STYLED;
        ls.ulStartMask = 0L;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_STYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

// chu01
    if ((ppdev->flCaps & CAPS_COMMAND_LIST) && (ppdev->pCommandList != NULL))
    {
        apfn = &gapfnPackedStripMm[NUM_STRIP_DRAW_STYLES *
                ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
    }
    else if (ppdev->flCaps & CAPS_MM_IO)
    {
        apfn = &gapfnStripMm[NUM_STRIP_DRAW_STYLES *
                ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
    }
    else
    {
        apfn = &gapfnStripIo[NUM_STRIP_DRAW_STYLES *
                ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
    }

// Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*) NULL;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            arclClip[0]        =  pco->rclBounds;

        // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

        // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

        // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }

        pd.flags = 0;
        PATHOBJ_vEnumStart(ppo);
        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    goto ReturnFalse;
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    goto ReturnFalse;
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

        // Masked styles don't normalize the style state.  It's a good
        // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                    goto ReturnFalse;
            }
        } while (bMore);
    }

    return(TRUE);

ReturnFalse:
    return(FALSE);
}


BOOL bPuntStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    PDEV* ppdev = (PDEV*) pso->dhpdev;
    BOOL     b = TRUE;

    if (pso->iType == STYPE_BITMAP)
    {
        b = EngStrokePath(pso,ppo,pco,pxo,pbo,
                          pptlBrush,pla,mix);
        goto ReturnStatus;
    }

    if (DIRECT_ACCESS(ppdev))
    {
        //////////////////////////////////////////////////////////////////////
        // Banked Framebuffer bPuntBlt
        //
        // This section of code handles a PuntBlt when GDI can directly draw
        // on the framebuffer, but the drawing has to be done in banks:

        BANK     bnk;

        {
            ASSERTDD(pso->iType != STYPE_BITMAP,
                     "Dest should be the screen");

            // Do a memory-to-screen blt:

            if (ppdev->bLinearMode)
            {
                SURFOBJ* psoPunt = ppdev->psoPunt;
                OH*      poh     = ((DSURF*) pso->dhsurf)->poh;

                psoPunt->pvScan0 = poh->pvScan0;
                ppdev->pfnBankSelectMode(ppdev, BANK_ON);

                b = EngStrokePath(psoPunt,ppo,pco,pxo,pbo,
                                  pptlBrush,pla,mix);

                goto ReturnStatus;
            }

            {
                RECTL   rclDraw;
                RECTL  *prclDst = &pco->rclBounds;

                FLOAT_LONG  elSavedStyleState = pla->elStyleState;

                {
                    // The bank manager requires that the 'draw' rectangle be
                    // well-ordered:

                    rclDraw = *prclDst;
                    if (rclDraw.left > rclDraw.right)
                    {
                        rclDraw.left   = prclDst->right;
                        rclDraw.right  = prclDst->left;
                    }
                    if (rclDraw.top > rclDraw.bottom)
                    {
                        rclDraw.top    = prclDst->bottom;
                        rclDraw.bottom = prclDst->top;
                    }

                    vBankStart(ppdev, &rclDraw, pco, &bnk);

                    b = TRUE;
                    do {
                        pla->elStyleState = elSavedStyleState;

                        b &= EngStrokePath(bnk.pso,
                                           ppo,
                                           bnk.pco,
                                           pxo,
                                           pbo,
                                           pptlBrush,
                                           pla,
                                           mix);
                    } while (bBankEnum(&bnk));
                }
            }
        }

        goto ReturnStatus;
    }
    else
    {
        //////////////////////////////////////////////////////////////////////
        // Really Slow bPuntStrokePath
        //
        // Here we handle a bPuntStrokePath when GDI can't draw directly on the
        // framebuffer (as on the Alpha, which can't do it because of its
        // 32 bit bus).  If you thought the banked version was slow, just
        // look at this one.  Guaranteed, there will one bitmap
        // allocation and extra copy involved

        RECTL   rclDst;
        RECTFX  rcfxBounds;
        SIZEL   sizl;
        LONG    lDelta;
        BYTE*   pjBits;
        BYTE*   pjScan0;
        HSURF   hsurfDst;
        RECTL   rclScreen;

        PATHOBJ_vGetBounds(ppo, &rcfxBounds);

        rclDst.left   = (rcfxBounds.xLeft   >> 4);
        rclDst.top    = (rcfxBounds.yTop    >> 4);
        rclDst.right  = (rcfxBounds.xRight  >> 4) + 2;
        rclDst.bottom = (rcfxBounds.yBottom >> 4) + 2;

        //
        // This function is guarenteed to get a clip object.  Since the
        // rounding of the above calculation can give us a rectangle
        // outside the screen area, we must clip to the drawing area.
        //

        {
            ASSERTDD(pco != NULL, "clip object pointer is NULL");

            // We have to intersect the destination rectangle with
            // the clip bounds if there is one (consider the case
            // where the app asked to blt a really, really big
            // rectangle from the screen -- prclDst would be really,
            // really big but pco->rclBounds would be the actual
            // area of interest):

            rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
            rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
            rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
            rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);
        }

        sizl.cx = rclDst.right  - rclDst.left;
        sizl.cy = rclDst.bottom - rclDst.top;

        // We need to create a temporary work buffer.  We have to do
        // some fudging with the offsets so that the upper-left corner
        // of the (relative coordinates) clip object bounds passed to
        // GDI will be transformed to the upper-left corner of our
        // temporary bitmap.

        // The alignment doesn't have to be as tight as this at 16bpp
        // and 32bpp, but it won't hurt:

        lDelta = PELS_TO_BYTES(((rclDst.right + 3) & ~3L) - (rclDst.left & ~3L));

        // We're actually only allocating a bitmap that is 'sizl.cx' x
        // 'sizl.cy' in size:

        pjBits = ALLOC(lDelta * sizl.cy);
        if (pjBits == NULL)
            goto ReturnStatus;

        // We now adjust the surface's 'pvScan0' so that when GDI thinks
        // it's writing to pixel (rclDst.top, rclDst.left), it will
        // actually be writing to the upper-left pixel of our temporary
        // bitmap:

        pjScan0 = pjBits - (rclDst.top * lDelta)
                         - PELS_TO_BYTES(rclDst.left & ~3L);

        ASSERTDD((((ULONG_PTR) pjScan0) & 3) == 0,
                "pvScan0 must be dword aligned!");

        // The checked build of GDI sometimes checks on blts that
        // prclDst->right <= pso->sizl.cx, so we lie to it about
        // the size of our bitmap:

        sizl.cx = rclDst.right;
        sizl.cy = rclDst.bottom;

        hsurfDst = (HSURF) EngCreateBitmap(
                    sizl,                   // Bitmap covers rectangle
                    lDelta,                 // Use this delta
                    ppdev->iBitmapFormat,   // Same colour depth
                    BMF_TOPDOWN,            // Must have a positive delta
                    NULL); //pjScan0);               // Where (0, 0) would be

        if ((hsurfDst == 0) ||
            (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
        {
            DISPDBG((0,"bPuntStrokePath - EngCreateBitmap or "
                       "EngAssociateSurface failed"));
            goto Error_3;
        }

        pso = EngLockSurface(hsurfDst);
        if (pso == NULL)
        {
            DISPDBG((0,"bPuntStrokePath - EngLockSurface failed"));
            goto Error_4;
        }

        // Make sure that the rectangle we Get/Put from/to the screen
        // is in absolute coordinates:

        rclScreen.left   = rclDst.left   + ppdev->xOffset;
        rclScreen.right  = rclDst.right  + ppdev->xOffset;
        rclScreen.top    = rclDst.top    + ppdev->yOffset;
        rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

        // It would be nice to get a copy of the destination rectangle
        // only when the ROP involves the destination (or when the source
        // is an RLE), but we can't do that.  If the brush is truly NULL,
        // GDI will immediately return TRUE from EngBitBlt, without
        // modifying the temporary bitmap -- and we would proceed to
        // copy the uninitialized temporary bitmap back to the screen.

        ppdev->pfnGetBits(ppdev, pso, &rclDst, (POINTL*) &rclScreen);

        b = EngStrokePath(pso,ppo,pco,pxo,pbo,
                          pptlBrush,pla,mix);

        ppdev->pfnPutBits(ppdev, pso, &rclScreen, (POINTL*) &rclDst);

        EngUnlockSurface(pso);

    Error_4:

        EngDeleteSurface(hsurfDst);

    Error_3:

        FREE(pjBits);
    }

ReturnStatus:

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\i386\strucs.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: strucs.inc
;
; Most of these definitions are pulled straight from winddi.h.  We have
; to copy these here because we don't have any good 'h2inc' C-include-to-
; Asm-include program for NT.
;
; Copyright (c) 1993-1994 Microsoft Corporation
;----------------------------------------------------------------------------;

BMF_1BPP        equ     1
BMF_4BPP        equ     2
BMF_8BPP        equ     3
BMF_16BPP       equ     4
BMF_24BPP       equ     5
BMF_32BPP       equ     6

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL          STRUC
ptl_x           DD      0
ptl_y           DD      0
POINTL          ENDS

;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL           STRUC
sizl_cx         DD      0
sizl_cy         DD      0
SIZEL           ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;


RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends

;-----------------------------------------------------------------------;
; Definition of the physical device data structure
;
; NOTE: Changes to this structure must be reflected in driver.h!
;-----------------------------------------------------------------------;

PDEV                struc           ; /* pdev, ppdev */
pdev_xOffset            dd  ?
pdev_yOffset            dd  ?
pdev_xyOffset           dd  ?
pdev_pjBase             dd  ?
pdev_pjPorts            dd  ?
pdev_pjScreen           dd  ?
pdev_iBitmapFormat      dd  ?
pdev_ulChipID           dd  ?
pdev_ulChipNum          dd  ?
PDEV                ends

;-----------------------------------------------------------------------;
; Definition of our realized brush structures.
;
; NOTE: Changes to these structure must be reflected in driver.h!
;-----------------------------------------------------------------------;

RBRUSH              struc           ; /* rb, prb */
rb_fl                   dd  ?
rb_bTransparent         dd  ?
rb_ulForeColor          dd  ?
rb_ulBackColor          dd  ?
rb_ptlBrushOrg          db  (size POINTL) dup(?)
rb_apbe                 dd  ?

; I haven't declared rb_aulPattern because we don't know the size of the
; rb_apbe array here.

RBRUSH              ends

BRUSHENTRY          struc           ; /* be, pbe */
be_prbVerify            dd  ?
be_x                    dd  ?
be_y                    dd  ?
be_xy                   dd  ?
BRUSHENTRY          ends

;-----------------------------------------------------------------------;
; Definitions for text output
;-----------------------------------------------------------------------;

GLYPHPOS    struc           ; /* gp */
gp_hg       dd      ?       ; hglyph (unused by vga)
gp_pgdf     dd      ?       ; glyphdef
gp_x        dd      ?       ; glyph x position
gp_y        dd      ?       ; glyph y position
GLYPHPOS    ends

GLYPHDEF struc              ; /* gdf */
gdf_pgb     dd      ?       ; points to GLYPHBITS
GLYPHDEF ends

GLYPHBITS struc             ; /* gb */
gb_x        dd      ?       ; glyph x offset
gb_y        dd      ?       ; glyph y offset
gb_cx       dd      ?       ; glyph width in pels
gb_cy       dd      ?       ; glyph height in pels
gb_aj       db      ?       ; glyph bit mask
GLYPHBITS ends

;-----------------------------------------------------------------------;
; Macro to do a simple RET, with no stack stuff, in a proc.
;-----------------------------------------------------------------------;

PLAIN_RET macro
        db      0c3h
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\thunk.c ===
/******************************************************************************\
*
* $Workfile:   thunk.c  $
*
* This module exists solely for testing, to make it is easy to instrument
* all the driver's Drv calls.
*
* Note that most of this stuff will only be compiled in a checked (debug)
* build.
*
* Copyright (c) 1993-1995 Microsoft Corporation
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/thunk.c_v  $
 * 
 *    Rev 1.1   Oct 10 1996 15:39:32   unknown
 *  
* 
*    Rev 1.5   12 Aug 1996 16:55:12   frido
* Added NT 3.5x/4.0 auto detection.
* 
*    Rev 1.4   20 Jul 1996 13:47:40   frido
* Added DbgDestroyFont.
* 
*    Rev 1.3   19 Jul 1996 00:50:26   frido
* Fixed a typo.
* 
*    Rev 1.2   12 Jul 1996 19:49:24   frido
* Added DbgLineTo and fixed GWM 4 debugging.
* 
*    Rev 1.1   03 Jul 1996 13:36:44   frido
* Added debugging thunks for DirectDraw code.
*
\**************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////

#if DBG

// This entire module is only enabled for checked builds

#define SYNCH_ENTER()   0   // do nothing
#define SYNCH_LEAVE()   0   // do nothing


////////////////////////////////////////////////////////////////////////////

BOOL gbNull = FALSE;    // Set to TRUE with the debugger to test the speed
                        //   of NT with an inifinitely fast display driver
                        //   (actually, almost infinitely fast since we're
                        //   not hooking all the calls we could be)


DHPDEV DbgEnablePDEV(
DEVMODEW*   pDevmode,
PWSTR       pwszLogAddress,
ULONG       cPatterns,
HSURF*      ahsurfPatterns,
ULONG       cjGdiInfo,
ULONG*      pGdiInfo,
ULONG       cjDevInfo,
DEVINFO*    pDevInfo,
HDEV        hdev,
PWSTR       pwszDeviceName,
HANDLE      hDriver)
{
    DHPDEV bRet;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnablePDEV"));

    bRet = DrvEnablePDEV(
                pDevmode,
                pwszLogAddress,
                cPatterns,
                ahsurfPatterns,
                cjGdiInfo,
                pGdiInfo,
                cjDevInfo,
                pDevInfo,
                hdev,
                pwszDeviceName,
                hDriver);

    DISPDBG((6, "DrvEnablePDEV done"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvCompletePDEV"));

    DrvCompletePDEV(
                dhpdev,
                hdev);

    DISPDBG((6, "DrvCompletePDEV done"));
    SYNCH_LEAVE();
}

VOID DbgDisablePDEV(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisable"));

    DrvDisablePDEV(dhpdev);

    DISPDBG((6, "DrvDisable done"));
    SYNCH_LEAVE();
}

HSURF DbgEnableSurface(DHPDEV dhpdev)
{
    HSURF h;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnableSurface"));

    h = DrvEnableSurface(dhpdev);

    DISPDBG((6, "DrvEnableSurface done"));
    SYNCH_LEAVE();

    return(h);
}

VOID DbgDisableSurface(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisableSurface"));

    DrvDisableSurface(dhpdev);

    DISPDBG((6, "DrvDisableSurface done"));
    SYNCH_LEAVE();
}

#if (NT_VERSION < 0x0400)
VOID DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvAssertMode"));
    DrvAssertMode(dhpdev,bEnable);
    DISPDBG((6, "DrvAssertMode done"));
    SYNCH_LEAVE();
}
#else
BOOL DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, "DrvAssertMode"));

    b = DrvAssertMode(dhpdev,bEnable);

    DISPDBG((6, "DrvAssertMode done"));
    SYNCH_LEAVE();

    return (b);
}
#endif

//
// We do not SYNCH_ENTER since we have not initalized the driver.
// We just want to get the list of modes from the miniport.
//

ULONG DbgGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG u;

    DISPDBG((5, "DrvGetModes"));

    u = DrvGetModes(
                hDriver,
                cjSize,
                pdm);

    DISPDBG((6, "DrvGetModes done"));

    return(u);
}

VOID DbgMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    if (gbNull)
        return;

    // Note: Because we set GCAPS_ASYNCMOVE, we don't want to do a
    //       SYNCH_ENTER/LEAVE here.

    DISPDBG((5, "DrvMovePointer"));

    DrvMovePointer(pso,x,y,prcl);

    DISPDBG((6, "DrvMovePointer done"));
}

ULONG DbgSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    ULONG u;

    if (gbNull)
        return(SPS_ACCEPT_NOEXCLUDE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPointerShape"));

    u = DrvSetPointerShape(
                pso,
                psoMask,
                psoColor,
                pxlo,
                xHot,
                yHot,
                x,
                y,
                prcl,
                fl);

    DISPDBG((6, "DrvSetPointerShape done"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    ULONG u;

    if (gbNull)
        return(DCR_DRIVER);

    //
    // No need to Synchronize Dither color.
    //

    DISPDBG((5, "DrvDitherColor"));

    u = DrvDitherColor(
                dhpdev,
                iMode,
                rgb,
                pul);

    DISPDBG((6, "DrvDitherColor done"));

    return(u);
}

BOOL DbgSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPalette"));

    u = DrvSetPalette(
                dhpdev,
                ppalo,
                fl,
                iStart,
                cColors);

    DISPDBG((6, "DrvSetPalette done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvCopyBits"));

    u = DrvCopyBits(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                pptlSrc);

    DISPDBG((6, "DrvCopyBits done"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvBitBlt"));

    u = DrvBitBlt(
                psoDst,
                psoSrc,
                psoMask,
                pco,
                pxlo,
                prclDst,
                pptlSrc,
                pptlMask,
                pbo,
                pptlBrush,
                rop4);

    DISPDBG((6, "DrvBitBlt done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvTextOut"));

    u = DrvTextOut(
                pso,
                pstro,
                pfo,
                pco,
                prclExtra,
                prclOpaque,
                pboFore,
                pboOpaque,
                pptlOrg,
                mix);

    DISPDBG((6, "DrvTextOut done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStrokePath"));

    u = DrvStrokePath(
                pso,
                ppo,
                pco,
                pxo,
                pbo,
                pptlBrushOrg,
                plineattrs,
                mix);

    DISPDBG((6, "DrvStrokePath done"));
    SYNCH_LEAVE();

    return(u);
}

// crus
//#if RE_ENABLE_FILL
BOOL DbgFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvFillPath"));

    u = DrvFillPath(pso,
                ppo,
                pco,
                pbo,
                pptlBrushOrg,
                mix,
                flOptions);

    DISPDBG((6, "DrvFillPath done"));
    SYNCH_LEAVE();

    return(u);
}
//#endif

BOOL DbgRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    BOOL u;

    // Note: The only time DrvRealizeBrush is called by GDI is when we've
    //       called BRUSHOBJ_pvGetRbrush in the middle of a DrvBitBlt
    //       call, and GDI had to call us back.  Since we're still in the
    //       middle of DrvBitBlt, synchronization has already taken care of.
    //       For the same reason, this will never be called when 'gbNull'
    //       is TRUE, so it doesn't even make sense to check gbNull...

    DISPDBG((5, "DrvRealizeBrush"));

    u = DrvRealizeBrush(
                pbo,
                psoTarget,
                psoPattern,
                psoMask,
                pxlo,
                iHatch);

    DISPDBG((6, "DrvRealizeBrush done"));

    return(u);
}

HBITMAP DbgCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    HBITMAP hbm;

    if (gbNull)                     // I would pretend to have created a
        return(FALSE);              //   bitmap when gbNull is set, by we
                                    //   would need some code to back this
                                    //   up so that the system wouldn't
                                    //   crash...

    SYNCH_ENTER();
    DISPDBG((5, "DrvCreateDeviceBitmap"));

    hbm = DrvCreateDeviceBitmap(dhpdev, sizl, iFormat);

    DISPDBG((6, "DrvCreateDeviceBitmap done"));
    SYNCH_LEAVE();

    return(hbm);
}

VOID DbgDeleteDeviceBitmap(DHSURF dhsurf)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDeleteDeviceBitmap"));

    DrvDeleteDeviceBitmap(dhsurf);

    DISPDBG((6, "DrvDeleteDeviceBitmap done"));
    SYNCH_LEAVE();
}

BOOL DbgStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStretchBlt"));

    u = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMask, iMode);

    DISPDBG((6, "DrvStretchBlt done"));
    SYNCH_LEAVE();

    return(u);
}

#if DIRECTDRAW
BOOL DbgGetDirectDrawInfo(
DHPDEV       dhpdev,
DD_HALINFO*  pHalInfo,
DWORD*       lpdwNumHeaps,
VIDEOMEMORY* pvmList,
DWORD*       lpdwNumFourCC,
DWORD*       lpdwFourCC)
{
    BOOL bRet;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgGetDirectDrawInfo"));

    bRet = DrvGetDirectDrawInfo(dhpdev, pHalInfo, lpdwNumHeaps, pvmList,
                                lpdwNumFourCC, lpdwFourCC);

    DISPDBG((6, "<< DbgGetDirectDrawInfo"));
    SYNCH_LEAVE();

    return(bRet);
}
#endif

#if DIRECTDRAW
BOOL DbgEnableDirectDraw(
DHPDEV               dhpdev,
DD_CALLBACKS*        pCallBacks,
DD_SURFACECALLBACKS* pSurfaceCallBacks,
DD_PALETTECALLBACKS* pPaletteCallBacks)
{
    BOOL bRet;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgEnableDirectDraw"));

    bRet = DrvEnableDirectDraw(dhpdev, pCallBacks, pSurfaceCallBacks,
                               pPaletteCallBacks);

    DISPDBG((6, "<< DbgEnableDirectDraw"));
    SYNCH_LEAVE();

    return(bRet);
}
#endif

#if DIRECTDRAW
VOID DbgDisableDirectDraw(
DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgDisableDirectDraw"));

    DrvDisableDirectDraw(dhpdev);

    DISPDBG((6, "<< DbgDisableDirectDraw"));
    SYNCH_LEAVE();
}
#endif

#if LINETO
BOOL DbgLineTo(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
LONG      x1,
LONG      y1,
LONG      x2,
LONG      y2,
RECTL*    prclBounds,
MIX       mix)
{
    BOOL bRet;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgLineTo"));

    bRet = DrvLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);

    DISPDBG((6, "<< DbgLineTo"));
    SYNCH_LEAVE();

    return(bRet);
}
#endif

#if 1 // Font cache
VOID DbgDestroyFont(
FONTOBJ* pfo)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgDestroyFont"));

    DrvDestroyFont(pfo);

    DISPDBG((6, "<< DbgDestroyFont"));
    SYNCH_LEAVE();
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\i386\strx86.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: str.asm
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated StretchBlt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\hw.inc
        .list

        .data

;
;  stack based params and local variables
;

STACK_STRUC             struc

; Feel free to add any local variables here:

sp_TempXFrac            dd      ?
sp_YCarry               dd      ?
sp_LeftCase             dd      ?
sp_RightCase            dd      ?
sp_pjSrcScan            dd      ?
sp_SrcIntStep           dd      ?
sp_DstStride            dd      ?
sp_XCntHW               dd      ?
sp_XCount               dd      ?
sp_xyOFfset             dd      ?
sp_yDst                 dd      ?
sp_pdev                 dd      ?

; Don't add any fields below here without modifying PROC_MEM_SIZE!

sp_ebp                  dd      ?
sp_esi                  dd      ?
sp_edi                  dd      ?
sp_ebx                  dd      ?
sp_RetAddr              dd      ?
sp_pSTR_BLT             dd      ?   ; If adding parameters, adjust 'ret' value!
STACK_STRUC             ends

PROC_MEM_SIZE           equ     6 * 4

;
; Make sure this STR_BLT matches that declared in driver.h!
;

STR_BLT                 struc
str_ppdev               dd      ?
str_pjSrcScan           dd      ?
str_lDeltaSrc           dd      ?
str_XSrcStart           dd      ?
str_pjDstScan           dd      ?
str_lDeltaDst           dd      ?
str_XDstStart           dd      ?
str_XDstEnd             dd      ?
str_YDstStart           dd      ?
str_YDstCount           dd      ?
str_ulXDstToSrcIntCeil  dd      ?
str_ulXDstToSrcFracCeil dd      ?
str_ulYDstToSrcIntCeil  dd      ?
str_ulYDstToSrcFracCeil dd      ?
str_ulXFracAccumulator  dd      ?
str_ulYFracAccumulator  dd      ?
STR_BLT                 ends

        .code

;---------------------------Public-Routine------------------------------;
; VOID vDirectStretch8(pStrBlt)
;
; NOTE: This routine doesn't handle cases where the blt stretch starts
;       and ends in the same destination dword!  vDirectStretchNarrow
;       is expected to have been called for that case.
;
; Stretch blt 8 -> 8
;-----------------------------------------------------------------------;

        public vDirectStretch8@4

vDirectStretch8@4 proc near

        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size STACK_STRUC) - PROC_MEM_SIZE  ; make room for local variables

        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        ;
        ; load up some stack-based parameters to be used by our scan
        ; duplicator when doing vertical stretches
        ;

        mov     eax,[ebp].str_ppdev
        mov     ecx,[ebp].str_YDstStart                 ; get start y coordinate
        mov     [esp].sp_pdev,eax                       ; save ppdev pointer

        mov     ebx,[eax].pdev_xyOffset
        mov     [esp].sp_xyOffset,ebx                   ; save xyOffset

        mov     [esp].sp_yDst,ecx                       ; save current y coordinate

        ;
        ; calc starting addressing parameters
        ;

        mov     esi,[ebp].str_pjSrcScan                 ; load src DIB pointer
        add     esi,[ebp].str_XSrcStart                 ; add starting Src Pixel
        mov     edi,[ebp].str_pjDstScan                 ; load dst DIB pointer
        add     edi,[ebp].str_XDstStart                 ; add strarting Dst Pixel
        mov     [esp].sp_pjSrcScan,esi                  ; save scan line start pointer
        mov     eax,[ebp].str_ulYDstToSrcIntCeil        ; number of src scan lines to step
        mul     [ebp].str_lDeltaSrc                     ; calc scan line int lines to step
        mov     [esp].sp_SrcIntStep,eax                 ; save int portion of Y src step
        mov     edx,4                                   ; calc left bytes = (4 - LeftCase) & 0x03
        sub     edx,edi
        and     edx,3                                   ; left edge bytes
        mov     [esp].sp_LeftCase,edx                   ; save left edge case pixels (4-LeftCase)&0x03
        mov     eax,[ebp].str_pjDstScan                 ; make copy
        mov     ecx,[ebp].str_XDstEnd                   ; load x end
        add     eax,ecx                                 ; ending dst addr
        and     eax,3                                   ; calc right edge case
        mov     [esp].sp_RightCase,eax                  ; save right edge case
        sub     ecx,[ebp].str_XDstStart                 ; calc x count

        dec     ecx
        mov     [esp].sp_XCntHW,ecx                     ; x width for accelerator
        inc     ecx

        mov     ebx,[ebp].str_lDeltaDst                 ; dst scan line stride
        sub     ebx,ecx                                 ; distance from end of one line to start of next
        mov     [esp].sp_DstStride,ebx                  ; save dst scan line stride
        sub     ecx,eax                                 ; sub right edge from XCount
        sub     ecx,edx                                 ; sub left edge from XCount
        shr     ecx,2                                   ; convert from byte to DWORD count
        mov     [esp].sp_XCount,ecx                     ; save DWORD count
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get x frac
        mov     [esp].sp_TempXFrac,ebx                  ; save x frac to a esp based location

NextScan:

        ;
        ; Wait until the accelerator is done with current blt
        ;

        mov     dx,3ceh     ;index register
        mov     al,31h      ;status reg
        out     dx,al
        mov     dx,3cfh     ;data register
@@:     in      al,dx
        test    al,1
        jnz     short @b

SingleLoop:

        ;
        ; esi and edi are assumed to be correctly loaded
        ;

        mov     eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get src frac step for step in dst
        mov     edx,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

        mov     ebp,edi                                 ; get dst pointer to ebp

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

        mov     edi,edx                                 ; get accumulator where we want it
        mov     ecx,[esp].sp_LeftCase

        ; eax = integer step in source
        ; ebx = fractional step in source
        ; ecx = left edge case
        ; edx = free for pixel data
        ; esi = pointer to source pixel
        ; edi = fractional accumulator
        ; ebp = pointer to dest pixel

        ;
        ; first do the left side to align dwords
        ;

        test    ecx,ecx
        jz      DwordAligned

@@:
        mov     dl,[esi]                                ; fetch pixel
        mov     [ebp],dl                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        inc     ebp                                     ; step 1 in dest
        dec     ecx                                     ; dec left count
        jne     @B                                      ; repeat until done

DwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length

@@:
        mov     dl,[esi]                                ; get a source pixel edx = ???0
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add integer and carry

        add     edi,ebx                                 ; step fraction
        mov     dh,[esi]                                ; get source pixel edx = ??10
        adc     esi,eax                                 ; add integer and carry

        shl     edx,16                                  ; edx = 10??

        add     edi,ebx                                 ; step fraction
        mov     dl,[esi]                                ; get a source pixel edx = 10?2
        adc     esi,eax                                 ; add integer and carry

        add     edi,ebx                                 ; step fraction
        mov     dh,[esi]                                ; get source pixel edx = 0132
        adc     esi,eax                                 ; add integer and carry

        ror     edx,16                                  ; edx = 3210

        mov     [ebp],edx                               ; write everything to dest

        add     ebp,4                                   ; increment dest pointer by 1 dword
        dec     ecx                                     ; decrement count
        jnz     @b                                      ; do more pixels

        ;
        ; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        test    ecx,ecx
        jz      EndScanLine

@@:

        mov     dl,[esi]                                ; fetch pixel
        mov     [ebp],dl                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        inc     ebp                                     ; step 1 in dest
        dec     ecx                                     ; dec right count
        jnz     @b                                      ; repeat until done

EndScanLine:

        mov     edi,ebp                                 ; get dst pointer back
        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

EndSkipScan:

        mov     esi,[esp].sp_pjSrcScan                  ; load src scan start addr
        mov     ebx,esi                                 ; save a copy
        mov     eax,[ebp].str_ulYFracAccumulator        ; get .32 part of Y pointer
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        add     esi,[esp].sp_SrcIntStep                 ; step int part
        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan addr
        add     edi,[esp].sp_DstStride                  ; step to next scan in dst
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      Done                                    ; no more scans

        inc     [esp].sp_yDst                           ; one scan further down in dst
        cmp     esi,ebx                                 ; is src scan same as before?
        jne     NextScan                                ; if so, fall through to dupe scan

        ;--------------------------------------------------------------------
        ; The source scan is the same one used for the previous destination
        ; scan, so we can simply use the hardware to copy the previous
        ; destination scan.
        ;
        ; Since on the S3 we can set up a 'rolling blt' to copy one scan
        ; line to several scans in a single command, we will count up how
        ; many times this scan should be duplicated.  If your hardware
        ; cannot do a rolling blt, simply issue a new blt command for
        ; every time the scan should be duplicated.
        ;
        ; eax = ulYFracAccumulator
        ; ebx = original pjSrcScan
        ; esi = current pjSrcScan
        ; ebp = pSTR_BLT
        ;

        mov     ecx,-1                                  ; number of times scan is to be
                                                        ;  duplicated, less one
AnotherDuplicate:

        inc     ecx                                     ; one scan further down
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      OutputDuplicates                        ; no more scans
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     add     esi,[esp].sp_SrcIntStep                 ; step int part
        add     edi,[ebp].str_lDeltaDst                 ; step entire dest scan
        cmp     esi,ebx                                 ; is src scan same as before?
        je      AnotherDuplicate

OutputDuplicates:

        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan address
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        ;
        ; Now output the command to do the 'rolling blt'
        ;

        ;; mov     edx,[esp].sp_pjBase

        ;
        ; Wait until the accelerator is done with current blt
        ;

        mov     dx,3ceh     ;index register
        mov     al,31h      ;status reg
        out     dx,al
        mov     dx,3cfh     ;data register
@@:     in      al,dx
        test    al,1
        jnz     short @b

        mov     ebx,[esp].sp_XCntHW
        mov     eax,[esp].sp_yDst

        ; eax = yDst      -- Destination scan line (source scan line is yDst - 1)
        ; ebx = XCntHW    -- Number of bytes across (width) - 1
        ; ecx = cy        -- Number of times scan is to be duplicated - 1
        ; ebp = pSTR_BLT  -- Stretch blt info

DuplicateViaMmIo:

        ;
        ; Do the copy:
        ;

if 0
        CP_XCNT(ppdev, pjBase, (WidthXBytes - 1));
        CP_YCNT(ppdev, pjBase, (cyDuplicate - 1));
        CP_SRC_ADDR(ppdev, pjBase, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
        SET_DEST_ADDR(ppdev, ((yDst * lDelta) + xDstBytes));
        START_ACL(ppdev);
endif

        .errnz  RECT_HEIGHT

        ;; mov     [edx+OFFSET_wXCnt],bx
        ;; mov     [edx+OFFSET_wYCnt],cx

        mov     dx,3ceh     ;index register

        ;
        ; set XCNT=bx and YCNT=cx
        ;

		push	eax

        mov     al,21h      ;BLT_WIDTH_HIGH
        mov     ah,bh       ;x count high byte
        out     dx,ax
        mov     al,20h      ;BLT_WIDTH_LOW
        mov     ah,bl       ;x count low byte
        out     dx,ax

        mov     al,23h      ;BLT_HEIGHT_HIGH
        mov     ah,ch       ;y count high byte
        out     dx,ax
        mov     al,22h      ;BLT_HEIGHT_LOW
        mov     ah,cl       ;y count low byte
        out     dx,ax

		pop		eax

        ;
        ; Calculate src address
        ;

        mov     ebx,eax                                 ; ebx <- yDst
        dec     ebx
        imul    ebx,[ebp].str_lDeltaDst
        add     ebx,[esp].sp_xyOffset
        add     ebx,[ebp].str_xDstStart

        ;; mov     [edx+OFFSET_ulSrcAddr],ebx

		push	eax

        mov     al,2ch      ;SRC_ADDR_LOW
        mov     ah,bl       ;src addr low byte
        out     dx,ax
        mov     al,2dh      ;SRC_ADDR_MID
        mov     ah,bh       ;src addr mid byte
        out     dx,ax

        shr     ebx,16

        mov     al,2eh      ;SRC_ADDR_HIGH
        mov     ah,bl       ;src addr high byte
        out     dx,ax

		pop		eax

        ;
        ; Calculate dst address
        ;

        inc     eax                                     ; account for 'ecx' being
                                                        ;  one less than scan count

        mov     ebx,eax                                 ; ebx <- yDst
        dec     ebx
        imul    ebx,[ebp].str_lDeltaDst
        add     ebx,[esp].sp_xyOffset
        add     ebx,[ebp].str_xDstStart

        ;; mov     [edx+OFFSET_ulDstAddr],ebx

        push	eax

        mov     al,28h      ;DST_ADDR_LOW
        mov     ah,bl       ;dst addr low byte
        out     dx,ax
        mov     al,29h      ;DST_ADDR_MID
        mov     ah,bh       ;dst addr mid byte
        out     dx,ax

        shr     ebx,16

        mov     al,2ah      ;DST_ADDR_HIGH
        mov     ah,bl       ;dst addr high byte
        out     dx,ax

        ;
        ; Start blt
        ;

        mov     al,31h      ;BLT_START_STATUS_REG
        mov     ah,2        ;BLT_START
        out     dx,ax

		pop		eax

DoneSetDestAddr:

        add     eax,ecx                                 ; add num scans just done
        mov     [esp].sp_yDst,eax

DoneDuplicate:

        cmp     [ebp].str_YDstCount,0                   ; we might be all done
        jne     NextScan

Done:

        add     esp,(size STACK_STRUC) - PROC_MEM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     4

vDirectStretch8@4 endp

;---------------------------Public-Routine------------------------------;
; VOID vDirectStretch16(pStrBlt)
;
; Stretch blt 16 -> 16
;-----------------------------------------------------------------------;

        public vDirectStretch16@4

vDirectStretch16@4 proc near

        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size STACK_STRUC) - PROC_MEM_SIZE  ; make room for local variables

        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        ;
        ; load up some stack-based parameters to be used by our scan
        ; duplicator when doing vertical stretches
        ;

        mov     eax,[ebp].str_ppdev
        mov     ecx,[ebp].str_YDstStart                 ; get start y coordinate
        mov     [esp].sp_pdev,eax                       ; save ppdev pointer

        mov     ebx,[eax].pdev_xyOffset
        mov     [esp].sp_xyOffset,ebx                   ; save xyOffset

        mov     [esp].sp_yDst,ecx                       ; save current y coordinate

        ;
        ; calc starting addressing parameters
        ;

        mov     esi,[ebp].str_pjSrcScan                 ; load src DIB pointer
        mov     eax,[ebp].str_XSrcStart
        mov     edi,[ebp].str_pjDstScan                 ; load dst DIB pointer
        mov     ebx,[ebp].str_XDstStart
        add     esi,eax
        add     edi,ebx
        add     esi,eax                                 ; add starting Src Pixel
        add     edi,ebx                                 ; add starting Dst Pixel
        mov     [esp].sp_pjSrcScan,esi                  ; save scan line start pointer
        mov     eax,[ebp].str_ulYDstToSrcIntCeil        ; number of src scan lines to step
        mul     [ebp].str_lDeltaSrc                     ; calc scan line int lines to step
        mov     [esp].sp_SrcIntStep,eax                 ; save int portion of Y src step
        mov     edx,edi                                 ; make copy of pjDst
        and     edx,2                                   ; calc left edge case
        shr     edx,1                                   ; left edge pixels
        mov     [esp].sp_LeftCase,edx                   ; save left edge case pixels
        mov     eax,[ebp].str_pjDstScan                 ; make copy
        mov     ecx,[ebp].str_XDstEnd                   ; load x end
        add     eax,ecx
        add     eax,ecx                                 ; ending dst addr
        and     eax,2                                   ; calc right edge case
        shr     eax,1                                   ; right edge pixels
        mov     [esp].sp_RightCase,eax                  ; save right edge case
        sub     ecx,[ebp].str_XDstStart                 ; calc x count

        shl     ecx,1
        dec     ecx
        mov     [esp].sp_XCntHW,ecx                     ; x width for accelerator
        inc     ecx
        shr     ecx,1

        mov     ebx,[ebp].str_lDeltaDst                 ; dst scan line stride
        sub     ebx,ecx
        sub     ebx,ecx                                 ; distance from end of one line to start of next
        mov     [esp].sp_DstStride,ebx                  ; save dst scan line stride
        sub     ecx,eax                                 ; sub right edge from XCount
        sub     ecx,edx                                 ; sub left edge from XCount
        shr     ecx,1                                   ; convert from pixels to DWORD count
        mov     [esp].sp_XCount,ecx                     ; save DWORD count
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get x frac
        mov     [esp].sp_TempXFrac,ebx                  ; save x frac to a esp based location

NextScan:

        ;
        ; Wait until the accelerator is done with current blt
        ;

        mov     dx,3ceh     ;index register
        mov     al,31h      ;status reg
        out     dx,al
        mov     dx,3cfh     ;data register
@@:     in      al,dx
        test    al,1
        jnz     short @b

SingleLoop:

        ;
        ; esi and edi are assumed to be correctly loaded
        ;

        mov     eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get src frac step for step in dst
        mov     edx,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

        mov     ebp,edi                                 ; get dst pointer to ebp

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

        mov     edi,edx                                 ; get accumulator where we want it
        mov     ecx,[esp].sp_LeftCase

        ; eax = integer step in source
        ; ebx = fractional step in source
        ; ecx = left edge case
        ; edx = free for pixel data
        ; esi = pointer to source pixel
        ; edi = fractional accumulator
        ; ebp = pointer to dest pixel

        ;
        ; divide 'esi' by 2 so that we can always dereference it by
        ; [2*esi] -- this allows us to still use an 'add with carry'
        ; to jump to the next pixel
        ;

        shr     esi,1

        ;
        ; first do the left side to align dwords
        ;

        test    ecx,ecx
        jz      DwordAligned

        mov     dx,[2*esi]                              ; fetch pixel
        mov     [ebp],dx                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        add     ebp,2                                   ; step 1 in dest

DwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length
        test    ecx,ecx
        jz      TrailingBytes                           ; watch for zero dword case

@@:
        mov     dx,[2*esi]                              ; get a source pixel
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add integer and carry

        shl     edx,16

        add     edi,ebx                                 ; step fraction
        mov     dx,[2*esi]                              ; get source pixel
        adc     esi,eax                                 ; add integer and carry

        ror     edx,16

        mov     [ebp],edx                               ; write everything to dest

        add     ebp,4                                   ; increment dest pointer by 1 dword
        dec     ecx                                     ; decrement count
        jnz     @b                                      ; do more pixels

TrailingBytes:

        ;
        ; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        test    ecx,ecx
        jz      EndScanLine

        mov     dx,[2*esi]                              ; fetch pixel
        mov     [ebp],dx                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        add     ebp,2                                   ; step 1 in dest

EndScanLine:

        mov     edi,ebp                                 ; get dst pointer back
        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

EndSkipScan:

        mov     esi,[esp].sp_pjSrcScan                  ; load src scan start addr
        mov     ebx,esi                                 ; save a copy
        mov     eax,[ebp].str_ulYFracAccumulator        ; get .32 part of Y pointer
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        add     esi,[esp].sp_SrcIntStep                 ; step int part
        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan addr
        add     edi,[esp].sp_DstStride                  ; step to next scan in dst
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      Done                                    ; no more scans

        inc     [esp].sp_yDst                           ; one scan further down in dst
        cmp     esi,ebx                                 ; is src scan same as before?
        jne     NextScan                                ; if so, fall through to dupe scan

        ;--------------------------------------------------------------------
        ; The source scan is the same one used for the previous destination
        ; scan, so we can simply use the hardware to copy the previous
        ; destination scan.
        ;
        ; Since on the S3 we can set up a 'rolling blt' to copy one scan
        ; line to several scans in a single command, we will count up how
        ; many times this scan should be duplicated.  If your hardware
        ; cannot do a rolling blt, simply issue a new blt command for
        ; every time the scan should be duplicated.
        ;
        ; eax = ulYFracAccumulator
        ; ebx = original pjSrcScan
        ; esi = current pjSrcScan
        ; ebp = pSTR_BLT
        ;

        mov     ecx,-1                                  ; number of times scan is to be
                                                        ;  duplicated, less one
AnotherDuplicate:

        inc     ecx                                     ; one scan further down
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      OutputDuplicates                        ; no more scans
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     add     esi,[esp].sp_SrcIntStep                 ; step int part
        add     edi,[ebp].str_lDeltaDst                 ; step entire dest scan
        cmp     esi,ebx                                 ; is src scan same as before?
        je      AnotherDuplicate

OutputDuplicates:

        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan address
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        ;
        ; Now output the command to do the 'rolling blt'
        ;

        ;; mov     edx,[esp].sp_pjBase

        ;
        ; Wait until the accelerator is done with current blt
        ;

        mov     dx,3ceh     ;index register
        mov     al,31h      ;status reg
        out     dx,al
        mov     dx,3cfh     ;data register
@@:     in      al,dx
        test    al,1
        jnz     short @b

        mov     ebx,[esp].sp_XCntHW
        mov     eax,[esp].sp_yDst

        ; eax = yDst      -- Destination scan line (source scan line is yDst - 1)
        ; ebx = XCntHW    -- Number of bytes across (width) - 1
        ; ecx = cy        -- Number of times scan is to be duplicated - 1
        ; edx = pjBase    -- Pointer to memory mapped accelerator registers
        ; ebp = pSTR_BLT  -- Stretch blt info

DuplicateViaMmIo:

        ;
        ; Do the copy:
        ;

if 0
        CP_XCNT(ppdev, pjBase, (WidthXBytes - 1));
        CP_YCNT(ppdev, pjBase, (cyDuplicate - 1));
        CP_SRC_ADDR(ppdev, pjBase, (xyOffset + ((yDst - 1) * lDelta) + xDstBytes));
        SET_DEST_ADDR(ppdev, ((yDst * lDelta) + xDstBytes));
        START_ACL(ppdev);
endif

        .errnz  RECT_HEIGHT

        ;; mov     [edx+OFFSET_wXCnt],bx
        ;; mov     [edx+OFFSET_wYCnt],cx

        mov     dx,3ceh     ;index register

        ;
        ; set XCNT=bx and YCNT=cx
        ;

		push	eax

        mov     al,21h      ;BLT_WIDTH_HIGH
        mov     ah,bh       ;x count high byte
        out     dx,ax
        mov     al,20h      ;BLT_WIDTH_LOW
        mov     ah,bl       ;x count low byte
        out     dx,ax

        mov     al,23h      ;BLT_HEIGHT_HIGH
        mov     ah,ch       ;y count high byte
        out     dx,ax
        mov     al,22h      ;BLT_HEIGHT_LOW
        mov     ah,cl       ;y count low byte
        out     dx,ax

		pop		eax

        ;
        ; Calculate src address
        ;

        mov     ebx,eax                                 ; ebx <- yDst
        dec     ebx
        imul    ebx,[ebp].str_lDeltaDst
        add     ebx,[esp].sp_xyOffset
        add     ebx,[ebp].str_xDstStart
        add     ebx,[ebp].str_xDstStart

        ;; mov     [edx+OFFSET_ulSrcAddr],ebx

		push	eax

        mov     al,2ch      ;SRC_ADDR_LOW
        mov     ah,bl       ;src addr low byte
        out     dx,ax
        mov     al,2dh      ;SRC_ADDR_MID
        mov     ah,bh       ;src addr mid byte
        out     dx,ax

        shr     ebx,16

        mov     al,2eh      ;SRC_ADDR_HIGH
        mov     ah,bl       ;src addr high byte
        out     dx,ax

		pop		eax

        ;
        ; Calculate dst address
        ;

        inc     eax                                     ; account for 'ecx' being
                                                        ;  one less than scan count

        mov     ebx,eax                                 ; ebx <- yDst
        dec     ebx
        imul    ebx,[ebp].str_lDeltaDst
        add     ebx,[esp].sp_xyOffset
        add     ebx,[ebp].str_xDstStart
        add     ebx,[ebp].str_xDstStart

        ;; mov     [edx+OFFSET_ulDstAddr],ebx

        push	eax

        mov     al,28h      ;DST_ADDR_LOW
        mov     ah,bl       ;dst addr low byte
        out     dx,ax
        mov     al,29h      ;DST_ADDR_MID
        mov     ah,bh       ;dst addr mid byte
        out     dx,ax

        shr     ebx,16

        mov     al,2ah      ;DST_ADDR_HIGH
        mov     ah,bl       ;dst addr high byte
        out     dx,ax

        ;
        ; Start blt
        ;

        mov     al,31h      ;BLT_START_STATUS_REG
        mov     ah,2        ;BLT_START
        out     dx,ax

		pop		eax

DoneSetDestAddr:

        add     eax,ecx                                 ; add num scans just done
        mov     [esp].sp_yDst,eax

DoneDuplicate:

        cmp     [ebp].str_YDstCount,0                   ; we might be all done
        jne     NextScan

Done:

        add     esp,(size STACK_STRUC) - PROC_MEM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     4

vDirectStretch16@4 endp

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\textout.c ===
/******************************************************************************\
*
* $Workfile:   textout.c  $
*
* On every TextOut, GDI provides an array of 'GLYPHPOS' structures for every
* glyph to be drawn. Each GLYPHPOS structure contains a glyph handle and a
* pointer to a monochrome bitmap that describes the glyph. (Note that unlike
* Windows 3.1, which provides a column-major glyph bitmap, Windows NT always
* provides a row-major glyph bitmap.) As such, there are three basic methods
* for drawing text with hardware acceleration:
*
* 1) Glyph caching -- Glyph bitmaps are cached by the accelerator (probably in
*        off-screen memory), and text is drawn by referring the hardware to the
*        cached glyph locations.
*
* 2) Glyph expansion -- Each individual glyph is color-expanded directly to the
*        screen from the monochrome glyph bitmap supplied by GDI.
*
* 3) Buffer expansion -- The CPU is used to draw all the glyphs into a 1bpp
*         monochrome bitmap, and the hardware is then used to color-expand the
*        result.
*
* The fastest method depends on a number of variables, such as the color
* expansion speed, bus speed, CPU speed, average glyph size, and average string
* length.
*
* Glyph expansion is typically faster than buffer expansion for very large
* glyphs, even on the ISA bus, because less copying by the CPU needs to be
* done. Unfortunately, large glyphs are pretty rare.
*
* An advantange of the buffer expansion method is that opaque text will never
* flash -- the other two methods typically need to draw the opaquing rectangle
* before laying down the glyphs, which may cause a flash if the raster is
* caught at the wrong time.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
********************************************************************************
*
* On the CL-GD5436/46 chips we use glyph caching which is a major performance
* gain.
*
* Copyright (c) 1996 Cirrus Logic, Inc.
*
* $Log:   S:/projects/drivers/ntsrc/display/textout.c_v  $
 * 
 *    Rev 1.5   Jan 15 1997 09:43:28   unknown
 * Enable font cache for english.
 * 
 *    Rev 1.4   Jan 14 1997 15:16:58   unknown
 * take out GR33 clearing after 80 blt.
 * 
 *    Rev 1.2   Nov 07 1996 16:48:08   unknown
 *  
 * 
 *    Rev 1.1   Oct 10 1996 15:39:28   unknown
 *  
* 
*    Rev 1.9   12 Aug 1996 17:12:50   frido
* Changed some comments.
* 
*    Rev 1.8   12 Aug 1996 16:55:08   frido
* Removed unaccessed local variables.
* 
*    Rev 1.7   02 Aug 1996 14:50:42   frido
* Fixed reported GPF during mode switching.
* Used another way to bypass the hardware bug.
* 
*    Rev 1.6   31 Jul 1996 17:56:08   frido
* Fixed clipping.
* 
*    Rev 1.5   26 Jul 1996 12:56:48   frido
* Removed clipping for now.
* 
*    Rev 1.4   24 Jul 1996 20:19:26   frido
* Added a chain of FONTCACHE structures.
* Fixed bugs in vDrawGlyph and vClipGlyph.
* Changed vAssertModeText to remove all cached fonts.
* 
*    Rev 1.3   23 Jul 1996 17:41:52   frido
* Fixed a compile problem after commenting.
* 
*    Rev 1.2   23 Jul 1996 08:53:00   frido
* Documentation done.
* 
*    Rev 1.1   22 Jul 1996 20:45:38   frido
* Added font cache.
*
* jl01  10-08-96  Do Transparent BLT w/o Solid Fill.  Refer to PDRs#5511/6817.
\******************************************************************************/

#include "precomp.h"

// Handy macros.
#define BUSY_BLT(ppdev, pjBase)    (CP_MM_ACL_STAT(ppdev, pjBase) & 0x10)

#define FIFTEEN_BITS            ((1 << 15) - 1)

/******************************Public*Routine******************************\
* VOID vClipSolid
*
* Fills the specified rectangles with the specified color, honoring
* the requested clipping.  No more than four rectangles should be passed in.
*
* Intended for drawing the areas of the opaquing rectangle that extend
* beyond the text box.  The rectangles must be in left to right, top to
* bottom order.  Assumes there is at least one rectangle in the list.
*
* Also used as a simple way to do a rectangular solid fill while honoring
* clipping (as in extra rectangles).
*
\**************************************************************************/

VOID vClipSolid(
PDEV*       ppdev,
LONG        crcl,
RECTL*      prcl,
ULONG       iColor,
CLIPOBJ*    pco)
{
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBRUSH_COLOR    rbc;

    ASSERTDD((crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");

    rbc.iSolidColor = iColor;
    if ((!pco) || (pco->iDComplexity == DC_TRIVIAL))
    {
        (ppdev->pfnFillSolid)(ppdev, 1, prcl, R4_PATCOPY, rbc, NULL);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        if (crcl != 0)
        {
            (ppdev->pfnFillSolid)(ppdev, crcl, prcl, R4_PATCOPY,
                                  rbc, NULL);
        }
    }
    else // iDComplexity == DC_COMPLEX
    {
        // Bottom of last rectangle to fill

        iLastBottom = prcl[crcl - 1].bottom;

        // Initialize the clip rectangle enumeration to right-down so we can
        // take advantage of the rectangle list being right-down:

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        // Scan through all the clip rectangles, looking for intersects
        // of fill areas with region rectangles:

        do {
            // Get a batch of region rectangles:

            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

            // Clip the rect list to each region rect:

            for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
                // Since the rectangles and the region enumeration are both
                // right-down, we can zip through the region until we reach
                // the first fill rect, and are done when we've passed the
                // last fill rect.

                if (prclClip->top >= iLastBottom)
                {
                    // Past last fill rectangle; nothing left to do:

                    return;
                }

                // Do intersection tests only if we've reached the top of
                // the first rectangle to fill:

                if (prclClip->bottom > prcl->top)
                {
                    // We've reached the top Y scan of the first rect, so
                    // it's worth bothering checking for intersection.

                    // Generate a list of the rects clipped to this region
                    // rect:

                    prclTmp     = prcl;
                    prclClipTmp = arclTmp;

                    for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                    {
                        // Intersect fill and clip rectangles

                        if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                            // Add to list if anything's left to draw:

                            crclTmp++;
                            prclClipTmp++;
                        }
                    }

                    // Draw the clipped rects

                    if (crclTmp != 0)
                    {
                        (ppdev->pfnFillSolid)(ppdev, crclTmp, &arclTmp[0],
                                             R4_PATCOPY, rbc, NULL);
                    }
                }
            }
        } while (bMore);
    }
}

#if 0 //removed
BOOL bVerifyStrObj(STROBJ* pstro)
{
    BOOL bMoreGlyphs;
    LONG cGlyph;
    GLYPHPOS * pgp;
    LONG iGlyph = 0;
    RECTL * prclDraw;
    GLYPHPOS * pgpTmp;
    POINTL ptlPlace;

    do
    {
        // Get the next batch of glyphs:

        if (pstro->pgp != NULL)
        {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        prclDraw = &pstro->rclBkGround;
        pgpTmp = pgp;

        ptlPlace = pgpTmp->ptl;

        while (cGlyph)
        {
            if (((ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x + pgpTmp->pgdf->pgb->sizlBitmap.cx) > (prclDraw->right)) ||
                ((ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x) < (prclDraw->left)) ||
                ((ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y + pgpTmp->pgdf->pgb->sizlBitmap.cy) > (prclDraw->bottom)) ||
                ((ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y) < (prclDraw->top))
               )
            {
                DISPDBG((0,"------------------------------------------------------------"));
                DISPDBG((0,"Glyph %d extends beyond pstro->rclBkGround", iGlyph));
                DISPDBG((0,"\tpstro->rclBkGround (%d,%d,%d,%d)",
                            pstro->rclBkGround.left,
                            pstro->rclBkGround.top,
                            pstro->rclBkGround.right,
                            pstro->rclBkGround.bottom));
                DISPDBG((0,"\teffective glyph rect (%d,%d,%d,%d)",
                            (ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x),
                            (ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y),
                            (ptlPlace.x + pgpTmp->pgdf->pgb->ptlOrigin.x + pgpTmp->pgdf->pgb->sizlBitmap.cx),
                            (ptlPlace.y + pgpTmp->pgdf->pgb->ptlOrigin.y + pgpTmp->pgdf->pgb->sizlBitmap.cy)));
                DISPDBG((0,"\tglyph pos (%d,%d)",ptlPlace.x,ptlPlace.y));
                DISPDBG((0,"\tglyph origin (%d,%d)",
                            pgpTmp->pgdf->pgb->ptlOrigin.x,
                            pgpTmp->pgdf->pgb->ptlOrigin.y));
                DISPDBG((0,"\tglyph sizl (%d,%d)",
                            pgpTmp->pgdf->pgb->sizlBitmap.cx,
                            pgpTmp->pgdf->pgb->sizlBitmap.cy));
                DISPDBG((0,"------------------------------------------------------------"));
                RIP("time to call the font guys...");
                return(FALSE);
            }

            cGlyph--;
            iGlyph++;
            pgpTmp++;

            if (pstro->ulCharInc == 0)
            {
                ptlPlace = pgpTmp->ptl;
            }
            else
            {
                ptlPlace.x += pstro->ulCharInc;
            }
        }
    } while (bMoreGlyphs);

    return(TRUE);
}

VOID vIoTextOutUnclipped(
PPDEV     ppdev,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)
{
    BYTE*       pjPorts         = ppdev->pjPorts;
    LONG        lDelta          = ppdev->lDelta;
    LONG        cBpp            = ppdev->cBpp;

    ULONG      *pulXfer;
    ULONG       ulDstAddr;

    ULONG       ulFgColor;
    ULONG       ulBgColor;
    ULONG       ulSolidColor;

    BYTE        jMode = 0;
    BYTE        jModeColor = 0;

    BOOL        bTextPerfectFit;
    ULONG       cGlyph;
    BOOL        bMoreGlyphs;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    LONG        cxGlyph;
    LONG        cyGlyph;
    ULONG*      pdSrc;
    ULONG*      pdDst;
    LONG        cj;
    LONG        cd;
    POINTL      ptlOrigin;
    LONG        ulCharInc;

    ulFgColor       = pboFore->iSolidColor;

    if (pboOpaque)
    {
        ulBgColor       = pboOpaque->iSolidColor;
    }

    if (cBpp == 1)
    {
        ulFgColor |= ulFgColor << 8;
        ulFgColor |= ulFgColor << 16;
        ulBgColor |= ulBgColor << 8;
        ulBgColor |= ulBgColor << 16;
    }
    else if (cBpp == 2)
    {
        ulFgColor |= ulFgColor << 16;
        ulBgColor |= ulBgColor << 16;
    }

    pulXfer = ppdev->pulXfer;
    ppdev->pfnBankMap(ppdev, ppdev->lXferBank);

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);
    CP_IO_DST_Y_OFFSET(ppdev, pjPorts, lDelta);

    if (prclOpaque != NULL)
    {
      ////////////////////////////////////////////////////////////
      // Opaque Initialization
      ////////////////////////////////////////////////////////////

      // If we paint the glyphs in 'opaque' mode, we may not actually
      // have to draw the opaquing rectangle up-front -- the process
      // of laying down all the glyphs will automatically cover all
      // of the pixels in the opaquing rectangle.
      //
      // The condition that must be satisfied is that the text must
      // fit 'perfectly' such that the entire background rectangle is
      // covered, and none of the glyphs overlap (if the glyphs
      // overlap, such as for italics, they have to be drawn in
      // transparent mode after the opaquing rectangle is cleared).

      bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
              SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
              SO_CHAR_INC_EQUAL_BM_BASE)) ==
              (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
              SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

      if (!(bTextPerfectFit)                               ||
          (pstro->rclBkGround.top    > prclOpaque->top)    ||
          (pstro->rclBkGround.left   > prclOpaque->left)   ||
          (pstro->rclBkGround.right  < prclOpaque->right)  ||
          (pstro->rclBkGround.bottom < prclOpaque->bottom))
      {
        vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
      }

      if (bTextPerfectFit)
      {
        // If we have already drawn the opaquing rectangle (because
        // is was larger than the text rectangle), we could lay down
        // the glyphs in 'transparent' mode.  But I've found the QVision
        // to be a bit faster drawing in opaque mode, so we'll stick
        // with that:

        jMode = jModeColor |
                ENABLE_COLOR_EXPAND |
                SRC_CPU_DATA;

        CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

        CP_IO_FG_COLOR(ppdev, pjPorts, ulFgColor);
        CP_IO_BG_COLOR(ppdev, pjPorts, ulBgColor);
        CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
        CP_IO_BLT_MODE(ppdev, pjPorts, jMode);

        goto SkipTransparentInitialization;
      }
    }

    ////////////////////////////////////////////////////////////
    // Transparent Initialization
    ////////////////////////////////////////////////////////////

    // Initialize the hardware for transparent text:

    jMode = jModeColor |
            ENABLE_COLOR_EXPAND |
            ENABLE_TRANSPARENCY_COMPARE |
            SRC_CPU_DATA;

    CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

    CP_IO_FG_COLOR(ppdev, pjPorts, ulFgColor);
    CP_IO_BG_COLOR(ppdev, pjPorts, ~ulFgColor);
    CP_IO_XPAR_COLOR(ppdev, pjPorts, ~ulFgColor);
    CP_IO_ROP(ppdev, pjPorts, CL_SRC_COPY);
    CP_IO_BLT_MODE(ppdev, pjPorts, jMode);
    CP_IO_BLT_EXT_MODE(ppdev, pjPorts, 0);                // jl01


  SkipTransparentInitialization:

    do {
        if (pstro->pgp != NULL)
        {
          // There's only the one batch of glyphs, so save ourselves
          // a call:

          pgp         = pstro->pgp;
          cGlyph      = pstro->cGlyphs;
          bMoreGlyphs = FALSE;
        }
        else
        {
          bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        if (cGlyph > 0)
        {
          if (pstro->ulCharInc == 0)
          {
            ////////////////////////////////////////////////////////////
            // Proportional Spacing

            pdDst = pulXfer;

            CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

            do {
              pgb = pgp->pgdf->pgb;

              ulDstAddr = ((pgp->ptl.y + pgb->ptlOrigin.y) * lDelta) +
                          PELS_TO_BYTES(pgp->ptl.x + pgb->ptlOrigin.x);

              cxGlyph = pgb->sizlBitmap.cx;
              cyGlyph = pgb->sizlBitmap.cy;

              CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

              CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(cxGlyph) - 1));
              CP_IO_YCNT(ppdev, pjPorts, cyGlyph - 1);

              //
              // The 542x chips require a write to the Src Address Register when
              // doing a host transfer with color expansion.  The value is
              // irrelevant, but the write is crucial.  This is documented in
              // the manual, not the errata.  Go figure.
              //

              CP_IO_SRC_ADDR(ppdev, pjPorts, 0);
              CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

              CP_IO_START_BLT(ppdev, pjPorts);

              pdSrc = (ULONG*) pgb->aj;

              cj = cyGlyph * ((cxGlyph + 7) >> 3);

              cd = (cj + 3) >> 2;

              {
                do {
                  WRITE_REGISTER_ULONG(pdDst, *pdSrc);
                  // *pdDst = *pdSrc;
                  CP_MEMORY_BARRIER();
                  pdSrc++;
                } while (--cd != 0);
              }
            } while (pgp++, --cGlyph != 0);
          }
          else
          {
            ////////////////////////////////////////////////////////////
            // Mono Spacing

            ulCharInc   = pstro->ulCharInc;
            pgb         = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            pdDst       = pulXfer;

            do {
              pgb = pgp->pgdf->pgb;

              ulDstAddr = (ptlOrigin.y * lDelta) +
                          PELS_TO_BYTES(ptlOrigin.x);

              cxGlyph = pgb->sizlBitmap.cx;
              cyGlyph = pgb->sizlBitmap.cy;

              CP_IO_WAIT_FOR_BLT_COMPLETE(ppdev, pjPorts);

              CP_IO_XCNT(ppdev, pjPorts, (PELS_TO_BYTES(cxGlyph) - 1));
              CP_IO_YCNT(ppdev, pjPorts, cyGlyph - 1);

              //
              // The 542x chips require a write to the Src Address Register when
              // doing a host transfer with color expansion.  The value is
              // irrelevant, but the write is crucial.  This is documented in
              // the manual, not the errata.  Go figure.
              //

              CP_IO_SRC_ADDR(ppdev, pjPorts, 0);
              CP_IO_DST_ADDR(ppdev, pjPorts, ulDstAddr);

              ptlOrigin.x += ulCharInc;

              CP_IO_START_BLT(ppdev, pjPorts);

              pdSrc = (ULONG*) pgb->aj;

              cj = cyGlyph * ((cxGlyph + 7) >> 3);

              cd = (cj + 3) >> 2;

              {
                do {
                  WRITE_REGISTER_ULONG(pdDst, *pdSrc);
                  // *pdDst = *pdSrc;
                  MEMORY_BARRIER();
                  pdSrc++;
                } while (--cd != 0);
              }
            } while (pgp++, --cGlyph != 0);
          }
        }
    } while (bMoreGlyphs);

}
#endif

/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
* If it's the fastest method, outputs text using the 'glyph expansion'
* method.  Each individual glyph is color-expanded directly to the
* screen from the monochrome glyph bitmap supplied by GDI.
*
* If it's not the fastest method, calls the routine that implements the
* 'buffer expansion' method.
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,
MIX       mix)
{
    PDEV*           ppdev;
    DSURF*          pdsurf;
    OH*             poh;
    BOOL            bTextPerfectFit;
    LONG            lDelta;

    BOOL            bTmpAlloc;
    VOID*           pvTmp;
    SURFOBJ*        psoTmpMono;
    BOOL            bOpaque;
    BRUSHOBJ        boFore;
    BRUSHOBJ        boOpaque;
    BOOL            bRet;
    XLATECOLORS     xlc;                // Temporary for keeping colours
    XLATEOBJ        xlo;                // Temporary for passing colours

    ULONG           ulBufferBytes;
    ULONG           ulBufferHeight;

    // The DDI spec says we'll only ever get foreground and background
    // mixes of R2_COPYPEN:

    ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;

    if (pdsurf->dt != DT_DIB)
    {
        // We'll be drawing to the screen or an off-screen DFB; copy the
        // surface's offset now so that we won't need to refer to the DSURF
        // again:

        poh   = pdsurf->poh;
        ppdev = (PDEV*) pso->dhpdev;

        ppdev->xOffset  = poh->x;
        ppdev->yOffset  = poh->y;
        ppdev->xyOffset = poh->xy;

        if (HOST_XFERS_DISABLED(ppdev) && DIRECT_ACCESS(ppdev))
        {
            //
            // if HOST_XFERS_DISABLED(ppdev) is TRUE then the BitBlt used by
            // our text code will be VERY slow.  We should just let the engine
            // draw the text if it can.
            //

            if (ppdev->bLinearMode)
            {
                SURFOBJ *psoPunt = ppdev->psoPunt;

                psoPunt->pvScan0 = poh->pvScan0;
                ppdev->pfnBankSelectMode(ppdev, BANK_ON);

                return(EngTextOut(psoPunt, pstro, pfo, pco, prclExtra,
                                  prclOpaque, pboFore, pboOpaque,
                                  pptlBrush, mix));
            }
            else
            {
                BANK    bnk;
                BOOL    b;
                RECTL   rclDraw;
                RECTL  *prclDst = &pco->rclBounds;

                // The bank manager requires that the 'draw' rectangle be
                // well-ordered:

                rclDraw = *prclDst;
                if (rclDraw.left > rclDraw.right)
                {
                    rclDraw.left   = prclDst->right;
                    rclDraw.right  = prclDst->left;
                }
                if (rclDraw.top > rclDraw.bottom)
                {
                    rclDraw.top    = prclDst->bottom;
                    rclDraw.bottom = prclDst->top;
                }

                vBankStart(ppdev, &rclDraw, pco, &bnk);

                b = TRUE;
                do {
                    b &= EngTextOut(bnk.pso,
                                    pstro,
                                    pfo,
                                    bnk.pco,
                                    prclExtra,
                                    prclOpaque,
                                    pboFore,
                                    pboOpaque,
                                    pptlBrush,
                                    mix);
                } while (bBankEnum(&bnk));

                return(b);
            }
        }

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // I'm not entirely sure why, but GDI will occasionally send
            // us TextOut's where the opaquing rectangle does not intersect
            // with the clip object bounds -- meaning that the text out
            // should have already been trivially rejected.  We will do so
            // here because the blt code usually assumes that all trivial
            // rejections will have already been performed, and we will be
            // passing this call on to the blt code:

            if ((pco->rclBounds.top    >= pstro->rclBkGround.bottom) ||
                (pco->rclBounds.left   >= pstro->rclBkGround.right)  ||
                (pco->rclBounds.right  <= pstro->rclBkGround.left)   ||
                (pco->rclBounds.bottom <= pstro->rclBkGround.top))
            {
                // The entire operation was trivially rejected:

                if (prclOpaque)
                {
                    vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
                }
                return(TRUE);
            }
        }

        // Font cache.
        if ((ppdev->flStatus & STAT_FONT_CACHE) &&
            bFontCache(ppdev, pstro, pfo, pco, prclOpaque, pboFore, pboOpaque))
        {
            return(TRUE);
        }

        // See if the temporary buffer is big enough for the text; if
        // not, try to allocate enough memory.  We round up to the
        // nearest dword multiple:

        lDelta = ((((pstro->rclBkGround.right + 31) & ~31) -
                    (pstro->rclBkGround.left & ~31)) >> 3);

        ulBufferHeight = pstro->rclBkGround.bottom - pstro->rclBkGround.top;
        ulBufferBytes  = lDelta * ulBufferHeight;

        if (((ULONG) lDelta > FIFTEEN_BITS) ||
            (ulBufferHeight > FIFTEEN_BITS))
        {
            // Fail if the math will have overflowed:

            return(FALSE);
        }

        // Use our temporary buffer if it's big enough, otherwise
        // allocate a buffer on the fly:

        if (ulBufferBytes >= TMP_BUFFER_SIZE)
        {
            // The textout is so big that I doubt this allocation will
            // cost a significant amount in performance:

            bTmpAlloc = TRUE;
            pvTmp     = ALLOC(ulBufferBytes);
            if (pvTmp == NULL)
                return(FALSE);
        }
        else
        {
            bTmpAlloc = FALSE;
            pvTmp     = ppdev->pvTmpBuffer;
        }

        psoTmpMono = ppdev->psoTmpMono;

        // Adjust 'lDelta' and 'pvScan0' of our temporary 1bpp surface object
        // so that when GDI starts drawing the text, it will begin in the
        // first dword

        psoTmpMono->pvScan0 = (BYTE*) pvTmp - (pstro->rclBkGround.top * lDelta)
                            - ((pstro->rclBkGround.left & ~31) >> 3);
        psoTmpMono->lDelta  = lDelta;

        ASSERTDD(((ULONG_PTR) psoTmpMono->pvScan0 & 3) == 0,
                 "pvScan0 must be dword aligned");
        ASSERTDD((lDelta & 3) == 0, "lDelta must be dword aligned");

        // We always want GDI to draw in opaque mode to temporary 1bpp
        // buffer:
        // We only want GDI to opaque within the rclBkGround.
        // We'll handle the rest ourselves.

        bOpaque = (prclOpaque != NULL);

        // Get GDI to draw the text for us:

        boFore.iSolidColor   = 1;
        boOpaque.iSolidColor = 0;

        bRet = EngTextOut(psoTmpMono,
                          pstro,
                          pfo,
                          pco,
                          prclExtra,
                          &pstro->rclBkGround,  //prclOpaque,
                          &boFore,
                          &boOpaque,
                          pptlBrush,
                          mix);

        if (bRet)
        {
            if (bOpaque)
            {
                bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
                      SO_CHAR_INC_EQUAL_BM_BASE)) ==
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

                if (!(bTextPerfectFit)                               ||
                    (pstro->rclBkGround.top    > prclOpaque->top)    ||
                    (pstro->rclBkGround.left   > prclOpaque->left)   ||
                    (pstro->rclBkGround.right  < prclOpaque->right)  ||
                    (pstro->rclBkGround.bottom < prclOpaque->bottom))
                {
                    //
                    // Drawing the Opaque test will not completely cover the
                    // opaque rectangle, so we must do it.  Go to transparent
                    // blt so we don't do the work twice (since opaque text is
                    // done in two passes).
                    //

                    vClipSolid(ppdev, 1, prclOpaque, pboOpaque->iSolidColor, pco);
                    goto Transparent_Text;
                }

                xlc.iForeColor = pboFore->iSolidColor;
                xlc.iBackColor = pboOpaque->iSolidColor;
                xlo.pulXlate   = (ULONG*) &xlc;

                bRet = DrvBitBlt(pso,
                                 psoTmpMono,
                                 NULL,
                                 pco,
                                 &xlo,
                                 &pstro->rclBkGround,
                                 (POINTL*)&pstro->rclBkGround,
                                 NULL,
                                 NULL, //&boFore
                                 NULL,
                                 R4_SRCCOPY);
            }
            else
            {
Transparent_Text:
                // Foreground colour must be 0xff for 8bpp and 0xffff for 16bpp:

                xlc.iForeColor = (ULONG)((1<<PELS_TO_BYTES(8)) - 1);
                xlc.iBackColor = 0;
                xlo.pulXlate   = (ULONG*) &xlc;

                boFore.iSolidColor = pboFore->iSolidColor;

                //
                // Transparently blt the text bitmap
                //

                bRet = DrvBitBlt(pso,
                                 psoTmpMono,
                                 NULL,
                                 pco,
                                 &xlo,
                                 &pstro->rclBkGround,
                                 (POINTL*)&pstro->rclBkGround,
                                 NULL,
                                 &boFore,
                                 NULL,
                                 0xe2e2);
            }
        }

        // Free up any memory we allocated for the temp buffer:

        if (bTmpAlloc)
        {
            FREE(pvTmp);
        }

        return(bRet);
    }
    else
    {
        // We're drawing to a DFB we've converted to a DIB, so just call GDI
        // to handle it:

        return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                          pboFore, pboOpaque, pptlBrush, mix));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
    // Here we free any stuff allocated in 'bEnableText'.
}

////////////////////////////////////////////////////////////////////////////////
//                                                                              //
//                         F O N T   C A C H E   S T U F F                      //
//                                                                              //
////////////////////////////////////////////////////////////////////////////////

/*
    The font cache has quite an impact on the speed. First a little note on the
    necessaty of an off-screen font cache (it is an off-screen font cache). The
    original code calls the GDI to perform the character drawing on a temporary
    monochrome surface and then blits that surface to the screen. The problem
    is that GDI is realy too slow. So we need some sort of acceleration here.
    The best acceleration possible is to cache all glyphs off-screen so we can
    let the bitblt engine do its work while we calculate the stuff required for
    the next glyph to draw. Call it co-operate cacheing if you like.    

    Okay, so now we know why we need a font cache, how do we do it? Calling
    the heap manager for every glyph we are going to cache is quite disasterous
    since the off-screen heap gets fragmented with a lot (and I mean a lot) of
    small chunks of data. We can do it better. We will implement our own very
    sneaky (simple and fast) memory manager. We just call the off-screen heap
    manager to allocate a big chunk (4Kb or so) rectengular memory and perform
    our own allocation in that chunk.

    We will use a simple linear allocation technique. Whenever we are required
    to allocate a number of bytes we will test if we have enough room in the
    last line accessed in the chunk. If we have, we decrease the size left on
    that line and return a pointer to it. If we don't have enough memory in the
    last line we simply move to the next line which will be free. If there is
    not enough memory there either, the requested glyph is too big and so we
    return NULL. The only problem here is when we run out of lines in the
    chunk. In this case we link in another chunk we allocate in off-screen
    memory and mark the current chunk 'full'. Okay, this may not be the best
    memory manager since it might leave lines in the chunk very empty if a
    large glyph needs to be allocated. But it is small and fast. And that's our
    main goal.

    We could copy the entire glyph into off-screen memory, but this would use
    up valueable memory since most glyphs will have a lot of white space in
    them. So we calculate the actual visible part of the glyph and only copy
    that data to the off-screen memory. This requires some extra overhead when
    a glyph is being cached, but that will happen only once. And we can detect
    empty glyphs (like the space) to speed up drawing in the process. This does
    however add the necessaty of first drawing an opaque rectangle if required.
    This does not matter that much, since the bitblt engine will draw it while
    we setup some loop variables.

    Okay, now we know about the memory manager. But how do we attach this glyph
    cache to a font? And how do we free its recourses? Windows NT has this nice
    feature called OEM extension. In the FONT object there is a field
    (vConsumer) which is for the display driver only. We can use this field to
    hook up a pointer to our FONTCACHE structure. And when the font is no
    longer required, Windows NT calls DrvDestroyFont so we can remove any
    resources attached to the font. There is only one glitch to this scheme.
    Windows NT does not free up the fonts when the screen goes to full-screen
    DOS mode. This does not matter but when the screen is reset to graphics
    mode all off-screen fonts are smashed and invalid. So I have added a
    counter that gets incremented when the screen is reset to graphics mode.
    When this counter does not match the copy in the FONTCACHE structure we
    must destroy the font first before caching it again.

    There might be some TrueType fonts out there that have many glyphs in them
    (the Unicode fonts for example). This would cause an extremely large font
    cache indeed. So we set a maximum (defaults to 256) of glyphs to cache.
    Whenever we are asked to draw a glyph outside the range we do it by
    bypassing the font cache for that particular glyph.

    Some glyphs might be too large to cache even though the font is small
    enough to be validated for cacheing. In this case we mark the specific
    glyph as uncacheable and draw it directly to screen, bypassing the font
    cache. Other glyphs might have no visble pixels at all (spaces) and we mark
    them as empty so they never get drawn.

    This covers most of the basics for the font cache. See the comments in the
    source for more details.

    EXTRA: Today (24-Jul-96) I have added a chain of FONTCACHE structures that
    keeps track of which FONTOBJs are loaded and cached. This chain will we
    walked to throw all cached fonts out of memory when a mode change to full-
    screen occurs or when DirectDraw is being initialized to give more memory
    to DirectDraw.
*/

/******************************************************************************\
*
* Function:     bEnableText
*
* This routine is called from DrvEnableSurface and should perform any actions
* required to set up the font cache.
*
* Parameters:   ppdev        Pointer to physical device.
*
* Returns:      TRUE.
*
\******************************************************************************/
BOOL bEnableText(
PDEV* ppdev)
{
    // The font cache is only available on the CL-GD5436 like chips, direct
    // access to the frame buffer is enabled and we can do host transfers.
    if ((ppdev->flCaps & CAPS_AUTOSTART) &&
        DIRECT_ACCESS(ppdev)           &&
        !(ppdev->flCaps & CAPS_NO_HOST_XFER))
    {
        // Don't enable the font cache in low memory situations.
        LONG cWidth = BYTES_TO_PELS(FONT_ALLOC_X);
        if ((cWidth <= ppdev->heap.cxMax) &&
            (FONT_ALLOC_Y <= ppdev->heap.cyMax) && FALSE)
        {
            // The font cache will be used.
            ppdev->flStatus |= STAT_FONT_CACHE;
            ppdev->pfcChain  = NULL;
        }
    }
    return(TRUE);
}

/******************************************************************************\
*
* Function:     vAssertModeText
*
* This routine is called from DrvAssertMode. When we switch to full screen we
* destroy all cached fonts.
*
* Parameters:   ppdev        Pointer to physical device.
*                bEnable        TRUE if switching to graphics mode, FALSE if
*                            switching to full-screen MS-DOS mode.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vAssertModeText(
PDEV* ppdev,
BOOL  bEnable)
{
    if (bEnable)
    {
        ppdev->ulFontCacheID++;
    }
    else
    {
        // Destroy all fonts in the chain.
        while (ppdev->pfcChain != NULL)
        {
            DrvDestroyFont(ppdev->pfcChain->pfo);
        }
    }
}

/******************************************************************************\
*
* Function:     DrvDestroyFont
*
* This functin is called by NT when a font is being removed from memory. We
* must free any resources we have attached to this font.
*
* Parameters:   pfo        Pointer to the font object being destroyed.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID DrvDestroyFont(
FONTOBJ *pfo)
{
    // Do we have any recourses allocated?
    if ((pfo->pvConsumer != NULL) && (pfo->pvConsumer != (VOID*) -1))
    {
        FONTCACHE*  pfc = pfo->pvConsumer;
        FONTMEMORY* pfm;
        PDEV*        ppdev;

        ppdev = pfc->ppdev;

        // Free all allocated memory blocks.
        pfm = pfc->pfm;
        while (pfm != NULL)
        {
            FONTMEMORY* pfmNext = pfm->pfmNext;

            if (pfm->poh != NULL)
            {
                pohFree(ppdev, pfm->poh);
            }

            FREE(pfm);
            pfm = pfmNext;
        }

        // Unhook the font cache from the chain.
        if (pfc->pfcPrev != NULL)
        {
            pfc->pfcPrev->pfcNext = pfc->pfcNext;
        }
        else
        {
            ppdev->pfcChain = pfc->pfcNext;
        }
        if (pfc->pfcNext != NULL)
        {
            pfc->pfcNext->pfcPrev = pfc->pfcPrev;
        }

        // Free the font cache.
        FREE(pfc);
    }

    // We don't have anything allocated anymore!
    pfo->pvConsumer = NULL;
}

/******************************************************************************\
*
* Function:     cGetGlyphSize
*
* Get the width and height of a glyph. The height is its visble height, without
* leading and trailing blank lines.
*
* Parameters:   pgb            Pointer to the glyph.
*                pptlOrigin    Pointer to a POINTL which receives the origin of
*                            the glyph.
*                psizlPixels    Pointer to a SIZEL which receives the size of the
*                            glyph in pixels.
*
* Returns:      The width of the glyph in bytes or 0 if the glyph is empty.
*
\******************************************************************************/
LONG cGetGlyphSize(
GLYPHBITS* pgb,
POINTL*    pptlOrigin,
SIZEL*       psizlPixels)
{
    LONG  x, y;
    BYTE* pByte = pgb->aj;
    INT   i;

    // Get width in bytes.
    x = (pgb->sizlBitmap.cx + 7) >> 3;
    if (x > 0)
    {
        // Find the first line in glyph that conatins data.
        for (y = 0; y < pgb->sizlBitmap.cy; y++, pByte += x)
        {
            // Walk through every byte on a line.
            for (i = 0; i < x; i++)
            {
                // If we have data here, we have found the first line.
                if (pByte[i]) 
                {
                    // Find the last line in the glyph that contains data.
                    LONG lHeight = pgb->sizlBitmap.cy - y;
                    for (pByte += (lHeight - 1) * x; lHeight > 0; lHeight--)
                    {
                        // Walk through every byte on a line.
                        for (i = 0; i < x; i++)
                        {
                            if (pByte[i])
                            {
                                // Fill return parameters.
                                pptlOrigin->y   = y;
                                psizlPixels->cx = pgb->sizlBitmap.cx;
                                psizlPixels->cy = lHeight;
                                return(x);
                            }
                        }
                        pByte -= x;
                    }

                    // Glyph is empty.
                    return(0);
                }
            }
        }
    }

    // Glyph is empty.
    return(0);
}

/******************************************************************************\
*
* Function:     pjAllocateFontCache
*
* Allocate a number of bytes in the off-screen font cache.
*
* Parameters:   pfc        Pointer to the font cache.
*                cBytes    Number of bytes to allocate.
*
* Returns:      Linear address of allocation or NULL if there was an error
*                allocating memory.
*
\******************************************************************************/
BYTE* pjAllocateFontCache(
FONTCACHE* pfc,
LONG       cBytes)
{
    FONTMEMORY* pfm;
    BYTE*        pjLinear;
    PDEV*        ppdev = pfc->ppdev;

    // Allocate first FONTMEMORY structure if not yet done.
    if (pfc->pfm == NULL)
    {
        pfc->pfm = ALLOC(sizeof(FONTMEMORY));
        if (pfc->pfm == NULL)
        {
            return(NULL);
        }
    }

    // Walk through all FONTMEMORY structures to find enough space.
    for (pfm = pfc->pfm; pfm != NULL; pfm = pfm->pfmNext)
    {
        // Allocate the off-screen node if not yet done so.
        if (pfm->poh == NULL)
        {
            OH* poh = pohAllocate(ppdev, pfc->cWidth, pfc->cHeight,
                                  FLOH_ONLY_IF_ROOM);
            if (poh == NULL)
            {
                DISPDBG((4, "Not enough room for font cache"));
                return(NULL);
            }

            // Make off-screen node PERMANENT.
            poh->ofl = OFL_PERMANENT;
            vCalculateMaximum(ppdev);

            // Initialize memory manager.
            pfm->poh = poh;
            pfm->cx  = PELS_TO_BYTES(poh->cx);
            pfm->cy  = poh->cy;
            pfm->xy  = poh->xy;
        }

        // Test if the font is too big to fit in any memory block.
        if (cBytes > pfm->cx)
        {
            return(NULL);
        }

        // If the block is not yet full...
        if (pfm->cy > 0)
        {
            // If the glyph fots on the current line...
            if ((pfm->x + cBytes) <= pfm->cx)
            {
                pjLinear = (BYTE*)(ULONG_PTR)(pfm->xy + pfm->x);
                pfm->x  += cBytes;
                return(pjLinear);
            }

            // Next line.
            pfm->cy--;

            // If this memory block is not yet full...
            if (pfm->cy > 0)
            {
                pfm->xy += ppdev->lDelta;
                pfm->x   = cBytes;
                return((BYTE*)(ULONG_PTR)pfm->xy);
            }
        }

        // Allocate the next FONTMEMORY structure if not yet done.
        if (pfm->pfmNext == NULL)
        {
            pfm->pfmNext = ALLOC(sizeof(FONTMEMORY));
        }
    }

    return(NULL);
}

/******************************************************************************\
*
* Function:     vAllocateGlyph
*
* Cache a glyph to the off-screen font cache.
*
* Parameters:   pfc        Pointer to the font cache.
*                pgb        Pointer to the glyph structure.
*                pgc        Pointer to the glyph cache.
*
* Returns:      pgc->sizlBytes.cy.
*
\******************************************************************************/
LONG lAllocateGlyph(
FONTCACHE*  pfc,
GLYPHBITS*  pgb,
GLYPHCACHE* pgc)
{
    PDEV* ppdev = pfc->ppdev;
    LONG  lDelta;
    BYTE* pjSrc;
    BYTE* pjDst;
    LONG  c;

    // Get the size of the glyph.
    lDelta = cGetGlyphSize(pgb, &pgc->ptlOrigin, &pgc->sizlPixels);
    if (lDelta == 0)
    {
        // Glyph is empty.
        pgc->pjGlyph      = (BYTE*) -1;
        pgc->sizlBytes.cy = GLYPH_EMPTY;
        return(GLYPH_EMPTY);
    }

    // Allocate the glyph in the off-screen font cache.
    pgc->lDelta  = lDelta;
    c             = lDelta * pgc->sizlPixels.cy;
    pgc->pjGlyph = pjAllocateFontCache(pfc, c);
    if (pgc->pjGlyph == NULL)
    {
        // Glyph is uncacheable.
        pgc->pjGlyph      = (BYTE*) -1;
        pgc->sizlBytes.cy = GLYPH_UNCACHEABLE;
        return(GLYPH_UNCACHEABLE);
    }

    // Calculate the glyph and off-screen pointers.
    pjSrc = &pgb->aj[pgc->ptlOrigin.y * lDelta];
    pjDst = ppdev->pjScreen + (ULONG_PTR) pgc->pjGlyph;

    // First, align the source to a DWORD boundary.
    while (((ULONG_PTR)pjSrc & 3) && (c > 0))
    {
        *pjDst++ = *pjSrc++;
        c--;
    }

    // Copy the data in DWORDs.
    while (c >= 4)
    {
        *((UNALIGNED DWORD*) pjDst)++ = *((DWORD*) pjSrc)++;
        c -= 4;
    }

    // Copy the remaining data.
    while (c >= 0)
    {
        *pjDst++ = *pjSrc++;
        c--;
    }

    // Calculate the glyph origin and size.
    pgc->ptlOrigin.x  = pgb->ptlOrigin.x;
    pgc->ptlOrigin.y += pgb->ptlOrigin.y;
    pgc->sizlBytes.cx = PELS_TO_BYTES(pgc->sizlPixels.cx) - 1;
    pgc->sizlBytes.cy = pgc->sizlPixels.cy - 1;

    return(pgc->sizlBytes.cy);
}

/******************************************************************************\
*
* Function:     bFontCache
*
* This is the font cache routine which is called from DrvTextOut if the font
* cache is turned on.
*
* Parameters:   ppdev        Pointer to physical device.
*                pstro        Pointer to array of glyphs to draw.
*                pfo            Pointer to the font.
*                pco            Pointer to a CLIPOBJ structure.
*                prclOpaque    Pointer to the opaque rectangle.
*                pboFore        Pointer to the foreground brush.
*                pboOpaque    Pointer to the opaque brush.
*
* Returns:      TRUE if the font has been drawn, FALSE if DrvTextOut should
*                handle it.
*
\******************************************************************************/
BOOL bFontCache(
PDEV*     ppdev,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)
{
    BYTE      iDComplexity;
    BOOL      bMoreGlyphs;
    LONG      cGlyphs;
    GLYPHPOS* pgp;
    BOOL       bFirstTime;
    POINTL    ptlOrigin;
    ULONG      ulCharInc;
    RECTL      rclBounds;
    ULONG      ulDstOffset;
    POINTL      ptlDst;
    SIZEL      sizlDst;

    FONTCACHE* pfc      = pfo->pvConsumer;
    BYTE*       pjBase   = ppdev->pjBase;
    LONG       lDelta   = ppdev->lDelta;
    BYTE       jBltMode = ppdev->jModeColor;

    // If the font is uncacheable, return FALSE.
    if (pfc == (VOID*) -1)
    {
        DISPDBG((5, "bFontCache: pfo=0x%08X uncachable", pfo));
        return(FALSE);
    }

    // We don't support complex clipping.
    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;
    if (iDComplexity == DC_COMPLEX)
    {
        return(FALSE);
    }

    // If the font was invalidated by a mode switch (or DirectDraw), destroy it
    // first.
    if ((pfc != NULL) && (pfc->ulFontCacheID != ppdev->ulFontCacheID))
    {
        DISPDBG((5, "bFontCache: pfo=0x%08X invalidated (%d)", pfo,
                 pfc->ulFontCacheID));
        DrvDestroyFont(pfo);
        pfc = NULL;
    }

    // If the font has not been cached, allocate a cache structure now.
    if (pfc == NULL)
    {
        // Mark the font uncacheable if it is too high. We could opt to cache
        // even the largest of fonts, but that will only reject them later on
        // if there is not enough font cache memory (remember we allocate off-
        // screen fonts in rectangular areas) so it will be rejected anyway.
        // This gives quite a bit of extra overhead we can better do without.
        if ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) > FONT_ALLOC_Y)
        {
            DISPDBG((5, "bFontCache: pfo(0x%08X) too large (%d > %d)", pfo,
                     pstro->rclBkGround.bottom - pstro->rclBkGround.top,
                     FONT_ALLOC_Y));
            pfo->pvConsumer = (VOID*) -1;
            return(FALSE);
        }

        // Allocate the font cache structure.
        pfc = ALLOC(sizeof(FONTCACHE));
        if (pfc == NULL)
        {
            // Not enough memory.
            return(FALSE);
        }
        pfo->pvConsumer = pfc;

        // Initialize the font cache structure.
        pfc->ppdev         = ppdev;
        pfc->ulFontCacheID = ppdev->ulFontCacheID;
        pfc->cWidth        = BYTES_TO_PELS(FONT_ALLOC_X);
        pfc->cHeight       = FONT_ALLOC_Y;
        pfc->pfo           = pfo;

        // Allocate the first block of off-screen memory.
        if (pjAllocateFontCache(pfc, 0) == NULL)
        {
            // Not enough off-screen memory.
            DISPDBG((5, "bFontCache: pfo(0x%08X) not enough memory", pfo));

            if (pfc->pfm != NULL)
            {
                FREE(pfc->pfm);
            }
            FREE(pfc);
            pfo->pvConsumer = NULL;
            return(FALSE);
        }

        // Hook the font cache into the chain.
        pfc->pfcPrev    = NULL;
        pfc->pfcNext    = ppdev->pfcChain;
        ppdev->pfcChain = pfc;
        if (pfc->pfcNext != NULL)
        {
            pfc->pfcNext->pfcPrev = pfc;
        }
    }

    // If we need to draw an opaque rectangle...
    if (prclOpaque != NULL)
    {
        // Get opaque rectangle.
        if (iDComplexity == DC_TRIVIAL)
        {
            ptlDst.x   = prclOpaque->left;
            ptlDst.y   = prclOpaque->top;
            sizlDst.cx = prclOpaque->right  - ptlDst.x;
            sizlDst.cy = prclOpaque->bottom - ptlDst.y;
        }
        else
        {
            ptlDst.x   = max(prclOpaque->left,   pco->rclBounds.left);
            ptlDst.y   = max(prclOpaque->top,    pco->rclBounds.top);
            sizlDst.cx = min(prclOpaque->right,  pco->rclBounds.right)
                       - ptlDst.x;
            sizlDst.cy = min(prclOpaque->bottom, pco->rclBounds.bottom)
                       - ptlDst.y;
        }

        // If the clipped opaque rectangle is valid...
        if ((sizlDst.cx > 0) && (sizlDst.cy > 0))
        {
            ulDstOffset = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);
            sizlDst.cx  = PELS_TO_BYTES(sizlDst.cx) - 1;
            sizlDst.cy    = sizlDst.cy - 1;

            // Wait for bitblt engine.
            while (BUSY_BLT(ppdev, pjBase));

            // Program bitblt engine.
            CP_MM_FG_COLOR(ppdev, pjBase, pboOpaque->iSolidColor);
            CP_MM_XCNT(ppdev, pjBase, sizlDst.cx);
            CP_MM_YCNT(ppdev, pjBase, sizlDst.cy);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_SRC_ADDR(ppdev, pjBase, 0);
            CP_MM_BLT_MODE(ppdev, pjBase, jBltMode |
                                          ENABLE_COLOR_EXPAND |
                                          ENABLE_8x8_PATTERN_COPY);
            CP_MM_ROP(ppdev, pjBase, HW_P);
               CP_MM_BLT_EXT_MODE(ppdev, pjBase, ENABLE_SOLID_FILL);
            CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        }
    }

    // Setup loop variables.
    bFirstTime = TRUE;
    ulCharInc  = pstro->ulCharInc;
    jBltMode  |= ENABLE_COLOR_EXPAND | ENABLE_TRANSPARENCY_COMPARE;

    // No clipping...
    if (iDComplexity == DC_TRIVIAL)
    {
#if 1 // D5480
        ppdev->pfnGlyphOut(ppdev, pfc, pstro, pboFore->iSolidColor);
#else
        do
        {
            // Get pointer to array of glyphs.
            if (pstro->pgp != NULL)
            {
                pgp         = pstro->pgp;
                cGlyphs        = pstro->cGlyphs;
                bMoreGlyphs = FALSE;
            }
            else
            {
                bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
            }

            // Setup the blitter if this is the first loop through.
            if (bFirstTime)
            {
                // Wait for the bitblt engine.
                while (BUSY_BLT(ppdev, pjBase));

                // Setup the common bitblt registers.
                CP_MM_FG_COLOR(ppdev, pjBase, pboFore->iSolidColor);
                CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
                CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
                CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);

                // Mark registers as setup.
                bFirstTime = FALSE;
            }

            // Get coordinates of first glyph.
            ptlOrigin.x = pgp->ptl.x;
            ptlOrigin.y = pgp->ptl.y;

            // Loop through all glyphs.
            while (cGlyphs-- > 0)
            {
                LONG        cy;
                GLYPHCACHE* pgc;

                if (pgp->hg < MAX_GLYPHS)
                {
                    // This is a cacheable glyph index.
                    pgc = &pfc->aGlyphs[pgp->hg];
                    cy  = (pgc->pjGlyph == NULL)
                        ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                        : pgc->sizlBytes.cy;
                }
                else
                {
                    // The glyph index is out of range.
                    cy = GLYPH_UNCACHEABLE;
                }

                if (cy >= 0) // The glyph is cached, expand it to the screen.
                {
                    // Setup the destination variables.
                    ptlDst.x = ptlOrigin.x + pgc->ptlOrigin.x;
                    ptlDst.y = ptlOrigin.y + pgc->ptlOrigin.y;
                    ulDstOffset = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

                    // Wait for the bitblt engine.
                    while (BUSY_BLT(ppdev, pjBase));

                    // Perform the blit expansion.
                    CP_MM_XCNT(ppdev, pjBase, pgc->sizlBytes.cx);
                    CP_MM_YCNT(ppdev, pjBase, cy);
                    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, pgc->lDelta);
                    CP_MM_SRC_ADDR(ppdev, pjBase, pgc->pjGlyph);
                    CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
                    CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
                }
                else if (cy == GLYPH_UNCACHEABLE)
                {
                    // The glyph is uncacheable, draw it directly.
                    vDrawGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin);
                }

                // Next glyph.
                pgp++;
                if (ulCharInc)
                {
                    ptlOrigin.x += ulCharInc;
                }
                else
                {
                    ptlOrigin.x = pgp->ptl.x;
                    ptlOrigin.y = pgp->ptl.y;
                }
            }
        } while (bMoreGlyphs);
#endif // endif D5480
        return(TRUE);
    }

    // Clipping...
    rclBounds = pco->rclBounds;

#if 1 // D5480
        ppdev->pfnGlyphOutClip(ppdev, pfc, pstro, &rclBounds, pboFore->iSolidColor);
#else
    do
    {
        // Get pointer to array of glyphs.
        if (pstro->pgp != NULL)
        {
            pgp         = pstro->pgp;
            cGlyphs        = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
        }

        // Setup the blitter if this is the first loop through.
        if (bFirstTime)
        {
            // Wait for the bitblt engine.
            while (BUSY_BLT(ppdev, pjBase));

            // Setup the common bitblt registers.
            CP_MM_FG_COLOR(ppdev, pjBase, pboFore->iSolidColor);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);

            // Mark registers as setup.
            bFirstTime = FALSE;
        }

        // Get coordinates of first glyph.
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;

        // Loop through all glyphs.
        while (cGlyphs-- > 0)
        {
            LONG        c, cy;
            GLYPHCACHE* pgc;

            if (pgp->hg < MAX_GLYPHS)
            {
                // This is a cacheable glyph index.
                pgc = &pfc->aGlyphs[pgp->hg];
                cy  = (pgc->pjGlyph == NULL)
                    ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                    : pgc->sizlBytes.cy;
            }
            else
            {
                // The glyph index is out of range.
                goto SoftwareClipping;
            }

            if (cy >= 0)
            {
                // The glyph is cached, expand it to the screen.
                ULONG ulSrcOffset;
                RECTL rcl;
                LONG  lSrcDelta;
                LONG  cSkipBits;

                // Calculate the glyph bounding box.
                rcl.left  = ptlOrigin.x + pgc->ptlOrigin.x;
                rcl.right = rcl.left + pgc->sizlPixels.cx;
                if ((rcl.left >= rclBounds.right) ||
                    (rcl.right <= rclBounds.left))
                {
                    goto NextGlyph;
                }
                rcl.top    = ptlOrigin.y + pgc->ptlOrigin.y;
                rcl.bottom = rcl.top + pgc->sizlPixels.cy;
                if ((rcl.top >= rclBounds.bottom) ||
                    (rcl.bottom <= rclBounds.top))
                {
                    goto NextGlyph;
                }

                // Setup source parameters.
                ulSrcOffset = (ULONG) pgc->pjGlyph;
                lSrcDelta   = pgc->lDelta;

                // Do the left side clipping.
                c = rclBounds.left - rcl.left;
                if (c > 0)
                {
                    ulSrcOffset += c >> 3;
                    cSkipBits    = c & 7;
                    rcl.left    += c & ~7;

                    if (ppdev->cBpp == 3)
                    {
                        cSkipBits *= 3;
                    }

                    ulSrcOffset |= cSkipBits << 24;
                }

                // Do the top side clipping.
                c = rclBounds.top - rcl.top;
                if (c > 0)
                {
                    rcl.top     += c;
                    ulSrcOffset += c * lSrcDelta;
                }

                // Calculate size of the blit.
                sizlDst.cx = min(rcl.right,  rclBounds.right)  - rcl.left;
                sizlDst.cy = min(rcl.bottom, rclBounds.bottom) - rcl.top;
                if ((sizlDst.cx <= 0) || (sizlDst.cy <= 0))
                {
                    goto NextGlyph;
                }

                // Setup destination variables.
                ulDstOffset = (rcl.top * lDelta) + PELS_TO_BYTES(rcl.left);

                // HARDWARE BUG:
                // ============
                // A monochrome screen-to-screen expansion with a source pitch
                // not equaling the width of the expansion (i.e. left- and/or
                // right-side clipping) is not done correctly by the hardware.
                // So we have to do the line increment by software.
                if (((sizlDst.cx + 7) >> 3) != lSrcDelta)
                {
                    // Wait for the bitblt engine.
                    while (BUSY_BLT(ppdev, pjBase));

                    // Setup the common bitblt registers.
                    CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
                    CP_MM_YCNT(ppdev, pjBase, 0);
                    CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);

                    while (TRUE)
                    {
                        // Perform the expansion.
                        CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
                        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

                        // Next line.
                        if (--sizlDst.cy == 0)
                        {
                            goto NextGlyph;
                        }
                        ulSrcOffset += lSrcDelta;
                        ulDstOffset += lDelta;

                        // Wait for the bitblt engine.
                        while (BUSY_BLT(ppdev, pjBase));
                    }
                }

                // Wait for the bitblt engine.
                while (BUSY_BLT(ppdev, pjBase));

                // Perform the expansion.
                CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
                CP_MM_YCNT(ppdev, pjBase, sizlDst.cy - 1);
                CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lSrcDelta);
                CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
                CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
                CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
            }
            else if (cy == GLYPH_UNCACHEABLE)
            {
                SoftwareClipping:
                {
                    // The glyph is uncacheable, draw it directly.
                    vClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds,
                               pboFore->iSolidColor);
                }
            }

            // Next glyph.
            NextGlyph:
            {
                pgp++;
                if (ulCharInc)
                {
                    ptlOrigin.x += ulCharInc;
                }
                else
                {
                    ptlOrigin.x = pgp->ptl.x;
                    ptlOrigin.y = pgp->ptl.y;
                }
            }
        }
    } while (bMoreGlyphs);
#endif // D5480
    return(TRUE);
}

/******************************************************************************\
*
* Function:     vDrawGlyph
*
* Draw an uncacheable glyph directly to screen.
*
* Parameters:   ppdev        Pointer to physical device.
*                pgb            Pointer to glyph to draw.
*                ptl            Coordinates of the glyph.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vDrawGlyph(
PDEV*      ppdev,
GLYPHBITS* pgb,
POINTL     ptl)
{
    BYTE*  pjBase = ppdev->pjBase;
    BYTE   jBltMode;
    ULONG  dstOffset;
    DWORD* pulSrc;
    DWORD* pulDst;
    LONG   c, cx, cy;
    LONG   x, y;

    // BLT Mode Register value.
    jBltMode = ENABLE_COLOR_EXPAND
             | ENABLE_TRANSPARENCY_COMPARE
             | SRC_CPU_DATA
             | ppdev->jModeColor;

    // Calculate the destination offset.
    x = ptl.x + pgb->ptlOrigin.x;
    y = ptl.y + pgb->ptlOrigin.y;
    dstOffset = (y * ppdev->lDelta) + PELS_TO_BYTES(x);

    // Calculate the glyph variables.
    pulSrc = (DWORD*) pgb->aj;
    pulDst = (DWORD*) ppdev->pulXfer;
    cx     = pgb->sizlBitmap.cx;
    cy     = pgb->sizlBitmap.cy;
    c      = (((cx + 7) >> 3) * cy + 3) >> 2;    // Number of DWORDs to transfer.
    cx      *= ppdev->cBpp;

    // Wait for the blitter.
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    // Setup the blitter registers.
    CP_MM_XCNT(ppdev, pjBase, cx - 1);
    CP_MM_YCNT(ppdev, pjBase, cy - 1);
    CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
    CP_MM_DST_ADDR(ppdev, pjBase, dstOffset);

    // Copy the data from the glyph to the screen. Note that the glyph is
    // always DWORD aligned, so we don't have to do anything weird here.
    while (c-- > 0)
    {
        *pulDst = *pulSrc++;
    }
}

/******************************************************************************\
*
* Function:     vClipGlyph
*
* Draw an uncacheable glyph directly to screen using a clipping rectangle.
*
* Parameters:   ppdev        Pointer to physical device.
*                pgb            Pointer to glyph to draw.
*                ptl            Coordinates of the glyph.
*                rclBounds    Clipping rectangle.
*               ulColor     Foreground Color.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vClipGlyph(
PDEV*      ppdev,
GLYPHBITS* pgb,
POINTL     ptl,
RECTL*       rclBounds,
ULONG       ulColor)
{
    BYTE   jBltMode;
    ULONG  ulDstOffset;
    BYTE*  pjSrc;
    LONG   cx, cy;
    RECTL  rcl;
    LONG   lSrcDelta;
    LONG   i, cBytes;

    BYTE*  pjBase    = ppdev->pjBase;
    LONG   lDelta    = ppdev->lDelta;
    ULONG* pulDst    = (ULONG*) ppdev->pulXfer;
    LONG   cSkipBits = 0;

    // Calculate glyph bounding box.
    rcl.left   = ptl.x + pgb->ptlOrigin.x;
    rcl.top    = ptl.y + pgb->ptlOrigin.y;
    rcl.right  = min(rcl.left + pgb->sizlBitmap.cx, rclBounds->right);
    rcl.bottom = min(rcl.top  + pgb->sizlBitmap.cy, rclBounds->bottom);

    // Setup source variables.
    pjSrc     = pgb->aj;
    lSrcDelta = (pgb->sizlBitmap.cx + 7) >> 3;

    // Setup BLT Mode Register value.
    jBltMode = ENABLE_COLOR_EXPAND
             | ENABLE_TRANSPARENCY_COMPARE
             | SRC_CPU_DATA
             | ppdev->jModeColor;

    // Do left side clipping.
    cx = rclBounds->left - rcl.left;
    if (cx > 0)
    {
        pjSrc    += cx >> 3;
        cSkipBits = cx & 7;
        rcl.left += cx & ~7;

        if (ppdev->cBpp == 3)
        {
            cSkipBits *= 3;
        }
    }

    // Calculate width in pixels.
    cx = rcl.right - rcl.left;
    if (cx <= 0)
    {
        // Glyph is completely clipped.
        return;
    }

    // Do top side clipping.
    cy = rclBounds->top - rcl.top;
    if (cy > 0)
    {
        pjSrc   += cy * lSrcDelta;
        rcl.top += cy;
    }

    // Calculate height in pixels.
    cy = rcl.bottom - rcl.top;
    if (cy <= 0)
    {
        // Glyph is completely clipped.
        return;
    }

    // Setup destination variables.
    ulDstOffset = (rcl.top * ppdev->lDelta) + PELS_TO_BYTES(rcl.left);
    cBytes        = (cx + 7) >> 3;

    // Wait for the bitblt engine.
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);

    // Setup the bitblt registers.
    CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(cx) - 1);
    CP_MM_YCNT(ppdev, pjBase, cy - 1);
    CP_MM_DST_WRITE_MASK(ppdev, pjBase, cSkipBits);
    CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, SOURCE_GRANULARITY);
    CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

    while (cy--)
    {
        BYTE* pjSrcTmp = pjSrc;

        // Copy one line of glyph data to the screen.
        for (i = cBytes; i >= sizeof(ULONG); i -= sizeof(ULONG))
        {
            *pulDst = *((ULONG*)pjSrcTmp)++;
        }

        if (i == 1)
        {
            *pulDst = *(BYTE*)pjSrcTmp;
        }
        else if (i == 2)
        {
            *pulDst = *(USHORT*)pjSrcTmp;
        }
        else if (i == 3)
        {
            *pulDst = pjSrcTmp[0] | (pjSrcTmp[1] << 8) | (pjSrcTmp[2] << 16);
        }

        pjSrc += lSrcDelta;
    }
    while (BUSY_BLT(ppdev, pjBase));
    CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);
}


#if 1 // D5480
/******************************************************************************\
*
* Function:     vGlyphOut
*
* Draw an uncacheable glyph directly to screen.
*
* Parameters:   ppdev            Pointer to physical device.
*               pfc             Pointer to FONTCACHE.
*                pstro            Pointer to array of glyphs to draw.
*               ulSolidColor    Foreground Color.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vMmGlyphOut(
PDEV*       ppdev,
FONTCACHE*  pfc,
STROBJ*     pstro,
ULONG       ulSolidColor )
{
    BOOL      bMoreGlyphs;
    LONG      cGlyphs;
    GLYPHPOS* pgp;
    BOOL      bFirstTime;
    POINTL    ptlOrigin;
    ULONG     ulCharInc;
    ULONG     ulDstOffset;
    POINTL    ptlDst;
    BYTE*     pjBase   = ppdev->pjBase;
    BYTE      jBltMode = ppdev->jModeColor;
    LONG      lDelta   = ppdev->lDelta;

    bFirstTime = TRUE;
    ulCharInc  = pstro->ulCharInc;
    jBltMode  |= ENABLE_COLOR_EXPAND | ENABLE_TRANSPARENCY_COMPARE;

    do
    {
        // Get pointer to array of glyphs.
        if (pstro->pgp != NULL)
        {
            pgp         = pstro->pgp;
            cGlyphs        = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
        }

        // Setup the blitter if this is the first loop through.
        if (bFirstTime)
        {
            // Wait for the bitblt engine.
            while (BUSY_BLT(ppdev, pjBase));

            // Setup the common bitblt registers.
            CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);

            // Mark registers as setup.
            bFirstTime = FALSE;
        }

        // Get coordinates of first glyph.
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;


        // Loop through all glyphs.
        while (cGlyphs-- > 0)
        {
            LONG        cy;
            GLYPHCACHE* pgc;

            if (pgp->hg < MAX_GLYPHS)
            {
                // This is a cacheable glyph index.
                pgc = &pfc->aGlyphs[pgp->hg];
                cy  = (pgc->pjGlyph == NULL)
                    ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                    : pgc->sizlBytes.cy;
            }
            else
            {
                // The glyph index is out of range.
                cy = GLYPH_UNCACHEABLE;
            }

            if (cy >= 0) // The glyph is cached, expand it to the screen.
            {
                // Setup the destination variables.
                ptlDst.x = ptlOrigin.x + pgc->ptlOrigin.x;
                ptlDst.y = ptlOrigin.y + pgc->ptlOrigin.y;
                ulDstOffset = (ptlDst.y * lDelta) + PELS_TO_BYTES(ptlDst.x);

                // Wait for the bitblt engine.
                while (BUSY_BLT(ppdev, pjBase));

                // Perform the blit expansion.
                CP_MM_XCNT(ppdev, pjBase, pgc->sizlBytes.cx);
                CP_MM_YCNT(ppdev, pjBase, cy);
                CP_MM_SRC_Y_OFFSET(ppdev, pjBase, pgc->lDelta);
                CP_MM_SRC_ADDR(ppdev, pjBase, (ULONG_PTR)pgc->pjGlyph);
                CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
                CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
            }
            else if (cy == GLYPH_UNCACHEABLE)
            {
                // The glyph is uncacheable, draw it directly.
                vDrawGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin);
            }

            // Next glyph.
            pgp++;
            if (ulCharInc)
            {
                ptlOrigin.x += ulCharInc;
            }
            else
            {
                ptlOrigin.x = pgp->ptl.x;
                ptlOrigin.y = pgp->ptl.y;
            }
        }
    } while (bMoreGlyphs);
}

/******************************************************************************\
*
* Function:     vGlyphOutClip
*
* Draw an uncacheable glyph directly to screen.
*
* Parameters:   ppdev            Pointer to physical device.
*               pfc             Pointer to FONTCACHE.
*                pstro            Pointer to array of glyphs to draw.
*                rclBounds        Clipping rectangle.
*               ulSolidColor    Foreground Color.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vMmGlyphOutClip(
PDEV*       ppdev,
FONTCACHE*  pfc,
STROBJ*     pstro,
RECTL*        rclBounds,
ULONG       ulSolidColor )
{
    BOOL      bMoreGlyphs;
    LONG      cGlyphs;
    GLYPHPOS* pgp;
    BOOL       bFirstTime;
    POINTL    ptlOrigin;
    ULONG      ulCharInc;
    ULONG     ulDstOffset;
    POINTL      ptlDst;
    BYTE*     pjBase   = ppdev->pjBase;
    BYTE      jBltMode = ppdev->jModeColor;
    LONG      lDelta   = ppdev->lDelta;

    bFirstTime = TRUE;
    ulCharInc  = pstro->ulCharInc;
    jBltMode  |= ENABLE_COLOR_EXPAND | ENABLE_TRANSPARENCY_COMPARE;

    do
    {
        // Get pointer to array of glyphs.
        if (pstro->pgp != NULL)
        {
            pgp         = pstro->pgp;
            cGlyphs        = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
        }

        // Setup the blitter if this is the first loop through.
        if (bFirstTime)
        {
            // Wait for the bitblt engine.
            while (BUSY_BLT(ppdev, pjBase));

            // Setup the common bitblt registers.
            CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);
            CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
            CP_MM_ROP(ppdev, pjBase, CL_SRC_COPY);
            CP_MM_BLT_EXT_MODE(ppdev, pjBase, 0);

            // Mark registers as setup.
            bFirstTime = FALSE;
        }

        // Get coordinates of first glyph.
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;

        // Loop through all glyphs.
        while (cGlyphs-- > 0)
        {
            LONG        c, cy;
            GLYPHCACHE* pgc;

            if (pgp->hg < MAX_GLYPHS)
            {
                // This is a cacheable glyph index.
                pgc = &pfc->aGlyphs[pgp->hg];
                cy  = (pgc->pjGlyph == NULL)
                    ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                    : pgc->sizlBytes.cy;
            }
            else
            {
                // The glyph index is out of range.
                goto SoftwareClipping;
            }

            if (cy >= 0)
            {
                // The glyph is cached, expand it to the screen.
                ULONG ulSrcOffset;
                RECTL rcl;
                LONG  lSrcDelta;
                LONG  cSkipBits;
                SIZEL sizlDst;

                // Calculate the glyph bounding box.
                rcl.left  = ptlOrigin.x + pgc->ptlOrigin.x;
                rcl.right = rcl.left + pgc->sizlPixels.cx;
                if ((rcl.left >= rclBounds->right) ||
                    (rcl.right <= rclBounds->left))
                {
                    goto NextGlyph;
                }
                rcl.top    = ptlOrigin.y + pgc->ptlOrigin.y;
                rcl.bottom = rcl.top + pgc->sizlPixels.cy;
                if ((rcl.top >= rclBounds->bottom) ||
                    (rcl.bottom <= rclBounds->top))
                {
                    goto NextGlyph;
                }

                // Setup source parameters.
                ulSrcOffset = (ULONG)((ULONG_PTR)pgc->pjGlyph);
                lSrcDelta   = pgc->lDelta;

                // Do the left side clipping.
                c = rclBounds->left - rcl.left;
                if (c > 0)
                {
                    ulSrcOffset += c >> 3;
                    cSkipBits    = c & 7;
                    rcl.left    += c & ~7;

                    if (ppdev->cBpp == 3)
                    {
                        cSkipBits *= 3;
                    }

                    ulSrcOffset |= cSkipBits << 24;
                }

                // Do the top side clipping.
                c = rclBounds->top - rcl.top;
                if (c > 0)
                {
                    rcl.top     += c;
                    ulSrcOffset += c * lSrcDelta;
                }

                // Calculate size of the blit.
                sizlDst.cx = min(rcl.right,  rclBounds->right)  - rcl.left;
                sizlDst.cy = min(rcl.bottom, rclBounds->bottom) - rcl.top;
                if ((sizlDst.cx <= 0) || (sizlDst.cy <= 0))
                {
                    goto NextGlyph;
                }

                // Setup destination variables.
                ulDstOffset = (rcl.top * lDelta) + PELS_TO_BYTES(rcl.left);

                // HARDWARE BUG:
                // ============
                // A monochrome screen-to-screen expansion with a source pitch
                // not equaling the width of the expansion (i.e. left- and/or
                // right-side clipping) is not done correctly by the hardware.
                // So we have to do the line increment by software.
                if (((sizlDst.cx + 7) >> 3) != lSrcDelta)
                {
                    // Wait for the bitblt engine.
                    while (BUSY_BLT(ppdev, pjBase));

                    // Setup the common bitblt registers.
                    CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
                    CP_MM_YCNT(ppdev, pjBase, 0);
                    CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);

                    while (TRUE)
                    {
                        // Perform the expansion.
                        CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
                        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);

                        // Next line.
                        if (--sizlDst.cy == 0)
                        {
                            goto NextGlyph;
                        }
                        ulSrcOffset += lSrcDelta;
                        ulDstOffset += lDelta;

                        // Wait for the bitblt engine.
                        while (BUSY_BLT(ppdev, pjBase));
                    }
                }

                // Wait for the bitblt engine.
                while (BUSY_BLT(ppdev, pjBase));

                // Perform the expansion.
                CP_MM_XCNT(ppdev, pjBase, PELS_TO_BYTES(sizlDst.cx) - 1);
                CP_MM_YCNT(ppdev, pjBase, sizlDst.cy - 1);
                CP_MM_SRC_Y_OFFSET(ppdev, pjBase, lSrcDelta);
                CP_MM_SRC_ADDR(ppdev, pjBase, ulSrcOffset);
                CP_MM_BLT_MODE(ppdev, pjBase, jBltMode);
                CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
            }
            else if (cy == GLYPH_UNCACHEABLE)
            {
                SoftwareClipping:
                {
                    // The glyph is uncacheable, draw it directly.
                    vClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds,
                               ulSolidColor);
                }
            }

            // Next glyph.
            NextGlyph:
            {
                pgp++;
                if (ulCharInc)
                {
                    ptlOrigin.x += ulCharInc;
                }
                else
                {
                    ptlOrigin.x = pgp->ptl.x;
                    ptlOrigin.y = pgp->ptl.y;
                }
            }
        }
    } while (bMoreGlyphs);
}

/******************************************************************************\
*
* Function:     vGlyphOut80
*
* Draw an uncacheable glyph directly to screen.
*
* Parameters:   ppdev            Pointer to physical device.
*               pfc             Pointer to FONTCACHE.
*                pstro            Pointer to array of glyphs to draw.
*               ulSolidColor    Foreground Color.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vMmGlyphOut80(
PDEV*       ppdev,
FONTCACHE*  pfc,
STROBJ*     pstro,
ULONG       ulSolidColor )
{
    ULONG_PTR*   ulCLStart;
    ULONG       ulWidthHeight;
    ULONG       xCLOffset;
    BOOL        bMoreGlyphs;
    LONG        cGlyphs;
    GLYPHPOS*   pgp;
    POINTL      ptlOrigin;
    ULONG       ulCharInc;
    POINTL      ptlDst;
    LONG        cy;
    GLYPHCACHE* pgc;
    DWORD       jSaveMode;
    ULONG       cCommandPacket = 0;
    ULONG       ulDstOffset = 0;
    BOOL        bCommandListOpen = FALSE;
    BYTE*       pjBase   = ppdev->pjBase;
    LONG        lDelta   = ppdev->lDelta;
    DWORD       jExtMode = ENABLE_XY_POSITION_PACKED
                           | CL_PACKED_SRC_COPY
                           | ppdev->jModeColor 
                           | ENABLE_COLOR_EXPAND
                           | ENABLE_TRANSPARENCY_COMPARE;

    ulCharInc  = pstro->ulCharInc;
    jSaveMode = jExtMode;

    //
    // Make sure we can write to the video registers.
    //
    // We need to change to wait for buffer ready
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    
    // Setup the common bitblt registers.
    CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);
    // Do we really need to set it every time?
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);

    do
    {
        // Get pointer to array of glyphs.
        if (pstro->pgp != NULL)
        {
            pgp         = pstro->pgp;
            cGlyphs        = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
        }

        // Get coordinates of first glyph.
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;


        // Loop through all glyphs.
        while (cGlyphs-- > 0)
        {
            if (pgp->hg < MAX_GLYPHS)
            {
                // This is a cacheable glyph index.
                pgc = &pfc->aGlyphs[pgp->hg];
                cy  = (pgc->pjGlyph == NULL)
                    ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                    : pgc->sizlBytes.cy;
            }
            else
            {
                // The glyph index is out of range.
                cy = GLYPH_UNCACHEABLE;
            }

            if (cy >= 0) // The glyph is cached, expand it to the screen.
            {
                if ( bCommandListOpen )
                {
                    // Command List
                    if( cCommandPacket == 0 )
                    {
                        jExtMode |= ENABLE_COMMAND_LIST_PACKED;
                        ulCLStart = ppdev->pCommandList;
                        ulDstOffset |= (ULONG)(((ULONG_PTR)ulCLStart
                                            - (ULONG_PTR)ppdev->pjScreen) << 14);
                        CP_MM_CL_SWITCH(ppdev);
                    }
    
                    // Calculate the destination address and size.
                    *ulCLStart = PACKXY_FAST(pgc->sizlPixels.cx - 1, cy);
                    // XY
                    *(ulCLStart + 1) = PACKXY_FAST(ptlOrigin.x + pgc->ptlOrigin.x,
                                                   ptlOrigin.y + pgc->ptlOrigin.y);
                    // Source Start address
                    *(ulCLStart + 2) = (ULONG)((ULONG_PTR)pgc->pjGlyph);
            
                    // Dst/SRC pitch
                    *(ulCLStart + 3) = PACKXY_FAST(lDelta, pgc->lDelta);

                    ulCLStart += 4;

                    if( ++cCommandPacket > COMMAND_TOTAL_PACKETS )
                    {
                        // Indicate last Packet
                        *(ulCLStart - 4) |= COMMAND_LAST_PACKET; 
                        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode);
                        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
                        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
                        bCommandListOpen = FALSE;
                        cCommandPacket   = 0;
                        jExtMode         = jSaveMode; 
                        ulDstOffset      = 0;
                    }
                }
                else
                {
                    bCommandListOpen = TRUE;
                    //
                    // Make sure we can write to the video registers.
                    //
                    // We need to change to wait for buffer ready
                    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                    // Setup the first set.
                    xCLOffset = ptlOrigin.x + pgc->ptlOrigin.x;
                    CP_MM_DST_Y(ppdev, pjBase, ptlOrigin.y + pgc->ptlOrigin.y);
                    CP_MM_SRC_Y_OFFSET(ppdev, pjBase, pgc->lDelta);
                    CP_MM_SRC_ADDR(ppdev,pjBase,(ULONG_PTR)pgc->pjGlyph);

                    // Perform the blit expansion.
                    CP_MM_XCNT(ppdev, pjBase, pgc->sizlPixels.cx - 1 );
                    CP_MM_YCNT(ppdev, pjBase, cy);
                }
            }
            else if (cy == GLYPH_UNCACHEABLE)
            {
                if ( bCommandListOpen )
                {
                    // Indicate last Packet
                    if ( cCommandPacket )
                        *(ulCLStart - 4) |= COMMAND_LAST_PACKET; 
                    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode);
                    CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
                    CP_MM_DST_X(ppdev, pjBase, xCLOffset);
                    bCommandListOpen    = FALSE;
                    jExtMode            = jSaveMode;
                    cCommandPacket      = 0;
                    ulDstOffset         = 0;
                }
                // The glyph is uncacheable, draw it directly.
                vDrawGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin);
            }

            // Next glyph.
            pgp++;
            if (ulCharInc)
            {
                ptlOrigin.x += ulCharInc;
            }
            else
            {
                ptlOrigin.x = pgp->ptl.x;
                ptlOrigin.y = pgp->ptl.y;
            }
        }
    } while (bMoreGlyphs);

    if ( bCommandListOpen )
    {
        // Indicate last Packet
        if ( cCommandPacket )
            *(ulCLStart - 4) |= COMMAND_LAST_PACKET; 
        CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode);
        CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
        CP_MM_DST_X(ppdev, pjBase, xCLOffset);
    }

}

/******************************************************************************\
*
* Function:     vGlyphOutClip80
*
* Draw an uncacheable glyph directly to screen.
*
* Parameters:   ppdev            Pointer to physical device.
*               pfc             Pointer to FONTCACHE.
*                pstro            Pointer to array of glyphs to draw.
*                rclBounds        Clipping rectangle.
*               ulSolidColor    Foreground Color.
*
* Returns:      Nothing.
*
\******************************************************************************/
VOID vMmGlyphOutClip80(
PDEV*       ppdev,
FONTCACHE*  pfc,
STROBJ*     pstro,
RECTL*      rclBounds,
ULONG       ulSolidColor )
{
    BOOL        bMoreGlyphs;
    LONG        cGlyphs;
    GLYPHPOS*   pgp;
    POINTL      ptlOrigin;
    ULONG       ulCharInc;
    POINTL      ptlDst;
    LONG        cy;
    GLYPHCACHE* pgc;
    RECTL       rclDst;
    RECTL       rclClip;
    ULONG       ulDstOffset;
    BYTE*       pjBase   = ppdev->pjBase;
    LONG        lDelta   = ppdev->lDelta;
    DWORD       jExtMode = ENABLE_XY_POSITION_PACKED
                           | ENABLE_CLIP_RECT_PACKED
                           | CL_PACKED_SRC_COPY
                           | ppdev->jModeColor 
                           | ENABLE_COLOR_EXPAND
                           | ENABLE_TRANSPARENCY_COMPARE;

    ulCharInc  = pstro->ulCharInc;

    //
    // Make sure we can write to the video registers.
    //
    // We need to change to wait for buffer ready
    CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
    
    // Setup the common bitblt registers.
    CP_MM_FG_COLOR(ppdev, pjBase, ulSolidColor);
    // Do we really need to set it every time?
    CP_MM_DST_Y_OFFSET(ppdev, pjBase, lDelta);
    CP_MM_SRC_XY_PACKED(ppdev, pjBase, 0);

    CP_MM_BLT_MODE_PACKED(ppdev, pjBase, jExtMode);

    do
    {
        // Get pointer to array of glyphs.
        if (pstro->pgp != NULL)
        {
            pgp         = pstro->pgp;
            cGlyphs        = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphs, &pgp);
        }

        // Get coordinates of first glyph.
        ptlOrigin.x = pgp->ptl.x;
        ptlOrigin.y = pgp->ptl.y;

        // Loop through all glyphs.
        while (cGlyphs-- > 0)
        {
            LONG        c, cy;
            GLYPHCACHE* pgc;

            if (pgp->hg < MAX_GLYPHS)
            {
                // This is a cacheable glyph index.
                pgc = &pfc->aGlyphs[pgp->hg];
                cy  = (pgc->pjGlyph == NULL)
                    ? lAllocateGlyph(pfc, pgp->pgdf->pgb, pgc)
                    : pgc->sizlBytes.cy;
            }
            else
            {
                // The glyph index is out of range.
                cy = GLYPH_UNCACHEABLE;
            }

            if (cy >= 0)
            {
                // Calculate the glyph bounding box.
                rclDst.left  = ptlOrigin.x + pgc->ptlOrigin.x;
                rclDst.right = rclDst.left + pgc->sizlPixels.cx;
                if ((rclDst.left >= rclBounds->right) ||
                    (rclDst.right <= rclBounds->left))
                {
                    goto NextGlyph;
                }
                rclDst.top    = ptlOrigin.y + pgc->ptlOrigin.y;
                rclDst.bottom = rclDst.top + pgc->sizlPixels.cy;
                if ((rclDst.top >= rclBounds->bottom) ||
                    (rclDst.bottom <= rclBounds->top))
                {
                    goto NextGlyph;
                }
                
                rclClip     = *rclBounds;
                ulDstOffset = 0;
                //
                // Handle X negtive
                //
                if (rclDst.left < 0)
                {
                    rclClip.left    -= rclDst.left;
                    rclClip.right   -= rclDst.left;
                    ulDstOffset     += PELS_TO_BYTES(rclDst.left);
                    rclDst.left      = 0;
                }
                //
                // Handle Y negtive
                //
                if (rclDst.top < 0)
                {
                    rclClip.top     -= rclDst.top;
                    rclClip.bottom  -= rclDst.top;
                    ulDstOffset     += (rclDst.top * lDelta);
                    rclDst.top       = 0;
                }

                CP_MM_CLIP_ULXY(ppdev, pjBase, rclClip.left, rclClip.top);
                CP_MM_CLIP_LRXY(ppdev, pjBase, rclClip.right - 1, rclClip.bottom - 1);

                //
                // Make sure we can write to the video registers.
                //
                // We need to change to wait for buffer ready
                CP_MM_WAIT_FOR_BLT_COMPLETE(ppdev, pjBase);
                CP_MM_DST_Y(ppdev, pjBase, rclDst.top);
                CP_MM_SRC_Y_OFFSET(ppdev, pjBase, pgc->lDelta);
                CP_MM_SRC_ADDR(ppdev, pjBase, (ULONG_PTR)pgc->pjGlyph);

                // Perform the blit expansion.
                CP_MM_XCNT(ppdev, pjBase, pgc->sizlPixels.cx - 1 );
                CP_MM_YCNT(ppdev, pjBase, cy);
                CP_MM_DST_ADDR(ppdev, pjBase, ulDstOffset);
                CP_MM_DST_X(ppdev, pjBase, rclDst.left);
            }
            else if (cy == GLYPH_UNCACHEABLE)
            {
                // The glyph is uncacheable, draw it directly.
                vClipGlyph(ppdev, pgp->pgdf->pgb, ptlOrigin, rclBounds,
                           ulSolidColor);
            }

            // Next glyph.
            NextGlyph:
            {
                pgp++;
                if (ulCharInc)
                {
                    ptlOrigin.x += ulCharInc;
                }
                else
                {
                    ptlOrigin.x = pgp->ptl.x;
                    ptlOrigin.y = pgp->ptl.y;
                }
            }
        }
    } while (bMoreGlyphs);

}
#endif // endif D5480
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\callback.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation.
Copyright (c) 1996-1997  Cirrus Logic, Inc.,

Module Name:

    C    A    L    L    B    A    C    K  .  C

Abstract:

    This routine contains various callback routines. e.g.,

    -  Gamma correction information from the following NT 4.0 registry.
         Registry subdirectory : System\CurrentControlSet\Services\cirrus\Device0
         Keys                  : "G Gamma", and "G Contrast"

    -  Callback routines for the DDC and Non-DDC monitors.

    -  IBM specific callback routine to get rid of 1024x768x16bpp 85Hz.
         Registry subdirectory : System\CurrentControlSet\Services\cirrus\Device0
         Keys                  : "OemModeOff"

Environment:

    Kernel mode only

Notes:
*
*    chu01  12-16-96 : Color correction start coding.
*    chu02  03-26-97 : Get rid of 1024x768x16bpp ( Mode 0x74 ) 85H for IBM only.
*
*
--*/


//---------------------------------------------------------------------------
// HEADER FILES
//---------------------------------------------------------------------------

//#include <ntddk.h>
#include <dderror.h>
#include <devioctl.h>
#include <miniport.h>  // I added
#include "clmini.h"

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"

extern UCHAR EDIDBuffer[]   ;

//---------------------------------------------------------------------------
// FUNCTION PROTOTYPE
//---------------------------------------------------------------------------

VP_STATUS
VgaGetGammaFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PGAMMA_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

VP_STATUS
VgaGetContrastFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCONTRAST_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

VP_STATUS GetGammaKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    ) ;

VP_STATUS GetContrastKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    ) ;

VP_STATUS GetGammaCorrectInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    ) ;

VP_STATUS
CirrusDDC2BRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VP_STATUS
CirrusNonDDCRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

BOOLEAN
IOCallback(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    ) ;

VP_STATUS
CirrusGetDeviceDataCallback(
   PVOID HwDeviceExtension,
   PVOID Context,
   VIDEO_DEVICE_DATA_TYPE DeviceDataType,
   PVOID Identifier,
   ULONG IdentifierLength,
   PVOID ConfigurationData,
   ULONG ConfigurationDataLength,
   PVOID ComponentInformation,
   ULONG ComponentInformationLength
   );

// chu02
VP_STATUS
GetOemModeOffInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetGammaKeyInfoFromReg)
#pragma alloc_text(PAGE,GetContrastKeyInfoFromReg)
#pragma alloc_text(PAGE,GetGammaCorrectInfoCallBack)
#pragma alloc_text(PAGE,VgaGetGammaFactor)
#pragma alloc_text(PAGE,VgaGetContrastFactor)
#pragma alloc_text(PAGE,CirrusDDC2BRegistryCallback)
#pragma alloc_text(PAGE,CirrusNonDDCRegistryCallback)
#pragma alloc_text(PAGE,CirrusGetDeviceDataCallback)
#pragma alloc_text(PAGE,GetOemModeOffInfoCallBack)                   // chu02
#endif

UCHAR GammaInfo[4] ;
UCHAR ModesExclude[4] ;                                              // chu02

OEMMODE_EXCLUDE ModeExclude = { 0, 0, 1 } ;                          // chu02


//---------------------------------------------------------------------------
//
// Function: Get Gamma factor
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS VgaGetGammaFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PGAMMA_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    )
{

    VP_STATUS status ;
    int       i      ;

    VideoDebugPrint((2, "VgaGetGammaFactor\n")) ;

    if ( ValueLength < (*OutputSize = sizeof(PGAMMA_VALUE)) )
        return ERROR_INSUFFICIENT_BUFFER;

    status = GetGammaKeyInfoFromReg(HwDeviceExtension) ;

    if (status == NO_ERROR)
    {
        for (i = 0; i < 4; i++) 
            value->value[i] = GammaInfo[i] ;
    }
    else if (status == ERROR_INVALID_PARAMETER)
    {
        //
        // If no subkey exists, we assign the default value.  Otherwise the
        // system would fail.
        //
        for (i = 0; i < 4; i++) 
            value->value[i] = 0x7f ; 
        status = NO_ERROR ; 
    }

    VideoDebugPrint((1, "Gamma value = %lx\n", *value)) ;

    return status ;

} // VgaGetGammaFactor


//---------------------------------------------------------------------------
//
// Function: Get Contrast factor
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS VgaGetContrastFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCONTRAST_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    )
{

    VP_STATUS status ;
    int       i      ;

    VideoDebugPrint((2, "VgaGetContrastFactor\n")) ;

    if ( ValueLength < (*OutputSize = sizeof(PCONTRAST_VALUE)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    status = GetContrastKeyInfoFromReg(HwDeviceExtension) ;

    if (status == NO_ERROR)
    {
        for (i = 0; i < 4; i++) 
            value->value[i] = GammaInfo[i] ;
    }
    else if (status == ERROR_INVALID_PARAMETER)
    {
        //
        // If no subkey exists, we assign the default value.  Otherwise the
        // system would fail.
        //
        for (i = 0; i < 4; i++) 
            value->value[i] = 0x80 ;
        status = NO_ERROR ; 
    }

    VideoDebugPrint((1, "Contrast value = %lx\n", *value)) ;
    return status ;


} // VgaGetContrastFactor


//---------------------------------------------------------------------------
//
// Function: Get Gamma Key information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS GetGammaKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{

    VP_STATUS status ;

    VideoDebugPrint((2, "GetGammaKeyInfoFromReg\n")) ;

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"G Gamma",
                                            FALSE,
                                            GetGammaCorrectInfoCallBack,
                                            NULL) ;
    if (status != NO_ERROR)
    {
        VideoDebugPrint((1, "Fail to access Gamma key info from registry\n"));
    }

    return status ;


} // GetGammaKeyInfoFromReg


//---------------------------------------------------------------------------
//
// Function: Get Contrast Key information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS GetContrastKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    VP_STATUS status ;
    VideoDebugPrint((2, "GetContrastKeyInfoFromReg\n")) ;

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"G Contrast",
                                            FALSE,
                                            GetGammaCorrectInfoCallBack,
                                            NULL) ;
    if (status != NO_ERROR)
    {
        VideoDebugPrint((1, "Fail to access Contrast key info from registry\n"));
    }
    return status ;

} // GetContrastKeyInfoFromReg


//---------------------------------------------------------------------------
//
// Function: Get Gamma coorrection information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful ; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS 
GetGammaCorrectInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )
/*++

Routine Description:
    This routine get the desired info from data registry.

Arguments:
    HwDeviceExtension - Supplies a pointer to the miniport's device extension.
    Context - Context value passed to the get registry paramters routine.
    ValueName - Name of the value requested.
    ValueData - Pointer to the requested data.
    ValueLength - Length of the requested data.

Return Value:
    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{
    VideoDebugPrint((2, "GetGammaCorrectInfoCallBack\n"));

    if (ValueLength == 0x04)
    {
        VideoPortMoveMemory (GammaInfo, ValueData, ValueLength) ;
        return NO_ERROR ;
    }
    else
    {
        return ERROR_INVALID_PARAMETER ;
    }

} // GetGammaCorrectInfoCallBack


//---------------------------------------------------------------------------
//
// Function:
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful ; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS
CirrusDDC2BRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    This routine determines if the alternate register set was requested via
    the registry.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Context - Context value passed to the get registry paramters routine.

    ValueName - Name of the value requested.

    ValueData - Pointer to the requested data.

    ValueLength - Length of the requested data.

Return Value:

    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{

    PULONG  pManuID = (PULONG)&EDIDBuffer[8];

    if (ValueLength &&
        ((*((PULONG)ValueData)) == *pManuID)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;

    }

} // CirrusDDC2BRegistryCallback


//---------------------------------------------------------------------------
//
// Function:
//     CirrusNonDDCRegistryCallback
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful ; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS
CirrusNonDDCRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    This routine determines if the alternate register set was requested via
    the registry.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Context - Context value passed to the get registry paramters routine.

    ValueName - Name of the value requested.

    ValueData - Pointer to the requested data.

    ValueLength - Length of the requested data.

Return Value:

    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{

    if(ValueLength && 
       ValueLength == 128 )
    {
        VideoPortMoveMemory(EDIDBuffer, ValueData, ValueLength);
        return NO_ERROR;
    }
    else
        return ERROR_INVALID_PARAMETER;

} // CirrusNonDDCRegistryCallback


//---------------------------------------------------------------------------
//
// Function:
//     Perform an IO operation during display enable.
//
// Input:
//     HwDeviceExtension - Pointer to the miniport driver's device extension.         
//
// Output: 
//     The routine always returns TRUE. 
//
//---------------------------------------------------------------------------
BOOLEAN
IOCallback(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    ULONG InputStatusReg;

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    //

    if (VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                MISC_OUTPUT_REG_READ_PORT) & 0x01)
        InputStatusReg = INPUT_STATUS_1_COLOR;
    else
        InputStatusReg = INPUT_STATUS_1_MONO;

    //
    // Guarantee that the display is in display mode
    //

    while (0x1 & VideoPortReadPortUchar(HwDeviceExtension->IOAddress
                                        + InputStatusReg));

    //
    // Perform the IO operation
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                             HwDeviceExtension->DEPort,
                             HwDeviceExtension->DEValue);

    return TRUE;

} // IOCallback


// chu02
//---------------------------------------------------------------------------
//
// Function: Get rid of one mode, specific to IBM only
//             - 1024x768x16bpp, 85Hz ( mode 0x74 )
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful ; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS 
GetOemModeOffInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )
/*++

Routine Description:
    This routine get the desired info from data registry.

Arguments:
    HwDeviceExtension - Supplies a pointer to the miniport's device extension.
    Context - Context value passed to the get registry paramters routine.
    ValueName - Name of the value requested.
    ValueData - Pointer to the requested data.
    ValueLength - Length of the requested data.

Return Value:
    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{
    VideoDebugPrint((2, "GetOemModeOffInfoCallBack\n"));

    if (ValueLength == 0x04)
    {
        VideoPortMoveMemory (ModesExclude, ValueData, ValueLength) ;
        ModeExclude.refresh = (UCHAR)ModesExclude[0] ;
        ModeExclude.mode    = (UCHAR)ModesExclude[1] ;
        return NO_ERROR ;
    }
    else
    {
        return ERROR_INVALID_PARAMETER ;
    }

} // GetOemModeOffInfoCallBack


//---------------------------------------------------------------------------
//
// Function:
//     Callback routine for the VideoPortGetDeviceData function.
//
// Input:
//    HwDeviceExtension - Pointer to the miniport drivers device extension.
//    Context - Context value passed to the VideoPortGetDeviceData function.
//    DeviceDataType - The type of data that was requested in
//        VideoPortGetDeviceData.
//    Identifier - Pointer to a string that contains the name of the device,
//        as setup by the ROM or ntdetect.
//    IdentifierLength - Length of the Identifier string.
//    ConfigurationData - Pointer to the configuration data for the device or
//        BUS.
//    ConfigurationDataLength - Length of the data in the configurationData
//        field.
//    ComponentInformation - Undefined.
//    ComponentInformationLength - Undefined.
//
// Output: 
//    Returns NO_ERROR if the function completed properly.
//    Returns ERROR_DEV_NOT_EXIST if we did not find the device.
//    Returns ERROR_INVALID_PARAMETER otherwise.
//
//---------------------------------------------------------------------------
VP_STATUS
CirrusGetDeviceDataCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    )

/*++

Routine Description:

    

Arguments:

    HwDeviceExtension - Pointer to the miniport drivers device extension.

    Context - Context value passed to the VideoPortGetDeviceData function.

    DeviceDataType - The type of data that was requested in
        VideoPortGetDeviceData.

    Identifier - Pointer to a string that contains the name of the device,
        as setup by the ROM or ntdetect.

    IdentifierLength - Length of the Identifier string.

    ConfigurationData - Pointer to the configuration data for the device or
        BUS.

    ConfigurationDataLength - Length of the data in the configurationData
        field.

    ComponentInformation - Undefined.

    ComponentInformationLength - Undefined.

Return Value:

    Returns NO_ERROR if the function completed properly.
    Returns ERROR_DEV_NOT_EXIST if we did not find the device.
    Returns ERROR_INVALID_PARAMETER otherwise.

--*/

{
    PWCHAR identifier = Identifier;
    PVIDEO_PORT_CONFIG_INFO ConfigInfo = (PVIDEO_PORT_CONFIG_INFO) Context;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    switch (DeviceDataType) {

        case VpMachineData:

            //
            // The caller assumes no-error mean that this machine was found, and
            // then memory mapped IO will be disabled.
            //
            // All other machine types must return an error.
            //

            if (VideoPortCompareMemory(L"TRICORDES",
                                       Identifier,
                                       sizeof(L"TRICORDES")) ==
                                       sizeof(L"TRICORDES"))
            {
                return NO_ERROR;
            }

            break;

        default:

            VideoDebugPrint((2, "Cirrus: callback has bad device type\n"));
    }

    return ERROR_INVALID_PARAMETER;

} // CirrusGetDeviceDataCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\disp\i386\hw.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: hw.inc
;
; All the hardware specific driver file stuff.  Mirrors some of 'hw.h'.
;
; Copyright (c) 1993-1994 Microsoft Corporation
;----------------------------------------------------------------------------;

;--------------------------------------------------------------------------
; Chip equates

STATUS_1                        equ 03DAh
VSY_NOT                         equ 08h

CRTC_INDEX                      equ 03D4h
CRTC_DATA                       equ 03D5h

S3R8                            equ 038h
S3R9                            equ 039h
S3R1                            equ 031h
S3R5                            equ 035h

CR39                            equ 039h
CR4C                            equ 04Ch
CR4D                            equ 04Dh

HGC_MODE                        equ 045h
HGC_ENABLE                      equ 001h
HGC_DISABLE                     equ 000h

HGC_ORGX_LSB                    equ 047h
HGC_ORGX_MSB                    equ 046h
HGC_ORGY_LSB                    equ 049h
HGC_ORGY_MSB                    equ 048h

HGC_DX                          equ 04Eh
HGC_DY                          equ 04Fh

REG_UNLOCK_1                    equ 048h
CPUA_BASE                       equ 001h

SYSCTL_UNLOCK                   equ 0A0h
SYSCTL_LOCK                     equ 000h

SYS_CNFG                        equ 040h
LAW_CTL                         equ 058h
EX_SCTL_2                       equ 051h
EX_DAC_CT                       equ 055h

MISC_1                          equ 03Ah

; Command types:

DRAW_LINE                       equ 02000h
RECTANGLE_FILL                  equ 04000h
BITBLT                          equ 0C000h
PATTERN_FILL                    equ 0E000h

BYTE_SWAP                       equ 01000h
BUS_SIZE_16                     equ 00200h
BUS_SIZE_8                      equ 00000h
WAIT_CPU                        equ 00100h

; Drawing directions (radial):

DRAWING_DIRECTION_0             equ 0000h
DRAWING_DIRECTION_45            equ 0020h
DRAWING_DIRECTION_90            equ 0040h
DRAWING_DIRECTION_135           equ 0060h
DRAWING_DIRECTION_180           equ 0080h
DRAWING_DIRECTION_225           equ 00A0h
DRAWING_DIRECTION_270           equ 00C0h
DRAWING_DIRECTION_315           equ 00E0h

; Drawing directions (x/y):

DRAWING_DIR_BTRLXM              equ 0000h
DRAWING_DIR_BTLRXM              equ 0020h
DRAWING_DIR_BTRLYM              equ 0040h
DRAWING_DIR_BTLRYM              equ 0060h
DRAWING_DIR_TBRLXM              equ 0080h
DRAWING_DIR_TBLRXM              equ 00A0h
DRAWING_DIR_TBRLYM              equ 00C0h
DRAWING_DIR_TBLRYM              equ 00E0h

; Drawing direction bits:

PLUS_X                          equ 0020h
PLUS_Y                          equ 0080h
MAJOR_Y                         equ 0040h

; Draw:

DRAW                            equ 0010h

; Direction type:

DIR_TYPE_RADIAL                 equ 0008h
DIR_TYPE_XY                     equ 0000h

; Last pixel:

LAST_PIXEL_OFF                  equ 0004h
LAST_PIXEL_ON                   equ 0000h

; Pixel mode:

MULTIPLE_PIXELS                 equ 0002h
SINGLE_PIXEL                    equ 0000h

; Read/write:

READ                            equ 0000h
WRITE                           equ 0001h

; Graphics processor status:

HARDWARE_BUSY                   equ 0200h
READ_DATA_AVAILABLE             equ 0100h
GP_ALL_EMPTY                    equ 0400h

; Fifo status in terms of empty entries:

FIFO_1_EMPTY                    equ 0080h
FIFO_2_EMPTY                    equ 0040h
FIFO_3_EMPTY                    equ 0020h
FIFO_4_EMPTY                    equ 0010h
FIFO_5_EMPTY                    equ 0008h
FIFO_6_EMPTY                    equ 0004h
FIFO_7_EMPTY                    equ 0002h
FIFO_8_EMPTY                    equ 0001h

; These are the defines for the multifunction control register.
; The 4 MSBs define the function of the register.

RECT_HEIGHT                     equ 00000h

CLIP_TOP                        equ 01000h
CLIP_LEFT                       equ 02000h
CLIP_BOTTOM                     equ 03000h
CLIP_RIGHT                      equ 04000h

DATA_EXTENSION                  equ 0A000h
MULT_MISC_INDEX                 equ 0E000h
READ_SEL_INDEX                  equ 0F000h

ALL_ONES                        equ 00000h
CPU_DATA                        equ 00080h
DISPLAY_MEMORY                  equ 000C0h

; Color source:

BACKGROUND_COLOR                equ 000h
FOREGROUND_COLOR                equ 020h
SRC_CPU_DATA                    equ 040h
SRC_DISPLAY_MEMORY              equ 060h

; Mix modes:

NOT_SCREEN                      equ 00h
LOGICAL_0                       equ 01h
LOGICAL_1                       equ 02h
LEAVE_ALONE                     equ 03h
NOT_NEW                         equ 04h
SCREEN_XOR_NEW                  equ 05h
NOT_SCREEN_XOR_NEW              equ 06h
OVERPAINT                       equ 07h
NOT_SCREEN_OR_NOT_NEW           equ 08h
SCREEN_OR_NOT_NEW               equ 09h
NOT_SCREEN_OR_NEW               equ 0Ah
SCREEN_OR_NEW                   equ 0Bh
SCREEN_AND_NEW                  equ 0Ch
NOT_SCREEN_AND_NEW              equ 0Dh
SCREEN_AND_NOT_NEW              equ 0Eh
NOT_SCREEN_AND_NOT_NEW          equ 0Fh

; When one of the following bits is set in a hardware mix, it means
; that a pattern is needed (i.e., is none of NOT_SCREEN, LOGICAL_0,
; LOGICAL_1 or LEAVE_ALONE):

MIX_NEEDSPATTERN                equ 0Ch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\cirrus.h ===
/*++

Copyright (c) 1992-1997 Microsoft Corporation
Copyright (c) 1996-1997 Cirrus Logic, Inc.,

Module Name:

    C    I    R    R    U    S  .  H

Abstract:

    This module contains the definitions for the code that implements the
    Cirrus Logic VGA 6410/6420/542x device driver.

Environment:

    Kernel mode

Revision History:
*  chu01   08-26-96 : Distinguish CL-5480 and CL-5436/46 because the former
*                     has new fratures such as XY-clipping, XY-position and
*                     BLT command list that the others do not have.
*  sge01  10-14-96 : Add PC97 Compliant support.
*
*  sge02  10-24-96 : Add second aperture flag.
*
*  sge03  10-29-96 : Merge port access and register access for VGA relocatable and MMIO registers.
*  chu02  12-16-96 : Enable color correct.
*
* myf0 : 08-19-96  added 85hz supported
* myf1 : 08-20-96  supported panning scrolling
* myf2 : 08-20-96 : fixed hardware save/restore state bug for matterhorn
* myf3 : 09-01-96 : Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4 : 09-01-96 : patch Viking BIOS bug, PDR #4287, begin
* myf5 : 09-01-96 : Fixed PDR #4365 keep all default refresh rate
* myf6 : 09-17-96 : Merged Desktop SRC1001 & MINI102
* myf7 : 09-19-96 : Fixed exclude 60Hz refresh rate selected
* myf8 :*09-21-96*: May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9 : 09-21-96 : 8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809:09-25-96 : fixed dstn panel icon corrupted
* ms923 :09-25-96 : merge MS-923 Disp.zip code
* myf10 :09-26-96 : Fixed DSTN reserved half-frame buffer bug.
* myf11 :09-26-96 : Fixed 755x CE chip HW bug, access ramdac before disable HW
*                   icons and cursor
* myf12 :10-01-96 : Supported Hot Key switch display
* myf13 :10-02-96 : Fixed Panning scrolling (1280x1024x256) bug y < ppdev->miny
* myf14 :10-15-96 : Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15 :10-16-96 : Fixed disable memory mapped IO for 754x, 755x
* myf16 :10-22-96 : Fixed PDR #6933,panel type set different demo board setting
* tao1 : 10-21-96 : added CAPS_IS_7555 flag for direct draw support.
* smith :10-22-96 : Disable Timer event, because sometimes creat PAGE_FAULT or
*                   IRQ level can't handle
* myf17 :11-04-96 : Added special escape code must be use 11/5/96 later NTCTRL,
*                   and added Matterhorn LF Device ID==0x4C
* myf18 :11-04-96 : Fixed PDR #7075,
* myf19 :11-06-96 : Fixed Vinking can't work problem, because DEVICEID = 0x30
*                   is different from data book (CR27=0x2C)
* myf20 :11-12-96 : Fixed DSTN panel initial reserved 128K memoru
* myf21 :11-15-96 : fixed #7495 during change resolution, screen appear garbage
*                   image, because not clear video memory.
* myf22 :11-19-96 : Added 640x480x256/640x480x64K -85Hz refresh rate for 7548
* myf23 :11-21-96 : Added fixed NT 3.51 S/W cursor panning problem
* myf24 :11-22-96 : Added fixed NT 4.0 Japanese dos full screen problem
* myf25 :12-03-96 : Fixed 8x6x16M 2560byte/line patch H/W bug PDR#7843, and
*                   fixed pre-install microsoft requested
* myf26 :12-11-96 : Fixed Japanese NT 4.0 Dos-full screen bug for LCD enable
* myf27 :01-09-96 : Fixed NT3.51 PDR#7986, horizontal lines appears at logon
*                   windows, set 8x6x64K mode boot up CRT, jumper set 8x6 DSTN
*                   Fixed NT3.51 PDR#7987, set 64K color modes, garbage on
*                   screen when boot up XGA panel.
* sge04  01-23-96 : Add CL5446_ID and CL5480_ID.
* myf33 :03-21-97 : Support TV ON/OFF
* chu03  03-26-97 : Get rid of 1024x768x16bpp ( Mode 0x74 ) 85H for IBM only.
*
--*/



#define INT10_MODE_SET

//
// Do full save and restore.
//

#define EXTENDED_REGISTER_SAVE_RESTORE 1

//
// Banking ifdefs to enable banking
// the banking type MUST match the type in clhard.asm
//

#define ONE_64K_BANK             0
#define TWO_32K_BANKS            1
#define MULTIPLE_REFRESH_TABLES  0

//crus
//myf17  #define PANNING_SCROLL          //myf1

//
// Treat CL-GD5434_6 (rev 0xHH) as CL-GD5434 if requested.
//

#define CL5434_6_SPECIAL_REQUEST 0

//---------------------------------------------------------------------------
//
// only one banking variable must be defined
//
#if TWO_32K_BANKS
#if ONE_64K_BANK
#error !!ERROR: two types of banking defined!
#endif
#elif ONE_64K_BANK
#else
#error !!ERROR: banking type must be defined!
#endif

//
// Enable P6 Cache support
//

#define P6CACHE 1

//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

#define MEM_LINEAR      0x0
#define MEM_LINEAR_SIZE 0x0

// #ifdef _ALPHA_
//
//     #define PHY_AD_20_23 0x060       // Value for SR7 to map video memory
//     #define PHY_VGA      0x0600000   // put it at 6 megabytes for Alpha (for now)
//     #define PHY_VGA_SIZE 0x0100000   // allocate a megabyte of space there
//
// #endif
//

//
// For memory mapped IO
//

#define MEMORY_MAPPED_IO_OFFSET (0xB8000 - 0xA0000)
#define RELOCATABLE_MEMORY_MAPPED_IO_OFFSET 0x100

//
// Port definitions for filling the ACCESS_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//

#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF

//
// VGA register definitions
//

#define CRTC_ADDRESS_PORT_MONO      0x03B4  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x03B5  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x03BA  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x03BA  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data
#define ATT_ADDRESS_PORT            0x03C0  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x03C0  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x010
#define ATT_DATA_READ_PORT          0x03C1  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x03C2  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x03C2  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x03C3  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x03C4  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x03C5  // Data registers
#define DAC_PIXEL_MASK_PORT         0x03C6  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x03C7  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x03C7  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x03C8  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x03C9  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x03CA  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x03CC  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x03CE  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x03CF  // and Data registers

                                            // ports in color mode
#define CRTC_ADDRESS_PORT_COLOR     0x03D4  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x03D5  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x03DA  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x03DA  // Input Status 1 register read
                                            // port in color mode

#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode
//
// Offsets in HardwareStateHeader->PortValue[] of save areas for non-indexed
// VGA registers.
//

#define CRTC_ADDRESS_MONO_OFFSET      0x04
#define FEAT_CTRL_WRITE_MONO_OFFSET   0x0A
#define ATT_ADDRESS_OFFSET            0x10
#define MISC_OUTPUT_REG_WRITE_OFFSET  0x12
#define VIDEO_SUBSYSTEM_ENABLE_OFFSET 0x13
#define SEQ_ADDRESS_OFFSET            0x14
#define DAC_PIXEL_MASK_OFFSET         0x16
#define DAC_STATE_OFFSET              0x17
#define DAC_ADDRESS_WRITE_OFFSET      0x18
#define GRAPH_ADDRESS_OFFSET          0x1E
#define CRTC_ADDRESS_COLOR_OFFSET     0x24
#define FEAT_CTRL_WRITE_COLOR_OFFSET  0x2A

                                            // toggle in color mode
//
// VGA indexed register indexes.
//

// CL-GD542x specific registers:
//
#define IND_CL_EXTS_ENB         0x06    // index in Sequencer to enable exts
#define IND_NORD_SCRATCH_PAD    0x09    // index in Seq of Nordic scratch pad
#define IND_CL_SCRATCH_PAD      0x0A    // index in Seq of 542x scratch pad
#define IND_ALP_SCRATCH_PAD     0x15    // index in Seq of Alpine scratch pad
#define IND_CL_REV_REG          0x25    // index in CRTC of ID Register
#define IND_CL_ID_REG           0x27    // index in CRTC of ID Register
//
#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_CR2C                0x2C    // Nordic LCD Interface Register
#define IND_CR2D                0x2D    // Nordic LCD Display Control
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC
#define IND_CRTC_COMPAT         0x34    // index of CRTC Compatibility reg
                                        //  in CRTC
#define IND_PERF_TUNING         0x16    // index of performance tuning in Seq
#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

//
// Value to write to Extensions Control register values extensions.
//

#define CL64xx_EXTENSION_ENABLE_INDEX     0x0A     // GR0A to be exact!
#define CL64xx_EXTENSION_ENABLE_VALUE     0xEC
#define CL64xx_EXTENSION_DISABLE_VALUE    0xCE
#define CL64xx_TRISTATE_CONTROL_REG       0xA1

#define CL6340_ENABLE_READBACK_REGISTER   0xE0
#define CL6340_ENABLE_READBACK_ALLSEL_VALUE 0xF0
#define CL6340_ENABLE_READBACK_OFF_VALUE  0x00
#define CL6340_IDENTIFICATION_REGISTER    0xE9
//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

#define INDEX_ENABLE_AUTO_START 0x31

// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00


//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F


//
// Indices for type of memory mapping; used in ModesVGA[], must match
// MemoryMap[].
//

typedef enum _VIDEO_MEMORY_MAP {
    MemMap_Mono,
    MemMap_CGA,
    MemMap_VGA
} VIDEO_MEMORY_MAP, *PVIDEO_MEMORY_MAP;

//
// Memory map table definition
//

typedef struct {
    ULONG   MaxSize;        // Maximum addressable size of memory
    ULONG   Offset;         // Start address of display memory
} MEMORYMAPS;

//
// For a mode, the type of banking supported. Controls the information
// returned in VIDEO_BANK_SELECT. PlanarHCBanking includes NormalBanking.
//

typedef enum _BANK_TYPE {
    NoBanking = 0,
    NormalBanking,
    PlanarHCBanking
} BANK_TYPE, *PBANK_TYPE;


//
// Define type of cirrus boards
//

typedef enum _BOARD_TYPE {
    SPEEDSTARPRO = 1,
    SIEMENS_ONBOARD_CIRRUS,
    NEC_ONBOARD_CIRRUS,
    OTHER
} BOARD_TYPE;


//
// The chip ID is returned to the display driver in the
// DriverSpecificAttributeFlags field during processing of
// the IOCTL_VIDEO_QUERY_CURRENT_MODE.
//

#define  CL6410       0x0001
#define  CL6420       0x0002
#define  CL542x       0x0004
#define  CL543x       0x0008
#define  CL5434       0x0010
#define  CL5434_6     0x0020
#define  CL5446BE     0x0040

#define  CL5436       0x0100
#define  CL5446       0x0200
#define  CL54UM36     0x0400
//crus
#define  CL5480       0x0800

//myf32 begin
//#define  CL754x       0x1000
//#define  CL755x       0x2000
#define  CL7541       0x1000
#define  CL7542       0x2000
#define  CL7543       0x4000
#define  CL7548       0x8000
#define  CL754x       (CL7541 | CL7542 | CL7543 | CL7548)
#define  CL7555       0x10000
#define  CL7556       0x20000
#define  CL755x       (CL7555 | CL7556)
#define  CL756x       0x40000
// crus
#define  CL6245       0x80000
//myf32 end
//
// Actual Revision IDs for certain cirrus chips
//

#define  CL5429_ID    0x27
#define  CL5428_ID    0x26
#define  CL5430_ID    0x28
#define  CL5434_ID    0x2A
#define  CL5436_ID    0x2B
//sge04
#define  CL5446_ID    0x2E
#define  CL5480_ID    0x2F
//myf32 begin
#define  CL7542_ID    0x2C
#define  CL7541_ID    0x34
#define  CL7543_ID    0x30
#define  CL7548_ID    0x38
#define  CL7555_ID    0x40
#define  CL7556_ID    0x4C

//#define  CHIP754X     (CL7541_ID | CL7542_ID | CL7543_ID | CL7548_ID)
//#define  CHIP755X     (CL7555_ID | CL7556_ID)
//myf32 end

//
// Driver Specific Attribute Flags
//

#define CAPS_NO_HOST_XFER       0x00000002   // Do not use host xfers to
                                             //   the blt engine.
#define CAPS_SW_POINTER         0x00000004   // Use software pointer.
#define CAPS_TRUE_COLOR         0x00000008   // Set upper color registers.
#define CAPS_MM_IO              0x00000010   // Use memory mapped IO.
#define CAPS_BLT_SUPPORT        0x00000020   // BLTs are supported
#define CAPS_IS_542x            0x00000040   // This is a 542x
#define CAPS_AUTOSTART          0x00000080   // Autostart feature support.
#define CAPS_CURSOR_VERT_EXP    0x00000100   // Flag set if 8x6 panel,
#define CAPS_DSTN_PANEL         0x00000200   // DSTN panel in use, ms0809.
#define CAPS_VIDEO              0x00000400   // Video support.
#define CAPS_SECOND_APERTURE    0x00000800   // Second aperture support.
#define CAPS_COMMAND_LIST       0x00001000   // Command List support.
#define CAPS_GAMMA_CORRECT      0x00002000   // Color correction
#define CAPS_VGA_PANEL          0x00004000   // use 6x4 VGA PANEL.
#define CAPS_SVGA_PANEL         0x00008000   // use 8x6 SVGA PANEL.
#define CAPS_XGA_PANEL          0x00010000   // use 10x7 XGA PANEL.
#define CAPS_PANNING            0x00020000   // Panning scrolling supported.
#define CAPS_TV_ON              0x00040000   // TV turn on supported., myf33
#define CAPS_TRANSPARENCY       0x00080000   // Transparency is supported
#define CAPS_ENGINEMANAGED      0x00100000   // Engine managed surface
//myf16, end
//crus end


// bitfields for the DisplayType
#define  crt      0x0001
#define  panel    0x0002

#define  panel8x6  0x0004
#define  panel10x7 0x0008

#define  TFT_LCD   0x0100
#define  STN_LCD   0x0200
#define  Mono_LCD   0x0400
#define  Color_LCD   0x0800
#define  Single_LCD   0x1000
#define  Dual_LCD   0x2000
#define  Jump_type   0x8000    //myf27

//crus
#define DefaultMode 0x9         //myf19: 11-07-96 if panel can't support mode,
                                //      use 640x480x256c(0x5F) replace.
//
// Indexes into array of mode table pointers
//

#define pCL6410_crt   0
#define pCL6410_panel 1
#define pCL6420_crt   2
#define pCL6420_panel 3
#define pCL542x       4
#define pCL543x       5
#define pStretchScan  6
#define pNEC_CL543x   7
#define NUM_CHIPTYPES 8

typedef struct {
    USHORT BiosModeCL6410;       // bios modes are different across the
    USHORT BiosModeCL6420;       // products. that's why we need multiple
    USHORT BiosModeCL542x;       // values.
} CLMODE, *PCLMODE;

//
// Structure used to describe each video mode in ModesVGA[].
//

typedef struct {
    USHORT  fbType; // color or monochrome, text or graphics, via
                    //  VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
    USHORT  numPlanes;    // # of video memory planes
    USHORT  bitsPerPlane; // # of bits of color in each plane
    SHORT   col;    // # of text columns across screen with default font
    SHORT   row;    // # of text rows down screen with default font
    USHORT  hres;   // # of pixels across screen
    USHORT  vres;   // # of scan lines down screen
    USHORT  wbytes; // # of bytes from start of one scan line to start of next
    ULONG   sbytes; // total size of addressable display memory in bytes
    ULONG   Frequency;         // Vertical Frequency
    ULONG   Interlaced;        // Determines if the mode is interlaced or not
    ULONG   MonitorType;       // Sets the desired vertical freq in an int10
    ULONG   MonTypeAX;         // Sets the desired horizontal freq in an int10
    ULONG   MonTypeBX;
    ULONG   MonTypeCX;
    BOOLEAN HWCursorEnable;    // Flag to disable cursor if necessary
    BANK_TYPE banktype;        // NoBanking, NormalBanking, PlanarHCBanking
    VIDEO_MEMORY_MAP   MemMap; // index from VIDEO_MEMORY_MAP of memory
                               //  mapping used by this mode
    ULONG      ChipType;       // flags that say which chipset runs this mode
                               //myf32 change USHORT to ULONG
    USHORT     DisplayType;    // display type this mode runs on(crt or panel)
    BOOLEAN    ValidMode;      // TRUE if mode valid, FALSE if not
    BOOLEAN    LinearSupport;  // TRUE if this mode can have its memory
                               //  mapped in linearly.

    CLMODE     BiosModes;

//
// the mode will be TRUE if there is enough video memory to support the
// mode, and the display type(it could be a panel), will support the mode.
// PANELS only support 640x480 for now.
//
    PUSHORT CmdStrings[NUM_CHIPTYPES];   // pointer to array of register-setting commands to
                                         //  set up mode
} VIDEOMODE, *PVIDEOMODE;

//
// Mode into which to put the VGA before starting a VDM, so it's a plain
// vanilla VGA.  (This is the mode's index in ModesVGA[], currently standard
// 80x25 text mode.)
//

#define DEFAULT_MODE 0

//crus, begin
//myf1, begin
#ifdef  PANNING_SCROLL
typedef struct {
    USHORT  Hres;
    USHORT  Vres;
    USHORT  BitsPerPlane;
    USHORT  ModesVgaStart;
    USHORT  Mode;
} RESTABLE, *PRESTABLE;

typedef struct {
    USHORT  hres;
    USHORT  vres;
    USHORT  wbytes;
    USHORT  bpp;
     SHORT  flag;
} PANNMODE;

USHORT ViewPoint_Mode = 0x5F;
#endif


UCHAR  HWcur, HWicon0, HWicon1, HWicon2, HWicon3;    //myf11
//myf1, end
//crus, end


//
// Info used by the Validator functions and save/restore code.
// Structure used to trap register accesses that must be done atomically.
//

#define VGA_MAX_VALIDATOR_DATA             100

#define VGA_VALIDATOR_UCHAR_ACCESS   1
#define VGA_VALIDATOR_USHORT_ACCESS  2
#define VGA_VALIDATOR_ULONG_ACCESS   3

typedef struct _VGA_VALIDATOR_DATA {
   ULONG Port;
   UCHAR AccessType;
   ULONG Data;
} VGA_VALIDATOR_DATA, *PVGA_VALIDATOR_DATA;

//
// Number of bytes to save in each plane.
//

#define VGA_PLANE_SIZE 0x10000

//
// Number of each type of indexed register in a standard VGA, used by
// validator and state save/restore functions.
//
// Note: VDMs currently only support basic VGAs only.
//

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

//
// Indices to start save/restore in extension registers:
// For both chip types

#define CL64xx_GRAPH_EXT_START          0x0b  // does not include ext. enable
#define CL64xx_GRAPH_EXT_END            0xFF

#define CL542x_GRAPH_EXT_START          0x09
#define CL542x_GRAPH_EXT_END            0x39
#define CL542x_SEQUENCER_EXT_START      0x07  // does not include ext. enable
#define CL542x_SEQUENCER_EXT_END        0x1F
#define CL542x_CRTC_EXT_START           0x19
#define CL542x_CRTC_EXT_END             0x1B

//
// Number of extended regs for both chip types
//

#define CL64xx_NUM_GRAPH_EXT_PORTS     (CL64xx_GRAPH_EXT_END - CL64xx_GRAPH_EXT_START + 1)

#define CL542x_NUM_GRAPH_EXT_PORTS     (CL542x_GRAPH_EXT_END - CL542x_GRAPH_EXT_START + 1)
#define CL542x_NUM_SEQUENCER_EXT_PORTS (CL542x_SEQUENCER_EXT_END - CL542x_SEQUENCER_EXT_START + 1)
#define CL542x_NUM_CRTC_EXT_PORTS      (CL542x_CRTC_EXT_END - CL542x_CRTC_EXT_START + 1)

//
// set values for save/restore area based on largest value for a chipset.
//

#define EXT_NUM_GRAPH_CONT_PORTS    ((CL64xx_NUM_GRAPH_EXT_PORTS >   \
                                     CL542x_NUM_GRAPH_EXT_PORTS) ?   \
                                     CL64xx_NUM_GRAPH_EXT_PORTS :    \
                                     CL542x_NUM_GRAPH_EXT_PORTS)
#define EXT_NUM_SEQUENCER_PORTS     CL542x_NUM_SEQUENCER_EXT_PORTS
#define EXT_NUM_CRTC_PORTS          CL542x_NUM_CRTC_EXT_PORTS
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

#else

#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_SEQUENCER_PORTS     0
#define EXT_NUM_CRTC_PORTS          0
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

#endif

//
// These constants determine the offsets within the
// VIDEO_HARDWARE_STATE_HEADER structure that are used to save and
// restore the VGA's state.
//

#define VGA_HARDWARE_STATE_SIZE sizeof(VIDEO_HARDWARE_STATE_HEADER)

#define VGA_BASIC_SEQUENCER_OFFSET (VGA_HARDWARE_STATE_SIZE + 0)
#define VGA_BASIC_CRTC_OFFSET (VGA_BASIC_SEQUENCER_OFFSET + \
         VGA_NUM_SEQUENCER_PORTS)
#define VGA_BASIC_GRAPH_CONT_OFFSET (VGA_BASIC_CRTC_OFFSET + \
         VGA_NUM_CRTC_PORTS)
#define VGA_BASIC_ATTRIB_CONT_OFFSET (VGA_BASIC_GRAPH_CONT_OFFSET + \
         VGA_NUM_GRAPH_CONT_PORTS)
#define VGA_BASIC_DAC_OFFSET (VGA_BASIC_ATTRIB_CONT_OFFSET + \
         VGA_NUM_ATTRIB_CONT_PORTS)
#define VGA_BASIC_LATCHES_OFFSET (VGA_BASIC_DAC_OFFSET + \
         (3 * VGA_NUM_DAC_ENTRIES))

#define VGA_EXT_SEQUENCER_OFFSET (VGA_BASIC_LATCHES_OFFSET + 4)
#define VGA_EXT_CRTC_OFFSET (VGA_EXT_SEQUENCER_OFFSET + \
         EXT_NUM_SEQUENCER_PORTS)
#define VGA_EXT_GRAPH_CONT_OFFSET (VGA_EXT_CRTC_OFFSET + \
         EXT_NUM_CRTC_PORTS)
#define VGA_EXT_ATTRIB_CONT_OFFSET (VGA_EXT_GRAPH_CONT_OFFSET +\
         EXT_NUM_GRAPH_CONT_PORTS)
#define VGA_EXT_DAC_OFFSET (VGA_EXT_ATTRIB_CONT_OFFSET + \
         EXT_NUM_ATTRIB_CONT_PORTS)

#define VGA_VALIDATOR_OFFSET (VGA_EXT_DAC_OFFSET + 4 * EXT_NUM_DAC_ENTRIES)

#define VGA_VALIDATOR_AREA_SIZE  sizeof (ULONG) + (VGA_MAX_VALIDATOR_DATA * \
                                 sizeof (VGA_VALIDATOR_DATA)) +             \
                                 sizeof (ULONG) +                           \
                                 sizeof (ULONG) +                           \
                                 sizeof (PVIDEO_ACCESS_RANGE)

#define VGA_MISC_DATA_AREA_OFFSET VGA_VALIDATOR_OFFSET + VGA_VALIDATOR_AREA_SIZE

#define VGA_MISC_DATA_AREA_SIZE  0

#define VGA_PLANE_0_OFFSET VGA_MISC_DATA_AREA_OFFSET + VGA_MISC_DATA_AREA_SIZE

#define VGA_PLANE_1_OFFSET VGA_PLANE_0_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_2_OFFSET VGA_PLANE_1_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_3_OFFSET VGA_PLANE_2_OFFSET + VGA_PLANE_SIZE

//
// Space needed to store all state data.
//

#define VGA_TOTAL_STATE_SIZE VGA_PLANE_3_OFFSET + VGA_PLANE_SIZE

//
// Merge port and register access for VGA relocatable and MMIO registers
//
// sge03
typedef VIDEOPORT_API UCHAR     (*FnVideoPortReadPortUchar)(PUCHAR Port);
typedef VIDEOPORT_API USHORT    (*FnVideoPortReadPortUshort)(PUSHORT Port);
typedef VIDEOPORT_API ULONG     (*FnVideoPortReadPortUlong)(PULONG Port);
typedef VIDEOPORT_API VOID      (*FnVideoPortWritePortUchar)(PUCHAR Port, UCHAR Value);
typedef VIDEOPORT_API VOID      (*FnVideoPortWritePortUshort)(PUSHORT Port, USHORT Value);
typedef VIDEOPORT_API VOID      (*FnVideoPortWritePortUlong)(PULONG Port, ULONG Value);

typedef struct  _PORT_READ_WRITE_FUNTION_TABLE
{
    FnVideoPortReadPortUchar     pfnVideoPortReadPortUchar;
    FnVideoPortReadPortUshort    pfnVideoPortReadPortUshort;
    FnVideoPortReadPortUlong     pfnVideoPortReadPortUlong;
    FnVideoPortWritePortUchar    pfnVideoPortWritePortUchar;
    FnVideoPortWritePortUshort   pfnVideoPortWritePortUshort;
    FnVideoPortWritePortUlong    pfnVideoPortWritePortUlong;
} PORT_READ_WRITE_FUNTION_TABLE;



//
// Device extension for the driver object.  This data is only used
// locally, so this structure can be added to as needed.
//

typedef struct _HW_DEVICE_EXTENSION {

    PHYSICAL_ADDRESS PhysicalVideoMemoryBase; // physical memory address and
    PHYSICAL_ADDRESS PhysicalFrameOffset;     // physical memory address and
    ULONG PhysicalVideoMemoryLength;          // length of display memory
    ULONG PhysicalFrameLength;                // length of display memory for
                                              // the current mode.

    PUCHAR  IOAddress;            // base I/O address of VGA ports
    PUCHAR  VideoMemoryAddress;   // base virtual memory address of VGA memory
    ULONG   NumAvailableModes;    // number of available modes this session
    ULONG   ModeIndex;            // index of current mode in ModesVGA[]
    PVIDEOMODE  CurrentMode;      // pointer to VIDEOMODE structure for
                                  // current mode

    USHORT  FontPelColumns;          // Width of the font in pels
    USHORT  FontPelRows;          // height of the font in pels

    USHORT  cursor_vert_exp_flag;

    VIDEO_CURSOR_POSITION CursorPosition;  // current cursor position


    UCHAR CursorEnable;           // whether cursor is enabled or not
    UCHAR CursorTopScanLine;      // Cursor Start register setting (top scan)
    UCHAR CursorBottomScanLine;   // Cursor End register setting (bottom scan)

// add HW cursor data here
    BOOLEAN VideoPointerEnabled;  // Whether HW Cursor is supported

    ULONG  ChipType;              // CL6410, CL6420, CL542x, or CL543x
                               //myf32 change USHORT to ULONG
    USHORT ChipRevision;                  // chip revision value
    INTERFACE_TYPE BusType;               // isa, pci, etc.
    USHORT DisplayType;                   // crt, panel or panel8x6
    USHORT BoardType;                     // Diamond, etc ...
    WCHAR LegacyPnPId[8];                 // legacy PnP ID
    ULONG AdapterMemorySize;              // amount of installed video ram
    BOOLEAN LinearMode;                   // TRUE if memory is mapped linear
    BOOLEAN BiosGT130;                    // Do we have a 1.30 or higher bios
    BOOLEAN BIOSPresent;                  // Indicates whether a bios is present
    BOOLEAN AutoFeature;                  // Autostart on 54x6

// crus
    BOOLEAN BitBLTEnhance;                // BitBLT enhancement includes
                                          //  XY-position, XY-clipping and
                                          //  command list in off-screen memory
                                          //  For CL-GD5480, it is TRUE,
                                          //  otherwise, it is FALSE.

    //
    // The following two values are used to pass information to the
    // IO Callback called by IOWaitDisplEnableThenWrite.
    //

    ULONG DEPort;                         // stores the port address to write to
    UCHAR DEValue;                        // stores the value to write

    //
    // These 4 fields must be at the end of the device extension and must be
    // kept in this order since this data will be copied to and from the save
    // state buffer that is passed to and from the VDM.
    //

    ULONG TrappedValidatorCount;   // number of entries in the Trapped
                                   // validator data Array.
    VGA_VALIDATOR_DATA TrappedValidatorData[VGA_MAX_VALIDATOR_DATA];
                                   // Data trapped by the validator routines
                                   // but not yet played back into the VGA
                                   // register.

    ULONG SequencerAddressValue;   // Determines if the Sequencer Address Port
                                   // is currently selecting the SyncReset data
                                   // register.

    ULONG CurrentNumVdmAccessRanges;           // Number of access ranges in
                                               // the access range array pointed
                                               // to by the next field
    PVIDEO_ACCESS_RANGE CurrentVdmAccessRange; // Access range currently
                                               // associated to the VDM
//  sge01 PC97 Compliant
    ULONG ulBIOSVersionNumber;                 // BIOS version number.

    BOOLEAN bMMAddress;                        // VGA register MMIO

    BOOLEAN bSecondAperture;                   // TRUE if chips have second apterture
                                               // else FALSE, sge02
//crus, begin
//myf12, for hoy-key support
    SHORT       bBlockSwitch;   //display switch block flag     //myf12
    SHORT       bDisplaytype;   //display type, 0:LCD, 1:CRT, 2:SIM  //myf12
    ULONG       bCurrentMode;   //Current Mode
//crus end

    PORT_READ_WRITE_FUNTION_TABLE gPortRWfn;

    ULONG       PMCapability;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


//
// Function prototypes.
//

//
// Entry points for the VGA validator. Used in VgaEmulatorAccessEntries[].
//

VP_STATUS
VgaValidatorUcharEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

VP_STATUS
VgaValidatorUshortEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

VP_STATUS
VgaValidatorUlongEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

BOOLEAN
VgaPlaybackValidatorData (
    PVOID Context
    );

#ifdef _X86_

//
// Bank switch code start and end labels, defined in CLHARD.ASM
//
// three versions for Cirrus Logic products
//

extern UCHAR CL64xxBankSwitchStart;
extern UCHAR CL64xxBankSwitchEnd;
extern UCHAR CL64xxPlanarHCBankSwitchStart;
extern UCHAR CL64xxPlanarHCBankSwitchEnd;
extern UCHAR CL64xxEnablePlanarHCStart;
extern UCHAR CL64xxEnablePlanarHCEnd;
extern UCHAR CL64xxDisablePlanarHCStart;
extern UCHAR CL64xxDisablePlanarHCEnd;

extern UCHAR CL542xBankSwitchStart;
extern UCHAR CL542xBankSwitchEnd;
extern UCHAR CL542xPlanarHCBankSwitchStart;
extern UCHAR CL542xPlanarHCBankSwitchEnd;
extern UCHAR CL542xEnablePlanarHCStart;
extern UCHAR CL542xEnablePlanarHCEnd;
extern UCHAR CL542xDisablePlanarHCStart;
extern UCHAR CL542xDisablePlanarHCEnd;

extern UCHAR CL543xBankSwitchStart;
extern UCHAR CL543xBankSwitchEnd;
extern UCHAR CL543xPlanarHCBankSwitchStart;
extern UCHAR CL543xPlanarHCBankSwitchEnd;

#endif

//
// Vga init scripts for font loading
//

extern USHORT EnableA000Data[];
extern USHORT DisableA000Color[];

//
// Mode Information
//

extern MEMORYMAPS MemoryMaps[];
extern ULONG NumVideoModes;
extern VIDEOMODE ModesVGA[];

//crus, begin
//myf1, begin
#ifdef PANNING_SCROLL
extern RESTABLE ResolutionTable[];
extern PANNMODE PanningMode;
extern USHORT   ViewPoint_Mode;

#endif

extern SHORT    Panning_flag;
//myf1, end
//crus, end

#define NUM_VGA_ACCESS_RANGES  5
extern VIDEO_ACCESS_RANGE VgaAccessRange[];

#define VGA_NUM_EMULATOR_ACCESS_ENTRIES     6
extern EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[];

#define NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE 4
extern VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[];

#define NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE 2
extern VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[];

//
// sr754x (NORDIC) prototypes
//

VP_STATUS
NordicSaveRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT NordicSaveArea
    );

VP_STATUS
NordicRestoreRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT NordicSaveArea
    );

#define VideoPortReadPortUchar(Port)            HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUchar(Port)
#define VideoPortReadPortUshort(Port)           HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUshort(Port)
#define VideoPortReadPortUlong(Port)            HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUlong(Port)
#define VideoPortWritePortUchar(Port, Value)    HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUchar(Port, Value)
#define VideoPortWritePortUshort(Port, Value)   HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUshort(Port, Value)
#define VideoPortWritePortUlong(Port, Value)    HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUlong(Port, Value)

typedef struct _PGAMMA_VALUE                                         // chu02
{
    UCHAR value[4] ;

} GAMMA_VALUE, *PGAMMA_VALUE, *PCONTRAST_VALUE ;

ULONG
GetAttributeFlags(
    PHW_DEVICE_EXTENSION HwDeviceExtension
);

typedef struct _POEMMODE_EXCLUDE                                     // chu03
{
    UCHAR    mode          ;
    UCHAR    refresh       ;
    BOOLEAN  NeverAccessed ;

} OEMMODE_EXCLUDE, *PMODE_EXCLUDE ;


//
// New NT 5.0 Functions
//

ULONG
CirrusGetChildDescriptor(
    PVOID pHwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );

VP_STATUS
CirrusGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

VP_STATUS
CirrusSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

#define VESA_POWER_FUNCTION 0x4f10
#define VESA_POWER_ON       0x0000
#define VESA_POWER_STANDBY  0x0100
#define VESA_POWER_SUSPEND  0x0200
#define VESA_POWER_OFF      0x0400
#define VESA_GET_POWER_FUNC 0x0000
#define VESA_SET_POWER_FUNC 0x0001
#define VESA_STATUS_SUCCESS 0x004f
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\clddc2b.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clddc2b.c

Abstract:
    
    This module checks for a DDC monitor, and returns the 
    established Timings value from the EDID if found.

Environment:

    Kernel mode only

Notes:

Revision History:

  * plc3  10-23-95  VESA DDC2B support.
  *
  * sge01 09-25-96  Non DDC Moniotr table support
  *
  * sge02 10-14-96  Detailed timing calculation in EDID
  *
  * sge03 12-05-96  Only check active pixel clock in detailed timing.
  *
--*/
//---------------------------------------------------------------------------
                                                       
#include <dderror.h>
#include <devioctl.h>                           
#include <miniport.h>
                                                        
#include <ntddvdeo.h>                        
#include <video.h>
#include "cirrus.h"

#define ERROR              0

#define OFF                0
#define ON                 1

#define SDA_BIT            2
#define SCL_BIT            1
#define SCL_BIT_ON         1
#define SCL_BIT_OFF        0

#define DELAY_COUNT            255

UCHAR WaitCount ;
UCHAR Err ;

VOID ReadVESATiming(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   

VOID EnableDDC(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN IsDDC2(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
VOID DisableDDC(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
VOID StartDDC(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
VOID StopDDC(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
VOID ProcessDDC2(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );     
                                               
BOOLEAN ReadSDA(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN ReadSCL(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN ReadBit(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN ReadByte(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );
                                                    
VOID SetSCL(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR status
    );
                                                   
VOID SetData(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN SetClock(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );
                                                    
VOID WaitVerticalRetrace(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR count
    );                                                   

VOID WaitDelay(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
VOID ClearData(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN SendByte(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR data
    );                                                   

BOOLEAN SendDDCCommand(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN
CheckDDC2BMonitor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    );

ULONG
CalculateMaxinumTiming(
    );

VOID ProcessNonDDC(
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    );

VP_STATUS
CirrusNonDDCRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

#if defined(ALLOC_PRAGMA)               
#pragma alloc_text (PAGE,ReadVESATiming)
#pragma alloc_text (PAGE,EnableDDC)
#pragma alloc_text (PAGE,IsDDC2)
#pragma alloc_text (PAGE,DisableDDC)
#pragma alloc_text (PAGE,StartDDC)
#pragma alloc_text (PAGE,StopDDC)
#pragma alloc_text (PAGE,ProcessDDC2)
#pragma alloc_text (PAGE,ReadSDA)
#pragma alloc_text (PAGE,ReadSCL)
#pragma alloc_text (PAGE,ReadBit)
#pragma alloc_text (PAGE,ReadByte)
#pragma alloc_text (PAGE,SetSCL)
#pragma alloc_text (PAGE,SetData)
#pragma alloc_text (PAGE,SetClock)
#pragma alloc_text (PAGE,WaitVerticalRetrace)
#pragma alloc_text (PAGE,WaitDelay)
#pragma alloc_text (PAGE,ClearData)
#pragma alloc_text (PAGE,SendByte)
#pragma alloc_text (PAGE,SendDDCCommand)
#pragma alloc_text (PAGE,CheckDDC2BMonitor)
#pragma alloc_text (PAGE,CalculateMaxinumTiming)
#pragma alloc_text (PAGE,ProcessNonDDC)
#pragma alloc_text (PAGE,CirrusNonDDCRegistryCallback)
#endif                                               

UCHAR EDIDBuffer[128] ;
UCHAR EDIDTiming_I    ;
UCHAR EDIDTiming_II   ;
UCHAR EDIDTiming_III  ;
UCHAR DDC2BFlag       ;
UCHAR NonDDCTable     ;
ULONG ulEDIDMaxTiming ;

UCHAR SDAValue ;

/*-------------------------------------------------------------------------*/
VOID EnableDDC (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSR08      ;
    UCHAR WaitCount = 2 ;

    VideoDebugPrint((1, "CLDDC2B!EnableDDC\n"));

    VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                 0x08) ;

    ReadSR08 = VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                           SEQ_DATA_PORT) ;
    // Enable DDC2B Configuration 
    ReadSR08 |= 0x43 ;

    VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                                 ReadSR08) ;

    WaitVerticalRetrace (HwDeviceExtension, WaitCount) ;
    
} /*-----  EnableDDC  -----*/ 


/*-------------------------------------------------------------------------*/
VOID DisableDDC (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSEQADDR, ReadSEQDATA ;
    UCHAR DDCStatus ;

    VideoDebugPrint((1, "CLDDC2B!DisableDDC\n"));

    if ((DDCStatus = SendDDCCommand ( HwDeviceExtension )) == 1)
        goto DDC_ERROR ;

    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar ( HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT ) ;
    // Disable DDC2B Configuration 
    ReadSEQDATA &= 0xBC ;

    // o 3c5 ReadSEQDATA
    VideoPortWritePortUchar ( HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                                 ReadSEQDATA ) ;

DDC_ERROR:
    return ;

}  /*-------  DisableDDC  -------*/ 


/*-------------------------------------------------------------------------*/
VOID ProcessDDC2 (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{                      
    UCHAR DDCStatus, i ;
    UCHAR checksum, header ;

    VideoDebugPrint((1, "CLDDC2B!ProcessDDC2\n"));

    DDC2BFlag = 0 ;

    if ((DDCStatus = SendDDCCommand ( HwDeviceExtension )) == 1) {
        VideoDebugPrint((0, "CLDDC2B!ProcessDDC2: Infinite wait state ...\n"));
        goto PROCESSDDC_EXIT ;
    }

    for (i = 0; i < 128; i++) {
        EDIDBuffer[i] = ReadByte (HwDeviceExtension) ;
	if (Err) {
            VideoDebugPrint((0, "CLDDC2B!ProcessDDC2: Infinite wait state ...\n"));
            goto PROCESSDDC_EXIT ;
        }
    }

    //
    // Check EDID table 8-byte header
    // The correct first 8 bytes of EDID table is 0x00, 0xFF, 0xFF, 0xFF, 
    //                                            0xFF, 0xFF, 0xFF, 0x00
    //

    if ((EDIDBuffer[0] != 0) ||
        (EDIDBuffer[7] != 0)) {
        VideoDebugPrint((1, "CLDDC2B: Invalid EDID header table\n"));
        StopDDC (HwDeviceExtension) ;
        return ;
    }
    for (i = 1; i < 7; i++) {
         if (EDIDBuffer[i] != 0xFF) {
            VideoDebugPrint((1, "CLDDC2B: Invalid EDID header table\n"));
            StopDDC (HwDeviceExtension) ;
            return ;
        }
    }

    //
    // Calculate checksum of 128-byte EDID table.
    // 
    checksum = 0x00 ;

    for (i = 0; i < 128; i++) {
        checksum += EDIDBuffer[i] ;
    }

    VideoDebugPrint((1, "CLDDC2B: EDID Table check sum = %d\n", checksum));

    //
    // EDID table checksum must be zero.
    // 
    if (checksum) {
        VideoDebugPrint((1, "CLDDC2B: Invalid checksum of EDID table\n"));
    }
    else
    {
        //
        // Set DDC2B Flag and find timing values.
        // 
        DDC2BFlag      = 1 ;
        EDIDTiming_I   = EDIDBuffer[35] ; 
        EDIDTiming_II  = EDIDBuffer[36] ;
        EDIDTiming_III = EDIDBuffer[37] ;
        ulEDIDMaxTiming= CalculateMaxinumTiming();
        VideoDebugPrint((1, "CLDDC2B: DDC2B is supported\n"));
    }

PROCESSDDC_EXIT:
    StopDDC (HwDeviceExtension) ;
    return ;

}  /*-------  ProcessDDC2  -------*/ 


/*-------------------------------------------------------------------------*/
VOID StartDDC (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{

    VideoDebugPrint((1, "DDC2B!StartDDC\n"));

    SetSCL (HwDeviceExtension, ON)  ;
    ClearData (HwDeviceExtension) ;
    SetSCL (HwDeviceExtension, OFF) ;

}  /*-------  StartDDC  -------*/ 


/*-------------------------------------------------------------------------*/
VOID StopDDC (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{

    VideoDebugPrint((1, "DDC2B!StopDDC\n"));

    SetSCL (HwDeviceExtension, ON) ;
    SetData (HwDeviceExtension) ;

}  /*-------  StopDDC  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN ReadSCL (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSEQDATA, status ;

    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar ( HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT ) ;

    // Read SR08.B2
    ReadSEQDATA = ( (ReadSEQDATA) & 0x04 ) >> 2 ;

    return (ReadSEQDATA) ;

}  /*-------  ReadSCL  -------*/ 


/*-------------------------------------------------------------------------*/
VOID SetSCL(                        
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR status
    )
{
    UCHAR ReadSEQADDR, ReadSEQDATA ;

    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar (HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT) ;

    ReadSEQDATA = ( ( ReadSEQDATA & 0xFE ) | status ) ;

    // o 3c5 ReadSEQDATA
    VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                                 ReadSEQDATA) ;

    WaitDelay (HwDeviceExtension) ; 

}  /*-------  SetSCL  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN ReadSDA (
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSEQADDR, ReadSEQDATA ;

    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar (HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT) ;

    ReadSEQDATA = ( ReadSEQDATA & 0x80 ) >> 7 ;

    return ( ReadSEQDATA ) ;

}  /*-------  ReadSDA  -------*/ 


/*-------------------------------------------------------------------------*/
VOID ClearData
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSEQADDR, ReadSEQDATA ;


    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar (HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT) ;

    ReadSEQDATA &= 0xFD ;

    // o 3c5 ReadSEQDATA
    VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                                 ReadSEQDATA) ;

    WaitDelay (HwDeviceExtension) ; 

}  /*-------  ClearData  -------*/ 


/*-------------------------------------------------------------------------*/
VOID SetData 
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ReadSEQADDR, ReadSEQDATA ;

    // i 3c5 ReadSEQDATA 
    ReadSEQDATA = VideoPortReadPortUchar (HwDeviceExtension->IOAddress + 
                                              SEQ_DATA_PORT) ;

    ReadSEQDATA |= 0x02 ;

    // o 3c5 ReadSEQDATA
    VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
                                 ReadSEQDATA) ;

    WaitDelay (HwDeviceExtension) ; 

}  /*-------  SetData  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN SetClock 
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    ULONG i ;
    UCHAR status ;

    SetSCL (HwDeviceExtension, ON) ;

    for (i = 0; i < DELAY_COUNT; i++)
        status = ReadSCL (HwDeviceExtension) ;

    SetSCL (HwDeviceExtension, OFF) ;

    if (!status)
        VideoDebugPrint((0, "DDC2B!SetClock: Infinite wait state ...\n"));
    
    if (status == 1)
        return ( FALSE ) ; // retuern 0 -> OK
    else 
        return ( TRUE ) ;  // retuern 1 -> Infinite wait state
                         

}  /*-------  SetClock  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN ReadBit 
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    USHORT i ; 
    UCHAR  bit ;

    SetSCL (HwDeviceExtension, ON) ;
    for (i = 0; i < DELAY_COUNT; i++)
        ReadSCL (HwDeviceExtension) ;

    bit = ReadSDA (HwDeviceExtension) ;

    SetSCL (HwDeviceExtension, OFF) ;
   
    return ( bit ) ;

}  /*-------  ReadBit  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN ReadByte 
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{

    UCHAR ReadByteValue, bit, i ;

    SetData ( HwDeviceExtension ) ;

    ReadByteValue = 0 ;

    for (i = 0; i < 8; i++) {
        ReadByteValue <<= 1  ;
        bit = ReadBit ( HwDeviceExtension ) ;
        ReadByteValue |= bit ;
    }

    if ((bit & 0x02) != 0) {
        SetData ( HwDeviceExtension ) ;
    } else {
        ClearData ( HwDeviceExtension ) ;
    }

    SetClock ( HwDeviceExtension ) ;

     SetData ( HwDeviceExtension ) ;

    return (ReadByteValue) ;

} /*-----  ReadByte  -----*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN SendByte ( 
/*-------------------------------------------------------------------------*/
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR data
    )
{
    UCHAR i ;

    UCHAR Mask[8] = { 0x80, 0x40, 0x20, 0x10, 
                      0x08, 0x04, 0x02, 0x01 } ; 

    for (i = 0; i < 8; i++)
    {
        if (data & Mask[i]) {
            SetData ( HwDeviceExtension ) ;
        } else { 
            ClearData ( HwDeviceExtension ) ;
        }
	Err = SetClock ( HwDeviceExtension ) ;
    }

    if (Err) {
        SetSCL ( HwDeviceExtension, OFF )  ;
        ClearData (HwDeviceExtension) ;
    } else {
        SetData ( HwDeviceExtension ) ;
        SetSCL ( HwDeviceExtension, ON )  ;
        ReadBit ( HwDeviceExtension ) ;  // Discard acknowledge bit
    }

    return (Err) ;

}  /*-------  SendByte  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN IsDDC2
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    UCHAR DDCStatus, SCLStatus ;

    VideoDebugPrint((1, "DDC2B!IsDDC2\n"));

    SetSCL (HwDeviceExtension, OFF) ;
    SCLStatus = ReadSCL(HwDeviceExtension) ;
    if (SCLStatus != 0) {
        return ( FALSE ) ;
    }

    SetSCL (HwDeviceExtension, ON) ;
    SCLStatus = ReadSCL (HwDeviceExtension) ;
    if (SCLStatus != 1) {
        return ( FALSE ) ;
    } 

    return ( TRUE ) ; 

}  /*-------  IsDDC2  -------*/ 


/*-------------------------------------------------------------------------*/
BOOLEAN SendDDCCommand
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    UCHAR ClockStatus ;

    VideoDebugPrint((1, "DDC2B!SendDDCCommand\n"));

    StartDDC ( HwDeviceExtension ) ;

    ClockStatus = SendByte ( HwDeviceExtension, 0xA0 ) ;
    if (ClockStatus)
        VideoDebugPrint((0, "DDC2B!SendDDCCommand: Infinite wait state ...\n"));
 
    ClockStatus = SendByte ( HwDeviceExtension, 0x00 ) ;
    if (ClockStatus)
        VideoDebugPrint((0, "DDC2B!SendDDCCommand: Infinite wait state ...\n"));

    StopDDC  ( HwDeviceExtension ) ;


    StartDDC ( HwDeviceExtension ) ;

    ClockStatus = SendByte ( HwDeviceExtension, 0xA1 ) ;
    if (ClockStatus)
        VideoDebugPrint((0, "DDC2B!SendDDCCommand: Infinite wait state ...\n"));

    SetData  ( HwDeviceExtension ) ;

    return (ClockStatus) ;  

}  /*-------  SendDDCCommand  -------*/ 


/*-------------------------------------------------------------------------*/
VOID WaitDelay 
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{
    PUCHAR InStatPort ;

    //
    // Set up port addresses for color/mono
    //
    if (VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                    MISC_OUTPUT_REG_READ_PORT) & 0x01) {
        InStatPort = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR ;
    } else {
        InStatPort = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO ;
    }

    while ((VideoPortReadPortUchar (InStatPort) & 0x01) != 0) ;
    while ((VideoPortReadPortUchar (InStatPort) & 0x01) == 0) ;
    while ((VideoPortReadPortUchar (InStatPort) & 0x01) != 0) ;

}  /*-------  wait_delay  -------*/ 


/*-------------------------------------------------------------------------*/
VOID WaitVerticalRetrace
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR waitcount
    )
{ 
    PUCHAR InStatPort ;
    ULONG i ;
    
    //
    // Set up port addresses for color/mono
    //
    if (VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                    MISC_OUTPUT_REG_READ_PORT) & 0x01) {
        InStatPort = INPUT_STATUS_1_COLOR + HwDeviceExtension->IOAddress;
    } else {
        InStatPort = INPUT_STATUS_1_MONO + HwDeviceExtension->IOAddress;
    }
        
    for (i = 0; i < waitcount; i++) 
    {
        while ((VideoPortReadPortUchar (InStatPort) & 0x08) != 0) ;
        while ((VideoPortReadPortUchar (InStatPort) & 0x08) == 0) ;
    }  

}  /*-------  WaitVerticalRetrace  -------*/

    

/*-------------------------------------------------------------------------*/
VOID ReadVESATiming
/*-------------------------------------------------------------------------*/
    (
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    UCHAR status ; 

    VideoDebugPrint((1, "DDC2B!ReadVESATiming\n"));
#if 1 // NonDDC #sge
    //
    // clear flag.
    //
    NonDDCTable = 0;
    DDC2BFlag   = 0;
#endif
    EnableDDC (HwDeviceExtension) ;

    if ((status = IsDDC2 (HwDeviceExtension)) != 0x00) {
        ProcessDDC2 (HwDeviceExtension) ;
    }
#if 1 // NonDDC #sge
    if(!DDC2BFlag)
        ProcessNonDDC(HwDeviceExtension);
#endif

    DisableDDC (HwDeviceExtension) ;

    return ;

}  /*-----  ReadVESATiming  -----*/

BOOLEAN
CheckDDC2BMonitor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    )

/*++

Routine Description:
    Determines if refresh rate support according to DDC2B standard.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:
    None.

--*/
{

    ULONG ulCurrTiming ;
#if 1 // NonDDC #sge
    if (!DDC2BFlag && !NonDDCTable)
        return TRUE ;
#else
    if (!DDC2BFlag)
        return TRUE ;
#endif

    VideoDebugPrint((4, "CheckDDC2B\n"));
    VideoDebugPrint((4, "refresh rate   = %ld\n", ModesVGA[i].Frequency));
    VideoDebugPrint((4, "hres           = %d\n", ModesVGA[i].hres));
    VideoDebugPrint((4, "vres           = %d\n", ModesVGA[i].vres));

    ulCurrTiming = ModesVGA[i].Frequency *
                   ModesVGA[i].hres *
                   ModesVGA[i].vres ;

    VideoDebugPrint((4, "ulCurrTiming = %d\n", ulCurrTiming)) ;

    VideoDebugPrint((4, "ulEDIDMaxTiming = %d\n", ulEDIDMaxTiming)) ;

    if ( ulCurrTiming > ulEDIDMaxTiming ) 
        return FALSE ;
    else
        return TRUE ;

}  // end of CheckDDC2bMonitor


ULONG
CalculateMaxinumTiming(
    )

/*++

Routine Description:
    Determines maximum allowablt VESA timing value.

Arguments:
    None.

Return Value:
    None.

--*/
{

    ULONG    current_timing_value ;
    ULONG    freq ;
    SHORT    i ;
    USHORT    usHzActive, usHzBlanking, usVtActive, usVtBlanking;
    ULONG    maximum_allowable_timing_value = ulEDIDMaxTiming;

    VideoDebugPrint((1, "CLDDC2B: CalculateMaxinumTiming\n")) ;

    //
    // Calculate established timing values
    // 
    /* 720 * 400 * 70 = 20160000 */
    if ( EDIDTiming_I & 0x80 ) {
        VideoDebugPrint((1, "CLDDC2B: 720 * 400 * 70\n")) ;
        if (maximum_allowable_timing_value < ((ULONG) 20160000)) {
            maximum_allowable_timing_value = ((ULONG) 20160000) ;
        }
    }

    /* 720 * 400 * 88 = 25344000 */
    if ( EDIDTiming_I & 0x40 ) {
        VideoDebugPrint((1, "CLDDC2B: 720 * 400 * 88\n")) ;
        if (maximum_allowable_timing_value < ((ULONG) 25344000)) {
            maximum_allowable_timing_value = ((ULONG) 25344000) ;
        }
    }

    /* 640 * 480 * 60 = 18432000 */
    if ( EDIDTiming_I & 0x20 ) {
        VideoDebugPrint((1, "CLDDC2B: 640 * 480 * 60\n"));
        if (maximum_allowable_timing_value < ((ULONG) 18432000)) {
            maximum_allowable_timing_value = ((ULONG) 18432000) ;
        }
    }

    /* 640 * 480 * 67 = 20582400 */
    if ( EDIDTiming_I & 0x10 ) {
        VideoDebugPrint((1, "CLDDC2B: 640 * 480 * 67\n"));
        if (maximum_allowable_timing_value < ((ULONG) 20582400)) {
            maximum_allowable_timing_value = ((ULONG) 20582400) ;
        }
    }
         
    /* 640 * 480 * 72 = 22118400 */
    if ( EDIDTiming_I & 0x08 ) {
        VideoDebugPrint((1, "CLDDC2B: 640 * 480 * 72\n"));
        if (maximum_allowable_timing_value < ((ULONG) 22118400)) {
            maximum_allowable_timing_value = ((ULONG) 22118400) ;
        }
    }

    /* 640 * 480 * 75 = 23040000 */
    if ( EDIDTiming_I & 0x04 ) {
        VideoDebugPrint((1, "CLDDC2B: 640 * 480 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 23040000)) {
            maximum_allowable_timing_value = ((ULONG) 23040000) ;
        }
    }

    /* 800 * 600 * 56 = 26880000 */
    if ( EDIDTiming_I & 0x02 ) {
        VideoDebugPrint((1, "CLDDC2B: 800 * 600 * 56\n"));
        if (maximum_allowable_timing_value < ((ULONG) 26880000)) {
            maximum_allowable_timing_value = ((ULONG) 26880000) ;
        }
    }

    /* 800 * 600 * 60 = 28800000 */
    if ( EDIDTiming_I & 0x01 ) {
        VideoDebugPrint((1, "CLDDC2B: 800 * 600 * 60\n"));
        if (maximum_allowable_timing_value < ((ULONG) 28800000)) {
            maximum_allowable_timing_value = ((ULONG) 28800000) ;
        }
    }   

    /* 800 * 600 * 72 = 34560000 */
    if ( EDIDTiming_II & 0x80 ) {
        VideoDebugPrint((1, "CLDDC2B: 800 * 600 * 72\n"));
        if (maximum_allowable_timing_value < ((ULONG) 34560000)) {
            maximum_allowable_timing_value = ((ULONG) 34560000) ;
        } 
    }

    /* 800 * 600 * 75 = 36000000 */
    if ( EDIDTiming_II & 0x40 ) {
        VideoDebugPrint((1, "CLDDC2B: 800 * 600 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 36000000)) {
            maximum_allowable_timing_value = ((ULONG) 36000000) ; 
        }
    }

    /* 832 * 624 * 75 = 38937600 */
    if ( EDIDTiming_II & 0x20 ) {
        VideoDebugPrint((1, "CLDDC2B: 832 * 624 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 38937600)) {
            maximum_allowable_timing_value = ((ULONG) 38937600) ; 
        }
    }

    /* 1024 * 768 * 43 = 33816576 */
    if ( EDIDTiming_II & 0x10 ) {
        VideoDebugPrint((1, "CLDDC2B: 1024 * 768 * 43\n"));
        if (maximum_allowable_timing_value < ((ULONG) 33816576)) {
            maximum_allowable_timing_value = ((ULONG) 33816576) ;
        }
    }

    /* 1024 * 768 * 60 = 47185920 */
    if ( EDIDTiming_II & 0x08 ) {
        VideoDebugPrint((1, "CLDDC2B: 1024 * 768 * 60\n"));
        if (maximum_allowable_timing_value < ((ULONG) 47185920)) {
            maximum_allowable_timing_value = ((ULONG) 47185920) ;
        }
    }

    /* 1024 * 768 * 70 = 55050240 */
    if ( EDIDTiming_II & 0x04 ) {
        VideoDebugPrint((1, "CLDDC2B: 1024 * 768 * 70\n"));
        if (maximum_allowable_timing_value < ((ULONG) 55050240)) {
            maximum_allowable_timing_value = ((ULONG) 55050240) ;
        }
    }

    /* 1024 * 768 * 75 = 58982400 */
    if ( EDIDTiming_II & 0x02 ) {
        VideoDebugPrint((1, "CLDDC2B: 1024 * 768 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 58982400)) {
            maximum_allowable_timing_value = ((ULONG) 58982400) ;
        }
    }

    /* 1280 * 1024 * 75 = 98304000 */
    if ( EDIDTiming_II & 0x01 ) {
        VideoDebugPrint((1, "CLDDC2B: 1280 * 1024 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 98304000)) {
            maximum_allowable_timing_value = ((ULONG) 98304000) ;
        }
    }

    /* 1152 * 870 * 75 = 75168000 */
    if ( EDIDTiming_III & 0x80 ) {
        VideoDebugPrint((1, "CLDDC2B: 1152 * 870 * 75\n"));
        if (maximum_allowable_timing_value < ((ULONG) 75168000)) {
            maximum_allowable_timing_value = ((ULONG) 75168000) ;
        }
    }

    //
    // Calculate standard timing values
    // 

    for ( i = 0x26 ; i <= 0x35 ; i+=2 ) {
        current_timing_value = 0L ;
        freq = ( EDIDBuffer[i+1] & 0x3F ) + 60 ;
        switch ( EDIDBuffer[i] ) {
            case 0x31 :                                 // 640 * 480 = 307200 
                current_timing_value = ((ULONG) freq) * 307200 ;
                VideoDebugPrint((1, "CLDDC2B: 640 * 480 * %d\n", freq));
                break ;   
            case 0x3B :                                 // 720 * 400 = 288000
                current_timing_value = ((ULONG) freq) * 288000 ;
                VideoDebugPrint((1, "CLDDC2B: 640 * 480 * %d\n", freq));
                break ;   
            case 0x45 :                                 // 800 * 600 = 480000
                current_timing_value = ((ULONG) freq) * 480000 ;
                VideoDebugPrint((1, "CLDDC2B: 800 * 600 * %d\n", freq));
                break ;   
            case 0x61 :                                // 1024 * 768 = 786432
                current_timing_value = ((ULONG) freq) * 786432 ;
                VideoDebugPrint((1, "CLDDC2B: 1024 * 768 * %d\n", freq));
                break ;   
            case 0x71 :                               // 1152 * 870 = 1002240
                current_timing_value = ((ULONG) freq) * 1002240 ;
                VideoDebugPrint((1, "CLDDC2B: 1152 * 870 * %d\n", freq));
                break ;   
            case 0x81 :                              // 1280 * 1024 = 1310720
                current_timing_value = ((ULONG) freq) * 1310720 ;
                VideoDebugPrint((1, "CLDDC2B: 1280 * 1024 * %d\n", freq));
                break ;   
            case 0xA9 :                              // 1600 * 1200 = 1920000
                current_timing_value = ((ULONG) freq) * 1920000 ;
                VideoDebugPrint((1, "CLDDC2B: 1600 * 1200 * %d\n", freq));
                break ;   
            default :
                ;
        }

        if (maximum_allowable_timing_value < current_timing_value) 
            maximum_allowable_timing_value = current_timing_value ;

    }

// sge02
    //
    // Calculate detailed timing values
    // 

    for ( i = 0x36 ; i <= 0x7D; i+=18 ) 
    {
        current_timing_value = EDIDBuffer[i] ;
        current_timing_value += EDIDBuffer[i+1] * 256;
        //
        // Validation.
        //
        // sge03
        if (current_timing_value <= 0x0101 )
            continue;
        current_timing_value *= 10000;
        //
        // Calculate Horizontal Active and Blanking
        //
        usHzActive    = (EDIDBuffer[i+4] & 0xf0);
        usHzActive    <<= 4;
        usHzActive    |= EDIDBuffer[i+2];
        usHzBlanking = (EDIDBuffer[i+4] & 0x0f);
        usHzBlanking <<= 8;
        usHzBlanking |= EDIDBuffer[i+3];
        //
        // Calculate Vertical Active and Blanking
        //
        usVtActive    = (EDIDBuffer[i+7] & 0xf0);
        usVtActive    <<= 4;
        usVtActive    |= EDIDBuffer[i+5];
        usVtBlanking = (EDIDBuffer[i+7] & 0x0f);
        usVtBlanking <<= 8;
        usVtBlanking |= EDIDBuffer[i+6];

        current_timing_value = (current_timing_value + usHzActive + usHzBlanking - 1) / (usHzActive + usHzBlanking);
        current_timing_value = (current_timing_value + usVtActive + usVtBlanking - 1) / (usVtActive + usVtBlanking);
        current_timing_value *= usHzActive; 
        current_timing_value *= usVtActive; 

        if (maximum_allowable_timing_value < current_timing_value) 
            maximum_allowable_timing_value = current_timing_value ;

    }

    return (maximum_allowable_timing_value);

}  // end of CalculateMaxinumTiming 

//---------------------------------------------------------------------------
//
// Function:
//     Read NonDDC Table from Registry and Set NonDDCTable Flag.
//
// Input:
//     HwDeviceExtension - Pointer to the miniport driver's device extension.         
//
// Output: 
//     None
//
//---------------------------------------------------------------------------
VOID ProcessNonDDC(
    PHW_DEVICE_EXTENSION HwDeviceExtension 
    )
{                      
    ULONG i ;

    VideoDebugPrint((1, "NonDDC!ProcessNonDDC\n"));

    NonDDCTable = 0 ;

    if (NO_ERROR == VideoPortGetRegistryParameters(HwDeviceExtension,
                                                   L"NonDDCMonitor.Data",
                                                   FALSE,
                                                   CirrusNonDDCRegistryCallback,
                                                   NULL)) 
    {
        // 
        // We got the table 
        //
        //
        // Check EDID table 8-byte header
        // The correct first 8 bytes of EDID table is 0x00, 0xFF, 0xFF, 0xFF, 
        //                                            0xFF, 0xFF, 0xFF, 0x00
        //

        if ((EDIDBuffer[0] != 0) ||
            (EDIDBuffer[7] != 0)) 
        {
            VideoDebugPrint((1, "CLNonDDC: Invalid EDID header table\n"));
            return ;
        }
        for (i = 1; i < 7; i++) 
        {
            if (EDIDBuffer[i] != 0xFF) 
            {
                VideoDebugPrint((1, "CLNonDDC: Invalid EDID header table\n"));
                return ;
            }
        }

        //
        // Set NonDDCTable Flag and find timing values.
        // 
        NonDDCTable    = 1 ;
        EDIDTiming_I   = EDIDBuffer[35] ; 
        EDIDTiming_II  = EDIDBuffer[36] ;
        EDIDTiming_III = EDIDBuffer[37] ;
        ulEDIDMaxTiming= CalculateMaxinumTiming();
        VideoDebugPrint((1, "NonDDC: NonDDC is supported\n"));
    }
} // end of ProcessNonDDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\cldata.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cldata.c

Abstract:

    This module contains all the global data used by the cirrus driver.

Environment:

    Kernel mode

Revision History:

* jl01   09-24-96  For 1280x1024x256, refresh 71Hz is replaced by 72Hz
*                  Refer to PDR#5373.
* chu01  10-06-96  Correst miscellaneous for CL-GD5480 refresh rate setting
* sge01  10-06-96  Fix PDR #6794: Correct Monitor refresh rate for 100Hz
*                  file changed: cldata.c modeset.c
* jl02   10-15-96  Add CL5446-BE support to the Mode Table; also newly support
*                  1152x864x64K@70Hz/75Hz and 1280x1024x64K@60Hz
* jl03   11-18-96  The mode 0x12 needs to be set up in Full DOS Screen ( Japanese
*                  Version).  Refer to PDR#7170.
* jl04   11-26-96  1024x768x16M@70Hz is corrected.  Refer to PDR#7629.
*                                                                                                                                               1600x1200x64K and 1280x1024x16M missing for 5480.  PDR#7616
* jl05   12-06-96  1152x864x16M only for 5480.
*
* myf0 : 08-19-96  added 85hz supported, and delete 6x4x16M for CL754x
* myf1 : 08-20-96  supported panning scrolling
* myf2 : 08-20-96 : fixed hardware save/restore state bug for matterhorn
* myf3 : 09-01-96 : Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4 : 09-01-96 : patch Viking BIOS bug, PDR #4287, begin
* myf5 : 09-01-96 : Fixed PDR #4365 keep all default refresh rate
* myf6 : 09-17-96 : Merged Desktop SRC1001 & MINI102
* myf7 : 09-19-96 : Fixed exclude 60Hz refresh rate select
* myf8 :*09-21-96*: May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9 : 09-21-96 : 8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809:09-25-96 : fixed dstn panel icon corrupted
* ms923 :09-25-96 : merge MS-923 Disp.zip code
* myf10 :09-26-96 : Fixed DSTN reserved half-frame buffer bug.
* myf11 :09-26-96 : Fixed 755x CE chip HW bug, access ramdac before disable HW
*                   icons and cursor
* myf12 :10-01-96 : Supported Hot Key switch display
* myf13 :10-02-96 : Fixed Panning scrolling (1280x1024x256) bug y < ppdev->miny
* myf14 :10-15-96 : Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15 :10-16-96 : Fixed disable memory mapped IO for 754x, 755x
* myf16 :10-22-96 : Fixed PDR #6933,panel type set different demo board setting
* tao1 : 10-21-96 : Added 7555 flag for Direct Draw support.
* smith :10-22-96 : Disable Timer event, because sometimes creat PAGE_FAULT or
*                   IRQ level can't handle
* myf17 :11-04-96 : Added special escape code must be use 11/5/96 later NTCTRL,
*                   and added Matterhorn LF Device ID==0x4C
* myf18 :11-04-96 : Fixed PDR #7075,
* myf19 :11-06-96 : Fixed Vinking can't work problem, because DEVICEID = 0x30
*                   is different from data book (CR27=0x2C)
* myf20 :11-12-96 : Fixed DSTN panel initial reserved 128K memoru
* myf21 :11-15-96 : fixed #7495 during change resolution, screen appear garbage
*                   image, because not clear video memory.
* myf22 :11-19-96 : Added 640x480x256/640x480x64K -85Hz refresh rate for 7548
* myf23 :11-21-96 : Added fixed NT 3.51 S/W cursor panning problem
* myf24 :11-22-96 : Added fixed NT 4.0 Japanese dos full screen problem
* myf25 :12-03-96 : Fixed 8x6x16M 2560byte/line patch H/W bug PDR#7843, and
*                   fixed pre-install microsoft requested
* myf26 :12-11-96 : Fixed Japanese NT 4.0 Dos-full screen bug for LCD enable
* myf27 :01-09-97 : Fixed jumper set 8x6 DSTN panel, select 8x6x64K mode,
*                   boot up CRT garbage appear PDR#7986

--*/

#include <dderror.h>
#include <devioctl.h>
#include <miniport.h>

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"

#include "cmdcnst.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif

//---------------------------------------------------------------------------
//
//        The actual register values for the supported modes are in chipset-specific
//        include files:
//
//                mode64xx.h has values for CL6410 and CL6420
//                mode542x.h has values for CL5422, CL5424, and CL5426
//                mode543x.h has values for CL5430-CL5439 (Alpine chips)
//
#include "mode6410.h"
#include "mode6420.h"
#include "mode542x.h"
#include "mode543x.h"

//crus begin
#ifdef PANNING_SCROLL                  //myf1
//myf1, begin
#ifdef INT10_MODE_SET
RESTABLE ResolutionTable[] = {
// {1280, 1024, 1,  16, 0x6C},
// {1024,  768, 1,  11, 0x5D},
// { 800,  600, 1,  8,  0x6A},
 { 640,  480, 1,  4,  0x12},    //myf26

 {1280, 1024, 8,  32, 0x6D},  //31,27
 {1024,  768, 8,  21, 0x60},  //20,16
 { 800,  600, 8,  15, 0x5C},  //14,10
 { 640,  480, 8,   9, 0x5F},  //08,04

 {1280, 1024, 16, 62, 0x75},  //61,56
 {1024,  768, 16, 52, 0x74},  //51,47
 { 800,  600, 16, 45, 0x65},  //44,40
 { 640,  480, 16, 40, 0x64},  //39,35

 {1280, 1024, 24, NULL, NULL},
 {1024,  768, 24, 82, 0x79},  //81,77
 { 800,  600, 24, 76, 0x78},  //75,71
 { 640,  480, 24, 70, 0x71},  //69,65

 {1280, 1024, 32, NULL, 0},
 {1024,  768, 32, NULL, 0},
 { 800,  600, 32, NULL, 0},
 { 640,  480, 32, NULL, 0},

 {   0,    0,  0, 0},
};
#endif
//myf1, end
#endif
//crus end


//
// This structure describes to which ports access is required.
//

VIDEO_ACCESS_RANGE VgaAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,                // 64-bit linear base address
                                                 // of range
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1, // # of ports
    1,                                           // range is in I/O space
    1,                                           // range should be visible
    0           //myf25                          // range should be shareable
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0   //myf25
},

//
// This next region also includes Memory mapped IO.  In MMIO, the ports are
// repeated every 256 bytes from b8000 to bff00.
//

{
    MEM_VGA, 0x00000000,
    MEM_VGA_SIZE,
    0,
    1,
    0   //myf25
},

//
// Region reserved for when linear mode is enabled.
//

{
    MEM_LINEAR, 0x00000000,
    MEM_LINEAR_SIZE,
    0,
    0,
    0
},


//
// This next region is for relocatable VGA register and MMIO register.
//

{
    MEM_VGA, 0x00000000,
    MEM_VGA_SIZE,
    0,
    1,
    0
}

};

//
// Validator Port list.
// This structure describes all the ports that must be hooked out of the V86
// emulator when a DOS app goes to full-screen mode.
// The structure determines to which routine the data read or written to a
// specific port should be sent.
//

EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[] = {

    //
    // Traps for byte OUTs.
    //

    {
        0x000003b0,                   // range start I/O address
        0x0C,                         // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    {
        0x000003c0,                   // range start I/O address
        0x20,                         // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    //
    // Traps for word OUTs.
    //

    {
        0x000003b0,
        0x06,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    {
        0x000003c0,
        0x10,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    //
    // Traps for dword OUTs.
    //

    {
        0x000003b0,
        0x03,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    },

    {
        0x000003c0,
        0x08,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    }

};


//
// Used to trap only the sequncer and the misc output registers
//

VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    1,        // <- enable range IOPM so that it is not trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    MISC_OUTPUT_REG_WRITE_PORT, 0x00000000,
    0x00000001,
    1,
    0,
    0
},
{
    SEQ_ADDRESS_PORT, 0x00000000,
    0x00000002,
    1,
    0,
    0
}
};

//
// Used to trap all registers
//

VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    0,        // <- disable range in the IOPM so that it is trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    0,
    0
}
};

USHORT MODESET_MODEX_320_200[] = {
    OW,
    SEQ_ADDRESS_PORT,
    0x0604,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0xe317,
    0x0014,

    EOD
};

USHORT MODESET_MODEX_320_240[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0604,
    0x0100,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,
    SEQ_ADDRESS_PORT,
    0x0300,

    OB,
    CRTC_ADDRESS_PORT_COLOR,
    0x11,

    METAOUT+MASKOUT,
    CRTC_DATA_PORT_COLOR,
    0x7f, 0x00,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    10,
    0x0d06,
    0x3e07,
    0x4109,
    0xea10,
    0xac11,
    0xdf12,
    0x0014,
    0xe715,
    0x0616,
    0xe317,

    OW,
    SEQ_ADDRESS_PORT,
    0x0f02,

    EOD
};

USHORT MODESET_MODEX_320_400[] = {
    OW,
    SEQ_ADDRESS_PORT,
    0x0604,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    3,
    0xe317,
    0x0014,
    0x4009,

    EOD
};

USHORT MODESET_MODEX_320_480[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0604,
    0x0100,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,
    SEQ_ADDRESS_PORT,
    0x0300,

    OB,
    CRTC_ADDRESS_PORT_COLOR,
    0x11,

    METAOUT+MASKOUT,
    CRTC_DATA_PORT_COLOR,
    0x7f, 0x00,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    10,
    0x0d06,
    0x3e07,
    0x4109,
    0xea10,
    0xac11,
    0xdf12,
    0x0014,
    0xe715,
    0x0616,
    0xe317,

    OW,
    SEQ_ADDRESS_PORT,
    0x0f02,

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x4009,

    EOD
};



USHORT MODESET_1K_WIDE[] = {
    OW,                             // stretch scans to 1k
    CRTC_ADDRESS_PORT_COLOR,
    0x8013,

    EOD
};

USHORT MODESET_2K_WIDE[] = {
    OWM,                            // stretch scans to 2k
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0x0013,
    0x021B, // CR1B[5]=0, 0x321b for 64kc bug

    EOD
};

USHORT MODESET_75[] = {
    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0x4013,
    0x321B,
    EOD
};


USHORT CL543x_640x480x16M[] = {
    OW,                             // begin setmode
    SEQ_ADDRESS_PORT,
    0x1206,                         // enable extensions
/*
    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0xF013, 0x221B,
*/
    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0xF013,
    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x221B,

    EOD
};

USHORT CL543x_800x600x16M[] = {
    OW,                             // begin setmode
    SEQ_ADDRESS_PORT,
    0x1206,                         // enable extensions
/*
    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0x2C13, 0x321B,
*/
    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x2C13,
    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x321B,

    EOD
};

//myf25
USHORT CL543x_800x600x16M_1[] = {
    OW,                             // begin setmode
    SEQ_ADDRESS_PORT,
    0x1206,                         // enable extensions

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x4013,
    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x321B,

    EOD
};

//---------------------------------------------------------------------------
//
// Memory map table -
//
// These memory maps are used to save and restore the physical video buffer.
//

MEMORYMAPS MemoryMaps[] = {

//               length      start
//               ------      -----
    {           0x08000,    0x10000},   // all mono text modes (7)
    {           0x08000,    0x18000},   // all color text modes (0, 1, 2, 3,
    {           0x10000,    0x00000}    // all VGA graphics modes
};

//
// Video mode table - contains information and commands for initializing each
// mode. These entries must correspond with those in VIDEO_MODE_VGA. The first
// entry is commented; the rest follow the same format, but are not so
// heavily commented.
//

VIDEOMODE ModesVGA[] = {
//
// Color text mode 3, 720x400, 9x16 char cell (VGA).
//
{
  VIDEO_MODE_COLOR,  // flags that this mode is a color mode, but not graphics
  4,                 // four planes
  1,                 // one bit of colour per plane
  80, 25,            // 80x25 text resolution
  720, 400,          // 720x400 pixels on screen
  160, 0x10000,      // 160 bytes per scan line, 64K of CPU-addressable bitmap
  0, 0,              // only support one frequency, non-interlaced
  0,                 // montype is 'dont care' for text modes
  0, 0, 0,           // montype is 'dont care' for text modes
  TRUE,              // hardware cursor enabled for this mode
  NoBanking,         // no banking supported or needed in this mode
  MemMap_CGA,        // the memory mapping is the standard CGA memory mapping
                     //  of 32K at B8000
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,              // ModeValid default is always off
  FALSE,              // This mode cannot be mapped linearly
  { 3,3,3},          // int10 BIOS modes
  { CL6410_80x25Text_crt, CL6410_80x25Text_panel,
   CL6420_80x25Text_crt, CL6420_80x25Text_panel,
   CL542x_80x25Text, CL543x_80x25Text, 0 },
},      //myf1, 0

//
// Color text mode 3, 640x350, 8x14 char cell (EGA).
//
{  VIDEO_MODE_COLOR,  // flags that this mode is a color mode, but not graphics
  4,                 // four planes
  1,                 // one bit of colour per plane
  80, 25,            // 80x25 text resolution
  640, 350,          // 640x350 pixels on screen
  160, 0x10000,      // 160 bytes per scan line, 64K of CPU-addressable bitmap
  0, 0,              // only support one frequency, non-interlaced
  0,                 // montype is 'dont care' for text modes
  0, 0, 0,           // montype is 'dont care' for text modes
  TRUE,              // hardware cursor enabled for this mode
  NoBanking,         // no banking supported or needed in this mode
  MemMap_CGA,        // the memory mapping is the standard CGA memory mapping
                     //  of 32K at B8000
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,              // ModeValid default is always off
  FALSE,
  { 3,3,3},             // int10 BIOS modes
    { CL6410_80x25_14_Text_crt, CL6410_80x25_14_Text_panel,
     CL6420_80x25_14_Text_crt, CL6420_80x25_14_Text_panel,
     CL542x_80x25_14_Text, CL543x_80x25_14_Text, 0 },
},      //myf1, 1

//
//
// Monochrome text mode 7, 720x400, 9x16 char cell (VGA).
//
{ 0,                            // flags that this mode is a monochrome text mode
  4,                // four planes
  1,                // one bit of colour per plane
  80, 25,           // 80x25 text resolution
  720, 400,         // 720x400 pixels on screen
  160, 0x10000,     // 160 bytes per scan line, 64K of CPU-addressable bitmap
  0, 0,             // only support one frequency, non-interlaced
  0,                // montype is 'dont care' for text modes
  0, 0, 0,          // montype is 'dont care' for text modes
  TRUE,             // hardware cursor enabled for this mode
  NoBanking,        // no banking supported or needed in this mode
  MemMap_Mono,      // the memory mapping is the standard monochrome memory
                    //  mapping of 32K at B0000
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,            // ModeValid default is always off
  FALSE,            // This mode cannot be mapped linearly
  { 7,7,7 },        // int10 BIOS modes
  { CL6410_80x25Text_crt, CL6410_80x25Text_panel,
   CL6420_80x25Text_crt, CL6420_80x25Text_panel,
   CL542x_80x25Text, CL543x_80x25Text, 0 },
},      //myf1, 2

//
//
// Monochrome text mode 7, 640x350, 8x14 char cell (EGA).
//
{ 0,                            // flags that this mode is a monochrome text mode
  4,                // four planes
  1,                // one bit of colour per plane
  80, 25,           // 80x25 text resolution
  640, 350,         // 640x350 pixels on screen
  160, 0x10000,     // 160 bytes per scan line, 64K of CPU-addressable bitmap
  0, 0,             // only support one frequency, non-interlaced
  0,                // montype is 'dont care' for text modes
  0, 0, 0,          // montype is 'dont care' for text modes
  TRUE,             // hardware cursor enabled for this mode
  NoBanking,        // no banking supported or needed in this mode
  MemMap_Mono,          // the memory mapping is the standard monochrome memory
                    //  mapping of 32K at B0000
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,            // ModeValid default is always off
  FALSE,
  { 7,7,7 },            // int10 BIOS modes
    { CL6410_80x25_14_Text_crt, CL6410_80x25_14_Text_panel,
     CL6420_80x25_14_Text_crt, CL6420_80x25_14_Text_panel,
     CL542x_80x25_14_Text, CL543x_80x25_14_Text, 0 },
},      //myf1, 3

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000,
  60, 0,              // 60hz, non-interlaced
  3,                  // montype
  0x1203, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0x12,0x12,0x12},          // int10 BIOS modes
  { CL6410_640x480_crt, CL6410_640x480_panel,
   CL6420_640x480_crt, CL6420_640x480_panel,
   CL542x_640x480_16, CL543x_640x480_16, 0 },
},      //myf1, 4

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000,
  72, 0,              // 72hz, non-interlaced
  4,                  // montype
  0x1213, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
// crus
  CL6245 | CL754x | CL755x | CL542x | CL754x | CL5436 | CL5446 | CL5446BE | CL5480,
  crt,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0,0,0x12},                // int10 BIOS modes
  { NULL, NULL,
   NULL, NULL,
   CL542x_640x480_16, NULL, 0 },
},

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000,
  75, 0,              // 75hz, non-interlaced
  4,                  // montype
  0x1230, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0,0,0x12},                // int10 BIOS modes
  { NULL, NULL,
   NULL, NULL,
   NULL, CL543x_640x480_16, 0 },
},

//
// Standard VGA Color graphics mode 0x12
// 640x480 16 colors, 85 Hz non-interlaced
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000,
  85, 0,              // 85hz, non-interlaced
  4,                  // montype
  0x1213, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
                                //myf0
  crt,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0,0,0x12},                // int10 BIOS modes
  { NULL, NULL,
   NULL, NULL,
   NULL, CL543x_640x480_16, 0 },
},

// We make ModeX modes available only on x86 because our IO-mapping IOCTL,
// QUERY_PUBLIC_ACCESS_RANGES doesn't currently support the ModeX request
// format:

#if defined(_X86_)

// Standard ModeX mode
// 320x200 256 colors, 70 Hz non-interlaced
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 200, 80, 0x10000,
  70, 0,              // 70hz, non-interlaced
  3,                  // montype
  0x1203, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0x13,0x13,0x13},          // int10 BIOS modes
  { MODESET_MODEX_320_200, MODESET_MODEX_320_200,
    MODESET_MODEX_320_200, MODESET_MODEX_320_200,
    MODESET_MODEX_320_200, MODESET_MODEX_320_200, 0 },
},      //myf1, 5

// Standard ModeX mode
// 320x240 256 colors, 60 Hz non-interlaced
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 240, 80, 0x10000,
  60, 0,              // 60hz, non-interlaced
  3,                  // montype
  0x1203, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0x13,0x13,0x13},          // int10 BIOS modes
  { MODESET_MODEX_320_240, MODESET_MODEX_320_240,
    MODESET_MODEX_320_240, MODESET_MODEX_320_240,
    MODESET_MODEX_320_240, MODESET_MODEX_320_240, 0 },
},      //myf1, 6

// Standard ModeX mode
// 320x400 256 colors, 70 Hz non-interlaced
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 400, 80, 0x10000,
  70, 0,              // 70hz, non-interlaced
  3,                  // montype
  0x1203, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0x13,0x13,0x13},          // int10 BIOS modes
  { MODESET_MODEX_320_400, MODESET_MODEX_320_400,
    MODESET_MODEX_320_400, MODESET_MODEX_320_400,
    MODESET_MODEX_320_400, MODESET_MODEX_320_400, 0 },
},      //myf1, 7

// Standard ModeX mode
// 320x480 256 colors, 60 Hz non-interlaced
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 8, 1, 80, 30,
  320, 480, 80, 0x10000,
  60, 0,              // 60hz, non-interlaced
  3,                  // montype
  0x1203, 0x00A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                      // ModeValid default is always off
  FALSE,
  { 0x13,0x13,0x13},          // int10 BIOS modes
  { MODESET_MODEX_320_480, MODESET_MODEX_320_480,
    MODESET_MODEX_320_480, MODESET_MODEX_320_480,
    MODESET_MODEX_320_480, MODESET_MODEX_320_480, 0 },
},      //myf1, 8

#endif // #defined(_X86_)


//
// Beginning of SVGA modes
//

//
// 800x600 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000,
  56, 0,              // 56hz, non-interlaced
  3,                  // montype
  0x1203, 0xA4, 0,    // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
// crus
  CL6245 | CL6410 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                   // ModeValid default is always off
  FALSE,
  { 0x6a,0x6a,0x6a},       // int10 BIOS modes
  { CL6410_800x600_crt, NULL,
   CL6420_800x600_crt, NULL,
   CL542x_800x600_16, CL543x_800x600_16, 0 },
},

//
// 800x600 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000,
  60, 0,              // 60hz, non-interlaced
  4,                  // montype
  0x1203, 0x01A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
// crus
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel8x6 | panel10x7,
  FALSE,                   // ModeValid default is always off
  FALSE,
  { 0,0x6a,0x6a},          // int10 BIOS modes
  { NULL, NULL,
   CL6420_800x600_crt, NULL,
   CL542x_800x600_16, CL543x_800x600_16, 0 },
},

//
// 800x600 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000,
  72, 0,              // 72hz, non-interlaced
  5,                  // montype
  0x1203, 0x02A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
// crus
  CL6245 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                   // ModeValid default is always off
  FALSE,
  { 0,0,0x6a},             // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_800x600_16, CL543x_800x600_16, 0 },
},

//
// 800x600 16 colors.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000,
  75, 0,              // 75hz, non-interlaced
  5,                  // montype
  0x1203, 0x03A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NoBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                   // ModeValid default is always off
  FALSE,
  { 0,0,0x6a},             // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_16, 0 },
},

//
// 1024x768 non-interlaced 16 colors.
// Assumes 512K.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000,
  60, 0,              // 60hz, non-interlaced
  5,                  // montype
  0x1203, 0x10A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
// crus
  CL6245 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel10x7,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0,0x5d},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},

//
// 1024x768 non-interlaced 16 colors.
// Assumes 512K.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000,
  70, 0,              // 70hz, non-interlaced
  6,                  // montype
  0x1203, 0x20A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0,0x5d},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
   CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},

//
// 1024x768 non-interlaced 16 colors.
// Assumes 512K.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000,
  72, 0,              // 72hz, non-interlaced
  7,                  // montype
  0x1203, 0x30A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0,0x5d},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},

//
// 1024x768 non-interlaced 16 colors.
// Assumes 512K.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000,
  75, 0,              // 75hz, non-interlaced
  7,                  // montype
  0x1203, 0x40A4, 0,  // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0,0x5d},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_16, 0 },
},

//
// 1024x768 interlaced 16 colors.
// Assumes 512K.
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000,
  43, 1,              // 43hz, interlaced
  4,                  // montype
  0x1203, 0xA4, 0,    // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
// crus
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0x37,0x5d},       // int10 BIOS modes
  { NULL, NULL,
   CL6420_1024x768_crt, NULL,
   CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},

//
// 1280x1024 interlaced 16 colors.
// Assumes 1meg required. 1K scan line
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 160, 64,
  1280, 1024, 256, 0x40000,
  43, 1,              // 43Hz, interlaced
  5,                  // montype
  0x1203, 0xA4, 0,    // montype
  FALSE,              // hardware cursor disabled for this mode
  NormalBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  FALSE,
  { 0,0,0x6c},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1280x1024_16, CL543x_1280x1024_16, MODESET_1K_WIDE},
},

//
//
// VGA Color graphics,
//
// 640x480 256 colors.
//
// For each mode which we have a broken raster version of the mode,
// followed by a stretched version of the mode.  This is ok because
// the vga display drivers will reject modes with broken rasters.
//

// ----- 640x480x256@60Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 640, 0x80000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x2e,0x5f},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_640x480_256color_crt, CL6420_640x480_256color_panel,
    CL542x_640x480_256, CL543x_640x480_256, NULL},
},      //myf1, 9


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x2e,0x5f},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_640x480_256color_crt, CL6420_640x480_256color_panel,
    CL542x_640x480_256, CL543x_640x480_256, MODESET_1K_WIDE },
},


// ----- 640x480x256@72Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 640, 0x80000,
  72, 0,                             // 72hz, non-interlaced
  4,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL754x | CL755x | CL542x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5f},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_640x480_256, CL543x_640x480_256, NULL },
},      //myf1, 10


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000,
  72, 0,                             // 72hz, non-interlaced
  4,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL754x | CL755x | CL542x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5f},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_640x480_256, CL543x_640x480_256, MODESET_1K_WIDE },
},


// ----- 640x480x256@75Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 640, 0x80000,
  75, 0,                             // 75hz, non-interlaced
  4,                                 // montype
  0x1230, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5f},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_256, NULL },
},      //myf1, 11


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000,
  75, 0,              // 75hz, non-interlaced
  4,                  // montype
  0x1230, 0x00A4, 0,  // montype
  TRUE,              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  TRUE,
  { 0,0,0x5f},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_256, MODESET_1K_WIDE },
},


// ----- 640x480x256@85Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 640, 0x80000,
  85, 0,              // 85 Hz, non-interlaced
  4,                  // montype
  0x1213, 0x00A4, 0,  // montype
  TRUE,              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  TRUE,
  { 0,0,0x5f},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_256, NULL },
},      //myf1, 12


// ----- 640x480x256@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 640, 0x80000,
  100, 0,                     // 100 Hz, non-interlaced
  4,                          // montype
  0x1213, 0x00A4, 0,          // montype
  TRUE,                       // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                      // ModeValid default is always off
  TRUE,
  { 0,0,0x5F},                // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_256, NULL },
},      //myf1, 13



// ----- 800x600x256@56Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  56, 0,                             // 56hz, non-interlaced
  3,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x30,0x5c},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_800x600_256color_crt, NULL,
    CL542x_800x600_256, CL543x_800x600_256, NULL },
},      //myf1, 14



{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000,
  56, 0,                             // 56hz, non-interlaced
  3,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x30,0x5c},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_800x600_256color_crt, NULL,
    CL542x_800x600_256, CL543x_800x600_256, MODESET_1K_WIDE },
},


// ----- 800x600x256@60Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  60, 0,                             // 60hz, non-interlaced
  4,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x30,0x5c},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_800x600_256color_crt, NULL,
    CL542x_800x600_256, CL543x_800x600_256, NULL },
},      //myf1, 15



{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  4,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x30,0x5c},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_800x600_256color_crt, NULL,
    CL542x_800x600_256, CL543x_800x600_256, MODESET_1K_WIDE },
},


// ----- 800x600x256@72Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  72, 0,                             // 72hz, non-interlaced
  5,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_800x600_256, CL543x_800x600_256, NULL },
},      //myf1, 16



{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  5,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6245 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_800x600_256, CL543x_800x600_256, MODESET_1K_WIDE },
},



// ----- 800x600x256@75Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  75, 0,                             // 75hz, non-interlaced
  5,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_256, NULL },
},      //myf1, 17



{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  5,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_256, MODESET_1K_WIDE },
},



// ----- 800x600x256@85Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  85, 0,                             // 85hz, non-interlaced
  5,                                 // montype
  0x1203, 0x04A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_256, NULL },
},      //myf1, 18


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 1024, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  5,                                 // montype
  0x1203, 0x04A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5c},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_256, MODESET_1K_WIDE },
},



// ----- 800x600x256@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 100, 37,
  800, 600, 800, 0x80000,
  100, 0,                            // 100Hz, non-interlaced
  5,                                 // montype
  0x1203, 0x05A4, 0, // sge01        // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x5C},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_256, NULL },
},      //myf1, 19



// ----- 1024x768x256@43i ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  43, 1,                             // 43Hz, interlaced
  4,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x38,0x60},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_1024x768_256color_crt, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},      //myf1, 20



// ----- 1024x768x256@60Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  5,                                 // montype
  0x1203, 0x10A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,                              // what should we do for this mode?  vga will accept this!
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},      //myf1, 21



// ----- 1024x768x256@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  70, 0,                             // 70hz, non-interlaced
  6,                                 // montype
  0x1203, 0x20A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},      //myf1, 22



// ----- 1024x768x256@72Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  7,                                 // montype
  0x1203, 0x30A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5436 | CL5446 | CL5446BE | CL54UM36,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},      //myf1, 23



// ----- 1024x768x256@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  7,                                 // montype
  0x1203, 0x40A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_16, 0 },
},      //myf1, 24



// ----- 1024x768x256@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  7,                                 // montype
  0x1203, 0x50A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_16, 0 },
},      //myf1, 25


// ----- 1024x768x256@100Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  100, 0,                            // 100Hz, non-interlaced
  7,                                 // montype
  0x1203, 0x60A4, 0,    // sge01     // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x60},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_16, 0 },
},      //myf1, 26



/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 128, 48,
  1024, 768, 1024, 0x100000,
  43, 1,                             // 43Hz, interlaced
  4,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL6420 | CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0x38,0x60},                    // int10 BIOS modes
  { NULL, NULL,
    CL6420_1024x768_256color_crt, NULL,
    CL542x_1024x768_16, CL543x_1024x768_16, 0 },
},

<----- */



// ----- 1152x864x256@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 144, 54,
  1152, 864, 1152, 0x100000,
  70, 0,                             // 70hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0000,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446 | CL5446BE | CL5480,
  crt,
  FALSE,                // ModeValid default is always off
  TRUE,
  { 0,0,0x7c },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 27


// ----- 1152x864x256@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 144, 54,
  1152, 864, 1152, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0100,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446 | CL5446BE | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7c },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 28


// ----- 1152x864x256@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 144, 54,
  1152, 864, 1152, 0x100000,
  85, 0,                             // 85Hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0200,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7C },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 29


// ----- 1152x864x256@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 144, 54,
  1152, 864, 1152, 0x100000,
  100, 0,                            // 100Hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0300,  // sge01    // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7C },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 30



// ----- 1280x1024x256@43i --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  43, 1,                             // 43Hz, interlaced
  5,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 31


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 2048, 0x200000,
  43, 1,                             // 43Hz, interlaced
  5,                                 // montype
  0x1203, 0xA4, 0,                   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, MODESET_2K_WIDE },
},

<----- */



// ----- 1280x1024x256@60Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  60, 0,                             // 60Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x1000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 32


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 2048, 0x200000,
  60, 0,                             // 60Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x1000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, MODESET_2K_WIDE },
},

<----- */


// ----- 1280x1024x256@72Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  72, 0,                             // 72Hz, non-interlaced, jl01
  0,                                 // montype
  0x1203, 0xA4, 0x2000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5434_6 | CL5436 | CL54UM36 | CL5446 | CL5446BE,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 33


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 2048, 0x200000,
  71, 0,                             // 71Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x2000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5434_6 | CL5436 | CL54UM36 | CL5446 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, MODESET_2K_WIDE },
},

<----- */


// ----- 1280x1024x256@75Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  75, 0,                             // 75Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x3000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5434_6 | CL5436 | CL54UM36 | CL5446 | CL5446BE | CL5480 | CL7556,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 34


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 2048, 0x200000,
  75, 0,                             // 75Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x3000,              // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5434_6 | CL5446 | CL5480,   //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, MODESET_2K_WIDE },
},

<----- */


// ----- 1280x1024x256@85Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  85, 0,                             // 85Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x4000,    // sge01  // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 35



// ----- 1280x1024x256@100Hz ------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 160, 64,
  1280, 1024, 1280, 0x200000,
  100, 0,                            // 100Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x5000,    // sge01  // montype
  FALSE,                             // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x6D},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1280x1024_16, NULL },
},      //myf1, 36



// (This mode doesn't seem to work!  ????? )
//
// ----- 1600x1200x256@48i --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 200, 75,
  1600, 1200, 1600, 0x200000,
  48, 1,                            // 96Hz, interlaced
  7,                                // montype
  0x1204, 0xA4, 0x0000,             // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7B },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 37


// ----- 1600x1200x256@60Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 200, 75,
  1600, 1200, 1600, 0x200000,
  60, 0,                            // 60Hz, non-interlaced
  7,                                // montype
  0x1204, 0x00A4, 0x0400, // chu01  // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7B },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 38


// ----- 1600x1200x256@70Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 200, 75,
  1600, 1200, 1600, 0x200000,
  70, 0,                            // 70Hz, non-interlaced
  7,                                // montype
  0x1204, 0x00A4, 0x0800, // chu01  // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7B },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 39



//
// The Cirrus Display Driver now supports broken rasters,
// so I have enabled support for broken rasters in the
// miniport.
//
// Eventually we will probably want to add additional
// (equivalent) modes which don't require broken rasters.
//
// To get back to these modes, make the wbytes field
// equal to 2048, set the memory requirements field
// appropriately (1 meg for 640x480x64k, 2 meg for
// 800x600x64).
//
// Finally for non broken rasters we need to the
// stretch from NULL to MODESET_2K_WIDE.
//



// ----- 640x480x64K@60Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1280, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_640x480_64k, CL543x_640x480_64k, NULL},
},      //myf1, 40




//
// The Compaq storm (754x 800x600 LCD) has a problem with the stretch
// code under 64k color modes.  The last pixel on a line is wrapped
// around to the start of the next line.  The problem is solved if we
// use a non-stretched broken raster mode.
//
// I've expanded our 640x480x64k color modes such that we have both
// a broken raster mode (on all platforms) and a stretched mode for
// x86 machines.  (In case cirrus.dll does not load, and vga64k
// loads instead.  Vga64k does not support broken rasters.)
//

//
// VGA Color graphics,        640x480 64k colors. 2K scan line
// Non-Broken Raster version
//


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 2048, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt | panel | panel8x6 | panel10x7,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    CL542x_640x480_64k, CL543x_640x480_64k, MODESET_2K_WIDE },
},

<----- */



//
//
// VGA Color graphics,        640x480 64k colors. 2K scan line
//

// ----- 640x480x64K@72Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1280, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  4,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, NULL },
},      //myf1, 41


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 2048, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  4,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL542x | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, NULL },
},

<----- */


//
// VGA Color graphics,        640x480 64k colors. 2K scan line
//

// ----- 640x480x64K@75Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1280, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  4,                                 // montype
  0x1230, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, NULL },
},      //myf1, 42


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 2048, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  4,                                 // montype
  0x1230, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, MODESET_2K_WIDE },
},

<----- */


// 640x480 64k colors.  85hz non-interlaced
//
// ----- 640x480x64K@85Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1280, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  4,                                 // montype
  0x1230, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,        //myf0, myf22
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, NULL },
},      //myf1, 43


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 2048, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  4,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,        //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, MODESET_2K_WIDE },
},

<----- */


// ----- 640x480x64K@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1280, 0x100000,
  100, 0,                            // 100hz, non-interlaced
  4,                                 // montype
  0x1230, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x64},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480_64k, NULL },
},      //myf1, 44


//
// VGA Color graphics,        800x600 64k colors. 2K scan line
//
// ----- 800x600x64K@56Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  56, 0,                             // 56hz, non-interlaced
  4,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL542x | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 45


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 2048, 0x200000,
  56, 0,                             // 56hz, non-interlaced
  4,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, MODESET_2K_WIDE },
},

<----- */


//
// VGA Color graphics,        800x600 64k colors. 2K scan line
//
// ----- 800x600x64K@60Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  4,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL542x | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 46




/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 2048, 0x200000,
  60, 0,                             // 60hz, non-interlaced
  4,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, MODESET_2K_WIDE },
},

<----- */


//
// VGA Color graphics,        800x600 64k colors. 2K scan line
//
// ----- 800x600x64K@72Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  5,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL542x | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 47


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 2048, 0x200000,
  72, 0,                             // 72hz, non-interlaced
  5,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, MODESET_2K_WIDE },
},

<----- */


//
// VGA Color graphics,        800x600 64k colors. 2K scan line
//
// ----- 800x600x64K@75Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  5,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 48


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 2048, 0x200000,
  75, 0,                             // 75hz, non-interlaced
  5,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, MODESET_2K_WIDE },
},

<----- */

// ----- 800x600x64K@85Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  5,                                 // montype
  0x1203, 0x04A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,        //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 49


// ----- 800x600x64K@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 100, 37,
  800, 600, 1600, 0x100000,
  100, 0,                            // 100hz, non-interlaced
  5,                                 // montype
  0x1203, 0x05A4, 0,    // sge01     // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x65},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600_64k, NULL },
},      //myf1, 50



//
// VGA Color graphics,        1024x768 64k colors. 2K scan line
//
// ----- 1024x768x64K@43i ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  43, 1,                             // 43hz, interlaced
  5,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0 },
},      //myf1, 51

//
// VGA Color graphics,        1024x768 64k colors. 2K scan line
//
// ----- 1024x768x64K@60Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  60, 0,                             // 60hz, non-interlaced
  5,                                 // montype
  0x1203, 0x10A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0 },
},      //myf1, 52


//
// VGA Color graphics,        1024x768 64k colors. 2K scan line
//
// ----- 1024x768x64K@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  70, 0,                             // 70hz, non-interlaced
  6,                                 // montype
  0x1203, 0x20A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0 },
},      //myf1, 53


//
// VGA Color graphics,        1024x768 64k colors. 2K scan line
//
// ----- 1024x768x64K@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  75, 0,                             // 75hz, non-interlaced
  7,                                 // montype
  0x1203, 0x40A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL754x | CL755x | CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0 },
},      //myf1, 54


// 1024x768 64k colors. 85Hz non-interlaced
//
// ----- 1024x768x64K@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  85, 0,                             // 85hz, non-interlaced
  7,                                 // montype
  0x1203, 0x50A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,        //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0,
    NULL},
},      //myf1, 55


// ----- 1024x768x64K@100Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 128, 48,
  1024, 768, 2048, 0x200000,
  100, 0,                            // 100hz, non-interlaced
  7,                                 // montype
  0x1203, 0x60A4, 0,    // sge01     // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x74},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_1024x768_64k, 0,
    NULL},
},      //myf1, 56


// crus
// 1152x864 64k colors. 70Hz non-interlaced
//
// ----- 1152x864x64K@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 144, 54,
  1152, 864, 2304, 0x200000,
  70, 0,                             // 70Hz, non-interlaced
  7,                                 // montype
  0x1203, 0x00A4, 0x0000,            // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446BE | CL5480,        // jl02
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7d },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 57

// crus
// 1152x864 64k colors. 75Hz non-interlaced
//
// ----- 1152x864x64K@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 144, 54,
  1152, 864, 2304, 0x200000,
  75, 0,                             // 75Hz, non-interlaced
  7,                                 // montype
  0x1203, 0x00A4, 0x0100,            // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446BE | CL5480,        // jl02
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7d },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 58


// ----- 1152x864x64K@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 144, 54,
  1152, 864, 2304, 0x200000,
  85, 0,                             // 85Hz, non-interlaced
  7,                                 // montype
  0x1203, 0x00A4, 0x0200,   // sge01 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7d },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 59


// ----- 1152x864x64K@100Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 144, 54,
  1152, 864, 2304, 0x200000,
  100, 0,                            // 100Hz, non-interlaced
  7,                                 // montype
  0x1203, 0x00A4, 0x0300,   // sge01 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7d },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 60


// crus
//
// 1280x1024 interlaced 64k colors, 43Hz interleaced
// Assumes 3 MB required.
//
// ----- 1280x1024x64K@43i --------------------------------------------------

#if 1
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x300000,        // 0x400000
  43, 1,                             // 43Hz, interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x0000,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL543x | CL5434 | CL5434_6 | CL5436 | CL5446 | CL5446BE | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 61
#endif


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x400000,        // 0x400000
  43, 1,                             // 43Hz, interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x0000,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480 | CL7556,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 62


// ----- 1280x1024x64K@60Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x400000,        // 0x400000
  60, 0,                             // 60Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x1000,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446BE | CL5480 | CL7556,                 // jl02
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 63


// ----- 1280x1024x64K@75Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x400000,        // 0x400000
  75,   0,                             // 75Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x3000,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 64


// ----- 1280x1024x64K@85Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x400000,        // 0x400000
  85, 0,                             // 85Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x4000,    //sge01   // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 65


// ----- 1280x1024x64K@100Hz ------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 160, 64,
  1280, 1024, 2560, 0x400000,        // 0x400000
  100, 0,                            // 100Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x5000,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x75 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, MODESET_75 },        // crus
},      //myf1, 66


//
// 1600x1200 64K colors.  (This mode doesn't seem to work!  ????? )
//
// ----- 1600x1200x64K@48i --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 200, 75,
  1600, 1200, 3200, 0x400000,
  48, 1,                            // 96Hz, interlaced
  7,                                // montype
  0x1204, 0xA4, 0x0000,             // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7F },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 67


// ----- 1600x1200x64K@60Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 200, 75,
  1600, 1200, 3200, 0x400000,
  60, 0,                            // 60Hz, non-interlaced
  7,                                // montype
  0x1204, 0xA4, 0x0400,    // sge01 // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7F },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 68


// ----- 1600x1200x64K@70Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 200, 75,
  1600, 1200, 3200, 0x400000,
  70, 0,                            // 70Hz, non-interlaced
  7,                                // montype
  0x1204, 0xA4, 0x0800,    // sge01 // montype
  FALSE,                            // hardware cursor disabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                            // ModeValid default is always off
  TRUE,
  { 0,0,0x7F },                     // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 69


#if 1
// added 24bpp mode tables

// ----- 640x480x16M@60Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 1920, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
//myf0  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,  //myf0
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
// crus
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480x16M, 0 },
},      //myf1, 70


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 2048, 0x100000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
//  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,
  CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,         //myf0
// crus
  crt | panel | panel8x6 | panel10x7,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},

<----- */



// ----- 640x480x16M@72Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 1920, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
//  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480x16M, 0 },
},      //myf1, 71


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 2048, 0x100000,
  72, 0,                             // 72hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
//  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,
  CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},

<----- */


// ----- 640x480x16M@75Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 1920, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
//  CL754x | CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480x16M, 0 },
},      //myf1, 72


/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 2048, 0x100000,
  75, 0,                             // 75hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
// crus
  CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},

<----- */



// ----- 640x480x16M@85Hz ---------------------------------------------------


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 1920, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480x16M, 0 },
},      //myf1, 73



/* ----->

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 2048, 0x100000,
  85, 0,                             // 85hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL54UM36 | CL5480,        //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},

<----- */


// ----- 640x480x16M@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 1920, 0x100000,
  100, 0,                            // 100hz, non-interlaced
  3,                                 // montype
  0x1213, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x71},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_640x480x16M, 0 },
},      //myf1, 74



// ----- 800x600x16M@56Hz ------------------- MYF TEST ----------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  56, 0,                             // 56hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                    // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 75



/* -----> MYF TEST

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
//  800, 600, 3072, 0x200000,
  800, 600, 2560, 0x177000,     //myf25
  56, 0,                             // 56hz, non-interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                    // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
//  NULL, NULL, 0 },
    NULL, CL543x_800x600x16M_1, 0 },    //myf25
},

<----- */


// ----- 800x600x16M@60Hz ---------------------- MYF TEST -------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 76



/* -----> MYF TEST

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
//  800, 600, 3072, 0x200000,
  800, 600, 2560, 0x177000,     //myf25
  60, 0,                             // 60hz, non-interlaced
  3,                                 // montype
  0x1203, 0x01A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
#ifdef PANNING_SCROLL   //myf17
  crt | panel | panel8x6 | panel10x7,
#else
  crt | panel8x6 | panel10x7,
#endif
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
//  NULL, NULL, 0 },
    NULL, CL543x_800x600x16M_1, 0 },    //myf25
},

<----- */


// ----- 800x600x16M@72Hz ---------------------- MYF TEST -------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  72, 0,                             // 72hz, non-interlaced
  3,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 77



/* -----> MYF TEST

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
//  800, 600, 3072, 0x200000,
  800, 600, 2560, 0x177000,     //myf25
  72, 0,                             // 72hz, non-interlaced
  3,                                 // montype
  0x1203, 0x02A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
//  NULL, NULL, 0 },
    NULL, CL543x_800x600x16M_1, 0 },    //myf25
},

<----- */


// ----- 800x600x16M@75Hz ---------------------- MYF TEST -------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  75, 0,                             // 75hz, non-interlaced
  3,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 78



/* -----> MYF TEST

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
//  800, 600, 3072, 0x200000,
  800, 600, 2560, 0x177000,     //myf25
  75, 0,                             // 75hz, non-interlaced
  3,                                 // montype
  0x1203, 0x03A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
//  NULL, NULL, 0 },
    NULL, CL543x_800x600x16M_1, 0 },    //myf25
},

<----- */


// ----- 800x600x16M@85Hz ---------------------- MYF TEST -------------------


{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  85, 0,                             // 85hz, non-interlaced
  3,                                 // montype
  0x1203, 0x04A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,      //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 79



/* -----> MYF TEST

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
//  800, 600, 3072, 0x200000,
  800, 600, 2560, 0x177000,     //myf25
  85, 0,                             // 85hz, non-interlaced
  3,                                 // montype
  0x1203, 0x04A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL755x | CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,         //myf0
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
//  NULL, NULL, 0 },
    NULL, CL543x_800x600x16M_1, 0 },    //myf25
},

<----- */


// ----- 800x600x16M@100Hz ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 100, 37,
  800, 600, 2400, 0x200000,
  100, 0,                            // 100Hz, non-interlaced
  3,                                 // montype
  0x1203, 0x05A4, 0,    // sge01     // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x78},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, CL543x_800x600x16M, 0 },
},      //myf1, 80



// ----- 1024x768x16M@43i ---------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  1024, 768, 3072, 0x300000,
  43, 1,                             // 43Hz, interlaced
  3,                                 // montype
  0x1203, 0x00A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480 | CL7556,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 81


// ----- 1024x768x16M@60Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  60, 0,                             // 60Hz, non-interlaced
  3,                                 // montype
  0x1203, 0x10A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480 | CL7556,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 82




// ----- 1024x768x16M@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  70, 0,                             // 70Hz, non-interlaced
  3,                                 // montype
  0x1203, 0x20A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5446 | CL5446BE | CL5480 | CL7556,        // jl04
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},


// ----- 1024x768x16M@72Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  72, 0,                             // 72Hz, non-interlaced
  3,                                 // montype
  0x1203, 0x30A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5436,                            // jl04
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 83


// ----- 1024x768x16M@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  75, 0,                             // 75Hz, non-interlaced
  3,                                 // montype
  0x1203, 0x40A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 84


// ----- 1024x768x16M@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  85, 0,                             // 85hz, non-interlaced
  3,                                 // montype
  0x1203, 0x50A4, 0,                 // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5436 | CL5446 | CL5446BE | CL54UM36 | CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 85


// ----- 1024x768x16M@100Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 128, 48,
  1024, 768, 3072, 0x300000,
  100, 0,                            // 85hz, non-interlaced
  3,                                 // montype
  0x1203, 0x60A4, 0,    // sge01     // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x79},                       // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 86



// ----- 1152x864x16M@70Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 144, 54,
  1152, 864, 3456, 0x400000,
  70, 0,                             // 70hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0000,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7E },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 87


// ----- 1152x864x16M@75Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 144, 54,
  1152, 864, 3456, 0x400000,
  75, 0,                             // 75hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0100,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7E },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 88


// ----- 1152x864x16M@85Hz --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 144, 54,
  1152, 864, 3456, 0x400000,
  85, 0,                             // 75hz, non-interlaced
  7,                                 // montype
  0x1203, 0xA4, 0x0200,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x7E },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },
},      //myf1, 89



// ----- 1280x1024x16M@43i --------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 160, 64,
  1280, 1024, 3840, 0x400000,        // 0x400000
  43, 1,                             // 43Hz, interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x0000,              // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x77 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },        // crus
},      //myf1, 90


// ----- 1280x1024x16M@60Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 160, 64,
  1280, 1024, 3840, 0x400000,        // 0x400000
  60, 0,                             // 60Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x1000,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x77 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },        // crus
},      //myf1, 91


// ----- 1280x1024x16M@75Hz -------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 160, 64,
  1280, 1024, 3840, 0x400000,        // 0x400000
  75, 0,                             // 75Hz, non-interlaced
  0,                                 // montype
  0x1203, 0xA4, 0x3000,    // sge01  // montype
  TRUE,                              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
  CL5480,
  crt,
  FALSE,                             // ModeValid default is always off
  TRUE,
  { 0,0,0x77 },                      // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0 },        // crus
},      //myf1, 92

#endif // added 24bpp mode tables





//
// VGA Color graphics,        640x480, 32 bpp, broken rasters
//
// ----- 640x480x16M --------------------------------------------------------

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 32, 80, 30,
  640, 480, 640*4, 0x200000,
  60, 0,              // 60hz, non-interlaced
  4,                  // montype
  0x1213, 0x00A4, 0,  // montype
  TRUE,              // hardware cursor enabled for this mode
  PlanarHCBanking, MemMap_VGA,
//myf9  CL754x | CL755x | CL5434 | CL5434_6,
  CL5434 | CL5434_6,
//myf9  crt | panel | panel8x6 | panel10x7,
  crt,
  FALSE,                // ModeValid default is always off
  TRUE,
  { 0,0,0x76},          // int10 BIOS modes
  { NULL, NULL,
    NULL, NULL,
    NULL, NULL, 0,
    NULL },
},      //myf1, 93

};

ULONG NumVideoModes = sizeof(ModesVGA) / sizeof(VIDEOMODE);


//
//
// Data used to set the Graphics and Sequence Controllers to put the
// VGA into a planar state at A0000 for 64K, with plane 2 enabled for
// reads and writes, so that a font can be loaded, and to disable that mode.
//

// Settings to enable planar mode with plane 2 enabled.
//

USHORT EnableA000Data[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0204,     // Read Map = plane 2
    0x0005, // Graphics Mode = read mode 0, write mode 0
    0x0406, // Graphics Miscellaneous register = A0000 for 64K, not odd/even,
            //  graphics mode
    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0402, // Map Mask = write to plane 2 only
    0x0404, // Memory Mode = not odd/even, not full memory, graphics mode
    0x0300,  // end sync reset
    EOD
};

//
// Settings to disable the font-loading planar mode.
//

USHORT DisableA000Color[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0004, 0x1005, 0x0E06,

    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0302, 0x0204, 0x0300,  // end sync reset
    EOD

};

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\clddk.h ===
//
// This contains declarations from ntddk.h that we need.  Unfortunately,
// we can't easily include ntddk.h since it conflicts with other
// header files.  So, we'll include the needed support here.  Hopefully,
// we'll find a better solution soon.
//

typedef LONG NTSTATUS;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;

typedef UNICODE_STRING *PUNICODE_STRING;

//
// Subroutines for dealing with the Registry
//

typedef NTSTATUS (*PRTL_QUERY_REGISTRY_ROUTINE)(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

typedef struct _RTL_QUERY_REGISTRY_TABLE {
    PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
    ULONG Flags;
    PWSTR Name;
    PVOID EntryContext;
    ULONG DefaultType;
    PVOID DefaultData;
    ULONG DefaultLength;

} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;


//
// The following flags specify how the Name field of a RTL_QUERY_REGISTRY_TABLE
// entry is interpreted.  A NULL name indicates the end of the table.
//

#define RTL_QUERY_REGISTRY_SUBKEY   0x00000001  // Name is a subkey and remainder of
                                                // table or until next subkey are value
                                                // names for that subkey to look at.

#define RTL_QUERY_REGISTRY_TOPKEY   0x00000002  // Reset current key to original key for
                                                // this and all following table entries.

#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004  // Fail if no match found for this table
                                                // entry.

#define RTL_QUERY_REGISTRY_NOVALUE  0x00000008  // Used to mark a table entry that has no
                                                // value name, just wants a call out, not
                                                // an enumeration of all values.

#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010  // Used to suppress the expansion of
                                                // REG_MULTI_SZ into multiple callouts or
                                                // to prevent the expansion of environment
                                                // variable values in REG_EXPAND_SZ

#define RTL_QUERY_REGISTRY_DIRECT   0x00000020  // QueryRoutine field ignored.  EntryContext
                                                // field points to location to store value.
                                                // For null terminated strings, EntryContext
                                                // points to UNICODE_STRING structure that
                                                // that describes maximum size of buffer.
                                                // If .Buffer field is NULL then a buffer is
                                                // allocated.
                                                //

#define RTL_QUERY_REGISTRY_DELETE   0x00000040  // Used to delete value keys after they
                                                // are queried.

#define REG_DWORD                   ( 4 )   // 32-bit number

#define RTL_REGISTRY_ABSOLUTE     0   // Path is a full path
#define RTL_REGISTRY_OPTIONAL     0x80000000    // Indicates the key node is optional

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

__declspec(dllimport)
NTSTATUS
__stdcall
RtlQueryRegistryValues(
     ULONG RelativeTo,
     PWSTR Path,
     PRTL_QUERY_REGISTRY_TABLE QueryTable,
     PVOID Context,
     PVOID Environment
    );

__declspec(dllimport)
NTSTATUS
__stdcall
RtlWriteRegistryValue(
     ULONG RelativeTo,
     PWSTR Path,
     PWSTR ValueName,
     ULONG ValueType,
     PVOID ValueData,
     ULONG ValueLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\cirrus.c ===
//---------------------------------------------------------------------------
/*++

Copyright (c) 1992-1997  Microsoft Corporation.
Copyright (c) 1996-1997  Cirrus Logic, Inc.,

Module Name:

    C   I   R   R   U   S  .  C

Abstract:

    This is the miniport driver for the Cirrus Logic
    6410/6420/542x/543x/544x/548x/754x/755x VGA's.

Environment:

    Kernel mode only

Notes:

Revision History:

* $Log:   S:/projects/drivers/ntsrc/miniport/cirrus.c_v  $
 *
 *    Rev 1.16   Apr 03 1997 15:44:40   unknown
 *
 *
 *    Rev 1.10   Jan 08 1997 14:25:40   unknown
 * Fix the 440FX and 5446AC coexist problem.
 *
 *    Rev 1.9   18 Dec 1996 14:03:48   PLCHU
 *
 *
 *    Rev 1.7   Dec 06 1996 11:14:16   unknown
 *
 *
 *    Rev 1.6   Nov 26 1996 16:29:02   unknown
 *
 *
 *    Rev 1.8   Nov 26 1996 16:02:20   unknown
 * Add conditional compile for P6Cache
 *
 *    Rev 1.7   Nov 26 1996 14:32:42   unknown
 * turn on PCI14 and second aperture for 5480
 *
 *    Rev 1.6   Nov 18 1996 16:23:32   unknown
 * Add P6 Cache flag and fix 5436BG hung bug for HCT
 *
 *    Rev 1.5   Nov 05 1996 14:49:56   unknown
 * turn off PCI14 for 5480 temporaryly
 *
 *    Rev 1.4   Nov 01 1996 16:44:54   unknown
*
*    Rev 1.3   Oct 14 1996 10:49:36   unknown
* Add 100Hz monitor support and Detailed timnig calculation
*
*    Rev 1.4   07 Aug 1996 14:43:02   frido
* Added better support for monochrome text modes.
*
*    Rev 1.3   06 Aug 1996 18:35:54   frido
* Changed the way the video memory is shared in linear mode.
*
*    Rev 1.2   06 Aug 1996 17:19:20   frido
* Removed banking in linear mode.
*
*   chu01  08-26-96   Distinguish CL-5480 and CL-5436/46 because the former
*                     has new fratures such as XY-clipping, XY-position and
*                     BLT command list that the others do not have.
*   jl01   09-24-96   Fix Alt+Tab switching between "Introducing Windows NT"
*                     and "Main".  Refer to PDR#5409.
*   jl02   10-21-96   Add CL-5446BE support.
*   sge01  10-14-96   VGA register and MMIO register can be relocatable.
*   sge02  10-22-96   VideoMemoryAddress use linear address instead of A0000.
*   sge03  10-23-96   Add second aperture maping
*   chu02  10-31-96   DDC2B enabling / disabling
*   sge04  11-04-96   Disable PCI14 for 5480 temporaryly
*   sge05  11-07-96   Add P6Cache support
*   sge06  11-26-96   Add conditional compile for P6Cache support
*   jl03   12-05-96   Set CL-5446BE flag "CL5446BE"
*   chu03  12-16-96   Enable color correction
*   sge07  12-16-96   Check mono or color mode before reading input status
*   sge08  01-08-97   Fix the 440FX and 5446AC coexist problem.
*   myf0   08-19-96   added 85hz supported
*   myf1   08-20-96   supported panning scrolling
*   myf2   08-20-96   fixed hardware save/restore state bug for matterhorn
*   myf3   09-01-96   Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
*   myf4   09-01-96   patch Viking BIOS bug, PDR #4287, begin
*   myf5   09-01-96   Fixed PDR #4365 keep all default refresh rate
*   myf6   09-17-96   Merged Desktop SRC1001 & MINI102
*   myf7   09-19-96   Fixed exclude 60Hz refresh rate select
*   myf8  *09-21-96*  May be need change CheckandUpdateDDC2BMonitor --keystring[]
*   myf9   09-21-96   8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
*   ms0809 09-25-96   fixed dstn panel icon corrupted
*   ms923  09-25-96   merge MS-923 Disp.zip code
*   myf10  09-26-96   Fixed DSTN reserved half-frame buffer bug.
*   myf11  09-26-96   Fixed 755x CE chip HW bug, access ramdac before disable HW
*                     icons and cursor
*   myf12  10-01-96   Supported Hot Key switch display
*   myf13  10-05-96   Fixed /w panning scrolling, vertical expension on bug
*   myf14  10-15-96   Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
*   myf15  10-16-96   Fixed disable memory mapped IO for 754x, 755x
*   myf16  10-22-96   Fixed PDR #6933,panel type set different demo board setting
*   smith  10-22-96   Disable Timer event, because sometimes creat PAGE_FAULT or
*                     IRQ level can't handle
*   myf17  11-04-96   Added special escape code must be use 11/5/96 later NTCTRL,
*                     and added Matterhorn LF Device ID==0x4C
*   myf18  11-04-96   Fixed PDR #7075,
*   myf19  11-06-96   Fixed Vinking can't work problem, because DEVICEID = 0x30
*                     is different from data book (CR27=0x2C)
*   myf20  11-12-96   Fixed DSTN panel initial reserved 128K memoru
*   myf21  11-15-96   fixed #7495 during change resolution, screen appear garbage
*                     image, because not clear video memory.
*   myf22  11-19-96   Added 640x480x256/640x480x64K -85Hz refresh rate for 7548
*   myf23  11-21-96   Added fixed NT 3.51 S/W cursor panning problem
*   myf24  11-22-96   Added fixed NT 4.0 Japanese dos full screen problem
*   myf25  12-03-96   Fixed 8x6x16M 2560byte/line patch H/W bug PDR#7843, and
*                     fixed pre-install microsoft requested
*   myf26  12-11-96   Fixed Japanese NT 4.0 Dos-full screen bug for LCD enable
*   myf27  01-09-96   Fixed NT3.51 PDR#7986, horizontal lines appears at logon
*                     windows, set 8x6x64K mode boot up CRT, jumper set 8x6 DSTN
*                     Fixed NT3.51 PDR#7987, set 64K color modes, garbage on
*                     screen when boot up XGA panel.
*   myf28  02-03-97   Fixed NT3.51 PDR#8357, mode 3, 12, panning scrolling bug
*   myf29  02-12-97   Support Gamma correction graphic/video LUT for 755x
*   myf30  02-10-97   Fixed NT3.51, 6x4 LCD boot set 256 coloe, test 64K mode
*   jl04   02-11-97   Fix 542x VLB banking issue.
*   myf31  02-25-97   Fixed RadiSys system, set MCLK to 66MHz
*   myf32  03-02-97   Display each chip information
*   sge09  03-10-97   Add P6CACHE condition compile.
*   chu04  03-10-97   Chip type "5430/40", instead of "5430" requested by Intel.
*   chu05  03-13-97   For 5436 checked build NT, read 4-byte PCI
*                     configuration register to access index 0x53 instead of
*                     the whole 256 bytes.
*   chu06  03-26-97   Common routine to get Cirrus chip and revision IDs.
*   jl05   03-28-97   Fix for NT3.51
--*/
//---------------------------------------------------------------------------

#include <dderror.h>
#include <devioctl.h>
#include <miniport.h>

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"

#include "clioctl.h"

#include "sr754x.h"
#include "cmdcnst.h"

#define DDC2B  1

#define QUERY_MONITOR_ID            0x22446688
#define QUERY_NONDDC_MONITOR_ID     0x11223344


#define LCD_type        1
#define CRT_type        2
#define SIM_type        3

//---------------------------------------------------------------------------
//
// Function declarations
//
// Functions that start with 'VGA' are entry points for the OS port driver.
//

VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//crus, smith
VOID
CirrusHwTimer(
    PVOID HwDeviceExtension
    );

//
// Private function prototypes.
//

VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    );

#ifdef PANNING_SCROLL
VP_STATUS
CirrusSetDisplayPitch (
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PANNMODE PanningMode
   );
#endif

VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    );

VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    );

BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
CirrusLogicIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

ULONG
CirrusFindVmemSize(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
CirrusValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
SetCirrusBanking(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT BankNumber
    );

VOID
vBankMap_CL64xx(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    );

VOID
vBankMap_CL543x(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    );

VOID
vBankMap_CL542x(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    );

USHORT
CirrusFind6410DisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

USHORT
CirrusFind6245DisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort,
    PUCHAR CRTCDataPort
    );

USHORT
CirrusFind754xDisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort,
    PUCHAR CRTCDataPort
    );

USHORT
CirrusFind755xDisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort,
    PUCHAR CRTCDataPort
    );

BOOLEAN
CirrusFind6340(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
AccessHWiconcursor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    SHORT Access_flag
    );


VOID
VgaInterpretCmdStream(
    PVOID HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    );

VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    );

VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    );

VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    );

BOOLEAN
CirrusConfigurePCI(
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PULONG NumPCIAccessRanges,
   PVIDEO_ACCESS_RANGE PCIAccessRanges
   );

VOID
WriteRegistryInfo(
   PHW_DEVICE_EXTENSION hwDeviceExtension
   );

VP_STATUS
CirrusGetDeviceDataCallback(
   PVOID HwDeviceExtension,
   PVOID Context,
   VIDEO_DEVICE_DATA_TYPE DeviceDataType,
   PVOID Identifier,
   ULONG IdentifierLength,
   PVOID ConfigurationData,
   ULONG ConfigurationDataLength,
   PVOID ComponentInformation,
   ULONG ComponentInformationLength
   );

VOID
IOWaitDisplEnableThenWrite(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG port,
    UCHAR value
    );

VOID
ReadVESATiming(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

#if (_WIN32_WINNT <= 0x0400)
VOID
CheckAndUpdateDDC2BMonitor(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );
#endif // (_WIN32_WINNT <= 0x0400)

VOID
CirrusUpdate440FX(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//
// NOTE:
//
// This is a High Priority system callback.  DO NOT mark this
// routine as pageable!
//

BOOLEAN
IOCallback(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
VgaGetGammaFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PGAMMA_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

VP_STATUS
VgaGetContrastFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCONTRAST_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

UCHAR
GetCirrusChipId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

USHORT
GetCirrusChipRevisionId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,VgaFindAdapter)
#pragma alloc_text(PAGE,VgaInitialize)
#pragma alloc_text(PAGE,VgaStartIO)
#pragma alloc_text(PAGE,CirrusHwTimer)
#pragma alloc_text(PAGE,VgaLoadAndSetFont)
#pragma alloc_text(PAGE,VgaQueryCursorPosition)
#pragma alloc_text(PAGE,VgaSetCursorPosition)
#pragma alloc_text(PAGE,VgaQueryCursorAttributes)
#pragma alloc_text(PAGE,VgaSetCursorAttributes)
#pragma alloc_text(PAGE,VgaIsPresent)
#pragma alloc_text(PAGE,CirrusLogicIsPresent)
#pragma alloc_text(PAGE,CirrusFindVmemSize)
#pragma alloc_text(PAGE,SetCirrusBanking)

#ifdef PANNING_SCROLL
#pragma alloc_text(PAGE,CirrusSetDisplayPitch)
#endif
#pragma alloc_text(PAGE,CirrusFind6245DisplayType)
#pragma alloc_text(PAGE,CirrusFind754xDisplayType)
#pragma alloc_text(PAGE,CirrusFind755xDisplayType)
#pragma alloc_text(PAGE,CirrusFind6410DisplayType)
#pragma alloc_text(PAGE,CirrusFind6340)
#pragma alloc_text(PAGE,AccessHWiconcursor)
#pragma alloc_text(PAGE,CirrusConfigurePCI)
#pragma alloc_text(PAGE,VgaSetPaletteReg)
#pragma alloc_text(PAGE,VgaSetColorLookup)
#pragma alloc_text(PAGE,VgaRestoreHardwareState)
#pragma alloc_text(PAGE,VgaSaveHardwareState)
#pragma alloc_text(PAGE,VgaGetBankSelectCode)

#pragma alloc_text(PAGE,VgaValidatorUcharEntry)
#pragma alloc_text(PAGE,VgaValidatorUshortEntry)
#pragma alloc_text(PAGE,VgaValidatorUlongEntry)

#pragma alloc_text(PAGE,WriteRegistryInfo)
#pragma alloc_text(PAGE,CirrusGetDeviceDataCallback)
#pragma alloc_text(PAGE,CirrusUpdate440FX)

#pragma alloc_text(PAGE,VgaGetGammaFactor)
#pragma alloc_text(PAGE,VgaGetContrastFactor)

#if (_WIN32_WINNT >= 0x0500)
#pragma alloc_text(PAGE,CirrusGetChildDescriptor)
#pragma alloc_text(PAGE,CirrusGetPowerState)
#pragma alloc_text(PAGE,CirrusSetPowerState)
#endif

#endif

BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG BufferSize);

ULONG
CirrusGetChildDescriptor(
    PVOID pHwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )

/*++

Routine Description:

    Enumerate all devices controlled by the ATI graphics chip.
    This includes DDC monitors attached to the board, as well as other devices
    which may be connected to a proprietary bus.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    ChildIndex        - Index of the child the system wants informaion for.

    pChildType        - Type of child we are enumerating - monitor, I2C ...

    pChildDescriptor  - Identification structure of the device (EDID, string)

    ppHwId            - Private unique 32 bit ID to passed back to the miniport

    pMoreChildren     - Should the miniport be called

Return Value:

    Status from VideoPortInitialize()

Note:

    In the event of a failure return, none of the fields are valid except for
    the return value and the pMoreChildren field.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = pHwDeviceExtension;
    ULONG Status;

    switch (ChildEnumInfo->ChildIndex) {
    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // Since we do not support ACPI devices yet, we must return failure.
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case 1:

        //
        // This is the last device we enumerate.  Tell the system we don't
        // have any more.
        //

        *pChildType = Monitor;

        //
        // Obtain the EDID structure via DDC.
        //

        if (GetDdcInformation(hwDeviceExtension,
                              pChildDescriptor,
                              ChildEnumInfo->ChildDescriptorSize))
        {
            *pHwId = QUERY_MONITOR_ID;

            VideoDebugPrint((1, "CirrusGetChildDescriptor - successfully read EDID structure\n"));

        } else {

            //
            // Alway return TRUE, since we always have a monitor output
            // on the card and it just may not be a detectable device.
            //

            *pHwId = QUERY_NONDDC_MONITOR_ID;

            VideoDebugPrint((1, "CirrusGetChildDescriptor - DDC not supported\n"));

        }

        Status = ERROR_MORE_DATA;
        break;


    case DISPLAY_ADAPTER_HW_ID:

        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;

        memcpy(pChildDescriptor, hwDeviceExtension->LegacyPnPId, 8*sizeof(WCHAR));

        Status = ERROR_MORE_DATA;
        break;


    default:

        Status = ERROR_NO_MORE_DEVICES;
        break;
    }

    return Status;
}

VP_STATUS
CirrusGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Returns power state information.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwDeviceId        - Private unique 32 bit ID identifing the device.

    VideoPowerManagement - Power state information.

Return Value:

    TRUE if power state can be set,
    FALSE otherwise.

--*/

{
    //
    // We only support power setting for the monitor.  Make sure the
    // HwDeviceId matches one the the monitors we could report.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        //
        // We are querying the power support for the monitor.
        //

        if ((VideoPowerManagement->PowerState == VideoPowerOn) ||
            (VideoPowerManagement->PowerState == VideoPowerHibernate)) {
	
            return NO_ERROR;
        }

        switch (VideoPowerManagement->PowerState) {
	
        case VideoPowerStandBy:
            return (HwDeviceExtension->PMCapability & VESA_POWER_STANDBY) ?
                   NO_ERROR : ERROR_INVALID_FUNCTION;
	
        case VideoPowerSuspend:
            return (HwDeviceExtension->PMCapability & VESA_POWER_SUSPEND) ?
                   NO_ERROR : ERROR_INVALID_FUNCTION;
	
        case VideoPowerOff:
            return (HwDeviceExtension->PMCapability & VESA_POWER_OFF) ?
                   NO_ERROR : ERROR_INVALID_FUNCTION;
	
        default:
            break;
        }

        VideoDebugPrint((1, "This device does not support Power Management.\n"));
        return ERROR_INVALID_FUNCTION;

    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        //
        // We are querying power support for the graphics card.
        //

        switch (VideoPowerManagement->PowerState) {

            case VideoPowerOn:
            case VideoPowerHibernate:
            case VideoPowerStandBy:

                return NO_ERROR;

            case VideoPowerOff:
            case VideoPowerSuspend:

                if ((HwDeviceExtension->ChipType & CL754x) ||
                    (HwDeviceExtension->ChipType & CL755x) ||
                    (HwDeviceExtension->ChipType & CL756x)) {

                    //
                    // We will allow the system to go into S3 sleep state
                    // for machines with laptop chipsets.  The system
                    // bios will be responsible for re-posting on wake up.
                    //

                    return NO_ERROR;

                } else {

                    //
                    // Indicate that we can't do VideoPowerOff, because
                    // we have no way of coming back when power is re-applied
                    // to the card.
                    //

                    return ERROR_INVALID_FUNCTION;
                }

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_FUNCTION;
        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}

VP_STATUS
CirrusSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Set the power state for a given device.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwDeviceId        - Private unique 32 bit ID identifing the device.

    VideoPowerManagement - Power state information.

Return Value:

    TRUE if power state can be set,
    FALSE otherwise.

--*/

{
    //
    // Make sure we recognize the device.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = VESA_POWER_FUNCTION;
        biosArguments.Ebx = VESA_SET_POWER_FUNC;

        switch (VideoPowerManagement->PowerState) {
        case VideoPowerOn:
        case VideoPowerHibernate:
            biosArguments.Ebx |= VESA_POWER_ON;
            break;

        case VideoPowerStandBy:
            biosArguments.Ebx |= VESA_POWER_STANDBY;
            break;

        case VideoPowerSuspend:
            biosArguments.Ebx |= VESA_POWER_SUSPEND;
            break;

        case VideoPowerOff:
            biosArguments.Ebx |= VESA_POWER_OFF;
            break;

        default:
            VideoDebugPrint((1, "Unknown power state.\n"));
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }

        VideoPortInt10(HwDeviceExtension, &biosArguments);

        //
        // I have no idea why, but on some machines after a while
        // the Pixel Mask Register gets set to zero.  Then when
        // we power back up, we can no longer see the screen.  It is
        // black.
        //
        // By setting the register here, we can prevent this
        // problem.  There should be no harmful side effects to
        // this.
        //

        if (VideoPowerManagement->PowerState == VideoPowerOn) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_PIXEL_MASK_PORT, 0xff);
        }

        return NO_ERROR;

    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        switch (VideoPowerManagement->PowerState) {

            case VideoPowerOn:
            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:
            case VideoPowerHibernate:

                return NO_ERROR;

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;
        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}


//---------------------------------------------------------------------------
ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls 3VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG initializationStatus = (ULONG) -1;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = VgaFindAdapter;
    hwInitData.HwInitialize = VgaInitialize;
    hwInitData.HwInterrupt = NULL;
    hwInitData.HwStartIO = VgaStartIO;

#if (_WIN32_WINNT>= 0x0500)

    hwInitData.HwGetVideoChildDescriptor = CirrusGetChildDescriptor;
    hwInitData.HwGetPowerState = CirrusGetPowerState;
    hwInitData.HwSetPowerState = CirrusSetPowerState;

    hwInitData.HwLegacyResourceList = VgaAccessRange;
    hwInitData.HwLegacyResourceCount = 3;

#endif

    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Always start with parameters for device0 in this case.
    // We can leave it like this since we know we will only ever find one
    // VGA type adapter in a machine.
    //

    // hwInitData.StartingDeviceNumber = 0;

    //
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    // For this device we will repeat this call three times, for ISA, EISA
    // and PCI.
    // We will return the minimum of all return values.
    //

    //
    // We will try the PCI bus first so that our ISA detection does'nt claim
    // PCI cards (since it is impossible to differentiate between the two
    // by looking at the registers).
    //

    //
    // NOTE: since this driver only supports one adapter, we will return
    // as soon as we find a device, without going on to the following buses.
    // Normally one would call for each bus type and return the smallest
    // value.
    //

    hwInitData.AdapterInterfaceType = PCIBus;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }

    hwInitData.AdapterInterfaceType = MicroChannel;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    //
    // Return immediately instead of checkin for smallest return code.
    //

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }


    hwInitData.AdapterInterfaceType = Isa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }


    hwInitData.AdapterInterfaceType = Eisa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }


    hwInitData.AdapterInterfaceType = Internal;

    status = VideoPortInitialize(Context1,
                                 Context2,
                                 &hwInitData,
                                 NULL);

    if (initializationStatus > status) {
        initializationStatus = status;
    }

    return initializationStatus;

} // end DriverEntry()


//---------------------------------------------------------------------------
VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize(). Must be NULL for PnP drivers.

    ArgumentString - Supplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any known configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    ULONG NumAccessRanges = NUM_VGA_ACCESS_RANGES;
    ULONG VESATimingBits ;

    VIDEO_ACCESS_RANGE AccessRangesTemp[5];

    //
    // if there are two cirrus cards and the one that is disabled is the second
    // one FindAdapter is called for, then we need to avoid writing to the global
    // VgaAccessRange. So make local copy of it
    //

    VideoPortMoveMemory((PUCHAR) AccessRangesTemp,
                        (PUCHAR) VgaAccessRange,
                        5*sizeof(VIDEO_ACCESS_RANGE));

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store the bus type
    //

    hwDeviceExtension->BusType = ConfigInfo->AdapterInterfaceType;

    //
    // Assign pfnVideoPortReadXxx and pfnVideoPortWriteXxx
    //

    hwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUchar   = VideoPortReadPortUchar   ;
    hwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUshort  = VideoPortReadPortUshort  ;
    hwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUlong   = VideoPortReadPortUlong   ;
    hwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUchar  = VideoPortWritePortUchar  ;
    hwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUshort = VideoPortWritePortUshort ;
    hwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUlong  = VideoPortWritePortUlong  ;

    //
    // Detect the PCI card.
    //

    if (ConfigInfo->AdapterInterfaceType == PCIBus)
    {
        VideoDebugPrint((1, "Cirrus!VgaFindAdapter: "
                            "ConfigInfo->AdapterInterfaceType == PCIBus\n"));//1

        if (!CirrusConfigurePCI(HwDeviceExtension,
                                &NumAccessRanges,
                                AccessRangesTemp))
        {
            VideoDebugPrint((1, "Failure Returned From CirrusConfigurePCI\n"));//1
            return ERROR_DEV_NOT_EXIST;
        }
    }
    else
    {
        VideoDebugPrint((1, "Cirrus!VgaFindAdapter: "
                            "ConfigInfo->AdapterInterfaceType != PCIBus\n"));//1
    }

    //
    // No interrupt information is necessary.
    //

    if (AccessRangesTemp[3].RangeLength == 0)
    {
        //
        // The last access range (range[3]) is the access range for
        // the linear frame buffer.  If this access range has a
        // range length of 0, then some HAL's will fail the request.
        // Therefore, if we are not using the last access range,
        // I'll not try to reserve it.
        //

        NumAccessRanges--;
    }

    //
    // Check to see if there is a hardware resource conflict.
    // (or if card is disabled)
    //

    status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                         NumAccessRanges,
                                         AccessRangesTemp);

    if (status != NO_ERROR) {

        VideoDebugPrint((1, "ERROR: VPVerifyAccessRanges failed!\n"));

        return status;

    }

    //
    // VideoPortVerifyAccessRanges will fail for a card that is disabled.
    // This card is not disabled.  We can write to the global VgaAccessRange
    //

    VideoPortMoveMemory((PUCHAR) VgaAccessRange,
                        (PUCHAR) AccessRangesTemp,
                        NumAccessRanges*sizeof(VIDEO_ACCESS_RANGE));

    //
    // Get logical IO port addresses.
    //

    if (hwDeviceExtension->bMMAddress)
    {
        if ((hwDeviceExtension->IOAddress =
             VideoPortGetDeviceBase(hwDeviceExtension,
             VgaAccessRange[4].RangeStart,
             VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
             VgaAccessRange[4].RangeInIoSpace)) == NULL)
        {
            VideoDebugPrint((2, "VgaFindAdapter - Fail to get io address\n"));

            return ERROR_INVALID_PARAMETER;
        }

        hwDeviceExtension->IOAddress -= VGA_END_BREAK_PORT;
    }
    else
    {
        if ((hwDeviceExtension->IOAddress =
             VideoPortGetDeviceBase(hwDeviceExtension,
             VgaAccessRange->RangeStart,
             VGA_MAX_IO_PORT - VGA_BASE_IO_PORT + 1,
             VgaAccessRange->RangeInIoSpace)) == NULL)
        {
            VideoDebugPrint((2, "VgaFindAdapter - Fail to get io address\n"));

            return ERROR_INVALID_PARAMETER;
        }

        hwDeviceExtension->IOAddress -= VGA_BASE_IO_PORT;
    }

    //
    // Determine whether a VGA is present.
    //

    if (!VgaIsPresent(hwDeviceExtension)) {

        VideoDebugPrint((1, "CirrusFindAdapter - VGA Failed\n"));
        return ERROR_DEV_NOT_EXIST;
    }

    //
    // Minimum size of the buffer required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //

    ConfigInfo->HardwareStateSize = VGA_TOTAL_STATE_SIZE;

    //
    // now that we have the video memory address in protected mode, lets do
    // the required video card initialization. We will try to detect a Cirrus
    // Logic chipset...
    //

    //
    // Determine whether an CL6410/6420/542x/543x is present.
    //

    //
    // CirrusLogicIsPresent may set up the
    // hwDeviceExtesion->AdapterMemorySize field.  Set it
    // to 0 now, so I can compare against this later to
    // see if CirrusLogicIsPresent assigned a value.
    //

    hwDeviceExtension->AdapterMemorySize = 0;

    if (!CirrusLogicIsPresent(hwDeviceExtension))
    {
        VideoDebugPrint((1, "CirrusFindAdapter - Failed\n"));
        return ERROR_DEV_NOT_EXIST;
    }

    //
    // Pass a pointer to the emulator range we are using.
    //

    ConfigInfo->NumEmulatorAccessEntries = VGA_NUM_EMULATOR_ACCESS_ENTRIES;
    ConfigInfo->EmulatorAccessEntries = VgaEmulatorAccessEntries;
    ConfigInfo->EmulatorAccessEntriesContext = (ULONG_PTR) hwDeviceExtension;

    //
    // There is really no reason to have the frame buffer mapped. On an
    // x86 we use if for save/restore (supposedly) but even then we
    // would only need to map a 64K window, not all 16 Meg!
    //

#ifdef _X86_

    //
    // Map the video memory into the system virtual address space so we can
    // clear it out and use it for save and restore.
    //

    if ( (hwDeviceExtension->VideoMemoryAddress =
              VideoPortGetDeviceBase(hwDeviceExtension,
                                     VgaAccessRange[2].RangeStart,
                                     VgaAccessRange[2].RangeLength,
                                     FALSE)) == NULL)
    {
        VideoDebugPrint((1, "VgaFindAdapter - Fail to get memory address\n"));

        return ERROR_INVALID_PARAMETER;
    }

#endif

    //
    // Size the memory
    //

    //
    // The size may have been set up in detection code, so
    // don't destroy if already set.
    //

    if( hwDeviceExtension->AdapterMemorySize == 0 )
    {
        hwDeviceExtension->AdapterMemorySize =
            CirrusFindVmemSize(hwDeviceExtension);
    }

    //
    // Write hardware info into registry
    //

    WriteRegistryInfo(hwDeviceExtension);

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart = MEM_VGA;
    ConfigInfo->VdmPhysicalVideoMemoryLength = MEM_VGA_SIZE;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;


#if 0
// removed the following call. This fixes MS bug #163251
//#if DDC2B

    //
    // Check DDC2B monitor, get EDID table.
    // Turn on/off extended modes according the properties of the monitor.
    //

    // The miniport takes forever to load doing DDC on an
    // ISA 5434 in a DELL XPS P120c.
    // (IDEKIyama Vision Master 17 Monitor).
    //
    // Let only try to get DDC info on PCI cards for now.
    // CIRRUS - Can you fix this?

    if (ConfigInfo->AdapterInterfaceType == PCIBus) {
        ReadVESATiming ( hwDeviceExtension ) ;
    }

#endif

    //
    // Determines which modes are valid.
    //


#if DDC2B

    CirrusValidateModes(hwDeviceExtension);

#endif


#if (_WIN32_WINNT <= 0x0400)
    CheckAndUpdateDDC2BMonitor(hwDeviceExtension);
#endif (_WIN32_WINNT <= 0x0400)

    if (hwDeviceExtension->NumAvailableModes == 0)
    {
        VideoDebugPrint((1, "FindAdapter failed because there are no"
                            "available modes.\n"));

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Fix the 5446Ac and 440FX core logic coexist bug.
    //

    if (hwDeviceExtension->ChipType == CL5446)
    {
        CirrusUpdate440FX(hwDeviceExtension);
    }

    //
    // Once modes are validated, all 543x's are the same (the number
    // of modes available is the only difference).
    //

#if 0
//myf31: for RadiSYS special driver, change MCLK to 66MHz
    if (hwDeviceExtension->ChipType == CL7555)
    {
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                        SEQ_ADDRESS_PORT, 0x1F);
        SR1F = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                        SEQ_DATA_PORT) & 0xC0;
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                        SEQ_DATA_PORT, (SR1F | 0x25));
    }
//myf31 end
#endif


    if ((hwDeviceExtension->ChipType == CL5434) ||
        (hwDeviceExtension->ChipType == CL5434_6) ||
        (hwDeviceExtension->ChipType == CL5436) ||
        (hwDeviceExtension->ChipType == CL5446) ||
        (hwDeviceExtension->ChipType == CL5446BE) ||
        (hwDeviceExtension->ChipType == CL5480))

    {
        hwDeviceExtension->ChipType = CL543x;
    }

    //
    // Indicate we do not wish to be called again for another initialization.
    //

    *Again = 0;

    //
    // Indicate a successful completion status.
    //

    return NO_ERROR;

}


//---------------------------------------------------------------------------
BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/

{
    VP_STATUS status;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // Get the BIOS version number.
    //

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    biosArguments.Eax = 0x1200;
    biosArguments.Ebx = 0x81;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if (status == NO_ERROR)
    {
        hwDeviceExtension->ulBIOSVersionNumber = biosArguments.Eax;
    }
    else
        hwDeviceExtension->ulBIOSVersionNumber = 0;

    hwDeviceExtension->bBlockSwitch = 0;

    biosArguments.Eax = 0x1200;
    biosArguments.Ebx = 0x9A;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);
    hwDeviceExtension->bDisplaytype = CRT_type;

    if (status == NO_ERROR)
    {
        if (!(biosArguments.Eax & 0x0100))
            hwDeviceExtension->bDisplaytype = LCD_type;
        else if (!(biosArguments.Ebx & 0x0200))
            hwDeviceExtension->bDisplaytype = SIM_type;
    }

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    biosArguments.Eax = VESA_POWER_FUNCTION;
    biosArguments.Ebx = VESA_GET_POWER_FUNC;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if ((status == NO_ERROR) &&
       ((biosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS))
    {
       hwDeviceExtension->PMCapability = biosArguments.Ebx;
    }
    else
    {
       hwDeviceExtension->PMCapability = 0;
    }

    //
    // set up the default cursor position and type.
    //

    hwDeviceExtension->CursorPosition.Column = 0;
    hwDeviceExtension->CursorPosition.Row = 0;
    hwDeviceExtension->CursorTopScanLine = 0;
    hwDeviceExtension->CursorBottomScanLine = 31;
    hwDeviceExtension->CursorEnable = TRUE;

    return TRUE;

}


//---------------------------------------------------------------------------
BOOLEAN
VgaStartIO(
    PVOID pHwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    accepts a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:

    This routine will return error codes from the various support routines
    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
    buffers and ERROR_INVALID_FUNCTION for unsupported functions.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = pHwDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension = pHwDeviceExtension;
    VP_STATUS status;
    VIDEO_MODE videoMode;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;
    ULONG physicalFrameLength;

    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    PHYSICAL_ADDRESS shareAddress;
    PVOID virtualAddress;
    ULONG sharedViewSize;
    UCHAR SR0A;


    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode)
    {
    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - ShareVideoMemory\n"));

        if ((RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
            (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
        {
            VideoDebugPrint((1, "VgaStartIO - ShareVideoMemory - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        RequestPacket->StatusBlock->Information =
                            sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        //
        // If you change to using a dense space frame buffer, make this
        // value a 4 for the ALPHA.
        //

        inIoSpace = 0;

        //
        // NOTE: we are ignoring ViewOffset
        //

        shareAddress.QuadPart =
            hwDeviceExtension->PhysicalFrameOffset.QuadPart +
            hwDeviceExtension->PhysicalVideoMemoryBase.QuadPart;

        if (hwDeviceExtension->LinearMode)
        {
            //
            // Add P6CACHE support
            //

#if P6CACHE
#if (_WIN32_WINNT >= 0x0400)
            inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
#endif
#endif

            status = VideoPortMapMemory(hwDeviceExtension,
                                        shareAddress,
                                        &sharedViewSize,
                                        &inIoSpace,
                                        &virtualAddress);
        }
        else
        {
            ULONG ulBankSize;
            VOID (*pfnBank)(ULONG,ULONG,PVOID);

            switch (hwDeviceExtension->ChipType) {

                case CL542x: pfnBank = vBankMap_CL542x;
                             break;

                case CL543x: pfnBank = vBankMap_CL543x;
                             break;

                default:     pfnBank = vBankMap_CL64xx;
                             break;

            };

            #if ONE_64K_BANK
            //
            // The Cirrus Logic VGA's support one 64K read/write bank.
            //

                ulBankSize = 0x10000; // 64K bank start adjustment
            #endif
            #if TWO_32K_BANKS
            //
            // The Cirrus Logic VGA's support two 32K read/write banks.
            //

                ulBankSize = 0x8000; // 32K bank start adjustment
            #endif

            status = VideoPortMapBankedMemory(hwDeviceExtension,
                                       shareAddress,
                                       &sharedViewSize,
                                       &inIoSpace,
                                       &virtualAddress,
                                       ulBankSize,
                                       FALSE,
                                       pfnBank,
                                       (PVOID)hwDeviceExtension);
        }

        pShareMemoryInformation = RequestPacket->OutputBuffer;

        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        break;

    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
                    break;

        }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);

        break;


    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - MapVideoMemory\n"));

        if ((RequestPacket->OutputBufferLength <
             (RequestPacket->StatusBlock->Information =
                          sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        memoryInformation = RequestPacket->OutputBuffer;

        memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
              (RequestPacket->InputBuffer))->RequestedVirtualAddress;

        //
        // We reserved 16 meg for the frame buffer, however, it makes
        // no sense to map more memory than there is on the card.  So
        // only map the amount of memory we have on the card.
        //

        memoryInformation->VideoRamLength =
                hwDeviceExtension->AdapterMemorySize;

        //
        // If you change to using a dense space frame buffer, make this
        // value a 4 for the ALPHA.
        //

        inIoSpace = 0;

        //
        // Add P6CACHE support
        //

        physicalFrameLength = hwDeviceExtension->PhysicalVideoMemoryLength;

#if P6CACHE
#if (_WIN32_WINNT >= 0x0400)

        // 
        // We saw corrupted screen in 16 color mode on 54M40 if P6CAHCHE 
        // is enabled. We only turn on P6CACHE when we see two access 
        // ranges (so that we know this request is from cirrus.dll but
        // not from vga.dll)
        //

        if (RequestPacket->OutputBufferLength >=     // if we have room for
            sizeof(VIDEO_MEMORY_INFORMATION) * 2)    // another access range
        {


            inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

            if ( physicalFrameLength < 0x00400000)
            {
                 physicalFrameLength = 0x00400000;
            }
        }
#endif
#endif

        status = VideoPortMapMemory(hwDeviceExtension,
                                    hwDeviceExtension->PhysicalVideoMemoryBase,
                                    &physicalFrameLength,
                                    &inIoSpace,
                                    &(memoryInformation->VideoRamBase));

        if (status != NO_ERROR) {
            VideoDebugPrint((1, "VgaStartIO - IOCTL_VIDEO_MAP_VIDEO_MEMORY failed VideoPortMapMemory (%x)\n", status));
            break;
        }

        memoryInformation->FrameBufferBase =
            ((PUCHAR) (memoryInformation->VideoRamBase)) +
            hwDeviceExtension->PhysicalFrameOffset.LowPart;

        memoryInformation->FrameBufferLength =
            hwDeviceExtension->PhysicalFrameLength ?
            hwDeviceExtension->PhysicalFrameLength :
            memoryInformation->VideoRamLength;

        VideoDebugPrint((2, "physical VideoMemoryBase %08lx\n", hwDeviceExtension->PhysicalVideoMemoryBase));
        VideoDebugPrint((2, "physical VideoMemoryLength %08lx\n", hwDeviceExtension->PhysicalVideoMemoryLength));
        VideoDebugPrint((2, "VideoMemoryBase %08lx\n", memoryInformation->VideoRamBase));
        VideoDebugPrint((2, "VideoMemoryLength %08lx\n", memoryInformation->VideoRamLength));

        VideoDebugPrint((2, "physical framebuf offset %08lx\n", hwDeviceExtension->PhysicalFrameOffset.LowPart));
        VideoDebugPrint((2, "framebuf base %08lx\n", memoryInformation->FrameBufferBase));
        VideoDebugPrint((2, "physical framebuf len %08lx\n", hwDeviceExtension->PhysicalFrameLength));
        VideoDebugPrint((2, "framebuf length %08lx\n", memoryInformation->FrameBufferLength));

        //
        // add address mapping for system to screen blt
        //

        if (RequestPacket->OutputBufferLength >=     // if we have room for
            sizeof(VIDEO_MEMORY_INFORMATION) * 2)    // another access range
        {
            RequestPacket->StatusBlock->Information =
                sizeof(VIDEO_MEMORY_INFORMATION) * 2;

            memoryInformation++;
            memoryInformation->VideoRamBase = (PVOID)NULL;

            if (hwDeviceExtension->bSecondAperture)
            {
                //
                // We reserved 16 meg for the frame buffer, however, it makes
                // no sense to map more memory than there is on the card.  So
                // only map the amount of memory we have on the card.
                //

                memoryInformation->VideoRamLength =
                    hwDeviceExtension->AdapterMemorySize;

                //
                // If you change to using a dense space frame buffer, make this
                // value a 4 for the ALPHA.
                //

                inIoSpace = 0;

                //
                // Add P6CACHE support
                //

#if P6CACHE
#if (_WIN32_WINNT >= 0x0400)
                inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
#endif
#endif
                shareAddress.QuadPart =
                    hwDeviceExtension->PhysicalVideoMemoryBase.QuadPart +
                    0x1000000;      // add 16M offset

                status = VideoPortMapMemory(hwDeviceExtension,
                                            shareAddress,
                                            &physicalFrameLength,
                                            &inIoSpace,
                                            &(memoryInformation->VideoRamBase));

                if (status != NO_ERROR)
                {
                    VideoDebugPrint((1, "VgaStartIO - IOCTL_VIDEO_MAP_VIDEO_MEMORY failed for system to screen blt mapping (%x)\n", status));
                }

            }
        }

        break;

    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      ((PVIDEO_MEMORY)
                                       (RequestPacket->InputBuffer))->
                                           RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryAvailableModes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryAvailableModes(HwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)&RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryNumAvailableModes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryNumberOfAvailableModes(HwDeviceExtension,
                                                (PVIDEO_NUM_MODES)
                                                    RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength,
                                                (PULONG)&RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - QueryCurrentMode\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCurrentMode(HwDeviceExtension,
                                     (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer,
                                     RequestPacket->OutputBufferLength,
                                     (PULONG)&RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - SetCurrentModes\n"));

        status = VgaSetMode(HwDeviceExtension,
                              (PVIDEO_MODE) RequestPacket->InputBuffer,
                              RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "VgaStartIO - Reset Device\n"));

        videoMode.RequestedMode = DEFAULT_MODE;

        VgaSetMode(HwDeviceExtension,
                        (PVIDEO_MODE) &videoMode,
                        sizeof(videoMode));

        //
        // Always return succcess since settings the text mode will fail on
        // non-x86.
        //
        // Also, failiure to set the text mode is not fatal in any way, since
        // this operation must be followed by another set mode operation.
        //

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_LOAD_AND_SET_FONT:

        VideoDebugPrint((2, "VgaStartIO - LoadAndSetFont\n"));

        status = VgaLoadAndSetFont(HwDeviceExtension,
                                   (PVIDEO_LOAD_FONT_INFORMATION) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorPosition\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCursorPosition(HwDeviceExtension,
                                        (PVIDEO_CURSOR_POSITION) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)&RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - SetCursorPosition\n"));

        status = VgaSetCursorPosition(HwDeviceExtension,
                                      (PVIDEO_CURSOR_POSITION)
                                          RequestPacket->InputBuffer,
                                      RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorAttributes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCursorAttributes(HwDeviceExtension,
                                          (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->OutputBuffer,
                                          RequestPacket->OutputBufferLength,
                                          (PULONG)&RequestPacket->StatusBlock->Information);

        break;


    case IOCTL_VIDEO_SET_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - SetCursorAttributes\n"));

        status = VgaSetCursorAttributes(HwDeviceExtension,
                                        (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->InputBuffer,
                                        RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_PALETTE_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetPaletteRegs\n"));

        status = VgaSetPaletteReg(HwDeviceExtension,
                                  (PVIDEO_PALETTE_DATA) RequestPacket->InputBuffer,
                                  RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetColorRegs\n"));

        status = VgaSetColorLookup(HwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_ENABLE_VDM:

        VideoDebugPrint((2, "VgaStartIO - EnableVDM\n"));

        hwDeviceExtension->TrappedValidatorCount = 0;
        hwDeviceExtension->SequencerAddressValue = 0;

        hwDeviceExtension->CurrentNumVdmAccessRanges =
            NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE;
        hwDeviceExtension->CurrentVdmAccessRange =
            MinimalVgaValidatorAccessRange;

        VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                         hwDeviceExtension->CurrentNumVdmAccessRanges,
                                         hwDeviceExtension->CurrentVdmAccessRange);

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_RESTORE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - RestoreHardwareState\n"));

        status = VgaRestoreHardwareState(HwDeviceExtension,
                                         (PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer,
                                         RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SAVE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - SaveHardwareState\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaSaveHardwareState(HwDeviceExtension,
                                      (PVIDEO_HARDWARE_STATE) RequestPacket->OutputBuffer,
                                      RequestPacket->OutputBufferLength,
                                      (PULONG)&RequestPacket->StatusBlock->Information);

        break;

    case IOCTL_VIDEO_GET_BANK_SELECT_CODE:

        VideoDebugPrint((2, "VgaStartIO - GetBankSelectCode\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaGetBankSelectCode(HwDeviceExtension,
                                        (PVIDEO_BANK_SELECT) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)&RequestPacket->StatusBlock->Information);

        VideoDebugPrint((2, "VgaStartIO - END GetBankSelectCode\n"));
        break;

    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

        {
            PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
            PHYSICAL_ADDRESS physicalPortAddress;
            ULONG physicalPortLength;

            if (RequestPacket->OutputBufferLength <
                sizeof(VIDEO_PUBLIC_ACCESS_RANGES))
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            RequestPacket->StatusBlock->Information =
                sizeof(VIDEO_PUBLIC_ACCESS_RANGES);

            portAccess = RequestPacket->OutputBuffer;

            //
            // The first public access range is the IO ports.
            //

            //
            // On the alpha, VGA.DLL will call into the cirrus miniport
            // trying to get a pointer to the IO ports.  So, we can never
            // return MMIO to the VGA driver.  We'll assume that if the
            // size of the OutputBuffer is only big enough for one access
            // range then the VGA driver is asking for the ranges, and
            // thus we should map them as IO space.
            //

            if ((hwDeviceExtension->bMMAddress) &&
                (RequestPacket->OutputBufferLength >=
                 sizeof(VIDEO_PUBLIC_ACCESS_RANGES) * 2))
            {
                // PC97 Compliant
                portAccess->VirtualAddress  = (PVOID) NULL;
                portAccess->InIoSpace       = FALSE;
                portAccess->MappedInIoSpace = portAccess->InIoSpace;
                // for VGA register
                physicalPortLength = VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1;

                status =  VideoPortMapMemory(hwDeviceExtension,
                                             VgaAccessRange[4].RangeStart,
                                             &physicalPortLength,
                                             &(portAccess->MappedInIoSpace),
                                             &(portAccess->VirtualAddress));

                (PUCHAR)portAccess->VirtualAddress -= VGA_END_BREAK_PORT;
                VideoDebugPrint((1, "VgaStartIO - memory mapping to (%x)\n", portAccess->VirtualAddress));

                if (status == NO_ERROR)
                {
                    RequestPacket->StatusBlock->Information =
                        sizeof(VIDEO_PUBLIC_ACCESS_RANGES) * 2;

                    portAccess++;

                    //
                    // map a region for memory mapped IO
                    //

                    portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
                    portAccess->InIoSpace       = FALSE;
                    portAccess->MappedInIoSpace = portAccess->InIoSpace;
                    // MMIO register
                    physicalPortAddress = VgaAccessRange[4].RangeStart;
                    physicalPortAddress.QuadPart += RELOCATABLE_MEMORY_MAPPED_IO_OFFSET;
                    physicalPortLength = 0x100;

                    status = VideoPortMapMemory(hwDeviceExtension,
                                                physicalPortAddress,
                                                &physicalPortLength,
                                                &(portAccess->MappedInIoSpace),
                                                &(portAccess->VirtualAddress));

                    VideoDebugPrint((1, "The base MMIO address is: %x\n",
                                        portAccess->VirtualAddress));
                }
            }
            else
            {
                portAccess->VirtualAddress  = (PVOID) NULL;
                portAccess->InIoSpace       = TRUE;
                portAccess->MappedInIoSpace = portAccess->InIoSpace;
                physicalPortLength = VGA_MAX_IO_PORT - VGA_BASE_IO_PORT + 1;

                status =  VideoPortMapMemory(hwDeviceExtension,
                                             VgaAccessRange->RangeStart,
                                             &physicalPortLength,
                                             &(portAccess->MappedInIoSpace),
                                             &(portAccess->VirtualAddress));

                (PUCHAR)portAccess->VirtualAddress -= VGA_BASE_IO_PORT;
                VideoDebugPrint((1, "VgaStartIO - mapping ports to (%x)\n", portAccess->VirtualAddress));

                if ((status == NO_ERROR) &&
                    (RequestPacket->OutputBufferLength >=     // if we have room for
                     sizeof(VIDEO_PUBLIC_ACCESS_RANGES) * 2)) // another access range
                {
                    RequestPacket->StatusBlock->Information =
                        sizeof(VIDEO_PUBLIC_ACCESS_RANGES) * 2;

                    portAccess++;

                    //
                    // If we are running on a chip which supports Memory Mapped
                    // IO, then return a pointer to the MMIO Ports.  Otherwise,
                    // return zero to indicate we do not support memory mapped IO.
                    //

                    if (((hwDeviceExtension->ChipType == CL543x) ||
                        (hwDeviceExtension->ChipType &  CL755x)) &&  //myf15
                        (hwDeviceExtension->BusType != Isa) &&
                        (VideoPortGetDeviceData(hwDeviceExtension,
                                                VpMachineData,
                                                &CirrusGetDeviceDataCallback,
                                                NULL) != NO_ERROR))

                    {
                        //
                        // map a region for memory mapped IO
                        //
                        // memory mapped IO is located in physical addresses B8000
                        // to BFFFF, but we will only touch the first 256 bytes.
                        //

                        portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
                        portAccess->InIoSpace       = FALSE;
                        portAccess->MappedInIoSpace = portAccess->InIoSpace;

                        physicalPortAddress = VgaAccessRange[2].RangeStart;
                        physicalPortAddress.QuadPart += MEMORY_MAPPED_IO_OFFSET;

                        physicalPortLength = 0x100;

                        status = VideoPortMapMemory(hwDeviceExtension,
                                                    physicalPortAddress,
                                                    &physicalPortLength,
                                                    &(portAccess->MappedInIoSpace),
                                                    &(portAccess->VirtualAddress));

                        VideoDebugPrint((1, "The base MMIO address is: %x\n",
                                            portAccess->VirtualAddress));
                    }
                    else
                    {
                        portAccess->VirtualAddress = 0;
                    }

                }
            }
        }

        break;

    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        //
        // We decrement VGA_BASE_IO_PORT before we hand this out,
        // so we should increment before we try to free it.
        //

        (PUCHAR)((PVIDEO_MEMORY)RequestPacket->InputBuffer)->
            RequestedVirtualAddress += VGA_BASE_IO_PORT;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      ((PVIDEO_MEMORY)
                                      (RequestPacket->InputBuffer))->
                                          RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_CIRRUS_GET_GAMMA_FACTOR:

        VideoDebugPrint((2, "VgaStartIO - GetGammaFactor\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaGetGammaFactor(hwDeviceExtension,
                                   (PGAMMA_VALUE) RequestPacket->OutputBuffer,
                                   RequestPacket->OutputBufferLength,
                                   (PULONG)&RequestPacket->StatusBlock->Information);
        break ;

    case IOCTL_CIRRUS_GET_CONTRAST_FACTOR:

        VideoDebugPrint((2, "VgaStartIO - GetContrastFactor\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaGetContrastFactor(hwDeviceExtension,
                                   (PCONTRAST_VALUE) RequestPacket->OutputBuffer,
                                   RequestPacket->OutputBufferLength,
                                   (PULONG)&RequestPacket->StatusBlock->Information);
        break ;

     case IOCTL_CIRRUS_GET_CAPABILITIES:

        VideoDebugPrint((2, "VgaStartIO - CirrusGetCapabilities\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryAvailableModes(HwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)&RequestPacket->StatusBlock->Information);

        break;

     case IOCTL_CIRRUS_SET_DISPLAY_PITCH:

        VideoDebugPrint((2, "VgaStartIO - CirrusSetDisplayPitch\n"));

        status = VgaSetMode(HwDeviceExtension,
                              (PVIDEO_MODE) RequestPacket->InputBuffer,
                              RequestPacket->InputBufferLength);
        break;


    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through vga startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

    RequestPacket->StatusBlock->Status = status;

    return TRUE;

}


//---------------------------------------------------------------------------
VOID
CirrusHwTimer(
    PVOID pHwDeviceExtension
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    accepts a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's HwVidTimer
    information.

Return Value:

    This routine will return error codes from the various support routines
    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
    buffers and ERROR_INVALID_FUNCTION for unsupported functions.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = pHwDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension = pHwDeviceExtension;
    VIDEO_MODE videoMode;
    UCHAR   SR0A, SR14, savSEQidx, savCRTidx, lcd;
    SHORT   Displaytype;
    ULONG   ulCRTCAddress, ulCRTCData;



    if (VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                               MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_COLOR;
        ulCRTCData    = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_MONO;
        ulCRTCData    = CRTC_DATA_PORT_MONO;
    }

    if (!(hwDeviceExtension->bBlockSwitch))            //not block switch
    {
        savSEQidx = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                             SEQ_ADDRESS_PORT);
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                             SEQ_ADDRESS_PORT, 0x14);
        SR14 = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                             SEQ_DATA_PORT);
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                             SEQ_DATA_PORT, (UCHAR)(SR14 | 0x04));

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                             SEQ_ADDRESS_PORT, 0x0A);
        SR0A = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                             SEQ_DATA_PORT);

        Displaytype = ((SR14 & 0x02) | (SR0A & 0x01));
        if (Displaytype == 0)
            Displaytype = LCD_type;
        else if (Displaytype == 1)
            Displaytype = CRT_type;
        else if (Displaytype == 3)
            Displaytype = SIM_type;

    VideoDebugPrint((1, "CirrusHwTimer :\n"
                        "\tPreDisplaytype: %d, Currenttype :%d\n",
                        hwDeviceExtension->bDisplaytype,
                        Displaytype));

    VideoDebugPrint((1, "CirrusHwTimer :\n"
                        "\tCurrentMode: %x\n",
                        hwDeviceExtension->bCurrentMode));

        if (hwDeviceExtension->bDisplaytype != Displaytype)
        {
            hwDeviceExtension->bDisplaytype = Displaytype;

            savCRTidx = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCAddress);
            if (hwDeviceExtension->ChipType &  CL754x)
            {
                VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCAddress, 0x20);
                lcd = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData);
                if (Displaytype == LCD_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0x9F) | 0x20));
                }
                else if (Displaytype == CRT_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0x9F)| 0x40));
                }
                else if (Displaytype == SIM_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0x9F)| 0x60));
                }
            }
            else if (hwDeviceExtension->ChipType &  CL755x)
            {
                VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCAddress, 0x80);
                lcd = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData);
                if (Displaytype == LCD_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0xFC) | 0x01));
                }
                else if (Displaytype == CRT_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0xFC)| 0x02));
                }
                else if (Displaytype == SIM_type)
                {
                    VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCData, (UCHAR)((lcd & 0xFC)| 0x03));
                }
            }
            VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                 ulCRTCAddress, savCRTidx);
        }
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT, 0x14);
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                             SEQ_DATA_PORT, (UCHAR)(SR14 & 0xFB));
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                             SEQ_ADDRESS_PORT, savSEQidx);
    }

}


//---------------------------------------------------------------------------
//
// private routines
//

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    )

/*++

Routine Description:

    Takes a buffer containing a user-defined font and loads it into the
    VGA soft font memory and programs the VGA to the appropriate character
    cell size.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FontInformation - Pointer to the structure containing the information
        about the loadable ROM font to be set.

    FontInformationSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    PUCHAR destination;
    PUCHAR source;
    USHORT width;
    ULONG  i;
    ULONG  ulCRTCAddress, ulCRTCData;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough
    // and that it contains all the data.
    //

    if ( (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION)) ||
         (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION) +
                   sizeof(UCHAR) * (FontInformation->FontSize - 1)) )
    {
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check for the width and height of the font
    //

    if ( ((FontInformation->WidthInPixels != 8) &&
          (FontInformation->WidthInPixels != 9)) ||
         (FontInformation->HeightInPixels > 32) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check the size of the font buffer is the right size for the size
    // font being passed down.
    //

    if (FontInformation->FontSize < FontInformation->HeightInPixels * 256 *
                                    sizeof(UCHAR) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Since the font parameters are valid, store the parameters in the
    // device extension and load the font.
    //

    HwDeviceExtension->FontPelRows = FontInformation->HeightInPixels;
    HwDeviceExtension->FontPelColumns = FontInformation->WidthInPixels;

    HwDeviceExtension->CurrentMode->row =
        HwDeviceExtension->CurrentMode->vres / HwDeviceExtension->FontPelRows;

    width =
      HwDeviceExtension->CurrentMode->hres / HwDeviceExtension->FontPelColumns;

    if (width < (USHORT)HwDeviceExtension->CurrentMode->col) {

        HwDeviceExtension->CurrentMode->col = width;

    }

    source = &(FontInformation->Font[0]);

    //
    // Set up the destination and source pointers for the font
    //

    destination = (PUCHAR)HwDeviceExtension->VideoMemoryAddress;

    //
    // Map font buffer at A0000
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

    //
    // Move the font to its destination
    //

    for (i = 1; i <= 256; i++) {

        VideoPortWriteRegisterBufferUchar(destination,
                                          source,
                                          FontInformation->HeightInPixels);

        destination += 32;
        source += FontInformation->HeightInPixels;

    }

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

    //
    // Restore to a text mode.
    //

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_COLOR;
        ulCRTCData    = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_MONO;
        ulCRTCData    = CRTC_DATA_PORT_MONO;
    }

    //
    // Set Height of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress, 0x09);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                       (UCHAR)(FontInformation->HeightInPixels - 1));

    //
    // Set Width of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress, 0x12);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                   (UCHAR)(((USHORT)FontInformation->HeightInPixels *
                   (USHORT)HwDeviceExtension->CurrentMode->row) - 1));

    i = HwDeviceExtension->CurrentMode->vres /
        HwDeviceExtension->CurrentMode->row;

    //
    // Set Cursor End
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress, 0x0B);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                                                      (UCHAR)--i);

    //
    // Set Cursor Start
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress, 0x0A);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                                                (UCHAR)--i);

    return NO_ERROR;

} //end VgaLoadAndSetFont()

//---------------------------------------------------------------------------
VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the output buffer supplied by the user. This
        is where the cursor position is stored.

    CursorPositionSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorPositionSize < (*OutputSize = sizeof(VIDEO_CURSOR_POSITION)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the postition of the cursor into the buffer.
    //

    CursorPosition->Column = HwDeviceExtension->CursorPosition.Column;
    CursorPosition->Row = HwDeviceExtension->CursorPosition.Row;

    return NO_ERROR;

} // end VgaQueryCursorPosition()

//---------------------------------------------------------------------------
VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor position is within
    the row and column bounds of the current mode and font. If valid, then
    it sets the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the structure containing the cursor position.

    CursorPositionSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    USHORT position;
    ULONG  ulCRTCAddress, ulCRTCData;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorPositionSize < sizeof(VIDEO_CURSOR_POSITION)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor positions are in the valid
    // bounds for the screen.
    //

    if ((CursorPosition->Column >= HwDeviceExtension->CurrentMode->col) ||
        (CursorPosition->Row >= HwDeviceExtension->CurrentMode->row)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store these new values in the device extension so we can use them in
    // a QUERY.
    //

    HwDeviceExtension->CursorPosition.Column = CursorPosition->Column;
    HwDeviceExtension->CursorPosition.Row = CursorPosition->Row;

    //
    // Calculate the position on the screen at which the cursor must be
    // be displayed
    //

    position = (USHORT) (HwDeviceExtension->CurrentMode->col *
                         CursorPosition->Row + CursorPosition->Column);

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_COLOR;
        ulCRTCData    = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_MONO;
        ulCRTCData    = CRTC_DATA_PORT_MONO;
    }

    //
    // Address Cursor Location Low Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress,
                            IND_CURSOR_LOW_LOC);

    //
    // Set Cursor Location Low Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                            (UCHAR) (position & 0x00FF));

    //
    // Address Cursor Location High Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress,
                            IND_CURSOR_HIGH_LOC);

    //
    // Set Cursor Location High Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                            (UCHAR) (position >> 8));

    return NO_ERROR;

} // end VgaSetCursorPosition()

//---------------------------------------------------------------------------
VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns information about the height and visibility of the
    cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorAttributes - Pointer to the output buffer supplied by the user.
        This is where the cursor type is stored.

    CursorAttributesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorAttributesSize < (*OutputSize =
            sizeof(VIDEO_CURSOR_ATTRIBUTES)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the cursor information into the buffer.
    //

    CursorAttributes->Height = (USHORT) HwDeviceExtension->CursorTopScanLine;
    CursorAttributes->Width = (USHORT) HwDeviceExtension->CursorBottomScanLine;

    if (HwDeviceExtension->cursor_vert_exp_flag)
       CursorAttributes->Enable = FALSE;
    else
       CursorAttributes->Enable = TRUE;

    CursorAttributes->Enable = HwDeviceExtension->CursorEnable;

    return NO_ERROR;

} // end VgaQueryCursorAttributes()

//---------------------------------------------------------------------------
VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor height is within the
    bounds of the character cell. If valid, then it sets the new
    visibility and height of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorType - Pointer to the structure containing the cursor information.

    CursorTypeSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    UCHAR cursorLine;
    ULONG ulCRTCAddress, ulCRTCData;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorAttributesSize < sizeof(VIDEO_CURSOR_ATTRIBUTES)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor type are in the valid range.
    //

    if ((CursorAttributes->Height >= HwDeviceExtension->FontPelRows) ||
        (CursorAttributes->Width > 31)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store the cursor information in the device extension so we can use
    // them in a QUERY.
    //

    HwDeviceExtension->CursorTopScanLine = (UCHAR) CursorAttributes->Height;
    HwDeviceExtension->CursorBottomScanLine = (UCHAR) CursorAttributes->Width;
    HwDeviceExtension->CursorEnable = CursorAttributes->Enable;

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                  MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_COLOR;
        ulCRTCData        = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_MONO;
        ulCRTCData        = CRTC_DATA_PORT_MONO;
    }

    //
    // Address Cursor Start Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress,
                            IND_CURSOR_START);

    //
    // Set Cursor Start Register by writting to CRTCtl Data Register
    // Preserve the high three bits of this register.
    //
    // Only the Five low bits are used for the cursor height.
    // Bit 5 is cursor enable, bit 6 and 7 preserved.
    //

    cursorLine = (UCHAR) CursorAttributes->Height & 0x1F;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        ulCRTCData) & 0xC0;

    if (!CursorAttributes->Enable) {

        cursorLine |= 0x20; // Flip cursor off bit

    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                            cursorLine);

    //
    // Address Cursor End Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCAddress,
                            IND_CURSOR_END);

    //
    // Set Cursor End Register. Preserve the high three bits of this
    // register.
    //

    cursorLine =
        (CursorAttributes->Width < (USHORT)(HwDeviceExtension->FontPelRows - 1)) ?
        CursorAttributes->Width : (HwDeviceExtension->FontPelRows - 1);

    cursorLine &= 0x1f;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ulCRTCData) & 0xE0;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ulCRTCData,
                            cursorLine);

    return NO_ERROR;

} // end VgaSetCursorAttributes()

//---------------------------------------------------------------------------
BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns TRUE if a VGA is present. Determining whether a VGA
    is present is a two-step process. First, this routine walks bits through
    the Bit Mask register, to establish that there are readable indexed
    registers (EGAs normally don't have readable registers, and other adapters
    are unlikely to have indexed registers). This test is done first because
    it's a non-destructive EGA rejection test (correctly rejects EGAs, but
    doesn't potentially mess up the screen or the accessibility of display
    memory). Normally, this would be an adequate test, but some EGAs have
    readable registers, so next, we check for the existence of the Chain4 bit
    in the Memory Mode register; this bit doesn't exist in EGAs. It's
    conceivable that there are EGAs with readable registers and a register bit
    where Chain4 is stored, although I don't know of any; if a better test yet
    is needed, memory could be written to in Chain4 mode, and then examined
    plane by plane in non-Chain4 mode to make sure the Chain4 bit did what it's
    supposed to do. However, the current test should be adequate to eliminate
    just about all EGAs, and 100% of everything else.

    If this function fails to find a VGA, it attempts to undo any damage it
    may have inadvertently done while testing. The underlying assumption for
    the damage control is that if there's any non-VGA adapter at the tested
    ports, it's an EGA or an enhanced EGA, because: a) I don't know of any
    other adapters that use 3C4/5 or 3CE/F, and b), if there are other
    adapters, I certainly don't know how to restore their original states. So
    all error recovery is oriented toward putting an EGA back in a writable
    state, so that error messages are visible. The EGA's state on entry is
    assumed to be text mode, so the Memory Mode register is restored to the
    default state for text mode.

    If a VGA is found, the VGA is returned to its original state after
    testing is finished.

Arguments:

    None.

Return Value:

    TRUE if a VGA is present, FALSE if not.

--*/

{
    UCHAR originalGCAddr;
    UCHAR originalSCAddr;
    UCHAR originalBitMask;
    UCHAR originalReadMap;
    UCHAR originalMemoryMode;
    UCHAR testMask;
    BOOLEAN returnStatus;

    //
    // Remember the original state of the Graphics Controller Address register.
    //

    originalGCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT);

    //
    // Write the Read Map register with a known state so we can verify
    // that it isn't changed after we fool with the Bit Mask. This ensures
    // that we're dealing with indexed registers, since both the Read Map and
    // the Bit Mask are addressed at GRAPH_DATA_PORT.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // If we can't read back the Graphics Address register setting we just
    // performed, it's not readable and this isn't a VGA.
    //

    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_READ_MAP) {

        return FALSE;
    }

    //
    // Set the Read Map register to a known state.
    //

    originalReadMap = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, READ_MAP_TEST_SETTING);

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map setting we just performed can't be read back; not a
        // VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    //
    // Remember the original setting of the Bit Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_BIT_MASK) {

        //
        // The Graphics Address register setting we just made can't be read
        // back; not a VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_READ_MAP);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    originalBitMask = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // Set up the initial test mask we'll write to and read from the Bit Mask.
    //

    testMask = 0xBB;

    do {

        //
        // Write the test mask to the Bit Mask.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, testMask);

        //
        // Make sure the Bit Mask remembered the value.
        //

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT) != testMask) {

            //
            // The Bit Mask is not properly writable and readable; not a VGA.
            // Restore the Bit Mask and Read Map to their default states.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, BIT_MASK_DEFAULT);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT, IND_READ_MAP);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, READ_MAP_DEFAULT);

            return FALSE;
        }

        //
        // Cycle the mask for next time.
        //

        testMask >>= 1;

    } while (testMask != 0);

    //
    // There's something readable at GRAPH_DATA_PORT; now switch back and
    // make sure that the Read Map register hasn't changed, to verify that
    // we're dealing with indexed registers.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);
    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map is not properly writable and readable; not a VGA.
        // Restore the Bit Mask and Read Map to their default states, in case
        // this is an EGA, so subsequent writes to the screen aren't garbled.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_BIT_MASK);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, BIT_MASK_DEFAULT);

        return FALSE;
    }

    //
    // We've pretty surely verified the existence of the Bit Mask register.
    // Put the Graphics Controller back to the original state.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalReadMap);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalBitMask);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, originalGCAddr);

    //
    // Now, check for the existence of the Chain4 bit.
    //

    //
    // Remember the original states of the Sequencer Address and Memory Mode
    // registers.
    //

    originalSCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT) & SEQ_ADDR_MASK) != IND_MEMORY_MODE) {

        //
        // Couldn't read back the Sequencer Address register setting we just
        // performed.
        //

        return FALSE;
    }
    originalMemoryMode = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT);

    //
    // Toggle the Chain4 bit and read back the result. This must be done during
    // sync reset, since we're changing the chaining state.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT),
             (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Toggle the Chain4 bit.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT, (UCHAR)(originalMemoryMode ^ CHAIN4_MASK));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT) != (UCHAR) (originalMemoryMode ^ CHAIN4_MASK)) {

        //
        // Chain4 bit not there; not a VGA.
        // Set text mode default for Memory Mode register.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, MEMORY_MODE_TEXT_DEFAULT);
        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        returnStatus = FALSE;

    } else {

        //
        // It's a VGA.
        //

        //
        // Restore the original Memory Mode setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, originalMemoryMode);

        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (USHORT)(IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        //
        // Restore the original Sequencer Address setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, originalSCAddr);

        returnStatus = TRUE;
    }

    return returnStatus;

} // VgaIsPresent()

//---------------------------------------------------------------------------
VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the EGA (not DAC) palette
    registers.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    PaletteBuffer - Pointer to the structure containing the palette data.

    PaletteBufferSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid palette size.

--*/

{
    USHORT i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((PaletteBufferSize) < (sizeof(VIDEO_PALETTE_DATA)) ||
        (PaletteBufferSize < (sizeof(VIDEO_PALETTE_DATA) +
                (sizeof(USHORT) * (PaletteBuffer->NumEntries -1)) ))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (PaletteBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER ) ||
         (PaletteBuffer->NumEntries == 0) ||
         (PaletteBuffer->FirstEntry + PaletteBuffer->NumEntries >
             VIDEO_MAX_PALETTE_REGISTER + 1 ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Reset ATC to index mode
    //

    //
    // check to see mono or color first
    //
    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               MISC_OUTPUT_REG_READ_PORT) & 0x01) {
        VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               ATT_INITIALIZE_PORT_COLOR);
    } else {
        VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               ATT_INITIALIZE_PORT_MONO);   //frido 07-Aug-96
    }

    //
    // Blast out our palette values.
    //

    for (i = 0; i < PaletteBuffer->NumEntries; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                                (UCHAR)(i+PaletteBuffer->FirstEntry));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    ATT_DATA_WRITE_PORT,
                                (UCHAR)PaletteBuffer->Colors[i]);
    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                            VIDEO_ENABLE);

    return NO_ERROR;

} // end VgaSetPaletteReg()


//---------------------------------------------------------------------------
VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the DAC color lookup table
    settings.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ClutBufferSize - Length of the input buffer supplied by the user.

    ClutBuffer - Pointer to the structure containing the color lookup table.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid clut size.

--*/

{
    ULONG i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
             VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    //  Set CLUT registers directly on the hardware
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, (UCHAR) ClutBuffer->FirstEntry);

    for (i = 0; i < ClutBuffer->NumEntries; i++) {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_WRITE_PORT,
                                (UCHAR)(i + ClutBuffer->FirstEntry));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT,
                                ClutBuffer->LookupTable[i].RgbArray.Red);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT,
                                ClutBuffer->LookupTable[i].RgbArray.Green);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT,
                                ClutBuffer->LookupTable[i].RgbArray.Blue);
    }

    return NO_ERROR;

} // end VgaSetColorLookup()

//---------------------------------------------------------------------------
VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    )

/*++

Routine Description:

    Restores all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer from which the state
    is to be restored. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: The offset in the hardware state header from which each general
    register is restored is the offset of the write address of that register
    from the base I/O address of the VGA.


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure from which the saved state is to be
        restored (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the input buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to from which the state is actually restored. The
        pointed-to buffer is assumed to be big enough.)

Return Value:

    NO_ERROR - restore performed successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough to provide data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    ULONG i;
    UCHAR dummy;
    PUCHAR pScreen;
    PUCHAR pucLatch;
    PULONG pulBuffer;
    PUCHAR port;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    ULONG bIsColor;
    ULONG portIO ;
    UCHAR value ;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE)) ||
            (HardwareState->StateLength < VGA_TOTAL_STATE_SIZE)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Point to the buffer where the restore data is actually stored.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Make sure the offset are in the structure ...
    //

    if ((hardwareStateHeader->BasicSequencerOffset + VGA_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicCrtContOffset + VGA_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicGraphContOffset + VGA_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicAttribContOffset + VGA_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicDacOffset + (3 * VGA_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicLatchesOffset + 4 >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedSequencerOffset + EXT_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedCrtContOffset + EXT_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedGraphContOffset + EXT_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedAttribContOffset + EXT_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedDacOffset + (4 * EXT_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        //
        // Only check the validator state offset if there is unemulated data.
        //

        ((hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) &&
            (hardwareStateHeader->ExtendedValidatorStateOffset + VGA_VALIDATOR_AREA_SIZE >
            HardwareState->StateLength)) ||

        (hardwareStateHeader->ExtendedMiscDataOffset + VGA_MISC_DATA_AREA_OFFSET >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane1Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane2Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane3Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane4Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->DIBOffset +
            hardwareStateHeader->DIBBitsPerPixel / 8 *
            hardwareStateHeader->DIBXResolution *
            hardwareStateHeader->DIBYResolution  > HardwareState->StateLength) ||

        (hardwareStateHeader->DIBXlatOffset + hardwareStateHeader->DIBXlatLength >
            HardwareState->StateLength)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Turn off the screen to avoid flickering. The screen will turn back on
    // when we restore the DAC state at the end of this routine.
    //

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_READ_PORT) & 0x01) {
        port = INPUT_STATUS_1_COLOR + HwDeviceExtension->IOAddress;
    } else {
        port = INPUT_STATUS_1_MONO + HwDeviceExtension->IOAddress;
    }

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);


    //
    // Restore the latches and the contents of display memory.
    //
    // Set up the VGA's hardware to allow us to copy to each plane in turn.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, (UCHAR) ((VideoPortReadPortUchar(
            HwDeviceExtension->IOAddress + GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x00));

    //
    // Set the Bit Mask to 0xFF to allow all CPU bits through.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_BIT_MASK + (0xFF << 8)));

    //
    // Set the Data Rotation and Logical Function fields to 0 to allow CPU
    // data through unmodified.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_DATA_ROTATE + (0 << 8)));

    //
    // Set Set/Reset Enable to 0 to select CPU data for all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_SET_RESET_ENABLE + (0 << 8)));

    //
    // Point the Sequencer Index to the Map Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT, IND_MAP_MASK);

    //
    // Restore the latches.
    //
    // Point to the saved data for the first latch.
    //

    pucLatch = ((PUCHAR) (hardwareStateHeader)) +
            hardwareStateHeader->BasicLatchesOffset;

    //
    // Point to first byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress;

    //
    // Write the contents to be restored to each of the four latches in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Write this plane's latch.
        //

        VideoPortWriteRegisterUchar(pScreen, *pucLatch++);

    }

    //
    // Read the latched data into the latches, and the latches are set.
    //

    dummy = VideoPortReadRegisterUchar(pScreen);

    //
    // Point to the offset of the saved data for the first plane.
    //

    pulBuffer = &(hardwareStateHeader->Plane1Offset);

    //
    // Restore each of the four planes in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Restore this plane from the buffer.
        //

        VideoPortMoveMemory((PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           ((PUCHAR) (hardwareStateHeader)) + *pulBuffer,
                           hardwareStateHeader->PlaneLength);

        pulBuffer++;

    }

    //
    // If we have some unemulated data, put it back into the buffer
    //

    if (hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) {

        if (!hardwareStateHeader->ExtendedValidatorStateOffset) {

            return ERROR_INVALID_PARAMETER;

        }

        //
        // Get the right offset in the struct and save all the data associated
        // with the trapped validator data.
        //

        VideoPortMoveMemory(&(HwDeviceExtension->TrappedValidatorCount),
                            ((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            VGA_VALIDATOR_AREA_SIZE);

        //
        // Check to see if this is an appropriate access range.
        // We are trapping - so we must have the trapping access range enabled.
        //

        if (((HwDeviceExtension->CurrentVdmAccessRange != FullVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE)) &&
            ((HwDeviceExtension->CurrentVdmAccessRange != MinimalVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE))) {

            return ERROR_INVALID_PARAMETER;

        }

        VideoPortSetTrappedEmulatorPorts(HwDeviceExtension,
                                         HwDeviceExtension->CurrentNumVdmAccessRanges,
                                         HwDeviceExtension->CurrentVdmAccessRange);

    }

    //
    // Set the critical registers (clock and timing states) during sync reset.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (START_SYNC_RESET_VALUE << 8)));

    //
    // Restore the Miscellaneous Output register.
    //

    portIO = MISC_OUTPUT_REG_WRITE_PORT ;
    value = (UCHAR) (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT-VGA_BASE_IO_PORT] & 0xF7) ;
    IOWaitDisplEnableThenWrite ( HwDeviceExtension,
                                 portIO,
                                 value ) ;

    //
    // Restore all Sequencer registers except the Sync Reset register, which
    // is always not in reset (except when we send out a batched sync reset
    // register set, but that can't be interrupted, so we know we're never in
    // sync reset at save/restore time).
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
            hardwareStateHeader->BasicSequencerOffset + 1;

    for (i = 1; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)) );

    }

    //
    // Restore extended sequencer registers
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    if (hardwareStateHeader->ExtendedSequencerOffset) {

        portValue = ((PUCHAR) hardwareStateHeader) +
                          hardwareStateHeader->ExtendedSequencerOffset;

        if ((HwDeviceExtension->ChipType != CL6410) &&
            (HwDeviceExtension->ChipType != CL6420))
        {

            //
            // No extended sequencer registers for the CL64xx
            //

            //
            // The first section in restore must open the extension registers
            //

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT),
                                     IND_CL_EXTS_ENB + (0x0012 << 8) );

            for (i = CL542x_SEQUENCER_EXT_START;
                 i <= CL542x_SEQUENCER_EXT_END;
                 i++) {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (i + ((*portValue++) << 8)) );

            }
        }
    }

#endif

    //
    // Restore the Graphics Controller Miscellaneous register, which contains
    // the Chain bit.
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
                hardwareStateHeader->BasicGraphContOffset + IND_GRAPH_MISC;

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT)(IND_GRAPH_MISC + (*portValue << 8)));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT-VGA_BASE_IO_PORT] & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }

    //
    // Restore the CRT Controller indexed registers.
    //
    // Unlock CRTC registers 0-7.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicCrtContOffset;

    if (bIsColor) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    } else {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    }

    //
    // Restore extended crtc registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    if (hardwareStateHeader->ExtendedCrtContOffset) {

        portValue = (PUCHAR) hardwareStateHeader +
                         hardwareStateHeader->ExtendedCrtContOffset;

        if ((HwDeviceExtension->ChipType != CL6410) &&
            (HwDeviceExtension->ChipType != CL6420))
        {
            //
            // No CRTC Extensions in CL64xx chipset
            //

            for (i = CL542x_CRTC_EXT_START; i <= CL542x_CRTC_EXT_END; i++) {

                if (bIsColor) {

                    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                                 CRTC_ADDRESS_PORT_COLOR),
                                             (USHORT) (i + ((*portValue++) << 8)));

                } else {

                    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                                 CRTC_ADDRESS_PORT_MONO),
                                             (USHORT) (i + ((*portValue++) << 8)));

                }
            }
        }

/* myf2, crus
        if (HwDeviceExtension->ChipType &  CL755x)
        {
            for (i = 0x81; i <= 0x91; i++)
            {
                if (bIsColor)
                {
                    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                                 CRTC_ADDRESS_PORT_COLOR),
                                             (USHORT) (i + ((*portValue++) << 8)));

                } else {

                    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                                 CRTC_ADDRESS_PORT_MONO),
                                             (USHORT) (i + ((*portValue++) << 8)));

                }
            }
        }
crus, myf2 */
    }

#endif

    //
    // Now restore the CRTC registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicCrtContOffset;

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR),
                    (USHORT) (i + ((*portValue++) << 8)));

        } else {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO),
                    (USHORT) (i + ((*portValue++) << 8)));

        }

    }

    //
    // Restore the Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicGraphContOffset;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)));

    }

    //
    // Restore extended graphics controller registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    if (hardwareStateHeader->ExtendedGraphContOffset) {

    portValue = (PUCHAR) hardwareStateHeader +
                         hardwareStateHeader->ExtendedGraphContOffset;

        if ((HwDeviceExtension->ChipType != CL6410) &&
            (HwDeviceExtension->ChipType != CL6420))
        {
            for (i = CL542x_GRAPH_EXT_START; i <= CL542x_GRAPH_EXT_END; i++) {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             GRAPH_ADDRESS_PORT),
                                         (USHORT) (i + ((*portValue++) << 8)));
            }

        } else {         // must be a CL64xx

            VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                         GRAPH_ADDRESS_PORT),
                                     CL64xx_EXTENSION_ENABLE_INDEX +
                                         (CL64xx_EXTENSION_ENABLE_VALUE << 8));

            for (i = CL64xx_GRAPH_EXT_START; i <= CL64xx_GRAPH_EXT_END; i++) {

                VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                             GRAPH_ADDRESS_PORT),
                                         (USHORT) (i + ((*portValue++) << 8)));

            }
        }
    }

#endif

    //
    // Restore the Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicAttribContOffset;

    //
    // Reset the AC index/data toggle, then blast out all the register
    // settings.
    //

    if (bIsColor) {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_COLOR);
    } else {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_MONO);
    }

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, *portValue++);

    }

    //
    // Restore DAC registers 1 through 255. We'll do register 0, the DAC Mask,
    // and the index registers later.
    // Set the DAC address port Index, then write out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Write them one at a time due to problems on local bus machines.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
                   hardwareStateHeader->BasicDacOffset + 3;

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_WRITE_PORT, (UCHAR)i);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

    }

    //
    // Is this color or mono ?
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    //
    // Restore the Feature Control register.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_COLOR,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR-VGA_BASE_IO_PORT]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_MONO,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO-VGA_BASE_IO_PORT]);

    }


    //
    // Restore the Sequencer Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT,
            hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT-VGA_BASE_IO_PORT]);

    //
    // Restore the CRT Controller Index.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR-VGA_BASE_IO_PORT]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO-VGA_BASE_IO_PORT]);

    }


    //
    // Restore the Graphics Controller Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT,
            hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT-VGA_BASE_IO_PORT]);


    //
    // Restore the Attribute Controller Index and index/data toggle state.
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    VideoPortReadPortUchar(port);  // reset the toggle to Index state

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT,  // restore the AC Index
            hardwareStateHeader->PortValue[ATT_ADDRESS_PORT-VGA_BASE_IO_PORT]);

    //
    // If the toggle should be in Data state, we're all set. If it should be in
    // Index state, reset it to that condition.
    //

    if (hardwareStateHeader->AttribIndexDataState == 0) {

        //
        // Reset the toggle to Index state.
        //

        VideoPortReadPortUchar(port);

    }


    //
    // Restore DAC register 0 and the DAC Mask, to unblank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicDacOffset;

    //
    // Restore the DAC Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT,
            hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT-VGA_BASE_IO_PORT]);

    //
    // Restore DAC register 0.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);


    //
    // Restore the read/write state and the current index of the DAC.
    //
    // See whether the Read or Write Index was written to most recently.
    // (The upper nibble stored at DAC_STATE_PORT is the # of reads/writes
    // for the current index.)
    //

    if ((hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] & 0x0F) == 3) {

        //
        // The DAC Read Index was written to last. Restore the DAC by setting
        // up to read from the saved index - 1, because the way the Read
        // Index works is that it autoincrements after reading, so you actually
        // end up reading the data for the index you read at the DAC Write
        // Mask register - 1.
        //
        // Set the Read Index to the index we read, minus 1, accounting for
        // wrap from 255 back to 0. The DAC hardware immediately reads this
        // register into a temporary buffer, then adds 1 to the index.
        //

        if (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT] == 0) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, 255);

        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, (UCHAR)
                    (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT] -
                    1));

        }

        //
        // Now read the hardware however many times are required to get to
        // the partial read state we saved.
        //

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] >> 4;
                i > 0; i--) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

        }

    } else {

        //
        // The DAC Write Index was written to last. Set the Write Index to the
        // index value we read out of the DAC. Then, if a partial write
        // (partway through an RGB triplet) was in place, write the partial
        // values, which we obtained by writing them to the current DAC
        // register. This DAC register will be wrong until the write is
        // completed, but at least the values will be right once the write is
        // finished, and most importantly we won't have messed up the sequence
        // of RGB writes (which can be as long as 768 in a row).
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_WRITE_PORT,
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT]);

        //
        // Now write to the hardware however many times are required to get to
        // the partial write state we saved (if any).
        //
        // Point to the saved value for the DAC register that was in the
        // process of being written to; we wrote the partial value out, so now
        // we can restore it.
        //

        portValueDAC = (PUCHAR) hardwareStateHeader +
                hardwareStateHeader->BasicDacOffset +
                (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT] * 3);

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] >> 4;
                i > 0; i--) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, *portValueDAC++);

        }

    }

    return NO_ERROR;

} // end VgaRestoreHardwareState()

//---------------------------------------------------------------------------
VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Saves all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer in which the state
    is saved. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: This routine leaves registers in any state it cares to, except
    that it will not mess with any of the CRT or Sequencer parameters that
    might make the monitor unhappy. It leaves the screen blanked by setting
    the DAC Mask and DAC register 0 to all zero values. The next video
    operation we expect after this is a mode set to take us back to Win32.

    Note: The offset in the hardware state header in which each general
    register is saved is the offset of the write address of that register from
    the base I/O address of the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure in which the saved state will be
        returned (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the output buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to where the state is actually saved. The pointed-
        to buffer is assumed to be big enough.)

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data returned in the buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    PUCHAR port;
    PUCHAR pScreen;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    PUCHAR bufferPointer;
    ULONG i;
    UCHAR dummy, originalACIndex, originalACData;
    UCHAR ucCRTC03;
    ULONG bIsColor;

    ULONG portIO ;
    UCHAR value ;

    //
    // See if the buffer is big enough to hold the hardware state structure.
    // (This is only the HardwareState structure itself, not the buffer it
    // points to.)
    //

    if (HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE) ) {

        *OutputSize = 0;  // nothing returned
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Amount of data we're going to return in the output buffer.
    // (The VIDEO_HARDWARE_STATE in the output buffer points to the actual
    // buffer in which the state is stored, which is assumed to be large
    // enough.)
    //

    *OutputSize = sizeof(VIDEO_HARDWARE_STATE);

    //
    // Indicate the size of the full state save info.
    //

    HardwareState->StateLength = VGA_TOTAL_STATE_SIZE;

    //
    // hardwareStateHeader is a structure of offsets at the start of the
    // actual save area that indicates the locations in which various VGA
    // register and memory components are saved.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Zero out the structure.
    //

    VideoPortZeroMemory(hardwareStateHeader, sizeof(VIDEO_HARDWARE_STATE_HEADER));

    //
    // Set the Length field, which is basically a version ID.
    //

    hardwareStateHeader->Length = sizeof(VIDEO_HARDWARE_STATE_HEADER);

    //
    // Set the basic register offsets properly.
    //

    hardwareStateHeader->BasicSequencerOffset = VGA_BASIC_SEQUENCER_OFFSET;
    hardwareStateHeader->BasicCrtContOffset = VGA_BASIC_CRTC_OFFSET;
    hardwareStateHeader->BasicGraphContOffset = VGA_BASIC_GRAPH_CONT_OFFSET;
    hardwareStateHeader->BasicAttribContOffset = VGA_BASIC_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->BasicDacOffset = VGA_BASIC_DAC_OFFSET;
    hardwareStateHeader->BasicLatchesOffset = VGA_BASIC_LATCHES_OFFSET;

    //
    // Set the entended register offsets properly.
    //

    hardwareStateHeader->ExtendedSequencerOffset = VGA_EXT_SEQUENCER_OFFSET;
    hardwareStateHeader->ExtendedCrtContOffset = VGA_EXT_CRTC_OFFSET;
    hardwareStateHeader->ExtendedGraphContOffset = VGA_EXT_GRAPH_CONT_OFFSET;
    hardwareStateHeader->ExtendedAttribContOffset = VGA_EXT_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->ExtendedDacOffset = VGA_EXT_DAC_OFFSET;

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if ((hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT))
            & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }

    //
    // Force the video subsystem enable state to enabled.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            VIDEO_SUBSYSTEM_ENABLE_PORT, 1);

    //
    // Save the DAC state first, so we can set the DAC to blank the screen
    // so nothing after this shows up at all.
    //
    // Save the DAC Mask register.
    //

    hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_PIXEL_MASK_PORT);

    //
    // Save the DAC Index register. Note that there is actually only one DAC
    // Index register, which functions as either the Read Index or the Write
    // Index as needed.
    //

    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT);

    //
    // Save the DAC read/write state. We determine if the DAC has been written
    // to or read from at the current index 0, 1, or 2 times (the application
    // is in the middle of reading or writing a DAC register triplet if the
    // count is 1 or 2), and save enough info so we can restore things
    // properly. The only hole is if the application writes to the Write Index,
    // then reads from instead of writes to the Data register, or vice-versa,
    // or if they do a partial read write, then never finish it.
    // This is fairly ridiculous behavior, however, and anyway there's nothing
    // we can do about it.
    //

    hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_STATE_PORT);

    if (hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] == 3) {

        //
        // The DAC Read Index was written to last. Figure out how many reads
        // have been done from the current index. We'll restart this on restore
        // by setting the Read Index to the current index - 1 (the read index
        // is one greater than the index being read), then doing the proper
        // number of reads.
        //
        // Read the Data register once, and see if the index changes.
        //

        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT]) {

            //
            // The DAC Index changed, so two reads had already been done from
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] |= 0x20;

        } else {

            //
            // Read the Data register again, and see if the index changes.
            //

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT]) {

                //
                // The DAC Index changed, so one read had already been done
                // from the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 reads had been done from the current index,
            // then 0 reads were done, and we're all set, since the upper
            // nibble of the read/write state field is already 0.
            //

        }

    } else {

        //
        // The DAC Write Index was written to last. Figure out how many writes
        // have been done to the current index. We'll restart this on restore
        // by setting the Write Index to the proper index, then doing the
        // proper number of writes. When we do the DAC register save, we'll
        // read out the value that gets written (if there was a partial write
        // in progress), so we can restore the proper data later. This will
        // cause this current DAC location to be briefly wrong in the 1- and
        // 2-bytes-written case (until the app finishes the write), but that's
        // better than having the wrong DAC values written for good.
        //
        // Write the Data register once, and see if the index changes.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT, 0);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT]) {

            //
            // The DAC Index changed, so two writes had already been done to
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] |= 0x20;

        } else {

            //
            // Write the Data register again, and see if the index changes.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, 0);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT-VGA_BASE_IO_PORT]) {

                //
                // The DAC Index changed, so one write had already been done
                // to the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT-VGA_BASE_IO_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 writes had been done to the current index,
            // then 0 writes were done, and we're all set.
            //

        }

    }

    //
    // Now, read out the 256 18-bit DAC palette registers (256 RGB triplets),
    // and blank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader + VGA_BASIC_DAC_OFFSET;

    //
    // Read out DAC register 0, so we can set it to black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_READ_PORT, 0);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);

    //
    // Read out the Attribute Controller Index state, and deduce the Index/Data
    // toggle state at the same time.
    //
    // Save the state of the Attribute Controller, both Index and Data,
    // so we can test in which state the toggle currently is.
    //

    originalACIndex = hardwareStateHeader->PortValue[ATT_ADDRESS_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT);
    originalACData = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_READ_PORT);

    //
    // Sequencer Index.
    //

    hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    SEQ_ADDRESS_PORT);

    //
    // Begin sync reset, just in case this is an SVGA and the currently
    // indexed Attribute Controller register controls clocking stuff (a
    // normal VGA won't require this).
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Now, write a different Index setting to the Attribute Controller, and
    // see if the Index changes.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT, (UCHAR) (originalACIndex ^ 0x10));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT) == originalACIndex) {

        //
        // The Index didn't change, so the toggle was in the Data state.
        //

        hardwareStateHeader->AttribIndexDataState = 1;

        //
        // Restore the original Data state; we just corrupted it, and we need
        // to read it out later; also, it may glitch the screen if not
        // corrected. The toggle is already in the Index state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, originalACIndex);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, originalACData);

    } else {

        //
        // The Index did change, so the toggle was in the Index state.
        // No need to restore anything, because the Data register didn't
        // change, and we've already read out the Index register.
        //

        hardwareStateHeader->AttribIndexDataState = 0;

    }

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));



    //
    // Save the rest of the DAC registers.
    // Set the DAC address port Index, then read out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Read them one at a time due to problems on local bus machines.
    //

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_READ_PORT, (UCHAR)i);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

    }

    //
    // Is this color or mono ?
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    //
    // The Feature Control register is read from 3CA but written at 3BA/3DA.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR-VGA_BASE_IO_PORT] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    } else {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO-VGA_BASE_IO_PORT] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    }

    //
    // CRT Controller Index.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR-VGA_BASE_IO_PORT] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_COLOR);

    } else {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO-VGA_BASE_IO_PORT] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_MONO);

    }

    //
    // Graphics Controller Index.
    //

    hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT-VGA_BASE_IO_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT);


    //
    // Sequencer indexed registers.
    //

    portValue = ((PUCHAR) hardwareStateHeader) + VGA_BASIC_SEQUENCER_OFFSET;

    for (i = 0; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

    }

    //
    // Save extended sequencer registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    portValue = ((PUCHAR) hardwareStateHeader) + VGA_EXT_SEQUENCER_OFFSET;

    if ((HwDeviceExtension->ChipType != CL6410) &&
        (HwDeviceExtension->ChipType != CL6420))
    {
        //
        // No extended sequencer registers for the CL64xx
        //

        for (i = CL542x_SEQUENCER_EXT_START;
             i <= CL542x_SEQUENCER_EXT_END;
             i++) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT, (UCHAR)i);

            *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                  SEQ_DATA_PORT);

        }
    }

#endif

    //
    // CRT Controller indexed registers.
    //

    //
    // Remember the state of CRTC register 3, then force bit 7
    // to 1 so we will read back the Vertical Retrace start and
    // end registers rather than the light pen info.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_COLOR);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR, (UCHAR) (ucCRTC03 | 0x80));
    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_MONO);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_DATA_PORT_MONO, (UCHAR) (ucCRTC03 | 0x80));
    }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_COLOR);
            }
        else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_MONO);
            }

       }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;
    portValue[3] = ucCRTC03;


    //
    // Save extended crtc registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    portValue = (PUCHAR) hardwareStateHeader + VGA_EXT_CRTC_OFFSET;

    if ((HwDeviceExtension->ChipType != CL6410) &&
        (HwDeviceExtension->ChipType != CL6420))
    {
        //
        // No CRTC Extensions in CL64xx chipset
        //

        for (i = CL542x_CRTC_EXT_START; i <= CL542x_CRTC_EXT_END; i++) {

            if (bIsColor) {

                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);

                *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                           CRTC_DATA_PORT_COLOR);

            } else {

                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_ADDRESS_PORT_MONO, (UCHAR)i);

                *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                           CRTC_DATA_PORT_MONO);
            }
        }
    }

/* myf2, crus
    if (HwDeviceExtension->ChipType &  CL755x)
    {
        for (i = 0x81; i <= 0x91; i++)
        {
            if (bIsColor)
            {
                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);
                *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                           CRTC_DATA_PORT_COLOR);

            } else {

                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_ADDRESS_PORT_MONO, (UCHAR)i);

                *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                           CRTC_DATA_PORT_MONO);
            }
        }
    }
crus, myf2 */

    //if ((HwDeviceExtension->ChipType &  CL754x) ||    //myf32
    //    (HwDeviceExtension->ChipType &  CL755x) ||    //myf32
    //    (HwDeviceExtension->ChipType == CL756x)) {
    //   {
    //   NordicSaveRegs(HwDeviceExtension,
    //      (PUSHORT)hardwareStateHeader + sizeof(NORDIC_REG_SAVE_BUF));
    //   }

#endif

    //
    // Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_GRAPH_CONT_OFFSET;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT);

        }

    //
    // Save extended graphics controller registers.
    //

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    portValue = (PUCHAR) hardwareStateHeader + VGA_EXT_GRAPH_CONT_OFFSET;

    if ((HwDeviceExtension->ChipType != CL6410) &&
        (HwDeviceExtension->ChipType != CL6420))
    {
        for (i = CL542x_GRAPH_EXT_START; i <= CL542x_GRAPH_EXT_END; i++) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    GRAPH_ADDRESS_PORT, (UCHAR)i);

            *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                  GRAPH_DATA_PORT);

        }

    } else {         // must be a CL64xx

        for (i = CL64xx_GRAPH_EXT_START; i <= CL64xx_GRAPH_EXT_END; i++) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    GRAPH_ADDRESS_PORT, (UCHAR)i);

            *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                  GRAPH_DATA_PORT);
        }
    }

#endif

    //
    // Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_ATTRIB_CONT_OFFSET;

    //
    // For each indexed AC register, reset the flip-flop for reading the
    // attribute register, then write the desired index to the AC Index,
    // then read the value of the indexed register from the AC Data register.
    //

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        if (bIsColor) {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_READ_PORT);

    }

    //
    // Save the latches. This destroys one byte of display memory in each
    // plane, which is unfortunate but unavoidable. Chips that provide
    // a way to read back the latches can avoid this problem.
    //
    // Set up the VGA's hardware so we can write the latches, then read them
    // back.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Set the Miscellaneous register to make sure we can access video RAM.
    //

    portIO = MISC_OUTPUT_REG_WRITE_PORT ;
    value = (UCHAR) (hardwareStateHeader->
                PortValue[MISC_OUTPUT_REG_WRITE_PORT-VGA_BASE_IO_PORT] |
                0x02) ;
    IOWaitDisplEnableThenWrite ( HwDeviceExtension,
                                 portIO,
                                 value ) ;

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the Map Mask to write to all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_MAP_MASK + (0x0F << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x01));

    //
    // Point to the last byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress +
            VGA_PLANE_SIZE - 1;

    //
    // Write the latches to the last byte of display memory.
    //

    VideoPortWriteRegisterUchar(pScreen, 0);

    //
    // Cycle through the four planes, reading the latch data from each plane.
    //

    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_LATCHES_OFFSET;

    for (i=0; i<4; i++) {

        //
        // Set the Read Map for the current plane.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Read the latched data we've written to memory.
        //

        *portValue++ = VideoPortReadRegisterUchar(pScreen);

    }

    //
    // Set the VDM flags
    // We are a standard VGA, and then check if we have unemulated state.
    //

    hardwareStateHeader->VGAStateFlags = 0;

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

    hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_NON_STANDARD_VGA;

#endif

    if (HwDeviceExtension->TrappedValidatorCount) {

        hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_UNEMULATED_VGA_STATE;

        //
        // Save the VDM Emulator data
        // No need to save the state of the seuencer port register for our
        // emulated data since it may change when we come back. It will be
        // recomputed.
        //

        hardwareStateHeader->ExtendedValidatorStateOffset = VGA_VALIDATOR_OFFSET;

        VideoPortMoveMemory(((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            &(HwDeviceExtension->TrappedValidatorCount),
                            VGA_VALIDATOR_AREA_SIZE);

    } else {

        hardwareStateHeader->ExtendedValidatorStateOffset = 0;

    }

    //
    // Set the size of each plane.
    //

    hardwareStateHeader->PlaneLength = VGA_PLANE_SIZE;

    //
    // Store all the offsets for the planes in the structure.
    //

    hardwareStateHeader->Plane1Offset = VGA_PLANE_0_OFFSET;
    hardwareStateHeader->Plane2Offset = VGA_PLANE_1_OFFSET;
    hardwareStateHeader->Plane3Offset = VGA_PLANE_2_OFFSET;
    hardwareStateHeader->Plane4Offset = VGA_PLANE_3_OFFSET;

    //
    // Now copy the contents of video VRAM into the buffer.
    //
    // The VGA hardware is already set up so that video memory is readable;
    // we already turned off Chain mode, mapped in at A0000, turned off Chain4,
    // turned off odd/even, and set read mode 0 when we saved the latches.
    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // Point to the save area for the first plane.
    //

    bufferPointer = ((PUCHAR) (hardwareStateHeader)) +
                     hardwareStateHeader->Plane1Offset;

    //
    // Save the four planes consecutively.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Read Map to select the plane we want to save next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Copy this plane into the buffer.
        //
        // Some cirrus cards have a bug where DWORD reads from
        // the frame buffer fail.  When we restore the video
        // memory, fonts are corrupted.
        //

#if 1
        {
            int c;

            for (c = 0; c < VGA_PLANE_SIZE / 2; c++)
            {
                ((PUSHORT)bufferPointer)[c] =
                    ((PUSHORT)(HwDeviceExtension->VideoMemoryAddress))[c];
            }
        }
#else
        VideoPortMoveMemory(bufferPointer,
                           (PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           VGA_PLANE_SIZE);
#endif

        //
        // Point to the next plane's save area.
        //

        bufferPointer += VGA_PLANE_SIZE;
    }

    return NO_ERROR;

} // end VgaSaveHardwareState()

//---------------------------------------------------------------------------
VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Returns information needed in order for caller to implement bank
         management.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BankSelect - Pointer to a VIDEO_BANK_SELECT structure in which the bank
             select data will be returned (output buffer).

    BankSelectSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a variable in which to return the actual size of
        the data returned in the output buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_MORE_DATA - output buffer not large enough to hold all info (but
        Size is returned, so caller can tell how large a buffer to allocate)

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode selection

--*/

{

#ifdef _X86_

    ULONG codeSize;
    ULONG codePlanarSize;
    ULONG codeEnablePlanarSize;
    ULONG codeDisablePlanarSize;
    PUCHAR pCodeDest;
    PUCHAR pCodeBank;
    PUCHAR pCodePlanarBank;
    PUCHAR pCodeEnablePlanar;
    PUCHAR pCodeDisablePlanar;

    ULONG AdapterType = HwDeviceExtension->ChipType;
    PVIDEOMODE pMode = HwDeviceExtension->CurrentMode;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // The minimum passed buffer size is a VIDEO_BANK_SELECT
    // structure, so that we can return the required size; we can't do
    // anything if we don't have at least that much buffer.
    //

    if (BankSelectSize < sizeof(VIDEO_BANK_SELECT)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Determine the banking type, and set whether any banking is actually
    // supported in this mode.
    //

    BankSelect->BankingFlags = 0;
    codeSize = 0;
    codePlanarSize = 0;
    pCodeBank = NULL;

    switch(pMode->banktype) {

    case NoBanking:

        BankSelect->BankingType = VideoNotBanked;
        BankSelect->Granularity = 0;

        break;

    case PlanarHCBanking:

        BankSelect->BankingFlags = PLANAR_HC; // planar mode supported

#if ONE_64K_BANK
        //
        // The Cirrus Logic VGA's support one 64K read/write bank.
        //

        BankSelect->PlanarHCBankingType = VideoBanked1RW;
        BankSelect->PlanarHCGranularity = 0x10000; // 64K bank start adjustment
                                                   //  in planar HC mode as well
#endif
#if TWO_32K_BANKS
        //
        // The Cirrus Logic VGA's support two 32K read/write banks.
        //

        BankSelect->PlanarHCBankingType = VideoBanked2RW;
        BankSelect->PlanarHCGranularity = 0x8000; // 32K bank start adjustment
                                                  //  in planar HC mode as well
#endif

        // 64K bank start adjustment in planar HC mode as well

        if ((HwDeviceExtension->ChipType != CL6410) &&
            (HwDeviceExtension->ChipType != CL6420))
        {
            if ((HwDeviceExtension->ChipType != CL542x) &&
                (HwDeviceExtension->ChipType != CL6245))
            {
                codePlanarSize =  ((ULONG)&CL543xPlanarHCBankSwitchEnd) -
                                 ((ULONG)&CL543xPlanarHCBankSwitchStart);

                pCodePlanarBank = &CL543xPlanarHCBankSwitchStart;
            }
            else
            {
                codePlanarSize =  ((ULONG)&CL542xPlanarHCBankSwitchEnd) -
                                  ((ULONG)&CL542xPlanarHCBankSwitchStart);

                pCodePlanarBank = &CL542xPlanarHCBankSwitchStart;
            }

            codeEnablePlanarSize = ((ULONG)&CL542xEnablePlanarHCEnd) -
                                   ((ULONG)&CL542xEnablePlanarHCStart);

            codeDisablePlanarSize = ((ULONG)&CL542xDisablePlanarHCEnd) -
                                    ((ULONG)&CL542xDisablePlanarHCStart);
            pCodeEnablePlanar = &CL542xEnablePlanarHCStart;
            pCodeDisablePlanar = &CL542xDisablePlanarHCStart;

        }
        else
        {   // must be a CL64xx product

            codePlanarSize =  ((ULONG)&CL64xxPlanarHCBankSwitchEnd) -
                              ((ULONG)&CL64xxPlanarHCBankSwitchStart);

            codeEnablePlanarSize = ((ULONG)&CL64xxEnablePlanarHCEnd) -
                                   ((ULONG)&CL64xxEnablePlanarHCStart);

            codeDisablePlanarSize = ((ULONG)&CL64xxDisablePlanarHCEnd) -
                                    ((ULONG)&CL64xxDisablePlanarHCStart);

            pCodePlanarBank = &CL64xxPlanarHCBankSwitchStart;
            pCodeEnablePlanar = &CL64xxEnablePlanarHCStart;
            pCodeDisablePlanar = &CL64xxDisablePlanarHCStart;
        }

    //
    // Fall through to the normal banking case
    //

    case NormalBanking:

#if ONE_64K_BANK
        //
        // The Cirrus Logic VGA's support one 64K read/write bank.
        //

        BankSelect->BankingType = VideoBanked1RW;
        BankSelect->Granularity = 0x10000;
#endif
#if TWO_32K_BANKS
        //
        // The Cirrus Logic VGA's support two 32K read/write banks.
        //

        BankSelect->BankingType = VideoBanked2RW;
        BankSelect->Granularity = 0x8000;
#endif

        if ((AdapterType == CL542x) ||
            (AdapterType == CL6245))
        {

            codeSize = ((ULONG)&CL542xBankSwitchEnd) -
                       ((ULONG)&CL542xBankSwitchStart);

            pCodeBank = &CL542xBankSwitchStart;

        }
        else if  ((AdapterType == CL6410) ||
                  (AdapterType == CL6420))
        {
            codeSize = ((ULONG)&CL64xxBankSwitchEnd) -
                       ((ULONG)&CL64xxBankSwitchStart);

            pCodeBank = &CL64xxBankSwitchStart;
        }
        else
        {
            codeSize = ((ULONG)&CL543xBankSwitchEnd) -
                       ((ULONG)&CL543xBankSwitchStart);

            pCodeBank = &CL543xBankSwitchStart;

        }

        break;
    }

    //
    // Size of banking info.
    //

    BankSelect->Size = sizeof(VIDEO_BANK_SELECT) + codeSize;

    if (BankSelect->BankingFlags & PLANAR_HC) {

        BankSelect->Size += codePlanarSize + codeEnablePlanarSize +
            codeDisablePlanarSize;

    }

    //
    // This serves an a ID for the version of the structure we're using.
    //

    BankSelect->Length = sizeof(VIDEO_BANK_SELECT);

    //
    // If the buffer isn't big enough to hold all info, just return
    // ERROR_MORE_DATA; Size is already set.
    //

    if (BankSelectSize < BankSelect->Size ) {

        //
        // We're returning only the VIDEO_BANK_SELECT structure.
        //

        *OutputSize = sizeof(VIDEO_BANK_SELECT);
        return ERROR_MORE_DATA;
    }

    //
    // There's room enough for everything, so fill in all fields in
    // VIDEO_BANK_SELECT. (All fields are always returned; the caller can
    // just choose to ignore them, based on BankingFlags and BankingType.)
    //

    BankSelect->BitmapWidthInBytes = pMode->wbytes;
    BankSelect->BitmapSize = pMode->sbytes;

    //
    // Copy all banking code into the output buffer.
    //

    pCodeDest = (PUCHAR)BankSelect + sizeof(VIDEO_BANK_SELECT);

    if (pCodeBank != NULL) {

        BankSelect->CodeOffset = pCodeDest - (PUCHAR)BankSelect;

        VideoPortMoveMemory(pCodeDest,
                            pCodeBank,
                            codeSize);

        pCodeDest += codeSize;
    }

    if (BankSelect->BankingFlags & PLANAR_HC) {

        //
        // Copy appropriate high-color planar Bank Switch code:
        //

        BankSelect->PlanarHCBankCodeOffset = pCodeDest - (PUCHAR)BankSelect;

        VideoPortMoveMemory(pCodeDest,
                            pCodePlanarBank,
                            codePlanarSize);

        pCodeDest += codePlanarSize;

        //
        // Copy high-color planar bank mode Enable code:
        //

        BankSelect->PlanarHCEnableCodeOffset = pCodeDest - (PUCHAR)BankSelect;

        VideoPortMoveMemory(pCodeDest,
                            pCodeEnablePlanar,
                            codeEnablePlanarSize);

        pCodeDest += codeEnablePlanarSize;

        //
        // Copy high-color planar bank mode Disable code:
        //

        BankSelect->PlanarHCDisableCodeOffset = pCodeDest - (PUCHAR)BankSelect;

        VideoPortMoveMemory(pCodeDest,
                            pCodeDisablePlanar,
                            codeDisablePlanarSize);

    }

    //
    // Number of bytes we're returning is the full banking info size.
    //

    *OutputSize = BankSelect->Size;

    return NO_ERROR;

#else

    //
    // This function is only defined for x86
    //

    return ERROR_INVALID_FUNCTION;

#endif
} // end VgaGetBankSelectCode()

//---------------------------------------------------------------------------
VP_STATUS
VgaValidatorUcharEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    )

/*++

Routine Description:

    Entry point into the validator for byte I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;
    UCHAR tempB ;
    ULONG portIO ;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_UCHAR_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) == END_SYNC_RESET_VALUE) &&
                 (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If we are accessing the seq address port, keep track of the
                // data value
                //

                if (Port == SEQ_ADDRESS_PORT) {

                    hwDeviceExtension->SequencerAddressValue = *Data;

                }

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                             (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                tempB = (UCHAR) (*Data & 0xF7) ;
                portIO = Port ;
                IOWaitDisplEnableThenWrite ( hwDeviceExtension,
                                            portIO,
                                            tempB ) ;

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                            SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            //
            // If we get an access to the sequencer register, start trapping.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 (VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_UCHAR_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

        }
    }

    return NO_ERROR;

} // end VgaValidatorUcharEntry()

//---------------------------------------------------------------------------
VP_STATUS
VgaValidatorUshortEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    )

/*++

Routine Description:

    Entry point into the validator for word I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;
    UCHAR tempB ;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }
                endEmulation = 0;
            }
        }
        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //
        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);
        //
        // Write back the real value of the sequencer address port.
        //
        VideoPortWritePortUchar((PUCHAR) (hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT),
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);
        //
        // If we are in a READ path, read the data
        //
        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress
                                                + Port));
            endEmulation = 0;
        }
        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //
        if (endEmulation) {
            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);
            return NO_ERROR;
        }
        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //
        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));
    } else {
        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //
        if (AccessMode & EMULATOR_WRITE_ACCESS) {
            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //
            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                             (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             (ULONG)Port),
                                             (USHORT) (*Data & 0xFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                             (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);
                return NO_ERROR;
            }
            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                             FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_USHORT_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;
                //
                // Start keeping track of the state of the sequencer port.
                //
                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;
            } else {
                VideoPortWritePortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                             Port),
                                         *Data);
            }
        } else {
            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                            Port));
        }
    }
    return NO_ERROR;

} // end VgaValidatorUshortEntry()

//---------------------------------------------------------------------------
VP_STATUS
VgaValidatorUlongEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    )

/*++

Routine Description:

    Entry point into the validator for dword I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    PHW_DEVICE_EXTENSION HwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    if (hwDeviceExtension->TrappedValidatorCount) {
        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //
        if (AccessMode & EMULATOR_WRITE_ACCESS) {
            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //
            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {
                *Data &= 0xFFFFFFF7;
            }
            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;
            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_ULONG_ACCESS;
            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;
            hwDeviceExtension->TrappedValidatorCount++;
            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //
            if (Port == SEQ_ADDRESS_PORT) {
                //
                // If we are accessing the seq address port, keep track of its
                // value
                //
                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);
            }
            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {
                endEmulation = 1;
            } else {
                //
                // If the buffer is not full, then just return right away.
                //
                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {
                    return NO_ERROR;
                }
                endEmulation = 0;
            }
        }
        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //
        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;
        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;
        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));
        hwDeviceExtension->TrappedValidatorCount++;
        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);
        //
        // Write back the real value of the sequencer address port.
        //
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);
        //
        // If we are in a READ path, read the data
        //
        if (AccessMode & EMULATOR_READ_ACCESS) {
            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                               Port));
            endEmulation = 0;
        }
        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //
        if (endEmulation) {
            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);
            return NO_ERROR;
        }
        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //
        hwDeviceExtension->TrappedValidatorCount = 1;
        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;
        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;
        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {
        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //
        if (AccessMode & EMULATOR_WRITE_ACCESS) {
            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //
            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {
                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT);
                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                             (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));
                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                             Port),
                                             (ULONG) (*Data & 0xFFFFFFF7) );
                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                             (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));
                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);
                return NO_ERROR;
            }
            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {
                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);
                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_ULONG_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;
                //
                // Start keeping track of the state of the sequencer port.
                //
                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {
                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                            Port),
                                        *Data);

            }
        } else {
            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                           Port));
        }
    }
    return NO_ERROR;

} // end VgaValidatorUlongEntry()

//---------------------------------------------------------------------------
BOOLEAN
VgaPlaybackValidatorData(
    PVOID Context
    )
/*++
Routine Description:

    Performs all the DOS apps IO port accesses that were trapped by the
    validator. Only IO accesses that can be processed are WRITEs

    The number of outstanding IO access in deviceExtension is set to
    zero as a side effect.

    This function must be called via a call to VideoPortSynchronizeRoutine.

Arguments:

    Context - Context parameter passed to the synchronized routine.
        Must be a pointer to the miniport driver's device extension.

Return Value:

    TRUE.
--*/
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = Context;
    PHW_DEVICE_EXTENSION HwDeviceExtension = Context;
    ULONG_PTR ioBaseAddress = PtrToUlong(hwDeviceExtension->IOAddress);
    UCHAR i;
    PVGA_VALIDATOR_DATA validatorData = hwDeviceExtension->TrappedValidatorData;
    //
    // Loop through the array of data and do instructions one by one.
    //
    for (i = 0; i < hwDeviceExtension->TrappedValidatorCount;
         i++, validatorData++) {
        //
        // Calculate base address first
        //
        ioBaseAddress = PtrToUlong(hwDeviceExtension->IOAddress) +
                            validatorData->Port;
        //
        // This is a write operation. We will automatically stop when the
        // buffer is empty.
        //

        switch (validatorData->AccessType) {

        case VGA_VALIDATOR_UCHAR_ACCESS :

            VideoPortWritePortUchar((PUCHAR)ioBaseAddress,
                                    (UCHAR) validatorData->Data);

            break;

        case VGA_VALIDATOR_USHORT_ACCESS :

            VideoPortWritePortUshort((PUSHORT)ioBaseAddress,
                                     (USHORT) validatorData->Data);

            break;

        case VGA_VALIDATOR_ULONG_ACCESS :

            VideoPortWritePortUlong((PULONG)ioBaseAddress,
                                    (ULONG) validatorData->Data);

            break;

        default:

            VideoDebugPrint((1, "InvalidValidatorAccessType\n" ));
        }
    }
    hwDeviceExtension->TrappedValidatorCount = 0;

    return TRUE;

} // end VgaPlaybackValidatorData()

//---------------------------------------------------------------------------
BOOLEAN
CirrusLogicIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

    This routine returns TRUE if an CL6410, 6420, 542x, or 543x is present.
    It assumes that it's already been established that a VGA is present.
    It performs the Cirrus Logic recommended ID test for each chip type:

    6410: we try to enable the extension registers and read back a 1, then
    disable the extensions are read back a 0 in GR0A.

    6420: same as above

    54xx: Enable extended registers by writing 0x12 to the extensions
          enable register, and reading back 0x12.  Then read from the
          ID register and make sure it specifies a 542x, 543x.
          Finally, disable the extensions and make sure the
          extensions enable register reads back 0x0F.

    If this function fails to find an Cirrus Logic VGA, it attempts to undo any
    damage it may have inadvertently done while testing.

    If a Cirrus Logic VGA is found, the adapter is returned to its original
    state after testing is finished, except that extensions are left enabled.

Arguments:

    None.

Return Value:

    TRUE if an CL6410/6420/542x/543x is present, FALSE if not.

--*/

{
    #define MAX_ROM_SCAN 4096

    UCHAR   *pRomAddr;
    PHYSICAL_ADDRESS paRom = {0x000C0000,0x00000000};

    UCHAR originalGRIndex;
    UCHAR originalGR0A;
    UCHAR originalCRTCIndex;
    UCHAR originalSeqIndex;
    UCHAR originalExtsEnb;
    UCHAR SystemBusSelect;
    PUCHAR CRTCAddressPort, CRTCDataPort;
    UCHAR temp1, temp2, temp3;
    UCHAR revision;
    ULONG rev10bit;

    BOOLEAN retvalue = FALSE;    // default return value

    // Set default value, assuming it is not CL-GD5480.

    HwDeviceExtension->BitBLTEnhance = FALSE ;

    //
    // first, save the Graphics controller index
    //

    originalGRIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT);

    //
    // Then save the value of GR0A
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, CL64xx_EXTENSION_ENABLE_INDEX);
    originalGR0A = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // then, Unlock the CL6410 extended registers., GR0A = 0ECH
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, CL64xx_EXTENSION_ENABLE_VALUE);

    //
    // read back GR0A, it should be a 1
    //

    temp1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // then, Lock the CL6410 extended registers., GR0A = 0CEH
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, CL64xx_EXTENSION_DISABLE_VALUE);

    //
    // read back GR0A, it should be a 0
    //

    temp2 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // restore the GR0A value
    // this will not have any effect if the chip IS a CL6410 or 6420
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalGR0A);

    //
    // now restore the graphics index
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, originalGRIndex);

    //
    // now test to see if the returned values were correct!
    //

    if ((temp1 == 1) && (temp2 == 0))
    {
        //
        // By golly, it *is* a CL6410 or CL6420!
        //
        // but now we have to determine the chip type, and which display is
        // active.
        // reenable the extension registers first
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), CL64xx_EXTENSION_ENABLE_INDEX +
            (CL64xx_EXTENSION_ENABLE_VALUE << 8));

        //
        // now get the chip type at ERAA
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, 0xaa);

        revision = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
             GRAPH_DATA_PORT);

        //
        // now restore the graphics index
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
         GRAPH_ADDRESS_PORT, originalGRIndex);

        if ((revision & 0xf0) == 0x80)      // 6410 rev code
        {
            VideoDebugPrint((1, "CL 6410 found\n"));

            //
            // we don't support 6340 in this driver, so force it not to be
            // installed.
            //

            if (!CirrusFind6340(HwDeviceExtension))
            {
                HwDeviceExtension->ChipType = CL6410;
                HwDeviceExtension->AdapterMemorySize = 0x00040000; // 256K
                HwDeviceExtension->DisplayType =
                                 CirrusFind6410DisplayType(HwDeviceExtension);
                retvalue = TRUE;
            }
        }
        else if ((revision & 0xf0) == 0x70)           // 6420 rev code
        {
            VideoDebugPrint((1, "CL 6420 found\n"));

            //
            // we don't support 6340 in this driver, so force it not to be
            // installed.
            //

            if (!CirrusFind6340(HwDeviceExtension))
            {
                HwDeviceExtension->ChipType = CL6420;
                HwDeviceExtension->ChipRevision = (USHORT) revision;
                HwDeviceExtension->DisplayType =
                                 CirrusFind6410DisplayType(HwDeviceExtension);

                VideoDebugPrint((2, "CL 64xxx Adapter Memory size = %08lx\n",
                                 HwDeviceExtension->AdapterMemorySize));


                retvalue = TRUE;
            }
        }
        else  // we dont support 5410 at this time
        {
            VideoDebugPrint((1, "Unsupported CL VGA chip found\n"));
        }
    }

    if (retvalue == FALSE)         // Did not detect a 64x0, see if it's a 542x
    {
        //
        // Determine where the CRTC registers are addressed (color or mono).
        //
        CRTCAddressPort = HwDeviceExtension->IOAddress;
        CRTCDataPort = HwDeviceExtension->IOAddress;

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT) & 0x01)
        {

            CRTCAddressPort += CRTC_ADDRESS_PORT_COLOR;
            CRTCDataPort += CRTC_DATA_PORT_COLOR;

        }
        else
        {
            CRTCAddressPort += CRTC_ADDRESS_PORT_MONO;
            CRTCDataPort += CRTC_DATA_PORT_MONO;
        }

        //
        // Save the original state of the CRTC and Sequencer Indices.
        //

        originalCRTCIndex = VideoPortReadPortUchar(CRTCAddressPort);
        originalSeqIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                          SEQ_ADDRESS_PORT);
        //
        // Try to enable all extensions:
        // a) Set the Sequencer Index to IND_CL_EXTS_ENB.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                IND_CL_EXTS_ENB);

        //
        // b) Save the original state of Sequencer register IND_CL_EXTS_ENB.
        //

        originalExtsEnb = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                          SEQ_DATA_PORT);

        //
        // c) Write enabling value (0x12) to extension enable register
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),(USHORT)((0x12 << 8) + IND_CL_EXTS_ENB));
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                IND_CL_EXTS_ENB);
        temp1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

        //
        // Read Chip ID Value from CRTC Register (Ignoring revision bits)
        //

        VideoPortWritePortUchar(CRTCAddressPort, IND_CL_ID_REG);
        temp3 = VideoPortReadPortUchar(CRTCDataPort);

        //
        // Detect if CL-GD6245 chips ID=0x16
        //
        if (temp3 != 0x16)
        {
            rev10bit = (ULONG)temp3 & 0x3;  // lo bits of ID are high bits of rev code
            temp3 = temp3 >> 2;   // shift off revision bits
        }

        //
        // Write another value (!= 0x12) to IND_CL_EXTS_ENB to disable extensions
        // Should read back as 0x0F
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),(USHORT)((0 << 8) + IND_CL_EXTS_ENB));
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                IND_CL_EXTS_ENB);
        temp2 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

        //
        // Restore the original IND_CL_EXTS_ENB state.
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress
              + SEQ_ADDRESS_PORT),
                (USHORT)((originalExtsEnb << 8) + IND_CL_EXTS_ENB));

        //
        // Check values read from IND_CL_EXTS_ENB and IND_CL_ID_REG to be correct
        //

        if ((temp1 != (UCHAR) (0x12)) ||
            (temp2 != (UCHAR) (0x0F)) ||
            (temp3 >  (UCHAR) (0x2F)) ||        // 2F is 5480
            (temp3 <  (UCHAR) (0x0B)) )         // 0B is Nordic (7542)
        {
            //
            // Did not find appropriate CL VGA Chip.
            //

            VideoDebugPrint((1, "CL VGA chip not found\n"));

            retvalue = FALSE;
        }

        //
        // Detect if CL-GD6245 chips
        //
        else if ((temp1 == (UCHAR) (0x12)) &&
                 (temp2 == (UCHAR) (0x0F)) &&
                 (temp3 == (UCHAR) (0x16)))     //6245
        {
            VideoDebugPrint((1, "CL 6245 found\n"));
            HwDeviceExtension->ChipType = CL6245;
            HwDeviceExtension->DisplayType =
                    CirrusFind6245DisplayType(HwDeviceExtension,
                                              CRTCAddressPort,
                                              CRTCDataPort);
            retvalue = TRUE;
        }
        else
        {

            //
            // It's a supported CL adapter.
            //
            // Save actual Chip ID in ChipRevision field of HwDeviceExtension
            //

            HwDeviceExtension->ChipRevision = temp3;
            if ((temp3 > (UCHAR) (0x27)) ||       // 27 is 5429
                (temp3 < (UCHAR) (0x22) ) )       // 22 is 5422
            {
                if ((temp3 >= (UCHAR) (0x0B)) &&  // Nordic
                    (temp3 <= (UCHAR) (0x0E)) )   // Everest

                {
                    if (temp3 == (UCHAR)0x0B)
                    {
                        VideoDebugPrint((1, "CL 7542 found\n"));        //myf32
                        HwDeviceExtension->ChipType = CL7542;
                    }
                    if (temp3 == (UCHAR)0x0C)
                    {
                        VideoDebugPrint((1, "CL 7543 found\n"));        //myf32
                        HwDeviceExtension->ChipType = CL7543;
                    }
                    if (temp3 == (UCHAR)0x0D)
                    {
                        VideoDebugPrint((1, "CL 7541 found\n"));        //myf32
                        HwDeviceExtension->ChipType = CL7541;
                    }
                    if (temp3 == (UCHAR)0x0E)
                    {
                        VideoDebugPrint((1, "CL 7548 found\n"));        //myf32
                        HwDeviceExtension->ChipType = CL7548;
                    }
                    HwDeviceExtension->DisplayType =
                        CirrusFind754xDisplayType(HwDeviceExtension,
                                                  CRTCAddressPort,
                                                  CRTCDataPort);
                } else if ((temp3 == (UCHAR) (0x10)) ||
                           (temp3 == (UCHAR) (0x13))) {  //myf17, CF
                    if (temp3 == (UCHAR)0x10)
                    {
                        VideoDebugPrint((1, "CL 7555 found\n")) ;
                        HwDeviceExtension->ChipType = CL7555;
                    }
                    if (temp3 == (UCHAR)0x13)
                    {
                        VideoDebugPrint((1, "CL 7556 found\n")) ;
                        HwDeviceExtension->ChipType = CL7556;
                    }
                    HwDeviceExtension -> DisplayType =
                      CirrusFind755xDisplayType(HwDeviceExtension,
                                                  CRTCAddressPort,
                                                  CRTCDataPort) ;
                     } else if (temp3 == (UCHAR) (0x11)) {
                         VideoDebugPrint((1, "CL 756x found\n")) ;
                         HwDeviceExtension->ChipType = CL756x ;
                         HwDeviceExtension->DisplayType =
                        CirrusFind755xDisplayType(HwDeviceExtension,
                                                  CRTCAddressPort,
                                                  CRTCDataPort) ;
                } else {
                    VideoDebugPrint((1, "CL 543x found\n"));
                    HwDeviceExtension->ChipType = CL543x;
                    HwDeviceExtension->DisplayType = crt;

                                                                                // jl03  Read CR27(b1 & b0) + CR25 for chip revision
                    VideoPortWritePortUchar(CRTCAddressPort, IND_CL_REV_REG);
                    revision = (VideoPortReadPortUchar(CRTCDataPort));
                    rev10bit = (ULONG)(rev10bit << 8) | revision;

                                                                                if (temp3 == (UCHAR) (0x2A))      // or a 5434?
                    {
                        VideoDebugPrint((1, "CL 5434 found\n"));

                        //
                        //Default to .8u 5434
                        //

                        HwDeviceExtension->ChipType = CL5434;

                        //
                        // Read the revision code from CR25&27 and compare to
                        // lowest rev that we know to be .6u
                        //
/* jl03
                        VideoPortWritePortUchar(CRTCAddressPort, IND_CL_REV_REG);
                        revision = (VideoPortReadPortUchar(CRTCDataPort));
                        rev10bit = (ULONG)(rev10bit << 8) | revision;
*/
                        if ((rev10bit >= 0xB0) ||  // B0 is rev "EP", first .6u 5434
                            (rev10bit == 0x28) )   // 28 is rev "AH" also .6u 5434
                        {
                            VideoDebugPrint((1, "CL 5434.6 found\n"));
                            HwDeviceExtension->ChipType = CL5434_6;
                        }
                    } else if (temp3 == (UCHAR) (0x2B)) {           // 5436
                        HwDeviceExtension->ChipType = CL5436 ;
                    } else if (temp3 == (UCHAR) (0x2E)) {           // 5446
                        HwDeviceExtension->ChipType = CL5446 ;
                        if (rev10bit == 0x45)
                           HwDeviceExtension->ChipType = CL5446BE ; // jl02  5446-BE
                    } else if (temp3 == (UCHAR) (0x2F)) {           // 5480
                        HwDeviceExtension->ChipType = CL5480;
                        HwDeviceExtension->BitBLTEnhance = TRUE ;
                    } else if (temp3 == (UCHAR) (0x3A)) {           // 54UM36 ?
                        HwDeviceExtension->ChipType = CL54UM36 ;
                    }
                }
            }
            else
            {
                VideoDebugPrint((1, "CL 542x found\n"));
                HwDeviceExtension->ChipType = CL542x;
                HwDeviceExtension->DisplayType = crt;
            }

            retvalue = TRUE;
        }

        //
        // Restore modified index registers
        //

        VideoPortWritePortUchar(
             (HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT),
             originalSeqIndex);

        VideoPortWritePortUchar(CRTCAddressPort, originalCRTCIndex);
    }

    if (retvalue)
    {
         //
         // Restore the original Sequencer and CRTC Indices.
         //

         HwDeviceExtension->AutoFeature = FALSE ;

         if ((HwDeviceExtension->ChipType == CL5436) ||
             (HwDeviceExtension->ChipType == CL5446) ||
             (HwDeviceExtension->ChipType == CL5446BE) ||
             (HwDeviceExtension->ChipType == CL5480) ||
             (HwDeviceExtension->ChipType &  CL754x) ||
             (HwDeviceExtension->ChipType &  CL755x) ||
             (HwDeviceExtension->ChipType == CL54UM36))
         {
             HwDeviceExtension->AutoFeature = TRUE;
         }
    }

   return retvalue;

} // CirrusLogicIsPresent()


//---------------------------------------------------------------------------
#ifdef PANNING_SCROLL
VP_STATUS
CirrusSetDisplayPitch (
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PANNMODE PanningMode
   )
{

    PUCHAR CRTCAddressPort, CRTCDataPort;
    USHORT RequestedPitchInBytes =  PanningMode.wbytes;
    USHORT PitchInQuadWords = RequestedPitchInBytes >> 3;
    UCHAR   savSEQidx, Panel_Type, LCD, ChipID;

    //
    // Determine where the CRTC registers are addressed (color or mono).
    //

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        CRTCAddressPort = CRTC_ADDRESS_PORT_COLOR;
        CRTCDataPort = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        CRTCAddressPort = CRTC_ADDRESS_PORT_MONO;
        CRTCDataPort = CRTC_DATA_PORT_MONO;
    }


    //
    // Write out the requested pitch in quad words to CR13
    //

    VideoPortWritePortUchar(CRTCAddressPort, 0x13);
    VideoPortWritePortUchar(CRTCDataPort,
                            (UCHAR) (PitchInQuadWords & 0xFF) );
    //
    // See if requested pitch overflows to bit 4 in CR1B
    // NOTE: In either case we must either set or reset the bit.
    //

    VideoPortWritePortUchar(CRTCAddressPort, 0x1B);
    if (PitchInQuadWords & 0x100)
    {
       VideoPortWritePortUchar(CRTCDataPort,
          (UCHAR)(VideoPortReadPortUchar(CRTCDataPort) | 0x10) );
    }
    else
    {
       VideoPortWritePortUchar(CRTCDataPort,
          (UCHAR)(VideoPortReadPortUchar(CRTCDataPort) & ~0x10) );
    }

    VideoDebugPrint((1,"CirrusSetDisplayPitch - Exit (not error)\n"));

    return NO_ERROR;
}

#endif // PANNING_SCROLL

//---------------------------------------------------------------------------
//
// The memory manager needs a "C" interface to the banking functions
//

/*++

Routine Description:

    Each of these functions is a "C" callable interface to the ASM banking
    functions.  They are NON paged because they are called from the
    Memory Manager during some page faults.

Arguments:

    iBankRead -     Index of bank we want mapped in to read from.
    iBankWrite -    Index of bank we want mapped in to write to.

Return Value:

    None.

--*/


VOID
vBankMap_CL64xx(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    )
{
    VideoDebugPrint((1, "vBankMap_CL64xx(%d,%d) - enter\n",iBankRead,iBankWrite));
#ifdef _X86_
    _asm {
        mov     eax,iBankRead
        mov     edx,iBankWrite
        lea     ebx,CL64xxBankSwitchStart
        call    ebx
    }
#endif
    VideoDebugPrint((1, "vBankMap_CL64xx - exit\n"));
}


VOID
vBankMap_CL543x(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    )
{
    VideoDebugPrint((1, "vBankMap_CL543x(%d,%d) - enter\n",iBankRead,iBankWrite));
#ifdef _X86_
    _asm {
        mov     eax,iBankRead
        mov     edx,iBankWrite
        lea     ebx,CL543xBankSwitchStart
        call    ebx
    }
#endif
    VideoDebugPrint((1, "vBankMap_CL543x - exit\n"));
}

VOID
vBankMap_CL542x(
    ULONG iBankRead,
    ULONG iBankWrite,
    PVOID pvContext
    )
{
    VideoDebugPrint((1, "vBankMap_CL542x(%d,%d) - enter\n",iBankRead,iBankWrite));
#ifdef _X86_
    _asm {
        mov     eax,iBankRead
        mov     edx,iBankWrite
        lea     ebx,CL542xBankSwitchStart
        call    ebx
    }
#endif
    VideoDebugPrint((1, "vBankMap_CL542x - exit\n"));
}


//---------------------------------------------------------------------------
ULONG
CirrusFindVmemSize(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns the amount of vram detected for the
    Cirrus Logic 6420 and 542x ONLY. It assumes that it is already known that
    a Cirrus Logic VGA is in the system.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    Number of butes of VRAM.

--*/
{

    UCHAR temp;
    ULONG memsize=0;
    UCHAR originalSeqIndex;
    UCHAR originalGraphicsIndex;
    UCHAR PostScratchPad;

    if (HwDeviceExtension->ChipType == CL6420) {

#ifdef _X86_

        originalGraphicsIndex =
            VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
                                   GRAPH_ADDRESS_PORT));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                GRAPH_ADDRESS_PORT, 0x9a); // Video memory config register

        temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                      GRAPH_DATA_PORT);    // get the data

        if ((temp & 0x07) == 0) { // 0 is accurate always

             memsize = 0x00040000;

        } else {

            //
            // We know now that the amount of vram is >256k. But we don't
            // know if it is 512k or 1meg.
            // They tell us to actually go out and see if memory is there by
            // writing into it and reading it back.
            //

            VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                     SEQ_ADDRESS_PORT),0x0f02);

            VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                     GRAPH_ADDRESS_PORT),0x0506);

            //
            // now pick a bank, and do the write
            //

            SetCirrusBanking(HwDeviceExtension,1);        // start of 2nd 256k

            VideoPortWriteRegisterUchar(HwDeviceExtension->VideoMemoryAddress,
                                        0x55);

            SetCirrusBanking(HwDeviceExtension,3);    // 3*256k is 768k

            VideoPortWriteRegisterUchar(HwDeviceExtension->VideoMemoryAddress,
                                        0xaa);

            SetCirrusBanking(HwDeviceExtension,1);        // start of 2nd 256k

            if (VideoPortReadRegisterUchar(HwDeviceExtension->VideoMemoryAddress)
                    == 0x55)  {

                memsize = 0x00100000; // 1 MEG

            } else {

                memsize = 0x00080000; // 512K
            }

            SetCirrusBanking(HwDeviceExtension,0);    // reset the memory value

            VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

            VideoPortWritePortUchar((HwDeviceExtension->IOAddress
                                    + GRAPH_ADDRESS_PORT),
                                    originalGraphicsIndex);
        }

        VideoPortWritePortUchar((HwDeviceExtension->IOAddress +
                                   GRAPH_ADDRESS_PORT), originalGraphicsIndex);

#endif
        return memsize;


   } else {   // its 542x or 543x

        originalSeqIndex = VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT));

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 SEQ_ADDRESS_PORT),
                                 (USHORT)((0x12 << 8) + IND_CL_EXTS_ENB));

        //
        // Read the POST scratch pad reg to determine amount of Video
        // memory
        //

        if (HwDeviceExtension->ChipType == CL542x) {
           VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                   IND_CL_SCRATCH_PAD);

           PostScratchPad = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                   SEQ_DATA_PORT);
           PostScratchPad = ((PostScratchPad & 0x18) >> 3);  // in bits 3 and 4
        }
        else if (HwDeviceExtension->ChipType == CL6245) {
           VideoPortWritePortUchar((HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT),originalSeqIndex);
           memsize = 0x00080000; // 512K
           return memsize;
        }

        else
         {    // its 543x or 754x
           if ((HwDeviceExtension->ChipType &  CL754x) ||
               (HwDeviceExtension->ChipType &  CL755x) ||
               (HwDeviceExtension->ChipType == CL756x))
            {
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                   IND_NORD_SCRATCH_PAD);
            }
           else // it's 543x, 5434, or 5434_6 by default
            {
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                   IND_ALP_SCRATCH_PAD);
            }
           // Nordic family uses same bits as 543x, but in different register
           PostScratchPad = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                   SEQ_DATA_PORT);
           PostScratchPad &= 0x0F; // It's in bits 0-3
        }
        VideoPortWritePortUchar((HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT),
                                originalSeqIndex);

        //
        // Installed video memory is stored in scratch pad register by POST.
        //

        switch (PostScratchPad) {

        case 0x00:

            memsize = 0x00040000; // 256K
            break;

        case 0x01:

            memsize = 0x00080000; // 512K
            break;

        case 0x02:

            memsize = 0x00100000; // 1 MEG
            break;

        case 0x03:

            memsize = 0x00200000; // 2 MEG
            break;

        case 0x04:

            memsize = 0x00400000; // 4 MEG
            break;

        case 0x05:

            memsize = 0x00300000; // 3 MEG
            break;

        }

        //
        // The 542x cards don't properly address more than 1MB of
        // video memory, so lie and limit these cards to 1MB.
        //

        if ((HwDeviceExtension->ChipType == CL542x) &&
            (memsize > 0x00100000)) {

            memsize = 0x00100000; // 1 MEG

        }

        //
        // The memory size should not be zero!
        //

        ASSERT(memsize != 0);

        return memsize;
    }

} // CirrusFindVmemSize()

//---------------------------------------------------------------------------
VOID
SetCirrusBanking(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT BankNumber
    )
/*++

Routine Description:

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BankNumber - the 256k bank number to set in 1RW mode(we will set this mode).

Return Value:

    vmem256k, vmem512k, or vmem1Meg ONLY ( these are defined in cirrus.h).

--*/
{

    if ((HwDeviceExtension->ChipType == CL542x) ||
        (HwDeviceExtension->ChipType == CL6245)) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0x1206);

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0x010b);

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT),
                                 (USHORT)(0x0009 + (BankNumber << (8+4))) );

    } else if ((HwDeviceExtension->ChipType == CL543x) ||
               (HwDeviceExtension->ChipType &  CL755x) ||       //myf15, crus
               (HwDeviceExtension->ChipType &  CL754x) ) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0x1206);

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0x210b);

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT),
                                 (USHORT)(0x0009 + (BankNumber << (8+2))) );

    } else { // 6410 or 6420

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0xec0a);

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT), 0x030d);

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                                 GRAPH_ADDRESS_PORT),
                                 (USHORT)(0x000e + (BankNumber << (8+4))) );

    }

} // SetCirrusBanking()

//---------------------------------------------------------------------------
USHORT
CirrusFind6410DisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

   Determines the display type for CL6410 or CL6420 crt/panel controllers.
Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    crt, panel as defined in cirrus.h

--*/
{
    UCHAR originalGraphicsIndex;
    UCHAR temp1;

    //
    // now we need to check to see which display we are on...
    //

    originalGraphicsIndex =
        VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
                               GRAPH_ADDRESS_PORT));

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
        GRAPH_ADDRESS_PORT, 0xd6);

    temp1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                   GRAPH_DATA_PORT);

    VideoPortWritePortUchar((HwDeviceExtension->IOAddress
                            + GRAPH_ADDRESS_PORT), originalGraphicsIndex);


    if (temp1 & 0x02) {  // display is LCD Panel

        return panel;

    } else {              // the display is a crt

        return crt;

    }

} // CirrusFind6410DisplayType()

// crus
//---------------------------------------------------------------------------
USHORT
CirrusFind6245DisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort, PUCHAR CRTCDataPort
    )

/*++

Routine Description:

   Determines the display type for CL6245 crt/panel controllers.
Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    crt, panel as defined in cirrus.h

--*/
{

    UCHAR originalCRTCIndex, originalLCDControl;
    UCHAR originalSEQIndex;
    USHORT temp2, temp4;
    USHORT temp1, temp3;

    //
    // we need to check to see which display we are on...
    //

    originalCRTCIndex = VideoPortReadPortUchar(CRTCAddrPort);
    VideoPortWritePortUchar(CRTCAddrPort, 0x20);
    temp1 = VideoPortReadPortUchar(CRTCDataPort);
    temp3 = 0;
    temp4 = 0;

    if (temp1 & 0x40) temp3 = 1;
    if (temp1 & 0x20)
    {
       originalSEQIndex =
                  VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                           SEQ_ADDRESS_PORT);
       VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                 SEQ_ADDRESS_PORT, 0x1A);
       temp4 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                 SEQ_DATA_PORT) & 0x40;
       VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                 SEQ_ADDRESS_PORT, originalSEQIndex);

      // Allow access to extended CRTC regs and read R8X[5], must CR1D[7]=1
      //
      VideoPortWritePortUchar(CRTCAddrPort, 0x1D);
      originalLCDControl = VideoPortReadPortUchar(CRTCDataPort);
      VideoPortWritePortUchar(CRTCDataPort,
                              (UCHAR) (originalLCDControl | 0x80));
      VideoPortWritePortUchar(CRTCAddrPort, 0x08);
      temp1 = (VideoPortReadPortUchar(CRTCDataPort) & 0x20);
      VideoPortWritePortUchar (CRTCAddrPort, 0x1D);
      VideoPortWritePortUchar (CRTCDataPort, originalLCDControl);

      // CR1C bit 6,7 set indicate LCD type, TFT, STN color or STN mono
      // STN mono, R8X bit 5 set Single or Dual
      // STN color, CR1C bit 7,6 must 10 & SR1A bit 6 set Dual or Single

      VideoPortWritePortUchar (CRTCAddrPort, 0x1C);
      temp2 = VideoPortReadPortUchar(CRTCDataPort) & 0xC0;
      if (temp2 == 0)           //STN mono LCD
      {
         if (temp1 == 0)
            temp3 |= (USHORT)Dual_LCD | Mono_LCD | STN_LCD;
         else
            temp3 |= (USHORT)Single_LCD | Mono_LCD | STN_LCD;
      }
      else if (temp2 == 0x80)           //STN color LCD
      {
         if (temp4)
         {
            temp3 |= (USHORT)Dual_LCD | Color_LCD | STN_LCD;
         }
         else
         {
            temp3 |= (USHORT)Single_LCD | Color_LCD | STN_LCD;
         }
      }
      else if (temp2 == 0xC0)           //TFT LCD
      {
         temp3 |= (USHORT)TFT_LCD;      //myf28
      }

      // Restore LCD Display Controls register and CRTC index to original state
      //
      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);

      return (temp3 | panel);
   }
   else              // the display is a crt
   {
      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);
      return (temp3);
   }


} // CirrusFind6245DisplayType()
// end crus

//---------------------------------------------------------------------------
USHORT
CirrusFind754xDisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort, PUCHAR CRTCDataPort
    )

/*++

Routine Description:

   Determines the display type for CL754x crt/panel controllers.
Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    CRTCAddrPort, CRTCDataPort - Index of CRTC registers for current mode.

Return Value:

    crt, panel, or panel8x6 as defined in cirrus.h

--*/
{
// crus
//
// update 754X Display Type Detect code
//
    UCHAR originalCRTCIndex, originalLCDControl; // temp1;
    UCHAR originalSEQIndex;
    USHORT temp1, temp2, temp4;
    USHORT temp3, temp5;        // crus

    // we need to check to see which display we are on...
    //
    originalCRTCIndex = VideoPortReadPortUchar(CRTCAddrPort);
    VideoPortWritePortUchar(CRTCAddrPort, 0x20);
    temp1 = VideoPortReadPortUchar(CRTCDataPort);
    temp3 = 0;          temp4 = 0;      //myf28
    if (temp1 & 0x40) temp3 = 1;

    if (!(temp1 & 0x20)) temp3 |= Jump_type;    //myf27
    else temp3 &= (~Jump_type);                 //myf27,myf28
//myf27    if (temp1 & 0x20)
    {
       originalSEQIndex =
                  VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                           SEQ_ADDRESS_PORT);
       VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                 SEQ_ADDRESS_PORT, 0x21);
       temp4 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                 SEQ_DATA_PORT) & 0x40;
       VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                 SEQ_ADDRESS_PORT, originalSEQIndex);

      // bit 5 set indicates that display is on LCD Panel
      // Check extended reg to see if panel supports 800x600 display
      //
      VideoPortWritePortUchar(CRTCAddrPort, 0x2D);
      originalLCDControl = VideoPortReadPortUchar(CRTCDataPort);

      // Allow access to extended CRTC regs and read R9X[3:2]
      //
      VideoPortWritePortUchar(CRTCDataPort,
                              (UCHAR) (originalLCDControl | 0x80));
      VideoPortWritePortUchar(CRTCAddrPort, 0x09);
      temp1 = (VideoPortReadPortUchar(CRTCDataPort) & 0x0C) >> 2;
      VideoPortWritePortUchar (CRTCAddrPort, 0x08);
      temp5 = VideoPortReadPortUchar(CRTCDataPort) & 0x20;
      VideoPortWritePortUchar (CRTCAddrPort, 0x2D);
      VideoPortWritePortUchar (CRTCDataPort, originalLCDControl);

      // CR2C bit 6,7 set indicate LCD type, TFT, STN color or STN mono
      // STN mono, R8X bit 5 set Single or Dual
      // STN color, CR2C bit 7,6 must 10 & SR21 bit 6 set Dual or Single

      VideoPortWritePortUchar (CRTCAddrPort, 0x2C);
      temp2 = VideoPortReadPortUchar(CRTCDataPort) & 0xC0;
      if (temp2 == 0)           //STN mono LCD
      {
         if (temp5 == 0)
            temp3 |= (USHORT)Dual_LCD | Mono_LCD | STN_LCD;
         else
            temp3 |= (USHORT)Single_LCD | Mono_LCD | STN_LCD;
      }
      else if (temp2 == 0x80)           //STN color LCD
      {
         if (temp4)
         {
            temp3 |= (USHORT)Dual_LCD | Color_LCD | STN_LCD;
         }
         else
         {
            temp3 |= (USHORT)Single_LCD | Color_LCD | STN_LCD;
         }
      }
      else if (temp2 == 0xC0)           //TFT LCD
      {
         temp3 |= (USHORT)TFT_LCD;      //myf28
      }

      // Restore LCD Display Controls register and CRTC index to original state
      //
      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);

      if (temp1 == 1)   // this means panel connected is 800x600
      {
          // will support either 800x600 or 640x480
          // return panel type
          return (temp3 | panel8x6);
      }
      else if (temp1 == 2)
      {
          return (temp3 | panel10x7);
      }
      else if (temp1 == 0)
      {
          return (temp3 | panel);
      }
      else              //temp1 =4 :reserve
      {
          return (temp3);
      }
   }
//myf27   else              // the display is a crt
//myf27   {
//myf27      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);
//myf27      return (temp3);
//myf27   }

} // CirrusFind754xDisplayType()

//---------------------------------------------------------------------------
USHORT
CirrusFind755xDisplayType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR CRTCAddrPort, PUCHAR CRTCDataPort
    )

/*++

Routine Description:

   Determines the display type for CL754x crt/panel controllers.
Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.
    CRTCAddrPort, CRTCDataPort - Index of CRTC registers for current mode.

Return Value:

    crt, panel, or panel8x6 LCD_type as defined in cirrus.h

--*/
{
    UCHAR originalCRTCIndex, originalLCDControl;
    USHORT temp1, temp2, temp3;

    // we need to check to see which display we are on...
    //
    originalCRTCIndex = VideoPortReadPortUchar(CRTCAddrPort);

    VideoPortWritePortUchar(CRTCAddrPort, 0x80);
    temp3 = 0;
    if (VideoPortReadPortUchar(CRTCDataPort) & 0x02) temp3 = crt;

    if (!(VideoPortReadPortUchar(CRTCDataPort) & 0x01))         //myf27
        temp3 |= Jump_type;                                     //myf27
    else temp3 &= (~Jump_type);                 //myf27, myf28

//myf27    if (VideoPortReadPortUchar(CRTCDataPort) & 0x01)
    {
      // bit 0 set indicates that display is on LCD Panel
      // Check extended reg to see panel data format
      //
        VideoPortWritePortUchar (CRTCAddrPort, 0x83);
        originalLCDControl = VideoPortReadPortUchar(CRTCDataPort);
        temp1 = originalLCDControl & 0x03;

      // check LCD support mode
      // CR83 bit 6:4 set indicate LCD type, TFT, DSTN color

      temp2 =  originalLCDControl & 0x70;
//    temp3 = crt;              //myf7, crus
      if (temp2 == 0)           //DSTN color LCD
      {
         temp3 |= Dual_LCD | Color_LCD | STN_LCD;
      }
      else if (temp2 == 0x20)           //TFT color LCD
         temp3 |= (USHORT)TFT_LCD;

      // Restore CRTC index to original state
      //
      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);

      if (temp1 == 1)   // this means panel connected is 800x600
      {
          // will support either 800x600 or 640x480
         return (temp3 | panel8x6);
      }
      else if (temp1 == 2)
      {
         return (temp3 | panel10x7);
      }
      else
      {
         return (temp3 | panel);
      }
   }
//myf27   else              // the display is a crt
//myf27   {
//myf27      VideoPortWritePortUchar(CRTCAddrPort, originalCRTCIndex);
//myf27      return crt;
//myf27   }
} // CirrusFind755xDisplayType()
//---------------------------------------------------------------------------
BOOLEAN
CirrusFind6340(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

   Determines if a CL6340 (Peacock) Color LCD controller is in the system
   along with a 6410 or 6420.

   Assumes that a 6410 or 6420 is already in the system.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    TRUE,   6340 detected
    FALSE,  6340 not detected

--*/
{
UCHAR originalGraphicsIndex;
UCHAR originalSRIndex;
UCHAR GRA1value;
UCHAR temp1,temp2;

   originalGraphicsIndex =
      VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
      GRAPH_ADDRESS_PORT));

   originalSRIndex =
      VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
      SEQ_ADDRESS_PORT));

   VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
      GRAPH_ADDRESS_PORT, CL64xx_TRISTATE_CONTROL_REG);

   GRA1value = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
      GRAPH_DATA_PORT);

   VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
      GRAPH_DATA_PORT, (UCHAR) (0x80 | GRA1value));

   VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
      SEQ_ADDRESS_PORT), (USHORT) CL6340_ENABLE_READBACK_REGISTER +
      (CL6340_ENABLE_READBACK_ALLSEL_VALUE << 8));

   VideoPortWritePortUchar((HwDeviceExtension->IOAddress +
      SEQ_ADDRESS_PORT), CL6340_IDENTIFICATION_REGISTER);

   temp1 = VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
      SEQ_DATA_PORT));

   temp2 = VideoPortReadPortUchar((HwDeviceExtension->IOAddress +
      SEQ_DATA_PORT));

   VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
      SEQ_ADDRESS_PORT), (USHORT) CL6340_ENABLE_READBACK_REGISTER +
      (CL6340_ENABLE_READBACK_OFF_VALUE << 8));

// Graphics index still points to CL64xx_TRISTATE_CONTROL_REG
   VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
      GRAPH_DATA_PORT, (UCHAR) (0x7f & GRA1value));

// now restore the Graphics and Sequencer indexes
      VideoPortWritePortUchar((HwDeviceExtension->IOAddress +
      GRAPH_ADDRESS_PORT),originalGraphicsIndex);

      VideoPortWritePortUchar((HwDeviceExtension->IOAddress +
      SEQ_ADDRESS_PORT),originalSRIndex);

// check the values for value peacock data
   if ( ((temp1 & 0xf0) == 0x70 && (temp2 & 0xf0) == 0x80) ||
        ((temp1 & 0xf0) == 0x80 && (temp2 & 0xf0) == 0x70)  )
      return TRUE;
   else
      return FALSE;

} // CirrusFind6410DisplayType()

BOOLEAN
CirrusConfigurePCI(
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PULONG NumPCIAccessRanges,
   PVIDEO_ACCESS_RANGE PCIAccessRanges
   )
{
    USHORT      VendorId = 0x1013;     // Vender Id for Cirrus Logic

    //
    // The device id order is important.  We want "most powerful"
    // first on the assumption that someone might want to plug
    // in a "more powerful" adapter into a system that has a "less
    // powerful" on-board device.
    //

    USHORT      DeviceId[] = {0x00BC,  // 5480
                              0x00B8,  // 5446
                              0x00AC,  // 5436
                              0x00E8,  // UM36
                              0x00A8,  // 5434
                              0x00A0,  // 5430/5440
                              0x1200,  // Nordic
                              0x1202,  // Viking
                              0x1204,  // Nordic Light
                              0x0038,  // Everest, myf14, crus
                              0x0040,  // Matterhorn
                              0x004C,  // Matterhorn, LV, myf17
                              0};

    ULONG       Slot;
    ULONG       ulRet;
    PUSHORT     pDeviceId;
    VP_STATUS   status;
    UCHAR       Command;
    PCI_COMMON_CONFIG   pciBuffer;     // jl02
    PPCI_COMMON_CONFIG  pciData;       // jl02

    VIDEO_ACCESS_RANGE AccessRanges[3];

    VideoPortZeroMemory(AccessRanges, 3 * sizeof(VIDEO_ACCESS_RANGE));

    pDeviceId = DeviceId;

    while (*pDeviceId != 0)
    {
        Slot = 0;

        status = VideoPortGetAccessRanges(HwDeviceExtension,
                                          0,
                                          NULL,
                                          3,
                                          AccessRanges,
                                          &VendorId,
                                          pDeviceId,
                                          &Slot);

        if (status == NO_ERROR)
        {
            VideoDebugPrint((2, "\t Found Cirrus chip in Slot[0x%02.2x]\n",
                             Slot));

            PCIAccessRanges[3].RangeStart  = AccessRanges[0].RangeStart;
            PCIAccessRanges[3].RangeLength = AccessRanges[0].RangeLength;

            VideoDebugPrint((1, "VideoMemoryAddress %x , length %x\n",
                                             PCIAccessRanges[3].RangeStart.LowPart,
                                             PCIAccessRanges[3].RangeLength));
            // sge01 begin
            //
            // checking CL5480 or CL5446BE
            //
            pciData = (PPCI_COMMON_CONFIG) &pciBuffer;
            VideoPortGetBusData(HwDeviceExtension,
                                PCIConfiguration,
                                Slot,
                                (PVOID) pciData,
                                0,
                                PCI_COMMON_HDR_LENGTH);

#if (_WIN32_WINNT >= 0x0400)
            if ((pciData->DeviceID == 0x00B8 && pciData->RevisionID == 0x45)
                || (pciData->DeviceID == 0x00BC))
            {
                HwDeviceExtension->bMMAddress = TRUE;
                HwDeviceExtension->bSecondAperture = TRUE;
                PCIAccessRanges[4].RangeStart  = AccessRanges[1].RangeStart;
                PCIAccessRanges[4].RangeLength = AccessRanges[1].RangeLength;
                VideoDebugPrint((1, "MMIOMemoryAddress %x , length %x\n",
                                             PCIAccessRanges[2].RangeStart.LowPart,
                                             PCIAccessRanges[2].RangeLength));
                //
                // Assign pfnVideoPortReadXxx and pfnVideoPortWriteXxx
                //
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUchar     = VideoPortReadRegisterUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUshort    = VideoPortReadRegisterUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUlong     = VideoPortReadRegisterUlong;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUchar    = VideoPortWriteRegisterUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUshort   = VideoPortWriteRegisterUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUlong    = VideoPortWriteRegisterUlong;
            }
#else // else of NT 4.0
            if ((pciData->DeviceID == 0x00BC) ||
                ((pciData->DeviceID == 0x00B8) && (pciData->RevisionID == 0x45)))
            {
                HwDeviceExtension->bMMAddress = FALSE;
                HwDeviceExtension->bSecondAperture = TRUE;
                //
                //
                // Assign pfnVideoPortReadXxx and pfnVideoPortWriteXxx
                //
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUchar     = VideoPortReadPortUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUshort    = VideoPortReadPortUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUlong     = VideoPortReadPortUlong;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUchar    = VideoPortWritePortUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUshort   = VideoPortWritePortUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUlong    = VideoPortWritePortUlong;

            }
#endif // end of NT 4.0
            else
            {
                HwDeviceExtension->bMMAddress = FALSE;
                HwDeviceExtension->bSecondAperture = FALSE;
                //
                // Assign pfnVideoPortReadXxx and pfnVideoPortWriteXxx
                //
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUchar     = VideoPortReadPortUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUshort    = VideoPortReadPortUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortReadPortUlong     = VideoPortReadPortUlong;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUchar    = VideoPortWritePortUchar;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUshort   = VideoPortWritePortUshort;
                HwDeviceExtension->gPortRWfn.pfnVideoPortWritePortUlong    = VideoPortWritePortUlong;
            }
            VideoDebugPrint((1, "Read Write Functions are mapped"));
//sge01 end

            return TRUE;

        }
        else
        {
            //
            // We did not find the device.  Use the next device ID.
            //

            VideoDebugPrint((1, "Check for DeviceID = %x failed.\n", *pDeviceId));

            pDeviceId++;
        }
    }

    VideoDebugPrint((1, "Returning a false from CirrusConfigurePCI\n"));

    return FALSE;
}

VOID
WriteRegistryInfo(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )
{
    PWSTR pwszChipType;
    ULONG cbString;
    PWSTR pnpId;

    //
    // Store Memory Size
    //

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &hwDeviceExtension->AdapterMemorySize,
                                   sizeof(ULONG));




    //
    // Store chip Type
    //

    switch (hwDeviceExtension->ChipType)
    {
        case CL6410: pwszChipType =    L"Cirrus Logic 6410";
                     cbString = sizeof(L"Cirrus Logic 6410");
                     pnpId =           L"*PNP0904";
                     break;

        case CL6420: pwszChipType =    L"Cirrus Logic 6420";
                     cbString = sizeof(L"Cirrus Logic 6420");
                     pnpId =           L"*PNP0904";
                     break;

        case CL542x: if (hwDeviceExtension->ChipRevision >= 0x22 &&
                         hwDeviceExtension->ChipRevision <= 0x27)
                     {
                         static PWSTR RevTable[] = { L"Cirrus Logic 5420",
                                                     L"Cirrus Logic 5422",
                                                     L"Cirrus Logic 5426",  // yes, the 26
                                                     L"Cirrus Logic 5424",  // is before
                                                     L"Cirrus Logic 5428",  // the 24
                                                     L"Cirrus Logic 5429" };

                         pwszChipType =
                             RevTable[hwDeviceExtension->ChipRevision - 0x22];
                     }
                     else
                     {
                         pwszChipType =    L"Cirrus Logic 542x";
                     }

                     cbString = sizeof(L"Cirrus Logic 542x");
                     pnpId =           L"*PNP0904";
                     break;

        case CL543x: if (hwDeviceExtension->ChipRevision == CL5430_ID)
                     {
                         pwszChipType =    L"Cirrus Logic 5430/40";  // chu04
                         cbString = sizeof(L"Cirrus Logic 5430/40"); // chu04
                     }
                     else
                     {
                         pwszChipType =    L"Cirrus Logic 543x";
                         cbString = sizeof(L"Cirrus Logic 543x");
                     }

                     pnpId =           L"*PNP0905";
                     break;

        case CL5434_6:
                     pwszChipType =    L"Cirrus Logic 5434 (.6 micron)";
                     cbString = sizeof(L"Cirrus Logic 5434 (.6 micron)");
                     pnpId =           L"*PNP0905";
                     break;

        case CL5434: pwszChipType =    L"Cirrus Logic 5434";
                     cbString = sizeof(L"Cirrus Logic 5434");
                     pnpId =           L"*PNP0905";
                     break;

        case CL5436: pwszChipType =    L"Cirrus Logic 5436";
                     cbString = sizeof(L"Cirrus Logic 5436");
                     pnpId =           L"*PNP0905";
                     break;

        case CL5446: pwszChipType =    L"Cirrus Logic 5446";
                     cbString = sizeof(L"Cirrus Logic 5446");
                     pnpId =           L"*PNP0905";
                     break;
#if 1   // jl02
        case CL5446BE:
                     pwszChipType =    L"Cirrus Logic 5446BE";
                     cbString = sizeof(L"Cirrus Logic 5446BE");
                     pnpId =           L"*PNP0905";
                     break;
#endif  // jl02

        case CL5480: pwszChipType =    L"Cirrus Logic 5480";
                     cbString = sizeof(L"Cirrus Logic 5480");
                     pnpId =           L"*PNP0905";
                     break;

//myf32 begin
        case CL7541: pwszChipType =    L"Cirrus Logic 7541";
                     cbString = sizeof(L"Cirrus Logic 7541");
                     pnpId =           L"*PNP0914";
                     break;

        case CL7542: pwszChipType =    L"Cirrus Logic 7542";
                     cbString = sizeof(L"Cirrus Logic 7542");
                     pnpId =           L"*PNP0914";
                     break;

        case CL7543: pwszChipType =    L"Cirrus Logic 7543";
                     cbString = sizeof(L"Cirrus Logic 7543");
                     pnpId =           L"*PNP0914";
                     break;

        case CL7548: pwszChipType =    L"Cirrus Logic 7548";
                     cbString = sizeof(L"Cirrus Logic 7548");
                     pnpId =           L"*PNP0914";
                     break;

        case CL7555: pwszChipType =    L"Cirrus Logic 7555";
                     cbString = sizeof(L"Cirrus Logic 7555");
                     pnpId =           L"*PNP0914";
                     break;

        case CL7556: pwszChipType =    L"Cirrus Logic 7556";
                     cbString = sizeof(L"Cirrus Logic 7556");
                     pnpId =           L"*PNP0914";
                     break;
//myf32


        case CL756x: pwszChipType =     L"Cirrus Logic 756x";
                     cbString = sizeof(L"Cirrus Logic 756x");
                     pnpId =           L"*PNP0914";
                     break;

// crus
        case CL6245: pwszChipType =     L"Cirrus Logic 6245";
                     cbString = sizeof(L"Cirrus Logic 6245");
                     pnpId =           L"*PNP0904";
                     break;

        default:
                     //
                     // we should never get here
                     //

                     ASSERT(FALSE);

                     pwszChipType = NULL;
                     cbString = 0;
                     pnpId = NULL;
    }

    if (pnpId)
    {
        memcpy(hwDeviceExtension->LegacyPnPId, pnpId, 8*sizeof(WCHAR));
    }

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChipType,
                                   cbString);

    //
    // Store Adapter String
    //
    // the only interesting adapter string is
    // for the speedstar pro
    //

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   L"Integrated RAMDAC",
                                   sizeof(L"Integrated RAMDAC") );

    if( hwDeviceExtension->BoardType == SPEEDSTARPRO )
    {
        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"HardwareInformation.AdapterString",
                                              L"SpeedStar PRO",
                                       sizeof(L"SpeedStar PRO"));
    }
    else
    {
        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"HardwareInformation.AdapterString",
                                               L"Cirrus Logic Compatible",
                                       sizeof (L"Cirrus Logic Compatible") );
    }


}

VOID
IOWaitDisplEnableThenWrite(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG portIO,
    UCHAR value
    )
{
    PHW_DEVICE_EXTENSION HwDeviceExtension = hwDeviceExtension;
    USHORT FCReg ;                     // feature control register
    UCHAR PSReg  ;                     // 3?4.25
    UCHAR DeviceID ;                   // 3?4.27
    UCHAR bIsColor ;                   // 1 : Color, 0 : Mono
    UCHAR tempB, tempB1 ;
    ULONG port ;
    PUCHAR CRTCAddrPort, CRTCDataPort;

    // Figure out if color/mono switchable registers are at 3BX or 3DX.

    port = PtrToUlong(hwDeviceExtension->IOAddress) + portIO ;
    tempB = VideoPortReadPortUchar (hwDeviceExtension->IOAddress +
                                    MISC_OUTPUT_REG_READ_PORT) ;
    tempB &= 0x01 ;

    if (tempB)
    {
        bIsColor = TRUE ;
        FCReg = FEAT_CTRL_WRITE_PORT_COLOR ;
        CRTCAddrPort = hwDeviceExtension->IOAddress + CRTC_ADDRESS_PORT_COLOR;
    }
    else
    {
        bIsColor = FALSE ;
        FCReg = FEAT_CTRL_WRITE_PORT_MONO ;
        CRTCAddrPort = hwDeviceExtension->IOAddress + CRTC_ADDRESS_PORT_MONO;
    }

    CRTCDataPort = CRTCAddrPort + 1;

    tempB = VideoPortReadPortUchar(CRTCAddrPort);

    VideoPortWritePortUchar(CRTCAddrPort, 0x27);
    DeviceID = VideoPortReadPortUchar(CRTCDataPort);

    VideoPortWritePortUchar(CRTCAddrPort, 0x25);
    PSReg = VideoPortReadPortUchar(CRTCDataPort);

    VideoPortWritePortUchar (CRTCAddrPort, tempB);

    if ((DeviceID == 0xAC) &&                                     // 5436
        ((PSReg == 0x45) || (PSReg == 0x47)))                     // BG or BE
    {

        hwDeviceExtension->DEPort = portIO;
        hwDeviceExtension->DEValue = value;

        while (!(0x1 & VideoPortReadPortUchar(hwDeviceExtension->IOAddress + FCReg)));
        while ( (0x1 & VideoPortReadPortUchar(hwDeviceExtension->IOAddress + FCReg)));

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE) IOCallback,
                                      hwDeviceExtension);
    }
    else
    {
        VideoPortWritePortUchar(hwDeviceExtension->IOAddress + portIO, value);
    }

} // IOWaitDisplEnableThenWrite


//sge08
VOID
CirrusUpdate440FX(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Check and Update 440FX PCI[53] bit 1 if necessary.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    The routine has no return.

--*/

{
    USHORT  chipRevisionId ;
    UCHAR   chipId ;
    PUCHAR  pBuffer;
    ULONG   Slot;

    USHORT  VendorId = 0x8086;                         // Vender Id for Intel
    USHORT  DeviceId = 0x1237;                         // VS440FX

    VP_STATUS   status;
    PCI_COMMON_CONFIG   pciBuffer;
    PPCI_COMMON_CONFIG  pciData;

    chipId = GetCirrusChipId(HwDeviceExtension) ;                    // chu06
    chipRevisionId = GetCirrusChipRevisionId(HwDeviceExtension) ;    // chu06

    if ((chipId == 0xB8) &&                                          // 5446
        (chipRevisionId == 0x0023))                                  // AC
    {
        //
        // We got it's 5446AC, then to find 440FX
        //
        pciData = (PPCI_COMMON_CONFIG)&pciBuffer;

        for (Slot = 0; Slot < 32; Slot++)
        {
            // chu05
            // For 5436 checked build NT, system always crashes when you
            // access the whole 256-byte PCI configuration registers.
            // Since we only care index 53h bit 1, we access 4 bytes, rather
            // than whole 256 bytes.

            VideoPortGetBusData(HwDeviceExtension,
                                PCIConfiguration,
                                Slot,
                                (PVOID) pciData,
                                0,
                                sizeof(PCI_COMMON_HDR_LENGTH));      // chu05

            if ((pciData->VendorID == VendorId) &&
                (pciData->DeviceID == DeviceId))
            {
                //
                // Access a double word, which contains index 53h.
                //

                VideoPortGetBusData(HwDeviceExtension,
                                    PCIConfiguration,
                                    Slot,
                                    (PVOID) pciData,
                                    0x53,
                                    0x04);                           // chu05

                // We borrow the space which is the first 4 bytes of PCI
                // configuration register. Please be aware that, at this
                // moment, the content is index 53h, rather than
                // vendor ID.

                pciBuffer.DeviceSpecific[19] =
                    (UCHAR) pciData->VendorID ;                      // chu05

                //
                // Found the Intel VS440FX motherboard.
                //
                //
                // Clear bit 1 of Register 0x53
                //

                pciBuffer.DeviceSpecific[19] &= 0xFD;

                //
                // Write Register 0x53 back.
                //

                pBuffer = (PUCHAR)&pciBuffer;
                pBuffer += 0x53;
                VideoPortSetBusData(HwDeviceExtension,
                                    PCIConfiguration,
                                    Slot,
                                    (PVOID) pBuffer,
                                    0x53,
                                    1);
                //
                // Read back only 4 bytes to verify it.
                //

                VideoPortGetBusData(HwDeviceExtension,
                                    PCIConfiguration,
                                    Slot,
                                    (PVOID) pciData,
                                    0x53,
                                    0x04);                           // chu05

                break;  // we have already modify it
            }
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\clmini.h ===
/*++

Copyright (c005289-1994  Microsoft Corporation

Module Name:

    miniport.h

Abstract:

    Type definitions for miniport drivers.

Author:

    Mike Glass  27-April-1992

Revision History:

--*/

#ifndef _MINIPORT_
#define _MINIPORT_

#include "stddef.h"

//#define ASSERT( exp )

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

// end_winnt

//
// Void
//

typedef void *PVOID;    // winnt


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR LPCTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote

#else   /* UNICODE */

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR LPCTSTR;
#define __TEXT(quote) quote

#endif /* UNICODE */
#define TEXT(quote) __TEXT(quote)


// end_winnt

typedef double DOUBLE;


//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// end_winnt

//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#if (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;





//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt


//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif // NULL

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))


//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (PCHAR)(&((type *)0)->field)))

//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! (defined(lint) || defined(_lint))
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint or _lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this.  line +e530 turns that checking back on.  Error 527 has to do with
// unreachable code.

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint +e527 +e530 */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint +e527 +e530 */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint +e527 +e530 */

#endif // lint or _lint



#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#pragma warning(default:4164)   // reenable C4164 warning

#endif
#endif


#endif //_X86_

//
// Define the I/O bus interface types.
//






//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;



#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2



#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000


//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//


//
// Graphics support routines.
//

typedef
VOID
(*PBANKED_SECTION_ROUTINE) (
    IN ULONG ReadBank,
    IN ULONG WriteBank,
    IN PVOID Context
    );


//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

//#define CM_RESOURCE_PORT_MEMORY 0
//#define CM_RESOURCE_PORT_IO 1


#include "pshpack1.h"











#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86


//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08



#endif /* _MINIPORT_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\clioctl.h ===
//---------------------------------------------------------------------------
//
//  file: CLIOCTL.H
//
// (c) Copyright 1993, Cirrus Logic, Inc.
// Copyright (c) 1996-1997  Microsoft Corporation
// Copyright (c) 1996-1997  Cirrus Logic, Inc.,
// All rights reserved.
//
//  date: 1 July 1993
//---------------------------------------------------------------------------
// The maximum GDI ESCAPE value defined in WINGDI.H is 4110(decimal). So here
// we pick an arbitrary value of...
//
// *chu01 : 12-16-96   Enable color correction
// *myf17 : 10-29-96 supported special Escape call
// *myf28 : 01-23-96 supported 755x gamma correction
// *

#define CIRRUS_PRIVATE_ESCAPE   0x5000

//myf17 begin
#define CLESCAPE_CRT_CONNECTION 0x5001
#define CLESCAPE_SET_VGA_OUTPUT 0x5002
#define CLESCAPE_GET_VGA_OUTPUT 0x5003
#define CLESCAPE_GET_PANEL_SIZE 0x5004
#define CLESCAPE_PANEL_MODE     0x5005
//myf17 end

//
// chu01 : GAMMACORRECT
//
#define CLESCAPE_GAMMA_CORRECT      0x2328                            // 9000
#define CLESCAPE_GET_CHIPID         0x2329                            // 9001
//myf28 : 755x gamma correction
#define CLESCAPE_WRITE_VIDEOLUT     0x2332      //myf28, 9010

//---------------------------------------------------------------------------
//
// The following macro(CTL_CODE) is defined in WINIOCTL.H. That file states
// that functions 2048-4095 are reserved for "customers". So I picked an
// arbitrary value of 0x900=2304.
//
#define IOCTL_CIRRUS_GET_CAPABILITIES  \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CIRRUS_SET_DISPLAY_PITCH \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// chu01 : GAMMACORRECT
//
#define IOCTL_CIRRUS_GET_GAMMA_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x908, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CIRRUS_GET_CONTRAST_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x909, METHOD_BUFFERED, FILE_ANY_ACCESS)

//myf28
#define IOCTL_CIRRUS_GET_755x_GAMMA_FACTOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x90A, METHOD_BUFFERED, FILE_ANY_ACCESS)


//---------------------------------------------------------------------------
// Structure for miniport to indicate to display driver the capabilities
// of the chip.  The flag currently indicates HW Cursor and BLT Engine
// support.
//
// Also included is the size of memory, and the top of available offscreen
// memory. (Actually it's top+1).
//
typedef struct {
   ULONG size;              // size of this structure
   ULONG fl;                // see bit description below
   ULONG ulChipId;          // Chip ID read from CR27[7:2] - e.g CL5434 = 0x2A
   ULONG ulMemSize;         // Size of memory in bytes=end of HW cursor buffers
   ULONG ulOffscreenMemTop; // Offset of 1st byte of unusable video memory
                            // [1st byte of cursor buffers on all but 754x]
                            // [1st byte of split screen buffer on 754x]
} CIRRUS_CAPABILITIES, *PCIRRUS_CAPABILITIES;

//#define CL_ALLOW_HW_CURSOR 0x01     // Flag to enable HW Cursor in
//capabilities
//#define CL_BLT_SUPPORT 0x02         // Flag set if chip has BLT Engine
//support
//#define CL_ALLOW_OPAQUE_TEXT 0x04   // Flag to enable HW Cursor in
//capabilities
//#define CL_LINEAR_MODE 0x08         // Flag set if addressing mode is linear
//#define CL_CURSOR_VERT_EXP 0x10     // Flag set if 8x6 panel, 6x4 resolution
//#define CL_DSTN_PANEL      0x20     // Flag set if DSTN panel connect

//---------------------------------------------------------------------------
//
// this is the structure used to pass arguments to the CIRRUS_PRIVATE_ESCAPE
// call done in DrvEscape(). The size of this struct limits the size of the
// returned arguments also. See the DrvEscape() function in enable.c (in the
// display driver DLL) for more information.
//
// NOTE: to enable the definition of these parameters, the following sequence
//       is recommended!
//
// #define ENABLE_BIOS_ARGUMENTS    // put this before the include
// #include "clioctl.h"


#ifdef ENABLE_BIOS_ARGUMENTS

typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\clgamma.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation.
Copyright (c) 1996-1997  Cirrus Logic, Inc.,

Module Name:

    C    L    G    A    M    M    A  .  C

Abstract:

    This routine accesses Gamma correction information from the following 
    NT 4.0 registry.

    Registry subdirectory : System\CurrentControlSet\Services\cirrus\Device0
    Keys                  : "G Gamma", and "G Contrast"

Environment:

    Kernel mode only

Notes:
*
*    chu01  12-16-96 : Color correction start coding.
*
*
--*/


//---------------------------------------------------------------------------
// HEADER FILES
//---------------------------------------------------------------------------

//#include <ntddk.h>
#include <dderror.h>
#include <devioctl.h>
#include <miniport.h>  // I added
#include "clmini.h"

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"


//---------------------------------------------------------------------------
// FUNCTION PROTOTYPE
//---------------------------------------------------------------------------

VP_STATUS
VgaGetGammaFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PGAMMA_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

VP_STATUS
VgaGetContrastFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCONTRAST_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    );

VP_STATUS GetGammaKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    ) ;

VP_STATUS GetContrastKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    ) ;

VP_STATUS GetGammaCorrectInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    ) ;

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetGammaKeyInfoFromReg)
#pragma alloc_text(PAGE,GetContrastKeyInfoFromReg)
#pragma alloc_text(PAGE,GetGammaCorrectInfoCallBack)
#pragma alloc_text(PAGE,VgaGetGammaFactor)
#pragma alloc_text(PAGE,VgaGetContrastFactor)
#endif

UCHAR GammaInfo[4] ;

//---------------------------------------------------------------------------
//
// Function: Get Gamma factor
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS VgaGetGammaFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PGAMMA_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    )
{

    VP_STATUS status ;
    int       i      ;

    VideoDebugPrint((2, "VgaGetGammaFactor\n")) ;

    if ( ValueLength < (*OutputSize = sizeof(PGAMMA_VALUE)) )
        return ERROR_INSUFFICIENT_BUFFER;

    status = GetGammaKeyInfoFromReg(HwDeviceExtension) ;

    if (status == NO_ERROR)
    {
        for (i = 0; i < 4; i++) 
            value->value[i] = GammaInfo[i] ;
    }
    else if (status == ERROR_INVALID_PARAMETER)
    {
        //
        // If no subkey exists, we assign the default value.  Otherwise the
        // system would fail.
        //
        for (i = 0; i < 4; i++) 
            value->value[i] = 0x7f ; 
        status = NO_ERROR ; 
    }

    VideoDebugPrint((1, "Gamma value = %lx\n", *value)) ;

    return status ;

} // VgaGetGammaFactor


//---------------------------------------------------------------------------
//
// Function: Get Contrast factor
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS VgaGetContrastFactor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCONTRAST_VALUE value,
    ULONG ValueLength,
    PULONG OutputSize
    )
{

    VP_STATUS status ;
    int       i      ;

    VideoDebugPrint((2, "VgaGetContrastFactor\n")) ;

    if ( ValueLength < (*OutputSize = sizeof(PCONTRAST_VALUE)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    status = GetContrastKeyInfoFromReg(HwDeviceExtension) ;

    if (status == NO_ERROR)
    {
        for (i = 0; i < 4; i++) 
            value->value[i] = GammaInfo[i] ;
    }
    else if (status == ERROR_INVALID_PARAMETER)
    {
        //
        // If no subkey exists, we assign the default value.  Otherwise the
        // system would fail.
        //
        for (i = 0; i < 4; i++) 
            value->value[i] = 0x80 ;
        status = NO_ERROR ; 
    }

    VideoDebugPrint((1, "Contrast value = %lx\n", *value)) ;
    return status ;


} // VgaGetContrastFactor

//---------------------------------------------------------------------------
//
// Function: Get Gamma Key information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS GetGammaKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{

    VP_STATUS status ;

    VideoDebugPrint((2, "GetGammaKeyInfoFromReg\n")) ;

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"G Gamma",
                                            FALSE,
                                            GetGammaCorrectInfoCallBack,
                                            NULL) ;
    if (status != NO_ERROR)
    {
        VideoDebugPrint((1, "Fail to access Gamma key info from registry\n"));
    }

    return status ;


} // GetGammaKeyInfoFromReg


//---------------------------------------------------------------------------
//
// Function: Get Contrast Key information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS GetContrastKeyInfoFromReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    VP_STATUS status ;
    VideoDebugPrint((2, "GetContrastKeyInfoFromReg\n")) ;

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"G Contrast",
                                            FALSE,
                                            GetGammaCorrectInfoCallBack,
                                            NULL) ;
    if (status != NO_ERROR)
    {
        VideoDebugPrint((1, "Fail to access Contrast key info from registry\n"));
    }
    return status ;

} // GetContrastKeyInfoFromReg


//---------------------------------------------------------------------------
//
// Function: Get Gamma coorrection information from data registry.
//
// Input:
//     None         
//
// Output: 
//     NO_ERROR: successful ; otherwise: fail 
//
//---------------------------------------------------------------------------
VP_STATUS 
GetGammaCorrectInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )
/*++

Routine Description:
    This routine get the desired info from data registry.

Arguments:
    HwDeviceExtension - Supplies a pointer to the miniport's device extension.
    Context - Context value passed to the get registry paramters routine.
    ValueName - Name of the value requested.
    ValueData - Pointer to the requested data.
    ValueLength - Length of the requested data.

Return Value:
    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{
    VideoDebugPrint((2, "GetGammaCorrectInfoCallBack\n"));

    if (ValueLength == 0x04)
    {
        VideoPortMoveMemory (GammaInfo, ValueData, ValueLength) ;
        return NO_ERROR ;
    }
    else
    {
        return ERROR_INVALID_PARAMETER ;
    }

} // GetGammaCorrectInfoCallBack
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\ddc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ddc.c

Abstract:

    This module contains the code that support DDC querying..

Environment:

    Kernel mode

Revision History:

--*/

#include <dderror.h>
#include <devioctl.h>                           
#include <miniport.h>
                                                        
#include <ntddvdeo.h>                        
#include <video.h>

#include <cirrus.h>

VOID    WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
VOID    WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);

BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension);
BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension);

VOID    WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension);

/****************************************************************
;       DDC register
;
;       Controls the individual toggling of bits in Sr8 to produce
;       clock and data pulses.
;
;       Sr8 is defined as follows:
;
;       7  ...  2   1   0    SCW = CLK  Write
;     |---|---|---|---|---|  SDW = DATA Write
;     |SDR ...|SCR|SDW|SCW|  SCR = CLK  Read
;     ---------------------  SDR = DATA Read
;
;****************************************************************/

#define DDC_PORT    (HwDeviceExtension->IOAddress + SEQ_DATA_PORT)
#define STATUS_PORT (HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR)

#define VSYNC_ACTIVE    0x08

VOID WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)
{
    UCHAR ucPortData;

    //
    //  read the current value and reset the clock line.
    //

    ucPortData = (VideoPortReadPortUchar(DDC_PORT) & 0xFE) | ucData;

    VideoPortWritePortUchar(DDC_PORT, ucPortData);
}

VOID WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)
{
    UCHAR ucPortData;

    //
    //  read the current value and reset the data line.
    //

    ucPortData = (VideoPortReadPortUchar(DDC_PORT) & 0xFD) | (ucData << 1);

    VideoPortWritePortUchar(DDC_PORT, ucPortData);
}

BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR uc;

    uc = VideoPortReadPortUchar(DDC_PORT);

    //VideoDebugPrint((0, "Read = 0x%x\n", uc));

    return ((VideoPortReadPortUchar(DDC_PORT) & 0x04) >> 2);
}


BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR uc;

    uc = VideoPortReadPortUchar(DDC_PORT);

    //VideoDebugPrint((0, "Read = 0x%x\n", uc));

    return ((VideoPortReadPortUchar(DDC_PORT) & 0x80) >> 7);
}

VOID WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    while ((VideoPortReadPortUchar(STATUS_PORT) & VSYNC_ACTIVE) != 0);
    while ((VideoPortReadPortUchar(STATUS_PORT) & VSYNC_ACTIVE) == 0);
}


BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG BufferSize)

/*++

Routine Description:

    Reads the basic EDID structure from the monitor using DDC2.

Arguments:

    HwDeviceExtension - Points to per-adapter device extension.

    QueryBuffer       - Buffer where information will be stored.

    BufferSize        - Size of the buffer to fill.

Return Value:

    Whether the call succeeded or not.

--*/

{
    UCHAR ucData;

    BOOLEAN       bRet = FALSE;
    I2C_FNC_TABLE i2c;
    ULONG         i;

    UCHAR OldSeqIdx;
    UCHAR ucSr6;
    UCHAR ucSr8;

	// workaround for Cirrus HW problem (part 1/2)
	static UCHAR onceQueryBuffer [512]; // EDID length is expected to be 128 or 256 bytes
	static UCHAR onceReadAttempt = FALSE;
	static UCHAR onceReturnedValue;
	
	if (onceReadAttempt) {
		VideoDebugPrint((1, "CIRRUS: ONCE READ => returning previously obtained data\n"));
		memcpy (QueryBuffer, onceQueryBuffer, BufferSize);
		return onceReturnedValue;
	}
	// end of the workaround (part 1/2)

    OldSeqIdx = VideoPortReadPortUchar(HwDeviceExtension->IOAddress
                    + SEQ_ADDRESS_PORT);

    //
    // Make sure the extension registers are unlocked.
    //

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
        0x6);

    ucSr6 = VideoPortReadPortUchar(
                HwDeviceExtension->IOAddress + SEQ_DATA_PORT);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
        0x12);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
        0x08);

    ucSr8 = VideoPortReadPortUchar(
                HwDeviceExtension->IOAddress + SEQ_DATA_PORT);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
        (UCHAR)(ucSr8 | 0x40));

    i2c.WriteClockLine = WriteClockLine;
    i2c.WriteDataLine  = WriteDataLine;
    i2c.ReadClockLine  = ReadClockLine;
    i2c.ReadDataLine   = ReadDataLine;
    i2c.WaitVsync      = WaitForVsyncActive;

    i2c.Size = sizeof(I2C_FNC_TABLE);

    // 5430/5440 has a problem doing DDC unless we wait for vsync first.
                                                                        
    if (HwDeviceExtension->ChipType == CL543x && HwDeviceExtension->ChipRevision == CL5430_ID)
    {
         WaitForVsyncActive(HwDeviceExtension);
	}

    bRet = VideoPortDDCMonitorHelper(HwDeviceExtension,
                                     &i2c,
                                     QueryBuffer,
                                     BufferSize);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
        0x08);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
        ucSr8);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
        0x6);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
        ucSr6);

    VideoPortWritePortUchar(
        HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
        OldSeqIdx);

	// workaround for Cirrus HW problem (part 2/2)
	onceReadAttempt = TRUE;
	onceReturnedValue = bRet;

	VideoDebugPrint((1, "CIRRUS: first EDID reading attempt "));
	if (onceReturnedValue)
		VideoDebugPrint((1, "succeeded"));
	else
		VideoDebugPrint((1, "failed"));
	VideoDebugPrint((1, " - the result saved\n"));
	memcpy (onceQueryBuffer, QueryBuffer, BufferSize);
	// end of the workaround (part 1/2)

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\clpanel.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation.
Copyright (c) 1996-1997  Cirrus Logic, Inc.,

Module Name:

    CLPANEL.C

Abstract:

    This routine accesses panning scrolling information from the following
    NT 4.0 laptop.

Environment:

    Kernel mode only

Notes:
*
* myf28 :02-03-97 : Fixed NT3.51 PDR#8357, mode 3, 12, panning scrolling bug,
*                   and move 4 routine from modeset.c to clpanel.c
* myf29 :02-12-97 : Support Gamma correction graphic/video LUT for 755x
* myf30 :02-10-97 : Fixed NT3.51, 6x4 LCD boot set 256 coloe, test 64K mode
* myf31 :03-12-97 : XGA DSTN panel can't support 24bpp mode for 7556
* myf32 :03-11-97 : check expension on, disable HW cursor fot 755x
* myf33 :03-21-97 : check TV on, disable HW video & HW cursor, PDR #9006
*
--*/


//---------------------------------------------------------------------------
// HEADER FILES
//---------------------------------------------------------------------------

//#include <ntddk.h>
#include <dderror.h>
#include <devioctl.h>
#include <miniport.h>
#include "clmini.h"

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"


// crus
#define DSTN       (Dual_LCD | STN_LCD)
#define DSTN10     (DSTN | panel10x7)
#define DSTN8      (DSTN | panel8x6)
#define DSTN6      (DSTN | panel)
#define PanelType  (panel | panel8x6 | panel10x7)
#define ScreenType (DSTN | PanelType)

SHORT Panning_flag = 0;
//myf1, begin
//#define PANNING_SCROLL

#ifdef PANNING_SCROLL
extern RESTABLE ResolutionTable[];
extern PANNMODE PanningMode;
extern USHORT   ViewPoint_Mode;

PANNMODE PanningMode = {1024, 768, 1024, 8, -1 };

#endif
extern UCHAR  HWcur, HWicon0, HWicon1, HWicon2, HWicon3;    //myf11

//---------------------------------------------------------------------------
// FUNCTION PROTOTYPE
//---------------------------------------------------------------------------
//myf28   VP_STATUS
ULONG
SetLaptopMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEOMODE pRequestedMode,
//  VIDEOMODE* RequestedMode,
    ULONG RequestedModeNum
    );

VOID                                    //myf11
AccessHWiconcursor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    SHORT Access_flag
    );

ULONG
GetPanelFlags(                                 //myf17
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

// LCD Support
USHORT
CheckLCDSupportMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,SetLaptopMode)
#pragma alloc_text(PAGE,AccessHWiconcursor)          //myf11, crus
#pragma alloc_text(PAGE,GetPanelFlags)          //myf17
#pragma alloc_text(PAGE,CheckLCDSupportMode)
#endif




//myf28  VP_STATUS
ULONG
SetLaptopMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEOMODE pRequestedMode,
//  VIDEOMODE* RequestedMode,
    ULONG RequestedModeNum
    )

/*++

Routine Description:

    This routine sets the laptop mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    Mode - Pointer to the structure containing the information about the
        font to be set.

    ModeSize - Length of the input buffer supplied by the user.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    ERROR_INVALID_PARAMETER if the mode number is invalid.

    NO_ERROR if the operation completed successfully.

--*/

{
//  PVIDEOMODE pRequestedMode;
    VP_STATUS status;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    USHORT Int10ModeNumber;
//  ULONG RequestedModeNum;

    UCHAR originalGRIndex, tempB ;
    UCHAR SEQIndex ;
    SHORT i;    //myf1

    VideoDebugPrint((1, "Miniport - SetLaptopMode\n")); //myfr

//  pRequestedMode = (PVIDEOMODE) RequestedMode;
    // Set SR14 bit 2 to lock panel, Panel will not be turned on if setting
    // this bit.  For laptop products only.
    //

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    if ((HwDeviceExtension->ChipType == CL756x) ||
        (HwDeviceExtension->ChipType & CL755x) ||
        (HwDeviceExtension->ChipType == CL6245) ||
        (HwDeviceExtension->ChipType & CL754x))
    {
//myf33: check TV on, disable HW video & HW cursor, PDR #9006
        biosArguments.Eax = 0x12FF;
        biosArguments.Ebx = 0xB0;     // set/get TV Output
        status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
        if ((biosArguments.Eax & 0x0003) &&
            (biosArguments.Ebx & 0x0100))
        {
            HwDeviceExtension->CursorEnable = FALSE;
            HwDeviceExtension->VideoPointerEnabled = FALSE; //disable HW Cursor
        }
//myf33: check TV on, disable HW video & HW cursor, PDR #9006

        biosArguments.Eax = pRequestedMode->BiosModes.BiosModeCL542x;
        biosArguments.Eax |= 0x1200;
        biosArguments.Eax &= 0xFF7F;    //myf1
        biosArguments.Ebx = 0xA0;     // query video mode availability
        status = VideoPortInt10 (HwDeviceExtension, &biosArguments);

#ifdef PANNING_SCROLL
        if (PanningMode.flag == -1)
        {
            PanningMode.hres = pRequestedMode->hres;
            PanningMode.vres = pRequestedMode->vres;
            PanningMode.wbytes = pRequestedMode->wbytes;
            PanningMode.bpp = pRequestedMode->bitsPerPlane;
            PanningMode.flag = 0;
            Panning_flag = 0;
        }
#endif  //PAANNING_SCROLL

//crus
        // bit0=1:video mode support
        if ((HwDeviceExtension->ChipType == CL6245) &&
            !(biosArguments.Eax & 0x0100))
        {
            return ERROR_INVALID_PARAMETER;
        }

        // fix CL6245 bug -- In 640x480x256C mode, with DSTN panel,
        // 512K bytes memory is not enought

        else if ((HwDeviceExtension->ChipType == CL6245) &&
                 (biosArguments.Eax & 0x0500) &&
                 (pRequestedMode->BiosModes.BiosModeCL542x == 0x5F) &&
//myf28          (pRequestedMode->DisplayType & DSTN))
                 (HwDeviceExtension->DisplayType & DSTN))       //myf28
        {
            return ERROR_INVALID_PARAMETER;
        }

//myf27: 1-9-97 fixed connect XGA panel, set 64K color mode for 754x, begin
        else if ((HwDeviceExtension->ChipType & CL754x) &&
                 (biosArguments.Eax & 0x0400) &&
//myf27          (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                 ((pRequestedMode->BiosModes.BiosModeCL542x == 0x64) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x65) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x74)) &&
//myf28          (pRequestedMode->DisplayType & (TFT_LCD | panel10x7)) )
                 ((HwDeviceExtension->DisplayType & (TFT_LCD | panel10x7)) ==
                     (TFT_LCD | panel10x7)) )//myf28
        {
            return ERROR_INVALID_PARAMETER;
        }
        else if ((HwDeviceExtension->ChipType & CL754x) &&
                 ((pRequestedMode->BiosModes.BiosModeCL542x == 0x64) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x65) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x74)) &&
                 (biosArguments.Eax & 0x0400) &&
//myf27          (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
//myf28          ((pRequestedMode->DisplayType & DSTN8) ||
//myf28           (pRequestedMode->DisplayType & DSTN10)) )
                 (((HwDeviceExtension->DisplayType & DSTN8) ==DSTN8) || //myf28
                  ((HwDeviceExtension->DisplayType & DSTN10)==DSTN10))) //myf28
        {
            return ERROR_INVALID_PARAMETER;
        }
//myf28 begin
        else if ((pRequestedMode->BiosModes.BiosModeCL542x == 0x03) ||
                 (pRequestedMode->BiosModes.BiosModeCL542x == 0x12))
        {
            goto PANNING_OVER;
        }
//myf31:3-12-97, XGA DSTN panel can't support 24bpp mode for 7556
        else if ((HwDeviceExtension->ChipType & CL755x) &&
                 ((pRequestedMode->BiosModes.BiosModeCL542x == 0x71) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x78) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x79) ||
                  (pRequestedMode->BiosModes.BiosModeCL542x == 0x77)) &&
                 (biosArguments.Eax & 0x0400) &&
                  ((HwDeviceExtension->DisplayType & DSTN10)==DSTN10))
        {
            return ERROR_INVALID_PARAMETER;
        }
//myf31 end

//myf28 end
//myf27: 1-9-97 fixed connect DSTN panel, set 64K color mode for 754x, end


        //
        // bit3=1:panel support, bit2=1:panel enable,
        // bit1=1:crt enable(in AH)
        //
        //panel turn on, mode not support (1)

        else if ((biosArguments.Eax & 0x0400) &&
            (HwDeviceExtension->ChipType != CL6245) &&
            !(biosArguments.Eax & 0x0800))
        {
#ifndef PANNING_SCROLL                  //myf1
            return ERROR_INVALID_PARAMETER;
#else
//myf1, begin
            biosArguments.Eax = 0x1280;
            biosArguments.Ebx = 0x9C;     // Inquire panel information
            status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
            if ((biosArguments.Eax & 0x0002) &&    //Dual-Scan STN
                (biosArguments.Ebx > 640) &&    //myf19
                (pRequestedMode->bitsPerPlane > 8) &&
                (HwDeviceExtension->ChipType & CL754x))
            {
                pRequestedMode = &ModesVGA[DefaultMode];       //myf19
                pRequestedMode->Frequency = 60;
                return ERROR_INVALID_PARAMETER;
            }
            else
            {
               i = 0;
               while ((ResolutionTable[i].Hres != 0) &&
                      (ResolutionTable[i].Vres != 0))
               {
                   if ((biosArguments.Ebx == ResolutionTable[i].Hres) &&
                       (biosArguments.Ecx == ResolutionTable[i].Vres) &&
                       (pRequestedMode->bitsPerPlane ==
                                    ResolutionTable[i].BitsPerPlane) &&
                       (ResolutionTable[i].ModesVgaStart != NULL))
                   {
                       if ((PanningMode.bpp != pRequestedMode->bitsPerPlane) &&
                           (Panning_flag == 1))
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 0;
                           Panning_flag = 0;
//myf30 begin
                           PanningMode.flag = 1;
                           Panning_flag = 1;
                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
//myf30 end
                       }
                       else if ((Panning_flag == 1) &&
                            (PanningMode.bpp == pRequestedMode->bitsPerPlane))
                       {
#if 1   //myf18 add
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 1;
#endif
                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
                       }
                       else
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 1;
                           Panning_flag = 1;

                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
                       }
                       break;
                   }
                   i ++;
               }
            }

#endif
//myf1, end
        }
        //panel turn off, mode not support (2)
        else if (!(biosArguments.Eax & 0x0800) &&
                 (HwDeviceExtension->ChipType != CL6245) &&
                 !(biosArguments.Eax & 0x0400))
        {
//myf1, begin
#ifdef PANNING_SCROLL
            PanningMode.flag = 0;
            Panning_flag = 0;
#if 0
            biosArguments.Eax = 0x1280;
            biosArguments.Ebx = 0x9C;     // Inquire panel information
            status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
            if ((biosArguments.Eax & 0x0002) &&             //Dual-Scan STN
                (biosArguments.Ebx > 640) &&    //myf19
                (pRequestedMode->bitsPerPlane > 8) &&
                (HwDeviceExtension->ChipType & CL754x))
            {
                pRequestedMode = &ModesVGA[DefaultMode];        //myf19
                pRequestedMode->Frequency = 60;
                return ERROR_INVALID_PARAMETER;
            }
            else
            {
               i = 0;
               while ((ResolutionTable[i].Hres != 0) &&
                      (ResolutionTable[i].Vres != 0))
               {
                   if ((biosArguments.Ebx == ResolutionTable[i].Hres) &&
                       (biosArguments.Ecx == ResolutionTable[i].Vres) &&
                       (pRequestedMode->bitsPerPlane ==
                                    ResolutionTable[i].BitsPerPlane) &&
                       (ResolutionTable[i].ModesVgaStart != NULL))
                   {
                       if ((PanningMode.bpp != pRequestedMode->bitsPerPlane) &&
                           (Panning_flag == 1))
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 0;
                           Panning_flag = 0;
                       }
                       else if ((Panning_flag == 1) &&
                            (PanningMode.bpp == pRequestedMode->bitsPerPlane))
                       {
                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
                       }
                       else
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 1;
                           Panning_flag = 1;

                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
                       }
                           break;
                   }
                   i ++;
               }
            }

#endif  //0
#else
//myf1, end

            //
            // Lock turn on panel
            //

            SEQIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_ADDRESS_PORT, 0x14);
            tempB = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                     SEQ_DATA_PORT) | 0x04;
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_DATA_PORT,tempB);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_ADDRESS_PORT, SEQIndex);

#endif  //myf1, ifdef PANNING_SCROLL
        }

//myf1, begin
        //panel turn on, mode support (3)
        else if ((biosArguments.Eax & 0x0800) &&
                 (HwDeviceExtension->ChipType != CL6245) &&
                 (biosArguments.Eax & 0x0400))
        {
#ifdef PANNING_SCROLL
            biosArguments.Eax = 0x1280;
            biosArguments.Ebx = 0x9C;     // Inquire panel information
            status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
            if ((biosArguments.Eax & 0x0002) &&    //Dual-Scan STN
                (biosArguments.Ebx > 640) &&    //myf19
                (pRequestedMode->bitsPerPlane > 8) &&
                (HwDeviceExtension->ChipType & CL754x))
            {
                pRequestedMode = &ModesVGA[DefaultMode];        //myf19
                pRequestedMode->Frequency = 60;
                return ERROR_INVALID_PARAMETER;
            }
//myf26, begin
            else if ((pRequestedMode->hres == 640) &&
                (pRequestedMode->vres == 480) &&
                (pRequestedMode->bitsPerPlane == 1) &&
                ((HwDeviceExtension->ChipType & CL754x) ||
                (HwDeviceExtension->ChipType & CL755x) ||       //myf32
                (HwDeviceExtension->ChipType == CL756x)))
            {
                pRequestedMode->Frequency = 60;
                PanningMode.hres = pRequestedMode->hres;
                PanningMode.vres = pRequestedMode->vres;
                PanningMode.wbytes = pRequestedMode->wbytes;
                PanningMode.bpp = pRequestedMode->bitsPerPlane;
                PanningMode.flag = 0;
                Panning_flag = 0;

                pRequestedMode =
                      &ModesVGA[ResolutionTable[0].ModesVgaStart];
                RequestedModeNum =
                      ResolutionTable[0].ModesVgaStart;
                                         //myf12
                pRequestedMode->Frequency = 60;
                ViewPoint_Mode = ResolutionTable[0].Mode;
            }
//myf26, end
            else
            {
               i = 0;
               while ((ResolutionTable[i].Hres != 0) &&
                      (ResolutionTable[i].Vres != 0))
               {
                   if ((biosArguments.Ebx == ResolutionTable[i].Hres) &&
                       (biosArguments.Ecx == ResolutionTable[i].Vres) &&
                       (pRequestedMode->bitsPerPlane ==
                                    ResolutionTable[i].BitsPerPlane) &&
                       (ResolutionTable[i].ModesVgaStart != NULL))
                   {
                       if ((pRequestedMode->hres < biosArguments.Ebx) &&
                           (pRequestedMode->vres < biosArguments.Eax))
                       {
#if 1   //myf18 add
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
#endif//myf18
                            Panning_flag = 0;
                            PanningMode.flag = 0;
                       }
                       else if ((PanningMode.bpp !=
                                     pRequestedMode->bitsPerPlane) &&
                                (Panning_flag == 1))
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 0;
                           Panning_flag = 0;
                       }
                       else if ((Panning_flag == 1) &&
                            (PanningMode.bpp == pRequestedMode->bitsPerPlane))
                       {
                           if ((pRequestedMode->hres<ResolutionTable[i].Hres)||
                               (pRequestedMode->vres <ResolutionTable[i].Vres))
                           {
                                while ((ResolutionTable[i].Hres !=
                                                  pRequestedMode->hres) &&
                                       (ResolutionTable[i].Vres !=
                                                  pRequestedMode->vres))
                                {
                                    if ((pRequestedMode->bitsPerPlane ==
                                           ResolutionTable[i].BitsPerPlane) &&
                                        (ResolutionTable[i].Hres ==
                                                  pRequestedMode->hres) &&
                                        (ResolutionTable[i].Vres ==
                                                  pRequestedMode->vres))
                                    {
#if 1   //myf18 add
                                       PanningMode.hres = pRequestedMode->hres;
                                       PanningMode.vres = pRequestedMode->vres;
                                       PanningMode.wbytes = pRequestedMode->wbytes;
                                       PanningMode.bpp = pRequestedMode->bitsPerPlane;
                                       PanningMode.flag = 1;
#endif

                                        pRequestedMode =
                                             &ModesVGA[ResolutionTable[i].ModesVgaStart];
                                        RequestedModeNum =
                                             ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                                        pRequestedMode->Frequency = 60;
                                        ViewPoint_Mode = ResolutionTable[i].Mode;
                                        break;
                                    }
                                    i ++;
                                }
                           }
                           else
                           {
#if 1   //myf18 add
                              PanningMode.hres = pRequestedMode->hres;
                              PanningMode.vres = pRequestedMode->vres;
                              PanningMode.wbytes = pRequestedMode->wbytes;
                              PanningMode.bpp = pRequestedMode->bitsPerPlane;
                              PanningMode.flag = 1;
#endif
                               pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                               pRequestedMode->Frequency = 60;
                               ViewPoint_Mode = ResolutionTable[i].Mode;
                           }
                       }
                       else
                       {
                           PanningMode.hres = pRequestedMode->hres;
                           PanningMode.vres = pRequestedMode->vres;
                           PanningMode.wbytes = pRequestedMode->wbytes;
                           PanningMode.bpp = pRequestedMode->bitsPerPlane;
                           PanningMode.flag = 1;
                           Panning_flag = 1;

                           pRequestedMode =
                                   &ModesVGA[ResolutionTable[i].ModesVgaStart];
                           RequestedModeNum = ResolutionTable[i].ModesVgaStart;
                                                                //myf12
                           pRequestedMode->Frequency = 60;
                           ViewPoint_Mode = ResolutionTable[i].Mode;
                       }
                       break;
                   }
                   i ++;
               }
            }

#endif
//myf1, end
        }

//myf1, begin
        //panel turn off, mode support (4)
        else if ((biosArguments.Eax & 0x0800) &&
                 (HwDeviceExtension->ChipType != CL6245) &&
                 !(biosArguments.Eax & 0x0400))
        {
#ifdef PANNING_SCROLL
#if 1
//myf18     if (PanningMode.flag == -1)
            {
                PanningMode.hres = pRequestedMode->hres;
                PanningMode.vres = pRequestedMode->vres;
                PanningMode.wbytes = pRequestedMode->wbytes;
                PanningMode.bpp = pRequestedMode->bitsPerPlane;
                PanningMode.flag = 0;
                Panning_flag = 0;
            }
#endif
#else
//myf18
            //
            // UnLock turn on panel
            //

            SEQIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_ADDRESS_PORT, 0x14);
            tempB = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                     SEQ_DATA_PORT) & 0xFB;
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_DATA_PORT,tempB);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                     SEQ_ADDRESS_PORT, SEQIndex);
//myf18 end

#endif
        }
//myf1, end

//myf4: patch Viking BIOS bug, PDR #4287, begin
/*
        else if ((biosArguments.Eax & 0x0800) && !(biosArguments.Eax & 0x0400)
                  && (HwDeviceExtension->ChipType & CL754x))
        {
        //by self check panel if or not supported
//myf16, begin
            biosArguments.Eax = 0x1280;
            biosArguments.Ebx = 0x9C;     // query panel information
            status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
            if (status == NO_ERROR)
            {
                if ( (((biosArguments.Ebx & 0x0000FFFF) == 640) &&
                      (pRequestedMode->vres > 480)) ||  //6x4 VGA
                     (((biosArguments.Ebx & 0x0000FFFF) == 800) &&
                      (pRequestedMode->vres > 600)) ||  //8x6 SVGA
                     (((biosArguments.Ebx & 0x0000FFFF) == 1024) &&
                      (pRequestedMode->vres > 768)) )   //10x7 XGA
                {

//myf16, end
                SEQIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress+
                            SEQ_ADDRESS_PORT);
                     VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT, 0x14);
                     VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                         SEQ_DATA_PORT,
                         (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                         SEQ_DATA_PORT) | 0x04));
                     VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                         SEQ_ADDRESS_PORT, SEQIndex);
                }
            }
        }
 */
//myf4: patch Viking BIOS bug, PDR #4287, end
    }

#ifdef PANNING_SCROLL
     VideoDebugPrint((1, "Info on Panning Mode:\n"
                        "\tResolution: %dx%dx%d (%d bytes) -- %x\n",
                        PanningMode.hres,
                        PanningMode.vres,
                        PanningMode.bpp,
                        PanningMode.wbytes,
                        ViewPoint_Mode ));
#endif

    //
    // Set the Vertical Monitor type, if BIOS supports it
    //

    if ((pRequestedMode->MonTypeAX) &&
        ((HwDeviceExtension->ChipType & CL754x) ||
         (HwDeviceExtension->ChipType == CL756x) ||
         (HwDeviceExtension->ChipType == CL6245) ||
         (HwDeviceExtension->ChipType & CL755x)) )
    {

        //
        // Re-write this part.
        //

        biosArguments.Eax = 0x1200;
        biosArguments.Ebx = 0x9A;
        status = VideoPortInt10(HwDeviceExtension, &biosArguments);

        if (status != NO_ERROR)
        {
            return status;
        }
        else
        {
            biosArguments.Eax = ((biosArguments.Ecx >> 4) & 0x000F);

//myf5 : 9-01-96, PDR #4365 keep all default refresh rate, begin

            biosArguments.Eax |= (biosArguments.Ebx >> 8) & 0x0030; //VGA
            biosArguments.Ebx = 0x00A4;
            biosArguments.Ebx |= (biosArguments.Ecx & 0xFF00); //XGA, SVGA
            biosArguments.Ecx = (biosArguments.Ecx & 0x000E) << 11; //12x10
//myf5 : 9-01-96, PDR #4365, end

            if (pRequestedMode->vres == 480)
            {
                biosArguments.Eax |= 0x1200;
                biosArguments.Eax &= 0xFFCF;         //myf5: 09-01-96
                if (pRequestedMode->Frequency == 85)    //myf0
                    biosArguments.Eax |= 0x30;          //myf0
                else if (pRequestedMode->Frequency == 75)
                    biosArguments.Eax |= 0x20;
                else if (pRequestedMode->Frequency == 72)
                    biosArguments.Eax |= 0x10;
            }
            else if (pRequestedMode->vres == 600)
            {
                biosArguments.Eax |= 0x1200;
                biosArguments.Ebx &= 0xF0FF;         //myf5: 09-01-96
                if (pRequestedMode->Frequency == 85)    //myf0
                    biosArguments.Ebx |= 0x0400;        //myf0
                else if (pRequestedMode->Frequency == 75)
                    biosArguments.Ebx |= 0x0300;
                else if (pRequestedMode->Frequency == 72)
                    biosArguments.Ebx |= 0x0200;
                else if (pRequestedMode->Frequency == 60)
                    biosArguments.Ebx |= 0x0100;
            }
            else if (pRequestedMode->vres == 768)
            {
                biosArguments.Eax |= 0x1200;
                biosArguments.Ebx &= 0x0FFF;         //myf5: 09-01-96
                if (pRequestedMode->Frequency == 85)    //myf0
                    biosArguments.Ebx |= 0x5000;        //myf0
                else if (pRequestedMode->Frequency == 75)
                    biosArguments.Ebx |= 0x4000;
                else if (pRequestedMode->Frequency == 72)
                    biosArguments.Ebx |= 0x3000;
                else if (pRequestedMode->Frequency == 70)
                    biosArguments.Ebx |= 0x2000;
                else if (pRequestedMode->Frequency == 60)
                    biosArguments.Ebx |= 0x1000;
            }
            else if (pRequestedMode->vres == 1024)
            {
                biosArguments.Eax |= 0x1200;
                biosArguments.Ecx &= 0x0FFF;         //myf5: 09-01-96
                if (pRequestedMode->Frequency == 45)
                    biosArguments.Ecx |= 0x0000;
                else if (pRequestedMode->Frequency == 60)    //myf0
                    biosArguments.Ecx |= 0x1000;        //myf0
                else if (pRequestedMode->Frequency == 72)    //myf0
                    biosArguments.Ecx |= 0x2000;        //myf0
                else if (pRequestedMode->Frequency == 75)    //myf0
                    biosArguments.Ecx |= 0x3000;        //myf0
                else if (pRequestedMode->Frequency == 85)    //myf0
                    biosArguments.Ecx |= 0x4000;        //myf0
            }
            status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
            if (status != NO_ERROR)
            {
                return status;
            }
        }
    }

    HwDeviceExtension->bCurrentMode = RequestedModeNum;   //myf12
    //VideoDebugPrint((0, "SetMode Info :\n"
    //                    "\tMode : %x, CurrentModeNum : %x, ( %d)\n",
    //                    Int10ModeNumber,
    //                    RequestedModeNum,
    //                    RequestedModeNum));
PANNING_OVER:

    return NO_ERROR;
    //return(pRequestedMode);

} //end SetLaptopMode()

//myf11 : begin
VOID
AccessHWiconcursor(
//  PVOID HwDeviceExtension,
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    SHORT Access_flag
    )

/*++

Routine Description:

    This routine determines disable/enable HW icon & HW cursor

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Access_flag - equal 0: Disable, equal 1: Enable.

Return Value:

    none

--*/

{
    UCHAR  savSEQidx;

    savSEQidx = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                       SEQ_ADDRESS_PORT);
    if (Access_flag)            //Enable hw icon/cursor
    {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x12);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, HWcur);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2A);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, HWicon0);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2B);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, HWicon1);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2C);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, HWicon2);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2D);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, HWicon3);
    }
    else                        //Disable HW cursor, icons
    {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x12);
        HWcur = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, (UCHAR)(HWcur & 0xFE));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2A);
        HWicon0 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, (UCHAR)(HWicon0 & 0xFE));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2B);
        HWicon1 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, (UCHAR)(HWicon1 & 0xFE));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2C);
        HWicon2 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, (UCHAR)(HWicon2 & 0xFE));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_ADDRESS_PORT, 0x2D);
        HWicon3 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT, (UCHAR)(HWicon3 & 0xFE));


    }
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT, savSEQidx);

} // end AccessHWiconcursor()
//myf11 : end


//crus begin
//myf10, begin
ULONG
GetPanelFlags (
    PHW_DEVICE_EXTENSION HwDeviceExtension
 )
{
    ULONG ChipType = HwDeviceExtension->ChipType;
    ULONG ulFlags  = 0;
    UCHAR  savSEQidx, Panel_Type =0, LCD;
    ULONG  ulCRTCAddress, ulCRTCData;
//myf16, begin
    VP_STATUS status;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    biosArguments.Eax = 0x1280;
    biosArguments.Ebx = 0x9C;     // query panel information
    status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
    if (status == NO_ERROR)
    {
        if ((biosArguments.Eax & 0x00000002) == 2)
            Panel_Type = (UCHAR)1;      //DSTN panel
        if (((biosArguments.Ebx & 0x0000FFFF) == 640) &&
             ((biosArguments.Ecx & 0x0000FFFF) == 480))
            ulFlags |= CAPS_VGA_PANEL;
        else if (((biosArguments.Ebx & 0x0000FFFF) == 800) &&
             ((biosArguments.Ecx & 0x0000FFFF) == 600))
            ulFlags |= CAPS_SVGA_PANEL;
        else if (((biosArguments.Ebx & 0x0000FFFF) == 1024) &&
             ((biosArguments.Ecx & 0x0000FFFF) == 768))
            ulFlags |= CAPS_XGA_PANEL;
    }

//myf33: check TV on, disable HW video & HW cursor, PDR #9006
    biosArguments.Eax = 0x12FF;
    biosArguments.Ebx = 0xB0;     // set/get TV Output
    status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
    if ((biosArguments.Eax & 0x0003) &&
        (biosArguments.Ebx & 0x0100))
    {
        ulFlags |= CAPS_TV_ON;
        ulFlags |= CAPS_SW_POINTER;
    }
    else
        ulFlags &= ~CAPS_TV_ON;

//myf33: check TV on, disable HW video & HW cursor, PDR #9006


#if 0
    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                               MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_COLOR;
        ulCRTCData    = CRTC_DATA_PORT_COLOR;
    }
    else
    {
        ulCRTCAddress = CRTC_ADDRESS_PORT_MONO;
        ulCRTCData    = CRTC_DATA_PORT_MONO;
    }

    savSEQidx = VideoPortReadPortUchar(ulCRTCAddress);

    if ((ChipType & CL754x))  //7548/7543/7541
    {
        VideoPortWritePortUchar(ulCRTCAddress, 0x20);
        LCD = VideoPortReadPortUchar(ulCRTCData) & 0x20;
    }
    else if (ChipType & CL755x)         //7555
    {
        VideoPortWritePortUchar(ulCRTCAddress, 0x80);
        LCD = VideoPortReadPortUchar(ulCRTCData) & 0x01;
    }
    VideoPortWritePortUchar(ulCRTCAddress, savSEQidx);
#endif

    if (((ChipType & CL754x) || (ChipType & CL755x)) &&
        (Panel_Type == 1))      //myf20
    {
        ulFlags |= CAPS_DSTN_PANEL;
    }
//myf16, end

//ms1016, begin
//  if (HwDeviceExtension->DisplayType & (STN_LCD | TFT_LCD))
//  {
//      ulFlags |= CAPS_DSTN_PANEL;
//  }
//ms1016, end

    if ((Panning_flag) && ((ChipType & CL754x) || (ChipType & CL755x)))
    {
        ulFlags |= CAPS_PANNING;       //myf15
    }

   return(ulFlags);
}
//myf10, end

USHORT
CheckLCDSupportMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    )

/*++

Routine Description:
    Determines if LCD support the modes.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:
    None.

--*/
{
    VP_STATUS status;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

//  DbgBreakPoint();
//  biosArguments.Eax = 0x1202;
//  biosArguments.Ebx = 0x92;     // set LCD & CRT turn on
//  status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
//  VideoDebugPrint((1, "LCD & CRT all Turn ON\n"));

// crus
#ifdef INT10_MODE_SET

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    biosArguments.Eax = 0x1200 | ModesVGA[i].BiosModes.BiosModeCL542x;
    biosArguments.Ebx = 0xA0;     // query video mode availability
    status = VideoPortInt10 (HwDeviceExtension, &biosArguments);
    if (status == NO_ERROR)
    {
// crus
       if ((biosArguments.Eax & 0x00000800) &&         //bit3=1:support
           (HwDeviceExtension->ChipType != CL6245))
          return TRUE ;
// crus
       else if ((biosArguments.Eax & 0x00000100) &&     //bit0=1:video support
                (HwDeviceExtension->ChipType == CL6245))
          return TRUE ;
// end crus
       else
       {
          return FALSE ;
       }
    }
    else
       return FALSE ;
// crus
#endif

} // end CheckLCDSupportMode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\mode6410.h ===
/*++

Copyright (c) 1992  Cirrus Logic, Inc.

Module Name:

    Mode6410.h

Abstract:

    This module contains all the global data used by the Cirrus Logic
    CL-6410 driver.

Environment:

    Kernel mode

Revision History:

--*/

//
// The first set of tables are for the CL6410
// Note that only 640x480 and 800x600 are supported.
//
// Color graphics mode 0x12, 640x480 16 colors.
//
USHORT CL6410_640x480_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
    
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,
    0x54,0x80,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x28,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0081,               // ER81 display mode
        0x0082,               // ER82 character clock selection
        0x1084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x14,0x07,0x38,0x39,
    0x3A,0x3B,0x3C,0x3D,0x3E,
    0x3F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,
 
#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

USHORT CL6410_640x480_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
    
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,
    0x54,0x80,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x28,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0181,               // ER81 display mode
        0x8982,               // ER82 character clock selection
        0xa684,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0xa0c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x14,0x07,0x38,0x39,
    0x3A,0x3B,0x3C,0x3D,0x3E,
    0x3F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,
 
#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};



//
// Cirrus color graphics mode 0x64, 800x600 16 colors.
//
USHORT CL6410_800x600_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x2f,

    OWM,                
    GRAPH_ADDRESS_PORT,
    3,
    0x0506,
    0x0f07,
    0xff08,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7b,0x63,0x64,0x9e,
    0x69,0x92,0x6f,0xf0,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x58,0xaa,0x57,0x32,
    0x00,0x58,0x6f,0xe3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x1e62,                   // ER62 horz. display end extension
    0x9264,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0xac84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0a95,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
//-----------------------------
// standard VGA text modes here
//-----------------------------

USHORT CL6410_80x25_14_Text_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x01,0xe0,
    0x9c,0xae,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x0262,                   // ER62 horz. display end extension
    0x8164,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0x1084,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0095,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
//
// 80x25 and 720 x 400
//

USHORT CL6410_80x25_14_Text_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0fc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW, 
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,0x00,0x4f,0xd,0xe,0x0,0x0,0x0,0x0,
    0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x1e62,                   // ER62 horz. display end extension
    0x9264,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0xac84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0a95,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x04,0x0,0x0F,0x8,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
USHORT CL6410_80x25Text_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x01,0xe0,
    0x9c,0xae,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x0262,                   // ER62 horz. display end extension
    0x8164,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0x1084,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0095,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
//
// 80x25 and 720 x 400
//

USHORT CL6410_80x25Text_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0fc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW, 
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,0x00,0x4f,0xd,0xe,0x0,0x0,0x0,0x0,
    0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x1e62,                   // ER62 horz. display end extension
    0x9264,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0xac84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0a95,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x04,0x0,0x0F,0x8,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// disable banking
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x030d,                   // ER0D = Paging control: 1 64K page, 
    0x000e,                   // ER0E page A address = 0
    0x000f,                   // ER0F page B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\mode6420.h ===
/*++

Copyright (c) 1992  Cirrus Logic, Inc.

Module Name:

    Mode6420.h

Abstract:

    This module contains all the global data used by the Cirrus Logic
    CL-6420 driver.

Environment:

    Kernel mode

Revision History:

--*/

//---------------------------------------------------------------------------
// The next set of tables are for the CL6420
// Note: all resolutions supported
//
USHORT CL6420_640x480_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
    
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,
    0x54,0x80,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x28,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0181,               // ER81 display mode
        0x8982,               // ER82 character clock selection
        0x9a84,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0xa1c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x14,0x07,0x38,0x39,
    0x3A,0x3B,0x3C,0x3D,0x3E,
    0x3F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

 
    EOD
};
USHORT CL6420_640x480_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
    
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,
    0x54,0x80,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x28,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0081,               // ER81 display mode
        0x0082,               // ER82 character clock selection
        0x1084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x14,0x07,0x38,0x39,
    0x3A,0x3B,0x3C,0x3D,0x3E,
    0x3F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,
 
#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
// 800x600 16-color (60Hz refresh) mode set command string for CL 6420.
//
USHORT CL6420_800x600_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
#ifndef INT10_MODE_SET

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7F,0x63,0x64,0x82,
    0x6b,0x1d,0x72,0xf0,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x58,0xac,0x57,0x32,
    0x00,0x58,0x72,0xe3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x0262,                   // ER62 horz. display end extension
    0x1b64,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0x9c84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0395,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//
// 1024x768 16-color (60Hz refresh) mode set command string for CL 6420.
// Requires 512K minimum.
//
USHORT CL6420_1024x768_crt[] = {

// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0bc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x2b,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x99,0x7f,0x80,0x9c,
    0x83,0x19,0x2f,0xfd,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x00,0xa4,0xff,0x3f,
    0x00,0x00,0x2f,0xe3,
    0xFF,
// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x1c62,               // ER62 horz. display end extension
        0x1964,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x4c7a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0481,               // ER81 display mode
        0x0082,               // ER82 character clock selection
        0xa084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x8391,               // ER91 CRT-circular buffer policy select
        0x0295,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// now do the banking registers
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
  
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//-----------------------------
// standard VGA text modes here
// 80x25 at 640x350
//
//-----------------------------

USHORT CL6420_80x25_14_Text_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x01,0xe0,
    0x9c,0xae,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8164,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0081,               // ER81 display mode
        0x0082,               // ER82 character clock selection
        0x1084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
//
USHORT CL6420_80x25_14_Text_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0e06,
                            
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x01,0xe0,
    0x9c,0xae,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8164,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0181,               // ER81 display mode
        0x8982,               // ER82 character clock selection
        0x9a84,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0xa1c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
//


USHORT CL6420_80x25Text_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0fc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW, 
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x00,0x00,
    0x9c,0x8e,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8164,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0081,               // ER81 display mode
        0x8082,               // ER82 character clock selection
        0x1084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x04,0x00,0x0F,0x8,0x00,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

USHORT CL6420_80x25Text_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
 
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0fc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW, 
    GRAPH_ADDRESS_PORT,
    0x0e06,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,
    0x55,0x81,0xbf,0x1f,
    0x00,0x4f,0x0d,0x0e,
    0x00,0x00,0x00,0x00,
    0x9c,0xae,0x8f,0x28,
    0x1f,0x96,0xb9,0xa3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x0262,               // ER62 horz. display end extension
        0x8164,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0181,               // ER81 display mode
        0x8982,               // ER82 character clock selection
        0x9a84,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0091,               // ER91 CRT-circular buffer policy select
        0x0095,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0xa1c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x04,0x00,0x0F,0x8,0x00,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};


//
//---------------------------------------------------------------------------
// 256 color tables
//---------------------------------------------------------------------------
//
// 800x600 256-color (60Hz refresh) mode set command string for CL 6420.
// requires 512k minimum
//
USHORT CL6420_640x480_256color_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0e04,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0xc3,0x9F,0xa0,0x86,
    0xa4,0x10,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x50,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x2662,               // ER62 horz. display end extension
        0x1064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0081,               // ER81 display mode
        0x0a82,               // ER82 character clock selection
        0x1084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0391,               // ER91 CRT-circular buffer policy select
        0x0895,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x20a1,               // ERa1 three-state and test control
        0x05c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x06,0x07,0x08,0x09,
    0x0A,0x0B,0x0C,0x0D,0x0E,
    0x0F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x40,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,
 
#endif
// now do the banking registers 
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

USHORT CL6420_640x480_256color_panel[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,
    
#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0e04,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                             //{ SetGraphCmd,{ "\x05", 0x06, 1 } },
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0111,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0xc3,0x9F,0xa0,0x86,
    0xa4,0x10,0x0B,0x3E,
    0x00,0x40,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0xEA,0xAC,0xDF,0x50,
    0x00,0xE7,0x04,0xE3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x2662,               // ER62 horz. display end extension
        0x1064,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x007a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0181,               // ER81 display mode
        0x8a82,               // ER82 character clock selection
        0x9a84,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0391,               // ER91 CRT-circular buffer policy select
        0x0895,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x20a1,               // ERa1 three-state and test control
        0xa5c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x01,0x02,0x03,0x04,
    0x05,0x06,0x07,0x08,0x09,
    0x0A,0x0B,0x0C,0x0D,0x0E,
    0x0F,0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x40,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,
 
#endif
// now do the banking registers 
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//
// 800x600 256-color (60Hz refresh) mode set command string for CL 6420.
// requires 512k minimum
//
USHORT CL6420_800x600_256color_crt[] = {
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0e04,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x2f,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x03,0xc7,0xc8,0x86,
    0xdc,0x0c,0x72,0xf0,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x5a,0xac,0x57,0x64,
    0x00,0x58,0x72,0xe3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x2662,                   // ER62 horz. display end extension
    0x2c64,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0a82,                   // ER82 character clock selection
    0x9c84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x0391,                   // ER91 CRT-circular buffer policy select
    0x0895,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x20a1,                   // ERa1 three-state and test control
    0x05c8,                   // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x40,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif

// now do the banking registers 
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

     EOD
};

//
// 1024x768 256-color (60Hz refresh) mode set command string for CL 6420.
// Requires 1Meg minimum.
//
USHORT CL6420_1024x768_256color_crt[] = {

// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

#ifndef INT10_MODE_SET
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0e04,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x23,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x39,0xff,0x00,0x9c,
    0x06,0x91,0x26,0xfd,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x04,0xa6,0xff,0x7f,
    0x00,0x00,0x26,0xe3,
    0xFF,
// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0xbc62,               // ER62 horz. display end extension
        0xf164,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x997a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0481,               // ER81 display mode
        0x0a82,               // ER82 character clock selection
        0xa084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0391,               // ER91 CRT-circular buffer policy select
        0x0895,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x20a1,               // ERa1 three-state and test control
        0x05c8,               // ERc8 RAMDAC control

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0F,0x0FF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
// now do the banking registers
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

#if MULTIPLE_REFRESH_TABLES
//
// 800x600 16-color (56Hz refresh) mode set command string for CL 6420.
//
USHORT CL6420_800x600_56Hz_crt[] = {
#ifndef INT10_MODE_SET
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7b,0x63,0x64,0x9e,
    0x69,0x92,0x6f,0xf0,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x58,0xaa,0x57,0x32,
    0x00,0x58,0x6f,0xe3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x1e62,                   // ER62 horz. display end extension
    0x9264,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0x8c84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x8391,                   // ER91 CRT-circular buffer policy select
    0x0395,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
    EOD
};

//
// 800x600 16-color (72Hz refresh) mode set command string for CL 6420.
//
USHORT CL6420_800x600_72Hz_crt[] = {
#ifndef INT10_MODE_SET
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x7f,0x63,0x64,0x82,
    0x6b,0x1b,0x72,0xf0,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x58,0xac,0x57,0x32,
    0x00,0x58,0x72,0xe3,
    0xFF,

// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
    0x0262,                   // ER62 horz. display end extension
    0x1b64,                   // ER64 horz. retrace end extension
    0x0079,                   // ER79 vertical overflow
    0x007a,                   // ER7a coarse vert. retrace skew for interlaced odd fields
    0x007b,                   // ER7b fine vert. retrace skew for interlaced odd fields
    0x007c,                   // ER7c screen A start addr. extension
    0x0081,                   // ER81 display mode
    0x0082,                   // ER82 character clock selection
    0x9c84,                   // ER84 clock select extension
    0x0090,                   // ER90 display memory control
    0x8391,                   // ER91 CRT-circular buffer policy select
    0x0395,                   // ER95 CRT-circular buffer delta & burst
    0x0096,                   // ER96 display memory control test
    0x12a0,                   // ERa0 bus interface unit control
    0x00a1,                   // ERa1 three-state and test control
    0x00c8,                   // ERc8 RAMDAC control

// zero out the banking regs. for this mode
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
    0x000d,                   // ER0D = Banking control: 1 64K bank, 
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
    EOD
};
//
// 1024x768 16-color (43.5Hz refresh interlaced) mode set command string 
// for CL 6420.
// Requires 512K minimum.
//
USHORT CL6420_1024x768_I43Hz_crt[] = {

#ifndef INT10_MODE_SET
// Unlock Key for color mode
    OW,                             // GR0A = 0xEC opens extension registers
    GRAPH_ADDRESS_PORT,
    0xec0a,

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,                         // start synch reset
    0x0101,0x0f02,0x0003,0x0604,    // program up sequencer


    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0006,0x0bc07,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x2b,

    OW,                
    GRAPH_ADDRESS_PORT,
    0x0506,
    
//  EndSyncResetCmd
    OW,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8),

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,                         

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x99,0x7f,0x80,0x9c,
    0x83,0x19,0x2f,0xfd,
    0x00,0x60,0x00,0x00,
    0x00,0x00,0x00,0x00,
    0x00,0xa4,0xff,0x3f,
    0x00,0x00,0x2f,0xe3,
    0xff,
// extension registers
    OWM,
    GRAPH_ADDRESS_PORT,
    16,
        0x1c62,               // ER62 horz. display end extension
        0x1964,               // ER64 horz. retrace end extension
        0x0079,               // ER79 vertical overflow
        0x4c7a,               // ER7a coarse vert. retrace skew for interlaced odd fields
        0x007b,               // ER7b fine vert. retrace skew for interlaced odd fields
        0x007c,               // ER7c screen A start addr. extension
        0x0481,               // ER81 display mode
        0x0082,               // ER82 character clock selection
        0xa084,               // ER84 clock select extension
        0x0090,               // ER90 display memory control
        0x0391,               // ER91 CRT-circular buffer policy select
        0x0295,               // ER95 CRT-circular buffer delta & burst
        0x0096,               // ER96 display memory control test
        0x12a0,               // ERa0 bus interface unit control
        0x00a1,               // ERa1 three-state and test control
        0x00c8,               // ERc8 RAMDAC control

// now do the banking registers
    OWM,
    GRAPH_ADDRESS_PORT,
    3,   
#if ONE_64K_BANK
    0x030d,                   // ER0D = Banking control: 1 64K bank, 
#endif
#if TWO_32K_BANKS
    0x050d,
#endif
    0x000e,                   // ER0E bank A address = 0
    0x000f,                   // ER0F bank B address = 0
 
    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x00,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xA,0xB,0xC,0xD,0xE,0xF,
    0x01,0x00,0x0F,0x00,0x00,

    METAOUT+INDXOUT,                // 
    GRAPH_ADDRESS_PORT,             // port        
    VGA_NUM_GRAPH_CONT_PORTS,       // count       
    0,                              // start index 
    0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x0F,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

#endif
    EOD
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\mode542x.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Mode542x.h

Abstract:

    This module contains all the global data used by the Cirrus Logic
   CL-542x driver.

Environment:

    Kernel mode

Revision History:

--*/

//
// The next set of tables are for the CL542x
// Note: all resolutions supported
//

//
// 640x480 16-color mode (BIOS mode 12) set command string for CL 542x.
//

USHORT CL542x_640x480_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in 640x480 mode

    EOD                   
};

//
// 800x600 16-color (60Hz refresh) mode set command string for CL 542x.
//

USHORT CL542x_800x600_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in 800x600 mode

    EOD
};

//
// 1024x768 16-color (60Hz refresh) mode set command string for CL 542x.
//

USHORT CL542x_1024x768_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,


    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x000b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x010b,
#endif

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//-----------------------------
// standard VGA text modes here
// 80x25 at 640x350
//
//-----------------------------

//
// 80x25 text mode set command string for CL 542x.
// (720x400 pixel resolution; 9x16 character cell.)
//

USHORT CL542x_80x25Text[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in text mode

    EOD
};

//
// 80x25 text mode set command string for CL 542x.
// (640x350 pixel resolution; 8x14 character cell.)
//

USHORT CL542x_80x25_14_Text[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,         // no banking in text mode

    EOD
};

//
// 1280x1024 16-color mode (BIOS mode 0x6C) set command string for CL 542x.
//

USHORT CL542x_1280x1024_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x000b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x010b,
#endif

    EOD
};

//
// 640x480 64k-color mode (BIOS mode 0x64) set command string for CL 542x.
//

USHORT CL542x_640x480_64k[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    4,
    0x0506,                         // Some BIOS's set Chain Odd maps bit
#if ONE_64K_BANK
    0x0009, 0x000a, 0x000b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x010b,
#endif

    EOD                   
};

//
// 640x480 256-color mode (BIOS mode 0x5F) set command string for CL 542x.
//

USHORT CL542x_640x480_256[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x000b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x010b,
#endif

    EOD                   
};

//
// 800x600 256-color mode (BIOS mode 0x5C) set command string for CL 542x.
//

USHORT CL542x_800x600_256[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                              // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x000b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x010b,
#endif

    EOD                   
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\modeset.c ===
/*++

Copyright (c) 1992-1997 Microsoft Corporation.
Copyright (c) 1996-1997 Cirrus Logic, Inc.

Module Name:

    modeset.c

Abstract:

    This is the modeset code for the CL6410/20 miniport driver.

Environment:

    kernel mode only

Notes:

Revision History:
*
* jl01   09-24-96  Fix Alt+Tab switching between "Introducing Windows NT"
*                  and "Main".  Refer to PDR#5409.
* chu01  08-26-96  CL-GD5480 BitBlt enhancement.
* chu02  10-06-96  Refresh rate setting for CL-GD5480 mode 7B
*                  ( 1600 x 1200 x 8 bpp )
* sge01  10-06-96  Fix PDR #6794: Correct Monitor refresh rate for 100Hz
*                  file changed: cldata.c modeset.c
* sge02  10-18-96  Add Monitor.Type Value name in registry
* chu03  10-31-96  Set Mode through registry.
* jl02   12-05-96  Comment out 5446 checking.
* chu04  12-16-96  Enable color correct.
*
* myf0   08-19-96  added 85hz supported
* myf1   08-20-96  supported panning scrolling
* myf2   08-20-96  fixed hardware save/restore state bug for matterhorn
* myf3   09-01-96  Added IOCTL_CIRRUS_PRIVATE_BIOS_CALL for TV supported
* myf4   09-01-96  patch Viking BIOS bug, PDR #4287, begin
* myf5   09-01-96  Fixed PDR #4365 keep all default refresh rate
* myf6   09-17-96  Merged Desktop SRC1001 & MINI102
* myf7   09-19-96  Fixed exclude 60Hz refresh rate selected
* myf8  *09-21-96* May be need change CheckandUpdateDDC2BMonitor --keystring[]
* myf9   09-21-96  8x6 panel in 6x4x256 mode, cursor can't move to bottom scrn
* ms0809 09-25-96  fixed dstn panel icon corrupted
* ms923  09-25-96  merge MS-923 Disp.zip code
* myf10  09-26-96  Fixed DSTN reserved half-frame buffer bug.
* myf11  09-26-96  Fixed 755x CE chip HW bug, access ramdac before disable HW
*                  icons and cursor
* myf12  10-01-96  Supported Hot Key switch display
* myf13  10-05-96  Fixed /w panning scrolling, vertical expension on bug
* myf14  10-15-96  Fixed PDR#6917, 6x4 panel can't panning scrolling for 754x
* myf15  10-16-96  Fixed disable memory mapped IO for 754x, 755x
* myf16  10-22-96  Fixed PDR #6933,panel type set different demo board setting
* tao1   10-21-96  Added 7555 flag for Direct Draw support.
* smith  10-22-96  Disable Timer event, because sometimes creat PAGE_FAULT or
*                  IRQ level can't handle
* myf17  11-04-96  Added special escape code must be use 11/5/96 later NTCTRL,
*                  and added Matterhorn LF Device ID==0x4C
* myf18  11-04-96  Fixed PDR #7075,
* myf19  11-06-96  Fixed Vinking can't work problem, because DEVICEID = 0x30
*                  is different from data book (CR27=0x2C)
* myf20  11-12-96  Fixed DSTN panel initial reserved 128K memoru
* myf21  11-15-96  fixed #7495 during change resolution, screen appear garbage
*                  image, because not clear video memory.
* myf22  11-19-96  Added 640x480x256/640x480x64K -85Hz refresh rate for 7548
* myf23  11-21-96  Added fixed NT 3.51 S/W cursor panning problem
* myf24  11-22-96  Added fixed NT 4.0 Japanese dos full screen problem
* myf25  12-03-96  Fixed 8x6x16M 2560byte/line patch H/W bug PDR#7843, and
*                  fixed pre-install microsoft requested
* myf26  12-11-96  Fixed Japanese NT 4.0 Dos-full screen bug for LCD enable
* myf27  01-09-97  Fixed NT3.51 PDR#7986, horizontal lines appears at logon
*                  windows, set 8x6x64K mode boot up CRT, jumper set 8x6 DSTN
*                  Fixed NT3.51 PDR#7987, set 64K color modes, garbage on
*                  screen when boot up XGA panel.
*
* pat08            Previous changes that didn't make into drv1.11
* sge03  01-23-97  Fix 1280x1024x8 clock mismatch problem for video.
* myf28  02-03-97  Fixed NT dos full screen bug, and add new clpanel.c file
*                  PDR #8357,mode 3, 12, panning scrolling bug
* myf29  02-12-97  Support Gamma correction graphic/video LUT for 755x
* myf30  02-10-97  Fixed NT3.51, 6x4 LCD boot set 256 coloe, test 64K mode
* chu05  02-19-97  MMIO internal error.
* chu06  03-12-96  Remove SR16 overwrite for 5436 or later. This is requested
*                  by Siemens Europe.
* myf31  03-12-97  Fixed 755x vertical expension on(CR82), HW cursor bug
* myf33 :03-21-97  check TV on, disable HW video & HW cursor, PDR #9006
* chu07  03-26-97  Get rid of 1024x768x16bpp ( Mode 0x74 ) 85H for IBM only.
* chu08  03-26-97  Common routine to get Cirrus chip and revision IDs.
* myf34 :04-08-97  if Internal TV on, change Vres to 452 (480-28) lines.
* myf35 :05-08-97  fIXED 7548 vl-BUS bug for panning scrolling enable
*
--*/
//#include <ntddk.h>
#include <dderror.h>
#include <devioctl.h>
//#include <clmini.h>
#include <miniport.h>

#include <ntddvdeo.h>
#include <video.h>
#include "cirrus.h"

#include "cmdcnst.h"

//
// Temporarily include defines from NTDDK.H which we can't
// currently include due to header file conflicts.
//

#include "clddk.h"

//crus
#ifndef VIDEO_MODE_MAP_MEM_LINEAR
#define VIDEO_MODE_MAP_MEM_LINEAR 0x40000000
#endif

// crus
#define DSTN       (Dual_LCD | STN_LCD)
#define DSTN10     (DSTN | panel10x7)
#define DSTN8      (DSTN | panel8x6)
#define DSTN6      (DSTN | panel)
#define PanelType  (panel | panel8x6 | panel10x7)
#define ScreenType (DSTN | PanelType)

extern UCHAR EDIDBuffer[]   ;
extern UCHAR EDIDTiming_I   ;
extern UCHAR EDIDTiming_II  ;
extern UCHAR EDIDTiming_III ;
extern UCHAR DDC2BFlag      ;
extern OEMMODE_EXCLUDE ModeExclude ;                                 // chu07

//crus begin
#if 0           //myf28
extern SHORT    Panning_flag;
//myf1, begin
//#define PANNING_SCROLL

#ifdef PANNING_SCROLL
extern RESTABLE ResolutionTable[];
extern PANNMODE PanningMode;
extern USHORT   ViewPoint_Mode;

PANNMODE PanningMode = {1024, 768, 1024, 8, -1 };

#endif

extern UCHAR  HWcur, HWicon0, HWicon1, HWicon2, HWicon3;    //myf11
#endif          //0,myf28

VOID                                    //myf11
AccessHWiconcursor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    SHORT Access_flag
    );

#ifdef PANNING_SCROLL
VP_STATUS
CirrusSetDisplayPitch (
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PANNMODE PanningMode
   );
#endif

ULONG
GetPanelFlags(                                 //myf17
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//myf28
ULONG
SetLaptopMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEOMODE pRequestedMode,
    ULONG RequestedModeNum
    );
//myf1, end
//crus end

VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
CirrusValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//crus
ULONG
GetAttributeFlags(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//crus
// LCD Support
USHORT
CheckLCDSupportMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    );

// DDC2B support
BOOLEAN
CheckDDC2B(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    );

VOID
AdjFastPgMdOperOnCL5424(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEOMODE pRequestedMode
    );

// crus
// jl02 BOOLEAN
// jl02 CheckGD5446Rev(
// jl02     PHW_DEVICE_EXTENSION HwDeviceExtension
// jl02     );


//crus
VOID CheckAndUpdateDDC2BMonitor(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VP_STATUS
CirrusDDC2BRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

//crus
BOOLEAN
CheckDDC2BMonitor(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    );

// chu03
BOOLEAN
VgaSetModeThroughRegistry(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEOMODE pRequestedMode,
    USHORT hres,
    USHORT vres
    );

// chu07
GetOemModeOffInfoCallBack (
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

// chu08
UCHAR
GetCirrusChipId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

// chu08
USHORT
GetCirrusChipRevisionId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,VgaInterpretCmdStream)
#pragma alloc_text(PAGE,VgaSetMode)
#pragma alloc_text(PAGE,VgaQueryAvailableModes)
#pragma alloc_text(PAGE,VgaQueryNumberOfAvailableModes)
#if 0           //myf28
#ifdef PANNING_SCROLL
#pragma alloc_text(PAGE,CirrusSetDisplayPitch)       //myf1, crus
#endif
#pragma alloc_text(PAGE,SetLaptopMode)          //myf28
#pragma alloc_text(PAGE,AccessHWiconcursor)          //myf11, crus
#pragma alloc_text(PAGE,GetPanelFlags)          //myf17
#endif          //myf28
#pragma alloc_text(PAGE,VgaQueryCurrentMode)
#pragma alloc_text(PAGE,VgaZeroVideoMemory)
#pragma alloc_text(PAGE,CirrusValidateModes)
#pragma alloc_text(PAGE,GetAttributeFlags)
//myf28 #pragma alloc_text(PAGE,CheckLCDSupportMode)
#pragma alloc_text(PAGE,CheckDDC2B)
#pragma alloc_text(PAGE,AdjFastPgMdOperOnCL5424)
// jl02 #pragma alloc_text(PAGE,CheckGD5446Rev)
//crus
#pragma alloc_text(PAGE,CheckAndUpdateDDC2BMonitor)
#pragma alloc_text(PAGE,CirrusDDC2BRegistryCallback)
#pragma alloc_text(PAGE,GetOemModeOffInfoCallBack)                   // chu07
#pragma alloc_text(PAGE,GetCirrusChipId)                             // chu08
#pragma alloc_text(PAGE,GetCirrusChipRevisionId)                     // chu08
#endif


// the following is defined in cirrus.c
VOID
SetCirrusBanking(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG BankNumber
    );

//---------------------------------------------------------------------------
VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pusCmdStream - array of commands to be interpreted.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG  ulCmd;
    ULONG  ulPort;
    UCHAR  jValue;
    USHORT usValue;
    ULONG  culCount;
    ULONG  ulIndex;
    ULONG  ulBase;
// chu05
    UCHAR  i;
    USHORT tempW;


//  VideoDebugPrint((0, "Miniport - VgaInterpretCmdStream\n")); //myfr
    if (pusCmdStream == NULL) {

        VideoDebugPrint((1, "VgaInterpretCmdStream - Invalid pusCmdStream\n"));
        return TRUE;
    }

    ulBase = PtrToUlong(HwDeviceExtension->IOAddress);

    //
    // Now set the adapter to the desired mode.
    //

    while ((ulCmd = *pusCmdStream++) != EOD) {

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

            //
            // Basic input/output command
            //

            case INOUT:

                //
                // Determine type of inout instruction
                //

                if (!(ulCmd & IO)) {

                    //
                    // Out instruction. Single or multiple outs?
                    //

                    if (!(ulCmd & MULTI)) {

                        //
                        // Single out. Byte or word out?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // Single byte out
                            //

                            ulPort = *pusCmdStream++;
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)(ulBase+ulPort),
                                    jValue);

                        } else {

                            //
                            // Single word out
                            //

                            ulPort = *pusCmdStream++;
                            usValue = *pusCmdStream++;
                            VideoPortWritePortUshort((PUSHORT)(ULONG_PTR)(ulBase+ulPort),
                                    usValue);

                        }

                    } else {

                        //
                        // Output a string of values
                        // Byte or word outs?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // String byte outs. Do in a loop; can't use
                            // VideoPortWritePortBufferUchar because the data
                            // is in USHORT form
                            //

                            ulPort = ulBase + *pusCmdStream++;
                            culCount = *pusCmdStream++;

                            while (culCount--) {
                                jValue = (UCHAR) *pusCmdStream++;
                                VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)ulPort,
                                        jValue);

                            }

                        } else {

                            //
                            // String word outs
                            //

                            ulPort = *pusCmdStream++;
                            culCount = *pusCmdStream++;

// chu05
                            if (!HwDeviceExtension->bMMAddress)
                            {
                                VideoPortWritePortBufferUshort((PUSHORT)(ULONG_PTR)
                                    (ulBase + ulPort), pusCmdStream, culCount);
                                pusCmdStream += culCount;
                            }
                            else
                            {
                                for (i = 0; i < culCount; i++)
                                {
                                    tempW = *pusCmdStream ;
                                    VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)(ulBase + ulPort),
                                                            (UCHAR)tempW) ;
                                    VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)(ulBase + ulPort + 1),
                                                            (UCHAR)(tempW >> 8)) ;
                                    pusCmdStream++ ;
                                }
                            }

                        }
                    }

                } else {

                    // In instruction
                    //
                    // Currently, string in instructions aren't supported; all
                    // in instructions are handled as single-byte ins
                    //
                    // Byte or word in?
                    //

                    if (!(ulCmd & BW)) {
                        //
                        // Single byte in
                        //

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)(ULONG_PTR)(ulBase+ulPort));

                    } else {

                        //
                        // Single word in
                        //

                        ulPort = *pusCmdStream++;
                        usValue = VideoPortReadPortUshort((PUSHORT)(ULONG_PTR)
                                (ulBase+ulPort));

                    }

                }

                break;

            //
            // Higher-level input/output commands
            //

            case METAOUT:

                //
                // Determine type of metaout command, based on minor
                // command field
                //
                switch (ulCmd & 0x0F) {

                    //
                    // Indexed outs
                    //

                    case INDXOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            usValue = (USHORT) (ulIndex +
                                      (((ULONG)(*pusCmdStream++)) << 8));
                            VideoPortWritePortUshort((PUSHORT)(ULONG_PTR)ulPort, usValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // Masked out (read, AND, XOR, write)
                    //

                    case MASKOUT:

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)(ULONG_PTR)(ulBase+ulPort));
                        jValue &= *pusCmdStream++;
                        jValue ^= *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)(ulBase + ulPort),
                                jValue);
                        break;

                    //
                    // Attribute Controller out
                    //

                    case ATCOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            // Write Attribute Controller index
                            VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)ulPort,
                                    (UCHAR)ulIndex);

                            // Write Attribute Controller data
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)(ULONG_PTR)ulPort, jValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // None of the above; error
                    //
                    default:

                        return FALSE;

                }


                break;

            //
            // NOP
            //

            case NCMD:

                break;

            //
            // Unknown command; error
            //

            default:

                return FALSE;

        }

    }

    return TRUE;

} // end VgaInterpretCmdStream()


VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    )

/*++

Routine Description:

    This routine sets the vga into the requested mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    Mode - Pointer to the structure containing the information about the
        font to be set.

    ModeSize - Length of the input buffer supplied by the user.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    ERROR_INVALID_PARAMETER if the mode number is invalid.

    NO_ERROR if the operation completed successfully.

--*/

{
    PVIDEOMODE pRequestedMode;
    PUSHORT pusCmdStream;
    VP_STATUS status;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    USHORT Int10ModeNumber;
    ULONG RequestedModeNum;

// crus
    UCHAR originalGRIndex, tempB ;
    UCHAR SEQIndex ;
//crus
//myf28    SHORT i;    //myf1

// crus chu02
    ULONG ulFlags = 0 ;

// chu03, begin
    BOOLEAN result = 0 ;
    USHORT  hres, vres ;
//chu03 end

    //
    // Check if the size of the data in the input buffer is large enough.
    //
//  VideoDebugPrint((0, "Miniport - VgaSetMode\n")); //myfr

    if (ModeSize < sizeof(VIDEO_MODE))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Extract the clear memory, and map linear bits.
    //

    RequestedModeNum = Mode->RequestedMode &
        ~(VIDEO_MODE_NO_ZERO_MEMORY | VIDEO_MODE_MAP_MEM_LINEAR);


    if (!(Mode->RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY))
    {
#if defined(_X86_)
  #if (_WIN32_WINNT >= 0x0400)          //pat08
       //
       // Don't do the operation.  Some Intel servers mysteriously RESET them selves because of this
       //
       if ((HwDeviceExtension->ChipType & CL754x) == 0) //myf35, fix VL-bus bug
       {
          //VgaZeroVideoMemory(HwDeviceExtension);
       }
  #else                                                 //pat08
       if (((HwDeviceExtension->ChipType & CL754x) == 0) &&     //pat08
           ((HwDeviceExtension->ChipType & CL755x) == 0) )      //pat08
       {
           //VgaZeroVideoMemory(HwDeviceExtension);
       }
  #endif        //pat08
#endif
    }

    //
    // Check to see if we are requesting a valid mode
    //

    if ( (RequestedModeNum >= NumVideoModes) ||
         (!ModesVGA[RequestedModeNum].ValidMode) )
    {
        VideoDebugPrint((1, "Invalide Mode Number = %d!\n", RequestedModeNum));

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Check to see if we are trying to map a non linear
    // mode linearly.
    //
    // We will fail early if we are trying to set a mode
    // with a linearly mapped frame buffer, and either of the
    // following two conditions are true:
    //
    // 1) The mode can not be mapped linearly because it is
    //    a vga mode, etc.
    //
    //    or,
    //
    // 2) We did not find the card in a PCI slot, and thus
    //    can not do linear mappings period.
    //

    VideoDebugPrint((1, "Linear Mode Requested: %x\n"
                        "Linear Mode Supported: %x\n",
                        Mode->RequestedMode & VIDEO_MODE_MAP_MEM_LINEAR,
                        ModesVGA[RequestedModeNum].LinearSupport));

#if defined(_ALPHA_)

    //
    // For some reason if we map a linear frame buffer
    // for the 5434 and older chips on the alpha, we
    // die when we touch the memory.  However, if we map
    // a banked 64k frame buffer all works fine.  So,
    // lets always fail the linear frame buffer mode set
    // on alpha for older chips.
    //
    // For some reason which is also a mystery to me, we
    // can map the memory linearly for the 5446 and
    // newer chips.
    //

    if (Mode->RequestedMode & VIDEO_MODE_MAP_MEM_LINEAR) {

        if ((HwDeviceExtension->ChipRevision != CL5436_ID) &&
            (HwDeviceExtension->ChipRevision != CL5446_ID) &&
            (HwDeviceExtension->ChipRevision != CL5480_ID)) {

            return ERROR_INVALID_PARAMETER;
        }
    }

#endif

    if ((Mode->RequestedMode & VIDEO_MODE_MAP_MEM_LINEAR) &&
        ((!ModesVGA[RequestedModeNum].LinearSupport) ||
         (!VgaAccessRange[3].RangeLength)))
    {
        VideoDebugPrint((1, "Cannot set linear mode!\n"));

        return ERROR_INVALID_PARAMETER;
    }
    else
    {

#if defined(_X86_) || defined(_ALPHA_)

        HwDeviceExtension->LinearMode =
            (Mode->RequestedMode & VIDEO_MODE_MAP_MEM_LINEAR) ?
            TRUE : FALSE;

#else

        HwDeviceExtension->LinearMode = TRUE;

#endif

        VideoDebugPrint((1, "Linear Mode = %s\n",
                            Mode->RequestedMode & VIDEO_MODE_MAP_MEM_LINEAR ?
                            "TRUE" : "FALSE"));         //myfr, 1
    }

    VideoDebugPrint((1, "Attempting to set mode %d\n",
                        RequestedModeNum));

    pRequestedMode = &ModesVGA[RequestedModeNum];

    VideoDebugPrint((1, "Info on Requested Mode:\n"
                        "\tResolution: %dx%dx%d\n",
                        pRequestedMode->hres,
                        pRequestedMode->vres,
                        pRequestedMode->bitsPerPlane ));        //myfr, 2


#ifdef INT10_MODE_SET
    //
    // Set SR14 bit 2 to lock panel, Panel will not be turned on if setting
    // this bit.  For laptop products only.
    //

//myf28 begin
    if ((HwDeviceExtension->ChipType == CL756x) ||
        (HwDeviceExtension->ChipType &  CL755x) ||
        (HwDeviceExtension->ChipType == CL6245) ||
        (HwDeviceExtension->ChipType &  CL754x))
    {
        status = SetLaptopMode(HwDeviceExtension,pRequestedMode,
                               RequestedModeNum);
#if 0
        if ((status == ERROR_INVALID_PARAMETER) ||
            (status == ERROR_INSUFFICIENT_BUFFER))
            return status;
        else
            pRequestedMode = (PVIDEOMODE)status;
#endif

        if (status != NO_ERROR) {
            return status;
        }
    }
//myf28 end

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    //
    // first, set the montype, if valid
    //

    if ((pRequestedMode->MonitorType) &&
        !(HwDeviceExtension->ChipType &  CL754x) &&
        (HwDeviceExtension->ChipType != CL756x) &&
// crus
        (HwDeviceExtension->ChipType != CL6245) &&
        !(HwDeviceExtension->ChipType & CL755x) )
    {

       biosArguments.Eax = 0x1200 | pRequestedMode->MonitorType;
       biosArguments.Ebx = 0xA2;     // set monitor type command

       status = VideoPortInt10(HwDeviceExtension, &biosArguments);

       if (status != NO_ERROR)
           return status;

    }

    //
    // Set the Vertical Monitor type, if BIOS supports it
    //

    if ((pRequestedMode->MonTypeAX) &&
        !(HwDeviceExtension->ChipType & CL754x) &&
        (HwDeviceExtension->ChipType != CL756x) &&
// crus
        (HwDeviceExtension->ChipType != CL6245) &&
        !(HwDeviceExtension->ChipType & CL755x) )
    {
        biosArguments.Eax = pRequestedMode->MonTypeAX;
        biosArguments.Ebx = pRequestedMode->MonTypeBX;  // set monitor type
        biosArguments.Ecx = pRequestedMode->MonTypeCX;
        status = VideoPortInt10 (HwDeviceExtension, &biosArguments);

        if (status != NO_ERROR)
        {
            return status;
        }
// crus
// chu02
#if 0
        ulFlags = GetAttributeFlags(HwDeviceExtension) ;
        if ((ulFlags & CAPS_COMMAND_LIST) &&
            (pRequestedMode->hres == 1600) &&
            (pRequestedMode->bitsPerPlane == 8))
        {
            switch (pRequestedMode->Frequency)
            {
                UCHAR tempB ;

                case 60 :
                    // o 3c4 14
                    VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                        SEQ_ADDRESS_PORT, 0x14) ;
                    // i 3c5 tempB
                    tempB = VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT) ;
                    tempB &= 0x1F ;
                    tempB |= 0x20 ;
                    // o 3c5 tempB
                    VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                        SEQ_DATA_PORT, tempB) ;
                    break ;

                case 70 :
                    // o 3c4 14
                    VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                        SEQ_ADDRESS_PORT, 0x14) ;
                    // i 3c5 tempB
                    tempB = VideoPortReadPortUchar (HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT) ;
                    tempB &= 0x1F ;
                    tempB |= 0x40 ;
                    // o 3c5 tempB
                    VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                        SEQ_DATA_PORT, tempB) ;
                    break ;
            }
        }
#endif // 0

    }

   //
   // for 640x480 modes, determine the refresh type
   //

   if (pRequestedMode->hres == 640)
   {
       if (!(HwDeviceExtension->ChipType & CL754x) &&
           (HwDeviceExtension->ChipType != CL756x) &&
//crus
           (HwDeviceExtension->ChipType != CL6245) &&
           !(HwDeviceExtension->ChipType & CL755x) )
       {
           if (HwDeviceExtension->ChipType == CL543x)
           {

               switch (pRequestedMode->Frequency) {

                   case 72 :
                       biosArguments.Eax = 0x1200;     // set HIGH refresh to 72hz
                       break;

                   case 75:
                       biosArguments.Eax = 0x1201;     // set HIGH refresh to 75hz
                       break;

                   case 85:
                       biosArguments.Eax = 0x1202;     // set HIGH refresh to 85hz
                       break;
// crus
// sge01
                   case 100:
                       biosArguments.Eax = 0x1203;     // set HIGH refresh to 100hz
                       break;
               }
               biosArguments.Ebx = 0xAF;         // set refresh type

               status = VideoPortInt10 (HwDeviceExtension, &biosArguments);

               biosArguments.Eax = 0x1200;
               biosArguments.Ebx = 0xAE;         // get refresh type

               status = VideoPortInt10 (HwDeviceExtension, &biosArguments);

           } else {

               if (pRequestedMode->Frequency == 72)
               {
                   // 72 hz refresh setup only takes effect in 640x480
                   biosArguments.Eax = 0x1201;   // enable HIGH refresh
               }
               else
               {
                   // set low refresh rate
                   biosArguments.Eax = 0x1200;   // enable LOW refresh, 640x480 only
               }
               biosArguments.Ebx = 0xA3;         // set refresh type

               status = VideoPortInt10 (HwDeviceExtension, &biosArguments);

           }
           if (status != NO_ERROR)
           {
               return status;
           }
       }

    }

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    //
    // then, set the mode
    //

    switch (HwDeviceExtension->ChipType)
    {
       case CL6410:

           Int10ModeNumber = pRequestedMode->BiosModes.BiosModeCL6410;
           break;

       case CL6420:

           Int10ModeNumber = pRequestedMode->BiosModes.BiosModeCL6420;
           break;

       case CL542x:
       case CL543x:     //myf1
//crus
           Int10ModeNumber = pRequestedMode->BiosModes.BiosModeCL542x;
           break;

       case CL754x:
       case CL755x:
       case CL7541:
       case CL7542:
       case CL7543:
       case CL7548:
       case CL7555:
       case CL7556:
       case CL756x:
// crus
       case CL6245:

           Int10ModeNumber = pRequestedMode->BiosModes.BiosModeCL542x;
//crus
//myf1, begin
#ifdef PANNING_SCROLL
              Int10ModeNumber |= 0x80;
#endif
//myf1, end
           break;

    }

    biosArguments.Eax = Int10ModeNumber;

//crus
//myf11: 9-26-96 fixed 755x-CE chip bug
    if (HwDeviceExtension->ChipType == CL7555)
    {
        AccessHWiconcursor(HwDeviceExtension, 0);   //disable HW icon, cursor
    }


//myf21 : 11-15-96 fixed #7495 during change resolution, screen appear garbage
//                 image, because not clear video memory.

//    SEQIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
//                     SEQ_ADDRESS_PORT);
//  VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_ADDRESS_PORT, 0x01);
//  tempB = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_DATA_PORT);
//  VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_DATA_PORT,(tempB | 0x20));
//    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                     SEQ_ADDRESS_PORT, SEQIndex);


    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

//myf21 : 11-15-96 fixed #7495 during change resolution, screen appear garbage
//                 image, because not clear video memory.

//    SEQIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
//                     SEQ_ADDRESS_PORT);
//  VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_ADDRESS_PORT, 0x01);
//  tempB = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_DATA_PORT);
//  VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                   SEQ_DATA_PORT,(tempB & ~0x20));
//    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
//                     SEQ_ADDRESS_PORT, SEQIndex);

//crus
    if (HwDeviceExtension->ChipType == CL7555)
    {
        AccessHWiconcursor(HwDeviceExtension, 1);   //Enable HW icon, cursor
    }

//crus
#if 0           //jl01
    if (HwDeviceExtension->AutoFeature)
    {
        // i 3ce originalGRIndex
        originalGRIndex = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                              GRAPH_ADDRESS_PORT);

        // o 3ce 31
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, INDEX_ENABLE_AUTO_START);

        // i 3cf tempB
        tempB = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT);

        tempB |= (UCHAR) 0x80;                  //enable auto start bit 7

        // o 3cf tempB
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, tempB);

        // o 3ce originalGRIndex
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, originalGRIndex);
    }
#endif          //jl01

    //
    // Lets check to see that we actually went into the mode
    // we just tried to set.  If not, then return failure.
    //

    biosArguments.Eax = 0x0f00;
    VideoPortInt10(HwDeviceExtension, &biosArguments);

    if ((biosArguments.Eax & 0xff) != Int10ModeNumber)
    {
        //
        // The int10 modeset failed.  Return the failure back to
        // the system.
        //

        VideoDebugPrint((1, "The INT 10 modeset didn't set the mode.\n"));

        return ERROR_INVALID_PARAMETER;
    }
//crus begin
#if 0           //myf28
    HwDeviceExtension->bCurrentMode = RequestedModeNum;   //myf12
    VideoDebugPrint((1, "SetMode Info :\n"
                        "\tMode : %x, CurrentModeNum : %x, ( %d)\n",
                        Int10ModeNumber,
                        RequestedModeNum,
                        RequestedModeNum));
#endif          //myf28
//crus end

    AdjFastPgMdOperOnCL5424 (HwDeviceExtension, pRequestedMode) ;

    //
    // this code fixes a bug for color TFT panels only
    // when on the 6420 and in 640x480 8bpp only
    //

    if ( (HwDeviceExtension->ChipType == CL6420) &&
         (pRequestedMode->bitsPerPlane == 8)     &&
         (pRequestedMode->hres == 640) )
    {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                GRAPH_ADDRESS_PORT, 0xDC); // color LCD config reg.

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                  GRAPH_DATA_PORT) & 01)  // if TFT panel
        {
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    GRAPH_ADDRESS_PORT, 0xD6); // greyscale offset LCD reg.

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    GRAPH_DATA_PORT,

            (UCHAR)((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                             GRAPH_DATA_PORT) & 0x3f) | 0x40));

        }
    }

#endif          //INT10_MODE_SET

// chu03
//MODESET_OK:

    //
    // Select proper command array for adapter type
    //

    switch (HwDeviceExtension->ChipType)
       {

       case CL6410:

           VideoDebugPrint((1, "VgaSetMode - Setting mode for 6410\n"));
           if (HwDeviceExtension->DisplayType == crt)
              pusCmdStream = pRequestedMode->CmdStrings[pCL6410_crt];
           else
              pusCmdStream = pRequestedMode->CmdStrings[pCL6410_panel];
           break;

       case CL6420:
           VideoDebugPrint((1, "VgaSetMode - Setting mode for 6420\n"));
           if (HwDeviceExtension->DisplayType == crt)
              pusCmdStream = pRequestedMode->CmdStrings[pCL6420_crt];
           else
              pusCmdStream = pRequestedMode->CmdStrings[pCL6420_panel];
           break;

       case CL542x:
           VideoDebugPrint((1, "VgaSetMode - Setting mode for 542x\n"));
           pusCmdStream = pRequestedMode->CmdStrings[pCL542x];
           break;

       case CL543x:

           if (HwDeviceExtension->BoardType == NEC_ONBOARD_CIRRUS)
           {
               VideoDebugPrint((1, "VgaSetMode - Setting mode for NEC 543x\n"));
               pusCmdStream = pRequestedMode->CmdStrings[pNEC_CL543x];
           }
           else
           {
               VideoDebugPrint((1, "VgaSetMode - Setting mode for 543x\n"));
               pusCmdStream = pRequestedMode->CmdStrings[pCL543x];
           }
           break;

       case CL7541:
       case CL7542:
       case CL7543:
       case CL7548:
       case CL754x:        // Use 543x cmd strs (16k granularity, >1M modes)
           VideoDebugPrint((1, "VgaSetMode - Setting mode for 754x\n"));
           pusCmdStream = pRequestedMode->CmdStrings[pCL543x];

//crus
#if 0           //myf10
            if ( (pRequestedMode->bitsPerPlane == 16) &&
                 (pRequestedMode->hres == 640) )
            {
                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR, 0x2E); //expension_reg.

                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR,
                    (UCHAR)((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR) & 0xF0)));
            }
#endif

           break;

        case CL7555:
        case CL7556:
        case CL755x:       // Use 543x cmd strs (16k granularity, >1M modes)
            VideoDebugPrint((1, "VgaSetMode - Setting mode for 755x\n"));
            pusCmdStream = pRequestedMode->CmdStrings[pCL543x];
            break;

        case CL756x:       // Use 543x cmd strs (16k granularity, >1M modes)
            VideoDebugPrint((1, "VgaSetMode - Setting mode for 756x\n"));
            pusCmdStream = pRequestedMode->CmdStrings[pCL543x];
            break;

// crus
       case CL6245:
           VideoDebugPrint((1, "VgaSetMode - Setting mode for 6245\n"));
           pusCmdStream = pRequestedMode->CmdStrings[pCL542x];
           break;
// end crus

       default:

           VideoDebugPrint((1, "HwDeviceExtension->ChipType is INVALID.\n"));
           return ERROR_INVALID_PARAMETER;
       }

    VgaInterpretCmdStream(HwDeviceExtension, pusCmdStream);

    //
    // Set linear mode on X86 systems w/PCI bus
    //

    if (HwDeviceExtension->LinearMode)
    {
        VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                                 SEQ_ADDRESS_PORT, 0x07);
        VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
           (UCHAR) (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
           SEQ_DATA_PORT) | 0x10));
    }
    else
    {
        VideoPortWritePortUchar (HwDeviceExtension->IOAddress +
                                 SEQ_ADDRESS_PORT, 0x07);
        VideoPortWritePortUchar (HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
           (UCHAR) (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
           SEQ_DATA_PORT) & ~0x10));
    }

    //
    // Support 256 color modes by stretching the scan lines.
    //
    if (pRequestedMode->CmdStrings[pStretchScan])
                  {
        VgaInterpretCmdStream(HwDeviceExtension,
                              pRequestedMode->CmdStrings[pStretchScan]);
    }

    {
        UCHAR temp;
        UCHAR dummy;
        UCHAR bIsColor;

        if (!(pRequestedMode->fbType & VIDEO_MODE_GRAPHICS))
        {

            //
            // Fix to make sure we always set the colors in text mode to be
            // intensity, and not flashing
            // For this zero out the Mode Control Regsiter bit 3 (index 0x10
            // of the Attribute controller).
            //

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT) & 0x01)
            {
                bIsColor = TRUE;
            }
            else
            {
                bIsColor = FALSE;
            }

            if (bIsColor)
            {
                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                         INPUT_STATUS_1_COLOR);
            }
            else
            {
                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                         INPUT_STATUS_1_MONO);
            }

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
            temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    ATT_DATA_READ_PORT);

            temp &= 0xF7;

            if (bIsColor)
            {
                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                         INPUT_STATUS_1_COLOR);
            }
            else
            {
                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                         INPUT_STATUS_1_MONO);
            }

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    ATT_DATA_WRITE_PORT, temp);
        }
    }

    //
    // Update the location of the physical frame buffer within video memory.
    //

    if (HwDeviceExtension->LinearMode)
    {
        HwDeviceExtension->PhysicalVideoMemoryBase   = VgaAccessRange[3].RangeStart;
        HwDeviceExtension->PhysicalVideoMemoryLength = HwDeviceExtension->AdapterMemorySize;

        HwDeviceExtension->PhysicalFrameLength = 0;
        HwDeviceExtension->PhysicalFrameOffset.LowPart = 0;
    }
    else
    {
        HwDeviceExtension->PhysicalVideoMemoryBase   = VgaAccessRange[2].RangeStart;
        HwDeviceExtension->PhysicalVideoMemoryLength = VgaAccessRange[2].RangeLength;

        HwDeviceExtension->PhysicalFrameLength =
                MemoryMaps[pRequestedMode->MemMap].MaxSize;

        HwDeviceExtension->PhysicalFrameOffset.LowPart =
                MemoryMaps[pRequestedMode->MemMap].Offset;
    }

    //
    // Store the new mode value.
    //

    HwDeviceExtension->CurrentMode = pRequestedMode;
    HwDeviceExtension->ModeIndex = Mode->RequestedMode;

    if ((HwDeviceExtension->ChipRevision < CL5434_ID) // we saved chip ID here
         && (pRequestedMode->numPlanes != 4) )
    {
        if ((HwDeviceExtension->ChipRevision >= 0x0B) && //Nordic(Lite,Viking)
            (HwDeviceExtension->ChipRevision <= 0x0E) && //and Everest
            (HwDeviceExtension->DisplayType & (panel8x6)) &&
            (pRequestedMode->hres == 640) &&
            ((pRequestedMode->bitsPerPlane == 8) ||     //myf33
             (pRequestedMode->bitsPerPlane == 16) ||    //myf33
             (pRequestedMode->bitsPerPlane == 24)) )    //myf33
       {    // For 754x on 800x600 panel, disable HW cursor in 640x480 mode
           HwDeviceExtension->VideoPointerEnabled = FALSE; // disable HW Cursor

           VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
               CRTC_ADDRESS_PORT_COLOR, 0x2E);

           HwDeviceExtension->cursor_vert_exp_flag =
               VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                   CRTC_DATA_PORT_COLOR) & 0x02;

           if (HwDeviceExtension->cursor_vert_exp_flag)
           {
               HwDeviceExtension->CursorEnable = FALSE;
           }
       }
// crus
        else if (HwDeviceExtension->ChipType == CL6245)
        {
            pRequestedMode->HWCursorEnable = FALSE;
            HwDeviceExtension->VideoPointerEnabled = FALSE;
        }
// end crus
//myf31 begin, 3-12-97, 755x expension on, HW cursor bug
        else if (HwDeviceExtension->ChipType & CL755x)      //CL755x
        {
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR, 0x82);

            HwDeviceExtension->cursor_vert_exp_flag =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR) & 0x60;

            if (HwDeviceExtension->cursor_vert_exp_flag)
            {
                HwDeviceExtension->CursorEnable = FALSE;
                HwDeviceExtension->VideoPointerEnabled = FALSE; //disable HW Cursor
            }
        //myf33
            if ((pRequestedMode->hres == 640) &&
                ((pRequestedMode->bitsPerPlane == 8) ||
                 (pRequestedMode->bitsPerPlane == 16) ||
                 (pRequestedMode->bitsPerPlane == 24)) )
            {
                HwDeviceExtension->CursorEnable = FALSE;
                HwDeviceExtension->VideoPointerEnabled = FALSE; //disable HW Cursor
            }
        //myf33 end

        }
//myf31 end
       else
       {
           HwDeviceExtension->VideoPointerEnabled = TRUE; // enable HW Cursor
       }
    }
    else
    {    // For 5434 and 4-bit modes, use value from VideoMode structure
        HwDeviceExtension->VideoPointerEnabled = pRequestedMode->HWCursorEnable;
    }

    //
    // Adjust the FIFO Demand Threshold value for the 5436+.
    // The 5434 values work for all of the other registers
    // except this one.
    //

    // chu06
    //
    // Siemens reports this might cause undesired "yellow" screen on some
    // 5436 16bpp modes. There's no reason to change it after BIOS sets it up
    //
#if 0
    if (HwDeviceExtension->ChipRevision >= CL5436_ID)
    {
        UCHAR  PerfTuningReg, FifoDemandThreshold;

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, IND_PERF_TUNING);

        PerfTuningReg = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    SEQ_DATA_PORT);

        //
        // Add an offset to the threshold that makes the 5434 values work
        // for the 5436+.  We do this rather than building a whole new set
        // of 5436-specific structures.
        //

        if ((FifoDemandThreshold = (PerfTuningReg & 0x0F) + 4) > 15)
        {
            FifoDemandThreshold = 15;
        }

        PerfTuningReg = (PerfTuningReg & ~0x0F) | FifoDemandThreshold;

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, PerfTuningReg);
    }
#endif // 0

//crus
//myf1, begin
#ifdef PANNING_SCROLL
{
    VP_STATUS status;
    if (Panning_flag && (((Int10ModeNumber & 0x7f) != 3) &&
                         ((Int10ModeNumber & 0x7f) != 0x12)))   //myf30
        status = CirrusSetDisplayPitch(HwDeviceExtension, PanningMode);
}
#endif
//myf1, end

    //
    // Adjust the GR18[5] for 5446.
    //
        // sge03

    if (HwDeviceExtension->ChipRevision == CL5446_ID)
    {
                UCHAR   bTemp;
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, 0x18);
        bTemp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT);
                bTemp &= 0xDF;
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, bTemp);

        }

    return NO_ERROR;

} //end VgaSetMode()


VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the list of all available available modes on the
    card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the list of all valid modes is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    PVIDEO_MODE_INFORMATION videoModes = ModeInformation;
    ULONG i;
    ULONG ulFlags;

    // chu07
    UCHAR            chipId ;
    USHORT           chipRevisionId ;
    static VP_STATUS status ;

    //
    // Find out the size of the data to be put in the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize =
            HwDeviceExtension->NumAvailableModes *
            sizeof(VIDEO_MODE_INFORMATION)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // The driver specific attribute flags for each mode remains
    // constant, so only calculate them once.
    //

    ulFlags = GetAttributeFlags(HwDeviceExtension);

    //
    // chu07
    // IBM does not favor 1024x768x16bpp 85 Hz for 5446 AC.
    // We access registry to know if there is a key OemModeOff, if there
    // is, we bypass it.
    //

    chipId         = GetCirrusChipId(HwDeviceExtension) ;
    chipRevisionId = GetCirrusChipRevisionId(HwDeviceExtension) ;

    //
    // IBM specific
    //
    if ((chipId == 0xB8) &&
        (chipRevisionId != 0x0045) &&
        (ModeExclude.NeverAccessed == TRUE)
       )
    {
        //
        // Access registry
        //
        status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                                L"OemModeOff",
                                                FALSE,
                                                GetOemModeOffInfoCallBack,
                                                NULL) ;

        if (status != NO_ERROR)
        {
            VideoDebugPrint((1, "Fail to access Contrast key info from registry\n"));
        }
        else
        {
            VideoDebugPrint((2, "ModeExclude.mode = %x\n", ModeExclude.mode));
            VideoDebugPrint((2, "ModeExclude.refresh = %x\n", ModeExclude.refresh));
        }

        ModeExclude.NeverAccessed = FALSE ;

    }

    //
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //

    for (i = 0; i < NumVideoModes; i++)
    {

        //
        // chu07 : Get rid of modes 0x74, 85Hz if required by IBM.
        //
        if ((status == NO_ERROR) &&
            (ModeExclude.mode == ModesVGA[i].BiosModes.BiosModeCL542x) &&
            (ModeExclude.refresh == ModesVGA[i].Frequency))
            continue ;

        if (ModesVGA[i].ValidMode)
        {
            videoModes->Length = sizeof(VIDEO_MODE_INFORMATION);
            videoModes->ModeIndex  = i;
            videoModes->VisScreenWidth = ModesVGA[i].hres;
            videoModes->ScreenStride = ModesVGA[i].wbytes;
            videoModes->VisScreenHeight = ModesVGA[i].vres;
            videoModes->NumberOfPlanes = ModesVGA[i].numPlanes;
            videoModes->BitsPerPlane = ModesVGA[i].bitsPerPlane;
            videoModes->Frequency = ModesVGA[i].Frequency;
            videoModes->XMillimeter = 320;        // temporary hardcoded constant
            videoModes->YMillimeter = 240;        // temporary hardcoded constant
            videoModes->AttributeFlags = ModesVGA[i].fbType;
            videoModes->AttributeFlags |= ModesVGA[i].Interlaced ?
                 VIDEO_MODE_INTERLACED : 0;

            videoModes->DriverSpecificAttributeFlags = ulFlags;

            //
            // The 5434 has a hardware cursor problem at 1280x1024
            // resolution.  Use a software cursor on these chips.
            //

            if ((videoModes->VisScreenWidth == 1280) &&
                (HwDeviceExtension->ChipRevision == 0x2A))
            {
                videoModes->DriverSpecificAttributeFlags
                    |= CAPS_SW_POINTER;
            }

// crus
            if (HwDeviceExtension->ChipType == CL6245)
            {
                videoModes->DriverSpecificAttributeFlags
                    |= CAPS_SW_POINTER;
            }
// end crus

            //
            // Account for vertical expansion on laptops
            //

            if ((HwDeviceExtension->ChipType &  CL754x)   &&
                (videoModes->VisScreenHeight == 480) &&
                (videoModes->BitsPerPlane == 8))
            {
                videoModes->DriverSpecificAttributeFlags
                    |= CAPS_SW_POINTER;
            }

            //
            // Calculate the VideoMemoryBitmapWidth
            //

            {
                LONG x;

                x = videoModes->BitsPerPlane;

                if( x == 15 ) x = 16;

                videoModes->VideoMemoryBitmapWidth =
                    (videoModes->ScreenStride * 8 ) / x;
            }

            videoModes->VideoMemoryBitmapHeight =
                     HwDeviceExtension->AdapterMemorySize / videoModes->ScreenStride;
//crus
//myf15, begin
            if ((HwDeviceExtension->ChipType &  CL754x) ||
                (HwDeviceExtension->ChipType == CL6245) ||
                (HwDeviceExtension->ChipType &  CL755x))
                 videoModes->VideoMemoryBitmapHeight =
                             (HwDeviceExtension->AdapterMemorySize - 0x4000) /
                                         videoModes->ScreenStride;
//myf15, end

            if ((ModesVGA[i].bitsPerPlane == 32) ||
                (ModesVGA[i].bitsPerPlane == 24))
            {

                videoModes->NumberRedBits = 8;
                videoModes->NumberGreenBits = 8;
                videoModes->NumberBlueBits = 8;
                videoModes->RedMask = 0xff0000;
                videoModes->GreenMask = 0x00ff00;
                videoModes->BlueMask = 0x0000ff;

            }
            else if (ModesVGA[i].bitsPerPlane == 16)
            {

                videoModes->NumberRedBits = 6;
                videoModes->NumberGreenBits = 6;
                videoModes->NumberBlueBits = 6;
                videoModes->RedMask = 0x1F << 11;
                videoModes->GreenMask = 0x3F << 5;
                videoModes->BlueMask = 0x1F;

            }
            else
            {

                videoModes->NumberRedBits = 6;
                videoModes->NumberGreenBits = 6;
                videoModes->NumberBlueBits = 6;
                videoModes->RedMask = 0;
                videoModes->GreenMask = 0;
                videoModes->BlueMask = 0;
                videoModes->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
                     VIDEO_MODE_MANAGED_PALETTE;

            }

            videoModes++;

        }
    }

    return NO_ERROR;

} // end VgaQueryAvailableModes()

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the number of available modes for this particular
    video card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    NumModes - Pointer to the output buffer supplied by the user. This is
        where the number of modes is stored.

    NumModesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //
//  VideoDebugPrint((0, "Miniport - VgaQueryNumberofAvailableModes\n")); //myfr

    if (NumModesSize < (*OutputSize = sizeof(VIDEO_NUM_MODES)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the number of modes into the buffer.
    //

    NumModes->NumModes = HwDeviceExtension->NumAvailableModes;
    NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    return NO_ERROR;

} // end VgaGetNumberOfAvailableModes()

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns a description of the current video mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the current mode information is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    // check if a mode has been set
    //
//  VideoDebugPrint((0, "Miniport - VgaQueryCurrentMode\n")); //myfr

    if (HwDeviceExtension->CurrentMode == NULL ) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize = sizeof(VIDEO_MODE_INFORMATION))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    ModeInformation->DriverSpecificAttributeFlags =
        GetAttributeFlags(HwDeviceExtension);           //myf17 move to this

    //
    // Store the characteristics of the current mode into the buffer.
    //

    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);
    ModeInformation->ModeIndex = HwDeviceExtension->ModeIndex;
//crus begin
//myf1, begin
#ifdef PANNING_SCROLL
    if (Panning_flag)
    {
        ModeInformation->VisScreenWidth = PanningMode.hres;
        ModeInformation->ScreenStride = PanningMode.wbytes;
        ModeInformation->VisScreenHeight = PanningMode.vres;
        ModeInformation->BitsPerPlane = PanningMode.bpp;
       ModeInformation->AttributeFlags = HwDeviceExtension->CurrentMode->fbType
             & ~(HwDeviceExtension->CurrentMode->Interlaced ?
                VIDEO_MODE_INTERLACED : 0);     //myf22

    }
    else
#endif
//myf1, end
//crus end
    {
        ModeInformation->VisScreenWidth = HwDeviceExtension->CurrentMode->hres;
        ModeInformation->ScreenStride = HwDeviceExtension->CurrentMode->wbytes;
        ModeInformation->VisScreenHeight = HwDeviceExtension->CurrentMode->vres;
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
              CRTC_ADDRESS_PORT_COLOR, 0x30);           //myf34

        if ((ModeInformation->DriverSpecificAttributeFlags & CAPS_TV_ON) &&
            (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                   CRTC_DATA_PORT_COLOR) & 0x40) &&     //myf34, Internal TV
            (ModeInformation->VisScreenHeight == 480) &&
            (ModeInformation->VisScreenWidth == 640))
        {
            ModeInformation->VisScreenHeight =
                HwDeviceExtension->CurrentMode->vres - 28;  //myf33
        }
        else if ((ModeInformation->DriverSpecificAttributeFlags & CAPS_TV_ON) &&
                 (!(VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                     CRTC_DATA_PORT_COLOR) & 0x40)) &&     //myf34, External TV
                 (ModeInformation->VisScreenHeight == 480) &&
                 (ModeInformation->VisScreenWidth == 640))
        {
             ModeInformation->VisScreenHeight =
                      HwDeviceExtension->CurrentMode->vres - 68;  //AI Tech.
             VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                      CRTC_ADDRESS_PORT_COLOR, 0x12);
             VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                      CRTC_DATA_PORT_COLOR,
                      (UCHAR)ModeInformation->VisScreenHeight);
        }

        ModeInformation->BitsPerPlane = HwDeviceExtension->CurrentMode->bitsPerPlane;
        ModeInformation->AttributeFlags = HwDeviceExtension->CurrentMode->fbType
             | (HwDeviceExtension->CurrentMode->Interlaced ?
                VIDEO_MODE_INTERLACED : 0);     //myf22
    }

    ModeInformation->NumberOfPlanes = HwDeviceExtension->CurrentMode->numPlanes;
//crus
//    ModeInformation->BitsPerPlane = HwDeviceExtension->CurrentMode->bitsPerPlane;
    ModeInformation->Frequency = HwDeviceExtension->CurrentMode->Frequency;
    ModeInformation->XMillimeter = 320;        // temporary hardcoded constant
    ModeInformation->YMillimeter = 240;        // temporary hardcoded constant

//  ModeInformation->AttributeFlags = HwDeviceExtension->CurrentMode->fbType |
//      (HwDeviceExtension->CurrentMode->Interlaced ?
//       VIDEO_MODE_INTERLACED : 0);

    ModeInformation->DriverSpecificAttributeFlags =
        GetAttributeFlags(HwDeviceExtension);   //original, myf17

    //
    // The 5434 has a hardware cursor problem at 1280x1024
    // resolution.  Use a software cursor on these chips.
    //

    if ((ModeInformation->VisScreenWidth == 1280) &&
        (HwDeviceExtension->ChipRevision == 0x2A))
    {
        ModeInformation->DriverSpecificAttributeFlags
            |= CAPS_SW_POINTER;
    }
// crus
    if(HwDeviceExtension->ChipType == CL6245)
    {
        ModeInformation->DriverSpecificAttributeFlags
            |= CAPS_SW_POINTER;
    }
// end crus

//crus begin
//myf13, expension on with panning scrolling bug
    if ((HwDeviceExtension->ChipType &  CL754x)   &&
        (ModeInformation->VisScreenHeight == 640) &&    //myf15, myf33
        (ModeInformation->BitsPerPlane == 8))           //myf15
    {
         ModeInformation->DriverSpecificAttributeFlags
                 |= CAPS_SW_POINTER;
    }
/*
    if (((HwDeviceExtension->ChipType &  CL754x) ||
         (HwDeviceExtension->ChipType &  CL755x))  &&
        (Panning_flag))
    {
         ModeInformation->DriverSpecificAttributeFlags
                |= GCAPS_PANNING;       //myf15
    }
*/

//myf13, end
//crus end


    //
    // Account for vertical expansion on laptops
    //

//crus
    if (((HwDeviceExtension->ChipType &  CL754x)  ||
        (HwDeviceExtension->ChipType &  CL755x))  &&    //myf9, crus
        (ModeInformation->VisScreenWidth == 640) &&
        ((ModeInformation->BitsPerPlane == 8) ||
         (ModeInformation->BitsPerPlane == 16) ||
         (ModeInformation->BitsPerPlane == 24)) )
    {
        ModeInformation->DriverSpecificAttributeFlags
             |= CAPS_SW_POINTER;

        if (HwDeviceExtension->cursor_vert_exp_flag)
        {
            ModeInformation->DriverSpecificAttributeFlags
                |= CAPS_CURSOR_VERT_EXP;
        }

        //myf33 begin
        if (ModeInformation->DriverSpecificAttributeFlags & CAPS_TV_ON)
            ModeInformation->DriverSpecificAttributeFlags
                |= CAPS_SW_POINTER;
        //myf33 end

    }
//myf31 begin:3-12-97 755x expension on, HW cursor bug
    if ((HwDeviceExtension->ChipType & CL755x))
    {
        //myf33
        if (ModeInformation->DriverSpecificAttributeFlags & CAPS_TV_ON)
            ModeInformation->DriverSpecificAttributeFlags
                |= CAPS_SW_POINTER;
        //myf33 end

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
             CRTC_ADDRESS_PORT_COLOR, 0x82);

        HwDeviceExtension->cursor_vert_exp_flag =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                  CRTC_DATA_PORT_COLOR) & 0x60;

        if (HwDeviceExtension->cursor_vert_exp_flag)
        {
            ModeInformation->DriverSpecificAttributeFlags
                |= CAPS_SW_POINTER;

            ModeInformation->DriverSpecificAttributeFlags
                |= CAPS_CURSOR_VERT_EXP;
        }
    }
//myf31 end

    if ((ModeInformation->BitsPerPlane == 24) ||
        (ModeInformation->BitsPerPlane == 32)) {

        ModeInformation->NumberRedBits = 8;
        ModeInformation->NumberGreenBits = 8;
        ModeInformation->NumberBlueBits = 8;
        ModeInformation->RedMask = 0xff0000;
        ModeInformation->GreenMask = 0x00ff00;
        ModeInformation->BlueMask = 0x0000ff;

    } else if (ModeInformation->BitsPerPlane == 16) {

        ModeInformation->NumberRedBits = 6;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 6;
        ModeInformation->RedMask = 0x1F << 11;
        ModeInformation->GreenMask = 0x3F << 5;
        ModeInformation->BlueMask = 0x1F;

    } else {

        ModeInformation->NumberRedBits = 6;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 6;
        ModeInformation->RedMask = 0;
        ModeInformation->GreenMask = 0;
        ModeInformation->BlueMask = 0;
        ModeInformation->AttributeFlags |=
            VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;

    }

    //
    // Calculate the VideoMemoryBitmapWidth
    //

    {
        LONG x;

        x = ModeInformation->BitsPerPlane;

        if( x == 15 ) x = 16;

        ModeInformation->VideoMemoryBitmapWidth =
            (ModeInformation->ScreenStride * 8 ) / x;
    }

    ModeInformation->VideoMemoryBitmapHeight =
          HwDeviceExtension->AdapterMemorySize / ModeInformation->ScreenStride;
//crus begin
//myf15, begin
    if ((HwDeviceExtension->ChipType &  CL754x) ||
        (HwDeviceExtension->ChipType == CL6245) ||
        (HwDeviceExtension->ChipType &  CL755x))
         ModeInformation->VideoMemoryBitmapHeight =
                          (HwDeviceExtension->AdapterMemorySize - 0x4000) /
                                 ModeInformation->ScreenStride;
//myf15, end
//crus end

    return NO_ERROR;

} // end VgaQueryCurrentMode()


VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine zeros the first 256K on the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.


Return Value:

    None.

--*/
{
    UCHAR temp;

    //
    // Map font buffer at A0000
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

    //
    // Enable all planes.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
            IND_MAP_MASK);

    temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) | (UCHAR)0x0F;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
            temp);

    VideoPortZeroDeviceMemory(HwDeviceExtension->VideoMemoryAddress, 0xFFFF);

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

}


VOID
CirrusValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Determines which modes are valid and which are not.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    None.

--*/
{

    ULONG i;
    USHORT usChipIndex;
//  VideoDebugPrint((0, "Miniport - CirrusValidateMode\n")); //myfr

    switch (HwDeviceExtension->ChipType)
    {
        case CL6410: if (HwDeviceExtension->DisplayType == crt)
                     {
                         usChipIndex = pCL6410_crt;
                     }
                     else
                     {
                         usChipIndex = pCL6410_panel;
                     }
                     break;

        case CL6420: if (HwDeviceExtension->DisplayType == crt)
                     {
                         usChipIndex = pCL6420_crt;
                     }
                     else
                     {
                         usChipIndex = pCL6420_panel;
                     }
                     break;

// crus
        case CL6245:
        case CL542x: usChipIndex = pCL542x; break;

        case CL543x:
        case CL5434:
        case CL5434_6:
        case CL5436:
        case CL5446:
        case CL5446BE:
        case CL5480:
        case CL754x:
        case CL7541:
        case CL7543:
        case CL7542:
        case CL7548:
        case CL756x:
        case CL755x:
        case CL7555:
        case CL7556:
                     if (HwDeviceExtension->BoardType == NEC_ONBOARD_CIRRUS)
                     {
                         usChipIndex = pNEC_CL543x;
                     }
                     else
                     {
                         usChipIndex = pCL543x;
                     }
                     break;

        default:     usChipIndex = 0xffff; break;
    }

    HwDeviceExtension->NumAvailableModes = 0;

    VideoDebugPrint((2, "Checking for available modes:\n"));

    VideoDebugPrint((2, "\tMemory Size = %x\n"
                        "\tChipType = %x\n"
                        "\tDisplayType = %x\n",
                        HwDeviceExtension->AdapterMemorySize,
                        HwDeviceExtension->ChipType,
                        HwDeviceExtension->DisplayType));

    for (i = 0; i < NumVideoModes; i++) {

        //
        // The SpeedStarPRO does not support refresh rates.
        // we must return hardware default for all of the modes.
        // clean out the mode tables of duplicates ...
        //

        if (HwDeviceExtension->BoardType == SPEEDSTARPRO)
        {
            ModesVGA[i].Frequency = 1;
            ModesVGA[i].Interlaced = 0;

            if (i &&
                (ModesVGA[i].numPlanes == ModesVGA[i-1].numPlanes) &&
                (ModesVGA[i].bitsPerPlane == ModesVGA[i-1].bitsPerPlane) &&
                (ModesVGA[i].hres == ModesVGA[i-1].hres) &&
                (ModesVGA[i].vres == ModesVGA[i-1].vres))
            {
                //
                // duplicate mode - skip it.
                //

                continue;

            }
        }

        VideoDebugPrint((2, "Mode #%ld %dx%d at %d bpp\n"
                            "\tAdapterMemoryRequired: %x\n"
                            "\tChipType:              %x\n"
                            "\tDisplayType:           %x\n",
                            i, ModesVGA[i].hres, ModesVGA[i].vres,
                            ModesVGA[i].bitsPerPlane * ModesVGA[i].numPlanes,
                            ModesVGA[i].numPlanes * ModesVGA[i].sbytes,
                            ModesVGA[i].ChipType,
                            ModesVGA[i].DisplayType));

        if ( (HwDeviceExtension->AdapterMemorySize >=
              ModesVGA[i].numPlanes * ModesVGA[i].sbytes) &&
             (HwDeviceExtension->ChipType & ModesVGA[i].ChipType) &&
             (HwDeviceExtension->DisplayType & ModesVGA[i].DisplayType) &&
// crus
             (!(HwDeviceExtension->ChipType &  CL754x) &&
              !(HwDeviceExtension->ChipType & CL755x) &&
              (HwDeviceExtension->ChipType != CL6245) &&
              (HwDeviceExtension->ChipType != CL756x)) &&
// end crus
             CheckDDC2BMonitor(HwDeviceExtension, i) &&
             ((ModesVGA[i].bitsPerPlane * ModesVGA[i].numPlanes == 24)
               ? VgaAccessRange[3].RangeLength : TRUE))
        {
            ModesVGA[i].ValidMode = TRUE;
            HwDeviceExtension->NumAvailableModes++;

            VideoDebugPrint((2, "This mode is valid.\n"));
        }

        // check if panel type is DSTN panel, must be used 128K frame buffer
        // for Half-Frame Accelerator
// crus
#if 1
        else if ((HwDeviceExtension->AdapterMemorySize >=
                  ModesVGA[i].numPlanes * ModesVGA[i].sbytes) &&
                 ((HwDeviceExtension->ChipType &  CL754x) ||
                 (HwDeviceExtension->ChipType &  CL755x) ||
                 (HwDeviceExtension->ChipType == CL6245) ||
                 (HwDeviceExtension->ChipType == CL756x)) &&
                 (HwDeviceExtension->ChipType & ModesVGA[i].ChipType) &&
                 (HwDeviceExtension->DisplayType & ModesVGA[i].DisplayType) &&
                 ((ModesVGA[i].bitsPerPlane * ModesVGA[i].numPlanes == 24)
                       ? VgaAccessRange[3].RangeLength : TRUE))
        {
        //DSTN panel must be turn on
           if ((((HwDeviceExtension->DisplayType & ScreenType)==DSTN10) ||
                ((HwDeviceExtension->DisplayType & ScreenType)==DSTN8 ) ||
                ((HwDeviceExtension->DisplayType & ScreenType)==DSTN6 )) &&
               ((LONG)HwDeviceExtension->AdapterMemorySize >=
               (LONG)((ModesVGA[i].wbytes * ModesVGA[i].vres) +0x24000)) )
           {

//myf27, begin
               if ((HwDeviceExtension->DisplayType & PanelType) &&
                   (ModesVGA[i].DisplayType & PanelType) &&
                   (HwDeviceExtension->ChipType &  CL754x) &&
                   (ModesVGA[i].bitsPerPlane >= 16) &&
                   (ModesVGA[i].hres > 640) &&
                   ((HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                   (((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType)
                     - crt) >= panel8x6))
               {
                   ModesVGA[i].ValidMode = FALSE;
            VideoDebugPrint((1, "***This mode is not valid.***\n"));
               }
               else if ((HwDeviceExtension->DisplayType & PanelType) &&
                   (ModesVGA[i].DisplayType & PanelType) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                   (HwDeviceExtension->ChipType &  CL754x) &&         //myf27
                   (ModesVGA[i].bitsPerPlane >= 16) &&
//                 (ModesVGA[i].hres > 640) &&
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType)
                      >= panel8x6))
               {
                   ModesVGA[i].ValidMode = FALSE;
            VideoDebugPrint((1, "This mode is valid.\n"));
               }
//myf27, end
//myf32 begin :fixed DSTN XGA panel not supported 24bpp mode
               else if ((HwDeviceExtension->DisplayType & PanelType) &&
                   (ModesVGA[i].DisplayType & PanelType) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                   (HwDeviceExtension->ChipType & CL755x) &&         //myf27
                   (ModesVGA[i].bitsPerPlane >= 24) &&
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType)
                      >= panel10x7))
               {
                   ModesVGA[i].ValidMode = FALSE;
            VideoDebugPrint((1, "This mode is valid.\n"));
               }
//myf32 end

               else if ((HwDeviceExtension->DisplayType & PanelType) &&
                   (ModesVGA[i].DisplayType & PanelType) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) &&  //myf27
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType) >= panel))
               {
                   ModesVGA[i].ValidMode = TRUE ;
                   HwDeviceExtension->NumAvailableModes++ ;
            VideoDebugPrint((1, "This mode is valid.\n"));
               }
//myf7, begin
//myf7         else if (!(HwDeviceExtension->DisplayType & PanelType))
               else if ((HwDeviceExtension->DisplayType & crt) &&
                        (HwDeviceExtension->DisplayType & Jump_type) )//myf27
                {
                    ModesVGA[i].ValidMode = TRUE ;
                    HwDeviceExtension->NumAvailableModes++ ;
            VideoDebugPrint((1, "This mode is valid.\n"));
                }
//myf7, end
//crus end
           }
           else if (((HwDeviceExtension->DisplayType & ScreenType)!=DSTN10) &&
                    ((HwDeviceExtension->DisplayType & ScreenType)!=DSTN8) &&
                    ((HwDeviceExtension->DisplayType & ScreenType)!=DSTN6) &&
                    ((LONG)HwDeviceExtension->AdapterMemorySize >=
                     (LONG)((ModesVGA[i].wbytes * ModesVGA[i].vres))))
           {

//myf27, begin
               if ((HwDeviceExtension->DisplayType & (panel10x7 | TFT_LCD)) &&
                   (ModesVGA[i].DisplayType & panel10x7) &&
                   (HwDeviceExtension->ChipType &  CL754x) &&
                   (ModesVGA[i].bitsPerPlane >= 16) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType)
                      >= panel10x7))
               {
                   ModesVGA[i].ValidMode = FALSE;
            VideoDebugPrint((1, "===This mode is not valid.===\n"));
               }
/*
               else if ((HwDeviceExtension->DisplayType &
                           (panel10x7 | TFT_LCD)) &&
                   (ModesVGA[i].DisplayType & panel10x7) &&
                   (HwDeviceExtension->ChipType &  CL754x) &&
                   (ModesVGA[i].bitsPerPlane >= 16) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) &&
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType)
                      >= panel10x7))
               {
                   ModesVGA[i].ValidMode = FALSE;
            VideoDebugPrint((1, "===This mode is not valid.===\n"));
               }
*/
//myf27, end
               else if ((HwDeviceExtension->DisplayType & PanelType) &&
                        (ModesVGA[i].DisplayType & PanelType) &&
                   (!(HwDeviceExtension->DisplayType & Jump_type)) && //myf27
                   ((ModesVGA[i].DisplayType & HwDeviceExtension->DisplayType) >= panel) )
               {
                   ModesVGA[i].ValidMode = TRUE ;
                   HwDeviceExtension->NumAvailableModes++ ;
            VideoDebugPrint((1, "This mode is valid.\n"));
               }
//myf7, this is fixed crt only can't display exclude 60Hz refresh rate
//myf7         else if (!(HwDeviceExtension->DisplayType & PanelType))
               else if ((HwDeviceExtension->DisplayType & crt) && //myf7
                        (HwDeviceExtension->DisplayType & Jump_type) )//myf27
                {
                    ModesVGA[i].ValidMode = TRUE ;
                    HwDeviceExtension->NumAvailableModes++ ;
            VideoDebugPrint((1, "This mode is valid.\n"));
                }
           }

        }
#endif
// end crus

        else
        {
            VideoDebugPrint((1, "This mode is not valid.\n"));  //2
        }

#if 0
        if (HwDeviceExtension->ChipRevision == 0x3A) {
            if (((ModesVGA[i].numPlanes * ModesVGA[i].sbytes) <= 0x200000) &&
                 (HwDeviceExtension->DisplayType & ModesVGA[i].DisplayType)) {
                if (CheckDDC2B(HwDeviceExtension, i)) {
                    ModesVGA[i].ValidMode = TRUE ;
                     HwDeviceExtension->NumAvailableModes++ ;
                    continue ;
                }
            }
        }
#endif

/*  jl02
        if (CheckGD5446Rev(HwDeviceExtension)) {

            // Block 1152x864, 16-bpp
            if ((ModesVGA[i].hres == 1152) &&
                (ModesVGA[i].vres == 864) &&
                (ModesVGA[i].bitsPerPlane == 16))
            {
                continue ;
            }

        }
*/

    }

#if 0           //myf28
//myf27, begin
    if ((HwDeviceExtension->DisplayType & Jump_type) &&
        ((HwDeviceExtension->ChipType &  CL754x) ||
         (HwDeviceExtension->ChipType &  CL755x) ||
//       (HwDeviceExtension->ChipType == CL6245) ||
         (HwDeviceExtension->ChipType == CL756x)))
         HwDeviceExtension->DisplayType &= crt;
//myf27, end
#endif          //myf28

    VideoDebugPrint((1, "NumAvailableModes = %ld\n",
                         HwDeviceExtension->NumAvailableModes));        //2
}

ULONG
GetAttributeFlags(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine determines whether or not the detected
    cirrus chip supports Blt's.

    NOTE: This device should not be called until after
          CirrusLogicIsPresent has been called.

Arguments:

    HwDeviceExtension - Pointer to the device extension.

Return Value:

    TRUE - If the device supports Blt's
    FALSE - otherwise

--*/

{
    ULONG ChipId   = HwDeviceExtension->ChipRevision;
    ULONG ChipType = HwDeviceExtension->ChipType;
    ULONG ulFlags  = 0;

    //
    // Check for BLT support
    //
    // All 543x & 754x/755x/756x do BLTs
    //
//myfr  VideoDebugPrint((0, "Miniport - VgaAttributeFlags\n"));

    if ((ChipType == CL543x) || (ChipType &  CL754x) ||
        (ChipType &  CL755x) || (ChipType == CL756x))
    {
        ulFlags |= CAPS_BLT_SUPPORT;

    }
    else if ((ChipType == CL542x) &&      // 5426-5429 have BLT engines
             (ChipId >= 0x26) ||          // 26 is CL5428
             (ChipId == 0x24) )           // 24 is CL5426
    {
        ulFlags |= CAPS_BLT_SUPPORT;
    }
// crus
    else if (ChipType == CL6245)
    {
        ulFlags &= ~CAPS_BLT_SUPPORT;
    }
// end crus

    //
    // Check for true color support
    //

    if ((ChipType == CL543x) || (ChipType &  CL755x) || (ChipType == CL756x))
    {
        ulFlags |= CAPS_TRUE_COLOR;

// crus
// Added CL-GD7555 for direct draw support.//tao1
//      if ((ChipType &  CL755x))
//      {
//         ulFlags |= CAPS_IS_7555;
//      }
// end crus

// crus
// Set CL-GD5436, CL-GD54UM36 and CL-GD5446 for autostart routine
// in display driver
//tso   else if (HwDeviceExtension->AutoFeature)
        if (HwDeviceExtension->AutoFeature)
        {
           //ulFlags |= CAPS_AUTOSTART;
           ulFlags |= CAPS_ENGINEMANAGED;
        }

// D5480 chu01
// chu04: GAMMACORRECT
        //
        // Specify BLT enhancement flag for later use.
        //
        if (HwDeviceExtension->BitBLTEnhance)
            ulFlags |= ( CAPS_COMMAND_LIST | CAPS_GAMMA_CORRECT) ;
//myf29
        if (ChipType &  CL755x)
           ulFlags |= CAPS_GAMMA_CORRECT;

    }

    //
    // don't do host transfer and avoid hardware problem on fast machines
    //

    ulFlags |= CAPS_NO_HOST_XFER;

    //
    // Can't do host transfers on ISA 5434s
    //

    if ((HwDeviceExtension->BusType == Isa) &&
        (ChipType == CL543x))
    {
        ulFlags |= CAPS_NO_HOST_XFER;
    }

    //
    // Is this a 542x
    //

    if (ChipType == CL542x)
    {
        ulFlags |= CAPS_IS_542x;

        if (ChipId == CL5429_ID)
        {
            //
            // Some 5429s have a problem doing host transfers.
            //

            ulFlags |= CAPS_NO_HOST_XFER;
        }

        //
        // 5428's have problems with HOST_TRANSFERS on MicroChannel bus.
        //

        if ((HwDeviceExtension->BusType == MicroChannel) &&
            (ChipId == CL5428_ID))
        {
            //
            // this is a 5428.  We've noticed that some of these have mono
            // expand problems on MCA IBM machines.
            //

            ulFlags |= CAPS_NO_HOST_XFER;
        }
    }

    //
    // The display driver needs to know if a Dual STN panel is
    // in use, so that it can reserve part of the frame buffer for
    // the half frame accelerator.
    //
    // Unfortunately we have found at least one machine with a DSTN
    // panel that reports itself as having a TFT panel. (Dell Latitude
    // XPi 90D).  Therefore, we will have to reserve the space for
    // any machine with a LCD panel!
    //

//crus begin
//myf10
        if ((ChipType &  CL755x) || (ChipType &  CL754x))
        {
            ulFlags |= GetPanelFlags(HwDeviceExtension);
        }
//crus end

    //
    // The cirrus 543x chips don't support transparency.
    //

    ulFlags |= CAPS_TRANSPARENCY;

    if ((ChipType & CL543x) &&
        (ChipType != CL5446) &&
        (ChipType != CL5446BE) &&
        (ChipType != CL5480))
    {
        ulFlags &= ~CAPS_TRANSPARENCY;
    }

    return ulFlags;
}


BOOLEAN
CheckDDC2B(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG i
    )

/*++

Routine Description:
    Determines if refresh rate support according to DDC2B standard.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:
    None.

--*/
{

    VideoDebugPrint((1, "Miniport -- CheckDDC2B\n"));       //2
    VideoDebugPrint((2, "refresh rate   = %ld\n", ModesVGA[i].Frequency));
    VideoDebugPrint((2, "hres           = %d\n", ModesVGA[i].hres));
    VideoDebugPrint((2, "vres           = %d\n", ModesVGA[i].vres));
    VideoDebugPrint((2, "EDIDTiming_I   = %d\n", EDIDTiming_I));
    VideoDebugPrint((2, "EDIDTiming_II  = %d\n", EDIDTiming_II));
    VideoDebugPrint((2, "EDIDTiming_III = %d\n", EDIDTiming_III));


    if (!DDC2BFlag)
        return TRUE ;

    if (ModesVGA[i].Frequency == 85) {

       if (ModesVGA[i].vres == 1200) {  // 1600x1200

//        if (!(EDIDTiming_III & 0x02))
//            return FALSE ;
          ;

       } else if (ModesVGA[i].vres == 1024) {  // 1280x1024

//        if (!(EDIDTiming_III & 0x10))
//            return FALSE ;
          ;

       } else if (ModesVGA[i].vres == 864) {  // 1152x864

          ;

       } else if (ModesVGA[i].vres == 768) {  // 1024x768

//        if (!(EDIDTiming_III & 0x08))
//            return FALSE ;
          ;

       } else if (ModesVGA[i].vres == 600) {  // 800x600

//        if (!(EDIDTiming_III & 0x20))
//            return FALSE ;
          ;

       } else if (ModesVGA[i].vres == 480) {  // 640x480

//        if (!(EDIDTiming_III & 0x40))
//            return FALSE ;
          ;

       }


    } else if (ModesVGA[i].Frequency == 75) {

       if (ModesVGA[i].vres == 1200) {  // 1600x1200

//        if (!(EDIDTiming_III & 0x04))
//            return FALSE ;
          ;

       } else if (ModesVGA[i].vres == 1024) {  // 1280x1024

          if (!(EDIDTiming_II & 0x01))
              return FALSE ;

       } else if (ModesVGA[i].vres == 864) {  // 1152x864

          if (!(EDIDTiming_III & 0x80))
              return FALSE ;

       } else if (ModesVGA[i].vres == 768) {  // 1024x768

          if (!(EDIDTiming_II & 0x02))
              return FALSE ;

       } else if (ModesVGA[i].vres == 600) {  // 800x600

          if (!(EDIDTiming_II & 0x40))
              return FALSE ;

       } else if (ModesVGA[i].vres == 480) {  // 640x480

          if (!(EDIDTiming_I & 0x04))
              return FALSE ;

       }

    } else if (ModesVGA[i].Frequency == 72) {

       if (ModesVGA[i].vres == 600) {  // 800x600

          if (!(EDIDTiming_II & 0x80))
              return FALSE ;

       } else if (ModesVGA[i].vres == 480) {  // 640x480

          if (!(EDIDTiming_I & 0x08))
              return FALSE ;

       }

    } else if (ModesVGA[i].Frequency == 70) {

       if (ModesVGA[i].vres == 768) {  // 1024x768

          if (!(EDIDTiming_II & 0x04))
              return FALSE ;

       }

    } else if (ModesVGA[i].Frequency == 60) {

       if (ModesVGA[i].vres == 768) {  // 1024x768

          if (!(EDIDTiming_II & 0x08))
              return FALSE ;

       } else if (ModesVGA[i].vres == 600) {  // 800x600

          if (!(EDIDTiming_I & 0x01))
              return FALSE ;

       }

    } else if (ModesVGA[i].Frequency == 56) {

       if (ModesVGA[i].vres == 600) {  // 800x600

          if (!(EDIDTiming_I & 0x02))
              return FALSE ;

       }
    }

    return TRUE ;

} // end CheckDDC2B ()



VOID
AdjFastPgMdOperOnCL5424(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEOMODE pRequestedMode
    )

/*++

Routine Description:
    Undesired bars happen on CL5424 800x600x16 color, 512Kb, 56, 60 and 72 Hz
    Compaq Prosignia 300 machine.  This can be solved by setting SRF(6) to 1.
    This bit restricts the write buffer to one level, disabling fast page
    mode operation;  The faulty control logic is therefore disabled.  The
    downside is that the performance will take a hit, since we are dealing
    with a 5424, so we make a slow chip slower.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.
    pRequestedMode

Return Value:
    None.

--*/
{

    UCHAR uc, chipId ;


    /*---  CL5424 : ID = 100101xx  ---*/

    chipId = GetCirrusChipId(HwDeviceExtension) ;                    // chu08
    if (chipId != 0x94)
        return ;


    /*---  800x600x16 color, 60 or 72 Hz  ---*/

    if (pRequestedMode->hres != 800)
        return ;

    if (pRequestedMode->vres != 600)
        return ;

    if (pRequestedMode->bitsPerPlane != 1)
        return ;

         if (!((pRequestedMode->Frequency == 56) ||
               (pRequestedMode->Frequency == 60) ||
               (pRequestedMode->Frequency == 72)))
        return ;


    /*---  512k  ---*/
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT, 0x0A) ;
    uc = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT) ;
    if ((uc & 0x38) != 0x08)
        return ;


    /*---  SRF(6)=1 --- */
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            SEQ_ADDRESS_PORT, 0x0F) ;
    uc = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                SEQ_DATA_PORT) ;
    uc &= 0xBF ;
    uc |= 0x40 ;
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                            SEQ_DATA_PORT, uc) ;


} // end AdjFastPgMdOperOnCL5424 ()



// crus
BOOLEAN
CheckGD5446Rev(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:
    Check if it is CL-GD5446

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:
    FALSE : It isn't CL-GD5446
    TRUE  : It is    CL-GD5446
--*/
{

    UCHAR chipId ;

    //
    // Get Chip ID
    //
    chipId = GetCirrusChipId(HwDeviceExtension) ;                    // chu08


    // For CL-GD5446, Chip ID = 101110xx

    if (chipId != 0xB8)
        return FALSE ;
    else
        return TRUE ;

} // end CheckGD5446Rev ()


#if (_WIN32_WINNT <= 0x0400)
#pragma message("NOTICE: We want to remove DDC update code before 5.0 ships")

VOID CheckAndUpdateDDC2BMonitor(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )
{
    NTSTATUS        ntStatus;
    UNICODE_STRING  paramPath;
    ULONG           i;
    BOOLEAN         bRefreshChanged;
#if (_WIN32_WINNT < 0x0400)
    WCHAR   KeyString[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Cl54xx35\\Device0";
#else
    WCHAR   KeyString[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Hardware Profiles\\Current\\System\\CurrentControlSet\\Services\\cirrus\\Device0";
#endif
    RTL_QUERY_REGISTRY_TABLE    paramTable[5];
    ULONG                       ulZero = 0;
    ULONG                       ulBitsPerPel = 8;
    ULONG                       ulVRefresh   = 60;
    ULONG                       ulXResolution= 640;
    ULONG                       ulYResolution= 480;

    //
    // Update the Monitor.Type Valuename
    //
    // sge02
    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"Monitor.Type",
                                   &DDC2BFlag,
                                   sizeof(BOOLEAN));
    //
    // First check whether it is a DDC2B monitor
    //

    if(!DDC2BFlag)
        return;

    //
    // Query the registry about the Manufacture and Product ID
    //

    if (NO_ERROR == VideoPortGetRegistryParameters(hwDeviceExtension,
                                                   L"Monitor.ID",
                                                   FALSE,
                                                   CirrusDDC2BRegistryCallback,
                                                   NULL))
    {
        //
        // Same DDC2B Monitor, do nothing
        //
    }
    else
    {
        //
        // Set the Manufacture of the Monitor.
        //

        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"Monitor.ID",
                                       &EDIDBuffer[8],
                                       sizeof(ULONG));
        //
        // Set the EDID data of the Monitor.
        //
        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"Monitor.Data",
                                       EDIDBuffer,
                                       128);

        //
        // Change to the highest refresh rate for the new
        // DDC2B monitor.
        //

        paramPath.MaximumLength = sizeof(KeyString);
        paramPath.Buffer = KeyString;

        //
        // We use this to query into the registry as to whether we
        // should break at driver entry.
        //


        VideoPortZeroMemory(&paramTable[0], sizeof(paramTable));

        paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name          = L"DefaultSettings.BitsPerPel";
        paramTable[0].EntryContext  = &ulBitsPerPel;
        paramTable[0].DefaultType   = REG_DWORD;
        paramTable[0].DefaultData   = &ulZero;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name          = L"DefaultSettings.VRefresh";
        paramTable[1].EntryContext  = &ulVRefresh;
        paramTable[1].DefaultType   = REG_DWORD;
        paramTable[1].DefaultData   = &ulZero;
        paramTable[1].DefaultLength = sizeof(ULONG);

        paramTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[2].Name          = L"DefaultSettings.XResolution";
        paramTable[2].EntryContext  = &ulXResolution;
        paramTable[2].DefaultType   = REG_DWORD;
        paramTable[2].DefaultData   = &ulZero;
        paramTable[2].DefaultLength = sizeof(ULONG);

        paramTable[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[3].Name          = L"DefaultSettings.YResolution";
        paramTable[3].EntryContext  = &ulYResolution;
        paramTable[3].DefaultType   = REG_DWORD;
        paramTable[3].DefaultData   = &ulZero;
        paramTable[3].DefaultLength = sizeof(ULONG);

        if (NT_SUCCESS(RtlQueryRegistryValues(
            RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
            paramPath.Buffer, &paramTable[0], NULL, NULL)))
        {
            bRefreshChanged = FALSE;
            //
            // Get the highest refresh rate from the mode
            //
            for (i = 0; i < NumVideoModes; i++)
            {
                if (ModesVGA[i].ValidMode &&
                    (ModesVGA[i].hres == ulXResolution) &&
                    (ModesVGA[i].vres == ulYResolution) &&
                    (ModesVGA[i].numPlanes == 1 ) &&
                    (ModesVGA[i].bitsPerPlane == ulBitsPerPel))
                {
                    if(ulVRefresh < ModesVGA[i].Frequency)
                        ulVRefresh = ModesVGA[i].Frequency;
                    bRefreshChanged = TRUE;
                }
            }
            //
            // Write to the registry
            //
            if (bRefreshChanged)
                RtlWriteRegistryValue(
                    RTL_REGISTRY_ABSOLUTE,
                    paramPath.Buffer,
                    L"DefaultSettings.VRefresh",
                    REG_DWORD,
                    &ulVRefresh,
                    sizeof(ULONG)
                    );
        }
    }

}
#endif // (_WIN32_WINNT <= 0x0400)

//
// chu08
//
UCHAR
GetCirrusChipId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:
    Get Cirrus Logic chip identifying value.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:
    Cirrus Logic chip ID.

--*/
{
    UCHAR  chipId ;

    VideoDebugPrint((4, "GetCirrusChipId\n")) ;

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR, 0x27) ;
        chipId = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_DATA_PORT_COLOR) ;
    } else {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_MONO, 0x27) ;
        chipId = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_DATA_PORT_MONO) ;
    }
    chipId &= 0xFC ;

    return chipId ;

} // end GetCirrusChipId




//
// chu08
//
USHORT
GetCirrusChipRevisionId(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:
    Get Cirrus Logic chip revision identifying value.

Arguments:
    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    e.g.,    Rev AB = xxxx xx00 0010 0010
             Rev AC = xxxx xx00 0010 0011

    Cirrus Logic chip revision ID.

--*/
{
    UCHAR  chipId, chipRevision ;
    USHORT chipRevisionId = 0   ;

    VideoDebugPrint((4, "GetCirrusChipRevisionId\n")) ;

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        MISC_OUTPUT_REG_READ_PORT) & 0x01)
    {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR, 0x27) ;
        chipId = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_DATA_PORT_COLOR) ;
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR, 0x25) ;
        chipRevision = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                              CRTC_DATA_PORT_COLOR) ;
    } else {
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_MONO, 0x27) ;
        chipId = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                        CRTC_DATA_PORT_MONO) ;
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_MONO, 0x25) ;
        chipRevision = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                              CRTC_DATA_PORT_MONO) ;
    }

    //
    // Chip revision
    //

    chipRevisionId += (chipId & 0x03) ;
    chipRevisionId <<= 8              ;
    chipRevisionId += chipRevision    ;

    return chipRevisionId ;


} // end GetCirrusChipRevisionId
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\sr754x.h ===
#define CL754x_NUM_VSHADOW              6
#define CL754x_NUM_YSHADOW              5
#define CL754x_NUM_ZSHADOW              5
#define CL754x_NUM_XSHADOW              12

#define CL754x_CRTC_EXT_START           0x19
#define CL754x_CRTC_EXT_END             0x30
#define CL754x_NUM_CRTC_EXT_PORTS (CL754x_CRTC_EXT_END-CL754x_CRTC_EXT_START+1)

#define CL754x_HRZ_TIME_START           0x40
#define CL754x_HRZ_TIME_END             0x4F
#define CL754x_NUM_HRZ_TIME_PORTS (CL754x_HRZ_TIME_END-CL754x_HRZ_TIME_START+1)

//
// 
typedef struct _NORDIC_REG_SAVE_BUF
{
   USHORT saveVshadow[CL754x_NUM_VSHADOW];
   USHORT saveCrtcExts[CL754x_NUM_CRTC_EXT_PORTS];
   USHORT saveHrzTime[CL754x_NUM_HRZ_TIME_PORTS];
   USHORT saveYshadow[CL754x_NUM_YSHADOW];
   USHORT saveZshadow[CL754x_NUM_ZSHADOW];
   USHORT saveXshadow[CL754x_NUM_XSHADOW];
} NORDIC_REG_SAVE_BUF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\mode543x.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Mode543x.h

Abstract:

    This module contains all the global data used by the Cirrus Logic
   CL-542x driver.

Environment:

    Kernel mode

Revision History:

--*/

//
// The next set of tables are for the CL543x
// Note: all resolutions supported
//

//
// 640x480 16-color mode (BIOS mode 12) set command string for CL 543x.
//

USHORT CL543x_640x480_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in 640x480 mode

    EOD
};

//
// 800x600 16-color (60Hz refresh) mode set command string for CL 543x.
//

USHORT CL543x_800x600_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in 800x600 mode

    EOD
};

//
// 1024x768 16-color (60Hz refresh) mode set command string for CL 543x.
//

USHORT CL543x_1024x768_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,


    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//-----------------------------
// standard VGA text modes here
// 80x25 at 640x350
//
//-----------------------------

//
// 80x25 text mode set command string for CL 543x.
// (720x400 pixel resolution; 9x16 character cell.)
//

USHORT CL543x_80x25Text[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,      // no banking in text mode

    EOD
};

//
// 80x25 text mode set command string for CL 543x.
// (640x350 pixel resolution; 8x14 character cell.)
//

USHORT CL543x_80x25_14_Text[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x000b,         // no banking in text mode

    EOD
};

//
// 1280x1024 16-color mode (BIOS mode 0x6C) set command string for CL 543x.
//

USHORT CL543x_1280x1024_16[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    EOD
};

//
// 640x480 256-color mode (BIOS mode 0x5F) set command string for CL 543x.
//

USHORT CL543x_640x480_256[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    EOD
};

//
// 800x600 256-color mode (BIOS mode 0x5C) set command string for CL 543x.
//

USHORT CL543x_800x600_256[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    EOD
};

//
// 640x480 64k-color mode (BIOS mode 0x64) set command string for CL 543x.
//

USHORT CL543x_640x480_64k[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    4,
    0x0506,                         // Some BIOS's set Chain Odd maps bit
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    EOD
};

//
// 800x600 64k-color mode (BIOS mode 0x65) set command string for CL 543x.
//

USHORT CL543x_800x600_64k[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    4,
    0x0506,                         // Some BIOS's set Chain Odd maps bit
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    EOD
};

//
// 1024x768 64k-color mode set command string for CL 543x.
//

USHORT CL543x_1024x768_64k[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,


    OWM,
    GRAPH_ADDRESS_PORT,
    4,
    0x0506,                         // some BIOS's set Chain Odd Maps bit
#if ONE_64K_BANK
    0x0009, 0x000a, 0x200b,
#endif
#if TWO_32K_BANKS
    0x0009, 0x000a, 0x210b,
#endif

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};

//
// 640x480 16M-color mode (BIOS mode 0x64) set command string for CL 543x.
//

USHORT CL543x_640x480_16M[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x200b,

    EOD                   
};

//
// 800x600 16M-color mode (BIOS mode 0x65) set command string for CL 543x.
//

USHORT CL543x_800x600_16M[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x200b,

    EOD                   
};

//
// 1024x768 16M-color mode set command string for CL 543x.
//

USHORT CL543x_1024x768_16M[] = {
    OWM,                            // begin setmode
    SEQ_ADDRESS_PORT,
    2,                             // count
    0x1206,                         // enable extensions
    0x0012,


    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0009, 0x000a, 0x200b,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    EOD
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\i386\clcursor.asm ===
title  "Cirrus hardware pointer routines"

;-----------------------------Module-Header-----------------------------;
; Module Name:  CLCURSOR.ASM
;
; This file contains the pointer shape routines to support the Cirrus
; Logic hardware pointer.
;
; Copyright (c) 1983-1992 Microsoft Corporation
;
;-----------------------------------------------------------------------;

        .386p
        .model  small,c

        include i386\egavga.inc
        include i386\clvga.inc
        include callconv.inc

; Mirrors structure in Cirrus.H.

HW_POINTER_SHIFT_INFO struc
ulXShift        dd      ?
ulYShift        dd      ?
ulShiftedFlag   dd      ?
HW_POINTER_SHIFT_INFO ends

        .code

page
;--------------------------Public-Routine-------------------------------;
; draw_pointer
;
;   Draw a cursor based at (ulVptlX,ulVptlY) (upper left corner).
;
;   The currently defined cursor/icon is drawn.  If the old
;   cursor/icon is currently on the screen, it is removed.
;
; Note: restores all standard VGA registers used to original state.
;
; Entry:
;       Passed parameters on stack:
;               (vptlX,vptlY) = location to which to move pointer
;               pointerLoadAddress -> virtual address of Cirrus display memory into
;                       which to load pointer masks
;               pointerLoadAddress -> Cirrus bank into which to load pointer masks
; Returns:
;       None
; Error Returns:
;       None
; Registers Preserved:
;       EBX,ESI,EDI,EBP,DS,ES
; Registers Destroyed:
;       EAX,ECX,EDX,flags
; Calls:
;       load_cursor
;-----------------------------------------------------------------------;

cPublicProc CirrusDrawPointer,6,<   \
        uses esi edi ebx,       \
        lVptlX:         dword,  \
        lVptlY:         dword,  \
        pVideoMem:      dword,  \
        pLoadAddress:   dword,  \
        pAndMask:       ptr,    \
        pShiftInfo:     ptr     >

	local	SavedSeqMode :byte
	local	SavedProA    :byte
	local	SavedExtReg  :byte
	local	SaveGRFIndex :byte
	local	SaveEnableSR :byte
	local	SaveMapMask  :byte
	local	SaveSetReset :byte
	local	SaveGR5      :byte
        local   SaveGR3      :byte
        local   SaveSR7      :byte

; Save the state of the banking and set the read and write banks to access the
; pointer bitmap.

        mov     edx,EGA_BASE + SEQ_ADDR
	cli
        mov     al,SEQ_MODE
        out     dx,al
        inc     dx
        in      al,dx
        mov     SavedSeqMode,al
        or      al,SM_CHAIN4
        out     dx,al
        dec     dx
	mov	al,SEQ_MAP_MASK
	out	dx,al
	inc	dx
	in	al,dx
	mov	SaveMapMask,al				;8 bit map mask

        mov     edx,EGA_BASE + GRAF_ADDR
	in	al,dx					;Read graphics index reg
	mov	SaveGRFIndex,al				;save it

	mov	al,AVGA_PROA
	out	dx,al					;Set for OFFSET 0 reg
	inc	dx
	in	al,dx
	mov	SavedProA,al				;Save OFFSET 0 reg
	dec	dx

	mov	al,AVGA_MODE_EXTENSIONS
	out	dx,al					;Set for extensions reg
	inc	dx
	in	al,dx
	sti
	dec	dx
	mov	SavedExtReg,al				;Save extensions

	test	al,1110b				;Are extensionsETC enabled?
	jz	@F					;no...

	cli
	mov	al,GRAF_ENAB_SR
	out	dx,al
	inc	dx
	in	al,dx
	mov	SaveEnableSR,al				;8 bit enable set reset
	mov	al,0
	out	dx,al					;set to 0!
	dec	dx

	mov	al,GRAF_SET_RESET
	out	dx,al
	inc	dx
	in	al,dx
	mov	SaveSetReset,al				;8 bit set reset

        mov     edx,EGA_BASE + SEQ_ADDR
;??do we need this
	mov	al,0FFh
	out	dx,al

        mov     edx,EGA_BASE + GRAF_ADDR
	mov	al,GRAF_MODE
	out	dx,al
	inc	dx
	in	al,dx					;save VGA mode
	mov	SaveGR5,al
	mov	al,01000000b
	out	dx,al
	dec	dx
        mov     al,GRAF_DATA_ROT
        out     dx,al
        inc     dx
        in      al,dx
        mov     SaveGR3,al
        mov     al,0
        out     dx,al
        dec     dx
	sti
@@:
        mov     eax,pLoadAddress        ; calculate bank from pointer pat addr
        shr     eax,6                   ; ah = bank to select
@@:
        mov     al,AVGA_PROA            ; al = bank select register
        out     dx,ax
	mov	ax,EXT_WR_MODES shl 8 + AVGA_MODE_EXTENSIONS
	out	dx,ax					;packed pel mode

; See if the masks need to be shifted; if they do, shift and
; load them. If the default masks can be used but the last masks
; loaded were shifted, load the default masks.

        mov     eax,lVptlX
        mov     ebx,lVptlY
        mov     ecx,ebx
        or      ecx,eax                 ;is either coordinate negative?
        jns     draw_cursor_unshifted   ;no-make sure the unshifted masks
                                        ; are loaded
                                        ;yes-make sure the right shift
                                        ; pattern is loaded

;  Determine the extent of the needed adjustment to the masks.

; If X is positive, no X shift is needed; if it is negative,
; then its absolute value is the X shift amount.

        and     eax,eax
        jns     short dcs_p1
        neg     eax                     ;required X shift
        jmp     short dcs_p2

        align   4
dcs_p1:
        sub     eax,eax                 ;no X shift required
dcs_p2:

; If Y is positive, no Y shift is needed; if it is negative,
; then its absolute value is the Y shift amount.

        and     ebx,ebx
        jns     short dcs_p3
        neg     ebx                     ;required Y shift
        jmp     short dcs_p4

        align   4
dcs_p3:
        sub     ebx,ebx
dcs_p4:
        cmp     ebx,PTR_HEIGHT          ;keep Y in the range 1-PTR_HEIGHT
        jbe     short ck_x_overflow
        mov     ebx,PTR_HEIGHT
ck_x_overflow:
        cmp     eax,(PTR_WIDTH * 8)     ;keep X in the range
                                        ; 0 through ( PTR_WIDTH * 8 )
        jb      short ck_current_shift
        mov     ebx,PTR_HEIGHT          ;if X is fully off the screen,
                                        ; simply move Y off the screen, which
                                        ; is simpler to implement below

; Shifted masks are required. If the currently loaded masks are shifted in the
; same way as the new masks, don't need to do anything; otherwise, the shifted
; masks have to be generated and loaded.

ck_current_shift:
        mov     edi,pShiftInfo
        cmp     [edi].ulShiftedFlag,1   ;if there are no currently loaded
                                        ; masks or the currently loaded masks
                                        ; are unshifted, must load shifted
                                        ; masks
        mov     edi,pShiftInfo
        jnz     short generate_shifted_masks ;no currently loaded shifted masks
        cmp     eax,[edi].ulXShift           ;if X and Y shifts are both the
        jnz     short generate_shifted_masks ; same as what's already loaded
        cmp     ebx,[edi].ulYShift      ; memory, then there's no need
                                        ; to do anything
        jz      draw_cursor_set_location ;Don't need to do anything

; Load the Cirrus cursor with the masks, shifted as required by
; the current X and Y.

generate_shifted_masks:

        mov     [edi].ulXShift,eax
        mov     [edi].ulYShift,ebx

        mov     edi,eax                 ;preserve X shift value

; Set the Map Mask to enable all planes.

        call    wait4VertRetrace
        mov     edx,EGA_BASE + SEQ_ADDR
        mov     eax,SEQ_MAP_MASK + 00f00h
        out     dx,ax
        mov     al,SEQ_EXT_MODE
        out     dx,al
        inc     dx
        in      al,dx
        mov     SaveSR7,al
        or      al,SEQ_HIRES_MODE
        out     dx,al

        mov     eax,edi                 ;retrieve X shift value

; Load the masks.

        xchg    al,bl                   ;BL=X shift value, AL=Y shift value
        cbw
        cwde
        neg     eax
        add     eax,PTR_HEIGHT          ;unpadded length of cursor
        and     bl,31                   ;X partial byte portion (bit shift)

        mov     edi,pLoadAddress        ;start of cursor load area
        and     edi,3FFFh               ; mask to 16K granularity
        add     edi,pVideoMem           ; move into protected mode space
        mov     esi,pAndMask            ;ESI points to start of AND mask
                                        
        call    shift_mask              ;generate shifted masks

; Restore default Bit Mask setting.

        mov     edx,EGA_BASE + SEQ_ADDR
        mov     al,SEQ_EXT_MODE
        mov     ah,SaveSR7
        out     dx,ax
        mov     edx,EGA_BASE + GRAF_ADDR
        mov     eax,GRAF_BIT_MASK + 0ff00h
        out     dx,ax

        mov     esi,pShiftInfo
        mov     [esi].ulShiftedFlag,1   ;mark that the currently loaded
                                        ; masks are shifted
        jmp     draw_cursor_set_location


; Default masks can be used. See if any masks are loaded into memory; if so
; see if they were shifted: if they were, load unshifted masks; if they
; weren't, the masks are already properly loaded into Cirrus memory.
        align   4
draw_cursor_unshifted:
        mov     esi,pShiftInfo
        cmp     [esi].ulShiftedFlag,0 ;are there any currently loaded masks,
                                      ; and if so, are they shifted?
        jz      draw_cursor_set_location  ;no-all set
                                                ;yes-load unshifted masks
        call    wait4VertRetrace
        mov     edx,EGA_BASE + SEQ_ADDR
        mov     al,SEQ_EXT_MODE
        out     dx,al
        inc     dx
        in      al,dx
        mov     SaveSR7,al
        or      al,SEQ_HIRES_MODE
        out     dx,al

        mov     esi,pAndMask    ;ESI points to default masks

; Copy the cursor patterns into Cirrus mask memory, one mask at a time.

        mov     ecx,PTR_HEIGHT*4        ;move 4 bytes per scanline of each mask
        mov     edi,pLoadAddress        ;start of cursor load area
        and     edi,3FFFh               ; mask to 16K granularity
        add     edi,pVideoMem           ; move into protected mode spaced
        add     esi,128
        rep     movsb
        mov     ecx,PTR_HEIGHT*4
        sub     esi,256
load_and_mask_loop:
        lodsb
        not     eax                     ; cirrus and mask is backwards
        stosb
        loop    load_and_mask_loop

; Restore the default Map Mask.

        mov     edx,EGA_BASE + SEQ_ADDR
        mov     eax,SEQ_MAP_MASK + 00f00h
        out     dx,ax
        mov     al,SEQ_EXT_MODE
        mov     ah,SaveSR7
        out     dx,ax

        mov     esi,pShiftInfo
        mov     [esi].ulShiftedFlag,0   ;mark that the currently loaded masks
                                        ; are unrotated
; Set the new cursor location.

draw_cursor_set_location:
        mov     edx,EGA_BASE + SEQ_ADDR
        mov     ecx,lVptlX        ;set X coordinate
        and     ecx,ecx
        jns     short set_x_coord ;if negative, force to 0 (the masks in
        sub     ecx,ecx           ; Cirrus memory have already been shifted
                                  ; to compensate)
set_x_coord:

        mov     ebx,lVptlY        ;set Y coordinate
        and     ebx,ebx
        jns     short set_y_coord ;if negative, force to 0 (the masks in
        sub     ebx,ebx           ; Cirrus memory have already been shifted
                                  ; to compensate)
set_y_coord:

        mov     ax,cx
        shl     ax,5            ; move x-coord into position
        or      al,SEQ_PX       ; generate reg addr based on x-coordinate
        out     dx,ax           ; (10,30,...,D0,F0)

        mov     ax,bx
        shl     ax,5            ; move y-coord into position
        or      al,SEQ_PY       ; generate reg addr based on y-coordinate
        out     dx,ax           ; (10,30,...,D0,F0)

; Restore Cirrus registers to their original states.

        mov     edx,EGA_BASE + GRAF_ADDR
	mov	al,AVGA_PROA
	mov	ah,SavedProA
	out	dx,ax
	mov	al,AVGA_MODE_EXTENSIONS
	mov	ah,SavedExtReg
	out	dx,ax

	test	ah,1110b				;Are any exts enabled?
	jz	@F					;no...

	mov	al,GRAF_SET_RESET
	mov	ah,SaveSetReset
	out	dx,ax
	mov	al,GRAF_ENAB_SR
	mov	ah,SaveEnableSR
	out	dx,ax
	mov	al,GRAF_MODE
	mov	ah,SaveGR5
	out	dx,ax
        mov     al,GRAF_DATA_ROT
        mov     ah,SaveGR3
        out     dx,ax
@@:

	mov	al,SaveGRFIndex
	out	dx,al

        mov     edx,EGA_BASE + SEQ_ADDR
        mov     al,SEQ_MODE
        mov     ah,SavedSeqMode
        out     dx,ax

	mov	al,SEQ_MAP_MASK
	mov	ah,SaveMapMask
	out	dx,ax           ;restore default sequencer index and map mask

        stdRET  CirrusDrawPointer

stdENDP CirrusDrawPointer

page
;--------------------------------------------------------------------;
; wait4VertRetrace
;
;       Returns when the vertical retrace bit has switched from 0 to 1
;
;--------------------------------------------------------------------;
wait4VertRetrace        proc    near
        mov     edx,EGA_BASE + IN_STAT_1
@@:
        in      al,dx
        and     al,08h          ; wait for vertical retrace to be clear
        jnz     @b
@@:
        in      al,dx
        and     al,08h          ; now wait for it to be set
        jz      @b
        ret                     ; vertical retrace just started
wait4VertRetrace        endp

page
;--------------------------------------------------------------------;
; shift_mask
;
;       Loads a shifted cursor mask.
;
;       Input:  EAX = unpadded mask height (vertical shift)
;               BL = amount of shift to left (horizontal shift)
;               DS:ESI = --> to unshifted masks to load
;               ES:EDI = --> to Cirrus mask memory to load
;
;       Output: DS:ESI = --> byte after unshifted masks
;               ES:EDI = --> to byte after Cirrus mask memory loaded
;
;       BH, CH destroyed.
;       Map Mask must enable all planes.
;--------------------------------------------------------------------;

        align   4
shift_mask      proc    near

        push    ebp                     ; use ebp for mask
	cmp	bl,0
	je	UPCFast
        mov     ecx,32
        sub     ecx,eax
        shl     ecx,2                   ; 4 bytes per scanline
        add     esi,ecx
        push    esi
        push    eax                     ; assumed non-zero, use as 1st time flag
        add	esi,128                 ; do XOR mask first
        xor     ebp,ebp
UPCSlow:
        mov     bh,al
        mov     ecx,32
        sub     ecx,eax
        push    ecx                     ; number of scanlines to pad at bottom
UPCLoop1:
	lodsw				;Fetch 32 bits
	mov	dx,[esi]
        xor     eax,ebp
        xor     edx,ebp
	inc	esi
	inc	esi
        xor     ecx,ecx                 ; clear high bytes of ecx
	mov	cl,bl                   ; shift count in ecx
UPCLoop2:				;Shift loop
	shl	dh,1
	adc	dl,dl
	adc	ah,ah
	adc	al,al
	loop	UPCLoop2
	stosw				;write shifted data
	mov	ax,dx
	stosw
	dec	bh			;done one scan
	jnz	UPCLoop1		;do the rest
	
        pop     ecx                     ; # of dwords to pad after visible mask
	xor	eax,eax
	rep	stosd			;write 0's for transparent

        pop     eax
        and     ax,ax
	jz	end_shift_mask          ;already 0, done...

        pop     esi
        xor     ecx,ecx
        push    ecx
        dec     ebp
	jmp	UPCSlow			;second pass..

UPCFast:
        mov     ebx,eax                 ; number of visible scans in ebx
        mov     ecx,ebx                 ; 1 dword per scan
	mov	edx,32                  ; total dwords in a mask
	sub	edx,ecx			; no. transparent dwords to add at end
        push    esi                     ; remember where the mask starts
        add     esi,128
; First do the XOR mask - just move the visible part, then pad with zeroes
        shl     edx,2
        add     esi,edx
        shr     edx,2
	mov	ecx,ebx
	rep	movsd			; Move opaque plane
	mov	ecx,edx
	xor	eax,eax                 ; pad with zeroes
	rep	stosd			; transparent

        pop     esi
        shl     edx,2
        add     esi,edx
        shr     edx,2
        mov     ecx,ebx
; Then handle the AND mask - remember that our hardware is backwards here	
@@:                     
        lodsd
        not     eax
        stosd
        loop    @b
	mov	ecx,edx
	xor	eax,eax                 ; pad with zeroes
	rep	stosd			; transparent
end_shift_mask:
        pop     ebp
        ret
shift_mask      endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\sr754x.c ===
//---------------------------------------------------------------------------
/*++

Copyright (c) 1994  Cirrus Logic, Inc.

Module Name:

    sr754x.c

Abstract:

    This module performs the save/restore operations specific to the
    CL-GD754x chipset (aka Nordic).

Environment:

    kernel mode only

Notes:

Revision History:
   13Oct94  mrh   Initial version

--*/
//---------------------------------------------------------------------------

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"


#include "ntddvdeo.h"
#include "video.h"
#include "cirrus.h"
#include "sr754x.h"



#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NordicSaveRegs)
#pragma alloc_text(PAGE,NordicRestoreRegs)
#endif

VP_STATUS NordicSaveRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pNordicSaveArea
    )
{
   UCHAR i;
   UCHAR PortVal, Save2C, Save2D;
   PUCHAR CRTCAddressPort, CRTCDataPort;
   PUSHORT pSaveBuf;
   UCHAR vShadowIndex[CL754x_NUM_VSHADOW] = {0x06,0x07,0x10,0x11,0x15,0x16};
   UCHAR zShadowIndex[CL754x_NUM_ZSHADOW] = {0,2,3,4,5};
   UCHAR yShadowIndex[CL754x_NUM_YSHADOW] = {0,2,3,4,5};
   UCHAR xShadowIndex[CL754x_NUM_XSHADOW] = {2,3,4,5,6,7,8,9,0x0B,0x0C,0x0D,0x0E};


   //
   // Determine where the CRTC registers are addressed (color or mono).
   //
   CRTCAddressPort = HwDeviceExtension->IOAddress;
   CRTCDataPort = HwDeviceExtension->IOAddress;

   if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
               MISC_OUTPUT_REG_READ_PORT) & 0x01)
      {
      CRTCAddressPort += CRTC_ADDRESS_PORT_COLOR;
      CRTCDataPort += CRTC_DATA_PORT_COLOR;
      }
   else
      {
      CRTCAddressPort += CRTC_ADDRESS_PORT_MONO;
      CRTCDataPort += CRTC_DATA_PORT_MONO;
      }

   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2D);
   Save2D = (VideoPortReadPortUchar(CRTCDataPort));

   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2C);
   Save2C = (VideoPortReadPortUchar(CRTCDataPort));

   pSaveBuf = pNordicSaveArea;

   //Initialize the control registers to access shadowed vertical regs:
   // CR2C[3] = {0} Allows access to Vert regs (CR6,CR7,CR10,CR11,CR15,CR16)
   // CR2D[7] = {0} Blocks access to LCD timing regs (R2X-REX)
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                           (USHORT)(((Save2C & ~0x08) << 8) | IND_CR2C));
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                           (USHORT)(((Save2D & ~0x80) << 8) | IND_CR2D));

   for (i = 0; i < CL754x_NUM_VSHADOW; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, vShadowIndex[i]);
      *pSaveBuf++ = (USHORT)((VideoPortReadPortUchar (CRTCDataPort)) << 8) |
                     vShadowIndex[i];
      }
   for (i = CL754x_CRTC_EXT_START; i <= CL754x_CRTC_EXT_END; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, i);
      *pSaveBuf++ = (USHORT)((VideoPortReadPortUchar (CRTCDataPort)) << 8) | i;
      }

   for (i = CL754x_HRZ_TIME_START; i <= CL754x_HRZ_TIME_END; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, i);
      *pSaveBuf++ = (USHORT)((VideoPortReadPortUchar (CRTCDataPort)) << 8) | i;
      }

   // Set CR2D [7] to {0} and CR2C[5,4] to {1,0}
   // These values provide access to Y shadow registers
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((Save2D & ~0x80) << 8) | IND_CR2D));
   PortVal = Save2C & ~0x30;              // We'll use PortVal again below
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((PortVal | 0x20) << 8) | IND_CR2C));

   for (i = 0; i < CL754x_NUM_YSHADOW; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, yShadowIndex[i]);
      *pSaveBuf++ = (USHORT)((VideoPortReadPortUchar (CRTCDataPort)) << 8) |
                     yShadowIndex[i];
      }

   // Set CR2C[5,4] to {1,1}
   // This will provide access to Z shadow registers
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((PortVal | 0x30) << 8 )| IND_CR2C));
   for (i = 0; i < CL754x_NUM_ZSHADOW; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, zShadowIndex[i]);
      *pSaveBuf++ = (USHORT)((VideoPortReadPortUchar (CRTCDataPort)) << 8) |
                     zShadowIndex[i];
      }

   // Set CR2C[5,4] to {0,0} and CR2D[7] to {1}
   // This will provide access to X shadow registers
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,  // PortVal=Save2C & ~0x30
                            (USHORT)((PortVal << 8) | IND_CR2C));
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((Save2D | 0x80) << 8) | IND_CR2D));

   for (i = 0; i < CL754x_NUM_XSHADOW; i++)
      {
      VideoPortWritePortUchar (CRTCAddressPort, xShadowIndex[i]);
      *pSaveBuf++ = ((VideoPortReadPortUchar (CRTCDataPort)) << 8) |
                     xShadowIndex[i];
      }

   //Restore the original values for CR2C and CR2D
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)((Save2D << 8) | IND_CR2D));
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)((Save2C << 8) | IND_CR2C));

   return NO_ERROR;
}

VP_STATUS NordicRestoreRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pNordicSaveArea
    )
{
   ULONG i;
   UCHAR PortVal, Save2C, Save2D;
   PUSHORT pSaveBuf;
   PUCHAR CRTCAddressPort, CRTCDataPort;

   //
   // Determine where the CRTC registers are addressed (color or mono).
   //
   CRTCAddressPort = HwDeviceExtension->IOAddress;
   CRTCDataPort = HwDeviceExtension->IOAddress;

   if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
               MISC_OUTPUT_REG_READ_PORT) & 0x01)
      {
      CRTCAddressPort += CRTC_ADDRESS_PORT_COLOR;
      CRTCDataPort += CRTC_DATA_PORT_COLOR;
      }
   else
      {
      CRTCAddressPort += CRTC_ADDRESS_PORT_MONO;
      CRTCDataPort += CRTC_DATA_PORT_MONO;
      }

   //Initialize the control registers to access shadowed vertical regs
   // CR11[7] = {0} Allows access to CR0-7
   // CR2C[3] = {0} Allows access to Vertical regs (CR6,CR7,CR10,CR11,CR15,CR16
   // CR2D[7] = {0} Blocks access to LCD timing regs (R2X-REX)
   //
   VideoPortWritePortUchar(CRTCAddressPort, IND_CRTC_PROTECT);
   VideoPortWritePortUchar(CRTCDataPort,
                  (UCHAR) (VideoPortReadPortUchar(CRTCDataPort) & ~0x80));

   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2C);
   VideoPortWritePortUchar(CRTCDataPort,
                  (UCHAR) (VideoPortReadPortUchar(CRTCDataPort) & ~0x08));

   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2D);
   VideoPortWritePortUchar(CRTCDataPort,
                  (UCHAR) (VideoPortReadPortUchar(CRTCDataPort) & ~0x80));

   pSaveBuf = pNordicSaveArea;
   for (i = 0; i < CL754x_NUM_VSHADOW; i++)
      {
      VideoPortWritePortUshort((PUSHORT)CRTCAddressPort, (*pSaveBuf++));
      }

   // Make sure we didn't lock CR0-CR7
   //
   VideoPortWritePortUchar(CRTCAddressPort, IND_CRTC_PROTECT);
   VideoPortWritePortUchar(CRTCDataPort,
                  (UCHAR) (VideoPortReadPortUchar(CRTCDataPort) & ~0x80));

   for (i=0; i < (CL754x_NUM_CRTC_EXT_PORTS + CL754x_NUM_HRZ_TIME_PORTS); i++)
      {
      VideoPortWritePortUshort((PUSHORT)CRTCAddressPort, (*pSaveBuf++));
      }

   // Set CR2D [7] to {0} and CR2C[5,4] to {1,0}; save current contents
   // These values provide access to Y shadow registers
   //
   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2D);
   Save2D = (VideoPortReadPortUchar(CRTCDataPort));
   VideoPortWritePortUchar(CRTCDataPort, (UCHAR)(Save2D & ~0x80));

   VideoPortWritePortUchar(CRTCAddressPort, IND_CR2C);
   PortVal = Save2C = (VideoPortReadPortUchar(CRTCDataPort));
   PortVal &= ~0x30;
   PortVal |= 0x20;
   VideoPortWritePortUchar(CRTCDataPort, PortVal);

   for (i = 0; i < CL754x_NUM_YSHADOW; i++)
      {
      VideoPortWritePortUshort((PUSHORT)CRTCAddressPort, (*pSaveBuf++));
      }

   // Set CR2C[5,4] to {1,1}
   // This will provide access to Z shadow registers
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((PortVal | 0x30) << 8) | IND_CR2C) );
   for (i = 0; i < CL754x_NUM_ZSHADOW; i++)
      {
      VideoPortWritePortUshort((PUSHORT)CRTCAddressPort, (*pSaveBuf++));
      }

   // Set CR2C[5,4] to {0,0} and CR2D[7] to {1}
   // This will provide access to X shadow registers
   //
   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                            (USHORT)(((PortVal & ~0x30) << 8) | IND_CR2C) );

   VideoPortWritePortUshort((PUSHORT)CRTCAddressPort,
                           (USHORT)(((Save2D | 0x80) << 8) | IND_CR2D) );

   for (i = 0; i < CL754x_NUM_XSHADOW; i++)
      {
      VideoPortWritePortUshort((PUSHORT)CRTCAddressPort, (*pSaveBuf++));
      }

   // Reset the Blitter, in case it's busy
   //
   VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                             GRAPH_ADDRESS_PORT), 0x0430);
   VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                             GRAPH_ADDRESS_PORT), 0x0030);

   VideoPortWritePortUshort((PUSHORT) CRTCAddressPort,
                            (USHORT)((Save2C << 8) | IND_CR2C));
   VideoPortWritePortUshort((PUSHORT) CRTCAddressPort,
                            (USHORT)((Save2D << 8) | IND_CR2D));

   return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\i386\clhard.asm ===
title  "Cirrus Logic ASM routines"
;

;ONE_64K_BANK    equ     1
TWO_32K_BANKS   equ     1

;++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;     vgahard.asm
;
; Abstract:
;
;     This module implements the banding code for the Cirrus Logic 6410,6420
;       and 542x VGA's.
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;
;--

.386p
        .xlist
include callconv.inc
        .list

;----------------------------------------------------------------------------
;
; Cirrus Logic banking control ports.
;
GRAPHICS_ADDRESS_PORT equ   03ceh      ;banking control here
CL6420_BANKING_INDEX_PORT_A equ   0eh        ;banking index register A is GR0E
CL6420_BANKING_INDEX_PORT_B equ   0fh        ;banking index register B is GR0F
CL542x_BANKING_INDEX_PORT_A equ   09h        ;banking index register A is GR09
CL542x_BANKING_INDEX_PORT_B equ   0ah        ;banking index register B is GR0A

SEQ_ADDRESS_PORT equ        03C4h      ;Sequencer Address register
IND_MEMORY_MODE  equ        04h        ;Memory Mode reg. index in Sequencer
CHAIN4_MASK      equ        08h        ;Chain4 bit in Memory Mode register

;----------------------------------------------------------------------------

;_TEXT   SEGMENT DWORD USE32 PUBLIC 'CODE'
;        ASSUME  CS:FLAT, DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
;    Bank switching code. This is a 1-64K-read/1-64K-write bank adapter
;    (VideoBanked1R1W).
;
;    Input:
;          EAX = desired read bank mapping
;          EDX = desired write bank mapping
;
;    Note: values must be correct, with no stray bits set; no error
;       checking is performed.
;
        public _CL64xxBankSwitchStart
        public _CL64xxBankSwitchEnd
        public _CL64xxPlanarHCBankSwitchStart
        public _CL64xxPlanarHCBankSwitchEnd
        public _CL64xxEnablePlanarHCStart
        public _CL64xxEnablePlanarHCEnd
        public _CL64xxDisablePlanarHCStart
        public _CL64xxDisablePlanarHCEnd

        public _CL542xBankSwitchStart
        public _CL542xBankSwitchEnd
        public _CL542xPlanarHCBankSwitchStart
        public _CL542xPlanarHCBankSwitchEnd
        public _CL542xEnablePlanarHCStart
        public _CL542xEnablePlanarHCEnd
        public _CL542xDisablePlanarHCStart
        public _CL542xDisablePlanarHCEnd

        public _CL543xBankSwitchStart
        public _CL543xBankSwitchEnd
        public _CL543xPlanarHCBankSwitchStart
        public _CL543xPlanarHCBankSwitchEnd

        align 4

;----------------------------------------------------------------------------
_CL64xxBankSwitchStart proc                   ;start of bank switch code
_CL64xxPlanarHCBankSwitchStart:               ;start of planar HC bank switch code,
                                        ; which is the same code as normal
                                        ; bank switching
        shl     eax,3                   ;shift them to bits 7-4
        shl     edx,3                   ;shift them to bits 7-4
;!!!! NOTE: The October 1992 release NT VGA driver assumes that the Graphics
;           index is not changed by the bank switch code.  We save it on the
;           stack (and save the write bank value in the high order of edx)
;           and restore it at the end of the routine.  If the NT VGA driver
;           changes so that it is the index need not be preserved, this code
;           could be simplified (and speeded up!)
        rol     edx,16                     ; save write value
        mov     ah,al
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        in      al,dx                    ; save graphics index
        push    eax
        mov     al,CL6420_BANKING_INDEX_PORT_A
        out     dx,ax                           ;select the READ bank
        rol     edx,16
        mov     ah,dl
        mov     al,CL6420_BANKING_INDEX_PORT_B
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        out     dx,ax                           ;select the WRITE bank
        pop     eax
        out     dx,al

        ret

_CL64xxBankSwitchEnd:
_CL64xxPlanarHCBankSwitchEnd:

        align 4
_CL64xxEnablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        and     al,NOT CHAIN4_MASK      ;turn off Chain4 to make memory planar
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address

ERA1_INDEX            equ 0A1h

        mov     dx,GRAPHICS_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the Graphics Index
        mov     al,ERA1_INDEX
        out     dx,al                   ;point to ERA1
        inc     edx
        in      al,dx                   ; get ERA1
        and     al,not 30h              ; turn off the shift bits
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Graphics Index
        ret

_CL64xxEnablePlanarHCEnd:

        align 4
_CL64xxDisablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        or      al,CHAIN4_MASK          ;turn on Chain4 to make memory linear
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address

        mov     dx,GRAPHICS_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the Graphics Index
        mov     al,ERA1_INDEX
        out     dx,al                   ;point to ERA1
        inc     edx
        in      al,dx                   ; get ERA1
        and     al,not 30h
        or      al,20h
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Graphics Index
        ret

_CL64xxDisablePlanarHCEnd:

_CL64xxBankSwitchStart endp


_CL542xBankSwitchStart proc                   ;start of bank switch code
_CL542xPlanarHCBankSwitchStart:               ;start of planar HC bank switch code,
                                        ; which is the same code as normal
                                        ; bank switching
        shl     eax,3                   ;shift them to bits 7-4
        shl     edx,3                   ;shift them to bits 7-4
;!!!! NOTE: The October 1992 release NT VGA driver assumes that the Graphics
;           index is not changed by the bank switch code.  We save it on the
;           stack (and save the write bank value in the high order of edx)
;           and restore it at the end of the routine.  If the NT VGA driver
;           changes so that it is the index need not be preserved, this code
;           could be simplified (and speeded up!)
        rol     edx,16                  ; save write value
        mov     ah,al
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        in      al,dx
        push    eax
        mov     al,CL542x_BANKING_INDEX_PORT_A
        out     dx,ax                           ;select the READ bank

        rol     edx,16                          ; restore write value
        mov     ah,dl
        mov     al,CL542x_BANKING_INDEX_PORT_B
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        out     dx,ax                           ;select the WRITE bank
        pop     eax
        out     dx,al

        ret

_CL542xBankSwitchEnd:
_CL542xPlanarHCBankSwitchEnd:

        align 4
_CL542xEnablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        and     al,NOT CHAIN4_MASK      ;turn off Chain4 to make memory planar
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address
        ret

_CL542xEnablePlanarHCEnd:

        align 4
_CL542xDisablePlanarHCStart:
        mov     dx,SEQ_ADDRESS_PORT
        in      al,dx
        push    eax                     ;preserve the state of the Seq Address
        mov     al,IND_MEMORY_MODE
        out     dx,al                   ;point to the Memory Mode register
        inc     edx
        in      al,dx                   ;get the state of the Memory Mode reg
        or      al,CHAIN4_MASK          ;turn on Chain4 to make memory linear
        out     dx,al
        dec     edx
        pop     eax
        out     dx,al                   ;restore the original Seq Address
        ret

_CL542xDisablePlanarHCEnd:


_CL542xBankSwitchStart endp

;
;       543x banking assumes 16k granularity to allow up to 4-meg modes
;
_CL543xBankSwitchStart proc             ;start of bank switch code
_CL543xPlanarHCBankSwitchStart:         ;start of planar HC bank switch code,
                                        ; which is the same code as normal
                                        ; bank switching
        shl     eax,1                   ;shift them to bits 4-1
        shl     edx,1                   ;shift them to bits 4-1
;!!!! NOTE: The October 1992 release NT VGA driver assumes that the Graphics
;           index is not changed by the bank switch code.  We save it on the
;           stack (and save the write bank value in the high order of edx)
;           and restore it at the end of the routine.  If the NT VGA driver
;           changes so that it is the index need not be preserved, this code
;           could be simplified (and speeded up!)
        rol     edx,16                  ; save write value
        mov     ah,al
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        in      al,dx
        push    eax
        mov     al,CL542x_BANKING_INDEX_PORT_A
        out     dx,ax                           ;select the READ bank

        rol     edx,16                          ; restore write value
        mov     ah,dl
        mov     al,CL542x_BANKING_INDEX_PORT_B
        mov     dx,GRAPHICS_ADDRESS_PORT        ;banking control port
        out     dx,ax                           ;select the WRITE bank
        pop     eax
        out     dx,al

        ret

_CL543xBankSwitchEnd:
_CL543xPlanarHCBankSwitchEnd:

_CL543xBankSwitchStart endp


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\i386\egavga.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  EGAVGA.INC
;
; This file contains the external definitions of the EGA/VGA specific
; locations which driver output routines need to reference.
;
; Copyright (c) Microsoft Corporation 1989 - 1993
;
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;

;       Miscellaneous Registers used only at EGA/VGA initialization time

MISC_OUTPUT     EQU     0C2h            ;Miscellaneous Output Register
CRTC_ADDR       EQU     0D4h            ;CRTC Address Register for color mode
CRTC_DATA       EQU     0D5h            ;CRTC Data    Register for color mode
GRAF_1_POS      EQU     0CCh            ;Graphics 1 Address Register
GRAF_2_POS      EQU     0CAh            ;Graphics 2 Address Register
ATTR_READ       EQU     0DAh            ;Attribute Controler Read  Address
ATTR_WRITE      EQU     0C0h            ;Attribute Controler Write Address
IN_STAT_0       EQU     0C2h            ;Input Status Register 0
IN_STAT_1       EQU     0DAh            ;Input Status Register 1



;       EGA/VGA Register Definitions.
;
;       The following definitions are the EGA/VGA registers and values
;       used by this driver.  All other registers are set up at
;       when the EGA/VGA is placed into graphics mode and never altered
;       afterwards.
;
;       All unspecified bits in the following registers must be 0.


EGA_BASE        EQU     300h            ;Base address of the EGA (3xx)
VGA_BASE        EQU     300h            ;Base address of the VGA (3xx)



;       EGA/VGA Register Definitions.

EGA_BASE        EQU     300h            ;Base address of the EGA (3xx)
VGA_BASE        EQU     300h            ;Base address of the VGA (3xx)

;       SEQUencer Registers Used

SEQ_ADDR        EQU     0C4h            ;SEQUencer Address Register
SEQ_DATA        EQU     0C5h            ;SEQUencer Data    Register

SEQ_MAP_MASK    EQU     02h             ;Write Plane Enable Mask
MM_C0           EQU     00000001b       ;  C0 plane enable
MM_C1           EQU     00000010b       ;  C1 plane enable
MM_C2           EQU     00000100b       ;  C2 plane enable
MM_C3           EQU     00001000b       ;  C3 plane enable
MM_ALL          EQU     00001111b       ;  All planes

SEQ_MODE        EQU     04h             ;Memory Mode
SM_ALPHA        EQU     00000001b       ;  Char map select enable
SM_EXTENDED     EQU     00000010b       ;  Extended memory present
SM_ODD_PLANE    EQU     00000100b       ;  Odd/even bytes to same plane
SM_CHAIN4       EQU     00001000b       ;  Chain4 mode

;       Graphics Controller Registers Used

GRAF_ADDR       EQU     0CEh            ;Graphics Controller Address Register
GRAF_DATA       EQU     0CFh            ;Graphics Controller Data    Register

GRAF_SET_RESET  EQU     00h             ;  Set/Reset Plane Color
GRAF_ENAB_SR    EQU     01h             ;  Set/Reset Enable
GRAF_COL_COMP   EQU     02h             ;  Color Compare Register

GRAF_DATA_ROT   EQU     03h             ;  Data Rotate Register
DR_ROT_CNT      EQU     00000111b       ;    Data Rotate Count
DR_SET          EQU     00000000b       ;    Data Unmodified
DR_AND          EQU     00001000b       ;    Data ANDed with latches
DR_OR           EQU     00010000b       ;    Data ORed  with latches
DR_XOR          EQU     00011000b       ;    Data XORed with latches

GRAF_READ_MAP   EQU     04h             ;  Read Map Select Register
RM_C0           EQU     00000000b       ;    Read C0 plane
RM_C1           EQU     00000001b       ;    Read C1 plane
RM_C2           EQU     00000010b       ;    Read C2 plane
RM_C3           EQU     00000011b       ;    Read C3 plane

GRAF_MODE       EQU     05h             ;  Mode Register
M_PROC_WRITE    EQU     00000000b       ;    Write processor data rotated
M_LATCH_WRITE   EQU     00000001b       ;    Write latched data
M_COLOR_WRITE   EQU     00000010b       ;    Write processor data as color
M_AND_WRITE     EQU     00000011b       ;    Write (procdata AND bitmask)
M_DATA_READ     EQU     00000000b       ;    Read selected plane
M_COLOR_READ    EQU     00001000b       ;    Read color compare

GRAF_MISC       EQU     06h             ;  Miscellaneous Register
MS_NON_ALPHA    EQU     00000001b       ;    Char generator disabled
MS_ODD_EVEN     EQU     00000010b       ;    Map odd addresses to even
MS_A0000_128K   EQU     00000000b       ;    Memory present at A0000, 128kb
MS_A0000_64K    EQU     00000100b       ;    Memory present at A0000, 64kb
MS_B0000_32K    EQU     00001000b       ;    Memory present at B0000, 32kb
MS_B8000_32K    EQU     00001100b       ;    Memory present at B8000, 32kb
MS_ADDR_MASK    EQU     00001100b

GRAF_CDC        EQU     07h             ;  Color Don't Care Register
GRAF_BIT_MASK   EQU     08h             ;  Bit Mask Register


;       Various sizes for EGA/VGA data structures

;-----------------------------------------------------------------------;
; The pointer parameters are the size of the pointer as received from
; DeviceSetCursor.
;-----------------------------------------------------------------------;

PTR_HEIGHT      EQU     32
PTR_WIDTH       EQU     4                       ;Width in bytes of pointer
PTR_WIDTH_BITS  EQU     PTR_WIDTH*8             ;Width in bits of pointer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\bank.c ===
/******************************Module*Header*******************************\
* Module Name: bank.c
*
* Contains all the banking code for the display driver.
*
* It's helpful not to have to implement all the DDI drawing functionality
* in a driver (who wants to write the code to support true ROP4's with
* arbitrary sized patterns?).  Fortunately, we can punt to GDI for any
* drawing we don't want to do.  And if GDI can write directly on the frame
* buffer bits, performance won't even be toooo bad.
*
* NT's GDI can draw on any standard format frame buffer.  When the entire
* frame buffer can be mapped into main memory, it's very simple to set up:
* the display driver tells GDI the frame buffer format and location, and
* GDI can then just draw directly.
*
* When only one bank of the frame buffer can be mapped into main memory
* at one time (e.g., there is a moveable 64k aperture) things are not
* nearly so easy.  For every bank spanned by a drawing operation, we have
* to set the hardware to the bank, and call back to GDI.  We tell GDI
* to draw only on the mapped-in bank by mucking with the drawing call's
* CLIPOBJ.
*
* This module contains the code for doing all banking support.
*
* This code supports 8, 16 and 32bpp colour depths, arbitrary bank
* sizes, and handles 'broken rasters' (which happens when the bank size
* is not a multiple of the scan length; some scans will end up being
* split over two separate banks).
*
* Note:  If you mess with this code and break it, you can expect to get
*        random access violations on call-backs in internal GDI routines
*        that are very hard to debug.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

VOID vBankSelectMode(
PDEV*        ppdev,
BANK_MODE    bankm)
{
    if (bankm == BANK_ON)
    {
        // Make sure the processor graphics engine is idle before we start
        // drawing:

        if (ppdev->pjMmBase != NULL)
        {
            MM_WAIT_FOR_IDLE(ppdev, ppdev->pjMmBase);
            MM_DATAPATH_CTRL(ppdev, ppdev->pjMmBase, SRC_IS_CPU_DATA);
            MM_CTRL_REG_1(ppdev, ppdev->pjMmBase, PACKED_PIXEL_VIEW |
                                                  BITS_PER_PIX_8    |
                                                  ENAB_TRITON_MODE);
        }
        else
        {
            IO_WAIT_FOR_IDLE(ppdev, ppdev->pjIoBase);
            IO_DATAPATH_CTRL(ppdev, ppdev->pjIoBase, SRC_IS_CPU_DATA);
            IO_CTRL_REG_1(ppdev, ppdev->pjIoBase, PACKED_PIXEL_VIEW |
                                                  BITS_PER_PIX_8    |
                                                  ENAB_TRITON_MODE);
        }
    }
}

VOID vBankMap(
PDEV*       ppdev,
LONG        iBank)
{
#if defined(i386)

    volatile PFN pfnBank;

    pfnBank = ppdev->pfnBankSwitchCode;

    _asm mov eax,iBank;
    _asm add eax,eax;
    _asm mov edx,eax;
    _asm inc edx;

    _asm call pfnBank;

#else

    ASSERTDD(iBank == 0, "Shouldn't be banking on non-x86");

#endif
}


BOOL bBankInitialize(
PDEV*       ppdev)
{
    // Set this now in case we have to early-out:

    ppdev->pBankInfo = NULL;

    // Only the x86 miniport has banking code; the Alpha miniport always
    // maps the frame buffer linearly:

    #if defined(i386)
    {
        PVIDEO_BANK_SELECT  pBankInfo;
        UINT                ReturnedDataLength;
        VIDEO_BANK_SELECT   TempBankInfo;
        DWORD               status;

        // Query the miniport for banking info for this mode.
        //
        // First, figure out how big a buffer we need for the banking info
        // (returned in TempBankInfo->Size).

        if (status = EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                             NULL,                      // input buffer
                             0,
                             (LPVOID) &TempBankInfo,    // output buffer
                             sizeof(VIDEO_BANK_SELECT),
                             &ReturnedDataLength))
        {
        //
        // We expect this call to fail, because we didn't allow any room
        // for the code; we just want to get the required output buffer
        // size. Make sure we got the expected error, ERROR_MORE_DATA.
        //
// BUGBUG
// BUGBUG reenable this check when we fix error reporting from miniports

        //if (status != ERROR_MORE_DATA) {
        //
        //    //
        //    // Should post error and return FALSE
        //    //
        //
        //    RIP("Initialization error - GetBankSelectCode, first call");
        //
        //    goto ReturnFailure;
        //}
        }

        // Now, allocate a buffer of the required size and get the banking info.

        pBankInfo = (PVIDEO_BANK_SELECT) EngAllocMem(FL_ZERO_MEMORY,
                        TempBankInfo.Size, ALLOC_TAG);
        if (pBankInfo == NULL)
        {
            RIP("Initialization ReturnFailure -- couldn't get memory for bank info");
            goto ReturnFailure;
        }

        // Remember it so we can free it later:

        ppdev->pBankInfo = pBankInfo;

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                             NULL,
                             0,
                             (LPVOID) pBankInfo,
                             TempBankInfo.Size,
                             &ReturnedDataLength))
        {
            RIP("Initialization ReturnFailure -- bBankInitialize, second call");
            goto ReturnFailure;
        }

        ppdev->pfnBankSwitchCode =
            (PFN) (((BYTE*) pBankInfo) + pBankInfo->CodeOffset);

        return(TRUE);

    ReturnFailure:

        if (ppdev->pBankInfo)
        {
            EngFreeMem(ppdev->pBankInfo);
        }

        return(FALSE);
    }
    #endif

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bEnableBanking
*
\**************************************************************************/

BOOL bEnableBanking(
PDEV*   ppdev)
{
    CLIPOBJ*            pcoBank;
    SURFOBJ*            psoBank;
    SIZEL               sizl;
    HSURF               hsurf;
    LONG                lDelta;
    LONG                cjBank;
    LONG                cPower2;

    // This routine may be called multiple times (e.g., each time
    // full-screen is exited), so make sure we do any allocations
    // only once:

    if (ppdev->pcoBank == NULL)
    {
        // Create a temporary clip object that we'll use for the bank
        // when we're given a Null or DC_TRIVIAL clip object:

        pcoBank = EngCreateClip();
        if (pcoBank == NULL)
            goto ReturnFalse;

        // We break every per-bank GDI call-back into simple rectangles:

        pcoBank->iDComplexity = DC_RECT;
        pcoBank->fjOptions    = OC_BANK_CLIP;

        // Create a GDI surface that we'll wrap around our bank in
        // call-backs:

        sizl.cx = ppdev->cxMemory;
        sizl.cy = ppdev->cyMemory;

        hsurf = (HSURF) EngCreateBitmap(sizl,
                                        ppdev->lDelta,
                                        ppdev->iBitmapFormat,
                                        BMF_TOPDOWN,
                                        ppdev->pjScreen);

        // Note that we hook zero calls -- after all, the entire point
        // of all this is to have GDI do all the drawing on the bank.
        // Once we're done the association, we can leave the surface
        // permanently locked:

        if ((hsurf == 0)                                        ||
            (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0))    ||
            (!(psoBank = EngLockSurface(hsurf))))
        {
            DISPDBG((0, "Failed wrapper surface creation"));

            EngDeleteSurface(hsurf);
            EngDeleteClip(pcoBank);

            goto ReturnFalse;
        }

        ppdev->pcoBank    = pcoBank;
        ppdev->psoBank    = psoBank;

        lDelta = ppdev->lDelta;
        cjBank = ppdev->cjBank;

        ASSERTDD(lDelta > 0, "Bad things happen with negative lDeltas");
        ASSERTDD(cjBank > lDelta, "Worse things happen with bad bank sizes");

        if (((lDelta & (lDelta - 1)) != 0) || ((cjBank & (cjBank - 1)) != 0))
        {
            // When either the screen stride or the bank size is not a power
            // of two, we have to use the slower 'bBankComputeNonPower2'
            // function for bank calculations, 'cause there can be broken
            // rasters and stuff:

            ppdev->pfnBankCompute = bBankComputeNonPower2;
        }
        else
        {
            // We can use the super duper fast bank calculator.  Yippie,
            // yahoo!  (I am easily amused.)

            cPower2 = 0;
            while (cjBank != lDelta)
            {
                cjBank >>= 1;
                cPower2++;
            }

            // We've just calculated that cjBank / lDelta = 2 ^ cPower2:

            ppdev->cPower2ScansPerBank = cPower2;

            while (cjBank != 1)
            {
                cjBank >>= 1;
                cPower2++;
            }

            // Continuing on, we've calculated that cjBank = 2 ^ cPower2:

            ppdev->cPower2BankSizeInBytes = cPower2;

            ppdev->pfnBankCompute = bBankComputePower2;
        }
    }

    // Warm up the hardware:

    if (!bBankInitialize(ppdev))
        goto ReturnFalse;

    vBankSelectMode(ppdev, BANK_ENABLE);

    DISPDBG((5, "Passed bEnableBanking"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableBanking!"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableBanking
*
\**************************************************************************/

VOID vDisableBanking(PDEV* ppdev)
{
    HSURF hsurf;

    if (ppdev->psoBank != NULL)
    {
        hsurf = ppdev->psoBank->hsurf;
        EngUnlockSurface(ppdev->psoBank);
        EngDeleteSurface(hsurf);
    }

    if (ppdev->pcoBank != NULL)
        EngDeleteClip(ppdev->pcoBank);

    if (ppdev->pBankInfo)
    {
        EngFreeMem(ppdev->pBankInfo);
    }
}

/******************************Public*Routine******************************\
* VOID vAssertModeBanking
*
\**************************************************************************/

VOID vAssertModeBanking(
PDEV*   ppdev,
BOOL    bEnable)
{
    // Inform the miniport bank code about the change in state:

    vBankSelectMode(ppdev, bEnable ? BANK_ENABLE : BANK_DISABLE);
}

/******************************Public*Routine******************************\
* BOOL bBankComputeNonPower2
*
* Given the bounds of the drawing operation described by 'prclDraw',
* computes the bank number and rectangle bounds for the first engine
* call back.
*
* Returns the bank number, 'prclBank' is the bounds for the first
* call-back, and 'pcjOffset' is the adjustment for 'pvScan0'.
*
* This routine does a couple of divides for the bank calculation.  We
* don't use a look-up table for banks because it's not straight forward
* to use with broken rasters, and with large amounts of video memory
* and small banks, the tables could get large.  We'd probably use it
* infrequently enough that the memory manager would be swapping it
* in and out whenever we touched it.
*
* Returns TRUE if prclDraw is entirely contained in one bank; FALSE if
* prclDraw spans multiple banks.
*
\**************************************************************************/

BOOL bBankComputeNonPower2( // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG cjBufferOffset;
    LONG iBank;
    LONG cjBank;
    LONG cjBankOffset;
    LONG cjBankRemainder;
    LONG cjScan;
    LONG cScansInBank;
    LONG cjScanRemainder;
    LONG lDelta;
    BOOL bOneBank;

    bOneBank = FALSE;
    lDelta   = ppdev->lDelta;

    cjBufferOffset  = prclDraw->top * lDelta
                    + (prclDraw->left << ppdev->cPelSize);

    cjBank          = ppdev->cjBank;

    // iBank        = cjBufferOffset / cjBank;
    // cjBankOffset = cjBufferOffset % cjBank;

    QUOTIENT_REMAINDER(cjBufferOffset, cjBank, iBank, cjBankOffset);

    *piBank         = iBank;
    *pcjOffset      = iBank * cjBank;
    cjBankRemainder = cjBank - cjBankOffset;
    cjScan          = (prclDraw->right - prclDraw->left) << ppdev->cPelSize;

    if (cjBankRemainder < cjScan)
    {
        // Oh no, we've got a broken raster!

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->left +
                           (cjBankRemainder >> ppdev->cPelSize);
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + 1;
    }
    else
    {
        // cScansInBank    = cjBankRemainder / lDelta;
        // cjScanRemainder = cjBankRemainder % lDelta;

        ASSERTDD(lDelta > 0, "We assume positive lDelta here");

        QUOTIENT_REMAINDER(cjBankRemainder, lDelta,
                           cScansInBank, cjScanRemainder);

        if (cjScanRemainder >= cjScan)
        {
            // The bottom scan of the bank may be broken, but it breaks after
            // any drawing we'll be doing on that scan.  So we can simply
            // add the scan to this bank:

            cScansInBank++;
        }

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->right;
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + cScansInBank;

        if (prclBank->bottom >= prclDraw->bottom)
        {
            prclBank->bottom  = prclDraw->bottom;
            bOneBank          = TRUE;
        }
    }

    return(bOneBank);
}

/******************************Public*Routine******************************\
* BOOL bBankComputePower2
*
* Functions the same as 'bBankComputeNonPower2', except that it is
* an accelerated special case for when both the screen stride and bank
* size are powers of 2.
*
\**************************************************************************/

BOOL bBankComputePower2(    // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG iBank;
    LONG yTopNextBank;
    BOOL bOneBank;

    iBank        = prclDraw->top >> ppdev->cPower2ScansPerBank;
    yTopNextBank = (iBank + 1) << ppdev->cPower2ScansPerBank;
    *piBank      = iBank;
    *pcjOffset   = iBank << ppdev->cPower2BankSizeInBytes;

    prclBank->left   = prclDraw->left;
    prclBank->right  = prclDraw->right;
    prclBank->top    = prclDraw->top;
    prclBank->bottom = yTopNextBank;

    bOneBank = FALSE;
    if (prclBank->bottom >= prclDraw->bottom)
    {
        prclBank->bottom  = prclDraw->bottom;
        bOneBank          = TRUE;
    }

    return(bOneBank);
}

#if GDI_BANKING                 // GDI can't draw directly in the framebuffer
                                //   when running on the Alpha

/******************************Public*Routine******************************\
* VOID vBankStart
*
* Given the bounds of the drawing operation described by 'prclDraw' and
* the original clip object, maps in the first bank and returns in
* 'pbnk->pco' and 'pbnk->pso' the CLIPOBJ and SURFOBJ to be passed to the
* engine for the first banked call-back.
*
* Note: This routine only supports the screen being the destination, and
*       not the source.  We have a separate, faster routine for doing
*       SRCCOPY reads from the screen, so it isn't worth the extra code
*       size to implement.
*
\**************************************************************************/

VOID vBankStart(
PDEV*       ppdev,      // Physical device information.
RECTL*      prclDraw,   // Rectangle bounding the draw area, in relative
                        //  coordinates.  Note that 'left' and 'right'
                        //  should be set for correct handling with broken
                        //  rasters.
CLIPOBJ*    pco,        // Original drawing clip object (may be modified).
BANK*       pbnk)       // Resulting bank information.
{
    LONG cjOffset;
    LONG xOffset;
    LONG yOffset;

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        pco = ppdev->pcoBank;

        // Reset the clipping flag to trivial because we may have left
        // it as rectangular in a previous call:

        pco->iDComplexity = DC_TRIVIAL;

        // At the same time we convert to absolute coordinates, make sure
        // we won't try to enumerate past the bounds of the screen:

        pbnk->rclDraw.left       = prclDraw->left   + xOffset;
        pbnk->rclDraw.right      = prclDraw->right  + xOffset;

        pbnk->rclDraw.top
            = max(0,               prclDraw->top    + yOffset);
        pbnk->rclDraw.bottom
            = min(ppdev->cyMemory, prclDraw->bottom + yOffset);
    }
    else
    {
        pbnk->rclSaveBounds    = pco->rclBounds;
        pbnk->iSaveDComplexity = pco->iDComplexity;
        pbnk->fjSaveOptions    = pco->fjOptions;

        // Let GDI know that it has to pay attention to the clip object:

        pco->fjOptions |= OC_BANK_CLIP;

        // We have to honour the original clip object's rclBounds, so
        // intersect the drawing region with it, then convert to absolute
        // coordinates:

        pbnk->rclDraw.left
            = max(prclDraw->left,   pco->rclBounds.left)   + xOffset;
        pbnk->rclDraw.right
            = min(prclDraw->right,  pco->rclBounds.right)  + xOffset;
        pbnk->rclDraw.top
            = max(prclDraw->top,    pco->rclBounds.top)    + yOffset;
        pbnk->rclDraw.bottom
            = min(prclDraw->bottom, pco->rclBounds.bottom) + yOffset;
    }

    if ((pbnk->rclDraw.left > pbnk->rclDraw.right)
     || (pbnk->rclDraw.top  > pbnk->rclDraw.bottom))
    {
        // It's conceivable that we could get a situation where we have
        // an empty draw rectangle.  Make sure we won't puke on our shoes:

        pbnk->rclDraw.left   = 0;
        pbnk->rclDraw.right  = 0;
        pbnk->rclDraw.top    = 0;
        pbnk->rclDraw.bottom = 0;
    }

    if (!ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                               &cjOffset, &pbnk->iBank))
    {
        // The drawing operation spans multiple banks.  If the original
        // clip object was marked as trivial, we have to make sure to
        // change it to rectangular so that GDI knows to pay attention
        // to the bounds of the bank:

        if (pco->iDComplexity == DC_TRIVIAL)
            pco->iDComplexity = DC_RECT;
    }

    pbnk->ppdev = ppdev;
    pbnk->pco   = pco;
    pbnk->pso   = ppdev->psoBank;

    // Convert rclBounds and pvScan0 from absolute coordinates back to
    // relative.  When GDI calculates where to start drawing, it computes
    // pjDst = pso->pvScan0 + y * pso->lDelta + (x << cPelSize), where 'x'
    // and 'y' are relative coordinates.  We'll muck with pvScan0 to get
    // it pointing to the correct spot in the bank:

    pbnk->pso->pvScan0 = ppdev->pjScreen - cjOffset
                       + yOffset * ppdev->lDelta
                       + (xOffset << ppdev->cPelSize);

    ASSERTDD((((ULONG_PTR) pbnk->pso->pvScan0) & 3) == 0,
             "Off-screen bitmaps must be dword aligned");

    pco->rclBounds.left   -= xOffset;
    pco->rclBounds.right  -= xOffset;
    pco->rclBounds.top    -= yOffset;
    pco->rclBounds.bottom -= yOffset;

    // Enable banking and map in bank iBank:

    vBankSelectMode(ppdev, BANK_ON);
    vBankMap(ppdev, pbnk->iBank);
}

/******************************Public*Routine******************************\
* BOOL bBankEnum
*
* If there is another bank to be drawn on, maps in the bank and returns
* TRUE and the CLIPOBJ and SURFOBJ to be passed in the banked call-back.
*
* If there were no more banks to be drawn, returns FALSE.
*
\**************************************************************************/

BOOL bBankEnum(
BANK* pbnk)
{
    LONG     iBank;
    LONG     cjOffset;
    PDEV*    ppdev;
    CLIPOBJ* pco;
    LONG     xOffset;
    LONG     yOffset;

    ppdev   = pbnk->ppdev;
    pco     = pbnk->pco;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    // We check here to see if we have to handle the second part of
    // a broken raster.  Recall that pbnk->rclDraw is in absolute
    // coordinates, but pco->rclBounds is in relative coordinates:

    if (pbnk->rclDraw.right - xOffset != pco->rclBounds.right)
    {
        // The clip object's 'top' and 'bottom' are already correct:

        pco->rclBounds.left  = pco->rclBounds.right;
        pco->rclBounds.right = pbnk->rclDraw.right - xOffset;

        pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;
        pbnk->iBank++;

        vBankMap(ppdev, pbnk->iBank);

        return(TRUE);
    }

    if (pbnk->rclDraw.bottom > pco->rclBounds.bottom + yOffset)
    {
        // Advance the drawing area 'top' to account for the bank we've
        // just finished, and map in the new bank:

        pbnk->rclDraw.top = pco->rclBounds.bottom + yOffset;

        ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                              &cjOffset, &iBank);

        // Convert rclBounds back from absolute to relative coordinates:

        pco->rclBounds.left   -= xOffset;
        pco->rclBounds.right  -= xOffset;
        pco->rclBounds.top    -= yOffset;
        pco->rclBounds.bottom -= yOffset;

        // If we just finished handling a broken raster, we've already
        // got the bank mapped in:

        if (iBank != pbnk->iBank)
        {
            pbnk->iBank = iBank;
            pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;

            vBankMap(ppdev, iBank);
        }

        return(TRUE);
    }

    // We're done!  Turn off banking and reset the clip object if necessary:

    vBankSelectMode(ppdev, BANK_OFF);

    if (pco != ppdev->pcoBank)
    {
        pco->rclBounds    = pbnk->rclSaveBounds;
        pco->iDComplexity = pbnk->iSaveDComplexity;
        pco->fjOptions    = pbnk->fjSaveOptions;
    }

    return(FALSE);
}

#endif // GDI_BANKING

/******************************Public*Routine******************************\
* VOID vAlignedCopy
*
* Copies the given portion of a bitmap, using dword alignment for the
* screen.  Note that this routine has no notion of banking.
*
* Updates ppjDst and ppjSrc to point to the beginning of the next scan.
*
\**************************************************************************/

VOID vAlignedCopy(
BYTE**  ppjDst,
LONG    lDstDelta,
BYTE**  ppjSrc,
LONG    lSrcDelta,
LONG    cjScan,
LONG    cyScan,
BOOL    bDstIsScreen)
{
    BYTE* pjDst;
    BYTE* pjSrc;
    LONG  cjMiddle;
    LONG  culMiddle;
    LONG  cjStartPhase;
    LONG  cjEndPhase;

    pjSrc = *ppjSrc;
    pjDst = *ppjDst;

    cjStartPhase = (LONG)((0 - ((bDstIsScreen) ? (ULONG_PTR) pjDst
                                               : (ULONG_PTR) pjSrc)) & 3);
    cjMiddle     = cjScan - cjStartPhase;

    if (cjMiddle < 0)
    {
        cjStartPhase = 0;
        cjMiddle     = cjScan;
    }

    lSrcDelta -= cjScan;
    lDstDelta -= cjScan;            // Account for middle

    cjEndPhase = cjMiddle & 3;
    culMiddle  = cjMiddle >> 2;

    #if defined(i386)
    {
        _asm {
            mov     eax,lSrcDelta   ; eax = Source delta accounting for middle
            mov     ebx,lDstDelta   ; ebx = Dest delta accounting for middle
            mov     edx,cyScan      ; edx = Count of scans
            mov     esi,pjSrc       ; esi = Source pointer
            mov     edi,pjDst       ; edi = Dest pointer

        Next_Scan:

            mov     ecx,cjStartPhase
            rep     movsb

            mov     ecx,culMiddle
            rep     movsd

            mov     ecx,cjEndPhase
            rep     movsb

            add     esi,eax         ; Advance to next scan
            add     edi,ebx
            dec     edx
            jnz     Next_Scan

            mov     eax,ppjSrc      ; Save the updated pointers
            mov     ebx,ppjDst
            mov     [eax],esi
            mov     [ebx],edi
        }
    }
    #else
    {
        LONG i;

        // Because of its bus design, we cannot do a straight memcpy
        // to/from the frame buffer on an Alpha -- we have to go
        // through WRITE/READ macros.

        // First, to be safe, flush all pending I/O:

        MEMORY_BARRIER();

        if (bDstIsScreen)
        {
            // Align to the destination (implying that the source may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjSrc += sizeof(ULONG UNALIGNED);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }
        else
        {
            // Align to the source (implying that the destination may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    #if !defined(ALPHA)
                    {
                        *((ULONG UNALIGNED *) pjDst) = READ_REGISTER_ULONG(pjSrc);
                    }
                    #else
                    {
                        // There are some board 864/964 boards where we can't
                        // do dword reads from the frame buffer without
                        // crashing the Avanti.

                        *((ULONG UNALIGNED *) pjDst) =
                         ((ULONG) READ_REGISTER_UCHAR(pjSrc + 3) << 24) |
                         ((ULONG) READ_REGISTER_UCHAR(pjSrc + 2) << 16) |
                         ((ULONG) READ_REGISTER_UCHAR(pjSrc + 1) << 8)  |
                         ((ULONG) READ_REGISTER_UCHAR(pjSrc));
                    }
                    #endif

                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG UNALIGNED);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }

        *ppjSrc = pjSrc;            // Save the updated pointers
        *ppjDst = pjDst;
    }
    #endif
}

/******************************Public*Routine******************************\
* VOID vPutBits
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vPutBits(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,            // Absolute coordinates!
POINTL*     pptlSrc)            // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    // We need a local copy of 'rclDraw' because we'll be iteratively
    // modifying 'top' and passing the modified rectangle back into
    // bBankComputeNonPower2:

    rclDraw = *prclDst;

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    // Compute the first bank, enable banking, then map in iBank:

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    vBankSelectMode(ppdev, BANK_ON);
    vBankMap(ppdev, iBank);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lDstDelta = ppdev->lDelta;
    pjDst     = ppdev->pjScreen + rclDraw.top  * lDstDelta
                                + (rclDraw.left << ppdev->cPelSize)
                                - cjOffset;

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0 + pptlSrc->y * lSrcDelta
                                        + (pptlSrc->x << ppdev->cPelSize);

    while (TRUE)
    {
        cjScan = (rclBank.right  - rclBank.left) << ppdev->cPelSize;
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(&pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     TRUE);             // Screen is the destination

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;

            vBankMap(ppdev, iBank);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = (rclDraw.right - rclBank.right) << ppdev->cPelSize;

            // Account for the fact that we're now one bank lower in the
            // destination:

            pjDst -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan:

            #if GDI_BANKING
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            #else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(&pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             TRUE);    // Screen is the destination
            }
            #endif
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjDst -= ppdev->cjBank;
                iBank = iNewBank;

                vBankMap(ppdev, iBank);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            vBankSelectMode(ppdev, BANK_OFF);

            return;
        }
    }
}

/******************************Public*Routine******************************\
* VOID vGetBits
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBits(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    rclDraw.left   = pptlSrc->x;
    rclDraw.top    = pptlSrc->y;
    rclDraw.right  = rclDraw.left + (prclDst->right  - prclDst->left);
    rclDraw.bottom = rclDraw.top  + (prclDst->bottom - prclDst->top);

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    // Compute the first bank, enable banking, then map in iBank.

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    vBankSelectMode(ppdev, BANK_ON);
    vBankMap(ppdev, iBank);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lSrcDelta = ppdev->lDelta;
    pjSrc     = ppdev->pjScreen + rclDraw.top  * lSrcDelta
                                + (rclDraw.left << ppdev->cPelSize)
                                - cjOffset;

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + prclDst->top  * lDstDelta
                                        + (prclDst->left << ppdev->cPelSize);

    while (TRUE)
    {
        cjScan = (rclBank.right  - rclBank.left) << ppdev->cPelSize;
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(&pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     FALSE);            // Screen is the source

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;

            vBankMap(ppdev, iBank);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = (rclDraw.right - rclBank.right) << ppdev->cPelSize;

            // Account for the fact that we're now one bank lower in the
            // source:

            pjSrc -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan.  Note that we don't have to
            // advance the pointers because they're already pointing to the
            // beginning of the next scan:

            #if GDI_BANKING
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            #else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(&pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             FALSE);    // Screen is the source
            }
            #endif
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjSrc -= ppdev->cjBank;
                iBank = iNewBank;

                vBankMap(ppdev, iBank);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            vBankSelectMode(ppdev, BANK_OFF);

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\cirrus\mini\i386\clvga.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  EGA.INC
;
; This file contains the definitions of the EGA registers used by
; the driver.
;
; Copyright (c) 1988-1993 Microsoft Corporation
;
; General Description:
;
;-----------------------------------------------------------------------;

HW_POINTER_LEN equ 100h            ;# of VGA addresses used by hardware

SEQ_EXT_MODE     equ     007h           ; Extended Sequencer Mode index
SEQ_HIRES_MODE   equ     001h           ; select true packed pixel addressing
SEQ_PX           equ     010h           ; X start index
SEQ_PY           equ     011h           ; Y start index
SEQ_PPA          equ     013h           ;pointer pattern address index

AVGA_PROA               equ     009h    ;banking control register
AVGA_MODE_EXTENSIONS    equ     00Bh
EXT_WR_MODES    equ     24h             ; enable extended write modes in GRB

SEQ_EXT_WRITE_CONTROL equ 0f3h

PTR_HEIGHT      equ     32              ;height of hardware pointer in scans
PTR_WIDTH       equ     4               ;width of hardware pointer in bytes
PTR_WIDTH_IN_PIXELS equ     32          ;width of hardware pointer in pixels
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/

#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)
#define STATEDBG(level)
#define LOGDBG(arg)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define STATEDBG(level)
#define LOGDBG(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
* level stuff lives in 'blt.c'.
*
* !!! Change note about 'iType'
*
* Note: Since we've implemented device-bitmaps, any surface that GDI passes
*       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
*       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
*       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
*       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
*       surfaces (e.g., a blt from an off-screen device bitmap to the screen
*       gets treated as a normal screen-to-screen blt).  So throughout
*       this code, we will compare a surface's 'iType' to STYPE_BITMAP:
*       if it's equal, we've got a true DIB, and if it's unequal, we have
*       a screen-to-screen operation.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Data*********************************\
* Rop-needs-pattern table
*
* Determines if a rop2 needs uses a pattern.
*
* Use 'gabRopNeedsPattern[(rop3 >> 2) & 0xf]', but note that this can only
* be done if it is known that the rop3 doesn't use a source.
*
\**************************************************************************/

BYTE gabRopNeedsPattern[] =
{
    FALSE, // R2_BLACK
    TRUE,  // R2_NOTMERGEPEN
    TRUE,  // R2_MASKNOTPEN
    TRUE,  // R2_NOTCOPYPEN
    TRUE,  // R2_MASKPENNOT
    FALSE, // R2_NOT
    TRUE,  // R2_XORPEN
    TRUE,  // R2_NOTMASKPEN
    TRUE,  // R2_MASKPEN
    TRUE,  // R2_NOTXORPEN
    FALSE, // R2_NOP
    TRUE,  // R2_MERGENOTPEN
    TRUE,  // R2_COPYPEN
    TRUE,  // R2_MERGEPENNOT
    TRUE,  // R2_MERGEPEN
    FALSE, // R2_WHITE
};

/******************************Public*Data*********************************\
* Mix-needs-pattern table
*
* Determines if a mix uses a pattern.
*
* Use 'gabMixNeedsPattern[mix & 0xf]' or 'gabMixNeedsPattern[mix & 0xff]'.
*
\**************************************************************************/

BYTE gabMixNeedsPattern[] =
{
    FALSE, // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0x0F]
    FALSE, // R2_BLACK
    TRUE,  // R2_NOTMERGEPEN
    TRUE,  // R2_MASKNOTPEN
    TRUE,  // R2_NOTCOPYPEN
    TRUE,  // R2_MASKPENNOT
    FALSE, // R2_NOT
    TRUE,  // R2_XORPEN
    TRUE,  // R2_NOTMASKPEN
    TRUE,  // R2_MASKPEN
    TRUE,  // R2_NOTXORPEN
    FALSE, // R2_NOP
    TRUE,  // R2_MERGENOTPEN
    TRUE,  // R2_COPYPEN
    TRUE,  // R2_MERGEPENNOT
    TRUE,  // R2_MERGEPEN
    FALSE, // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0xFF]
};

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaRop3FromMix[] =
{
    0xFF,  // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0xFF]
};

#if DBG || !GDI_BANKING

// This table is big, so we only use to aid in debugging...

/******************************Public*Data*********************************\
* ROP3 translation table - Use only for debugging
*
* Translates the usual ternary rop into A-vector notation.  Each bit in
* this new notation corresponds to a term in a polynomial translation of
* the rop.
*
* Rop(D,S,P) = a + a D + a S + a P + a  DS + a  DP + a  SP + a   DSP
*               0   d     s     p     ds      dp      sp      dsp
*
\**************************************************************************/

BYTE gajRop3[] =
{
    0x00, 0xff, 0xb2, 0x4d, 0xd4, 0x2b, 0x66, 0x99,
    0x90, 0x6f, 0x22, 0xdd, 0x44, 0xbb, 0xf6, 0x09,
    0xe8, 0x17, 0x5a, 0xa5, 0x3c, 0xc3, 0x8e, 0x71,
    0x78, 0x87, 0xca, 0x35, 0xac, 0x53, 0x1e, 0xe1,
    0xa0, 0x5f, 0x12, 0xed, 0x74, 0x8b, 0xc6, 0x39,
    0x30, 0xcf, 0x82, 0x7d, 0xe4, 0x1b, 0x56, 0xa9,
    0x48, 0xb7, 0xfa, 0x05, 0x9c, 0x63, 0x2e, 0xd1,
    0xd8, 0x27, 0x6a, 0x95, 0x0c, 0xf3, 0xbe, 0x41,
    0xc0, 0x3f, 0x72, 0x8d, 0x14, 0xeb, 0xa6, 0x59,
    0x50, 0xaf, 0xe2, 0x1d, 0x84, 0x7b, 0x36, 0xc9,
    0x28, 0xd7, 0x9a, 0x65, 0xfc, 0x03, 0x4e, 0xb1,
    0xb8, 0x47, 0x0a, 0xf5, 0x6c, 0x93, 0xde, 0x21,
    0x60, 0x9f, 0xd2, 0x2d, 0xb4, 0x4b, 0x06, 0xf9,
    0xf0, 0x0f, 0x42, 0xbd, 0x24, 0xdb, 0x96, 0x69,
    0x88, 0x77, 0x3a, 0xc5, 0x5c, 0xa3, 0xee, 0x11,
    0x18, 0xe7, 0xaa, 0x55, 0xcc, 0x33, 0x7e, 0x81,
    0x80, 0x7f, 0x32, 0xcd, 0x54, 0xab, 0xe6, 0x19,
    0x10, 0xef, 0xa2, 0x5d, 0xc4, 0x3b, 0x76, 0x89,
    0x68, 0x97, 0xda, 0x25, 0xbc, 0x43, 0x0e, 0xf1,
    0xf8, 0x07, 0x4a, 0xb5, 0x2c, 0xd3, 0x9e, 0x61,
    0x20, 0xdf, 0x92, 0x6d, 0xf4, 0x0b, 0x46, 0xb9,
    0xb0, 0x4f, 0x02, 0xfd, 0x64, 0x9b, 0xd6, 0x29,
    0xc8, 0x37, 0x7a, 0x85, 0x1c, 0xe3, 0xae, 0x51,
    0x58, 0xa7, 0xea, 0x15, 0x8c, 0x73, 0x3e, 0xc1,
    0x40, 0xbf, 0xf2, 0x0d, 0x94, 0x6b, 0x26, 0xd9,
    0xd0, 0x2f, 0x62, 0x9d, 0x04, 0xfb, 0xb6, 0x49,
    0xa8, 0x57, 0x1a, 0xe5, 0x7c, 0x83, 0xce, 0x31,
    0x38, 0xc7, 0x8a, 0x75, 0xec, 0x13, 0x5e, 0xa1,
    0xe0, 0x1f, 0x52, 0xad, 0x34, 0xcb, 0x86, 0x79,
    0x70, 0x8f, 0xc2, 0x3d, 0xa4, 0x5b, 0x16, 0xe9,
    0x08, 0xf7, 0xba, 0x45, 0xdc, 0x23, 0x6e, 0x91,
    0x98, 0x67, 0x2a, 0xd5, 0x4c, 0xb3, 0xfe, 0x01
};

#define AVEC_NOT            0x01
#define AVEC_D              0x02
#define AVEC_S              0x04
#define AVEC_P              0x08
#define AVEC_DS             0x10
#define AVEC_DP             0x20
#define AVEC_SP             0x40
#define AVEC_DSP            0x80
#define AVEC_NEED_SOURCE    (AVEC_S | AVEC_DS | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_PATTERN   (AVEC_P | AVEC_DP | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_DEST      (AVEC_D | AVEC_DS | AVEC_DP | AVEC_DSP)

#endif // DBG

/******************************Public*Table********************************\
* BYTE gajLeftMask[] and BYTE gajRightMask[]
*
* Edge tables for vXferScreenTo1bpp.
\**************************************************************************/

BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* VOID vXferScreenTo1bpp
*
* Performs a SRCCOPY transfer from the screen (when it's 8bpp) to a 1bpp
* bitmap.
*
\**************************************************************************/

#if defined(i386)

VOID vXferScreenTo1bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       ulHwMix,            // Not used
SURFOBJ*    psoDst,             // Destination surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Provides colour-compressions information
{
    LONG    cjPel;
    VOID*   pfnCompute;
    SURFOBJ soTmp;
    ULONG*  pulXlate;
    ULONG   ulForeColor;
    POINTL  ptlSrc;
    RECTL   rclTmp;
    BYTE*   pjDst;
    BYTE    jLeftMask;
    BYTE    jRightMask;
    BYTE    jNotLeftMask;
    BYTE    jNotRightMask;
    LONG    cjMiddle;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    LONG    cyTmpScans;
    LONG    cyThis;
    LONG    cyToGo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations");
    ASSERTDD(TMP_BUFFER_SIZE >= (ppdev->cxMemory * ppdev->cjPel),
                "Temp buffer has to be larger than widest possible scan");

    // When the destination is a 1bpp bitmap, the foreground colour
    // maps to '1', and any other colour maps to '0'.

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // When the source is 8bpp or less, we find the forground colour
        // by searching the translate table for the only '1':

        pulXlate = pxlo->pulXlate;
        while (*pulXlate != 1)
            pulXlate++;

        ulForeColor = pulXlate - pxlo->pulXlate;
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This routine only supports 8, 16 or 32bpp");

        // When the source has a depth greater than 8bpp, the foreground
        // colour will be the first entry in the translate table we get
        // from calling 'piVector':

        pulXlate = XLATEOBJ_piVector(pxlo);

        ulForeColor = 0;
        if (pulXlate != NULL)           // This check isn't really needed...
            ulForeColor = pulXlate[0];
    }

    // We use the temporary buffer to keep a copy of the source
    // rectangle:

    soTmp.pvScan0 = ppdev->pvTmpBuffer;

    do {
        // ptlSrc points to the upper-left corner of the screen rectangle
        // for the current batch:

        ptlSrc.x = prcl->left + (pptlSrc->x - prclDst->left);
        ptlSrc.y = prcl->top  + (pptlSrc->y - prclDst->top);

        // vGetBits takes absolute coordinates for the source point:

        ptlSrc.x += ppdev->xOffset;
        ptlSrc.y += ppdev->yOffset;

        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta)
                                        + (prcl->left >> 3);

        cjPel = ppdev->cjPel;

        soTmp.lDelta = (((prcl->right + 7L) & ~7L) - (prcl->left & ~7L))
                       * cjPel;

        // Our temporary buffer, into which we read a copy of the source,
        // may be smaller than the source rectangle.  In that case, we
        // process the source rectangle in batches.
        //
        // cyTmpScans is the number of scans we can do in each batch.
        // cyToGo is the total number of scans we have to do for this
        // rectangle.
        //
        // We take the buffer size less four so that the right edge case
        // can safely read one dword past the end:

        cyTmpScans = (TMP_BUFFER_SIZE - 4) / soTmp.lDelta;
        cyToGo     = prcl->bottom - prcl->top;

        ASSERTDD(cyTmpScans > 0, "Buffer too small for largest possible scan");

        // Initialize variables that don't change within the batch loop:

        rclTmp.top    = 0;
        rclTmp.left   = prcl->left & 7L;
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left;

        // Note that we have to be careful with the right mask so that it
        // isn't zero.  A right mask of zero would mean that we'd always be
        // touching one byte past the end of the scan (even though we
        // wouldn't actually be modifying that byte), and we must never
        // access memory past the end of the bitmap (because we can access
        // violate if the bitmap end is exactly page-aligned).

        jLeftMask     = gajLeftMask[rclTmp.left & 7];
        jRightMask    = gajRightMask[rclTmp.right & 7];
        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1;

        if (cjMiddle < 0)
        {
            // The blt starts and ends in the same byte:

            jLeftMask &= jRightMask;
            jRightMask = 0;
            cjMiddle   = 0;
        }

        jNotLeftMask  = ~jLeftMask;
        jNotRightMask = ~jRightMask;
        lDstDelta     = psoDst->lDelta - cjMiddle - 2;
                                // Delta from the end of the destination
                                //  to the start on the next scan, accounting
                                //  for 'left' and 'right' bytes

        lSrcDelta     = soTmp.lDelta - ((8 * (cjMiddle + 2)) * cjPel);
                                // Compute source delta for special cases
                                //  like when cjMiddle gets bumped up to '0',
                                //  and to correct aligned cases

        do {
            // This is the loop that breaks the source rectangle into
            // manageable batches.

            cyThis  = cyTmpScans;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            rclTmp.bottom = cyThis;

            vGetBits(ppdev, &soTmp, &rclTmp, &ptlSrc);

            ptlSrc.y += cyThis;         // Get ready for next batch loop

            _asm {
                mov     eax,ulForeColor     ;eax = foreground colour
                                            ;ebx = temporary storage
                                            ;ecx = count of middle dst bytes
                                            ;dl  = destination byte accumulator
                                            ;dh  = temporary storage
                mov     esi,soTmp.pvScan0   ;esi = source pointer
                mov     edi,pjDst           ;edi = destination pointer

                ; Figure out the appropriate compute routine:

                mov     ebx,cjPel
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp
                dec     ebx
                jz      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp

            Do_Left_Byte:
                call    pfnCompute
                and     dl,jLeftMask
                mov     dh,jNotLeftMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi
                mov     ecx,cjMiddle
                dec     ecx
                jl      short Do_Right_Byte

            Do_Middle_Bytes:
                call    pfnCompute
                mov     [edi],dl
                inc     edi
                dec     ecx
                jge     short Do_Middle_Bytes

            Do_Right_Byte:
                call    pfnCompute
                and     dl,jRightMask
                mov     dh,jNotRightMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi

                add     edi,lDstDelta
                add     esi,lSrcDelta
                dec     cyThis
                jnz     short Do_Left_Byte

                mov     pjDst,edi               ;save for next batch

                jmp     All_Done

            Compute_Destination_Byte_From_8bpp:
                mov     bl,[esi]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 0

                mov     bl,[esi+1]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 1

                mov     bl,[esi+2]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 2

                mov     bl,[esi+3]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 3

                mov     bl,[esi+4]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 4

                mov     bl,[esi+5]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 5

                mov     bl,[esi+6]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 6

                mov     bl,[esi+7]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 7

                add     esi,8                   ;advance the source
                ret

            Compute_Destination_Byte_From_16bpp:
                mov     bx,[esi]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 0

                mov     bx,[esi+2]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 1

                mov     bx,[esi+4]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 2

                mov     bx,[esi+6]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 3

                mov     bx,[esi+8]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 4

                mov     bx,[esi+10]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 5

                mov     bx,[esi+12]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 6

                mov     bx,[esi+14]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 7

                add     esi,16                  ;advance the source
                ret

            Compute_Destination_Byte_From_32bpp:
                mov     ebx,[esi]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 0

                mov     ebx,[esi+4]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 1

                mov     ebx,[esi+8]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 2

                mov     ebx,[esi+12]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 3

                mov     ebx,[esi+16]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 4

                mov     ebx,[esi+20]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 5

                mov     ebx,[esi+24]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 6

                mov     ebx,[esi+28]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 7

                add     esi,32                  ;advance the source
                ret

            All_Done:
            }
        } while (cyToGo > 0);

        prcl++;
    } while (--c != 0);
}

#endif // i386

/******************************Public*Routine******************************\
* BOOL bPuntBlt
*
* Has GDI do any drawing operations that we don't specifically handle
* in the driver.
*
\**************************************************************************/

BOOL bPuntBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    #if DBG
    {
        //////////////////////////////////////////////////////////////////////
        // Diagnostics
        //
        // Since calling the engine to do any drawing can be rather painful,
        // particularly when the source is an off-screen DFB (since GDI will
        // have to allocate a DIB and call us to make a temporary copy before
        // it can even start drawing), we'll try to avoid it as much as
        // possible.
        //
        // Here we simply spew out information describing the blt whenever
        // this routine gets called (checked builds only, of course):

        ULONG ulClip;
        PDEV* ppdev;
        ULONG ulAvec;

        if (psoDst->dhpdev != NULL)
            ppdev = (PDEV*) psoDst->dhpdev;
        else
            ppdev = (PDEV*) psoSrc->dhpdev;

        ulClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        DISPDBG((3, ">> Punt << Dst format: %li Dst type: %li Clip: %li Rop: %lx",
            psoDst->iBitmapFormat, psoDst->iType, ulClip, rop4));

        if (psoSrc != NULL)
            DISPDBG((3, "        << Src format: %li Src type: %li",
                psoSrc->iBitmapFormat, psoSrc->iType));

        if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL) && (psoSrc != NULL))
        {
            if (((psoSrc->dhsurf == NULL) &&
                 (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)) ||
                ((psoDst->dhsurf == NULL) &&
                 (psoDst->iBitmapFormat != ppdev->iBitmapFormat)))
            {
                // Don't bother printing the 'xlate' message when the source
                // is a different bitmap format from the destination -- in
                // those cases we know there always has to be a translate.
            }
            else
            {
                DISPDBG((3, "        << With xlate"));
            }
        }

        // The high 2 bytes of rop4 is not guaranteed to be zero. So in order
        // to get the low 8 bits as index, we have to &ffff before do >>
        ulAvec = gajRop3[rop4 & 0xff] | gajRop3[(rop4 & 0xffff) >> 8];

        if ((ulAvec & AVEC_NEED_PATTERN) && (pbo->iSolidColor == -1))
        {
            if (pbo->pvRbrush == NULL)
                DISPDBG((3, "        << With brush -- Not created"));
            else
                DISPDBG((3, "        << With brush -- Created Ok"));
        }
    }
    #endif

    #if GDI_BANKING
    {
        //////////////////////////////////////////////////////////////////////
        // Banked Framebuffer bPuntBlt
        //
        // This section of code handles a PuntBlt when GDI can directly draw
        // on the framebuffer, but the drawing has to be done in banks:

        BANK     bnk;
        PDEV*    ppdev;
        BOOL     b;
        HSURF    hsurfTmp;
        SURFOBJ* psoTmp;
        SIZEL    sizl;
        POINTL   ptlSrc;
        RECTL    rclTmp;
        RECTL    rclDst;

        b = FALSE;          // Fore error cases, assume we'll fail

        // We copy the original destination rectangle, and use that in every
        // GDI call-back instead of the original because sometimes GDI is
        // sneaky and points 'prclDst' to '&pco->rclBounds'.  Because we
        // modify 'rclBounds', that would affect 'prclDst', which we don't
        // want to happen:

        rclDst = *prclDst;

        if ((psoSrc == NULL) || (psoSrc->dhsurf == NULL))
        {
            ASSERTDD(psoDst->dhsurf != NULL,
                     "Dest should be the screen when given a DIB source");

            // Do a memory-to-screen blt:

            ppdev = (PDEV*) psoDst->dhpdev;

            vBankStart(ppdev, &rclDst, pco, &bnk);

            b = TRUE;
            do {
                b &= EngBitBlt(bnk.pso, psoSrc, psoMsk, bnk.pco, pxlo,
                               &rclDst, pptlSrc, pptlMsk, pbo, pptlBrush,
                               rop4);

            } while (bBankEnum(&bnk));
        }
        else
        {
            // The screen is the source (it may be the destination too...)

            ppdev = (PDEV*) psoSrc->dhpdev;

            ptlSrc.x = pptlSrc->x + ppdev->xOffset;
            ptlSrc.y = pptlSrc->y + ppdev->yOffset;

            if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
            {
                // We have to intersect the destination rectangle with
                // the clip bounds if there is one (consider the case
                // where the app asked to blt a really, really big
                // rectangle from the screen -- prclDst would be really,
                // really big but pco->rclBounds would be the actual
                // area of interest):

                rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
                rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
                rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
                rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

                // Correspondingly, we have to offset the source point:

                ptlSrc.x += (rclDst.left - prclDst->left);
                ptlSrc.y += (rclDst.top - prclDst->top);
            }

            // We're now either going to do a screen-to-screen or screen-to-DIB
            // blt.  In either case, we're going to create a temporary copy of
            // the source.  (Why do we do this when GDI could do it for us?
            // GDI would create a temporary copy of the DIB for every bank
            // call-back!)

            sizl.cx = rclDst.right  - rclDst.left;
            sizl.cy = rclDst.bottom - rclDst.top;

            // Don't forget to convert from relative to absolute coordinates
            // on the source!  (vBankStart takes care of that for the
            // destination.)

            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;
            rclTmp.left   = 0;
            rclTmp.top    = 0;

            // GDI does guarantee us that the blt extents have already been
            // clipped to the surface boundaries (we don't have to worry
            // here about trying to read where there isn't video memory).
            // Let's just assert to make sure:

            ASSERTDD((ptlSrc.x >= 0) &&
                     (ptlSrc.y >= 0) &&
                     (ptlSrc.x + sizl.cx <= ppdev->cxMemory) &&
                     (ptlSrc.y + sizl.cy <= ppdev->cyMemory),
                     "Source rectangle out of bounds!");

            hsurfTmp = (HSURF) EngCreateBitmap(sizl,
                                               0,    // Let GDI choose ulWidth
                                               ppdev->iBitmapFormat,
                                               0,    // Don't need any options
                                               NULL);// Let GDI allocate

            if (hsurfTmp != 0)
            {
                psoTmp = EngLockSurface(hsurfTmp);

                if (psoTmp != NULL)
                {
                    vGetBits(ppdev, psoTmp, &rclTmp, &ptlSrc);

                    if (psoDst->dhsurf == NULL)
                    {
                        // It was a Screen-to-DIB blt; now it's a DIB-to-DIB
                        // blt.  Note that the source point is (0, 0) in our
                        // temporary surface:

                        b = EngBitBlt(psoDst, psoTmp, psoMsk, pco, pxlo,
                                      &rclDst, (POINTL*) &rclTmp, pptlMsk,
                                      pbo, pptlBrush, rop4);
                    }
                    else
                    {
                        // It was a Screen-to-Screen blt; now it's a DIB-to-
                        // screen blt.  Note that the source point is (0, 0)
                        // in our temporary surface:

                        vBankStart(ppdev, &rclDst, pco, &bnk);

                        b = TRUE;
                        do {
                            b &= EngBitBlt(bnk.pso, psoTmp, psoMsk, bnk.pco,
                                           pxlo, &rclDst, (POINTL*) &rclTmp,
                                           pptlMsk, pbo, pptlBrush, rop4);

                        } while (bBankEnum(&bnk));
                    }

                    EngUnlockSurface(psoTmp);
                }

                EngDeleteSurface(hsurfTmp);
            } // if (hsurfTmp != 0)
            else
                b = FALSE;
        }

        return(b);
    }
    #else
    {
        //////////////////////////////////////////////////////////////////////
        // Really Slow bPuntBlt
        //
        // Here we handle a PuntBlt when GDI can't draw directly on the
        // framebuffer (as on the Alpha, which can't do it because of its
        // 32 bit bus).  If you thought the banked version was slow, just
        // look at this one.  Guaranteed, there will be at least one bitmap
        // allocation and extra copy involved; there could be two if it's a
        // screen-to-screen operation.

        PDEV*   ppdev;
        POINTL  ptlSrc;
        RECTL   rclDst;
        SIZEL   sizl;
        ULONG   ulAvec;
        BOOL    bSrcIsScreen;
        HSURF   hsurfSrc;
        RECTL   rclTmp;
        BOOL    b;
        LONG    lDelta;
        BYTE*   pjBits;
        BYTE*   pjScan0;
        HSURF   hsurfDst;
        RECTL   rclScreen;

        b = FALSE;          // Fore error cases, assume we'll fail

        rclDst = *prclDst;
        if (pptlSrc != NULL)
            ptlSrc = *pptlSrc;

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // We have to intersect the destination rectangle with
            // the clip bounds if there is one (consider the case
            // where the app asked to blt a really, really big
            // rectangle from the screen -- prclDst would be really,
            // really big but pco->rclBounds would be the actual
            // area of interest):

            rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
            rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
            rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
            rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

            ptlSrc.x += (rclDst.left - prclDst->left);
            ptlSrc.y += (rclDst.top  - prclDst->top);
        }

        sizl.cx = rclDst.right  - rclDst.left;
        sizl.cy = rclDst.bottom - rclDst.top;

        // The high 2 bytes of rop4 is not guaranteed to be zero. So in order
        // to get the low 8 bits as index, we have to &ffff before do >>
        ulAvec = gajRop3[rop4 & 0xff] | gajRop3[(rop4 & 0xffff) >> 8];

        bSrcIsScreen = ((ulAvec & AVEC_NEED_SOURCE) &&
                        (psoSrc->dhsurf != NULL));

        if (bSrcIsScreen)
        {
            ppdev = (PDEV*) psoSrc->dhpdev;

            // We need to create a copy of the source rectangle:

            hsurfSrc = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat,
                                               0, NULL);
            if (hsurfSrc == 0)
                goto Error_0;

            psoSrc = EngLockSurface(hsurfSrc);
            if (psoSrc == NULL)
                goto Error_1;

            rclTmp.left   = 0;
            rclTmp.top    = 0;
            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;

            // vGetBits takes absolute coordinates for the source point:

            ptlSrc.x += ppdev->xOffset;
            ptlSrc.y += ppdev->yOffset;

            vGetBits(ppdev, psoSrc, &rclTmp, &ptlSrc);

            // The source will now come from (0, 0) of our temporary source
            // surface:

            ptlSrc.x = 0;
            ptlSrc.y = 0;
        }

        if (psoDst->dhsurf == NULL)
        {
            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);
        }
        else
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            // We need to create a temporary work buffer.  We have to do
            // some fudging with the offsets so that the upper-left corner
            // of the (relative coordinates) clip object bounds passed to
            // GDI will be transformed to the upper-left corner of our
            // temporary bitmap.

            // The alignment doesn't have to be as tight as this at 16bpp
            // and 32bpp, but it won't hurt:

            lDelta = (((rclDst.right + 3) & ~3L) - (rclDst.left & ~3L))
                   << ppdev->cPelSize;

            // We're actually only allocating a bitmap that is 'sizl.cx' x
            // 'sizl.cy' in size:

            pjBits = EngAllocMem(0, lDelta * sizl.cy, ALLOC_TAG);
            if (pjBits == NULL)
                goto Error_2;

            // We now adjust the surface's 'pvScan0' so that when GDI thinks
            // it's writing to pixel (rclDst.top, rclDst.left), it will
            // actually be writing to the upper-left pixel of our temporary
            // bitmap:

            pjScan0 = pjBits - (rclDst.top * lDelta)
                             - ((rclDst.left & ~3L) << ppdev->cPelSize);

            ASSERTDD((((ULONG_PTR) pjScan0) & 3) == 0,
                    "pvScan0 must be dword aligned!");

            // The checked build of GDI sometimes checks on blts that
            // prclDst->right <= pso->sizl.cx, so we lie to it about
            // the size of our bitmap:

            sizl.cx = rclDst.right;
            sizl.cy = rclDst.bottom;

            hsurfDst = (HSURF) EngCreateBitmap(
                        sizl,                   // Bitmap covers rectangle
                        lDelta,                 // Use this delta
                        ppdev->iBitmapFormat,   // Same colour depth
                        BMF_TOPDOWN,            // Must have a positive delta
                        pjScan0);               // Where (0, 0) would be

            if ((hsurfDst == 0) ||
                (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
                goto Error_3;

            psoDst = EngLockSurface(hsurfDst);
            if (psoDst == NULL)
                goto Error_4;

            // Make sure that the rectangle we Get/Put from/to the screen
            // is in absolute coordinates:

            rclScreen.left   = rclDst.left   + ppdev->xOffset;
            rclScreen.right  = rclDst.right  + ppdev->xOffset;
            rclScreen.top    = rclDst.top    + ppdev->yOffset;
            rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

            // It would be nice to get a copy of the destination rectangle
            // only when the ROP involves the destination (or when the source
            // is an RLE), but we can't do that.  If the brush is truly NULL,
            // GDI will immediately return TRUE from EngBitBlt, without
            // modifying the temporary bitmap -- and we would proceed to
            // copy the uninitialized temporary bitmap back to the screen.

            vGetBits(ppdev, psoDst, &rclDst, (POINTL*) &rclScreen);

            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);

            vPutBits(ppdev, psoDst, &rclScreen, (POINTL*) &rclDst);

            EngUnlockSurface(psoDst);

        Error_4:

            EngDeleteSurface(hsurfDst);

        Error_3:

            EngFreeMem(pjBits);
        }

        Error_2:

        if (bSrcIsScreen)
        {
            EngUnlockSurface(psoSrc);

        Error_1:

            EngDeleteSurface(hsurfSrc);
        }

        Error_0:

        return(b);
    }
    #endif
}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*           ppdev;
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    OH*             poh;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    ULONG           rop3;
    FNFILL*         pfnFill;
    RBRUSH_COLOR    rbc;         // Realized brush or solid colour
    FNXFER*         pfnXfer;
    ULONG           iSrcBitmapFormat;
    ULONG           iDir;

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL

    if (psoSrc == NULL)
    {
        ///////////////////////////////////////////////////////////////////
        // Fills
        ///////////////////////////////////////////////////////////////////

        // Fills are this function's "raison d'etre" (which is French
        // for "purple armadillo"), so we handle them as quickly as
        // possible:

        ASSERTDD(pdsurfDst != NULL,
                 "Expect only device destinations when no source");

        if (pdsurfDst->dt == DT_SCREEN)
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            poh = pdsurfDst->poh;
            ppdev->xOffset = poh->x;
            ppdev->yOffset = poh->y;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
            {
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                         "Need source but GDI gave us a NULL 'psoSrc'");

            Fill_It:

                pfnFill = ppdev->pfnFillSolid;
                if (gabRopNeedsPattern[(rop4 >> 2) & 0xf])
                {
                    rbc.iSolidColor = pbo->iSolidColor;
                    if (rbc.iSolidColor == -1)
                    {
                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):

                                goto Punt_It;
                            }
                        }
                        pfnFill = ppdev->pfnFillPat;
                    }
                }

                // Note that these 2 'if's are more efficient than
                // a switch statement:

                if (jClip == DC_TRIVIAL)
                {
                    pfnFill(ppdev, 1, prclDst, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else if (jClip == DC_RECT)
                {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        pfnFill(ppdev, 1, &rcl, rop4, rbc, pptlBrush);
                    goto All_Done;
                }
                else
                {
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            pfnFill(ppdev, c, ce.arcl, rop4, rbc, pptlBrush);

                    } while (bMore);
                    goto All_Done;
                }
            }
        }
    }

    if ((psoSrc != NULL) && (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_DIB)
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                ppdev = (PDEV*) psoSrc->dhpdev;

                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                            goto Continue_It;
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            psoSrc = pdsurfSrc->pso;

            // Handle the case where the source is a DIB DFB and the
            // destination is a regular bitmap:

            if (psoDst->dhsurf == NULL)
                goto EngBitBlt_It;

        }
    }

Continue_It:

    if (pdsurfDst != NULL)
    {
        if (pdsurfDst->dt == DT_DIB)
        {
            psoDst = pdsurfDst->pso;

            // If the destination is a DIB, we can only handle this
            // call if the source is not a DIB:

            if ((psoSrc == NULL) || (psoSrc->dhsurf == NULL))
                goto EngBitBlt_It;
        }
    }

    // At this point, we know that either the source or the destination is
    // not a DIB.  Check for a DFB to screen, DFB to DFB, or screen to DFB
    // case:

    if ((psoSrc != NULL) &&
        (psoDst->dhsurf != NULL) &&
        (psoSrc->dhsurf != NULL))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        pdsurfDst = (DSURF*) psoDst->dhsurf;

        ASSERTDD(pdsurfSrc->dt == DT_SCREEN, "Expected screen source");
        ASSERTDD(pdsurfDst->dt == DT_SCREEN, "Expected screen destination");

        ptlSrc.x = pptlSrc->x - (pdsurfDst->poh->x - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y - (pdsurfDst->poh->y - pdsurfSrc->poh->y);

        pptlSrc  = &ptlSrc;
    }

    if (psoDst->dhsurf != NULL)
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        ppdev     = (PDEV*)  psoDst->dhpdev;

        ppdev->xOffset = pdsurfDst->poh->x;
        ppdev->yOffset = pdsurfDst->poh->y;
    }
    else
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        ppdev     = (PDEV*)  psoSrc->dhpdev;

        ppdev->xOffset = pdsurfSrc->poh->x;
        ppdev->yOffset = pdsurfSrc->poh->y;
    }

    // We bail here if we're running in a high-colour mode:

    if (ppdev->flStat & STAT_UNACCELERATED)
        goto EngBitBlt_It;

    if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
    {
        // Since we've already handled the cases where the ROP4 is really
        // a ROP3 and no source is required, we can assert...

        ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                 "Expected no-source case to already have been handled");

        ///////////////////////////////////////////////////////////////////
        // Bitmap transfers
        ///////////////////////////////////////////////////////////////////

        // Since the foreground and background ROPs are the same, we
        // don't have to worry about no stinking masks (it's a simple
        // Rop3).

        rop3 = (rop4 & 0xff);   // Make it into a Rop3 (we keep the rop4
                                //  around in case we decide to punt)

        if (psoDst->dhsurf != NULL)
        {
            // The destination is the screen:

            if ((rop3 >> 4) == (rop3 & 0xf))
            {
                // The ROP3 doesn't require a pattern:

                if (psoSrc->dhsurf == NULL)
                {

                    //////////////////////////////////////////////////
                    // DIB-to-screen blt

                    // This section handles 1bpp, 4bpp and 8bpp sources.

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)
                    {
                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                    }
                }
                else // psoSrc->dhsurf != NULL
                {
                    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                    {
                        //////////////////////////////////////////////////
                        // Screen-to-screen blt with no translate

                        if (jClip == DC_TRIVIAL)
                        {
                            (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, rop4,
                                pptlSrc, prclDst);
                            goto All_Done;
                        }
                        else if (jClip == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                (ppdev->pfnCopyBlt)(ppdev, 1, &rcl, rop4,
                                    pptlSrc, prclDst);
                            }
                            goto All_Done;
                        }
                        else
                        {
                            // Don't forget that we'll have to draw the
                            // rectangles in the correct direction:

                            if (pptlSrc->y >= prclDst->top)
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                            }
                            else
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                            }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               iDir, 0);

                            do {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                      (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                {
                                    (ppdev->pfnCopyBlt)(ppdev, c, ce.arcl,
                                        rop4, pptlSrc, prclDst);
                                }

                            } while (bMore);
                            goto All_Done;
                        }
                    }
                }
            }
        }
        else
        {
            #if defined(i386)
            {
                // We special case screen to monochrome blts because they
                // happen fairly often.  We only handle SRCCOPY rops and
                // monochrome destinations (to handle a true 1bpp DIB
                // destination, we would have to do near-colour searches
                // on every colour; as it is, the foreground colour gets
                // mapped to '1', and everything else gets mapped to '0'):

                if ((psoDst->iBitmapFormat == BMF_1BPP) &&
                    (rop3 == 0xcc) &&
                    (pxlo->flXlate & XO_TO_MONO) &&
                    (ppdev->iBitmapFormat != BMF_24BPP))
                {
                    pfnXfer = vXferScreenTo1bpp;
                    psoSrc  = psoDst;               // A misnomer, I admit
                    goto Xfer_It;
                }
            }
            #endif // i386
        }
    }
    else if ((psoMsk == NULL) && (rop4 == 0xaacc))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP):

        goto Fill_It;
    }

    // Just fall through to Punt_It...

Punt_It:

    return(bPuntBlt(psoDst,
                    psoSrc,
                    psoMsk,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    pptlMsk,
                    pbo,
                    pptlBrush,
                    rop4));

//////////////////////////////////////////////////////////////////////
// Common bitmap transfer

Xfer_It:
    if (jClip == DC_TRIVIAL)
    {
        pfnXfer(ppdev, 1, prclDst, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, rop4, psoSrc, pptlSrc, prclDst, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnXfer(ppdev, c, ce.arcl, rop4, psoSrc,
                        pptlSrc, prclDst, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

////////////////////////////////////////////////////////////////////////
// Common DIB blt

EngBitBlt_It:

    // Our driver doesn't handle any blt's between two DIBs.  Normally
    // a driver doesn't have to worry about this, but we do because
    // we have DFBs that may get moved from off-screen memory to a DIB,
    // where we have GDI do all the drawing.  GDI does DIB drawing at
    // a reasonable speed (unless one of the surfaces is a device-
    // managed surface...)
    //
    // If either the source or destination surface in an EngBitBlt
    // call-back is a device-managed surface (meaning it's not a DIB
    // that GDI can draw with), GDI will automatically allocate memory
    // and call the driver's DrvCopyBits routine to create a DIB copy
    // that it can use.  So this means that this could handle all 'punts',
    // and we could conceivably get rid of bPuntBlt.  But this would have
    // a bad performance impact because of the extra memory allocations
    // and bitmap copies -- you really don't want to do this unless you
    // have to (or your surface was created such that GDI can draw
    // directly onto it) -- I've been burned by this because it's not
    // obvious that the performance impact is so bad.
    //
    // That being said, we only call EngBitBlt when all the surfaces
    // are DIBs:

    return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                     pptlSrc, pptlMsk, pbo, pptlBrush, rop4));

All_Done:
    return(TRUE);

}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* Note that GDI will (usually) automatically adjust the blt extents to
* adjust for any rectangular clipping, so we'll rarely see DC_RECT
* clipping in this routine (and as such, we don't bother special casing
* it).
*
* I'm not sure if the performance benefit from this routine is actually
* worth the increase in code size, since SRCCOPY BitBlts are hardly the
* most common drawing operation we'll get.  But what the heck.
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    PDEV*   ppdev;
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    RECTL   rcl;
    POINTL  ptl;
    OH*     pohSrc;
    OH*     pohDst;

    // DrvCopyBits is a fast-path for SRCCOPY blts.  But it can still be
    // pretty complicated: there can be translates, clipping, RLEs,
    // bitmaps that aren't the same format as the screen, plus
    // screen-to-screen, DIB-to-screen or screen-to-DIB operations,
    // not to mention DFBs (device format bitmaps).
    //
    // Rather than making this routine almost as big as DrvBitBlt, I'll
    // handle here only the speed-critical cases, and punt the rest to
    // our DrvBitBlt routine.
    //
    // We'll try to handle anything that doesn't involve clipping:

    if (((pco  == NULL) || (pco->iDComplexity == DC_TRIVIAL)) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        if (psoDst->dhsurf != NULL)
        {
            // We know the destination is either a DFB or the screen:

            ppdev     = (PDEV*)  psoDst->dhpdev;
            pdsurfDst = (DSURF*) psoDst->dhsurf;

            // See if the source is a plain DIB:

            if (psoSrc->dhsurf != NULL)
            {
                pdsurfSrc = (DSURF*) psoSrc->dhsurf;

                // Make sure the destination is really the screen or an
                // off-screen DFB (i.e., not a DFB that we've converted
                // to a DIB):

                if (pdsurfDst->dt == DT_SCREEN)
                {
                    ASSERTDD(psoSrc->dhsurf != NULL, "Can't be a DIB");

                    if (pdsurfSrc->dt == DT_SCREEN)
                    {

                    Screen_To_Screen:

                        //////////////////////////////////////////////////////
                        // Screen-to-screen

                        ASSERTDD((psoSrc->dhsurf != NULL)        &&
                                 (pdsurfSrc->dt == DT_SCREEN)    &&
                                 (psoDst->dhsurf != NULL)        &&
                                 (pdsurfDst->dt == DT_SCREEN),
                                 "Should be a screen-to-screen case");

                        // pfnCopyBlt takes relative coordinates (relative
                        // to the destination surface, that is), so we have
                        // to change the start point to be relative to the
                        // destination surface too:

                        pohSrc = pdsurfSrc->poh;
                        pohDst = pdsurfDst->poh;

                        ptl.x = pptlSrc->x - (pohDst->x - pohSrc->x);
                        ptl.y = pptlSrc->y - (pohDst->y - pohSrc->y);

                        ppdev->xOffset = pohDst->x;
                        ppdev->yOffset = pohDst->y;

                        (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, 0xCCCC, &ptl,
                            prclDst);
                        return(TRUE);
                    }
                    else // (pdsurfSrc->dt != DT_SCREEN)
                    {
                        // Ah ha, the source is a DFB that's really a DIB.

                        ASSERTDD(psoDst->dhsurf != NULL,
                                "Destination can't be a DIB here");

                        /////////////////////////////////////////////////////
                        // Put It Back Into Off-screen?
                        //
                        // We take this opportunity to decide if we want to
                        // put the DIB back into off-screen memory.  This is
                        // a pretty good place to do it because we have to
                        // copy the bits to some portion of the screen,
                        // anyway.  So we would incur only an extra screen-to-
                        // screen blt at this time, much of which will be
                        // over-lapped with the CPU.
                        //
                        // The simple approach we have taken is to move a DIB
                        // back into off-screen memory only if there's already
                        // room -- we won't throw stuff out to make space
                        // (because it's tough to know what ones to throw out,
                        // and it's easy to get into thrashing scenarios).
                        //
                        // Because it takes some time to see if there's room
                        // in off-screen memory, we only check one in
                        // HEAP_COUNT_DOWN times if there's room.  To bias
                        // in favour of bitmaps that are often blt, the
                        // counters are reset every time any space is freed
                        // up in off-screen memory.  We also don't bother
                        // checking if no space has been freed since the
                        // last time we checked for this DIB.

                        if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                        {
                            if (--pdsurfSrc->cBlt == 0)
                            {
                                if (bMoveDibToOffscreenDfbIfRoom(ppdev,
                                                                 pdsurfSrc))
                                    goto Screen_To_Screen;
                            }
                        }
                        else
                        {
                            // Some space was freed up in off-screen memory,
                            // so reset the counter for this DFB:

                            pdsurfSrc->iUniq = ppdev->iHeapUniq;
                            pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                        }

                        // Since the destination is definitely the screen,
                        // we don't have to worry about creating a DIB to
                        // DIB copy case (for which we would have to call
                        // EngCopyBits):

                        psoSrc = pdsurfSrc->pso;

                        goto DIB_To_Screen;
                    }
                }
                else // (pdsurfDst->dt != DT_SCREEN)
                {
                    // Because the source is not a DIB, we don't have to
                    // worry about creating a DIB to DIB case here (although
                    // we'll have to check later to see if the source is
                    // really a DIB that's masquerading as a DFB...)

                    ASSERTDD(psoSrc->dhsurf != NULL,
                             "Source can't be a DIB here");

                    psoDst = pdsurfDst->pso;

                    goto Screen_To_DIB;
                }
            }
            else if (psoSrc->iBitmapFormat == ppdev->iBitmapFormat)
            {
                // Make sure the destination is really the screen:

                if (pdsurfDst->dt == DT_SCREEN)
                {

                DIB_To_Screen:

                    //////////////////////////////////////////////////////
                    // DIB-to-screen

                    ASSERTDD((psoDst->dhsurf != NULL)        &&
                             (pdsurfDst->dt == DT_SCREEN)    &&
                             (psoSrc->dhsurf == NULL)        &&
                             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a DIB-to-screen case");

                    // vPutBits takes absolute screen coordinates, so
                    // we have to muck with the destination rectangle:

                    pohDst = pdsurfDst->poh;

                    rcl.left   = prclDst->left   + pohDst->x;
                    rcl.right  = prclDst->right  + pohDst->x;
                    rcl.top    = prclDst->top    + pohDst->y;
                    rcl.bottom = prclDst->bottom + pohDst->y;

                    // We use the memory aperture to do the transfer,
                    // because that is supposed to be faster for SRCCOPY
                    // blts than using the data-transfer register:

                    vPutBits(ppdev, psoSrc, &rcl, pptlSrc);
                    return(TRUE);
                }
            }
        }
        else // (psoDst->dhsurf == NULL)
        {

        Screen_To_DIB:

            pdsurfSrc = (DSURF*) psoSrc->dhsurf;
            ppdev     = (PDEV*)  psoSrc->dhpdev;

            if (psoDst->iBitmapFormat == ppdev->iBitmapFormat)
            {
                if (pdsurfSrc->dt == DT_SCREEN)
                {
                    //////////////////////////////////////////////////////
                    // Screen-to-DIB

                    ASSERTDD((psoSrc->dhsurf != NULL)        &&
                             (pdsurfSrc->dt == DT_SCREEN)    &&
                             (psoDst->dhsurf == NULL)        &&
                             (psoDst->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a screen-to-DIB case");

                    // vGetBits takes absolute screen coordinates, so we have
                    // to muck with the source point:

                    pohSrc = pdsurfSrc->poh;

                    ptl.x = pptlSrc->x + pohSrc->x;
                    ptl.y = pptlSrc->y + pohSrc->y;

                    vGetBits(ppdev, psoDst, prclDst, &ptl);
                    return(TRUE);
                }
                else
                {
                    // The source is a DFB that's really a DIB.  Since we
                    // know that the destination is a DIB, we've got a DIB
                    // to DIB operation, and should call EngCopyBits:

                    psoSrc = pdsurfSrc->pso;
                    goto EngCopyBits_It;
                }
            }
        }
    }

    // We can't call DrvBitBlt if we've accidentally converted both
    // surfaces to DIBs, because it isn't equipped to handle it:

    ASSERTDD((psoSrc->dhsurf != NULL) ||
             (psoDst->dhsurf != NULL),
             "Accidentally converted both surfaces to DIBs");

    /////////////////////////////////////////////////////////////////
    // A DrvCopyBits is after all just a simplified DrvBitBlt:

    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                     NULL, NULL, 0x0000CCCC));

EngCopyBits_It:

    ASSERTDD((psoDst->dhsurf == NULL) &&
             (psoSrc->dhsurf == NULL),
             "Both surfaces should be DIBs to call EngCopyBits");

    return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\brush.c ===
/******************************Module*Header*******************************\
* Module Name: Brush.c
*
* Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the colour ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because vComputeSubspaces ignores it.
\**************************************************************************/

VOID vRealizeDitherPattern(
RBRUSH*     prb,
ULONG       ulRGBToDither)
{
    ULONG           ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA*    pvVertexData;

    // Calculate what colour subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering:

    vDitherColor(&prb->aulPattern[0], vVertexData, pvVertexData, ulNumVertices);

    // Initialize the fields we need:

    prb->fl = 0;
}

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It may be called directly by GDI at SelectObject time, or
* it may be called by GDI as a result of us calling BRUSHOBJ_pvGetRbrush
* to create a realized brush in a function like DrvBitBlt.
*
* Note that we have no way of determining what the current Rop or brush
* alignment are at this point.
*
\**************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    PDEV*   ppdev;
    ULONG   iPatternFormat;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    lSrcDelta;
    LONG    cj;
    LONG    i;
    LONG    j;
    RBRUSH* prb;
    ULONG*  pulXlate;
    ULONG*  pulRBits;

    ppdev = (PDEV*) psoDst->dhpdev;

    // We don't do brushes in high-colour modes:

    if (ppdev->flStat & STAT_UNACCELERATED)
        goto ReturnFalse;

    // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE:

    if (iHatch & RB_DITHERCOLOR)
    {
        // Implementing DITHERONREALIZE increased our score on a certain
        // unmentionable benchmark by 0.4 million 'megapixels'.  Too bad
        // this didn't work in the first version of NT.

        prb = BRUSHOBJ_pvAllocRbrush(pbo,
              sizeof(RBRUSH) + (TOTAL_BRUSH_SIZE * ppdev->cjPel));
        if (prb == NULL)
            goto ReturnFalse;

        vRealizeDitherPattern(prb, iHatch);
        goto ReturnTrue;
    }

    // We only accelerate 8x8 patterns.  Since Win3.1 and Chicago don't
    // support patterns of any other size, it's a safe bet that 99.9%
    // of the patterns we'll ever get will be 8x8:

    if ((psoPattern->sizlBitmap.cx != 8) ||
        (psoPattern->sizlBitmap.cy != 8))
        goto ReturnFalse;

    // At 8bpp, we handle patterns at 1bpp and 8bpp with/without an xlate.

    iPatternFormat = psoPattern->iBitmapFormat;

    if ((iPatternFormat == BMF_1BPP)             ||
        (iPatternFormat == ppdev->iBitmapFormat))
    {
        prb = BRUSHOBJ_pvAllocRbrush(pbo,
              sizeof(RBRUSH) + (TOTAL_BRUSH_SIZE * ppdev->cjPel));
        if (prb == NULL)
            goto ReturnFalse;

        // Initialize the fields we need:

        prb->fl = 0;

        lSrcDelta = psoPattern->lDelta;
        pjSrc     = (BYTE*) psoPattern->pvScan0;
        pjDst     = (BYTE*) &prb->aulPattern[0];

        if (ppdev->iBitmapFormat == iPatternFormat)
        {
            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                DISPDBG((1, "Realizing un-translated brush"));

                // The pattern is the same colour depth as the screen, and
                // there's no translation to be done:

                cj = (8 * ppdev->cjPel);    // Every pattern is 8 pels wide

                for (i = 8; i != 0; i--)
                {
                    RtlCopyMemory(pjDst, pjSrc, cj);

                    pjSrc += lSrcDelta;
                    pjDst += cj;
                }
            }
            else if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                DISPDBG((1, "Realizing 8bpp translated brush"));

                // The screen is 8bpp, and there's translation to be done:

                pulXlate = pxlo->pulXlate;

                for (i = 8; i != 0; i--)
                {
                    for (j = 8; j != 0; j--)
                    {
                        *pjDst++ = (BYTE) pulXlate[*pjSrc++];
                    }

                    pjSrc += lSrcDelta - 8;
                }
            }
            else
            {
                // I don't feel like writing code to handle translations
                // when our screen is 16bpp or higher (although I probably
                // should; we could allocate a temporary buffer and use
                // GDI to convert, like is done in the VGA driver).

                goto ReturnFalse;
            }
        }
        else
        {
            ASSERTDD(iPatternFormat == BMF_1BPP, "Expected 1bpp only");

            for (i = 8; i != 0; i--)
            {
                *pjDst = *pjSrc;
                pjSrc += lSrcDelta;
                pjDst += 1;
            }

            pulXlate         = pxlo->pulXlate;
            prb->fl          = RBRUSH_2COLOR;
            prb->ulBackColor = pulXlate[0];
            prb->ulForeColor = pulXlate[1];
        }

ReturnTrue:

        if (!(prb->fl & RBRUSH_2COLOR))
        {
            pulRBits = (ULONG*) &prb->aulPattern[0];

            prb->cy          = 8;
            prb->cyLog2      = 3;
            prb->xBlockAlign = -1;

            // See if pattern is really only 4 scans long:

            ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP,
                     "This only works at 8bpp");

            if (pulRBits[0] == pulRBits[8]  && pulRBits[1] == pulRBits[9]  &&
                pulRBits[2] == pulRBits[10] && pulRBits[3] == pulRBits[11] &&
                pulRBits[4] == pulRBits[12] && pulRBits[5] == pulRBits[13] &&
                pulRBits[6] == pulRBits[14] && pulRBits[7] == pulRBits[15])
            {
                prb->cy     = 4;
                prb->cyLog2 = 2;

                // See if pattern is really only 2 scans long:

                if (pulRBits[0] == pulRBits[4] && pulRBits[1] == pulRBits[5] &&
                    pulRBits[2] == pulRBits[6] && pulRBits[3] == pulRBits[7])
                {
                    DISPDBG((2, "cy = 2 "));

                    prb->cy     = 2;
                    prb->cyLog2 = 1;
                }
                else
                {
                    DISPDBG((2, "cy = 4 "));
                }
            }
            else
            {
                DISPDBG((2, "cy = 8 "));
            }

            // See if pattern is really only 4 pels wide:

            for (i = prb->cy / 2; i > 0; i--)
            {
                if (*(pulRBits    ) != *(pulRBits + 1) ||
                    *(pulRBits + 2) != *(pulRBits + 3))
                    goto Not_4_Wide;

                pulRBits += 4;
            }

            DISPDBG((2, "4pels wide"));

        Not_4_Wide:

            ;
        }

        return(TRUE);
    }

ReturnFalse:

    if (psoPattern != NULL)
    {
        DISPDBG((1, "Failed realization -- Type: %li Format: %li cx: %li cy: %li",
                    psoPattern->iType, psoPattern->iBitmapFormat,
                    psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vAssertModeBrushCache
*
* Resets the brush cache when we exit out of full-screen.
\**************************************************************************/

VOID vAssertModeBrushCache(
PDEV*   ppdev,
BOOL    bEnable)
{

}

/******************************Public*Routine******************************\
* BOOL bEnableBrushCache
*
* Allocates off-screen memory for storing the brush cache.
\**************************************************************************/

BOOL bEnableBrushCache(
PDEV*   ppdev)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableBrushCache
*
* Cleans up anything done in bEnableBrushCache.
\**************************************************************************/

VOID vDisableBrushCache(PDEV* ppdev)
{
    // We ain't gotta do nothin'
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\bltio.c ===
/******************************Module*Header*******************************\
* Module Name: bltio.c
*
* Contains the low-level in/out blt functions.  This module mirrors
* 'bltmm.c'.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vIoFillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vIoFillSolid(              // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Mix
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjIoBase;

    ASSERTDD((rop4 >> 8) == (rop4 & 0xff), "Illegal mix");

    pjIoBase = ppdev->pjIoBase;

    IO_WAIT_FOR_IDLE(ppdev, pjIoBase);

    IO_PREG_COLOR_8(ppdev, pjIoBase, rbc.iSolidColor);
    IO_CTRL_REG_1(ppdev, pjIoBase, PACKED_PIXEL_VIEW |
                                   BITS_PER_PIX_8    |
                                   ENAB_TRITON_MODE);
    IO_BLT_CMD_1(ppdev, pjIoBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);
    if (rop4 == 0xf0f0)
    {
        IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS    |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_PATTERN_REGS);
    }
    else
    {
        IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_ALL        |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_PATTERN_REGS);
        IO_ROP_A(ppdev, pjIoBase, rop4 >> 2);
    }

    IO_BITMAP_HEIGHT(ppdev, pjIoBase, prcl->bottom - prcl->top);
    IO_BITMAP_WIDTH(ppdev, pjIoBase, prcl->right - prcl->left);
    IO_DEST_XY(ppdev, pjIoBase, prcl->left, prcl->top);
    IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

    while (prcl++, --c)
    {
        IO_WAIT_BUFFER_NOT_BUSY(ppdev, pjIoBase);

        IO_BITMAP_HEIGHT(ppdev, pjIoBase, prcl->bottom - prcl->top);
        IO_BITMAP_WIDTH(ppdev, pjIoBase, prcl->right - prcl->left);
        IO_DEST_XY(ppdev, pjIoBase, prcl->left, prcl->top);
        IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);
    }
}

/******************************Public*Routine******************************\
* VOID vIoFillPat2Color
*
* This routine uses the QVision pattern hardware to draw a patterned list of
* rectangles.
*
\**************************************************************************/

VOID vIoFillPat2Color(          // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Mix
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjIoBase;
    LONG    xAlign;
    LONG    yAlign;

    ASSERTDD(((rop4 >> 8) == (rop4 & 0xff)) || ((rop4 & 0xff00) == 0xaa00),
             "Illegal mix");

    pjIoBase = ppdev->pjIoBase;
    xAlign   = pptlBrush->x;
    yAlign   = pptlBrush->y;

    IO_WAIT_FOR_IDLE(ppdev, pjIoBase);

    IO_FG_COLOR(ppdev, pjIoBase, rbc.prb->ulForeColor);
    IO_BG_COLOR(ppdev, pjIoBase, rbc.prb->ulBackColor);
    IO_PREG_PATTERN(ppdev, pjIoBase, rbc.prb->aulPattern);

    IO_CTRL_REG_1(ppdev, pjIoBase, EXPAND_TO_FG      |
                                   BITS_PER_PIX_8    |
                                   ENAB_TRITON_MODE);
    IO_BLT_CMD_1(ppdev, pjIoBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);

    if (rop4 == 0xf0f0)
    {
        // Opaque brush with PATCOPY rop:

        IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS    |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_PATTERN_REGS);
    }
    else if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
    {
        // Opaque brush with rop other than PATCOPY:

        IO_ROP_A(ppdev, pjIoBase, rop4 >> 2);
        IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_ALL        |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_PATTERN_REGS);
    }
    else if ((rop4 & 0xff) == 0xcc)
    {
        // Transparent brush with PATCOPY rop:

        IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS      |
                                          PIXELMASK_AND_SRC_DATA |
                                          PLANARMASK_NONE_0XFF   |
                                          SRC_IS_PATTERN_REGS);
    }
    else
    {
        // Transparent brush with rop other than PATCOPY:

        IO_ROP_A(ppdev, pjIoBase, rop4 >> 2);
        IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_ALL          |
                                          PIXELMASK_AND_SRC_DATA |
                                          PLANARMASK_NONE_0XFF   |
                                          SRC_IS_PATTERN_REGS);
    }

    IO_BITMAP_HEIGHT(ppdev, pjIoBase, prcl->bottom - prcl->top);
    IO_BITMAP_WIDTH(ppdev, pjIoBase, prcl->right - prcl->left);
    IO_DEST_XY(ppdev, pjIoBase, prcl->left, prcl->top);
    IO_SRC_ALIGN(ppdev, pjIoBase, ((prcl->left - xAlign) & 7) |
                                  ((prcl->top  - yAlign) << 3));
    IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

    while (prcl++, --c)
    {
        IO_WAIT_BUFFER_NOT_BUSY(ppdev, pjIoBase);

        IO_BITMAP_HEIGHT(ppdev, pjIoBase, prcl->bottom - prcl->top);
        IO_BITMAP_WIDTH(ppdev, pjIoBase, prcl->right - prcl->left);
        IO_DEST_XY(ppdev, pjIoBase, prcl->left, prcl->top);
        IO_SRC_ALIGN(ppdev, pjIoBase, ((prcl->left - xAlign) & 7) |
                                      ((prcl->top  - yAlign) << 3));
        IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);
    }
}

/******************************Public*Routine******************************\
* VOID vIoFillPat
*
* This routine uses the QVision pattern hardware to draw a patterned list of
* rectangles.
*
\**************************************************************************/

VOID vIoFillPat(                // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Mix
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjIoBase;
    LONG    xAlign;
    LONG    yAlign;
    LONG    lLinearDelta;
    BYTE*   pjPattern;
    LONG    xLeft;
    LONG    yTop;
    LONG    yBottom;
    LONG    lLinearDest;
    LONG    cy;
    LONG    iPattern;
    LONG    cyHeightOfEachBlt;
    LONG    cBltsBeforeHeightChange;
    LONG    cBlts;

    if (!(rbc.prb->fl & RBRUSH_2COLOR))
    {
        ASSERTDD((rop4 >> 8) == (rop4 & 0xff), "Illegal mix");

        pjIoBase     = ppdev->pjIoBase;
        xAlign       = pptlBrush->x;
        yAlign       = pptlBrush->y;
        lLinearDelta = ppdev->lDelta << 3;
        pjPattern    = (BYTE*) rbc.prb->aulPattern;

        IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
        IO_DEST_PITCH(ppdev, pjIoBase, (ppdev->lDelta << rbc.prb->cyLog2) >> 2);
        IO_CTRL_REG_1(ppdev, pjIoBase, PACKED_PIXEL_VIEW |
                                       BITS_PER_PIX_8    |
                                       ENAB_TRITON_MODE);
        IO_BLT_CMD_1(ppdev, pjIoBase, XY_SRC_ADDR |
                                      LIN_DEST_ADDR);

        if (rop4 == 0xf0f0)
        {
            IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS    |
                                              PIXELMASK_ONLY       |
                                              PLANARMASK_NONE_0XFF |
                                              SRC_IS_PATTERN_REGS);
        }
        else
        {
            IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_ALL        |
                                              PIXELMASK_ONLY       |
                                              PLANARMASK_NONE_0XFF |
                                              SRC_IS_PATTERN_REGS);
            IO_ROP_A(ppdev, pjIoBase, rop4 >> 2);
        }

        while (TRUE)
        {
            xLeft       = prcl->left;
            yTop        = prcl->top;
            lLinearDest = ((yTop + ppdev->yOffset) * lLinearDelta)
                        + ((xLeft + ppdev->xOffset) << 3);

            // Note that any registers we set now before the
            // WAIT_FOR_IDLE must be buffered, as this loop may be
            // executed multiple times when doing more than one
            // rectangle:

            IO_BITMAP_WIDTH(ppdev, pjIoBase, prcl->right - xLeft);
            IO_DEST_X(ppdev, pjIoBase, xLeft);
            IO_SRC_ALIGN(ppdev, pjIoBase, xLeft - xAlign);

            yBottom  = prcl->bottom;
            cy       = yBottom - yTop;
            iPattern = 8 * (yTop - yAlign);

            cyHeightOfEachBlt       = (cy >> rbc.prb->cyLog2) + 1;
            cBlts                   = min(cy, rbc.prb->cy);
            cBltsBeforeHeightChange = (cy & (rbc.prb->cy - 1)) + 1;

            if (cBltsBeforeHeightChange != 1)
                IO_BITMAP_HEIGHT(ppdev, pjIoBase, cyHeightOfEachBlt);

            do {
                // Need to wait for idle because we're about to modify the
                // pattern registers, which aren't buffered:

                IO_WAIT_FOR_IDLE(ppdev, pjIoBase);

                IO_PREG_PATTERN(ppdev, pjIoBase, pjPattern + (iPattern & 63));
                iPattern += 8;

                IO_DEST_LIN(ppdev, pjIoBase, lLinearDest);
                lLinearDest += lLinearDelta;

                cBltsBeforeHeightChange--;
                if (cBltsBeforeHeightChange == 0)
                    IO_BITMAP_HEIGHT(ppdev, pjIoBase, cyHeightOfEachBlt - 1);

                IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

            } while (--cBlts != 0);

            if (--c == 0)
                break;

            prcl++;
        }
    }
    else
    {
        vIoFillPat2Color(ppdev, c, prcl, rop4, rbc, pptlBrush);
    }
}

/******************************Public*Routine******************************\
* VOID vIoXfer1bpp
*
* This routine colours expands a monochrome bitmap, possibly with different
* Rop2's for the foreground and background.  It will be called in the
* following cases:
*
* 1) To colour-expand the monochrome text buffer for the vFastText routine.
* 2) To blt a 1bpp source with a simple Rop2 between the source and
*    destination.
* 3) To blt a true Rop3 when the source is a 1bpp bitmap that expands to
*    white and black, and the pattern is a solid colour.
* 4) To handle a true Rop4 that works out to be Rop2's between the pattern
*    and destination.
*
* Needless to say, making this routine fast can leverage a lot of
* performance.
*
\**************************************************************************/

VOID vIoXfer1bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Mix
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjIoBase;
    LONG    dxSrc;
    LONG    dySrc;      // Add delta to destination to get source
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjDstStart;
    LONG    yTop;
    LONG    xLeft;
    LONG    xRight;
    LONG    cx;
    LONG    cy;         // Dimensions of blt rectangle
    LONG    xBias;
    LONG    cjSrc;
    LONG    cdSrc;
    LONG    lSrcSkip;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    i;
    LONG    j;

    ASSERTDD((rop4 >> 8) == (rop4 & 0xff), "Illegal mix");

    pjIoBase  = ppdev->pjIoBase;

    dxSrc = pptlSrc->x - prclDst->left;
    dySrc = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;
    pjDstStart = ppdev->pjScreen;

    IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
    IO_CTRL_REG_1(ppdev, pjIoBase, EXPAND_TO_FG      |
                                   BITS_PER_PIX_8    |
                                   ENAB_TRITON_MODE);
    IO_BLT_CMD_1(ppdev, pjIoBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);
    IO_FG_COLOR(ppdev, pjIoBase, pxlo->pulXlate[1]);
    IO_BG_COLOR(ppdev, pjIoBase, pxlo->pulXlate[0]);

    if (rop4 == 0xcccc)
    {
        IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS    |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_CPU_DATA);
    }
    else
    {
        IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_ALL        |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_CPU_DATA);
        IO_ROP_A(ppdev, pjIoBase, rop4);
    }

    while (TRUE)
    {
        yTop   = prcl->top;
        xLeft  = prcl->left;
        xRight = prcl->right;

        cy = prcl->bottom - yTop;
        cx = xRight - xLeft;

        IO_BITMAP_WIDTH(ppdev, pjIoBase, cx);
        IO_BITMAP_HEIGHT(ppdev, pjIoBase, cy);
        IO_DEST_XY(ppdev, pjIoBase, xLeft, yTop);

        xBias = (xLeft + dxSrc) & 7;
        IO_SRC_ALIGN(ppdev, pjIoBase, xBias);
        xLeft -= xBias;

        cjSrc    = (xRight - xLeft + 7) >> 3;
        cdSrc    = cjSrc >> 2;
        lSrcSkip = lSrcDelta - (cdSrc << 2);

        pjSrc = pjSrcScan0 + (yTop + dySrc) * lSrcDelta
                           + ((xLeft + dxSrc) >> 3);

        IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

        switch(cjSrc & 3)
        {
        case 0:
            for (i = cy; i != 0; i--)
            {
                MEMORY_BARRIER();
                pjDst = pjDstStart;
                for (j = cdSrc; j != 0; j--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjDst += sizeof(ULONG);
                    pjSrc += sizeof(ULONG);
                }
                pjSrc += lSrcSkip;
            }
            break;

        case 1:
            for (i = cy; i != 0; i--)
            {
                MEMORY_BARRIER();
                pjDst = pjDstStart;
                for (j = cdSrc; j != 0; j--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjDst += sizeof(ULONG);
                    pjSrc += sizeof(ULONG);
                }
                WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                pjSrc += lSrcSkip;
            }
            break;

        case 2:
            for (i = cy; i != 0; i--)
            {
                MEMORY_BARRIER();
                pjDst = pjDstStart;
                for (j = cdSrc; j != 0; j--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjDst += sizeof(ULONG);
                    pjSrc += sizeof(ULONG);
                }
                WRITE_REGISTER_USHORT(pjDst, *((USHORT UNALIGNED *) pjSrc));
                pjSrc += lSrcSkip;
            }
            break;

        case 3:
            for (i = cy; i != 0; i--)
            {
                MEMORY_BARRIER();
                pjDst = pjDstStart;
                for (j = cdSrc; j != 0; j--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjDst += sizeof(ULONG);
                    pjSrc += sizeof(ULONG);
                }
                WRITE_REGISTER_USHORT(pjDst, *((USHORT UNALIGNED *) pjSrc));
                WRITE_REGISTER_UCHAR((pjDst + 2), *(pjSrc + 2));
                pjSrc += lSrcSkip;
            }
            break;
        }

        IO_WAIT_TRANSFER_DONE(ppdev, pjIoBase);

        if (--c == 0)
            break;

        prcl++;
        IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
    }

    // Give the Triton a kick in the pants to work around a goofy
    // hardware bug:

    IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
    IO_BLT_CONFIG(ppdev, pjIoBase, RESET_BLT);
    IO_BLT_CONFIG(ppdev, pjIoBase, BLT_ENABLE);
}

/******************************Public*Routine******************************\
* VOID vIoCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
\**************************************************************************/

VOID vIoCopyBlt(    // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // Hardware mix
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BYTE*   pjIoBase;
    LONG    dxSrc;
    LONG    dySrc;      // Add delta to destination to get source
    LONG    cx;
    LONG    cy;         // Dimensions of blt rectangle
    LONG    xDst;
    LONG    yDst;       // Start point of destination

    ASSERTDD((rop4 >> 8) == (rop4 & 0xff), "Illegal mix");

    pjIoBase  = ppdev->pjIoBase;

    dxSrc = pptlSrc->x - prclDst->left;
    dySrc = pptlSrc->y - prclDst->top;

    IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
    IO_CTRL_REG_1(ppdev, pjIoBase, PACKED_PIXEL_VIEW |  // !!! Need this each time?
                                   BITS_PER_PIX_8    |
                                   ENAB_TRITON_MODE);
    IO_BLT_CMD_1(ppdev, pjIoBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);
    if (rop4 == 0xcccc)
    {
        IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS    |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_SCRN_LATCHES);
    }
    else
    {
        IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_ALL        |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_SCRN_LATCHES);
        IO_ROP_A(ppdev, pjIoBase, rop4);
    }

    if ((prclDst->top < pptlSrc->y) ||
        (prclDst->top == pptlSrc->y) && (prclDst->left <= pptlSrc->x))
    {
        // Forward blt:

        cx   = prcl->right - prcl->left;
        cy   = prcl->bottom - prcl->top;
        xDst = prcl->left;
        yDst = prcl->top;

        IO_BITMAP_WIDTH(ppdev, pjIoBase, cx);
        IO_BITMAP_HEIGHT(ppdev, pjIoBase, cy);
        IO_DEST_XY(ppdev, pjIoBase, xDst, yDst);
        IO_SRC_XY(ppdev, pjIoBase, xDst + dxSrc, yDst + dySrc);
        IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

        while (prcl++, --c)
        {
            cx   = prcl->right - prcl->left;
            cy   = prcl->bottom - prcl->top;
            xDst = prcl->left;
            yDst = prcl->top;

            IO_WAIT_BUFFER_NOT_BUSY(ppdev, pjIoBase);
            IO_BITMAP_WIDTH(ppdev, pjIoBase, cx);
            IO_BITMAP_HEIGHT(ppdev, pjIoBase, cy);
            IO_DEST_XY(ppdev, pjIoBase, xDst, yDst);
            IO_SRC_XY(ppdev, pjIoBase, xDst + dxSrc, yDst + dySrc);
            IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);
        }
    }
    else
    {
        // Backward blt:

        cx   = prcl->right - prcl->left;
        cy   = prcl->bottom - prcl->top;
        xDst = prcl->left + cx - 1;
        yDst = prcl->top + cy - 1;

        IO_BITMAP_WIDTH(ppdev, pjIoBase, cx);
        IO_BITMAP_HEIGHT(ppdev, pjIoBase, cy);
        IO_DEST_XY(ppdev, pjIoBase, xDst, yDst);
        IO_SRC_XY(ppdev, pjIoBase, xDst + dxSrc, yDst + dySrc);
        IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT | BACKWARD);

        while (prcl++, --c)
        {
            cx   = prcl->right - prcl->left;
            cy   = prcl->bottom - prcl->top;
            xDst = prcl->left + cx - 1;
            yDst = prcl->top + cy - 1;

            IO_WAIT_BUFFER_NOT_BUSY(ppdev, pjIoBase);
            IO_BITMAP_WIDTH(ppdev, pjIoBase, cx);
            IO_BITMAP_HEIGHT(ppdev, pjIoBase, cy);
            IO_DEST_XY(ppdev, pjIoBase, xDst, yDst);
            IO_SRC_XY(ppdev, pjIoBase, xDst + dxSrc, yDst + dySrc);
            IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT | BACKWARD);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\bltmm.c ===
/******************************Module*Header*******************************\
* Module Name: bltmm.c
*
* Contains the low-level memory-mapped blt functions.  This module mirrors
* 'bltio.c'.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vMmFillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vMmFillSolid(              // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Mix
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjMmBase;

    ASSERTDD((rop4 >> 8) == (rop4 & 0xff), "Illegal mix");

    pjMmBase = ppdev->pjMmBase;

    MM_WAIT_FOR_IDLE(ppdev, pjMmBase);

    MM_PREG_COLOR_8(ppdev, pjMmBase, rbc.iSolidColor);
    MM_BLT_CMD_1(ppdev, pjMmBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);
    if (rop4 == 0xf0f0)
    {
        // Note block write:

        MM_CTRL_REG_1(ppdev, pjMmBase, PACKED_PIXEL_VIEW |
                                       BLOCK_WRITE       |
                                       BITS_PER_PIX_8    |
                                       ENAB_TRITON_MODE);
        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS    |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_PATTERN_REGS);
    }
    else
    {
        MM_CTRL_REG_1(ppdev, pjMmBase, PACKED_PIXEL_VIEW |
                                       BITS_PER_PIX_8    |
                                       ENAB_TRITON_MODE);
        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_ALL        |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_PATTERN_REGS);
        MM_ROP_A(ppdev, pjMmBase, rop4 >> 2);
    }

    MM_BITMAP_HEIGHT(ppdev, pjMmBase, prcl->bottom - prcl->top);
    MM_BITMAP_WIDTH(ppdev, pjMmBase, prcl->right - prcl->left);
    MM_DEST_XY(ppdev, pjMmBase, prcl->left, prcl->top);
    MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

    while (prcl++, --c)
    {
        MM_WAIT_BUFFER_NOT_BUSY(ppdev, pjMmBase);

        MM_BITMAP_HEIGHT(ppdev, pjMmBase, prcl->bottom - prcl->top);
        MM_BITMAP_WIDTH(ppdev, pjMmBase, prcl->right - prcl->left);
        MM_DEST_XY(ppdev, pjMmBase, prcl->left, prcl->top);
        MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);
    }
}

/******************************Public*Routine******************************\
* VOID vMmFillPat2Color
*
* This routine uses the QVision pattern hardware to draw a patterned list of
* rectangles.
*
\**************************************************************************/

VOID vMmFillPat2Color(          // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Mix
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjMmBase;
    LONG    xAlign;
    LONG    yAlign;

    ASSERTDD(((rop4 >> 8) == (rop4 & 0xff)) || ((rop4 & 0xff00) == 0xaa00),
             "Illegal mix");

    pjMmBase = ppdev->pjMmBase;
    xAlign   = pptlBrush->x;
    yAlign   = pptlBrush->y;

    MM_WAIT_FOR_IDLE(ppdev, pjMmBase);

    MM_FG_COLOR(ppdev, pjMmBase, rbc.prb->ulForeColor);
    MM_BG_COLOR(ppdev, pjMmBase, rbc.prb->ulBackColor);
    MM_PREG_PATTERN(ppdev, pjMmBase, rbc.prb->aulPattern);

    MM_CTRL_REG_1(ppdev, pjMmBase, EXPAND_TO_FG      |
                                   BITS_PER_PIX_8    |
                                   ENAB_TRITON_MODE);
    MM_BLT_CMD_1(ppdev, pjMmBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);

    if (rop4 == 0xf0f0)
    {
        // Opaque brush with PATCOPY rop:

        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS    |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_PATTERN_REGS);
    }
    else if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
    {
        // Opaque brush with rop other than PATCOPY:

        MM_ROP_A(ppdev, pjMmBase, rop4 >> 2);
        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_ALL        |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_PATTERN_REGS);
    }
    else if ((rop4 & 0xff) == 0xcc)
    {
        // Transparent brush with PATCOPY rop:

        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS      |
                                          PIXELMASK_AND_SRC_DATA |
                                          PLANARMASK_NONE_0XFF   |
                                          SRC_IS_PATTERN_REGS);
    }
    else
    {
        // Transparent brush with rop other than PATCOPY:

        MM_ROP_A(ppdev, pjMmBase, rop4 >> 2);
        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_ALL          |
                                          PIXELMASK_AND_SRC_DATA |
                                          PLANARMASK_NONE_0XFF   |
                                          SRC_IS_PATTERN_REGS);
    }

    MM_BITMAP_HEIGHT(ppdev, pjMmBase, prcl->bottom - prcl->top);
    MM_BITMAP_WIDTH(ppdev, pjMmBase, prcl->right - prcl->left);
    MM_DEST_XY(ppdev, pjMmBase, prcl->left, prcl->top);
    MM_SRC_ALIGN(ppdev, pjMmBase, ((prcl->left - xAlign) & 7) |
                                  ((prcl->top  - yAlign) << 3));
    MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

    while (prcl++, --c)
    {
        MM_WAIT_BUFFER_NOT_BUSY(ppdev, pjMmBase);

        MM_BITMAP_HEIGHT(ppdev, pjMmBase, prcl->bottom - prcl->top);
        MM_BITMAP_WIDTH(ppdev, pjMmBase, prcl->right - prcl->left);
        MM_DEST_XY(ppdev, pjMmBase, prcl->left, prcl->top);
        MM_SRC_ALIGN(ppdev, pjMmBase, ((prcl->left - xAlign) & 7) |
                                      ((prcl->top  - yAlign) << 3));
        MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);
    }
}

/******************************Public*Routine******************************\
* VOID vMmFillPatArbitraryRop
*
* This routine uses the QVision pattern hardware to draw a patterned list of
* rectangles.
*
\**************************************************************************/

VOID vMmFillPatArbitraryRop(    // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Mix
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjMmBase;
    LONG    xAlign;
    LONG    yAlign;
    LONG    lLinearDelta;
    BYTE*   pjPatternStart;
    LONG    xLeft;
    LONG    yTop;
    LONG    yBottom;
    LONG    lLinearDest;
    LONG    cy;
    LONG    iPattern;
    LONG    cyHeightOfEachBlt;
    LONG    cBltsBeforeHeightChange;
    LONG    cBlts;

    ASSERTDD((rop4 >> 8) == (rop4 & 0xff), "Illegal mix");

    pjMmBase     = ppdev->pjMmBase;
    xAlign       = pptlBrush->x;
    yAlign       = pptlBrush->y;
    lLinearDelta = ppdev->lDelta << 3;
    pjPatternStart    = (BYTE*) rbc.prb->aulPattern;

    MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
    MM_DEST_PITCH(ppdev, pjMmBase, (ppdev->lDelta << rbc.prb->cyLog2) >> 2);
    MM_CTRL_REG_1(ppdev, pjMmBase, PACKED_PIXEL_VIEW |
                                   BITS_PER_PIX_8    |
                                   ENAB_TRITON_MODE);
    MM_BLT_CMD_1(ppdev, pjMmBase, XY_SRC_ADDR |
                                  LIN_DEST_ADDR);

    if (rop4 == 0xf0f0)
    {
        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS    |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_PATTERN_REGS);
    }
    else
    {
        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_ALL        |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_PATTERN_REGS);
        MM_ROP_A(ppdev, pjMmBase, rop4 >> 2);
    }

    while (TRUE)
    {
        xLeft       = prcl->left;
        yTop        = prcl->top;
        lLinearDest = ((yTop + ppdev->yOffset) * lLinearDelta)
                    + ((xLeft + ppdev->xOffset) << 3);

        // Note that any registers we set now before the
        // WAIT_FOR_IDLE must be buffered, as this loop may be
        // executed multiple times when doing more than one
        // rectangle:

        MM_BITMAP_WIDTH(ppdev, pjMmBase, prcl->right - xLeft);
        MM_DEST_X(ppdev, pjMmBase, xLeft);
        MM_SRC_ALIGN(ppdev, pjMmBase, xLeft - xAlign);

        yBottom  = prcl->bottom;
        cy       = yBottom - yTop;
        iPattern = 8 * (yTop - yAlign);

        cyHeightOfEachBlt       = (cy >> rbc.prb->cyLog2) + 1;
        cBlts                   = min(cy, rbc.prb->cy);
        cBltsBeforeHeightChange = (cy & (rbc.prb->cy - 1)) + 1;

        if (cBltsBeforeHeightChange != 1)
            MM_BITMAP_HEIGHT(ppdev, pjMmBase, cyHeightOfEachBlt);

        do {
            // Need to wait for idle because we're about to modify the
            // pattern registers, which aren't buffered:

            MM_WAIT_FOR_IDLE(ppdev, pjMmBase);

            MM_PREG_PATTERN(ppdev, pjMmBase, pjPatternStart + (iPattern & 63));
            iPattern += 8;

            MM_DEST_LIN(ppdev, pjMmBase, lLinearDest);
            lLinearDest += lLinearDelta;

            cBltsBeforeHeightChange--;
            if (cBltsBeforeHeightChange == 0)
                MM_BITMAP_HEIGHT(ppdev, pjMmBase, cyHeightOfEachBlt - 1);

            MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

        } while (--cBlts != 0);

        if (--c == 0)
            break;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vMmFillPat
*
* This routine uses the QVision pattern hardware to draw a patterned list of
* rectangles.
*
\**************************************************************************/

VOID vMmFillPat(                // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // Mix
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjMmBase;
    LONG    xAlign;
    LONG    yAlign;
    LONG    iMax;
    LONG    lLinearDelta;
    BYTE*   pjPatternStart;
    LONG    xLeft;
    LONG    yTop;
    LONG    yBottom;
    LONG    lLinearDest;
    LONG    cy;
    LONG    iPattern;
    LONG    cyHeightOfEachBlt;
    LONG    cBltsBeforeHeightChange;
    LONG    cBlts;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    i;
    LONG    j;
    ULONG*  pulPattern;
    BOOL    bWriteMaskSet;

    if (!(rbc.prb->fl & RBRUSH_2COLOR))
    {
        if (rop4 == 0xf0f0)
        {
            pjMmBase = ppdev->pjMmBase;
            xAlign   = ((pptlBrush->x + ppdev->xOffset) & 7);
            iMax     = (8 << rbc.prb->cyLog2) - 1;

            // The pattern must be pre-aligned to use the QVision's
            // block-write capability for patterns.  We keep a cached
            // aligned copy in the brush itself:

            if (xAlign != rbc.prb->xBlockAlign)
            {
                rbc.prb->xBlockAlign = xAlign;

                pjSrc = (BYTE*) rbc.prb->aulPattern;
                pjDst = (BYTE*) rbc.prb->aulBlockPattern;

                i = rbc.prb->cy;
                do {
                    for (j = 0; j != 8; j++)
                        pjDst[(xAlign + j) & 7] = *pjSrc++;

                    pjDst += 8;
                } while (--i != 0);
            }

            bWriteMaskSet  = FALSE;
            pjPatternStart = (BYTE*) rbc.prb->aulBlockPattern;
            yAlign         = pptlBrush->y;
            lLinearDelta   = ppdev->lDelta << 3;

            MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
            MM_DEST_PITCH(ppdev, pjMmBase, (ppdev->lDelta << rbc.prb->cyLog2) >> 2);
            MM_CTRL_REG_1(ppdev, pjMmBase, PACKED_PIXEL_VIEW |
                                           BLOCK_WRITE       |
                                           BITS_PER_PIX_8    |
                                           ENAB_TRITON_MODE);
            MM_BLT_CMD_1(ppdev, pjMmBase, XY_SRC_ADDR |
                                          LIN_DEST_ADDR);
            MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS    |
                                              PIXELMASK_ONLY       |
                                              PLANARMASK_NONE_0XFF |
                                              SRC_IS_PATTERN_REGS);

            while (TRUE)
            {
                xLeft       = prcl->left;
                yTop        = prcl->top;
                lLinearDest = ((yTop + ppdev->yOffset) * lLinearDelta)
                            + ((xLeft + ppdev->xOffset) << 3);

                // Note that any registers we set now before the
                // WAIT_FOR_IDLE must be buffered, as this loop may be
                // executed multiple times when doing more than one
                // rectangle:

                MM_BITMAP_WIDTH(ppdev, pjMmBase, prcl->right - xLeft);
                MM_DEST_X(ppdev, pjMmBase, xLeft);

                yBottom  = prcl->bottom;
                cy       = yBottom - yTop;
                iPattern = 8 * (yTop - yAlign);

                cyHeightOfEachBlt       = (cy >> rbc.prb->cyLog2) + 1;
                cBlts                   = min(cy, rbc.prb->cy);
                cBltsBeforeHeightChange = (cy & (rbc.prb->cy - 1)) + 1;

                if (cBltsBeforeHeightChange != 1)
                    MM_BITMAP_HEIGHT(ppdev, pjMmBase, cyHeightOfEachBlt);

                do {
                    // Need to wait for idle because we're about to modify the
                    // pattern registers, which aren't buffered:

                    MM_WAIT_FOR_IDLE(ppdev, pjMmBase);

                    MM_DEST_LIN(ppdev, pjMmBase, lLinearDest);
                    lLinearDest += lLinearDelta;

                    cBltsBeforeHeightChange--;
                    if (cBltsBeforeHeightChange == 0)
                        MM_BITMAP_HEIGHT(ppdev, pjMmBase, cyHeightOfEachBlt - 1);

                    pulPattern = (ULONG*) (pjPatternStart + (iPattern & iMax));
                    iPattern += 8;

                    if (*(pulPattern) == *(pulPattern + 1))
                    {
                        // The pattern on this scan is 4 pixels wide, so we can
                        // do it in one pass:

                        MM_PREG_BLOCK(ppdev, pjMmBase, (pulPattern));
                        if (bWriteMaskSet)
                        {
                            bWriteMaskSet = FALSE;
                            MM_PIXEL_WRITE_MASK(ppdev, pjMmBase, 0xff);
                        }

                        MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);
                    }
                    else
                    {
                        // The pattern on this scan is 8 pixels wide, so we
                        // have to do it in two passes, using the pixel mask
                        // register:

                        bWriteMaskSet = TRUE;
                        MM_PREG_BLOCK(ppdev, pjMmBase, (pulPattern));
                        MM_PIXEL_WRITE_MASK(ppdev, pjMmBase, 0xf0);
                        MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

                        MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
                        MM_PREG_BLOCK(ppdev, pjMmBase, (pulPattern + 1));
                        MM_PIXEL_WRITE_MASK(ppdev, pjMmBase, 0x0f);
                        MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);
                    }
                } while (--cBlts != 0);

                if (--c == 0)
                    break;

                prcl++;
            }

            // Don't forget to reset the write mask when we're done:

            if (bWriteMaskSet)
            {
                MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
                MM_PIXEL_WRITE_MASK(ppdev, pjMmBase, 0xff);
            }
        }
        else
        {
            vMmFillPatArbitraryRop(ppdev, c, prcl, rop4, rbc, pptlBrush);
        }
    }
    else
    {
        vMmFillPat2Color(ppdev, c, prcl, rop4, rbc, pptlBrush);
    }
}

/******************************Public*Routine******************************\
* VOID vMmXfer1bpp
*
* This routine colours expands a monochrome bitmap, possibly with different
* Rop2's for the foreground and background.  It will be called in the
* following cases:
*
* 1) To colour-expand the monochrome text buffer for the vFastText routine.
* 2) To blt a 1bpp source with a simple Rop2 between the source and
*    destination.
* 3) To blt a true Rop3 when the source is a 1bpp bitmap that expands to
*    white and black, and the pattern is a solid colour.
* 4) To handle a true Rop4 that works out to be Rop2's between the pattern
*    and destination.
*
* Needless to say, making this routine fast can leverage a lot of
* performance.
*
\**************************************************************************/

VOID vMmXfer1bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Mix
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjMmBase;
    LONG    dxSrc;
    LONG    dySrc;      // Add delta to destination to get source
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjDstStart;
    LONG    yTop;
    LONG    xLeft;
    LONG    xRight;
    LONG    cx;
    LONG    cy;         // Dimensions of blt rectangle
    LONG    xBias;
    LONG    cjSrc;
    LONG    cdSrc;
    LONG    lSrcSkip;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    i;
    LONG    j;

    ASSERTDD((rop4 >> 8) == (rop4 & 0xff), "Illegal mix");

    pjMmBase  = ppdev->pjMmBase;

    dxSrc = pptlSrc->x - prclDst->left;
    dySrc = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;
    pjDstStart = ppdev->pjScreen;

    MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
    MM_CTRL_REG_1(ppdev, pjMmBase, EXPAND_TO_FG      |
                                   BITS_PER_PIX_8    |
                                   ENAB_TRITON_MODE);
    MM_BLT_CMD_1(ppdev, pjMmBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);
    MM_FG_COLOR(ppdev, pjMmBase, pxlo->pulXlate[1]);
    MM_BG_COLOR(ppdev, pjMmBase, pxlo->pulXlate[0]);

    if (rop4 == 0xcccc)
    {
        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS    |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_CPU_DATA);
    }
    else
    {
        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_ALL        |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_CPU_DATA);
        MM_ROP_A(ppdev, pjMmBase, rop4);
    }

    while (TRUE)
    {
        yTop   = prcl->top;
        xLeft  = prcl->left;
        xRight = prcl->right;

        cy = prcl->bottom - yTop;
        cx = xRight - xLeft;

        MM_BITMAP_WIDTH(ppdev, pjMmBase, cx);
        MM_BITMAP_HEIGHT(ppdev, pjMmBase, cy);
        MM_DEST_XY(ppdev, pjMmBase, xLeft, yTop);

        xBias = (xLeft + dxSrc) & 7;
        MM_SRC_ALIGN(ppdev, pjMmBase, xBias);
        xLeft -= xBias;

        cjSrc    = (xRight - xLeft + 7) >> 3;
        cdSrc    = cjSrc >> 2;
        lSrcSkip = lSrcDelta - (cdSrc << 2);

        pjSrc = pjSrcScan0 + (yTop + dySrc) * lSrcDelta
                           + ((xLeft + dxSrc) >> 3);

        MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

        switch(cjSrc & 3)
        {
        case 0:
            for (i = cy; i != 0; i--)
            {
                MEMORY_BARRIER();
                pjDst = pjDstStart;
                for (j = cdSrc; j != 0; j--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjDst += sizeof(ULONG);
                    pjSrc += sizeof(ULONG);
                }
                pjSrc += lSrcSkip;
            }
            break;

        case 1:
            for (i = cy; i != 0; i--)
            {
                MEMORY_BARRIER();
                pjDst = pjDstStart;
                for (j = cdSrc; j != 0; j--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjDst += sizeof(ULONG);
                    pjSrc += sizeof(ULONG);
                }
                WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                pjSrc += lSrcSkip;
            }
            break;

        case 2:
            for (i = cy; i != 0; i--)
            {
                MEMORY_BARRIER();
                pjDst = pjDstStart;
                for (j = cdSrc; j != 0; j--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjDst += sizeof(ULONG);
                    pjSrc += sizeof(ULONG);
                }
                WRITE_REGISTER_USHORT(pjDst, *((USHORT UNALIGNED *) pjSrc));
                pjSrc += lSrcSkip;
            }
            break;

        case 3:
            for (i = cy; i != 0; i--)
            {
                MEMORY_BARRIER();
                pjDst = pjDstStart;
                for (j = cdSrc; j != 0; j--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjDst += sizeof(ULONG);
                    pjSrc += sizeof(ULONG);
                }
                WRITE_REGISTER_USHORT(pjDst, *((USHORT UNALIGNED *) pjSrc));
                WRITE_REGISTER_UCHAR((pjDst + 2), *(pjSrc + 2));
                pjSrc += lSrcSkip;
            }
            break;
        }

        MM_WAIT_TRANSFER_DONE(ppdev, pjMmBase);

        if (--c == 0)
            break;

        prcl++;
        MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
    }
}

/******************************Public*Routine******************************\
* VOID vMmCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
\**************************************************************************/

VOID vMmCopyBlt(    // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // Hardware mix
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BYTE*   pjMmBase;
    LONG    dxSrc;
    LONG    dySrc;      // Add delta to destination to get source
    LONG    cx;
    LONG    cy;         // Dimensions of blt rectangle
    LONG    xDst;
    LONG    yDst;       // Start point of destination

    ASSERTDD((rop4 >> 8) == (rop4 & 0xff), "Illegal mix");

    pjMmBase  = ppdev->pjMmBase;

    dxSrc = pptlSrc->x - prclDst->left;
    dySrc = pptlSrc->y - prclDst->top;

    MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
    MM_CTRL_REG_1(ppdev, pjMmBase, PACKED_PIXEL_VIEW |  // !!! Need this each time?
                                   BITS_PER_PIX_8    |
                                   ENAB_TRITON_MODE);
    MM_BLT_CMD_1(ppdev, pjMmBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);
    if (rop4 == 0xcccc)
    {
        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS    |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_SCRN_LATCHES);
    }
    else
    {
        MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_ALL        |
                                          PIXELMASK_ONLY       |
                                          PLANARMASK_NONE_0XFF |
                                          SRC_IS_SCRN_LATCHES);
        MM_ROP_A(ppdev, pjMmBase, rop4);
    }

    if ((prclDst->top < pptlSrc->y) ||
        (prclDst->top == pptlSrc->y) && (prclDst->left <= pptlSrc->x))
    {
        // Forward blt:

        cx   = prcl->right - prcl->left;
        cy   = prcl->bottom - prcl->top;
        xDst = prcl->left;
        yDst = prcl->top;

        MM_BITMAP_WIDTH(ppdev, pjMmBase, cx);
        MM_BITMAP_HEIGHT(ppdev, pjMmBase, cy);
        MM_DEST_XY(ppdev, pjMmBase, xDst, yDst);
        MM_SRC_XY(ppdev, pjMmBase, xDst + dxSrc, yDst + dySrc);
        MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

        while (prcl++, --c)
        {
            cx   = prcl->right - prcl->left;
            cy   = prcl->bottom - prcl->top;
            xDst = prcl->left;
            yDst = prcl->top;

            MM_WAIT_BUFFER_NOT_BUSY(ppdev, pjMmBase);
            MM_BITMAP_WIDTH(ppdev, pjMmBase, cx);
            MM_BITMAP_HEIGHT(ppdev, pjMmBase, cy);
            MM_DEST_XY(ppdev, pjMmBase, xDst, yDst);
            MM_SRC_XY(ppdev, pjMmBase, xDst + dxSrc, yDst + dySrc);
            MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);
        }
    }
    else
    {
        // Backward blt:

        cx   = prcl->right - prcl->left;
        cy   = prcl->bottom - prcl->top;
        xDst = prcl->left + cx - 1;
        yDst = prcl->top + cy - 1;

        MM_BITMAP_WIDTH(ppdev, pjMmBase, cx);
        MM_BITMAP_HEIGHT(ppdev, pjMmBase, cy);
        MM_DEST_XY(ppdev, pjMmBase, xDst, yDst);
        MM_SRC_XY(ppdev, pjMmBase, xDst + dxSrc, yDst + dySrc);
        MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT | BACKWARD);

        while (prcl++, --c)
        {
            cx   = prcl->right - prcl->left;
            cy   = prcl->bottom - prcl->top;
            xDst = prcl->left + cx - 1;
            yDst = prcl->top + cy - 1;

            MM_WAIT_BUFFER_NOT_BUSY(ppdev, pjMmBase);
            MM_BITMAP_WIDTH(ppdev, pjMmBase, cx);
            MM_BITMAP_HEIGHT(ppdev, pjMmBase, cy);
            MM_DEST_XY(ppdev, pjMmBase, xDst, yDst);
            MM_SRC_XY(ppdev, pjMmBase, xDst + dxSrc, yDst + dySrc);
            MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT | BACKWARD);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData);  // # of vertices with more than
                                                //  zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

// Set this bit when GDI's HOOK_SYNCHRONIZEACCESS works so that we don't
// have to worry about synchronizing device-bitmap access.  Note that
// this wasn't an option in the first release of NT:

#define SYNCHRONIZEACCESS_WORKS 1

// When running on an x86, we can make banked call-backs to GDI where
// GDI can write directly on the frame buffer.  The Alpha has a weird
// bus scheme, and can't do that:

#if !defined(_ALPHA_)
    #define GDI_BANKING         1
#else
    #define GDI_BANKING         0
#endif

// Multi-board support can be enabled by setting this to 1:

#define MULTI_BOARDS            0

// This is the maximum number of boards we'll support in a single
// virtual driver:

#if MULTI_BOARDS
    #define MAX_BOARDS          16
    #define IBOARD(ppdev)       ((ppdev)->iBoard)
#else
    #define MAX_BOARDS          1
    #define IBOARD(ppdev)       0
#endif

// Useful for visualizing the 2-d heap:

#define DEBUG_HEAP              0

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"QV"       // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "Qv: "      // All debug output is prefixed
                                            //   by this string
#define ALLOC_TAG               ' vqD'      // Dqv
                                            // Four byte tag (characters in
                                            // reverse order) used for memory
                                            // allocations

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define TMP_BUFFER_SIZE     8192  // Size in bytes of 'pvTmpBuffer'.  Has to
                                  //   be at least enough to store an entire
                                  //   scan line (i.e., 6400 for 1600x1200x32).

#if defined(ALPHA)
    #define XFER_BUFFERS    16  // Defines the maximum number of write buffers
                                //   possible on any Alpha.  Must be a power
#else                           //   of two.
    #define XFER_BUFFERS    1   // On non-alpha systems, we don't have to
                                //   worry about the chip caching our bus
#endif                          //   writes.

#define XFER_MASK           (XFER_BUFFERS - 1)

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */

typedef struct _PDEV PDEV;      // Handy forward declaration

VOID vSetClipping(PDEV*, RECTL*);
VOID vResetClipping(PDEV*);

//////////////////////////////////////////////////////////////////////
// Text stuff

#define GLYPH_CACHE_HEIGHT  32  // Number of scans to allocate for glyph cache

#define GLYPH_GRANULARITY   31  // Horizontal granularity for packing glyphs,
                                //   expressed in pixels as width minus one

#define GLYPH_CACHE_CX      32  // Maximal width of glyphs that we'll consider
                                //   caching

#define GLYPH_CACHE_CY      32  // Maximum height of glyphs that we'll consider
                                //   caching

#define MAX_GLYPH_SIZE      ((((GLYPH_CACHE_CX + GLYPH_GRANULARITY) & ~GLYPH_GRANULARITY) \
                             * GLYPH_CACHE_CY + 7) / 8)
                                // Maximum amount of off-screen memory required
                                //   to cache a glyph, in bytes

#define GLYPH_ALLOC_SIZE    8100
                                // Do all cached glyph memory allocations
                                //   in 8k chunks

#define HGLYPH_SENTINEL     ((ULONG) -1)
                                // GDI will never give us a glyph with a
                                //   handle value of 0xffffffff, so we can
                                //   use this as a sentinel for the end of
                                //   our linked lists

#define GLYPH_HASH_SIZE     256

#define GLYPH_HASH_FUNC(x)  ((x) & (GLYPH_HASH_SIZE - 1))

typedef struct _CACHEDGLYPH CACHEDGLYPH;
typedef struct _CACHEDGLYPH
{
    CACHEDGLYPH*    pcgNext;    // Points to next glyph that was assigned
                                //   to the same hash table bucket
    HGLYPH          hg;         // Handles in the bucket-list are kept in
                                //   increasing order
    POINTL          ptlOrigin;  // Origin of glyph bits
    LONG            yxHeightWidth;
                                // Packed height and width of glyph
    ULONG           ulSrcLin;   // QVision style linear address for glyph in
                                //   off-screen memory
} CACHEDGLYPH;  /* cg, pcg */

typedef struct _GLYPHALLOC GLYPHALLOC;
typedef struct _GLYPHALLOC
{
    GLYPHALLOC*     pgaNext;    // Points to next glyph structure that
                                //   was allocated for this font
    CACHEDGLYPH     acg[1];     // This array is a bit misleading, because
                                //   the CACHEDGLYPH structures are actually
                                //   variable sized
} GLYPHAALLOC;  /* ga, pga */

typedef struct _CACHEDFONT CACHEDFONT;
typedef struct _CACHEDFONT
{
    CACHEDFONT*     pcfNext;    // Points to next entry in CACHEDFONT list
    CACHEDFONT*     pcfPrev;    // Points to previous entry in CACHEDFONT list
    GLYPHALLOC*     pgaChain;   // Points to start of allocated memory list
    CACHEDGLYPH*    pcgNew;     // Points to where in the current glyph
                                //   allocation structure a new glyph should
                                //   be placed
    LONG            cjAlloc;    // Bytes remaining in current glyph allocation
                                //   structure
    CACHEDGLYPH     cgSentinel; // Sentinel entry of the end of our bucket
                                //   lists, with a handle of HGLYPH_SENTINEL
    CACHEDGLYPH*    apcg[GLYPH_HASH_SIZE];
                                // Hash table for glyphs

} CACHEDFONT;   /* cf, pcf */

BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);

//////////////////////////////////////////////////////////////////////
// Brush stuff

#define RBRUSH_2COLOR           1   // For RBRUSH flags
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

typedef struct _BRUSHENTRY BRUSHENTRY;

// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
//       in strucs.inc!

typedef struct _RBRUSH {
    FLONG       fl;             // Type flags
    ULONG       ulForeColor;    // Foreground colour if 1bpp
    ULONG       ulBackColor;    // Background colour if 1bpp
    LONG        cy;             // Unique height of pattern
    ULONG       cyLog2;         // Unique height expressed as power of 2
    LONG        xBlockAlign;    // 'x' alignment of block-write pattern
    ULONG       aulBlockPattern[TOTAL_BRUSH_SIZE / 4];
                                // Contains screen-aligned version of
                                //   'aulPattern', used for block-write
                                //   patterns; -1 indicates it's not yet
                                //   aligned
    ULONG       aulPattern[1];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)
} RBRUSH;                           /* rb, prb */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */

BOOL bEnableBrushCache(PDEV*);
VOID vDisableBrushCache(PDEV*);
VOID vAssertModeBrushCache(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Heap stuff

typedef enum {
    OFL_INUSE       = 1,    // The device bitmap is no longer located in
                            //   off-screen memory; it's been converted to
                            //   a DIB
    OFL_AVAILABLE   = 2,    // Space is in-use
    OFL_PERMANENT   = 4     // Space is available
} OHFLAGS;                  // Space is permanently allocated; never free it

typedef struct _DSURF DSURF;
typedef struct _OH OH;
typedef struct _OH
{
    OHFLAGS  ofl;           // OH_ flags
    LONG     x;             // x-coordinate of left edge of allocation
    LONG     y;             // y-coordinate of top edge of allocation
    LONG     cx;            // Width in pixels of allocation
    LONG     cy;            // Height in pixels of allocation
    OH*      pohNext;       // When OFL_AVAILABLE, points to the next free node,
                            //   in ascending cxcy value.  This is kept as a
                            //   circular doubly-linked list with a sentinel
                            //   at the end.
                            // When OFL_INUSE, points to the next most recently
                            //   blitted allocation.  This is kept as a circular
                            //   doubly-linked list so that the list can be
                            //   quickly be updated on every blt.
    OH*      pohPrev;       // Opposite of 'pohNext'
    ULONG    cxcy;          // Width and height in a dword for searching
    OH*      pohLeft;       // Adjacent allocation when in-use or available
    OH*      pohUp;
    OH*      pohRight;
    OH*      pohDown;
    DSURF*   pdsurf;        // Points to our DSURF structure
};                              /* oh, poh */

// This is the smallest structure used for memory allocations:

typedef struct _OHALLOC OHALLOC;
typedef struct _OHALLOC
{
    OHALLOC* pohaNext;
    OH       aoh[1];
} OHALLOC;                      /* oha, poha */

typedef struct _HEAP
{
    LONG     cxMax;         // Largest possible free space by area
    LONG     cyMax;
    OH       ohAvailable;   // Head of available list (pohNext points to
                            //   smallest available rectangle, pohPrev
                            //   points to largest available rectangle,
                            //   sorted by cxcy)
    OH       ohDfb;         // Head of the list of all DFBs currently in
                            //   offscreen memory that are eligible to be
                            //   tossed out of the heap (pohNext points to
                            //   the most recently blitted; pohPrev points
                            //   to least recently blitted)
    OH*      pohFreeList;   // List of OH node data structures available
    OHALLOC* pohaChain;     // Chain of allocations
} HEAP;                         /* heap, pheap */

typedef enum {
    DT_SCREEN,              // Surface is kept in screen memory
    DT_DIB                  // Surface is kept as a DIB
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap
    union {
        OH*         poh;    // If DT_SCREEN, points to off-screen heap node
        SURFOBJ*    pso;    // If DT_DIB, points to locked GDI surface
    };

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

} DSURF;                          /* dsurf, pdsurf */

// GDI expects dword alignment for any bitmaps on which it is expected
// to draw.  Since we occasionally ask GDI to draw directly on our off-
// screen bitmaps, this means that any off-screen bitmaps must be dword
// aligned in the frame buffer.  We enforce this merely by ensuring that
// all off-screen bitmaps are four-pel aligned (we may waste a couple of
// pixels at the higher colour depths):

#define HEAP_X_ALIGNMENT    4

// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:

#define HEAP_COUNT_DOWN     6

// Flags for 'pohAllocate':

typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x00000001,   // Don't kick stuff out of off-
                                            //   screen memory to make room
} FLOH;

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);

OH*  pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);
OH*  pohAllocatePermanent(PDEV*, LONG, LONG);
BOOL bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev);

/////////////////////////////////////////////////////////////////////////
// Bank manager stuff

#define BANK_DATA_SIZE  80      // Number of bytes to allocate for the
                                //   miniport down-loaded bank code working
                                //   space

typedef struct _BANK
{
    // Private data:

    RECTL    rclDraw;           // Rectangle describing the remaining undrawn
                                //   portion of the drawing operation
    RECTL    rclSaveBounds;     // Saved from original CLIPOBJ for restoration
    BYTE     iSaveDComplexity;  // Saved from original CLIPOBJ for restoration
    BYTE     fjSaveOptions;     // Saved from original CLIPOBJ for restoration
    LONG     iBank;             // Current bank
    PDEV*    ppdev;             // Saved copy

    // Public data:

    SURFOBJ* pso;               // Surface wrapped around the bank.  Has to be
                                //   passed as the surface in any banked call-
                                //   back.
    CLIPOBJ* pco;               // Clip object that is the intersection of the
                                //   original clip object with the bounds of the
                                //   current bank.  Has to be passed as the clip
                                //   object in any banked call-back.

} BANK;                         /* bnk, pbnk */

typedef enum {
    BANK_OFF = 0,       // We've finished using the memory aperture
    BANK_ON,            // We're about to use the memory aperture
    BANK_DISABLE,       // We're about to enter full-screen; shut down banking
    BANK_ENABLE,        // We've exited full-screen; re-enable banking

} BANK_MODE;                    /* bankm, pbankm */

typedef BOOL (FNBANKCOMPUTE)(PDEV*, RECTL*, RECTL*, LONG*, LONG*);

VOID vBankStart(PDEV*, RECTL*, CLIPOBJ*, BANK*);
BOOL bBankEnum(BANK*);

FNBANKCOMPUTE bBankComputeNonPower2;
FNBANKCOMPUTE bBankComputePower2;

BOOL bEnableBanking(PDEV*);
VOID vDisableBanking(PDEV*);
VOID vAssertModeBanking(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Pointer stuff

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);
BOOL bInitializePointer(PDEV*);
VOID vUninitializePointer(PDEV*);

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette(PDEV*);
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

/////////////////////////////////////////////////////////////////////////
// 3D DDI Rendering Extension stuff

BOOL bEnableRx(PDEV*);
VOID vDisableRx(PDEV*);
VOID vAssertModeRx(PDEV*, BOOL);

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ULONG, RBRUSH_COLOR, POINTL*);
typedef VOID (FNXFER)(PDEV*, LONG, RECTL*, ULONG, SURFOBJ*, POINTL*,
                      RECTL*, XLATEOBJ*);
typedef VOID (FNCOPY)(PDEV*, LONG, RECTL*, ULONG, POINTL*, RECTL*);
typedef VOID (FNTEXTOUT)(PDEV*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*,
                         BRUSHOBJ*, BRUSHOBJ*);

FNFILL      vIoFillPat;
FNFILL      vIoFillSolid;
FNXFER      vIoXfer1bpp;
FNCOPY      vIoCopyBlt;
FNTEXTOUT   vIoTextOut;

FNFILL      vMmFillPat;
FNFILL      vMmFillSolid;
FNXFER      vMmXfer1bpp;
FNCOPY      vMmCopyBlt;
FNTEXTOUT   vMmTextOut;

VOID vPutBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vGetBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
BOOL bFastFill(PDEV*, LONG, POINTFIX*, ULONG, ULONG, RBRUSH*, POINTL*);

////////////////////////////////////////////////////////////////////////
// Capabilities flags
//
// These are private flags passed to us from the S3 miniport.  They
// come from the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the S3 miniport's 's3.h'!

typedef enum {
} CAPS;

////////////////////////////////////////////////////////////////////////
// Status flags

typedef enum {
    STAT_UNACCELERATED      = 0x0001,   // Unaccelerated 16bpp or 32bpp mode
    STAT_GLYPH_CACHE        = 0x0002,   // Off-screen glyph cache allocated
} STATUS;

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    LONG        xOffset;                // Pixel offset from (0, 0) to current
    LONG        yOffset;                //   DFB located in off-screen memory
    BYTE*       pjMmBase;               // Start of memory mapped I/O
    BYTE*       pjScreen;               // Points to base screen address
    LONG        lDelta;                 // Distance from one scan to the next.
    LONG        cPelSize;               // 0 if 8bpp, 1 if 16bpp, 2 if 32bpp
    ULONG       iBitmapFormat;          // BMF_8BPP or BMF_16BPP or BMF_32BPP
                                        //   (our current colour depth)
    LONG        iBoard;                 // Logical multi-board identifier
                                        //   (zero by default)

    // Rendering extensions colour information.

    UCHAR       rDepth;                 // Number of red bits
    UCHAR       gDepth;                 // Number of green bits
    UCHAR       bDepth;                 // Number of blue bits
    UCHAR       aDepth;                 // Number of alpha bits
    UCHAR       rBitShift;              // Left bit-shift for red component
    UCHAR       gBitShift;              // Left bit-shift for green component
    UCHAR       bBitShift;              // Left bit-shift for blue component
    UCHAR       aBitShift;              // Left bit-shift for alpha component

    BYTE*       pjIoBase;               // !!!
    LONG        cjPel;                  // !!!
    CAPS        flCaps;                 // Capabilities flags
    STATUS      flStat;                 // Status flags
    BOOL        bEnabled;               // In graphics mode (not full-screen)

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF*      pdsurfScreen;           // Our private DSURF for the screen

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyMemory;               // Height of Video RAM
    ULONG       ulMode;                 // Mode the mini-port driver is in.

    FLONG       flHooks;                // What we're hooking from GDI
    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    VOID*       pvTmpBuffer;            // General purpose temporary buffer,
                                        //   TMP_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)

    ////////// Low-level blt function pointers:

    FNFILL*     pfnFillSolid;
    FNFILL*     pfnFillPat;
    FNXFER*     pfnXfer1bpp;
    FNCOPY*     pfnCopyBlt;
    FNTEXTOUT*  pfnTextOut;

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields
    ULONG       cPaletteShift;          // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.
    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap

    ////////// Banking stuff:

    LONG        cjBank;                 // Size of a bank, in bytes
    LONG        cPower2ScansPerBank;    // Used by 'bBankComputePower2'
    LONG        cPower2BankSizeInBytes; // Used by 'bBankComputePower2'
    CLIPOBJ*    pcoBank;                // Clip object for banked call backs
    SURFOBJ*    psoBank;                // Surface object for banked call backs
    PFN         pfnBankSwitchCode;      // Pointer to bank switch code
    VIDEO_BANK_SELECT* pBankInfo;       // Bank info for current mode returned
                                        //   by miniport

    FNBANKCOMPUTE*      pfnBankCompute;

    ////////// Pointer stuff:

    VIDEO_POINTER_CAPABILITIES PointerCapabilities;
                                        // Capabilities of the hardware
                                        //   pointer, as reported back by
                                        //   the miniport
    VIDEO_POINTER_ATTRIBUTES*  pPointerAttributes;
                                        // Points to attributes buffer for
                                        //   current pointer shape
    LONG        cjPointerAttributes;    // Length of allocated pointer
                                        //   attributes buffer
    LONG        cjXorMaskStartOffset;   // Offset from start of AND buffer to
                                        //   start of XOR buffer, in bytes
    POINTL      ptlHotSpot;             // Current pointer hot-spot
    BOOL        bPointerEnabled;        // True if pointer is current visible

    ////////// Brush stuff:

    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    POINTL      ptlReRealize;           // Work area for 864/964 pattern
                                        //   hardware bug work-around

    ////////// Text stuff:

    LONG        xGlyphCurrent;          // x-position of next glyph to be
                                        //   cached in off-screen memory
    LONG        yGlyphCurrent;          // y-position of next glyph
    LONG        yGlyphStart;            // y-coordinate of start of glyph cache
    LONG        yGlyphEnd;              // y-coordinate of one-past end of
                                        //   cache
    CACHEDFONT  cfSentinel;             // Sentinel for the doubly-linked list
                                        //   we use to keep track of all
                                        //   cached font allocations

    ////////// 3D DDI Rendering Extension stuff:

    VOID*       pvOut;                  // Points to current output buffer
    VOID*       pvOutMax;               // Points to end of current output buffer
    VOID*       pvInMax;                // Points to end of current input buffer
    OH*         pohFrontBuffer;         // Allocation structure for the screen
    OH*         pohBackBuffer;          // Allocation structure for optional
                                        //   off-screen back buffer
    LONG        cDoubleBufferRef;       // Reference count for current number
                                        //   of RC's that have active double-
                                        //   buffers
    POINTL      ptlDoubleBuffer[2];     // (x, y) positions of front and back
                                        //   buffers in video memory
                                        //   0 -- RX_BACK_LEFT
                                        //   1 -- RX_FRONT_LEFT
                                        // Note: Make sure that the index
                                        //   is in the range [0, 1]!

} PDEV;

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*);

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);

extern BYTE gaRop3FromMix[];
extern BYTE gabMixNeedsPattern[];
extern BYTE gabRopNeedsPattern[];

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

/////////////////////////////////////////////////////////////////////////
// SWAP - Swaps the value of two variables, using a temporary variable

#define SWAP(a, b, tmp) { (tmp) = (a); (a) = (b); (b) = (tmp); }

//////////////////////////////////////////////////////////////////////
// These Mul prototypes are thunks for multi-board support:

ULONG   MulGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  MulEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    MulCompletePDEV(DHPDEV, HDEV);
HSURF   MulEnableSurface(DHPDEV);
BOOL    MulStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    MulFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    MulBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    MulDisablePDEV(DHPDEV);
VOID    MulDisableSurface(DHPDEV);
BOOL    MulAssertMode(DHPDEV, BOOL);
VOID    MulMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   MulSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   MulDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    MulSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    MulCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    MulTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    MulDestroyFont(FONTOBJ*);
BOOL    MulPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    MulRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP MulCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    MulDeleteDeviceBitmap(DHSURF);
BOOL    MulStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);

// These Dbg prototypes are thunks for debugging:

ULONG   DbgGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  DbgEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    DbgCompletePDEV(DHPDEV, HDEV);
HSURF   DbgEnableSurface(DHPDEV);
BOOL    DbgStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    DbgFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    DbgBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    DbgDisablePDEV(DHPDEV);
VOID    DbgDisableSurface(DHPDEV);
BOOL    DbgAssertMode(DHPDEV, BOOL);
VOID    DbgMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   DbgSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   DbgDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    DbgSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    DbgCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    DbgTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    DbgDestroyFont(FONTOBJ*);
BOOL    DbgPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    DbgRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP DbgCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    DbgDeleteDeviceBitmap(DHSURF);
BOOL    DbgStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);
BOOL    DbgEscape(SURFOBJ*, ULONG, ULONG, VOID*, ULONG, VOID*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\fastfill.c ===
/******************************Module*Header*******************************\
* Module Name: fastfill.c
*
* Draws fast solid-coloured, unclipped, non-complex rectangles.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define RIGHT 0
#define LEFT  1

typedef struct _TRAPEZOIDDATA TRAPEZOIDDATA;    // Handy forward declaration

typedef VOID (FNTRAPEZOID)(TRAPEZOIDDATA*, LONG, LONG);
                                                // Prototype for trapezoid
                                                //   drawing routines

typedef struct _EDGEDATA {
LONG      x;                // Current x position
LONG      dx;               // # pixels to advance x on each scan
LONG      lError;           // Current DDA error
LONG      lErrorUp;         // DDA error increment on each scan
LONG      lErrorDown;       // DDA error adjustment
POINTFIX* pptfx;            // Points to start of current edge
LONG      dptfx;            // Delta (in bytes) from pptfx to next point
LONG      cy;               // Number of scans to go for this edge
} EDGEDATA;                         /* ed, ped */

typedef struct _TRAPEZOIDDATA {
FNTRAPEZOID*    pfnTrap;    // Pointer to appropriate trapezoid drawing routine
PDEV*           ppdev;      // Pointer to PDEV
EDGEDATA        aed[2];     // DDA information for both edges
RBRUSH*         prb;        // Pointer to brush realization
POINTL          ptlBrush;   // Brush alignment
} TRAPEZOIDDATA;                    /* td, ptd */

/******************************Public*Routine******************************\
* VOID vIoSolidTrapezoid
*
\**************************************************************************/

VOID vIoSolidTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV* ppdev    = ptd->ppdev;
    BYTE* pjIoBase = ppdev->pjIoBase;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 1))
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

    ContinueVertical:

        lWidth = ptd->aed[RIGHT].x - ptd->aed[LEFT].x;
        if (lWidth > 0)
        {
            IO_WAIT_BUFFER_NOT_BUSY(ppdev, pjIoBase);
            IO_BITMAP_WIDTH(ppdev, pjIoBase, lWidth);
            IO_BITMAP_HEIGHT(ppdev, pjIoBase, cyTrapezoid);
            IO_DEST_XY(ppdev, pjIoBase, ptd->aed[LEFT].x, yTrapezoid);
            IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

            IO_WAIT_BUFFER_NOT_BUSY(ppdev, pjIoBase);
            IO_BITMAP_HEIGHT(ppdev, pjIoBase, 1);
        }
        else if (lWidth < 0)
        {
            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(ptd->aed[LEFT].x,     ptd->aed[RIGHT].x,     lTmp);
            SWAP(ptd->aed[LEFT].cy,    ptd->aed[RIGHT].cy,    lTmp);
            SWAP(ptd->aed[LEFT].dptfx, ptd->aed[RIGHT].dptfx, lTmp);
            SWAP(ptd->aed[LEFT].pptfx, ptd->aed[RIGHT].pptfx, pptfxTmp);
            goto ContinueVertical;
        }
    }
    else
    {
        LONG lLeftError  = ptd->aed[LEFT].lError;
        LONG dxLeft      = ptd->aed[LEFT].dx;
        LONG xLeft       = ptd->aed[LEFT].x;
        LONG lRightError = ptd->aed[RIGHT].lError;
        LONG dxRight     = ptd->aed[RIGHT].dx;
        LONG xRight      = ptd->aed[RIGHT].x;

        while (TRUE)
        {
            LONG lWidth;

            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            lWidth = xRight - xLeft;
            if (lWidth > 0)
            {
                IO_WAIT_BUFFER_NOT_BUSY(ppdev, pjIoBase);
                IO_BITMAP_WIDTH(ppdev, pjIoBase, lWidth);
                IO_DEST_XY(ppdev, pjIoBase, xLeft, yTrapezoid);
                IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

            ContinueAfterZero:

                yTrapezoid++;

                // Advance the right wall:

                xRight      += dxRight;
                lRightError += ptd->aed[RIGHT].lErrorUp;

                if (lRightError >= 0)
                {
                    lRightError -= ptd->aed[RIGHT].lErrorDown;
                    xRight++;
                }

                // Advance the left wall:

                xLeft      += dxLeft;
                lLeftError += ptd->aed[LEFT].lErrorUp;

                if (lLeftError >= 0)
                {
                    lLeftError -= ptd->aed[LEFT].lErrorDown;
                    xLeft++;
                }

                cyTrapezoid--;
                if (cyTrapezoid == 0)
                    break;
            }
            else if (lWidth == 0)
            {
                goto ContinueAfterZero;
            }
            else
            {
                // We certainly don't want to optimize for this case because we
                // should rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves):

                LONG      lTmp;
                POINTFIX* pptfxTmp;

                SWAP(xLeft,                     xRight,                     lTmp);
                SWAP(dxLeft,                    dxRight,                    lTmp);
                SWAP(lLeftError,                lRightError,                lTmp);
                SWAP(ptd->aed[LEFT].lErrorUp,   ptd->aed[RIGHT].lErrorUp,   lTmp);
                SWAP(ptd->aed[LEFT].lErrorDown, ptd->aed[RIGHT].lErrorDown, lTmp);
                SWAP(ptd->aed[LEFT].cy,         ptd->aed[RIGHT].cy,         lTmp);
                SWAP(ptd->aed[LEFT].dptfx,      ptd->aed[RIGHT].dptfx,      lTmp);
                SWAP(ptd->aed[LEFT].pptfx,      ptd->aed[RIGHT].pptfx,      pptfxTmp);
            }
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].dx      = dxLeft;
        ptd->aed[LEFT].x       = xLeft;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].dx     = dxRight;
        ptd->aed[RIGHT].x      = xRight;
    }
}

/******************************Public*Routine******************************\
* VOID vIo2ColorTrapezoid
*
\**************************************************************************/

VOID vIo2ColorTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*   ppdev    = ptd->ppdev;
    BYTE*   pjIoBase = ppdev->pjIoBase;
    LONG    xAlign;
    LONG    yAlign;

    xAlign = ptd->ptlBrush.x;
    yAlign = ptd->ptlBrush.y;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 1))
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

    ContinueVertical:

        lWidth = ptd->aed[RIGHT].x - ptd->aed[LEFT].x;
        if (lWidth > 0)
        {
            IO_WAIT_BUFFER_NOT_BUSY(ppdev, pjIoBase);
            IO_BITMAP_WIDTH(ppdev, pjIoBase, lWidth);
            IO_BITMAP_HEIGHT(ppdev, pjIoBase, cyTrapezoid);
            IO_DEST_XY(ppdev, pjIoBase, ptd->aed[LEFT].x, yTrapezoid);
            IO_SRC_ALIGN(ppdev, pjIoBase, ((ptd->aed[LEFT].x - xAlign) & 7) |
                                          ((yTrapezoid  - yAlign) << 3));
            IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

            IO_WAIT_BUFFER_NOT_BUSY(ppdev, pjIoBase);
            IO_BITMAP_HEIGHT(ppdev, pjIoBase, 1);
        }
        else if (lWidth < 0)
        {
            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(ptd->aed[LEFT].x,     ptd->aed[RIGHT].x,     lTmp);
            SWAP(ptd->aed[LEFT].cy,    ptd->aed[RIGHT].cy,    lTmp);
            SWAP(ptd->aed[LEFT].dptfx, ptd->aed[RIGHT].dptfx, lTmp);
            SWAP(ptd->aed[LEFT].pptfx, ptd->aed[RIGHT].pptfx, pptfxTmp);
            goto ContinueVertical;
        }
    }
    else
    {
        LONG lLeftError  = ptd->aed[LEFT].lError;
        LONG dxLeft      = ptd->aed[LEFT].dx;
        LONG xLeft       = ptd->aed[LEFT].x;
        LONG lRightError = ptd->aed[RIGHT].lError;
        LONG dxRight     = ptd->aed[RIGHT].dx;
        LONG xRight      = ptd->aed[RIGHT].x;
        LONG yScaledAlign;

        // Scale y alignment up by 8 so that it's easier to compute
        // the QVision's alignment on each scan:

        yScaledAlign = (yTrapezoid - yAlign) << 3;

        while (TRUE)
        {
            LONG lWidth;

            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            lWidth = xRight - xLeft;
            if (lWidth > 0)
            {
                IO_WAIT_BUFFER_NOT_BUSY(ppdev, pjIoBase);
                IO_BITMAP_WIDTH(ppdev, pjIoBase, lWidth);
                IO_DEST_XY(ppdev, pjIoBase, xLeft, yTrapezoid);
                IO_SRC_ALIGN(ppdev, pjIoBase, (((xLeft - xAlign) & 7)
                                              | yScaledAlign));
                IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

            ContinueAfterZero:

                yScaledAlign += 8;
                yTrapezoid++;

                // Advance the right wall:

                xRight      += dxRight;
                lRightError += ptd->aed[RIGHT].lErrorUp;

                if (lRightError >= 0)
                {
                    lRightError -= ptd->aed[RIGHT].lErrorDown;
                    xRight++;
                }

                // Advance the left wall:

                xLeft      += dxLeft;
                lLeftError += ptd->aed[LEFT].lErrorUp;

                if (lLeftError >= 0)
                {
                    lLeftError -= ptd->aed[LEFT].lErrorDown;
                    xLeft++;
                }

                cyTrapezoid--;
                if (cyTrapezoid == 0)
                    break;
            }
            else if (lWidth == 0)
            {
                goto ContinueAfterZero;
            }
            else
            {
                // We certainly don't want to optimize for this case because we
                // should rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves):

                LONG      lTmp;
                POINTFIX* pptfxTmp;

                SWAP(xLeft,                     xRight,                     lTmp);
                SWAP(dxLeft,                    dxRight,                    lTmp);
                SWAP(lLeftError,                lRightError,                lTmp);
                SWAP(ptd->aed[LEFT].lErrorUp,   ptd->aed[RIGHT].lErrorUp,   lTmp);
                SWAP(ptd->aed[LEFT].lErrorDown, ptd->aed[RIGHT].lErrorDown, lTmp);
                SWAP(ptd->aed[LEFT].cy,         ptd->aed[RIGHT].cy,         lTmp);
                SWAP(ptd->aed[LEFT].dptfx,      ptd->aed[RIGHT].dptfx,      lTmp);
                SWAP(ptd->aed[LEFT].pptfx,      ptd->aed[RIGHT].pptfx,      pptfxTmp);
            }
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].dx      = dxLeft;
        ptd->aed[LEFT].x       = xLeft;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].dx     = dxRight;
        ptd->aed[RIGHT].x      = xRight;
    }
}

/******************************Public*Routine******************************\
* VOID vIoPatternedTrapezoid
*
\**************************************************************************/

VOID vIoPatternedTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*   ppdev       = ptd->ppdev;
    BYTE*   pjIoBase    = ppdev->pjIoBase;
    LONG    lLeftError  = ptd->aed[LEFT].lError;
    LONG    dxLeft      = ptd->aed[LEFT].dx;
    LONG    xLeft       = ptd->aed[LEFT].x;
    LONG    lRightError = ptd->aed[RIGHT].lError;
    LONG    dxRight     = ptd->aed[RIGHT].dx;
    LONG    xRight      = ptd->aed[RIGHT].x;
    BYTE*   pjPattern;
    LONG    iPattern;
    LONG    xAlign;

    xAlign    = ptd->ptlBrush.x;
    iPattern  = 8 * (yTrapezoid - ptd->ptlBrush.y);
    pjPattern = (BYTE*) ptd->prb->aulPattern;

    while (TRUE)
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Run the DDAs

        lWidth = xRight - xLeft;
        if (lWidth > 0)
        {
            // Note that we're setting these buffered registers without
            // first checking for idle, or even buffer not busy.  But
            // this is safe because at initialization, we did a wait
            // for idle, and here we always loop after waiting for idle
            // to set the pattern registers.

            IO_BITMAP_WIDTH(ppdev, pjIoBase, lWidth);
            IO_DEST_XY(ppdev, pjIoBase, xLeft, yTrapezoid);
            IO_SRC_ALIGN(ppdev, pjIoBase, xLeft - xAlign);

            IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
            IO_PREG_PATTERN(ppdev, pjIoBase, pjPattern + (iPattern & 63));
            IO_BLT_CMD_0(ppdev, pjIoBase, START_BLT);

        ContinueAfterZero:

            iPattern += 8;
            yTrapezoid++;

            // Advance the right wall:

            xRight      += dxRight;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].lErrorDown;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += dxLeft;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].lErrorDown;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }
        else if (lWidth == 0)
        {
            goto ContinueAfterZero;
        }
        else
        {
            // We certainly don't want to optimize for this case because we
            // should rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves):

            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(xLeft,                     xRight,                     lTmp);
            SWAP(dxLeft,                    dxRight,                    lTmp);
            SWAP(lLeftError,                lRightError,                lTmp);
            SWAP(ptd->aed[LEFT].lErrorUp,   ptd->aed[RIGHT].lErrorUp,   lTmp);
            SWAP(ptd->aed[LEFT].lErrorDown, ptd->aed[RIGHT].lErrorDown, lTmp);
            SWAP(ptd->aed[LEFT].cy,         ptd->aed[RIGHT].cy,         lTmp);
            SWAP(ptd->aed[LEFT].dptfx,      ptd->aed[RIGHT].dptfx,      lTmp);
            SWAP(ptd->aed[LEFT].pptfx,      ptd->aed[RIGHT].pptfx,      pptfxTmp);
        }
    }

    ptd->aed[LEFT].lError  = lLeftError;
    ptd->aed[LEFT].dx      = dxLeft;
    ptd->aed[LEFT].x       = xLeft;
    ptd->aed[RIGHT].lError = lRightError;
    ptd->aed[RIGHT].dx     = dxRight;
    ptd->aed[RIGHT].x      = xRight;
}

/******************************Public*Routine******************************\
* VOID vIoTrapezoidSetup
*
* Initialize the hardware and some state for doing I/O trapezoids.
*
\**************************************************************************/

VOID vIoTrapezoidSetup(
PDEV*           ppdev,
ULONG           rop4,
ULONG           iSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd)
{
    BYTE*   pjIoBase;

    ptd->ppdev = ppdev;
    pjIoBase   = ppdev->pjIoBase;

    IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
    IO_BITMAP_HEIGHT(ppdev, pjIoBase, 1);
    IO_BLT_CMD_1(ppdev, pjIoBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);

    if (iSolidColor != -1)
    {
        ptd->pfnTrap = vIoSolidTrapezoid;

        /////////////////////////////////////////////////////////////////
        // Setup the hardware for solid colours

        IO_PREG_COLOR_8(ppdev, pjIoBase, iSolidColor);
        IO_CTRL_REG_1(ppdev, pjIoBase, PACKED_PIXEL_VIEW |
                                       BITS_PER_PIX_8    |
                                       ENAB_TRITON_MODE);
        if (rop4 == 0xf0f0)
        {
            IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS    |
                                              PIXELMASK_ONLY       |
                                              PLANARMASK_NONE_0XFF |
                                              SRC_IS_PATTERN_REGS);
        }
        else
        {
            IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_ALL        |
                                              PIXELMASK_ONLY       |
                                              PLANARMASK_NONE_0XFF |
                                              SRC_IS_PATTERN_REGS);
            IO_ROP_A(ppdev, pjIoBase, rop4 >> 2);
        }
    }
    else
    {
        ptd->prb      = prb;
        ptd->ptlBrush = *pptlBrush;

        if (!(prb->fl & RBRUSH_2COLOR))
        {
            ptd->pfnTrap = vIoPatternedTrapezoid;

            /////////////////////////////////////////////////////////////////
            // Setup for coloured patterns

            IO_CTRL_REG_1(ppdev, pjIoBase, PACKED_PIXEL_VIEW |
                                           BITS_PER_PIX_8    |
                                           ENAB_TRITON_MODE);
            if (rop4 == 0xf0f0)
            {
                IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS    |
                                                  PIXELMASK_ONLY       |
                                                  PLANARMASK_NONE_0XFF |
                                                  SRC_IS_PATTERN_REGS);
            }
            else
            {
                IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_ALL        |
                                                  PIXELMASK_ONLY       |
                                                  PLANARMASK_NONE_0XFF |
                                                  SRC_IS_PATTERN_REGS);
                IO_ROP_A(ppdev, pjIoBase, rop4 >> 2);
            }
        }
        else
        {
            ptd->pfnTrap = vIo2ColorTrapezoid;

            /////////////////////////////////////////////////////////////////
            // Setup for 2-colour patterns

            IO_FG_COLOR(ppdev, pjIoBase, prb->ulForeColor);
            IO_BG_COLOR(ppdev, pjIoBase, prb->ulBackColor);
            IO_PREG_PATTERN(ppdev, pjIoBase, prb->aulPattern);

            IO_CTRL_REG_1(ppdev, pjIoBase, EXPAND_TO_FG      |
                                           BITS_PER_PIX_8    |
                                           ENAB_TRITON_MODE);
            if (rop4 == 0xf0f0)
            {
                IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS    |
                                                  PIXELMASK_ONLY       |
                                                  PLANARMASK_NONE_0XFF |
                                                  SRC_IS_PATTERN_REGS);
            }
            else if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
            {
                IO_ROP_A(ppdev, pjIoBase, rop4 >> 2);
                IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_ALL        |
                                                  PIXELMASK_ONLY       |
                                                  PLANARMASK_NONE_0XFF |
                                                  SRC_IS_PATTERN_REGS);
            }
            else if ((rop4 & 0xff) == 0xcc)
            {
                IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS      |
                                                  PIXELMASK_AND_SRC_DATA |
                                                  PLANARMASK_NONE_0XFF   |
                                                  SRC_IS_PATTERN_REGS);
            }
            else
            {
                IO_ROP_A(ppdev, pjIoBase, rop4 >> 2);
                IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_ALL          |
                                                  PIXELMASK_AND_SRC_DATA |
                                                  PLANARMASK_NONE_0XFF   |
                                                  SRC_IS_PATTERN_REGS);
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vMmSolidTrapezoid
*
\**************************************************************************/

VOID vMmSolidTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV* ppdev    = ptd->ppdev;
    BYTE* pjMmBase = ppdev->pjMmBase;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 1))
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

    ContinueVertical:

        lWidth = ptd->aed[RIGHT].x - ptd->aed[LEFT].x;
        if (lWidth > 0)
        {
            MM_WAIT_BUFFER_NOT_BUSY(ppdev, pjMmBase);
            MM_BITMAP_WIDTH(ppdev, pjMmBase, lWidth);
            MM_BITMAP_HEIGHT(ppdev, pjMmBase, cyTrapezoid);
            MM_DEST_XY(ppdev, pjMmBase, ptd->aed[LEFT].x, yTrapezoid);
            MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

            MM_WAIT_BUFFER_NOT_BUSY(ppdev, pjMmBase);
            MM_BITMAP_HEIGHT(ppdev, pjMmBase, 1);
        }
        else if (lWidth < 0)
        {
            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(ptd->aed[LEFT].x,     ptd->aed[RIGHT].x,     lTmp);
            SWAP(ptd->aed[LEFT].cy,    ptd->aed[RIGHT].cy,    lTmp);
            SWAP(ptd->aed[LEFT].dptfx, ptd->aed[RIGHT].dptfx, lTmp);
            SWAP(ptd->aed[LEFT].pptfx, ptd->aed[RIGHT].pptfx, pptfxTmp);
            goto ContinueVertical;
        }
    }
    else
    {
        LONG lLeftError  = ptd->aed[LEFT].lError;
        LONG dxLeft      = ptd->aed[LEFT].dx;
        LONG xLeft       = ptd->aed[LEFT].x;
        LONG lRightError = ptd->aed[RIGHT].lError;
        LONG dxRight     = ptd->aed[RIGHT].dx;
        LONG xRight      = ptd->aed[RIGHT].x;

        while (TRUE)
        {
            LONG lWidth;

            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            lWidth = xRight - xLeft;
            if (lWidth > 0)
            {
                MM_WAIT_BUFFER_NOT_BUSY(ppdev, pjMmBase);
                MM_BITMAP_WIDTH(ppdev, pjMmBase, lWidth);
                MM_DEST_XY(ppdev, pjMmBase, xLeft, yTrapezoid);
                MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

            ContinueAfterZero:

                yTrapezoid++;

                // Advance the right wall:

                xRight      += dxRight;
                lRightError += ptd->aed[RIGHT].lErrorUp;

                if (lRightError >= 0)
                {
                    lRightError -= ptd->aed[RIGHT].lErrorDown;
                    xRight++;
                }

                // Advance the left wall:

                xLeft      += dxLeft;
                lLeftError += ptd->aed[LEFT].lErrorUp;

                if (lLeftError >= 0)
                {
                    lLeftError -= ptd->aed[LEFT].lErrorDown;
                    xLeft++;
                }

                cyTrapezoid--;
                if (cyTrapezoid == 0)
                    break;
            }
            else if (lWidth == 0)
            {
                goto ContinueAfterZero;
            }
            else
            {
                // We certainly don't want to optimize for this case because we
                // should rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves):

                LONG      lTmp;
                POINTFIX* pptfxTmp;

                SWAP(xLeft,                     xRight,                     lTmp);
                SWAP(dxLeft,                    dxRight,                    lTmp);
                SWAP(lLeftError,                lRightError,                lTmp);
                SWAP(ptd->aed[LEFT].lErrorUp,   ptd->aed[RIGHT].lErrorUp,   lTmp);
                SWAP(ptd->aed[LEFT].lErrorDown, ptd->aed[RIGHT].lErrorDown, lTmp);
                SWAP(ptd->aed[LEFT].cy,         ptd->aed[RIGHT].cy,         lTmp);
                SWAP(ptd->aed[LEFT].dptfx,      ptd->aed[RIGHT].dptfx,      lTmp);
                SWAP(ptd->aed[LEFT].pptfx,      ptd->aed[RIGHT].pptfx,      pptfxTmp);
            }
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].dx      = dxLeft;
        ptd->aed[LEFT].x       = xLeft;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].dx     = dxRight;
        ptd->aed[RIGHT].x      = xRight;
    }
}

/******************************Public*Routine******************************\
* VOID vMm2ColorTrapezoid
*
\**************************************************************************/

VOID vMm2ColorTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*   ppdev    = ptd->ppdev;
    BYTE*   pjMmBase = ppdev->pjMmBase;
    LONG    xAlign;
    LONG    yAlign;

    xAlign = ptd->ptlBrush.x;
    yAlign = ptd->ptlBrush.y;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((ptd->aed[LEFT].lErrorUp | ptd->aed[RIGHT].lErrorUp) == 0) &&
        ((ptd->aed[LEFT].dx       | ptd->aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 1))
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Vertical-edge special case

    ContinueVertical:

        lWidth = ptd->aed[RIGHT].x - ptd->aed[LEFT].x;
        if (lWidth > 0)
        {
            MM_WAIT_BUFFER_NOT_BUSY(ppdev, pjMmBase);
            MM_BITMAP_WIDTH(ppdev, pjMmBase, lWidth);
            MM_BITMAP_HEIGHT(ppdev, pjMmBase, cyTrapezoid);
            MM_DEST_XY(ppdev, pjMmBase, ptd->aed[LEFT].x, yTrapezoid);
            MM_SRC_ALIGN(ppdev, pjMmBase, ((ptd->aed[LEFT].x - xAlign) & 7) |
                                          ((yTrapezoid  - yAlign) << 3));
            MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

            MM_WAIT_BUFFER_NOT_BUSY(ppdev, pjMmBase);
            MM_BITMAP_HEIGHT(ppdev, pjMmBase, 1);
        }
        else if (lWidth < 0)
        {
            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(ptd->aed[LEFT].x,     ptd->aed[RIGHT].x,     lTmp);
            SWAP(ptd->aed[LEFT].cy,    ptd->aed[RIGHT].cy,    lTmp);
            SWAP(ptd->aed[LEFT].dptfx, ptd->aed[RIGHT].dptfx, lTmp);
            SWAP(ptd->aed[LEFT].pptfx, ptd->aed[RIGHT].pptfx, pptfxTmp);
            goto ContinueVertical;
        }
    }
    else
    {
        LONG lLeftError  = ptd->aed[LEFT].lError;
        LONG dxLeft      = ptd->aed[LEFT].dx;
        LONG xLeft       = ptd->aed[LEFT].x;
        LONG lRightError = ptd->aed[RIGHT].lError;
        LONG dxRight     = ptd->aed[RIGHT].dx;
        LONG xRight      = ptd->aed[RIGHT].x;
        LONG yScaledAlign;

        // Scale y alignment up by 8 so that it's easier to compute
        // the QVision's alignment on each scan:

        yScaledAlign = (yTrapezoid - yAlign) << 3;

        while (TRUE)
        {
            LONG lWidth;

            /////////////////////////////////////////////////////////////////
            // Run the DDAs

            lWidth = xRight - xLeft;
            if (lWidth > 0)
            {
                MM_WAIT_BUFFER_NOT_BUSY(ppdev, pjMmBase);
                MM_BITMAP_WIDTH(ppdev, pjMmBase, lWidth);
                MM_DEST_XY(ppdev, pjMmBase, xLeft, yTrapezoid);
                MM_SRC_ALIGN(ppdev, pjMmBase, (((xLeft - xAlign) & 7)
                                              | yScaledAlign));
                MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

            ContinueAfterZero:

                yScaledAlign += 8;
                yTrapezoid++;

                // Advance the right wall:

                xRight      += dxRight;
                lRightError += ptd->aed[RIGHT].lErrorUp;

                if (lRightError >= 0)
                {
                    lRightError -= ptd->aed[RIGHT].lErrorDown;
                    xRight++;
                }

                // Advance the left wall:

                xLeft      += dxLeft;
                lLeftError += ptd->aed[LEFT].lErrorUp;

                if (lLeftError >= 0)
                {
                    lLeftError -= ptd->aed[LEFT].lErrorDown;
                    xLeft++;
                }

                cyTrapezoid--;
                if (cyTrapezoid == 0)
                    break;
            }
            else if (lWidth == 0)
            {
                goto ContinueAfterZero;
            }
            else
            {
                // We certainly don't want to optimize for this case because we
                // should rarely get self-intersecting polygons (if we're slow,
                // the app gets what it deserves):

                LONG      lTmp;
                POINTFIX* pptfxTmp;

                SWAP(xLeft,                     xRight,                     lTmp);
                SWAP(dxLeft,                    dxRight,                    lTmp);
                SWAP(lLeftError,                lRightError,                lTmp);
                SWAP(ptd->aed[LEFT].lErrorUp,   ptd->aed[RIGHT].lErrorUp,   lTmp);
                SWAP(ptd->aed[LEFT].lErrorDown, ptd->aed[RIGHT].lErrorDown, lTmp);
                SWAP(ptd->aed[LEFT].cy,         ptd->aed[RIGHT].cy,         lTmp);
                SWAP(ptd->aed[LEFT].dptfx,      ptd->aed[RIGHT].dptfx,      lTmp);
                SWAP(ptd->aed[LEFT].pptfx,      ptd->aed[RIGHT].pptfx,      pptfxTmp);
            }
        }

        ptd->aed[LEFT].lError  = lLeftError;
        ptd->aed[LEFT].dx      = dxLeft;
        ptd->aed[LEFT].x       = xLeft;
        ptd->aed[RIGHT].lError = lRightError;
        ptd->aed[RIGHT].dx     = dxRight;
        ptd->aed[RIGHT].x      = xRight;
    }
}

/******************************Public*Routine******************************\
* VOID vMmPatternedTrapezoid
*
\**************************************************************************/

VOID vMmPatternedTrapezoid(
TRAPEZOIDDATA*  ptd,
LONG            yTrapezoid,
LONG            cyTrapezoid)
{
    PDEV*   ppdev       = ptd->ppdev;
    BYTE*   pjMmBase    = ppdev->pjMmBase;
    LONG    lLeftError  = ptd->aed[LEFT].lError;
    LONG    dxLeft      = ptd->aed[LEFT].dx;
    LONG    xLeft       = ptd->aed[LEFT].x;
    LONG    lRightError = ptd->aed[RIGHT].lError;
    LONG    dxRight     = ptd->aed[RIGHT].dx;
    LONG    xRight      = ptd->aed[RIGHT].x;
    BYTE*   pjPattern;
    LONG    iPattern;
    LONG    xAlign;

    xAlign    = ptd->ptlBrush.x;
    iPattern  = 8 * (yTrapezoid - ptd->ptlBrush.y);
    pjPattern = (BYTE*) ptd->prb->aulPattern;

    while (TRUE)
    {
        LONG lWidth;

        /////////////////////////////////////////////////////////////////
        // Run the DDAs

        lWidth = xRight - xLeft;
        if (lWidth > 0)
        {
            // Note that we're setting these buffered registers without
            // first checking for idle, or even buffer not busy.  But
            // this is safe because at initialization, we did a wait
            // for idle, and here we always loop after waiting for idle
            // to set the pattern registers.

            MM_BITMAP_WIDTH(ppdev, pjMmBase, lWidth);
            MM_DEST_XY(ppdev, pjMmBase, xLeft, yTrapezoid);
            MM_SRC_ALIGN(ppdev, pjMmBase, xLeft - xAlign);

            MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
            MM_PREG_PATTERN(ppdev, pjMmBase, pjPattern + (iPattern & 63));
            MM_BLT_CMD_0(ppdev, pjMmBase, START_BLT);

        ContinueAfterZero:

            iPattern += 8;
            yTrapezoid++;

            // Advance the right wall:

            xRight      += dxRight;
            lRightError += ptd->aed[RIGHT].lErrorUp;

            if (lRightError >= 0)
            {
                lRightError -= ptd->aed[RIGHT].lErrorDown;
                xRight++;
            }

            // Advance the left wall:

            xLeft      += dxLeft;
            lLeftError += ptd->aed[LEFT].lErrorUp;

            if (lLeftError >= 0)
            {
                lLeftError -= ptd->aed[LEFT].lErrorDown;
                xLeft++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                break;
        }
        else if (lWidth == 0)
        {
            goto ContinueAfterZero;
        }
        else
        {
            // We certainly don't want to optimize for this case because we
            // should rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves):

            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(xLeft,                     xRight,                     lTmp);
            SWAP(dxLeft,                    dxRight,                    lTmp);
            SWAP(lLeftError,                lRightError,                lTmp);
            SWAP(ptd->aed[LEFT].lErrorUp,   ptd->aed[RIGHT].lErrorUp,   lTmp);
            SWAP(ptd->aed[LEFT].lErrorDown, ptd->aed[RIGHT].lErrorDown, lTmp);
            SWAP(ptd->aed[LEFT].cy,         ptd->aed[RIGHT].cy,         lTmp);
            SWAP(ptd->aed[LEFT].dptfx,      ptd->aed[RIGHT].dptfx,      lTmp);
            SWAP(ptd->aed[LEFT].pptfx,      ptd->aed[RIGHT].pptfx,      pptfxTmp);
        }
    }

    ptd->aed[LEFT].lError  = lLeftError;
    ptd->aed[LEFT].dx      = dxLeft;
    ptd->aed[LEFT].x       = xLeft;
    ptd->aed[RIGHT].lError = lRightError;
    ptd->aed[RIGHT].dx     = dxRight;
    ptd->aed[RIGHT].x      = xRight;
}

/******************************Public*Routine******************************\
* VOID vMmTrapezoidSetup
*
* Initialize the hardware and some state for doing memory-mapped I/O
* trapezoids.
*
\**************************************************************************/

VOID vMmTrapezoidSetup(
PDEV*           ppdev,
ULONG           rop4,
ULONG           iSolidColor,
RBRUSH*         prb,
POINTL*         pptlBrush,
TRAPEZOIDDATA*  ptd)
{
    BYTE*   pjMmBase;

    ptd->ppdev = ppdev;
    pjMmBase   = ppdev->pjMmBase;

    MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
    MM_BITMAP_HEIGHT(ppdev, pjMmBase, 1);
    MM_BLT_CMD_1(ppdev, pjMmBase, XY_SRC_ADDR |
                                  XY_DEST_ADDR);

    if (iSolidColor != -1)
    {
        ptd->pfnTrap = vMmSolidTrapezoid;

        /////////////////////////////////////////////////////////////////
        // Setup the hardware for solid colours

        MM_PREG_COLOR_8(ppdev, pjMmBase, iSolidColor);
        if (rop4 == 0xf0f0)
        {
            // Note block write:

            MM_CTRL_REG_1(ppdev, pjMmBase, PACKED_PIXEL_VIEW |
                                           BLOCK_WRITE       |
                                           BITS_PER_PIX_8    |
                                           ENAB_TRITON_MODE);
            MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS    |
                                              PIXELMASK_ONLY       |
                                              PLANARMASK_NONE_0XFF |
                                              SRC_IS_PATTERN_REGS);
        }
        else
        {
            MM_CTRL_REG_1(ppdev, pjMmBase, PACKED_PIXEL_VIEW |
                                           BITS_PER_PIX_8    |
                                           ENAB_TRITON_MODE);
            MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_ALL        |
                                              PIXELMASK_ONLY       |
                                              PLANARMASK_NONE_0XFF |
                                              SRC_IS_PATTERN_REGS);
            MM_ROP_A(ppdev, pjMmBase, rop4 >> 2);
        }
    }
    else
    {
        ptd->prb      = prb;
        ptd->ptlBrush = *pptlBrush;

        if (!(prb->fl & RBRUSH_2COLOR))
        {
            ptd->pfnTrap = vMmPatternedTrapezoid;

            /////////////////////////////////////////////////////////////////
            // Setup for coloured patterns

            MM_CTRL_REG_1(ppdev, pjMmBase, PACKED_PIXEL_VIEW |
                                           BITS_PER_PIX_8    |
                                           ENAB_TRITON_MODE);
            if (rop4 == 0xf0f0)
            {
                MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS    |
                                                  PIXELMASK_ONLY       |
                                                  PLANARMASK_NONE_0XFF |
                                                  SRC_IS_PATTERN_REGS);
            }
            else
            {
                MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_ALL        |
                                                  PIXELMASK_ONLY       |
                                                  PLANARMASK_NONE_0XFF |
                                                  SRC_IS_PATTERN_REGS);
                MM_ROP_A(ppdev, pjMmBase, rop4 >> 2);
            }
        }
        else
        {
            ptd->pfnTrap = vMm2ColorTrapezoid;

            /////////////////////////////////////////////////////////////////
            // Setup for 2-colour patterns

            MM_FG_COLOR(ppdev, pjMmBase, prb->ulForeColor);
            MM_BG_COLOR(ppdev, pjMmBase, prb->ulBackColor);
            MM_PREG_PATTERN(ppdev, pjMmBase, prb->aulPattern);

            MM_CTRL_REG_1(ppdev, pjMmBase, EXPAND_TO_FG      |
                                           BITS_PER_PIX_8    |
                                           ENAB_TRITON_MODE);
            if (rop4 == 0xf0f0)
            {
                MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS    |
                                                  PIXELMASK_ONLY       |
                                                  PLANARMASK_NONE_0XFF |
                                                  SRC_IS_PATTERN_REGS);
            }
            else if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
            {
                MM_ROP_A(ppdev, pjMmBase, rop4 >> 2);
                MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_ALL        |
                                                  PIXELMASK_ONLY       |
                                                  PLANARMASK_NONE_0XFF |
                                                  SRC_IS_PATTERN_REGS);
            }
            else if ((rop4 & 0xff) == 0xcc)
            {
                MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS      |
                                                  PIXELMASK_AND_SRC_DATA |
                                                  PLANARMASK_NONE_0XFF   |
                                                  SRC_IS_PATTERN_REGS);
            }
            else
            {
                MM_ROP_A(ppdev, pjMmBase, rop4 >> 2);
                MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_ALL          |
                                                  PIXELMASK_AND_SRC_DATA |
                                                  PLANARMASK_NONE_0XFF   |
                                                  SRC_IS_PATTERN_REGS);
            }
        }
    }
}

/******************************Public*Routine******************************\
* BOOL bFastFill
*
* Draws a non-complex, unclipped polygon.  'Non-complex' is defined as
* having only two edges that are monotonic increasing in 'y'.  That is,
* the polygon cannot have more than one disconnected segment on any given
* scan.  Note that the edges of the polygon can self-intersect, so hourglass
* shapes are permissible.  This restriction permits this routine to run two
* simultaneous DDAs, and no sorting of the edges is required.
*
* Note that NT's fill convention is different from that of Win 3.1 or 4.0.
* With the additional complication of fractional end-points, our convention
* is the same as in 'X-Windows'.  But a DDA is a DDA is a DDA, so once you
* figure out how we compute the DDA terms for NT, you're golden.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bFastFill(
PDEV*       ppdev,
LONG        cEdges,         // Includes close figure edge
POINTFIX*   pptfxFirst,
ULONG       rop4,
ULONG       iSolidColor,
RBRUSH*     prb,
POINTL*     pptlBrush)
{
    LONG      yTrapezoid;   // Top scan for next trapezoid
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;

    TRAPEZOIDDATA   td;     // Edge data and stuff
    EDGEDATA*       ped;    // Points to current edge being processed

    /////////////////////////////////////////////////////////////////
    // See if the polygon is 'non-complex'

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        return(FALSE);
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        return(FALSE);
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    /////////////////////////////////////////////////////////////////
    // Some Initialization

    yTrapezoid = (pptfxTop->y + 15) >> 4;

    // Make sure we initialize the DDAs appropriately:

    td.aed[LEFT].cy  = 0;
    td.aed[RIGHT].cy = 0;

    // For now, guess as to which is the left and which is the right edge:

    td.aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
    td.aed[RIGHT].dptfx = sizeof(POINTFIX);
    td.aed[LEFT].pptfx  = pptfxTop;
    td.aed[RIGHT].pptfx = pptfxTop;

    // Do the hardware setup.  These are not in-line only because it
    // takes too much space to ahve both I/O and memory-mapped I/O
    // versions:

    if (ppdev->pjMmBase != NULL)
        vMmTrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td);
    else
        vIoTrapezoidSetup(ppdev, rop4, iSolidColor, prb, pptlBrush, &td);

NewTrapezoid:

    /////////////////////////////////////////////////////////////////
    // DDA initialization

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped = &td.aed[iEdge];
        if (ped->cy == 0)
        {
            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                    return(TRUE);

                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yTrapezoid:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yTrapezoid'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTDD(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->lErrorDown = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i != 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->lErrorDown;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(td.aed[LEFT].cy, td.aed[RIGHT].cy); // # of scans in this trap
    td.aed[LEFT].cy  -= cyTrapezoid;
    td.aed[RIGHT].cy -= cyTrapezoid;

    td.pfnTrap(&td, yTrapezoid, cyTrapezoid);

    yTrapezoid += cyTrapezoid;

    goto NewTrapezoid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\paint.c ===
/******************************Module*Header*******************************\
* Module Name: paint.c
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE        - Allow rop = gaMix[mix & 0xFF]
};

/******************************Public*Routine******************************\
* BOOL DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    ROP4 rop4;

    rop4 = ((MIX) gaMix[mix >> 8] << 8) | gaMix[mix & 0xf];

    // Since our DrvFillPath routine handles almost all fills, DrvPaint
    // won't get called all that much (mainly via PaintRgn, FillRgn, or
    // complex clipped polygons).  As such, we save some code and simply
    // punt to DrvBitBlt:

    return(DrvBitBlt(pso, NULL, NULL, pco, NULL, &pco->rclBounds, NULL,
                     NULL, pbo, pptlBrush, rop4));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiDefault = {
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh
    0,                       // ulBltAlignment
    0,                       // ulPanningHorzRes
    0,                       // ulPanningVertRes
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {
    (GCAPS_OPAQUERECT       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_PALMANAGED       |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
     GCAPS_MONO_DITHER      |
     GCAPS_COLOR_DITHER),
                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
* Why haven't we implemented DrvSaveScreenBits?  To save code.
*
* When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
* the-fly by creating a temporary device-format-bitmap, and explicitly
* calling DrvCopyBits to save/restore the bits.  Since we already hook
* DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
* the bits anyway (which would have been the main reason for implementing
* DrvSaveScreenBits).  So we may as well save some working set.
\**************************************************************************/

#if MULTI_BOARDS

// Multi-board support has its own thunks...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) MulEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) MulCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) MulDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) MulEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) MulDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) MulAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) MulMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) MulSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) MulDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) MulSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) MulCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) MulBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) MulTextOut            },
    {   INDEX_DrvGetModes,              (PFN) MulGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) MulStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) MulFillPath           },
    {   INDEX_DrvPaint,                 (PFN) MulPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) MulRealizeBrush       },
    {   INDEX_DrvDestroyFont,           (PFN) MulDestroyFont        },
    // Note that DrvCreateDeviceBitmap is not supported for multi-boards
    // Note that DrvDeleteDeviceBitmap is not supported for multi-boards
    // Note that DrvStretchBlt is not supported for multi-boards
    // Note that DrvEscape is not supported for multi-boards
};

#elif DBG || !SYNCHRONIZEACCESS_WORKS

// On Checked builds, or when we have to synchronize access, thunk
// everything through Dbg calls...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DbgEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DbgCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DbgDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DbgEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DbgDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DbgAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DbgMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DbgSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DbgDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DbgSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DbgCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DbgBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DbgTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DbgGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DbgStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) DbgFillPath           },
    {   INDEX_DrvPaint,                 (PFN) DbgPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DbgRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DbgCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DbgDeleteDeviceBitmap },
    {   INDEX_DrvStretchBlt,            (PFN) DbgStretchBlt         },
    {   INDEX_DrvEscape,                (PFN) DbgEscape             },
    {   INDEX_DrvDestroyFont,           (PFN) DbgDestroyFont        },
};

#else

// On Free builds, directly call the appropriate functions...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
    {   INDEX_DrvEscape,                (PFN) DrvEscape             },
    {   INDEX_DrvDestroyFont,           (PFN) DrvDestroyFont        },
};

#endif

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Initialize hardware pointer.

    if (!bInitializePointer(ppdev))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePointer"));
        goto ReturnFailure1;
    }

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    vUninitializePointer(ppdev);
    EngFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}


/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;
    SIZEL   sizl;
    DSURF*  pdsurf;
    VOID*   pvTmpBuffer;

    ppdev = (PDEV*) dhpdev;

    /////////////////////////////////////////////////////////////////////
    // First enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnableBanking(ppdev))
        goto ReturnFailure;

    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

    if (!bEnableText(ppdev))
        goto ReturnFailure;

    if (!bEnableBrushCache(ppdev))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    if (!bEnableRx(ppdev))
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // Now create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.

    pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
    if (pdsurf == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed pdsurf EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pdsurfScreen = pdsurf;           // Remember it for clean-up
    pdsurf->poh     = ppdev->pohFrontBuffer;// The screen is a surface, too
    pdsurf->dt      = DT_SCREEN;            // Not to be confused with a DIB
    pdsurf->sizl.cx = ppdev->cxScreen;
    pdsurf->sizl.cy = ppdev->cyScreen;
    pdsurf->ppdev   = ppdev;

    /////////////////////////////////////////////////////////////////////
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.
    //
    // If we could map the entire framebuffer linearly into main memory
    // (i.e., we didn't have to go through a 64k aperture), it would be
    // beneficial to create the surface via EngCreateBitmap, giving GDI a
    // pointer to the framebuffer bits.  When we pass a call on to GDI
    // where it can't directly read/write to the surface bits because the
    // surface is device managed, it has to create a temporary bitmap and
    // call our DrvCopyBits routine to get/set a copy of the affected bits.
    // Fer example, the OpenGL component prefers to be able to write on the
    // framebuffer bits directly.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    hsurf = EngCreateDeviceSurface((DHSURF) pdsurf, sizl, ppdev->iBitmapFormat);
    if (hsurf == 0)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngCreateDeviceSurface"));
        goto ReturnFailure;
    }

    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    /////////////////////////////////////////////////////////////////////
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks))
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface"));
        goto ReturnFailure;
    }

    // Create our generic temporary buffer, which may be used by any
    // component.

    pvTmpBuffer = EngAllocMem(0, TMP_BUFFER_SIZE, ALLOC_TAG);
    if (pvTmpBuffer == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;

    DISPDBG((5, "Passed DrvEnableSurface"));

    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note that this function will be called when previewing modes in the
* Display Applet, but not at system shutdown.  If you need to reset the
* hardware at shutdown, you can do it in the miniport by providing a
* 'HwResetHw' entry point in the VIDEO_HW_INITIALIZATION_DATA structure.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    vDisableRx(ppdev);
    vDisablePalette(ppdev);
    vDisableBrushCache(ppdev);
    vDisableText(ppdev);
    vDisablePointer(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableBanking(ppdev);
    vDisableHardware(ppdev);

    EngFreeMem(ppdev->pvTmpBuffer);
    EngDeleteSurface(ppdev->hsurfScreen);
    EngFreeMem(ppdev->pdsurfScreen);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

        vAssertModeRx(ppdev, FALSE);

        vAssertModePalette(ppdev, FALSE);

        vAssertModeBrushCache(ppdev, FALSE);

        vAssertModeText(ppdev, FALSE);

        vAssertModePointer(ppdev, FALSE);

        if (bAssertModeOffscreenHeap(ppdev, FALSE))
        {
            vAssertModeBanking(ppdev, FALSE);

            if (bAssertModeHardware(ppdev, FALSE))
            {
                ppdev->bEnabled = FALSE;

                return(TRUE);
            }

            //////////////////////////////////////////////////////////
            // We failed to switch to full-screen.  So undo everything:

            vAssertModeBanking(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
        }                                           //   return code with TRUE

        vAssertModePointer(ppdev, TRUE);

        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);

        vAssertModePalette(ppdev, TRUE);

        vAssertModeRx(ppdev, TRUE);
    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        if (bAssertModeHardware(ppdev, TRUE))
        {
            vAssertModeBanking(ppdev, TRUE);

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
                                                    //   return code with TRUE
            vAssertModePointer(ppdev, TRUE);

            vAssertModeText(ppdev, TRUE);

            vAssertModeBrushCache(ppdev, TRUE);

            vAssertModePalette(ppdev, TRUE);

            vAssertModeRx(ppdev, TRUE);

            ppdev->bEnabled = TRUE;

            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW)
                                                     + DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD ReturnedDataLength;

    if (bEnable)
    {
        // Call the miniport via an IOCTL to set the graphics mode.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_CURRENT_MODE,
                             &ppdev->ulMode,  // input buffer
                             sizeof(DWORD),
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
            return(FALSE);
        }

    }
    else
    {
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
            return(FALSE);
        }
        else
        {
            return(TRUE);
        }
    }

    DISPDBG((5, "Passed bAssertModeHardware"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware in the requested mode and initializes it.
*
* Note: Should be called before any access is done to the hardware from
*       the display driver.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange[1];
    DWORD                       ReturnedDataLength;
    VIDEO_MEMORY                VideoMemory;
    VIDEO_MEMORY_INFORMATION    VideoMemoryInfo;
    VIDEO_MODE_INFORMATION      VideoModeInfo;

    ppdev->pjMmBase = NULL;
    ppdev->pjIoBase = NULL;

    // Map io ports into virtual memory:

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         NULL,                      // input buffer
                         0,
                         &VideoAccessRange[0],      // output buffer
                         sizeof(VideoAccessRange),
                         &ReturnedDataLength))
    {
        RIP("bEnableHardware - Initialization error mapping IO port base");
        goto ReturnFalse;
    }

    #if defined(i386)
    {
        ppdev->pjMmBase = (BYTE*) VideoAccessRange[0].VirtualAddress;
    }
    #else
    {
        ppdev->pjIoBase = VideoAccessRange[0].VirtualAddress;
    }
    #endif

    // Now we can set the mode.

    if (!bAssertModeHardware(ppdev, TRUE))
        goto ReturnFalse;

    //
    // Now map the memory for the mode.
    //

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                         &VideoMemory,      // input buffer
                         sizeof(VIDEO_MEMORY),
                         &VideoMemoryInfo,  // output buffer
                         sizeof(VideoMemoryInfo),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Error mapping buffer address"));
        goto ReturnFalse;
    }

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_CURRENT_MODE,
                         NULL,
                         0,
                         &VideoModeInfo,
                         sizeof(VideoModeInfo),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bAssertModeHardware - failed VIDEO_QUERY_CURRENT_MODE"));
        goto ReturnFalse;
    }

    #if DEBUG_HEAP
        VideoModeInfo.VideoMemoryBitmapWidth  = VideoModeInfo.VisScreenWidth;
        VideoModeInfo.VideoMemoryBitmapHeight = VideoModeInfo.VisScreenHeight;
    #endif

    // The following variables are determined only after the initial
    // modeset:

    ppdev->lDelta       = VideoModeInfo.ScreenStride;
    ppdev->flCaps       = VideoModeInfo.AttributeFlags;
    ppdev->cxMemory     = ppdev->lDelta / ppdev->cjPel;
    ppdev->pjScreen     = (BYTE*) VideoMemoryInfo.FrameBufferBase;
    ppdev->cyMemory     = VideoMemoryInfo.VideoRamLength / ppdev->lDelta;

    // If we're using the original QVision-compatible I/O routines,
    // we're constrained to the original QVision's coordinate limit:

    if (ppdev->pjMmBase == NULL)
        ppdev->cyMemory = min(ppdev->cyMemory, 1024);

    #if defined(i386)
        ppdev->cjBank   = 0x10000;  // Hardcoded 64k for x86
    #else
        ppdev->cjBank   = 0x100000; // Hardcoded 1 MB for Alpha
    #endif

    // Do some paramater checking on the values that the miniport
    // returned to us:

    ASSERTDD(ppdev->cxMemory >= ppdev->cxScreen, "Invalid cxMemory");
    ASSERTDD(ppdev->cyMemory >= ppdev->cyScreen, "Invalid cyMemory");

    //
    // Set the function pointers.
    //

    if (ppdev->pjMmBase == NULL)
    {
        // Have to do IN/OUTs:

        ppdev->pfnFillSolid = vIoFillSolid;
        ppdev->pfnFillPat   = vIoFillPat;
        ppdev->pfnXfer1bpp  = vIoXfer1bpp;
        ppdev->pfnCopyBlt   = vIoCopyBlt;
        ppdev->pfnTextOut   = vIoTextOut;
    }
    else
    {
        ppdev->pfnFillSolid = vMmFillSolid;
        ppdev->pfnFillPat   = vMmFillPat;
        ppdev->pfnXfer1bpp  = vMmXfer1bpp;
        ppdev->pfnCopyBlt   = vMmCopyBlt;
        ppdev->pfnTextOut   = vMmTextOut;
    }

    DISPDBG((0, "%lix%li / %lix%li @ 0x%lxx%li cjBank: 0x%lx flCaps: 0x%lx",
                ppdev->cxScreen, ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory,
                ppdev->pjScreen, ppdev->lDelta, ppdev->cjBank, ppdev->flCaps));

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory[1];

    VideoMemory[0].RequestedVirtualAddress = ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                         VideoMemory,
                         sizeof(VIDEO_MEMORY),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
    }

    #if defined(i386)
        VideoMemory[0].RequestedVirtualAddress = ppdev->pjMmBase;
    #else
        VideoMemory[0].RequestedVirtualAddress = ppdev->pjIoBase;
    #endif

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                         VideoMemory,
                         sizeof(VideoMemory),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
    }
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((8, "   Checking against miniport mode:"));
            DISPDBG((8, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((8, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((8, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((8, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    #if DEBUG_HEAP
        VideoModeInformation.VisScreenWidth  = 640;
        VideoModeInformation.VisScreenHeight = 480;
    #endif

    // Set up screen information from the mini-port:

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;

    DISPDBG((1, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

    ppdev->flHooks          = (HOOK_BITBLT     |
                               HOOK_TEXTOUT    |
                               HOOK_COPYBITS   |
                               HOOK_STROKEPATH |
                               HOOK_PAINT      |
                               HOOK_FILLPATH);
// !!!                               HOOK_STRETCHBLT);

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    if (ppdev->PointerCapabilities.Flags & VIDEO_MODE_ASYNC_POINTER)
        pdi->flGraphicsCaps |= GCAPS_ASYNCMOVE;

    if (VideoModeInformation.BitsPerPlane == 8)
    {
        ppdev->cPelSize        = 0;
        ppdev->cjPel           = 1;
        ppdev->iBitmapFormat   = BMF_8BPP;
        ppdev->ulWhite         = 0xff;

        // Assuming palette is orthogonal - all colors are same size.

        ppdev->cPaletteShift   = 8 - pgdi->ulDACRed;
        DISPDBG((3, "palette shift = %d\n", ppdev->cPaletteShift));
    }
    else if ((VideoModeInformation.BitsPerPlane == 16) ||
             (VideoModeInformation.BitsPerPlane == 15))
    {
        ppdev->cPelSize        = 1;
        ppdev->cjPel           = 2;
        ppdev->iBitmapFormat   = BMF_16BPP;
        ppdev->ulWhite         = 0xffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_16BPP;

        pdi->iDitherFormat     = BMF_16BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }
    else
    {
        ASSERTDD(VideoModeInformation.BitsPerPlane == 32,
                 "This driver supports only 8, 16 and 32bpp");

        ppdev->cPelSize        = 2;
        ppdev->cjPel           = 4;
        ppdev->iBitmapFormat   = BMF_32BPP;
        ppdev->ulWhite         = 0xffffffff;
        ppdev->flRed           = VideoModeInformation.RedMask;
        ppdev->flGreen         = VideoModeInformation.GreenMask;
        ppdev->flBlue          = VideoModeInformation.BlueMask;

        pgdi->ulNumColors      = (ULONG) -1;
        pgdi->ulNumPalReg      = 0;
        pgdi->ulHTOutputFormat = HT_FORMAT_32BPP;

        pdi->iDitherFormat     = BMF_32BPP;
        pdi->flGraphicsCaps   &= ~(GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    }

    DISPDBG((5, "Passed bInitializeModeFields"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG                   ulTemp;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8, 15, 16 or 32 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            ((pVideoTemp->BitsPerPlane != 8) &&
             (pVideoTemp->BitsPerPlane != 15) &&
             (pVideoTemp->BitsPerPlane != 16) &&
             (pVideoTemp->BitsPerPlane != 32)))
        {
            DISPDBG((2, "Rejecting miniport mode:"));
            DISPDBG((2, "   Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "   Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "   Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                   pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "   Frequency     -- %li", pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\fillpath.c ===
/******************************Module*Header*******************************\
* Module Name: fillpath.c
*
* Contains the DrvFillPath routine.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

// LATER move pointed-to variables into automatics in search loops
// LATER handle complex clipping
// LATER coalesce rectangles

#include "precomp.h"

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// Int32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit LONGs to produce a 64-bit LONGLONG result.
//      I use it because it is much faster than 64x64 multiplies.

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define TAKING_ALLOC_STATS  0

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill

#if TAKING_ALLOC_STATS
    ULONG BufferHitInFillpath = 0;
    ULONG BufferMissInFillpath = 0;
#endif

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.  This routine
* detects single convex polygons, and will call to separate faster convex
* polygon code for those cases.  This routine also detects polygons that
* are really rectangles, and handles those separately as well.
*
* Note: Multiple polygons in a path cannot be treated as being disjoint;
*       the fill must consider all the points in the path.  That is, if the
*       path contains multiple polygons, you cannot simply draw one polygon
*       after the other (unless they don't overlap).
*
* Note: This function is optional, but is recommended for good performance.
*       To get GDI to call this function, not only do you have to
*       HOOK_FILLPATH, you have to set GCAPS_ALTERNATEFILL and/or
*       GCAPS_WINDINGFILL.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    ULONG rop4;
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    ULONG        ulHwMix;           // Hardware mix value
    RBRUSH_COLOR rbc;               // Realized brush or solid color
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    FNFILL      *pfnFill;           // Points to appropriate fill routine

    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev;
    DSURF       *pdsurf;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        goto ReturnTrue;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                           flOptions));
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = pdsurf->poh->x;
    ppdev->yOffset = pdsurf->poh->y;

    pfnFill = ppdev->pfnFillSolid;
    ulHwMix = (gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xF];
    iSolidColor = 0;                    // Assume we won't need a pattern

    rop4 = (gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xff];

    if ((((rop4 & 0xff00) >> 8) != (rop4 & 0x00ff)) ||
        ((((rop4 >> 4) ^ (rop4)) & 0xf0f) != 0))  // Only do if we need a pattern
    {
        iSolidColor     = pbo->iSolidColor;
        rbc.iSolidColor = iSolidColor;
        if (rbc.iSolidColor == -1)
        {
            rbc.prb = pbo->pvRbrush;
            if (rbc.prb == NULL)
            {
                rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                if (rbc.prb == NULL)
                    return(FALSE);
            }
            pfnFill = ppdev->pfnFillPat;
        }
    }

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    bMore = PATHOBJ_bEnum(ppo, &pd);

    if (jClipping == DC_TRIVIAL)
    {
        if (bMore)
        {
            // FastFill only knows how to take a single contiguous buffer
            // of points.  Unfortunately, GDI sometimes hands us paths
            // that are split over multiple path data records.  Convex
            // figures such as Ellipses, Pies and RoundRects are almost
            // always given in multiple records.  Since probably 90% of
            // multiple record paths could still be done by FastFill, for
            // those cases we simply copy the points into a contiguous
            // buffer...

            // First make sure that the entire path would fit in the
            // temporary buffer, and make sure the path isn't comprised
            // of more than one subpath:

            if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
                (pd.flags & PD_ENDSUBPATH))
                goto SkipFastFill;

            pptfxTmp = &aptfxBuf[0];

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

            pptfxTmp     += pd.count;
            cptfxTmp      = pd.count;
            flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
                cptfxTmp += pd.count;
                pptfxTmp += pd.count;
            } while (!(pd.flags & PD_ENDSUBPATH));

            // Fake up the path data record:

            pd.pptfx  = &aptfxBuf[0];
            pd.count  = cptfxTmp;
            pd.flags |= flFirstRecord;

            // If there's more than one subpath, we can't call FastFill:

            if (bMore)
                goto SkipFastFill;
        }

        if (bFastFill(ppdev, pd.count, pd.pptfx, ulHwMix, iSolidColor,
                       rbc.prb, pptlBrush))
        {
            return(TRUE);
        }
    }

SkipFastFill:

    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle)) {
                // Totally clipped, nothing to do
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
#if TAKING_ALLOC_STATS
            BufferMissInFillpath++;
#endif
        //
        // try to allocate enough memory
        //
        pFreeEdges = (EDGE *) EngAllocMem(0, (ppo->cCurves * sizeof(EDGE)), ALLOC_TAG);

        if (pFreeEdges == NULL)
        {
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
#if TAKING_ALLOC_STATS
            BufferHitInFillpath++;
#endif
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
            // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect)) {
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                    (*pfnFill)(ppdev, ulNumRects, prclRects, ulHwMix,
                               rbc, pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
        (*pfnFill)(ppdev, ulNumRects, prclRects, ulHwMix, rbc, pptlBrush);
    }

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        EngFreeMem (pFreeEdges);
    }

    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else

    LONGLONG llErrorTerm;
    INT NumAdjustDowns;

    llErrorTerm = *pErrorTerm;

    // Adjust the error term up by the number of y coordinates we'll skip
    llErrorTerm += Int32x32To64(iErrorAdjustUp,yJump);

    // See if the error term turned over even once while skipping
    if (llErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (UInt64Div32To32(llErrorTerm,iErrorAdjustDown)) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        llErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }

    *pErrorTerm = (INT) llErrorTerm;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\heap.c ===
/******************************Module*Header*******************************\
* Module Name: heap.c
*
* This module contains the routines for a 2-d heap.  It is used primarily
* for allocating space for device-format-bitmaps in off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* The heap algorithm employed herein attempts to solve an unsolvable
* problem: the problem of keeping arbitrary sized bitmaps as packed as
* possible in a 2-d space, when the bitmaps can come and go at random.
*
* This problem is due entirely to the nature of the hardware for which this
* driver is written: the hardware treats everything as 2-d quantities.  If
* the hardware bitmap pitch could be changed so that the bitmaps could be
* packed linearly in memory, the problem would be infinitely easier (it is
* much easier to track the memory, and the accelerator can be used to re-pack
* the heap to avoid segmentation).
*
* If your hardware can treat bitmaps as one dimensional quantities (as can
* the XGA and ATI), by all means please implement a new off-screen heap.
*
* When the heap gets full, old allocations will automatically be punted
* from off-screen and copied to DIBs, which we'll let GDI draw on.
*
* Note that this heap manages reverse-L shape off-screen memory
* configurations (where the scan pitch is longer than the visible screen,
* such as happens at 800x600 when the scan length must be a multiple of
* 1024).
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define OH_ALLOC_SIZE   4000        // Do all memory allocations in 4k chunks
#define OH_QUANTUM      8           // The minimum dimension of an allocation
#define CXCY_SENTINEL   0x7fffffff  // The sentinel at the end of the available
                                    //  list has this very large 'cxcy' value

// This macro results in the available list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

/******************************Public*Routine******************************\
* OH* pohNewNode
*
* Allocates a basic memory unit in which we'll pack our data structures.
*
* Since we'll have a lot of OH nodes, most of which we will be
* occasionally traversing, we do our own memory allocation scheme to
* keep them densely packed in memory.
*
* It would be the worst possible thing for the working set to simply
* call EngAllocMem(sizeof(OH)) every time we needed a new node.  There
* would be no locality; OH nodes would get scattered throughout memory,
* and as we traversed the available list for one of our allocations,
* it would be far more likely that we would hit a hard page fault.
\**************************************************************************/

OH* pohNewNode(
PDEV*   ppdev)
{
    LONG     i;
    LONG     cOhs;
    OHALLOC* poha;
    OH*      poh;

    if (ppdev->heap.pohFreeList == NULL)
    {
        // We zero-init to initialize all the OH flags, and to help in
        // debugging (we can afford to do this since we'll be doing this
        // very infrequently):

        poha = EngAllocMem(FL_ZERO_MEMORY, OH_ALLOC_SIZE, ALLOC_TAG);
        if (poha == NULL)
            return(NULL);

        // Insert this OHALLOC at the begining of the OHALLOC chain:

        poha->pohaNext  = ppdev->heap.pohaChain;
        ppdev->heap.pohaChain = poha;

        // This has a '+ 1' because OHALLOC includes an extra OH in its
        // structure declaration:

        cOhs = (OH_ALLOC_SIZE - sizeof(OHALLOC)) / sizeof(OH) + 1;

        // The big OHALLOC allocation is simply a container for a bunch of
        // OH data structures in an array.  The new OH data structures are
        // linked together and added to the OH free list:

        poh = &poha->aoh[0];
        for (i = cOhs - 1; i != 0; i--)
        {
            poh->pohNext = poh + 1;
            poh          = poh + 1;
        }

        poh->pohNext      = NULL;
        ppdev->heap.pohFreeList = &poha->aoh[0];
    }

    poh = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh->pohNext;

    return(poh);
}

/******************************Public*Routine******************************\
* VOID vOhFreeNode
*
* Frees our basic data structure allocation unit by adding it to a free
* list.
*
\**************************************************************************/

VOID vOhFreeNode(
PDEV*   ppdev,
OH*     poh)
{
    if (poh == NULL)
        return;

    poh->pohNext            = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh;
    poh->ofl                = 0;
}

/******************************Public*Routine******************************\
* OH* pohFree
*
* Frees an off-screen heap allocation.  The free space will be combined
* with any adjacent free spaces to avoid segmentation of the 2-d heap.
*
* Note: A key idea here is that the data structure for the upper-left-
*       most node must be kept at the same physical CPU memory so that
*       adjacency links are kept correctly (when two free spaces are
*       merged, the lower or right node can be freed).
*
\**************************************************************************/

OH* pohFree(
PDEV*   ppdev,
OH*     poh)
{
    ULONG cxcy;
    OH*   pohBeside;
    OH*   pohNext;
    OH*   pohPrev;

    if (poh == NULL)
        return(NULL);

    DISPDBG((1, "Freeing %li x %li at (%li, %li)",
            poh->cx, poh->cy, poh->x, poh->y));

    #if DEBUG_HEAP
    {
        RECTL           rclBitmap;
        RBRUSH_COLOR    rbc;
        LONG            xOffset;
        LONG            yOffset;

        rclBitmap.left   = poh->x;
        rclBitmap.top    = poh->y;
        rclBitmap.right  = poh->x + poh->cx;
        rclBitmap.bottom = poh->y + poh->cy;

        xOffset = ppdev->xOffset;
        yOffset = ppdev->yOffset;

        ppdev->xOffset = 0;
        ppdev->yOffset = 0;

        ppdev->pfnFillSolid(ppdev, 1, &rclBitmap, LOGICAL_0, LOGICAL_0, rbc,
                            NULL);

        ppdev->xOffset = xOffset;
        ppdev->yOffset = yOffset;
    }
    #endif

    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:

    ppdev->iHeapUniq++;

MergeLoop:

    ASSERTDD(!(poh->ofl & OFL_PERMANENT), "Can't free permanents for now");

    // Try merging with the right sibling:

    pohBeside = poh->pohRight;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cy      == poh->cy)         &&
        (pohBeside->pohUp   == poh->pohUp)      &&
        (pohBeside->pohDown == poh->pohDown)    &&
        (pohBeside->pohRight->pohLeft != pohBeside))
    {
        // Add the right rectangle to ours:

        poh->cx      += pohBeside->cx;
        poh->pohRight = pohBeside->pohRight;

        // Remove 'pohBeside' from the ??? list and free it:

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the lower sibling:

    pohBeside = poh->pohDown;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown->pohUp != pohBeside))
    {
        poh->cy     += pohBeside->cy;
        poh->pohDown = pohBeside->pohDown;

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the left sibling:

    pohBeside = poh->pohLeft;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cy       == poh->cy)        &&
        (pohBeside->pohUp    == poh->pohUp)     &&
        (pohBeside->pohDown  == poh->pohDown)   &&
        (pohBeside->pohRight == poh)            &&
        (poh->pohRight->pohLeft != poh))
    {
        // We add our rectangle to the one to the left:

        pohBeside->cx      += poh->cx;
        pohBeside->pohRight = poh->pohRight;

        // Remove 'poh' from the ??? list and free it:

        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev->pohNext = poh->pohNext;

        vOhFreeNode(ppdev, poh);

        poh = pohBeside;
        goto MergeLoop;
    }

    // Try merging with the upper sibling:

    pohBeside = poh->pohUp;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown  == poh)            &&
        (poh->pohDown->pohUp != poh))
    {
        pohBeside->cy      += poh->cy;
        pohBeside->pohDown  = poh->pohDown;

        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev->pohNext = poh->pohNext;

        vOhFreeNode(ppdev, poh);

        poh = pohBeside;
        goto MergeLoop;
    }

    // Remove the node from the ???list if it was in use (we wouldn't
    // want to do this for a OFL_PERMANENT node that had been freed):

    poh->pohNext->pohPrev = poh->pohPrev;
    poh->pohPrev->pohNext = poh->pohNext;

    cxcy = CXCY(poh->cx, poh->cy);

    // Insert the node into the available list:

    pohNext = ppdev->heap.ohAvailable.pohNext;
    while (pohNext->cxcy < cxcy)
    {
        pohNext = pohNext->pohNext;
    }
    pohPrev = pohNext->pohPrev;

    pohPrev->pohNext    = poh;
    pohNext->pohPrev    = poh;
    poh->pohPrev        = pohPrev;
    poh->pohNext        = pohNext;

    poh->ofl            = OFL_AVAILABLE;
    poh->cxcy           = cxcy;

    // Return the node pointer for the new and improved available rectangle:

    return(poh);
}

/******************************Public*Routine******************************\
* OH* pohAllocate
*
* Allocates space for an off-screen rectangle.  It will attempt to find
* the smallest available free rectangle, and will allocate the block out
* of its upper-left corner.  The remaining two rectangles will be placed
* on the available free space list.
*
* If the rectangle would have been large enough to fit into off-screen
* memory, but there is not enough available free space, we will boot
* bitmaps out of off-screen and into DIBs until there is enough room.
*
\**************************************************************************/

OH* pohAllocate(
PDEV*   ppdev,
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLOH    floh)               // Allocation flags
{
    ULONG cxcyThis;         // Width and height search key
    OH*   pohThis;          // Points to found available rectangle we'll use
    ULONG cxcy;             // Temporary versions
    OH*   pohNext;
    OH*   pohPrev;

    LONG  cxRem;
    LONG  cyRem;

    OH*   pohBelow;
    LONG  cxBelow;
    LONG  cyBelow;

    OH*   pohBeside;
    LONG  cxBeside;
    LONG  cyBeside;

    DISPDBG((1, "Allocating %li x %li...", cxThis, cyThis));

    ASSERTDD((cxThis > 0) && (cyThis > 0), "Illegal allocation size");

    // Increase the width to get the proper alignment (thus ensuring that all
    // allocations will be properly aligned):

    cxThis = (cxThis + (HEAP_X_ALIGNMENT - 1)) & ~(HEAP_X_ALIGNMENT - 1);

    // We can't succeed if the requested rectangle is larger than the
    // largest possible available rectangle:

    if ((cxThis > ppdev->heap.cxMax) || (cyThis > ppdev->heap.cyMax))
        return(NULL);

    // Find the first available rectangle the same size or larger than
    // the requested one:

    cxcyThis = CXCY(cxThis, cyThis);
    pohThis  = ppdev->heap.ohAvailable.pohNext;
    while (pohThis->cxcy < cxcyThis)
    {
        pohThis = pohThis->pohNext;
    }

    while (pohThis->cy < cyThis)
    {
        pohThis = pohThis->pohNext;
    }

    if (pohThis->cxcy == CXCY_SENTINEL)
    {
        // There was no space large enough...

        if (floh & FLOH_ONLY_IF_ROOM)
            return(NULL);

        // We couldn't find an available rectangle that was big enough
        // to fit our request.  So throw things out of the heap until we
        // have room:

        do {
            pohThis = ppdev->heap.ohDfb.pohPrev;  // Least-recently blitted

            ASSERTDD(pohThis != &ppdev->heap.ohDfb, "Ran out of in-use entries");

            // We can safely exit here if we have to:

            pohThis = pohMoveOffscreenDfbToDib(ppdev, pohThis);
            if (pohThis == NULL)
                return(NULL);

        } while ((pohThis->cx < cxThis) || (pohThis->cy < cyThis));
    }

    // We've now found an available rectangle that is the same size or
    // bigger than our requested rectangle.  We're going to use the
    // upper-left corner of our found rectangle, and divide the unused
    // remainder into two rectangles which will go on the available
    // list.

    // Compute the width of the unused rectangle to the right, and the
    // height of the unused rectangle below:

    cyRem = pohThis->cy - cyThis;
    cxRem = pohThis->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow  = cyRem;
    cxBeside = cxRem;

    if (cxRem <= cyRem)
    {
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
    else
    {
        cxBelow  = cxThis;
        cyBeside = cyThis + cyRem;
    }

    // We only make new available rectangles of the unused right and bottom
    // portions if they're greater in dimension than OH_QUANTUM (it hardly
    // makes sense to do the book-work to keep around a 2-pixel wide
    // available space, for example):

    pohBeside = NULL;
    if (cxBeside >= OH_QUANTUM)
    {
        pohBeside = pohNewNode(ppdev);
        if (pohBeside == NULL)
            return(NULL);
    }

    pohBelow = NULL;
    if (cyBelow >= OH_QUANTUM)
    {
        pohBelow = pohNewNode(ppdev);
        if (pohBelow == NULL)
        {
            vOhFreeNode(ppdev, pohBeside);
            return(NULL);
        }

        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBelow, cyBelow);
        pohNext = ppdev->heap.ohAvailable.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext   = pohBelow;
        pohNext->pohPrev   = pohBelow;
        pohBelow->pohPrev  = pohPrev;
        pohBelow->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBelow->pohLeft  = pohThis->pohLeft;
        pohBelow->pohUp    = pohThis;
        pohBelow->pohRight = pohThis->pohRight;
        pohBelow->pohDown  = pohThis->pohDown;

        // Update the rest of the new node information:

        pohBelow->cxcy     = cxcy;
        pohBelow->ofl      = OFL_AVAILABLE;
        pohBelow->x        = pohThis->x;
        pohBelow->y        = pohThis->y + cyThis;
        pohBelow->cx       = cxBelow;
        pohBelow->cy       = cyBelow;

        // Modify the current node to reflect the changes we've made:

        pohThis->cy        = cyThis;
    }

    if (cxBeside >= OH_QUANTUM)
    {
        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBeside, cyBeside);
        pohNext = ppdev->heap.ohAvailable.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = pohBeside;
        pohNext->pohPrev    = pohBeside;
        pohBeside->pohPrev  = pohPrev;
        pohBeside->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBeside->pohUp    = pohThis->pohUp;
        pohBeside->pohLeft  = pohThis;
        pohBeside->pohDown  = pohThis->pohDown;
        pohBeside->pohRight = pohThis->pohRight;

        // Update the rest of the new node information:

        pohBeside->cxcy     = cxcy;
        pohBeside->ofl      = OFL_AVAILABLE;
        pohBeside->x        = pohThis->x + cxThis;
        pohBeside->y        = pohThis->y;
        pohBeside->cx       = cxBeside;
        pohBeside->cy       = cyBeside;

        // Modify the current node to reflect the changes we've made:

        pohThis->cx         = cxThis;
    }

    if (pohBelow != NULL)
    {
        pohThis->pohDown = pohBelow;
        if ((pohBeside != NULL) && (cyBeside == pohThis->cy))
            pohBeside->pohDown = pohBelow;
    }
    if (pohBeside != NULL)
    {
        pohThis->pohRight = pohBeside;
        if ((pohBelow != NULL) && (cxBelow == pohThis->cx))
            pohBelow->pohRight  = pohBeside;
    }

    pohThis->ofl                 = OFL_INUSE;
    pohThis->cxcy                = CXCY(pohThis->cx, pohThis->cy);
    pohThis->pdsurf              = NULL;    // Caller is responsible for
                                            //   setting this field

    // Remove this from the available list:

    pohThis->pohPrev->pohNext    = pohThis->pohNext;
    pohThis->pohNext->pohPrev    = pohThis->pohPrev;

    // Now insert this at the head of the DFB list:

    pohThis->pohNext                   = ppdev->heap.ohDfb.pohNext;
    pohThis->pohPrev                   = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.pohNext->pohPrev = pohThis;
    ppdev->heap.ohDfb.pohNext          = pohThis;

    DISPDBG((1, "   Allocated at (%li, %li)", pohThis->x, pohThis->y));

    return(pohThis);
}

/******************************Public*Routine******************************\
* VOID vCalculateMaxmimum
*
* Traverses the list of in-use and available rectangles to find the one
* with the maximal area.
*
\**************************************************************************/

VOID vCalculateMaximum(
PDEV*   ppdev)
{
    OH*     poh;
    OH*     pohSentinel;
    LONG    lArea;
    LONG    lMaxArea;
    LONG    cxMax;
    LONG    cyMax;
    LONG    i;

    lMaxArea = 0;
    cxMax    = 0;
    cyMax    = 0;

    // First time through, loop through the list of available rectangles:

    pohSentinel = &ppdev->heap.ohAvailable;

    for (i = 2; i != 0; i--)
    {
        for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
        {
            ASSERTDD(!(poh->ofl & OFL_PERMANENT),
                     "Permanent in available/DFB chain?");

            // We don't have worry about this multiply overflowing
            // because we are dealing in physical screen coordinates,
            // which will probably never be more than 15 bits:

            lArea = poh->cx * poh->cy;
            if (lArea > lMaxArea)
            {
                cxMax    = poh->cx;
                cyMax    = poh->cy;
                lMaxArea = lArea;
            }
        }

        // Second time through, loop through the list of in-use rectangles:

        pohSentinel = &ppdev->heap.ohDfb;
    }

    // All that we are interested in is the dimensions of the rectangle
    // that has the largest possible available area (and remember that
    // there might not be any possible available area):

    ppdev->heap.cxMax = cxMax;
    ppdev->heap.cyMax = cyMax;
}

/******************************Public*Routine******************************\
* OH* pohAllocatePermanent
*
* Allocates an off-screen rectangle that can never be booted of the heap.
* It's the caller's responsibility to manage the rectangle, which includes
* what to do with the memory in DrvAssertMode when the display is changed
* to full-screen mode.
*
\**************************************************************************/

OH* pohAllocatePermanent(
PDEV*   ppdev,
LONG    cx,
LONG    cy)
{
    OH*     poh;

    poh = pohAllocate(ppdev, cx, cy, 0);
    if (poh != NULL)
    {
        // Mark the rectangle as permanent:

        poh->ofl = OFL_PERMANENT;

        // Remove the node from the most-recently blitted list:

        poh->pohPrev->pohNext = poh->pohNext;
        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev = NULL;
        poh->pohNext = NULL;

        // Now calculate the new maximum size rectangle available in the
        // heap:

        vCalculateMaximum(ppdev);
    }

    return(poh);
}

/******************************Public*Routine******************************\
* BOOL bMoveDibToOffscreenDfbIfRoom
*
* Converts the DIB DFB to an off-screen DFB, if there's room for it in
* off-screen memory.
*
* Returns: FALSE if there wasn't room, TRUE if successfully moved.
*
\**************************************************************************/

BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)
{
    OH*         poh;
    SURFOBJ*    pso;
    RECTL       rclDst;
    POINTL      ptlSrc;
    HSURF       hsurf;

    ASSERTDD(pdsurf->dt == DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:

    if (!ppdev->bEnabled)
        return(FALSE);

    poh = pohAllocate(ppdev, pdsurf->sizl.cx, pdsurf->sizl.cy,
                      FLOH_ONLY_IF_ROOM);
    if (poh == NULL)
    {
        // There wasn't any free room.

        return(FALSE);
    }

    // 'pdsurf->sizl' is the actual bitmap dimension, not 'poh->cx' or
    // 'poh->cy'.

    rclDst.left   = poh->x;
    rclDst.top    = poh->y;
    rclDst.right  = rclDst.left + pdsurf->sizl.cx;
    rclDst.bottom = rclDst.top  + pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    vPutBits(ppdev, pdsurf->pso, &rclDst, &ptlSrc);

    // Update the data structures to reflect the new off-screen node:

    pso           = pdsurf->pso;
    pdsurf->dt    = DT_SCREEN;
    pdsurf->poh   = poh;
    poh->pdsurf   = pdsurf;

    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):

    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMoveOffscreenDfbToDib
*
* Converts the DFB from being off-screen to being a DIB.
*
* Note: The caller does NOT have to call 'pohFree' on 'poh' after making
*       this call.
*
* Returns: NULL if the function failed (due to a memory allocation).
*          Otherwise, it returns a pointer to the coalesced off-screen heap
*          node that has been made available for subsequent allocations
*          (useful when trying to free enough memory to make a new
*          allocation).
\**************************************************************************/

OH* pohMoveOffscreenDfbToDib(
PDEV*   ppdev,
OH*     poh)
{
    DSURF*   pdsurf;
    HBITMAP  hbmDib;
    SURFOBJ* pso;
    RECTL    rclDst;
    POINTL   ptlSrc;

    DISPDBG((1, "Throwing out %li x %li at (%li, %li)!",
                 poh->cx, poh->cy, poh->x, poh->y));

    pdsurf = poh->pdsurf;

    ASSERTDD((poh->x != 0) || (poh->y != 0),
            "Can't make the visible screen into a DIB");
    ASSERTDD(pdsurf->dt != DT_DIB,
            "Can't make a DIB into even more of a DIB");

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                rclDst.left   = 0;
                rclDst.top    = 0;
                rclDst.right  = pdsurf->sizl.cx;
                rclDst.bottom = pdsurf->sizl.cy;

                ptlSrc.x      = poh->x;
                ptlSrc.y      = poh->y;

                vGetBits(ppdev, pso, &rclDst, &ptlSrc);

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;

                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:

                return(pohFree(ppdev, poh));
            }
        }

        // Fail case:

        EngDeleteSurface((HSURF) hbmDib);
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* BOOL bMoveEverythingFromOffscreenToDibs
*
* This function is used when we're about to enter full-screen mode, which
* would wipe all our off-screen bitmaps.  GDI can ask us to draw on
* device bitmaps even when we're in full-screen mode, and we do NOT have
* the option of stalling the call until we switch out of full-screen.
* We have no choice but to move all the off-screen DFBs to DIBs.
*
* Returns TRUE if all DSURFs have been successfully moved.
*
\**************************************************************************/

BOOL bMoveAllDfbsFromOffscreenToDibs(
PDEV*   ppdev)
{
    OH*  poh;
    OH*  pohNext;
    BOOL bRet;

    bRet = TRUE;
    poh  = ppdev->heap.ohDfb.pohNext;
    while (poh != &ppdev->heap.ohDfb)
    {
        pohNext = poh->pohNext;

        // If something's already a DIB, we shouldn't try to make it even
        // more of a DIB:

        if (poh->pdsurf->dt == DT_SCREEN)
        {
            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
                bRet = FALSE;
        }

        poh = pohNext;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Function called by GDI to create a device-format-bitmap (DFB).  We will
* always try to allocate the bitmap in off-screen; if we can't, we simply
* fail the call and GDI will create and manage the bitmap itself.
*
* Note: We do not have to zero the bitmap bits.  GDI will automatically
*       call us via DrvBitBlt to zero the bits (which is a security
*       consideration).
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)
{
    PDEV*   ppdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;
    FLONG   flHooks;

    ppdev = (PDEV*) dhpdev;

    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.

    if (!ppdev->bEnabled)
        return(0);

    // We only support device bitmaps when we're in a fully accelerated
    // mode:

    if (ppdev->iBitmapFormat != BMF_8BPP)
        return(0);

    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.

    if (iFormat != ppdev->iBitmapFormat)
        return(0);

    poh = pohAllocate(ppdev, sizl.cx, sizl.cy, 0);
    if (poh != NULL)
    {
        pdsurf = EngAllocMem(0, sizeof(DSURF), ALLOC_TAG);
        if (pdsurf != NULL)
        {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                flHooks = ppdev->flHooks;

                #if SYNCHRONIZEACCESS_WORKS
                {
                    // Setting the SYNCHRONIZEACCESS flag tells GDI that we
                    // want all drawing to the bitmaps to be synchronized (GDI
                    // is multi-threaded and by default does not synchronize
                    // device bitmap drawing -- it would be a Bad Thing for us
                    // to have multiple threads using the accelerator at the
                    // same time):

                    flHooks |= HOOK_SYNCHRONIZEACCESS;
                }
                #endif // SYNCHRONIZEACCESS_WORKS

                if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                                        flHooks))
                {
                    pdsurf->dt    = DT_SCREEN;
                    pdsurf->poh   = poh;
                    pdsurf->sizl  = sizl;
                    pdsurf->ppdev = ppdev;
                    poh->pdsurf   = pdsurf;

                    return(hbmDevice);
                }

                EngDeleteSurface((HSURF) hbmDevice);
            }
            EngFreeMem(pdsurf);
        }
        pohFree(ppdev, poh);
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap
*
* Deletes a DFB.
*
\**************************************************************************/

VOID DrvDeleteDeviceBitmap(
DHSURF  dhsurf)
{
    DSURF*   pdsurf;
    PDEV*    ppdev;
    SURFOBJ* psoDib;
    HSURF    hsurfDib;

    pdsurf = (DSURF*) dhsurf;
    ppdev  = pdsurf->ppdev;

    if (pdsurf->dt == DT_SCREEN)
    {
        pohFree(ppdev, pdsurf->poh);
    }
    else
    {
        ASSERTDD(pdsurf->dt == DT_DIB, "Expected DIB type");

        psoDib = pdsurf->pso;

        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):

        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }

    EngFreeMem(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeOffscreenHeap
*
* This function is called whenever we switch in or out of full-screen
* mode.  We have to convert all the off-screen bitmaps to DIBs when
* we switch to full-screen (because we may be asked to draw on them even
* when in full-screen, and the mode switch would probably nuke the video
* memory contents anyway).
*
\**************************************************************************/

BOOL bAssertModeOffscreenHeap(
PDEV*   ppdev,
BOOL    bEnable)
{
    BOOL b;

    b = TRUE;

    if (!bEnable)
    {
        b = bMoveAllDfbsFromOffscreenToDibs(ppdev);
    }

    return(b);
}

/******************************Public*Routine******************************\
* VOID vDisableOffscreenHeap
*
* Frees any resources allocated by the off-screen heap.
*
\**************************************************************************/

VOID vDisableOffscreenHeap(
PDEV*   ppdev)
{
    OHALLOC* poha;
    OHALLOC* pohaNext;

    poha = ppdev->heap.pohaChain;
    while (poha != NULL)
    {
        pohaNext = poha->pohaNext;  // Grab the next pointer before it's freed
        EngFreeMem(poha);
        poha = pohaNext;
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableOffscreenHeap
*
* Initializes the off-screen heap using all available video memory,
* accounting for the portion taken by the visible screen.
*
* Input: ppdev->cxScreen
*        ppdev->cyScreen
*        ppdev->cxMemory
*        ppdev->cyMemory
*
\**************************************************************************/

BOOL bEnableOffscreenHeap(
PDEV*   ppdev)
{
    OH*     poh;

    DISPDBG((5, "Screen: %li x %li  Memory: %li x %li",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory));

    ppdev->heap.pohaChain   = NULL;
    ppdev->heap.pohFreeList = NULL;

    // Initialize the available list, which will be a circular
    // doubly-linked list kept in ascending 'cxcy' order, with a
    // 'sentinel' at the end of the list:

    poh = pohNewNode(ppdev);
    if (poh == NULL)
        goto ReturnFalse;

    // The first node describes the entire video memory size:

    poh->pohNext  = &ppdev->heap.ohAvailable;
    poh->pohPrev  = &ppdev->heap.ohAvailable;
    poh->ofl      = OFL_AVAILABLE;
    poh->x        = 0;
    poh->y        = 0;
    poh->cx       = ppdev->cxMemory;
    poh->cy       = ppdev->cyMemory;
    poh->cxcy     = CXCY(ppdev->cxMemory, ppdev->cyMemory);
    poh->pohLeft  = &ppdev->heap.ohAvailable;
    poh->pohUp    = &ppdev->heap.ohAvailable;
    poh->pohRight = &ppdev->heap.ohAvailable;
    poh->pohDown  = &ppdev->heap.ohAvailable;

    // The second node is our available list sentinel:

    ppdev->heap.ohAvailable.pohNext = poh;
    ppdev->heap.ohAvailable.pohPrev = poh;
    ppdev->heap.ohAvailable.cxcy    = CXCY_SENTINEL;
    ppdev->heap.ohAvailable.cx      = 0x7fffffff;
    ppdev->heap.ohAvailable.cy      = 0x7fffffff;
    ppdev->heap.ohAvailable.ofl     = OFL_PERMANENT;
    ppdev->heap.ohDfb.pohLeft       = NULL;
    ppdev->heap.ohDfb.pohUp         = NULL;
    ppdev->heap.ohDfb.pohRight      = NULL;
    ppdev->heap.ohDfb.pohDown       = NULL;

    // Initialize the most-recently-blitted DFB list, which will be
    // a circular doubly-linked list kept in order, with a sentinel at
    // the end.  This node is also used for the screen-surface, for its
    // offset:

    ppdev->heap.ohDfb.pohNext  = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.pohPrev  = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.ofl      = OFL_PERMANENT;

    // For the moment, make the max really big so that the first
    // allocation we're about to do will succeed:

    ppdev->heap.cxMax = 0x7fffffff;
    ppdev->heap.cyMax = 0x7fffffff;

    // Finally, reserve the upper-left corner for the screen.  We can
    // actually throw away 'poh' because we'll never need it again
    // (not even for disabling the off-screen heap since everything is
    // freed using OHALLOCs):

    poh = pohAllocatePermanent(ppdev, ppdev->cxScreen, ppdev->cyScreen);

    ppdev->pohFrontBuffer = poh;

    ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == 0),
             "We assumed allocator would use the upper-left corner");

    DISPDBG((5, "Passed bEnableOffscreenHeap"));

    if (poh != NULL)
        return(TRUE);

    vDisableOffscreenHeap(ppdev);

ReturnFalse:

    DISPDBG((0, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\hw.h ===
/******************************Module*Header*******************************\
* Module Name: hw.h
*
* All the hardware specific driver file stuff.  Parts are mirrored in
* 'hw.inc'.
*
* Copyright (c) 1994-1995 Microsoft Corporation
*
\**************************************************************************/

#define GC_INDEX            0x3CE      /* Index and Data Registers */
#define GC_DATA             0x3CF
#define SEQ_INDEX           0x3C4
#define SEQ_DATA            0x3C5
#define CRTC_INDEX          0x3D4
#define CRTC_DATA           0x3D5
#define ATTR_INDEX          0x3C0
#define ATTR_DATA           0x3C0
#define ATTR_DATA_READ      0x3C1
#define MISC_OUTPUT         0x3C2
#define MISC_OUTPUT_READ    0x3CC
#define INPUT_STATUS_REG_1  0x3DA

#define CTRL_REG_0           0x40
#define CTRL_REG_1         0x63CA      /* Datapath Registers */
#define DATAPATH_CTRL        0x5A
#define GC_FG_COLOR          0x43
#define GC_BG_COLOR          0x44
#define SEQ_PIXEL_WR_MSK     0x02
#define GC_PLANE_WR_MSK      0x08
#define ROP_A              0x33C7
#define ROP_0              0x33C5
#define ROP_1              0x33C4
#define ROP_2              0x33C3
#define ROP_3              0x33C2
#define DATA_ROTATE          0x03
#define READ_CTRL            0x41

#define X0_SRC_ADDR_LO     0x63C0      /* BitBLT Registers */
#define Y0_SRC_ADDR_HI     0x63C2
#define DEST_ADDR_LO       0x63CC
#define DEST_ADDR_HI       0x63CE
#define BITMAP_WIDTH       0x23C2
#define BITMAP_HEIGHT      0x23C4
#define SRC_PITCH          0x23CA
#define DEST_PITCH         0x23CE
#define BLT_CMD_0          0x33CE
#define BLT_CMD_1          0x33CF
#define PREG_0             0x33CA
#define PREG_1             0x33CB
#define PREG_2             0x33CC
#define PREG_3             0x33CD
#define PREG_4             0x33CA
#define PREG_5             0x33CB
#define PREG_6             0x33CC
#define PREG_7             0x33CD

#define BLT_START_MASK     0x33C0      /* XccelVGA BitBlt Registers */
#define BLT_END_MASK       0x33C1
#define BLT_ROTATE         0x33C8
#define BLT_SKEW_MASK      0x33C9
#define BLT_SRC_ADDR       0x23C0
#define DEST_OFFSET        0x23CC


#define X1                 0x83CC      /* Line Draw Registers */
#define Y1                 0x83CE
#define LINE_PATTERN       0x83C0
#define PATTERN_END          0x62
#define LINE_CMD             0x60
#define LINE_PIX_CNT         0x64
#define LINE_ERR_TERM        0x66
#define SIGN_CODES           0x63
#define   X_MAJOR            0x00
#define   Y_MAJOR            0x01
#define   DELTA_Y_POS        0x00
#define   DELTA_Y_NEG        0x02
#define   DELTA_X_POS        0x00
#define   DELTA_X_NEG        0x04
#define K1_CONST             0x68
#define K2_CONST             0x6A

#define PALETTE_WRITE       0x3C8      /* DAC registers */
#define PALETTE_READ        0x3C7
#define PALETTE_DATA        0x3C9
#define DAC_CMD_0          0x83C6
#define DAC_CMD_1          0x13C8
#define DAC_CMD_2          0x13C9
#define   CURSOR_ENABLE      0x02
#define   CURSOR_DISABLE     0x00

#define CURSOR_WRITE        0x3C8     /* HW Cursor registers */
#define CURSOR_READ         0x3C7
#define   CURSOR_PLANE_0     0x00
#define   CURSOR_PLANE_1     0x80
#define CURSOR_DATA        0x13C7
#define CURSOR_COLOR_READ  0x83C7
#define CURSOR_COLOR_WRITE 0x83C8
#define CURSOR_COLOR_DATA  0x83C9
#define   OVERSCAN_COLOR     0x00
#define   CURSOR_COLOR_1     0x01
#define   CURSOR_COLOR_2     0x02
#define   CURSOR_COLOR_3     0x03
#define CURSOR_X           0x93C8     /* 16-bit register */
#define CURSOR_Y           0x93C6     /* 16-bit register */
#define   CURSOR_CX            32     /* h/w cursor width */
#define   CURSOR_CY            32     /* h/w cursor height */

#define PAGE_REG_0           0x45      /* Control Registers */
#define PAGE_REG_1           0x46
#define HI_ADDR_MAP          0x48        /* LO, HI is at 0x49 */
#define ENV_REG_1            0x50
#define VIRT_CTRLR_SEL     0x83C4

#define VER_NUM_REG         0x0C
#define EXT_VER_NUM_REG     0x0D
#define ENV_REG_0           0x0F
#define BLT_CONFIG          0x10
#define CONFIG_STATE        0x52         /* LO, HI is at 0x53 */
#define BIOS_DATA           0x54
#define DATAPATH_CONTROL    0x5A

#define LOCK_KEY_QVISION    0x05
#define EXT_COLOR_MODE      0x01

#define BLT_ENABLE          0x28       /* BLT_CONFIG values */
#define RESET_BLT           0x60       // Make sure we don't enable IRQ9


#define BUFFER_BUSY          0x80      /* CTRL_REG_1 values */
#define GLOBAL_BUSY          0x40
#define BLOCK_WRITE          0x20
#define PACKED_PIXEL_VIEW    0x00
#define PLANAR_VIEW          0x08
#define EXPAND_TO_FG         0x10
#define EXPAND_TO_BG         0x18
#define BITS_PER_PIX_4       0x00
#define BITS_PER_PIX_8       0x02
#define BITS_PER_PIX_16      0x04
#define BITS_PER_PIX_32      0x06
#define ENAB_TRITON_MODE     0x01

#define ROPSELECT_NO_ROPS              0x00      /* DATAPATH_CTRL values */
#define ROPSELECT_PRIMARY_ONLY         0x40
#define ROPSELECT_ALL_EXCPT_PRIMARY    0x80
#define ROPSELECT_ALL                  0xc0
#define PIXELMASK_ONLY                 0x00
#define PIXELMASK_AND_SRC_DATA         0x10
#define PIXELMASK_AND_CPU_DATA         0x20
#define PIXELMASK_AND_SCRN_LATCHES     0x30
#define PLANARMASK_ONLY                0x00
#define PLANARMASK_NONE_0XFF           0x04
#define PLANARMASK_AND_CPU_DATA        0x08
#define PLANARMASK_AND_SCRN_LATCHES    0x0c
#define SRC_IS_CPU_DATA                0x00
#define SRC_IS_SCRN_LATCHES            0x01
#define SRC_IS_PATTERN_REGS            0x02
#define SRC_IS_LINE_PATTERN            0x03

#define LOGICAL_0               0x00       // 0   (ROP values)
#define NOT_DEST_AND_NOT_SOURCE 0x01       // DSon
#define DEST_AND_NOT_SOURCE     0x02       // DSna
#define NOT_SOURCE              0x03       // Sn
#define NOT_DEST_AND_SOURCE     0x04       // SDna
#define NOT_DEST                0x05       // Dn
#define DEST_XOR_SOURCE         0x06       // DSx
#define NOT_DEST_OR_NOT_SOURCE  0x07       // DSan
#define DEST_AND_SOURCE         0x08       // DSa
#define DEST_XNOR_SOURCE        0x09       // DSxn
#define DEST_DATA               0x0A       // D
#define DEST_OR_NOT_SOURCE      0x0B       // DSno
#define SOURCE_DATA             0x0C       // S
#define NOT_DEST_OR_SOURCE      0x0D       // SDno
#define DEST_OR_SOURCE          0x0E       // DSo
#define LOGICAL_1               0x0F       // 1

#define START_BLT            0x01      /* BLT_CMD_0 values */
#define NO_BYTE_SWAP         0x00
#define BYTE_SWAP            0x20
#define FORWARD              0x00
#define BACKWARD             0x40
#define WRAP                 0x00
#define NO_WRAP              0x80

#define PRELOAD              0x02      /* BLT_CMD_0 XccelVGA values */
#define SKIP_LAST            0x04
#define SKIP_SRC             0x08
#define SKIP_DEST            0x10


#define LIN_SRC_ADDR         0x00      /* BLT_CMD_1 values */
#define XY_SRC_ADDR          0x40
#define LIN_DEST_ADDR        0x00
#define XY_DEST_ADDR         0x80

#define BLT_ROP_ENABLE       0x10      /* BLT_CMD_1 XccelVGA values */
#define BLT_DSR              0x20

#define START_LINE           0x01      /* LINE_CMD values */
#define NO_CALC_ONLY         0x00
#define CALC_ONLY            0x02
#define LAST_PIXEL_ON        0x00
#define LAST_PIXEL_NULL      0x04
#define NO_KEEP_X0_Y0        0x00
#define KEEP_X0_Y0           0x08
#define RETAIN_PATTERN_PTR   0x00
#define RESET_PATTERN_PTR    0x10
#define USE_AXIAL_WHEN_ZERO  0x00
#define NO_USE_AXIAL_WHEN_ZERO 0x20
#define AXIAL_ROUND_DOWN     0x40
#define AXIAL_ROUND_UP       0x00
#define LINE_RESET           0x80

#define SS_BIT               0x01      /* BLT_CMD_0 bit */

#define START_BIT            0x01      /* LINE_CMD bit */

#define NO_ROTATE            0x00
#define NO_MASK              0xFF

/////////////////////////////////////////////////////////////////////
//

#define IO_WAIT_FOR_IDLE(ppdev, pjIoBase)                           \
{                                                                   \
    while (READ_PORT_UCHAR((pjIoBase) + CTRL_REG_1) & GLOBAL_BUSY)  \
        ;                                                           \
}

#define IO_WAIT_BUFFER_NOT_BUSY(ppdev, pjIoBase)                    \
{                                                                   \
    while (READ_PORT_UCHAR((pjIoBase) + CTRL_REG_1) & BUFFER_BUSY)  \
        ;                                                           \
}

// We occasionally hit a chip bug in QVision 1280's on monochrome
// expansions, where the the driver will get caught in an endless loop
// on engine-busy, even though all data has been transferred
// properly.  It turns out that some QVision chips have a bug where
// 'certain types of I/O writes abutting a write to the frame buffer'
// cause the data count occasionally to fail to increment.
//
// As a work-around, we'll always check for the hang condition after
// doing a monochrome expansion, looping a few times to allow the
// engine to catch up, and if it's still hung we reset the engine:

#define WAIT_TRANSFER_DONE_LOOP_COUNT       100

#define IO_WAIT_TRANSFER_DONE(ppdev, pjIoBase)                            \
{                                                                         \
    LONG i;                                                               \
    for (i = WAIT_TRANSFER_DONE_LOOP_COUNT; i != 0; i--)                  \
    {                                                                     \
        if (!(READ_PORT_UCHAR((pjIoBase) + CTRL_REG_1) & GLOBAL_BUSY))    \
            break;                                                        \
    }                                                                     \
    if (i == 0)                                                           \
    {                                                                     \
        IO_BLT_CMD_0(ppdev, (pjIoBase), 0);                               \
        IO_WAIT_FOR_IDLE(ppdev, (pjIoBase));                              \
    }                                                                     \
}

//

#define IO_CURSOR_X(ppdev, pjIoBase, x)                                   \
    WRITE_PORT_USHORT((pjIoBase) + CURSOR_X, (USHORT)(x))

#define IO_CURSOR_Y(ppdev, pjIoBase, x)                                   \
    WRITE_PORT_USHORT((pjIoBase) + CURSOR_Y, (USHORT)(x))

#define IO_CTRL_REG_1(ppdev, pjIoBase, x)                                 \
    WRITE_PORT_UCHAR((pjIoBase) + CTRL_REG_1, (x))

#define IO_DATAPATH_CTRL(ppdev, pjIoBase, x)                              \
{                                                                         \
    WRITE_PORT_USHORT((pjIoBase)+GC_INDEX,(USHORT)(((x)<<8)|DATAPATH_CTRL));\
    MEMORY_BARRIER();                                                     \
}

#define IO_FG_COLOR(ppdev, pjIoBase, x)                                   \
{                                                                         \
    WRITE_PORT_USHORT((pjIoBase)+GC_INDEX,(USHORT)(((x)<<8)|GC_FG_COLOR));\
    MEMORY_BARRIER();                                                     \
}

#define IO_BG_COLOR(ppdev, pjIoBase, x)                                   \
{                                                                         \
    WRITE_PORT_USHORT((pjIoBase)+GC_INDEX,(USHORT)(((x)<<8)|GC_BG_COLOR));\
    MEMORY_BARRIER();                                                     \
}

#define IO_BLT_CONFIG(ppdev, pjIoBase, x)                                 \
{                                                                         \
    WRITE_PORT_USHORT((pjIoBase) +GC_INDEX,(USHORT)(((x)<<8)|BLT_CONFIG));\
    MEMORY_BARRIER();                                                     \
}

#define IO_BLT_CMD_0(ppdev, pjIoBase, x)                                  \
{                                                                         \
    MEMORY_BARRIER();                                                     \
    WRITE_PORT_UCHAR((pjIoBase) + BLT_CMD_0, (x));                        \
    MEMORY_BARRIER();                                                     \
}

#define IO_BLT_CMD_1(ppdev, pjIoBase, x)                                  \
    WRITE_PORT_UCHAR((pjIoBase) + BLT_CMD_1, (x))

#define IO_PREG_COLOR_8(ppdev, pjIoBase, x)                               \
{                                                                         \
    ULONG ul;                                                             \
                                                                          \
    /* Unfortunately, PREG_0 isn't dword aligned, so we can't */          \
    /* do a dword out to it...                                */          \
                                                                          \
    ul = ((x) << 8) | (x);                                                \
    WRITE_PORT_USHORT((pjIoBase) + PREG_4, (USHORT)(ul));                 \
    WRITE_PORT_USHORT((pjIoBase) + PREG_6, (USHORT)(ul));                 \
    MEMORY_BARRIER();                                                     \
    WRITE_PORT_USHORT((pjIoBase) + PREG_0, (USHORT)(ul));                 \
    WRITE_PORT_USHORT((pjIoBase) + PREG_2, (USHORT)(ul));                 \
}

#define IO_PREG_PATTERN(ppdev, pjIoBase, p)                               \
{                                                                         \
    USHORT* pw = (USHORT*) (p);                                           \
                                                                          \
    /* Unfortunately, PREG_0 isn't dword aligned, so we can't */          \
    /* do a dword out to it...                                */          \
                                                                          \
    WRITE_PORT_USHORT((pjIoBase) + PREG_4, (USHORT)(*(pw)));              \
    WRITE_PORT_USHORT((pjIoBase) + PREG_6, (USHORT)(*(pw + 1)));          \
    MEMORY_BARRIER();                                                     \
    WRITE_PORT_USHORT((pjIoBase) + PREG_0, (USHORT)(*(pw + 2)));          \
    WRITE_PORT_USHORT((pjIoBase) + PREG_2, (USHORT)(*(pw + 3)));          \
}

#define IO_BITMAP_WIDTH(ppdev, pjIoBase, x)                               \
    WRITE_PORT_USHORT((pjIoBase) + BITMAP_WIDTH, (USHORT)(x))

#define IO_BITMAP_HEIGHT(ppdev, pjIoBase, x)                              \
    WRITE_PORT_USHORT((pjIoBase) + BITMAP_HEIGHT, (USHORT)(x))

#define IO_PACKED_HEIGHT_WIDTH(ppdev, pjIoBase, yx)                       \
{                                                                         \
    WRITE_PORT_USHORT((pjIoBase) + BITMAP_HEIGHT, (USHORT)(yx));          \
    WRITE_PORT_USHORT((pjIoBase) + BITMAP_WIDTH, (USHORT)((yx) >> 16));   \
}

#define IO_SRC_LIN(ppdev, pjIoBase, x)                                    \
    WRITE_PORT_ULONG((pjIoBase) + X0_SRC_ADDR_LO, (x))

#define IO_SRC_ALIGN(ppdev, pjIoBase, x)                                  \
    WRITE_PORT_UCHAR((pjIoBase) + X0_SRC_ADDR_LO, (UCHAR)(x))

#define IO_DEST_LIN(ppdev, pjIoBase, x)                                   \
    WRITE_PORT_ULONG((pjIoBase) + DEST_ADDR_LO, (x))

/* Note that the pitch is specified in dwords */

#define IO_DEST_PITCH(ppdev, pjIoBase, x)                                 \
    WRITE_PORT_USHORT((pjIoBase) + DEST_PITCH, (USHORT)(x))

#define IO_SRC_PITCH(ppdev, pjIoBase, x)                                  \
    WRITE_PORT_USHORT((pjIoBase) + SRC_PITCH, (USHORT)(x))

#define IO_ROP_A(ppdev, pjIoBase, x)                                      \
    WRITE_PORT_UCHAR((pjIoBase) + ROP_A, (UCHAR)(x))

#define IO_K1_CONST(ppdev, pjIoBase, x)                                   \
{                                                                         \
    WRITE_PORT_USHORT((pjIoBase)+GC_INDEX,(USHORT)(((x)<<8)|(K1_CONST))); \
    MEMORY_BARRIER();                                                     \
    WRITE_PORT_USHORT((pjIoBase)+GC_INDEX,(USHORT)(((x)&0xff00)|(K1_CONST + 1)));\
    MEMORY_BARRIER();                                                     \
}

#define IO_K2_CONST(ppdev, pjIoBase, x)                                   \
{                                                                         \
    WRITE_PORT_USHORT((pjIoBase) +GC_INDEX,(USHORT)(((x)<<8)|(K2_CONST)));\
    MEMORY_BARRIER();                                                     \
    WRITE_PORT_USHORT((pjIoBase)+GC_INDEX,(USHORT)(((x)&0xff00)|(K2_CONST+1)));\
    MEMORY_BARRIER();                                                     \
}

#define IO_LINE_PIX_CNT(ppdev, pjIoBase, x)                               \
{                                                                         \
    WRITE_PORT_USHORT((pjIoBase)+GC_INDEX,(USHORT)(((x)<<8)|(LINE_PIX_CNT))); \
    MEMORY_BARRIER();                                                     \
    WRITE_PORT_USHORT((pjIoBase)+GC_INDEX,(USHORT)(((x)&0xff00)|(LINE_PIX_CNT+1))); \
    MEMORY_BARRIER();                                                     \
}

#define IO_LINE_ERR_TERM(ppdev, pjIoBase, x)                              \
{                                                                         \
    WRITE_PORT_USHORT((pjIoBase)+GC_INDEX,(USHORT)(((x)<<8)|(LINE_ERR_TERM)));\
    MEMORY_BARRIER();                                                     \
    WRITE_PORT_USHORT((pjIoBase)+GC_INDEX,(USHORT)(((x)&0xff00)|(LINE_ERR_TERM+1)));\
    MEMORY_BARRIER();                                                     \
}

#define IO_SIGN_CODES(ppdev, pjIoBase, x)                                 \
{                                                                         \
    WRITE_PORT_USHORT((pjIoBase)+ GC_INDEX,(USHORT)(((x)<<8)|SIGN_CODES));\
    MEMORY_BARRIER();                                                     \
}

#define IO_LINE_PATTERN(ppdev, pjIoBase, x)                               \
    WRITE_PORT_ULONG((pjIoBase) + LINE_PATTERN, (x))

#define IO_LINE_CMD(ppdev, pjIoBase, x)                                   \
{                                                                         \
    MEMORY_BARRIER();                                                     \
    WRITE_PORT_USHORT((pjIoBase) +GC_INDEX,(USHORT)(((x) << 8)|LINE_CMD));\
    MEMORY_BARRIER();                                                     \
}

#define IO_PIXEL_WRITE_MASK(ppdev, pjIoBase, x)                           \
{                                                                         \
    WRITE_PORT_USHORT((pjIoBase)+SEQ_INDEX,(USHORT)(((x)<<8)|SEQ_PIXEL_WR_MSK));\
}

//

#define IO_SRC_XY(ppdev, pjIoBase, x, y)                                  \
    WRITE_PORT_ULONG((pjIoBase) + X0_SRC_ADDR_LO,                         \
        (((y) + ppdev->yOffset) << 16) | ((x) + ppdev->xOffset))

#define IO_DEST_XY(ppdev, pjIoBase, x, y)                                 \
    WRITE_PORT_ULONG((pjIoBase) + DEST_ADDR_LO,                           \
        (((y) + ppdev->yOffset) << 16) | ((x) + ppdev->xOffset))

#define IO_DEST_X(ppdev, pjIoBase, x)                                     \
    WRITE_PORT_USHORT((pjIoBase) + DEST_ADDR_LO, ((x) + (USHORT) ppdev->xOffset))

#define IO_DEST_Y(ppdev, pjIoBase, x)                                     \
    WRITE_PORT_USHORT((pjIoBase) + DEST_ADDR_HI, ((x) + (USHORT) ppdev->yOffset))

#define IO_X0_Y0(ppdev, pjIoBase, x, y)                                   \
    WRITE_PORT_ULONG((pjIoBase) + X0_SRC_ADDR_LO,                         \
        (((y) + ppdev->yOffset) << 16) | ((x) + ppdev->xOffset))

#define IO_X1_Y1(ppdev, pjIoBase, x, y)                                   \
    WRITE_PORT_ULONG((pjIoBase) + X1,                                     \
        (((y) + ppdev->yOffset) << 16) | ((x) + ppdev->xOffset))

//

#define IO_ABS_SRC_XY(ppdev, pjIoBase, x, y)                              \
    WRITE_PORT_ULONG((pjIoBase) + X0_SRC_ADDR_LO, ((y) << 16) | (x))

#define IO_ABS_DEST_XY(ppdev, pjIoBase, x, y)                             \
    WRITE_PORT_ULONG((pjIoBase) + DEST_ADDR_LO, ((y) << 16) | (x))

#define IO_ABS_X0_Y0(ppdev, pjIoBase, x, y)                               \
    WRITE_PORT_ULONG((pjIoBase) + X0_SRC_ADDR_LO, ((y) << 16) | (x))

#define IO_ABS_X1_Y1(ppdev, pjIoBase, x, y)                               \
    WRITE_PORT_ULONG((pjIoBase) + X1, ((y) << 16) | (x))

/////////////////////////////////////////////////////////////////////

#define MEM_CTRL_REG_1       0xf3c
#define MEM_DATAPATH_CTRL    0xf3e
#define MEM_FG_COLOR         0xf40
#define MEM_BG_COLOR         0xf41
#define MEM_BLT_CMD_0        0xfb0
#define MEM_BLT_CMD_1        0xfb1
#define MEM_BROADCAST_COLOR  0xf42
#define MEM_PREG_0           0xfa0
#define MEM_PREG_1           0xfa1
#define MEM_PREG_2           0xfa2
#define MEM_PREG_3           0xfa3
#define MEM_PREG_4           0xfa4
#define MEM_PREG_5           0xfa5
#define MEM_PREG_6           0xfa6
#define MEM_PREG_7           0xfa7
#define MEM_BITMAP_HEIGHT    0xfac
#define MEM_BITMAP_WIDTH     0xfae
#define MEM_SRC_ADDR_LO      0xfb8
#define MEM_SRC_ADDR_HI      0xfba
#define MEM_DEST_ADDR_LO     0xfbc
#define MEM_DEST_ADDR_HI     0xfbe
#define MEM_DEST_PITCH       0xfaa
#define MEM_SRC_PITCH        0xfa8
#define MEM_ROP_A            0xf43
#define MEM_K1_CONST         0xf70
#define MEM_K2_CONST         0xf74
#define MEM_LINE_PIX_CNT     0xf68
#define MEM_LINE_ERR_TERM    0xf6c
#define MEM_SIGN_CODES       0xf63
#define MEM_LINE_PATTERN     0xf64
#define MEM_LINE_CMD         0xf60
#define MEM_X0               0xf78
#define MEM_Y0               0xf7a
#define MEM_X1               0xf7c
#define MEM_Y1               0xf7e
#define MEM_SEQ_PIXEL_WR_MSK 0xf30

//

#define MM_WAIT_FOR_IDLE(ppdev, pjMmBase)                                 \
{                                                                         \
    while (READ_REGISTER_UCHAR((pjMmBase) + MEM_CTRL_REG_1) & GLOBAL_BUSY)\
        ;                                                                 \
}

#define MM_WAIT_BUFFER_NOT_BUSY(ppdev, pjMmBase)                          \
{                                                                         \
    while (READ_REGISTER_UCHAR((pjMmBase) + MEM_CTRL_REG_1) & BUFFER_BUSY)\
        ;                                                                 \
}

// We occasionally hit a chip bug in QVision 1280's on monochrome
// expansions, where the the driver will get caught in an endless loop
// on engine-busy, even though all data has been transferred
// properly.  It turns out that some QVision chips have a bug where
// 'certain types of I/O writes abutting a write to the frame buffer'
// cause the data count occasionally to fail to increment.
//
// As a work-around, we'll always check for the hang condition after
// doing a monochrome expansion, looping a few times to allow the
// engine to catch up, and if it's still hung we reset the engine:

#define WAIT_TRANSFER_DONE_LOOP_COUNT       100

#define MM_WAIT_TRANSFER_DONE(ppdev, pjMmBase)                            \
{                                                                         \
    LONG i;                                                               \
    for (i = WAIT_TRANSFER_DONE_LOOP_COUNT; i != 0; i--)                  \
    {                                                                     \
        if (!(READ_REGISTER_UCHAR((pjMmBase) + MEM_CTRL_REG_1) & GLOBAL_BUSY))  \
            break;                                                        \
    }                                                                     \
    if (i == 0)                                                           \
    {                                                                     \
        MM_BLT_CMD_0(ppdev, (pjMmBase), 0);                               \
        MM_WAIT_FOR_IDLE(ppdev, (pjMmBase));                              \
    }                                                                     \
}

//

#define MM_CTRL_REG_1(ppdev, pjMmBase, x)                                 \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_CTRL_REG_1, (UCHAR) (x))

#define MM_DATAPATH_CTRL(ppdev, pjMmBase, x)                              \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_DATAPATH_CTRL, (UCHAR) (x))

#define MM_FG_COLOR(ppdev, pjMmBase, x)                                   \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_FG_COLOR, (UCHAR) (x))

#define MM_BG_COLOR(ppdev, pjMmBase, x)                                   \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_BG_COLOR, (UCHAR) (x))

#define MM_BLT_CMD_0(ppdev, pjMmBase, x)                                  \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_BLT_CMD_0, (UCHAR) (x))

#define MM_BLT_CMD_1(ppdev, pjMmBase, x)                                  \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_BLT_CMD_1, (UCHAR) (x))

#define MM_PREG_COLOR_8(ppdev, pjMmBase, x)                               \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_BROADCAST_COLOR, (UCHAR) (x))

#define MM_PREG_PATTERN(ppdev, pjMmBase, p)                               \
{                                                                         \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_PREG_4, *((ULONG*) (p)));       \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_PREG_0, *((ULONG*) (p) + 1));   \
}

#define MM_PREG_BLOCK(ppdev, pjMmBase, p)                                 \
{                                                                         \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_PREG_0, *((ULONG*) (p)));       \
}

#define MM_BITMAP_WIDTH(ppdev, pjMmBase, x)                               \
    WRITE_REGISTER_USHORT((pjMmBase) + MEM_BITMAP_WIDTH, (USHORT) (x))

#define MM_BITMAP_HEIGHT(ppdev, pjMmBase, x)                              \
    WRITE_REGISTER_USHORT((pjMmBase) + MEM_BITMAP_HEIGHT, (USHORT) (x))

#define MM_PACKED_HEIGHT_WIDTH(ppdev, pjMmBase, yx)                       \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_BITMAP_HEIGHT, (yx))

#define MM_SRC_LIN(ppdev, pjMmBase, x)                                    \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_SRC_ADDR_LO, (x))

#define MM_SRC_ALIGN(ppdev, pjMmBase, x)                                  \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_SRC_ADDR_LO, (UCHAR) (x))

#define MM_DEST_LIN(ppdev, pjMmBase, x)                                   \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_DEST_ADDR_LO, (x))

/* Note that the pitch is specified in dwords */

#define MM_DEST_PITCH(ppdev, pjMmBase, x)                                 \
    WRITE_REGISTER_USHORT((pjMmBase) + MEM_DEST_PITCH, (USHORT) (x))

#define MM_SRC_PITCH(ppdev, pjMmBase, x)                                  \
    WRITE_REGISTER_USHORT((pjMmBase) + MEM_SRC_PITCH, (USHORT) (x))

#define MM_ROP_A(ppdev, pjMmBase, x)                                      \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_ROP_A, (UCHAR) (x))

#define MM_K1_CONST(ppdev, pjMmBase, x)                                   \
    WRITE_REGISTER_USHORT((pjMmBase) + MEM_K1_CONST, (USHORT) (x))

#define MM_K2_CONST(ppdev, pjMmBase, x)                                   \
    WRITE_REGISTER_USHORT((pjMmBase) + MEM_K2_CONST, (USHORT) (x))

#define MM_LINE_PIX_CNT(ppdev, pjMmBase, x)                               \
    WRITE_REGISTER_USHORT((pjMmBase) + MEM_LINE_PIX_CNT, (USHORT) (x))

#define MM_LINE_ERR_TERM(ppdev, pjMmBase, x)                              \
    WRITE_REGISTER_USHORT((pjMmBase) + MEM_LINE_ERR_TERM, (USHORT) (x))

#define MM_SIGN_CODES(ppdev, pjMmBase, x)                                 \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_SIGN_CODES, (UCHAR) (x))

#define MM_LINE_PATTERN(ppdev, pjMmBase, x)                               \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_LINE_PATTERN, (x))

#define MM_LINE_CMD(ppdev, pjMmBase, x)                                   \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_LINE_CMD, (UCHAR) (x))

#define MM_PIXEL_WRITE_MASK(ppdev, pjMmBase, x)                           \
    WRITE_REGISTER_UCHAR((pjMmBase) + MEM_SEQ_PIXEL_WR_MSK, (UCHAR) (x))

//

#define MM_SRC_XY(ppdev, pjMmBase, x, y)                                  \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_SRC_ADDR_LO,                    \
        (((y) + ppdev->yOffset) << 16) | ((x) + ppdev->xOffset))

#define MM_DEST_XY(ppdev, pjMmBase, x, y)                                 \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_DEST_ADDR_LO,                   \
        (((y) + ppdev->yOffset) << 16) | ((x) + ppdev->xOffset))

#define MM_DEST_X(ppdev, pjMmBase, x)                                     \
    WRITE_REGISTER_USHORT((pjMmBase) + MEM_DEST_ADDR_LO,                  \
                          (USHORT) ((x) + (ppdev->xOffset)))

#define MM_DEST_Y(ppdev, pjMmBase, x)                                     \
    WRITE_REGISTER_USHORT((pjMmBase) + MEM_DEST_ADDR_HI,                  \
                          (USHORT) ((x) + (ppdev->yOffset)))

#define MM_X0_Y0(ppdev, pjMmBase, x, y)                                   \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_X0,                             \
        (((y) + ppdev->yOffset) << 16) | ((x) + ppdev->xOffset))

#define MM_X1_Y1(ppdev, pjMmBase, x, y)                                   \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_X1,                             \
        (((y) + ppdev->yOffset) << 16) | ((x) + ppdev->xOffset))

//

#define MM_ABS_SRC_XY(ppdev, pjMmBase, x, y)                              \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_SRC_ADDR_LO, ((y) << 16) | (x))

#define MM_ABS_DEST_XY(ppdev, pjMmBase, x, y)                             \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_DEST_ADDR_LO, ((y) << 16) | (x))

#define MM_ABS_X0_Y0(ppdev, pjMmBase, x, y)                               \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_X0, ((y) << 16) | (x))

#define MM_ABS_X1_Y1(ppdev, pjMmBase, x, y)                               \
    WRITE_REGISTER_ULONG((pjMmBase) + MEM_X1, ((y) << 16) | (x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

// This is the default QVision line command for drawing integer lines.
//
// The line command register is sticky, meaning that the settings for
// the current line will affect any future point-to-point lines, so
// we want to always keep our preferred values for doing integer
// point-to-point lines:

#define DEFAULT_LINE_CMD (USE_AXIAL_WHEN_ZERO | \
                          RETAIN_PATTERN_PTR  | \
                          NO_KEEP_X0_Y0       | \
                          CALC_ONLY           | \
                          START_LINE)

typedef struct _PDEV PDEV;      // Handy forward declaration

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;              // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);

// Strip drawers:

VOID vIoStripSolidHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vIoStripSolidVertical(PDEV*, STRIP*, LINESTATE*);
VOID vIoStripSolidDiagonalHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vIoStripSolidDiagonalVertical(PDEV*, STRIP*, LINESTATE*);
VOID vIoStripStyledHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vIoStripStyledVertical(PDEV*, STRIP*, LINESTATE*);

VOID vMmStripSolidHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vMmStripSolidVertical(PDEV*, STRIP*, LINESTATE*);
VOID vMmStripSolidDiagonalHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vMmStripSolidDiagonalVertical(PDEV*, STRIP*, LINESTATE*);
VOID vMmStripStyledHorizontal(PDEV*, STRIP*, LINESTATE*);
VOID vMmStripStyledVertical(PDEV*, STRIP*, LINESTATE*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\lines.c ===
/*************************************************************************\
* Module Name: Lines.c
*
* Contains most of the required GDI line support.  Supports drawing
* lines in short 'strips' when clipping is complex or coordinates
* are too large to be drawn by the line hardware.
*
* Copyright (c) 1990-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

///////////////////////////////////////////////////////////////////////

// We have to be careful of arithmetic overflow in a number of places.
// Fortunately, the compiler is guaranteed to natively support 64-bit
// signed LONGLONGs and 64-bit unsigned DWORDLONGs.
//
// UUInt32x32To64(a, b) is a macro defined in 'winnt.h' that multiplies
//      two 32-bit ULONGs to produce a 64-bit DWORDLONG result.
//
// UInt64By32To32 is our own macro to divide a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// UInt64Mod32To32 is our own macro to modulus a 64-bit DWORDLONG by
//      a 32-bit ULONG to produce a 32-bit ULONG result.
//
// 64 bit divides are usually very expensive.  Since it's very rare
// that we'll get lines where the upper 32 bits of the 64 bit result
// are used, we can almost always use 32-bit ULONG divides.  We still
// must correctly handle the larger cases:

#define UInt64Div32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) / (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) / (ULONG)(b)))

#define UInt64Mod32To32(a, b)                   \
    ((((DWORDLONG)(a)) > ULONG_MAX)          ?  \
        (ULONG)((DWORDLONG)(a) % (ULONG)(b)) :  \
        (ULONG)((ULONG)(a) % (ULONG)(b)))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V | FL_FLIP_D
};

//////////////////////////////////////////////////////////////////////////
// General defines for bHardwareLine

BOOL bHardwareLine(PDEV*, POINTFIX*, POINTFIX*);

#define HW_FLIP_D           0x0001L     // Diagonal flip
#define HW_FLIP_V           0x0002L     // Vertical flip
#define HW_FLIP_H           0x0004L     // Horizontal flip
#define HW_FLIP_SLOPE_ONE   0x0008L     // Normalized line has exactly slope one
#define HW_FLIP_MASK        (HW_FLIP_D | HW_FLIP_V | HW_FLIP_H)

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

LONG gaiDir[] = { 0, 1, 7, 6, 3, 2, 4, 5 };

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};

//////////////////////////////////////////////////////////////////////////
// QVision specific defines

// The QVision's hardware can have 12 bits of significance for the error and
// step terms:

#define NUM_DDA_BITS 12

// This table is used to compute the appropriate QVision drawing command
// so that tie-breaker pixels are done correctly in each direction.  The
// index is a flag composed of HW_FLIP_D, HW_FLIP_V and HW_FLIP_H, which
// indicates in which octant the line lies:

LONG gaiIntegerLineCmd[] = {
    DEFAULT_LINE_CMD | LAST_PIXEL_NULL | AXIAL_ROUND_DOWN,
    DEFAULT_LINE_CMD | LAST_PIXEL_NULL | AXIAL_ROUND_DOWN,
    DEFAULT_LINE_CMD | LAST_PIXEL_NULL | AXIAL_ROUND_UP,
    DEFAULT_LINE_CMD | LAST_PIXEL_NULL | AXIAL_ROUND_DOWN,
    DEFAULT_LINE_CMD | LAST_PIXEL_NULL | AXIAL_ROUND_DOWN,
    DEFAULT_LINE_CMD | LAST_PIXEL_NULL | AXIAL_ROUND_UP,
    DEFAULT_LINE_CMD | LAST_PIXEL_NULL | AXIAL_ROUND_UP,
    DEFAULT_LINE_CMD | LAST_PIXEL_NULL | AXIAL_ROUND_UP,
};

/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing NT Lines Right
* --------------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Styled lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the S3 sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code (or if your display is a frame
*    buffer, fall back to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the
*    'bHardwareLine' routine for an example.
*
\**************************************************************************/

BOOL bLines(
PDEV*      ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart)     // Flags for each line, which is a combination of:
                        //      FL_SIMPLE_CLIP
                        //      FL_COMPLEX_CLIP
                        //      FL_STYLED
                        //      FL_LAST_PEL_INCLUSIVE
                        //        - Should be set only for all integer lines,
                        //          and can't be used with FL_COMPLEX_CLIP
{
    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG  llBeta;
    LONGLONG  llGamma;
    LONGLONG  dl;
    LONGLONG  ll;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line
    BYTE*     pjIoBase;
    BYTE*     pjMmBase;

    pjIoBase = ppdev->pjIoBase;
    pjMmBase = ppdev->pjMmBase;

    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

        // Check for non-clipped, non-styled integer endpoint lines

        if ((fl & (FL_CLIP | FL_STYLED)) == 0)
        {
            // Special-case integer end-point lines:

            if (((M0 | dM | N0 | dN) & (F - 1)) == 0)
            {
                LONG    x0;
                LONG    y0;
                LONG    x1;
                LONG    y1;
                FLONG   flQuadrant;
                ULONG   ulCmd;

                x0 = M0 >> FLOG2;
                y0 = N0 >> FLOG2;
                x1 = dM >> FLOG2;
                y1 = dN >> FLOG2;

                flQuadrant = 0;
                dM -= M0;
                if ((LONG) dM < 0)
                {
                    dM = - (LONG) dM;
                    flQuadrant = HW_FLIP_H;
                }
                dN -= N0;
                if ((LONG) dN < 0)
                {
                    dN = - (LONG) dN;
                    flQuadrant |= HW_FLIP_V;
                }
                if (dN > dM)
                {
                    flQuadrant |= HW_FLIP_D;
                }

                // When the start and end point are coincident, NT's
                // last-pel exclusion rule dictates that no pixel is
                // lit.  Unfortunately, the QVision will light a
                // pixel even when LAST_PIXEL_NULL is specified, so
                // we have to special case zero-length lines:

                if (dN | dM)
                {
                    ulCmd = gaiIntegerLineCmd[flQuadrant];

                    // Unfortunately, the line command register itself isn't
                    // buffered, so we can't take advantage of the buffered
                    // registers here:

                    if (pjMmBase != NULL)
                    {
                        MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
                        MM_X0_Y0(ppdev, pjMmBase, x0, y0);
                        MM_X1_Y1(ppdev, pjMmBase, x1, y1);
                        MM_LINE_CMD(ppdev, pjMmBase, ulCmd);
                    }
                    else
                    {
                        IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
                        IO_X0_Y0(ppdev, pjIoBase, x0, y0);
                        IO_X1_Y1(ppdev, pjIoBase, x1, y1);
                        IO_LINE_CMD(ppdev, pjIoBase, ulCmd);
                    }
                }
                goto Next_Line;
            }

            // Check for fractional endpoint lines that are small enough
            // to use the hardware DDA:

            if (bHardwareLine(ppdev, pptfxFirst, pptfxBuf))
            {
                // v-normmi... NT bugid 227596
                // bHardwareLine sets the LINE_CMD bits differently so set them
                // back to the default values so that the next 'strip' works right
                if (pjMmBase != NULL)
                {
                    MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
                    MM_LINE_CMD(ppdev, pjMmBase, DEFAULT_LINE_CMD & ~START_LINE);
                }
                else    
                {
                    IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
                    IO_LINE_CMD(ppdev, pjIoBase, DEFAULT_LINE_CMD & ~START_LINE);
                }

                goto Next_Line;
            }
        }

        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitued more than 2^31 - 1, but GDI never actually checks
    // its transforms.  So we have to check for this case to avoid overflow:

        dM -= M0;
        if ((LONG) dM < 0)
        {
            goto Next_Line;
        }

        if ((LONG) dN < (LONG) N0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        dN -= N0;

        if ((LONG) dN < 0)
        {
            goto Next_Line;
        }

    // We now have a line running left-to-right, top-to-bottom from (M0, N0)
    // to (M0 + dM, N0 + dN):

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        llGamma = UInt32x32To64(dM, N0 + F/2) - UInt32x32To64(M0, dN);
        if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
        {
            llGamma--;
        }

        llGamma >>= FLOG2;
        llBeta = ~llGamma;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
            ULONG M1 = FXFRAC(M0 + dM);

            x1 = LFLOOR(M0 + dM);

            if (fl & FL_LAST_PEL_INCLUSIVE)
            {
            // It sure is easy to compute the first pel when lines have only
            // integer coordinates and are last-pel inclusive:

                x0 = 0;
                y0 = 0;

            // Last-pel inclusive lines that are exactly one pixel long
            // have a 'delta-x' and 'delta-y' equal to zero.  The problem is
            // that our clip code assumes that 'delta-x' is always non-zero
            // (since it never happens with last-pel exclusive lines).  As
            // an inelegant solution, we simply modify 'delta-x' in this
            // case -- because the line is exactly one pixel long, changing
            // the slope will obviously have no effect on rasterization.

                if (x1 == 0)
                {
                    dM      = 1;
                    llGamma = 0;
                    llBeta  = ~llGamma;
                }
            }
            else
            {
                if (fl & FL_FLIP_H)
                {
                // ---------------------------------------------------------------
                // Line runs right-to-left:  <----

                // Compute x1:

                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                        {
                            x1++;
                        }
                    }
                    else if (abs((LONG) (N1 - F/2)) + M1 > F)
                    {
                        x1++;
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((N1 > 0) && (M1 == N1 + 8))
                            x1++;

                    // Don't you love special cases?  Is this a rhetorical question?

                        if ((N0 > 0) && (M0 == N0 + 8))
                        {
                            x0      = 2;
                            ulDelta = dN;
                            goto right_to_left_compute_y0;
                        }
                    }

                // Compute x0:

                    x0      = 1;
                    ulDelta = 0;
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                        {
                            x0      = 2;
                            ulDelta = dN;
                        }
                    }
                    else if (abs((LONG) (N0 - F/2)) + M0 > F)
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }


                // Compute y0:

                right_to_left_compute_y0:

                    y0 = 0;
                    ll = llGamma + (LONGLONG) ulDelta;

                    if (ll >= (LONGLONG) (2 * dM - dN))
                        y0 = 2;
                    else if (ll >= (LONGLONG) (dM - dN))
                        y0 = 1;
                }
                else
                {
                // ---------------------------------------------------------------
                // Line runs left-to-right:  ---->

                // Compute x1:

                    if (!(fl & FL_LAST_PEL_INCLUSIVE))
                        x1--;

                    if (M1 > 0)
                    {
                        if (N1 == 0)
                        {
                            if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                                x1++;
                        }
                        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
                        {
                            x1++;
                        }
                    }

                    if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                           == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                    {
                    // Have to special-case diagonal lines going through our
                    // the point exactly equidistant between two horizontal
                    // pixels, if we're supposed to round x=1/2 down:

                        if ((M1 > 0) && (N1 == M1 + 8))
                            x1--;

                        if ((M0 > 0) && (N0 == M0 + 8))
                        {
                            x0 = 0;
                            goto left_to_right_compute_y0;
                        }
                    }

                // Compute x0:

                    x0 = 0;
                    if (M0 > 0)
                    {
                        if (N0 == 0)
                        {
                            if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                                x0 = 1;
                        }
                        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
                        {
                            x0 = 1;
                        }
                    }

                // Compute y0:

                left_to_right_compute_y0:

                    y0 = 0;
                    if (llGamma >= (LONGLONG) (dM - (dN & (-(LONG) x0))))
                    {
                        y0 = 1;
                    }
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/

        if (fl & FL_COMPLEX_CLIP)
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

            dl = UInt32x32To64(x0, dN) + llGamma;

        // y0 = dl / dM:

            y0 = UInt64Div32To32(dl, dM);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

            dl = UInt32x32To64(x1, dN) + llGamma;

        // y1 = dl / dM:

            y1 = UInt64Div32To32(dl, dM);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;
                dl = UInt32x32To64(y1, dM) + llBeta;

            // x1 = dl / dN:

                x1 = UInt64Div32To32(dl, dN);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;
                dl = UInt32x32To64(x0, dN) + llGamma;

            // y0 = dl / dM;

                y0 = UInt64Div32To32(dl, dM);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;
                dl = UInt32x32To64(y0, dM) + llBeta;

            // x0 = dl / dN + 1;

                x0 = UInt64Div32To32(dl, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_STYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

        strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            llBeta  = llGamma - (LONGLONG) ((LONG) dM);
            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
                dl = UInt32x32To64(y0 + 1, dM) + llBeta;

                ASSERTDD(dl >= 0, "Oops!");

            // i = (dl / dN) - x0 + 1;
            // r = (dl % dN);

                i = UInt64Div32To32(dl, dN);
                r = UInt64Mod32To32(dl, dN);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = (LONG)(plStrip - &strip.alStrips[0]);
            (*pfn)(ppdev, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);

}

/******************************Public*Routine******************************\
* BOOL bHardwareLine(ppdev, pptfxStart, pptfxEnd)
*
* This routine is useful for folks who have line drawing hardware where
* they can explicitly set the Bresenham terms -- they can use this routine
* to draw fractional coordinate GIQ lines with the hardware.
*
* Fractional coordinate lines require an extra 4 bits of precision in the
* Bresenham terms.  For example, if your hardware has 13 bits of precision
* for the terms, you can only draw GIQ lines up to 255 pels long using this
* routine.
*
* Input:
*   pptfxStart  - Points to GIQ coordinate of start of line
*   pptfxEnd    - Points to GIQ coordinate of end of line
*   NUM_DDA_BITS- The number of bits of precision your hardware can support.
*
* Output:
*   returns     - TRUE if the line was drawn.
*                 FALSE if the line is too long, and the strips code must be
*                 used.
*
* DDALINE:
*   iDir        - Direction of the line, as an octant numbered as follows:
*
*                    \ 5 | 6 /
*                     \  |  /
*                    4 \ | / 7
*                       \ /
*                   -----+-----
*                       /|\
*                    3 / | \ 0
*                     /  |  \
*                    / 2 | 1 \
*
*   ptlStart    - Start pixel of line.
*   cPels       - # of pels in line.  *NOTE* You must check if this is <= 0!
*   dMajor      - Major axis delta.
*   dMinor      - Minor axis delta.
*   lErrorTerm  - Error term.
*
* What you do with the last 3 terms may be a little tricky.  They are
* actually the terms for the formula of the normalized line
*
*                     dMinor * x + (lErrorTerm + dMajor)
*       y(x) = floor( ---------------------------------- )
*                                  dMajor
*
* where y(x) is the y coordinate of the pixel to be lit as a function of
* the x-coordinate.
*
* Every time the line advances one in the major direction 'x', dMinor
* gets added to the current error term.  If the resulting value is >= 0,
* we know we have to move one pixel in the minor direction 'y', and
* dMajor must be subtracted from the current error term.
*
* If you're trying to figure out what this means for your hardware, you can
* think of the DDALINE terms as having been computed equivalently as
* follows:
*
*     dMinor     = 2 * (minor axis delta)
*     dMajor     = 2 * (major axis delta)
*     lErrorTerm = - (major axis delta) - fixup
*
* That is, if your documentation tells you that for integer lines, a
* register is supposed to be initialized with the value
* '2 * (minor axis delta)', you'll actually use dMinor.
*
* Example: Setting up the 8514
*
*     AXSTPSIGN is supposed to be the axial step constant register, defined
*     as 2 * (minor axis delta).  You set:
*
*           AXSTPSIGN = dMinor
*
*     DGSTPSIGN is supposed to be the diagonal step constant register,
*     defined as 2 * (minor axis delta) - 2 * (major axis delta).  You set:
*
*           DGSTPSIGN = dMinor - dMajor
*
*     ERR_TERM is supposed to be the adjusted error term, defined as
*     2 * (minor axis delta) - (major axis delta) - fixup.  You set:
*
*           ERR_TERM = lErrorTerm + dMinor
*
* Implementation:
*
*     You'll want to special case integer lines before calling this routine
*     (since they're very common, take less time to the computation of line
*     terms, and can handle longer lines than this routine because 4 bits
*     aren't being given to the fraction).
*
*     If a GIQ line is too long to be handled by this routine, you can just
*     use the slower strip routines for that line.  Note that you cannot
*     just fail the call -- you must be able to accurately draw any line
*     in the 28.4 device space when it intersects the viewport.
*
* Testing:
*
*     Use Guiman, or some other test that draws random fractional coordinate
*     lines and compares them to what GDI itself draws to a bitmap.
*
\**************************************************************************/

BOOL bHardwareLine(
PDEV*     ppdev,
POINTFIX* pptfxStart,       // Start of line
POINTFIX* pptfxEnd)         // End of line
{
    FLONG fl;    // Various flags
    ULONG M0;    // Normalized fractional unit x start coordinate (0 <= M0 < F)
    ULONG N0;    // Normalized fractional unit y start coordinate (0 <= N0 < F)
    ULONG M1;    // Normalized fractional unit x end coordinate (0 <= M1 < F)
    ULONG N1;    // Normalized fractional unit x end coordinate (0 <= N1 < F)
    ULONG dM;    // Normalized fractional unit x-delta (0 <= dM)
    ULONG dN;    // Normalized fractional unit y-delta (0 <= dN <= dM)
    LONG  x;     // Normalized x coordinate of origin
    LONG  y;     // Normalized y coordinate of origin
    LONG  x0;    // Normalized x offset from origin to start pixel (inclusive)
    LONG  y0;    // Normalized y offset from origin to start pixel (inclusive)
    LONG  x1;    // Normalized x offset from origin to end pixel (inclusive)
    LONG  lGamma;// Bresenham error term at origin
    LONG  cPels; // Number of pixels in line
    BYTE* pjMmBase;
    BYTE* pjIoBase;

/***********************************************************************\
* Normalize line to the first octant.
\***********************************************************************/

    fl = 0;

    M0 = pptfxStart->x;
    dM = pptfxEnd->x;

    if ((LONG) dM < (LONG) M0)
    {
    // Line runs from right to left, so flip across x = 0:

        M0 = -(LONG) M0;
        dM = -(LONG) dM;
        fl |= HW_FLIP_H;
    }

// Compute the delta.  The DDI says we can never have a valid delta
// with a magnitude more than 2^31 - 1, but the engine never actually
// checks its transforms.  To ensure that we'll never puke on our shoes,
// we check for that case and simply refuse to draw the line:

    dM -= M0;
    if ((LONG) dM < 0)
        return(FALSE);

    N0 = pptfxStart->y;
    dN = pptfxEnd->y;

    if ((LONG) dN < (LONG) N0)
    {
    // Line runs from bottom to top, so flip across y = 0:

        N0 = -(LONG) N0;
        dN = -(LONG) dN;
        fl |= HW_FLIP_V;
    }

// Compute another delta:

    dN -= N0;
    if ((LONG) dN < 0)
        return(FALSE);

    if (dN >= dM)
    {
        if (dN == dM)
        {
        // Have to special case slopes of one:

            fl |= HW_FLIP_SLOPE_ONE;
        }
        else
        {
        // Since line has slope greater than 1, flip across x = y:

            register ULONG ulTmp;
            ulTmp = dM; dM = dN; dN = ulTmp;
            ulTmp = M0; M0 = N0; N0 = ulTmp;
            fl |= HW_FLIP_D;
        }
    }

// Figure out if we can do the line in hardware, given that we have a
// limited number of bits of precision for the Bresenham terms.
//
// Remember that one bit has to be kept as a sign bit:

    if ((LONG) dM >= (1L << (NUM_DDA_BITS - 1)))
        return(FALSE);

    fl |= gaflHardwareRound[fl];

/***********************************************************************\
* Calculate the error term at pixel 0.
\***********************************************************************/

    x = LFLOOR((LONG) M0);
    y = LFLOOR((LONG) N0);

    M0 = FXFRAC(M0);
    N0 = FXFRAC(N0);

// NOTE NOTE NOTE: If this routine were to handle any line in the 28.4
// space, it will overflow its math (the following part requires 36 bits
// of precision)!  But we get here for lines that the hardware can handle
// (see the expression (dM >= (1L << (NUM_DDA_BITS - 1))) above?), so if
// cBits is less than 28, we're safe.
//
// If you're going to use this routine to handle all lines in the 28.4
// device space, you will HAVE to make sure the math doesn't overflow,
// otherwise you won't be NT compliant!  (See 'bHardwareLine' for an example
// how to do that.  You don't have to worry about this if you simply
// default to the strips code for long lines, because those routines
// already do the math correctly.)

// Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ].  Note
// that M0 and N0 have at most 4 bits of significance (and if the
// arguments are properly ordered, on a 486 each multiply would be no
// more than 13 cycles):

    lGamma = (N0 + F/2) * dM - M0 * dN;

    if (fl & HW_Y_ROUND_DOWN)
        lGamma--;

    lGamma >>= FLOG2;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.
\***********************************************************************/

// The toughest part of GIQ is determining the start and end pels.
//
// Our approach here is to calculate x0 and x1 (the inclusive start
// and end columns of the line respectively, relative to our normalized
// origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
// start point is easily calculated by plugging x0 into our line equation
// (which takes care of whether y = 1/2 rounds up or down in value)
// getting y0, and then undoing the normalizing flips to get back
// into device space.
//
// We look at the fractional parts of the coordinates of the start and
// end points, and call them (M0, N0) and (M1, N1) respectively, where
// 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
// to determine x0:
//
//   +-----------------------> +x
//   |
//   | 0                     1
//   |     0123456789abcdef
//   |
//   |   0 ........?xxxxxxx
//   |   1 ..........xxxxxx
//   |   2 ...........xxxxx
//   |   3 ............xxxx
//   |   4 .............xxx
//   |   5 ..............xx
//   |   6 ...............x
//   |   7 ................
//   |   8 ................
//   |   9 ......**........
//   |   a ........****...x
//   |   b ............****
//   |   c .............xxx****
//   |   d ............xxxx    ****
//   |   e ...........xxxxx        ****
//   |   f ..........xxxxxx
//   |
//   | 2                     3
//   v
//
//   +y
//
// This grid accounts for the appropriate rounding of GIQ and last-pel
// exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
// on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// For the end point, if (M1, N1) lands on an 'x', x1 =
// floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
// floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// Lines of exactly slope one require a special case for both the start
// and end.  For example, if the line ends such that (M1, N1) is (9, 1),
// the line has gone exactly through (8, 0) -- which may be considered
// to be part of 'x' because of rounding!  So slopes of exactly slope
// one going through (8, 0) must also be considered as belonging in 'x'
// when an x value of 1/2 is supposed to round up in value.

// Calculate x0, x1:

    N1 = FXFRAC(N0 + dN);
    M1 = FXFRAC(M0 + dM);

    x1 = LFLOOR(M0 + dM);

// Line runs left-to-right:

// Compute x1:

    x1--;
    if (M1 > 0)
    {
        if (N1 == 0)
        {
            if (LROUND(M1, fl & HW_X_ROUND_DOWN))
                x1++;
        }
        else if (abs((LONG) (N1 - F/2)) <= (LONG) M1)
        {
            x1++;
        }
    }

    if ((fl & (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
           == (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
    {
    // Have to special-case diagonal lines going through our
    // the point exactly equidistant between two horizontal
    // pixels, if we're supposed to round x=1/2 down:

        if ((M1 > 0) && (N1 == M1 + 8))
            x1--;

        if ((M0 > 0) && (N0 == M0 + 8))
        {
            x0 = 0;
            goto left_to_right_compute_y0;
        }
    }

// Compute x0:

    x0 = 0;
    if (M0 > 0)
    {
        if (N0 == 0)
        {
            if (LROUND(M0, fl & HW_X_ROUND_DOWN))
                x0 = 1;
        }
        else if (abs((LONG) (N0 - F/2)) <= (LONG) M0)
        {
            x0 = 1;
        }
    }

left_to_right_compute_y0:

/***********************************************************************\
* Calculate the start pixel.
\***********************************************************************/

// We now compute y0 and adjust the error term.  We know x0, and we know
// the current formula for the pixels to be lit on the line:
//
//                     dN * x + lGamma
//       y(x) = floor( --------------- )
//                           dM
//
// The remainder of this expression is the new error term at (x0, y0).
// Since x0 is going to be either 0 or 1, we don't actually have to do a
// multiply or divide to compute y0.  Finally, we subtract dM from the
// new error term so that it is in the range [-dM, 0).

    y0      = 0;
    lGamma += (dN & (-x0));
    lGamma -= dM;
    if (lGamma >= 0)
    {
        y0      = 1;
        lGamma -= dM;
    }

// Undo our flips to get the start coordinate:

    x += x0;
    y += y0;

    if (fl & HW_FLIP_D)
    {
        register LONG lTmp;
        lTmp = x; x = y; y = lTmp;
    }

    if (fl & HW_FLIP_V)
    {
        y = -y;
    }

    if (fl & HW_FLIP_H)
    {
        x = -x;
    }

/***********************************************************************\
* Return the Bresenham terms:
\***********************************************************************/

    // iDir       = gaiDir[fl & HW_FLIP_MASK];
    // ptlStart.x = x;
    // ptlStart.y = y;
    // cPels      = x1 - x0 + 1;  // NOTE: You'll have to check if cPels <= 0!
    // dMajor     = dM;
    // dMinor     = dN;
    // lErrorTerm = lGamma;

/***********************************************************************\
* Draw the line.  S3 specific code follows:
\***********************************************************************/

    cPels = x1 - x0 + 1;
    if (cPels > 0)
    {
        pjMmBase = ppdev->pjMmBase;

        if (pjMmBase != NULL)
        {
            MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
            MM_LINE_PIX_CNT(ppdev, pjMmBase, cPels);
            MM_LINE_ERR_TERM(ppdev, pjMmBase, lGamma + dN);
            MM_K1_CONST(ppdev, pjMmBase, dN);
            MM_K2_CONST(ppdev, pjMmBase, dN - dM);
            MM_SIGN_CODES(ppdev, pjMmBase, (fl & HW_FLIP_MASK));
            MM_X0_Y0(ppdev, pjMmBase, x, y);
            MM_LINE_CMD(ppdev, pjMmBase, DEFAULT_LINE_CMD | LAST_PIXEL_NULL);
        }
        else
        {
            pjIoBase = ppdev->pjIoBase;

            IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
            IO_LINE_PIX_CNT(ppdev, pjIoBase, cPels);
            IO_LINE_ERR_TERM(ppdev, pjIoBase, lGamma + dN);
            IO_K1_CONST(ppdev, pjIoBase, dN);
            IO_K2_CONST(ppdev, pjIoBase, dN - dM);
            IO_SIGN_CODES(ppdev, pjIoBase, (fl & HW_FLIP_MASK));
            IO_X0_Y0(ppdev, pjIoBase, x, y);
            IO_LINE_CMD(ppdev, pjIoBase, DEFAULT_LINE_CMD | LAST_PIXEL_NULL);
        }
    }

    return(TRUE);
}

/*******************************Public*Table*******************************\
* gapfnStrip
*
* Look-up table for DrvStrokePath to find which strip routines to call.
*
\**************************************************************************/

VOID (*gapfnIoStrip[])(PDEV*, STRIP*, LINESTATE*) = {
    vIoStripSolidHorizontal,
    vIoStripSolidVertical,
    vIoStripSolidDiagonalHorizontal,
    vIoStripSolidDiagonalVertical,

    vIoStripStyledHorizontal,
    vIoStripStyledVertical,
    vIoStripStyledVertical,       // Diagonal goes here
    vIoStripStyledVertical,       // Diagonal goes here
};

VOID (*gapfnMmStrip[])(PDEV*, STRIP*, LINESTATE*) = {
    vMmStripSolidHorizontal,
    vMmStripSolidVertical,
    vMmStripSolidDiagonalHorizontal,
    vMmStripSolidDiagonalVertical,

    vMmStripStyledHorizontal,
    vMmStripStyledVertical,
    vMmStripStyledVertical,       // Diagonal goes here
    vMmStripStyledVertical,       // Diagonal goes here
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDEV*     ppdev;
    DSURF*    pdsurf;
    OH*       poh;
    RECTL     arclClip[4];                  // For rectangular clipping
    BYTE*     pjIoBase;
    BYTE*     pjMmBase;
    RECTL*    prclClip;
    ULONG     ulLinePattern;

    ASSERTDD(((mix >> 8) & 0xff) == (mix & 0xff),
             "GDI gave us an improper mix");

// Pass the surface off to GDI if it's a device bitmap that we've
// converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
    }

// We'll be drawing to the screen or an off-screen DFB; copy the surface's
// offset now so that we won't need to refer to the DSURF again:

    poh   = pdsurf->poh;
    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = poh->x;
    ppdev->yOffset = poh->y;

    pjIoBase      = ppdev->pjIoBase;
    pjMmBase      = ppdev->pjMmBase;
    prclClip      = NULL;
    fl            = 0;
    ulLinePattern = (ULONG) -1;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_STYLED;
        ls.ulStartMask = 0L;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_STYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    if (pco->iDComplexity == DC_RECT)
    {
        fl |= FL_SIMPLE_CLIP;

        arclClip[0]        =  pco->rclBounds;

    // FL_FLIP_D:

        arclClip[1].top    =  pco->rclBounds.left;
        arclClip[1].left   =  pco->rclBounds.top;
        arclClip[1].bottom =  pco->rclBounds.right;
        arclClip[1].right  =  pco->rclBounds.bottom;

    // FL_FLIP_V:

        arclClip[2].top    = -pco->rclBounds.bottom + 1;
        arclClip[2].left   =  pco->rclBounds.left;
        arclClip[2].bottom = -pco->rclBounds.top + 1;
        arclClip[2].right  =  pco->rclBounds.right;

    // FL_FLIP_V | FL_FLIP_D:

        arclClip[3].top    =  pco->rclBounds.left;
        arclClip[3].left   = -pco->rclBounds.bottom + 1;
        arclClip[3].bottom =  pco->rclBounds.right;
        arclClip[3].right  = -pco->rclBounds.top + 1;

        prclClip = arclClip;
    }

    if (ppdev->pjMmBase != NULL)
        apfn = &gapfnMmStrip[4 * ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];
    else
        apfn = &gapfnIoStrip[4 * ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

// Get the device ready:

    if (pjMmBase != NULL)
    {
        MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
        MM_FG_COLOR(ppdev, pjMmBase, pbo->iSolidColor);
        MM_CTRL_REG_1(ppdev, pjMmBase, EXPAND_TO_FG     |
                                       BITS_PER_PIX_8   |
                                       ENAB_TRITON_MODE);
        MM_LINE_PATTERN(ppdev, pjMmBase, ulLinePattern);
        MM_LINE_CMD(ppdev, pjMmBase, DEFAULT_LINE_CMD & ~START_LINE);
        if (mix == ((R2_COPYPEN << 8) | R2_COPYPEN))
        {
            MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_NO_ROPS      |
                                              PIXELMASK_AND_SRC_DATA |
                                              PLANARMASK_NONE_0XFF   |
                                              SRC_IS_LINE_PATTERN);
        }
        else
        {
            MM_ROP_A(ppdev, pjMmBase, (mix - 1));
            MM_DATAPATH_CTRL(ppdev, pjMmBase, ROPSELECT_ALL          |
                                              PIXELMASK_AND_SRC_DATA |
                                              PLANARMASK_NONE_0XFF   |
                                              SRC_IS_LINE_PATTERN);
        }
    }
    else
    {
        IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
        IO_FG_COLOR(ppdev, pjIoBase, pbo->iSolidColor);
        IO_CTRL_REG_1(ppdev, pjIoBase, EXPAND_TO_FG     |
                                       BITS_PER_PIX_8   |
                                       ENAB_TRITON_MODE);
        IO_LINE_PATTERN(ppdev, pjIoBase, ulLinePattern);
        IO_LINE_CMD(ppdev, pjIoBase, DEFAULT_LINE_CMD & ~START_LINE);
        if (mix == ((R2_COPYPEN << 8) | R2_COPYPEN))
        {
            IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_NO_ROPS      |
                                              PIXELMASK_AND_SRC_DATA |
                                              PLANARMASK_NONE_0XFF   |
                                              SRC_IS_LINE_PATTERN);
        }
        else
        {
            IO_ROP_A(ppdev, pjIoBase, (mix - 1));
            IO_DATAPATH_CTRL(ppdev, pjIoBase, ROPSELECT_ALL          |
                                              PIXELMASK_AND_SRC_DATA |
                                              PLANARMASK_NONE_0XFF   |
                                              SRC_IS_LINE_PATTERN);
        }
    }

// Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        PATHDATA  pd;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        pd.flags = 0;

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
                break;

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

        // Masked styles don't normalize the style state.  It's a good
        // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\rxhw.c ===
/******************************Module*Header*******************************\
* Module Name: rxhw.c
*
* This module contains all the implementation-dependent capabilities
* required by 'rxddi.c' that haven't been implemented in 'rxhw.h'.
*
* Copyright (c) 1994-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

ULONG DrvEscape(SURFOBJ *pso, ULONG iEsc,
                ULONG cjIn, VOID *pvIn,
                ULONG cjOut, VOID *pvOut)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) pso->dhpdev;

    if (ppdev->iBitmapFormat != BMF_8BPP)
    {
        // We support the RX escapes only at 8bpp, because that's the
        // only QVision mode we've accelerated for lines:

        return(0);
    }

    return(0);
}

BOOL DrvStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    return(0);
}

/******************************Public*Routine******************************\
* BOOL bEnableRx
*
\**************************************************************************/

BOOL bEnableRx(
PDEV*   ppdev)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableRx
*
\**************************************************************************/

VOID vDisableRx(
PDEV*   ppdev)
{

}

/******************************Public*Routine******************************\
* VOID vAssertModeRx
*
\**************************************************************************/

VOID vAssertModeRx(
PDEV*   ppdev,
BOOL    bEnable)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\strips.c ===
/******************************Module*Header*******************************\
* Module Name: Strips.c
*
* These are the line rendering routines of last resort, and are called
* by 'bLines' when a line is clipped or otherwise cannot be drawn
* directly by the hardware.
*
* Note that we don't take advantage in the strip routines of the QVision's
* capability for automatically starting when the Y1 register is written,
* because that requires different state from what is required for the
* integer line special case in 'bLines' -- and we want that integer line
* special case to be as fast as possible, at cost to these strip routines.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vIoStripSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID vIoStripSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjIoBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjIoBase = ppdev->pjIoBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
        IO_X0_Y0(ppdev, pjIoBase, x, y);
        x += *pStrips++;
        IO_X1_Y1(ppdev, pjIoBase, x - 1, y);
        y += yDir;
        IO_LINE_CMD(ppdev, pjIoBase, DEFAULT_LINE_CMD);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vIoStripSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vIoStripSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjIoBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjIoBase = ppdev->pjIoBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
        IO_X0_Y0(ppdev, pjIoBase, x, y);
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        IO_X1_Y1(ppdev, pjIoBase, x, y - yDir);
        x++;
        IO_LINE_CMD(ppdev, pjIoBase, DEFAULT_LINE_CMD);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vIoStripSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vIoStripSolidDiagonalHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjIoBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjIoBase = ppdev->pjIoBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
        IO_X0_Y0(ppdev, pjIoBase, x, y);
        x += *pStrips;
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        IO_X1_Y1(ppdev, pjIoBase, x - 1, y - yDir);
        y -= yDir;
        IO_LINE_CMD(ppdev, pjIoBase, DEFAULT_LINE_CMD);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vIoStripSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vIoStripSolidDiagonalVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjIoBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjIoBase = ppdev->pjIoBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
        IO_X0_Y0(ppdev, pjIoBase, x, y);
        x += *pStrips;
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        IO_X1_Y1(ppdev, pjIoBase, x - 1, y - yDir);
        x--;
        IO_LINE_CMD(ppdev, pjIoBase, DEFAULT_LINE_CMD);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vIoStripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vIoStripStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjIoBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjIoBase = ppdev->pjIoBase;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy = -1;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        // Short stroke vectors can handle lines that are a maximum of
        // 15 pels long.  When we have to draw a longer consecutive
        // segment than that, we simply break it into 16 pel portions:

        IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
        IO_X0_Y0(ppdev, pjIoBase, x, y);
        x += cThis;
        IO_X1_Y1(ppdev, pjIoBase, x - 1, y);
        IO_LINE_CMD(ppdev, pjIoBase, DEFAULT_LINE_CMD);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vIoStripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vIoStripStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjIoBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjIoBase = ppdev->pjIoBase;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dy = -1;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dy = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        IO_WAIT_FOR_IDLE(ppdev, pjIoBase);
        IO_X0_Y0(ppdev, pjIoBase, x, y);
        y += (dy > 0) ? cThis : -cThis;
        IO_X1_Y1(ppdev, pjIoBase, x, y - dy);
        IO_LINE_CMD(ppdev, pjIoBase, DEFAULT_LINE_CMD);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmStripSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID vMmStripSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjMmBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjMmBase = ppdev->pjMmBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
        MM_X0_Y0(ppdev, pjMmBase, x, y);
        x += *pStrips++;
        MM_X1_Y1(ppdev, pjMmBase, x - 1, y);
        y += yDir;
        MM_LINE_CMD(ppdev, pjMmBase, DEFAULT_LINE_CMD);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmStripSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vMmStripSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjMmBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjMmBase = ppdev->pjMmBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
        MM_X0_Y0(ppdev, pjMmBase, x, y);
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        MM_X1_Y1(ppdev, pjMmBase, x, y - yDir);
        x++;
        MM_LINE_CMD(ppdev, pjMmBase, DEFAULT_LINE_CMD);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmStripSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vMmStripSolidDiagonalHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjMmBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjMmBase = ppdev->pjMmBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
        MM_X0_Y0(ppdev, pjMmBase, x, y);
        x += *pStrips;
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        MM_X1_Y1(ppdev, pjMmBase, x - 1, y - yDir);
        y -= yDir;
        MM_LINE_CMD(ppdev, pjMmBase, DEFAULT_LINE_CMD);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmStripSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vMmStripSolidDiagonalVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjMmBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjMmBase = ppdev->pjMmBase;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
        MM_X0_Y0(ppdev, pjMmBase, x, y);
        x += *pStrips;
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        MM_X1_Y1(ppdev, pjMmBase, x - 1, y - yDir);
        x--;
        MM_LINE_CMD(ppdev, pjMmBase, DEFAULT_LINE_CMD);
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmStripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vMmStripStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjMmBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjMmBase = ppdev->pjMmBase;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy = -1;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        // Short stroke vectors can handle lines that are a maximum of
        // 15 pels long.  When we have to draw a longer consecutive
        // segment than that, we simply break it into 16 pel portions:

        MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
        MM_X0_Y0(ppdev, pjMmBase, x, y);
        x += cThis;
        MM_X1_Y1(ppdev, pjMmBase, x - 1, y);
        MM_LINE_CMD(ppdev, pjMmBase, DEFAULT_LINE_CMD);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vMmStripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vMmStripStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjMmBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjMmBase = ppdev->pjMmBase;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dy = -1;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dy = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        MM_WAIT_FOR_IDLE(ppdev, pjMmBase);
        MM_X0_Y0(ppdev, pjMmBase, x, y);
        y += (dy > 0) ? cThis : -cThis;
        MM_X1_Y1(ppdev, pjMmBase, x, y - dy);
        MM_LINE_CMD(ppdev, pjMmBase, DEFAULT_LINE_CMD);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\compaq.qv\disp\multi.c ===
/******************************Module*Header*******************************\
* Module Name: multi.c
*
* Supports multiple display boards as a single virtual desktop.
*
* This is implemented by presenting to GDI a single large virtual
* display and adding a layer between GDI and the driver's Drv functions.
* For the most part, the rest of the driver outside of multi.c doesn't
* have to change much, subject to the requirements below.
*
* This implementation requires that each board have the same virtual
* resolution and colour depth (e.g., all be running 1024x768x256), and
* that the boards be arranged in a rectangular configuration.
*
* Each board has its own PDEV, and completely manages its surface
* independently, down to glyph and bitmap caching.  The Mul
* routine intercepts the DDI call, and for each board dispatches
* a Drv call with the appropriate PDEV and clip object modifications.
*
* The following support in the main driver is required:
*
* 1) The driver should be able to handle a per-surface offset.  For
*    example, if two 1024x768 displays are pasted side-by-side, the
*    right board will get drawing operations in the range (1024, 768) -
*    (2048, 768).  The driver has a (-1024, 0) surface offset to convert
*    the actual drawing on the right board to the expected (0, 0) -
*    (1024, 768).
*
*    The current driver already uses this notion to support device-format
*    bitmaps drawn in off-screen memory.
*
*    Another option would be to handle the surface offsets in this layer,
*    but then all parameters including clip objects, paths and glyph
*    enumerations would have to be adjusted here as well.
*
* 2) The main driver must be able to share realized pattern information
*    between board instances.  That is, with the current DDI specification
*    GDI entirely handles brush memory allocation via pvAllocRBrush,
*    and the driver doesn't get notified when the brush is destroyed, so
*    the driver has to keep all information about the brush for all the
*    boards in the one brush realization.  This isn't too onerous.
*
* Problems:
*
* 1) DrvSetPointerShape requires that support be consistent between all
*    board instances -- for example, one board instance cannot accept
*    a h/w cursor and the other fail it, because GDI doesn't know it would
*    have to simulate on one area of the screen and not the other.
*
* 2) CompatibleBitmaps would have to be shared between board instances.
*    This becomes a problem when the bitmaps are kept by the driver in off-
*    screen memory.
*
* Status:
*
*    This code is officially untested.  However, I know of no outstanding
*    bugs -- everything seems to just work.
*
*    Note that I haven't addressed any initialization issues; to adapt this
*    code, you will need to solve some of those problems (such as proper
*    miniport support, and a nice method for the user to control the board
*    configurations and geometry).
*
* Disclaimer:
*
*    This code is provided as sample code only.  It is not intended to
*    represent Microsoft's endorsed solution for multiple screen support.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#if MULTI_BOARDS

// We change the active board to the home board after every drawing
// operation.  We do this only because the Metheus BIOS does not reset
// the active board on a soft-reset, and so the initial POST text
// would come up on whatever happened to be the last board drawn to.

#define GO_HOME(pmdev)       vSelectBoard(pmdev, pmdev->pmbHome)
#define GO_BOARD(pmdev, pmb) vSelectBoard(pmdev, pmb)

struct _MULTI_BOARD;

typedef struct _MULTI_BOARD MULTI_BOARD;    /* mb */

struct _MULTI_BOARD
{
    LONG            iHwBoard;       // Hardware board number
    LONG            iBoard;         // Sequentially allocated board number
    RECTL           rcl;            // Board's coordinates
    MULTI_BOARD*    pmbNext;        // For traversing the entire list of boards
    MULTI_BOARD*    pmbLeft;        // For traversing by direction
    MULTI_BOARD*    pmbUp;
    MULTI_BOARD*    pmbRight;
    MULTI_BOARD*    pmbDown;

    PDEV*           ppdev;          // Pointer to the board's PDEV
    SURFOBJ*        pso;            // Surface representing the board
    HSURF           hsurf;          // Handle to surface
};                                          /* mb, pmb */

typedef struct _MDEV
{
    MULTI_BOARD*    pmb;            // Where to start enumerating
    MULTI_BOARD*    pmbHome;        // Board used for full-screen
    MULTI_BOARD*    pmbUpperLeft;   // Board in upper-left corner
    MULTI_BOARD*    pmbUpperRight;
    MULTI_BOARD*    pmbLowerLeft;
    MULTI_BOARD*    pmbLowerRight;
    LONG            cxBoards;       // Number of boards per row
    LONG            cyBoards;       // Number of boards per column
    LONG            cBoards;        // Total number of boards

    MULTI_BOARD*    pmbPointer;     // Board where cursor is currently visible
    MULTI_BOARD*    pmbCurrent;     // Currently selected board (needed for
                                    //   DrvRealizeBrush)
    HDEV            hdev;           // Handle that GDI knows us by
    HSURF           hsurf;          // Handle to our virtual surface
    CLIPOBJ*        pco;            // A temporary CLIPOBJ that we can modify
    ULONG           iBitmapFormat;  // Current colour depth
    FLONG           flHooks;        // Those functions that the main driver
                                    //   is hooking

} MDEV;                                     /* mdev, pmdev */

typedef struct _PVCONSUMER
{
    PVOID       pvConsumer;
} PVCONSUMER;

typedef struct _FONT_CONSUMER
{
    LONG        cConsumers;         // Total number of boards
    PVCONSUMER  apvc[MAX_BOARDS];   // Array of structures cConsumers in length
} FONT_CONSUMER;                            /* fc, pfc */

typedef struct _BITBLTDATA
{
    RECTL       rclBounds;
    MDEV*       pmdev;

    SURFOBJ*    psoDst;
    SURFOBJ*    psoSrc;
    SURFOBJ*    psoMask;
    CLIPOBJ*    pco;
    XLATEOBJ*   pxlo;
    RECTL*      prclDst;
    POINTL*     pptlSrc;
    POINTL*     pptlMask;
    BRUSHOBJ*   pbo;
    POINTL*     pptlBrush;
    ROP4        rop4;
} BITBLTDATA;                               /* bb, pbb */

/******************************Public*Routine******************************\
* bFindBoard
*
* Returns in ppmb a pointer to the board containing the upper-left
* corner of prcl.
*
* Returns TRUE if prcl is entirely containing on one board; FALSE if
* prcl spans multiple boards.
*
\**************************************************************************/

BOOL bFindBoard(MDEV* pmdev, RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = pmdev->pmbUpperLeft;

    // It should never happen that GDI will give us a call whose bounds
    // don't intersect the virtual screen.  But so that we don't crash
    // should it ever happen, we'll return an intersection with the first
    // board -- we can assume GDI at least said the clipping was non-
    // trivial, in which case that board's display routine will realize
    // nothing had to be done:

    *ppmb = pmb;

    // First find the row:

    while (prcl->top >= pmb->rcl.bottom)
    {
        pmb = pmb->pmbDown;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // Now find the column:

    while (prcl->left >= pmb->rcl.right)
    {
        pmb = pmb->pmbRight;
        if (pmb == NULL)
            return(FALSE);      // This is a case where the bounds doesn't
                                //  intercept the virtual screen
    }

    // So we found the first board:

    *ppmb = pmb;

    return(prcl->right  <= pmb->rcl.right &&
           prcl->bottom <= pmb->rcl.bottom);
}

/******************************Public*Routine******************************\
* bNextBoard
*
* Returns in ppmb a pointer to the next board after intersecting prcl, going
* left-to-right then top-to-bottom.
*
* Returns TRUE if all boards intersecting prcl have been enumerated; FALSE
* if there are more boards.
*
\**************************************************************************/

BOOL bNextBoard(RECTL* prcl, MULTI_BOARD** ppmb)
{
    MULTI_BOARD* pmb;

    pmb = *ppmb;

    // We'll do all the boards in a row first, remembering that the
    // bounds rectangle can extend past the end of our virtual screen:

    if ((prcl->right > pmb->rcl.right) && (pmb->pmbRight != NULL))
    {
        *ppmb = pmb->pmbRight;
        return(TRUE);
    }

    // Go to next row if need be, starting at the rcl.left:

    if ((prcl->bottom > pmb->rcl.bottom) && (pmb->pmbDown != NULL))
    {
        pmb = pmb->pmbDown;
        while ((prcl->left < pmb->rcl.left) && (pmb->pmbLeft != NULL))
        {
            pmb = pmb->pmbLeft;
        }
        *ppmb = pmb;
        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* vIntersect
*
* Returns in prclOut the intersection of rectangles prcl1 and prcl2.
*
\**************************************************************************/

VOID vIntersect(RECTL* prcl1, RECTL* prcl2, RECTL* prclOut)
{
    prclOut->left   = max(prcl1->left,   prcl2->left);
    prclOut->top    = max(prcl1->top,    prcl2->top);
    prclOut->right  = min(prcl1->right,  prcl2->right);
    prclOut->bottom = min(prcl1->bottom, prcl2->bottom);
}

/******************************Public*Routine******************************\
* bVeryTemporaryInitializationCode
*
\**************************************************************************/

BOOL bVeryTemporaryInitializationCode(MDEV* pmdev)
{
    MULTI_BOARD* pmb1 = NULL;
    MULTI_BOARD* pmb2 = NULL;

    pmb1 = EngAllocMem(FL_ZERO_MEMORY, sizeof(MULTI_BOARD), ALLOC_TAG);
    pmb2 = EngAllocMem(FL_ZERO_MEMORY, sizeof(MULTI_BOARD), ALLOC_TAG);

    if ((pmb1 == NULL) || (pmb2 == NULL))
    {
        EngFreeMem(pmb1);
        EngFreeMem(pmb2);
        return(FALSE);
    }

    // Only this initialization part is hard-coded to have two monitors,
    // side-by-side.

    // Board one:

    pmb1->iHwBoard         = 0;
    pmb1->iBoard           = 0;
    pmb1->pmbNext          = pmb2;
    pmb1->pmbRight         = pmb2;

    pmdev->pmb             = pmb1;
    pmdev->pmbUpperLeft    = pmb1;
    pmdev->pmbLowerLeft    = pmb1;
    pmdev->pmbHome         = pmb1;

    // Board two:

    pmb2->iHwBoard         = 1;
    pmb2->iBoard           = 1;
    pmb2->pmbLeft          = pmb1;

    pmdev->pmbUpperRight   = pmb2;
    pmdev->pmbLowerRight   = pmb2;

    pmdev->cxBoards        = 2;
    pmdev->cyBoards        = 1;
    pmdev->cBoards         = 2;

    // Assume that the currently active board is the 'home' board:

    pmdev->pmbCurrent      = pmdev->pmbHome;

    return(TRUE);
}

/******************************Public*Routine******************************\
* vSelectBoard
*
* Selects board pmb for drawing.  We can have only one Metheus board active
* at any time, so we have to disable the old board before enabling the new.
*
* Obviously, your hardware implementation may not require this entire
* function.  For example, you probably won't have to do this if you can
* have each board's accelerator registers mapped into separate address
* spaces.  NOTE: You'll still have to set pmdev->pmbCurrent, however,
* for DrvRealizeBrush to work!
*
\**************************************************************************/

VOID vSelectBoard(MDEV* pmdev, MULTI_BOARD* pmb)
{
    LONG iOldHwBoard;

    ASSERTDD(pmdev->pmbCurrent != NULL, "Can't have NULL pmbCurrent");

    // LATER: Expand this to handle more than 8 Metheus boards.

    iOldHwBoard = pmdev->pmbCurrent->iHwBoard;
    if (pmb->iHwBoard != iOldHwBoard)
    {
        OUTP(0x220, iOldHwBoard);           // Disable old board
        OUTP(0x220, (8 | pmb->iHwBoard));   // Enable new one
        pmdev->pmbCurrent = pmb;            // Remember new board
    }

}

/******************************Public*Routine******************************\
* bBoardCopy
*
* Given the BitBlt parameters in pbb, bitblt's the part of the rectangle
* on the pmbSrc board that must bitblt'ed to the pmbDst board.  Bails
* out quickly if nothing actually has to be copied.
*
* Will do a screen-to-screen blt if pmbSrc and pmbDst are the same board;
* otherwise it uses the psoTmp bitmap as temporary storage for transferring
* between the two boards.
*
* NOTE: If your hardware allows you to have all the frame buffers mapped
*       into memory simultaneously, you can avoid the 'psoTmp' bitmap
*       allocation and extra copy!
*
\**************************************************************************/

BOOL bBoardCopy(
BITBLTDATA*  pbb,
SURFOBJ*     psoTmp,
MULTI_BOARD* pmbDst,
MULTI_BOARD* pmbSrc)
{
    BOOL     b;
    RECTL    rclDst;
    LONG     dx;
    LONG     dy;
    RECTL    rclTmp;
    POINTL   ptlSrc;

    // If there's really no source board, we're guaranteed not to
    // have to copy anything from it:

    if (pmbSrc == NULL)
        return(TRUE);

    dx = pbb->prclDst->left - pbb->pptlSrc->x;
    dy = pbb->prclDst->top  - pbb->pptlSrc->y;

    // Pretend we're going to copy the entire source board's screen.
    // rclDst would be the destination rectangle:

    rclDst.left   = pmbSrc->rcl.left   + dx;
    rclDst.right  = pmbSrc->rcl.right  + dx;
    rclDst.top    = pmbSrc->rcl.top    + dy;
    rclDst.bottom = pmbSrc->rcl.bottom + dy;

    // We really want to copy only the part that overlaps the
    // destination board's screen:

    vIntersect(&pmbDst->rcl, &rclDst, &rclDst);

    // Plus we really only want to copy anything to what is contained
    // in the original destination rectangle:

    vIntersect(&pbb->rclBounds, &rclDst, &rclDst);

    // rclDst is now the destination rectangle for our call.  We'll
    // need a temporary bitmap for copying, so compute its extents:

    rclTmp.left   = 0;
    rclTmp.top    = 0;
    rclTmp.right  = rclDst.right  - rclDst.left;
    rclTmp.bottom = rclDst.bottom - rclDst.top;

    // If it's empty, we're outta here:

    if ((rclTmp.right <= 0) || (rclTmp.bottom <= 0))
        return(TRUE);

    if (pmbDst == pmbSrc)
    {
        // If the source and destination are the same board, we don't
        // need a temporary bitmap:

        psoTmp = pmbSrc->pso;
        ptlSrc = *pbb->pptlSrc;
    }
    else
    {
        ASSERTDD(psoTmp != NULL, "Need non-null bitmap");
        ASSERTDD(psoTmp->sizlBitmap.cx >= rclTmp.right, "Bitmap too small in x");
        ASSERTDD(psoTmp->sizlBitmap.cy >= rclTmp.bottom, "Bitmap too small in y");

        // Figure out the upper-left source corner corresponding to our
        // upper-left destination corner:

        ptlSrc.x = rclDst.left - dx;
        ptlSrc.y = rclDst.top  - dy;

        // Copy the rectangle from the source to the temporary bitmap:

        GO_BOARD(pbb->pmdev, pmbSrc);
        b = DrvCopyBits(psoTmp, pmbSrc->pso, NULL, NULL, &rclTmp, &ptlSrc);

        // Then get ready to do the copy from the temporary bitmap to
        // the destination:

        ptlSrc.x = pbb->prclDst->left - rclDst.left;
        ptlSrc.y = pbb->prclDst->top  - rclDst.top;
    }

    pbb->pco->rclBounds = rclDst;
    GO_BOARD(pbb->pmdev, pmbDst);
    b &= DrvBitBlt(pmbDst->pso, psoTmp, pbb->psoMask, pbb->pco, pbb->pxlo,
                   pbb->prclDst, &ptlSrc, pbb->pptlMask, pbb->pbo,
                   pbb->pptlBrush, pbb->rop4);

    return(b);
}

/******************************Public*Routine******************************\
* bBitBltBetweenBoards
*
* Handles screen-to-screen blts across multiple boards.
*
\**************************************************************************/

BOOL bBitBltBetweenBoards(
SURFOBJ*     psoDst,
SURFOBJ*     psoSrc,
SURFOBJ*     psoMask,
CLIPOBJ*     pco,
XLATEOBJ*    pxlo,
RECTL*       prclDst,
POINTL*      pptlSrc,
POINTL*      pptlMask,
BRUSHOBJ*    pbo,
POINTL*      pptlBrush,
ROP4         rop4,
RECTL*       prclUnion,     // Rectangular union of source and destination
MULTI_BOARD* pmbUnion)      // Board containing upper-left corner of prclUnion
{
    BOOL         b = TRUE;
    BITBLTDATA   bb;
    RECTL        rclOriginalBounds;
    SIZEL        sizlBoard;
    SIZEL        sizlDst;
    SIZEL        sizl;
    MULTI_BOARD* pmbSrc;
    MULTI_BOARD* pmbDst;
    LONG         dx;
    LONG         dy;
    RECTL        rclStart;

    SURFOBJ*     pso0 = NULL;   // Initialize these first off in case we
    SURFOBJ*     pso1 = NULL;   //   early-out
    SURFOBJ*     pso2 = NULL;
    SURFOBJ*     pso3 = NULL;
    HSURF        hsurf0 = 0;
    HSURF        hsurf1 = 0;

    bb.pmdev     = (MDEV*) psoDst->dhpdev;
    bb.psoDst    = psoDst;
    bb.psoSrc    = psoSrc;
    bb.psoMask   = psoMask;
    bb.pxlo      = pxlo;
    bb.prclDst   = prclDst;
    bb.pptlSrc   = pptlSrc;
    bb.pptlMask  = pptlMask;
    bb.pbo       = pbo;
    bb.pptlBrush = pptlBrush;
    bb.rop4      = rop4;
    bb.pco       = pco;
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        bb.pco = bb.pmdev->pco;

    vIntersect(&bb.pco->rclBounds, prclDst, &bb.rclBounds);
    rclOriginalBounds = bb.pco->rclBounds;

    sizlDst.cx = bb.rclBounds.right - bb.rclBounds.left;
    sizlDst.cy = bb.rclBounds.bottom - bb.rclBounds.top;

    // This really should never happen, but we'll be paranoid:

    if ((sizlDst.cx <= 0) || (sizlDst.cy <= 0))
        return(TRUE);

    // Compute delta from source to destination:

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    // Figure out the size of a board:

    sizlBoard.cx = bb.pmdev->pmbUpperLeft->rcl.right;
    sizlBoard.cy = bb.pmdev->pmbUpperLeft->rcl.bottom;

    // We use temporary bitmaps as intermediaries for copying from one
    // board to another.  Note that it is much more efficient to allocate
    // on the fly, rather than keeping a dedicated bitmap around that
    // would have to be swapped in and out.

    // When the destination is close to the source, we can accomplish
    // most of the blt using screen-to-screen copies, and will need
    // only two small temporary bitmaps to temporarily hold the bits
    // that must be transferred from one board to another:

    if ((abs(dx) < (sizlBoard.cx >> 1)) && (abs(dy) < (sizlBoard.cy >> 1)))
    {
        // Create a temporary bitmap for the horizontal delta only if
        // the blt actually spans boards in the x-direction:

        if ((dx != 0) && (prclUnion->right > pmbUnion->rcl.right))
        {
            sizl.cx = min(sizlDst.cx, abs(dx));
            sizl.cy = min(sizlDst.cy, sizlBoard.cy - abs(dy));

            hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso1 = EngLockSurface(hsurf0);
            if (pso1 == NULL)
                return(FALSE);

            // Can use same temporary bitmap for section '3':

            pso3 = pso1;
        }

        // Similarly for the vertical delta:

        if ((dy != 0) && (prclUnion->bottom > pmbUnion->rcl.bottom))
        {
            sizl.cx = min(sizlDst.cx, sizlBoard.cx - abs(dx));
            sizl.cy = min(sizlDst.cy, abs(dy));

            hsurf1 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso2 = EngLockSurface(hsurf1);
            if (pso2 == NULL)
            {
                b = FALSE;
                goto OuttaHere;
            }
        }
    }
    else
    {
        // Make the bitmap the size of a board, or the size of the
        // destination rectangle, which ever is smaller:

        sizl.cx = min(sizlDst.cx, sizlBoard.cx);
        sizl.cy = min(sizlDst.cy, sizlBoard.cy);

        hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                         0, NULL);
        pso0 = EngLockSurface(hsurf0);
        if (pso0 == NULL)
            return(FALSE);

        pso1 = pso0;
        pso2 = pso0;
        pso3 = pso0;
    }

    if ((dx <= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the left:

        // Find the board containing the upper-left corner of the destination:

        pmbDst = bb.pmdev->pmbUpperLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left = pmbDst->rcl.left - dx;
        rclStart.top  = pmbDst->rcl.top  - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to left side of next lower row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else if ((dx >= 0) && (dy >= 0))
    {
        // Move the rectangle down and to the right:

        // Find the board containing the lower-right corner of the destination:

        pmbDst = bb.pmdev->pmbLowerRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to go up to right side of next upper row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }
    else if ((dx >= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the right:

        // Find the board containing the upper-right corner of the destination:

        pmbDst = bb.pmdev->pmbUpperRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.top   = pmbDst->rcl.top   - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to right side of next lower row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else
    {
        // Move the rectangle down and to the left:

        // Find the board containing the lower-left corner of the destination:

        pmbDst = bb.pmdev->pmbLowerLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left   = pmbDst->rcl.left   - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to up down to left side of next upper row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }

    GO_HOME(bb.pmdev);
    bb.pco->rclBounds = rclOriginalBounds;

OuttaHere:

    // In one case, pso0 == pso1 == pso2 == pso3, and we don't want to
    // unlock the same surface twice:

    if (pso1 != pso2)
        EngUnlockSurface(pso1);

    EngUnlockSurface(pso2);
    EngDeleteSurface(hsurf0);
    EngDeleteSurface(hsurf1);

    return(b);
}

/******************************Public*Routine******************************\
* MulGetModes
*
\**************************************************************************/

ULONG MulGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG ulRet;

    ulRet = DrvGetModes(hDriver, cjSize, pdm);

    return(ulRet);
}

/******************************Public*Routine******************************\
* MulEnablePDEV
*
\**************************************************************************/

DHPDEV MulEnablePDEV(
DEVMODEW* pDevmode,
PWSTR     pwszLogAddress,
ULONG     cPatterns,
HSURF*    ahsurfPatterns,
ULONG     cjGdiInfo,
ULONG*    pGdiInfo,
ULONG     cjDevInfo,
DEVINFO*  pDevInfo,
HDEV      hdev,
PWSTR     pwszDeviceName,
HANDLE    hDriver)
{
    MDEV*        pmdev;                // Multi-board PDEV
    PDEV*        ppdev;                // Per-board PDEV
    MULTI_BOARD* pmb;
    LONG         cx;
    LONG         cy;

    // Note that we depend on the zero initialization:

    pmdev = (MDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(MDEV), ALLOC_TAG);
    if (pmdev == NULL)
        goto ReturnFailure0;

    if (!bVeryTemporaryInitializationCode(pmdev))
        goto ReturnFailure1;

    // For every board, we'll create our own PDEV and surface:

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // Initialize each board and create a surface to go with it:

        ppdev = (PDEV*) DrvEnablePDEV(pDevmode,     pwszLogAddress,
                                      cPatterns,    ahsurfPatterns,
                                      cjGdiInfo,    pGdiInfo,
                                      cjDevInfo,    pDevInfo,
                                      hdev,         pwszDeviceName,
                                      hDriver);
        if (ppdev == NULL)
            goto ReturnFailure1;

        pmb->ppdev = ppdev;
    }

    // Choose a board, any board:

    pmb = pmdev->pmbLowerLeft;

    // Get a copy of what functions we're supposed to hook, sans
    // HOOK_STRETCHBLT because I can't be bothered to write its
    // MulStretchBlt function:

    pmdev->flHooks       = pmb->ppdev->flHooks & ~HOOK_STRETCHBLT;
    pmdev->iBitmapFormat = pmb->ppdev->iBitmapFormat;

    // As part of our hard-coded initialization hack, we will simply
    // take whatever resolution was requested via the Control Panel
    // and create a two board virtual desktop, where the screens are
    // side-by-side.
    //
    // The DrvEnablePDEV function for any board has already figured
    // out what the requested mode was:

    cx = ((GDIINFO*) pGdiInfo)->ulHorzRes;
    cy = ((GDIINFO*) pGdiInfo)->ulVertRes;

    // Set up bounds for left board:

    pmb->rcl.left       = 0;
    pmb->rcl.top        = 0;
    pmb->rcl.right      = cx;
    pmb->rcl.bottom     = cy;

    // Set up bounds for right board:

    pmb = pmb->pmbRight;

    pmb->rcl.left       = cx;
    pmb->rcl.top        = 0;
    pmb->rcl.right      = 2 * cx;
    pmb->rcl.bottom     = cy;

    // Adjust the stuff we return back to GDI:

    //((GDIINFO*) pGdiInfo)->ulDesktopHorzRes  *= 2;
    // ((GDIINFO*) pGdiInfo)->ulHorzSize        *= 2;

    // With the Metheus board, since only one board can be mapped in
    // at one time, we cannot allow asynchronous pointers:

    pDevInfo->flGraphicsCaps &= ~(GCAPS_ASYNCMOVE | GCAPS_ASYNCCHANGE);

    return((DHPDEV) pmdev);

ReturnFailure1:
    MulDisablePDEV((DHPDEV) pmdev);

ReturnFailure0:
    DISPDBG((0, "Failed MulEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* MulCompletePDEV
*
\**************************************************************************/

VOID MulCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    pmdev = (MDEV*) dhpdev;
    pmdev->hdev = hdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);
        DrvCompletePDEV((DHPDEV) pmb->ppdev, hdev);
    }
}

/******************************Public*Routine******************************\
* MulEnableSurface
*
\**************************************************************************/

HSURF MulEnableSurface(DHPDEV dhpdev)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;
    SIZEL         sizlVirtual;
    HSURF         hsurfBoard;               // Gnarly, dude!
    SURFOBJ*      psoBoard;
    DSURF*        pdsurfBoard;
    HSURF         hsurfVirtual;
    CLIPOBJ*      pco;

    pmdev = (MDEV*) dhpdev;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        hsurfBoard = DrvEnableSurface((DHPDEV) pmb->ppdev);
        if (hsurfBoard == 0)
            goto ReturnFailure;

        pmb->hsurf = hsurfBoard;

        // Every time we draw on a particular board, we'll refer to it
        // using this surface:

        psoBoard = EngLockSurface(hsurfBoard);
        if (psoBoard == NULL)
            goto ReturnFailure;

        pmb->pso = psoBoard;

        // There are a few things in the board's data instances that we
        // have to modify:

        pdsurfBoard = (DSURF*) psoBoard->dhsurf;

        pmb->ppdev->iBoard  =  pmb->iBoard;
        pdsurfBoard->poh->x = -pmb->rcl.left;
        pdsurfBoard->poh->y = -pmb->rcl.top;

        // This is sort of a hack.  Whenever we pass a call on to a board's
        // Drv function using 'pmb->pso', it has to be able to retrieve
        // it's own PDEV pointer from 'dhpdev':

        pmb->pso->dhpdev = (DHPDEV) pmb->ppdev;
    }

    // Now create the surface which the engine will use to refer to our
    // entire multi-board virtual screen:

    sizlVirtual.cx = pmdev->pmbLowerRight->rcl.right;
    sizlVirtual.cy = pmdev->pmbLowerRight->rcl.bottom;

    hsurfVirtual = EngCreateDeviceSurface((DHSURF) pmdev, sizlVirtual,
                                          pmdev->iBitmapFormat);
    if (hsurfVirtual == 0)
        goto ReturnFailure;

    pmdev->hsurf = hsurfVirtual;

    if (!EngAssociateSurface(hsurfVirtual, pmdev->hdev, pmdev->flHooks))
        goto ReturnFailure;

    // Create a temporary clip object that we can use when a drawing
    // operation spans multiple boards:

    pco = EngCreateClip();
    if (pco == NULL)
        goto ReturnFailure;

    pmdev->pco = pco;

    pmdev->pco->iDComplexity      = DC_RECT;
    pmdev->pco->iMode             = TC_RECTANGLES;
    pmdev->pco->rclBounds.left    = 0;
    pmdev->pco->rclBounds.top     = 0;
    pmdev->pco->rclBounds.right   = pmdev->pmbLowerRight->rcl.right;
    pmdev->pco->rclBounds.bottom  = pmdev->pmbLowerRight->rcl.bottom;

    return(hsurfVirtual);

ReturnFailure:
    MulDisableSurface((DHPDEV) pmdev);

    DISPDBG((0, "Failed MulEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* MulStrokePath
*
\**************************************************************************/

BOOL MulStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;
    FLOAT_LONG   elStyleState;

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;
        elStyleState = pla->elStyleState;

        b = TRUE;
        do {
            // For each board, make sure the style state gets reset and
            // the path enumeration gets restarted:

            pla->elStyleState = elStyleState;
            PATHOBJ_vEnumStart(ppo);

            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla,
                                   mix);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulFillPath
*
\**************************************************************************/

BOOL MulFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix,
FLONG     flOptions)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            // Make sure we restart the path enumeration if need be:

            PATHOBJ_vEnumStart(ppo);
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix,
                                 flOptions);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    GO_HOME(pmdev);

    return(b);
}

/******************************Public*Routine******************************\
* MulBitBlt
*
\**************************************************************************/

BOOL MulBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    LONG         xOffset;
    LONG         yOffset;
    RECTL        rclDstBounds;
    RECTL        rclDst;

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            return(bBitBltBetweenBoards(psoDst, psoSrc, psoMask, pco, pxlo,
                                        &rclDst, pptlSrc, pptlMask, pbo,
                                        pptlBrush, rop4, &rclBounds, pmb));
        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoSrc->dhpdev;

        // rclBounds is the source rectangle:

        rclBounds.left   = pptlSrc->x;
        rclBounds.top    = pptlSrc->y;
        rclBounds.right  = pptlSrc->x + (rclDst.right - rclDst.left);
        rclBounds.bottom = pptlSrc->y + (rclDst.bottom - rclDst.top);

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            // Offset to transform from source rectangle to destination
            // rectangle:

            xOffset = rclDst.left - pptlSrc->x;
            yOffset = rclDst.top  - pptlSrc->y;

            b = TRUE;
            do {
                // Since the screen is the source, but the clip bounds applies
                // to the destination, we have to convert our board clipping
                // information to destination coordinates:

                rclDstBounds.left   = pmb->rcl.left   + xOffset;
                rclDstBounds.right  = pmb->rcl.right  + xOffset;
                rclDstBounds.top    = pmb->rcl.top    + yOffset;
                rclDstBounds.bottom = pmb->rcl.bottom + yOffset;

                if (bIntersect(&rclOriginalBounds, &rclDstBounds, &pco->rclBounds))
             