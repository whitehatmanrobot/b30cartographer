io, 
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 00000001-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_PCM 
EXTERN_GUID(WMMEDIASUBTYPE_PCM, 
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000009-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_DRM 
EXTERN_GUID(WMMEDIASUBTYPE_DRM, 
0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV8 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV8, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV7 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV7, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV2 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV2, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000130-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_ACELPnet 
EXTERN_GUID(WMMEDIASUBTYPE_ACELPnet, 
0x00000130, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == WMMEDIATYPE_Script 
EXTERN_GUID(WMMEDIATYPE_Script, 
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 34A50FD8-8AA5-4386-81FE-A0EFE0488E31  'imag' == WMMEDIATYPE_Image 
EXTERN_GUID(WMMEDIATYPE_Image, 
0x34a50fd8, 0x8aa5, 0x4386, 0x81, 0xfe, 0xa0, 0xef, 0xe0, 0x48, 0x8e, 0x31); 
// D9E47579-930E-4427-ADFC-AD80F290E470  'fxfr' == WMMEDIATYPE_FileTransfer 
EXTERN_GUID(WMMEDIATYPE_FileTransfer, 
0xd9e47579, 0x930e, 0x4427, 0xad, 0xfc, 0xad, 0x80, 0xf2, 0x90, 0xe4, 0x70); 
// 05589f80-c356-11ce-bf01-00aa0055595a        WMFORMAT_VideoInfo 
EXTERN_GUID(WMFORMAT_VideoInfo, 
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// e06d80e3-db46-11cf-b4d1-00805f6cbbea        WMFORMAT_MPEG2Video 
EXTERN_GUID(WMFORMAT_MPEG2Video, 
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea); 
// 05589f81-c356-11ce-bf01-00aa0055595a        WMFORMAT_WaveFormatEx 
EXTERN_GUID(WMFORMAT_WaveFormatEx, 
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// 5C8510F2-DEBE-4ca7-BBA5-F07A104F8DFF        WMFORMAT_Script 
EXTERN_GUID(WMFORMAT_Script, 
0x5c8510f2, 0xdebe, 0x4ca7, 0xbb, 0xa5, 0xf0, 0x7a, 0x10, 0x4f, 0x8d, 0xff); 
// 82f38a70-c29f-11d1-97ad-00a0c95ea850        WMSCRIPTTYPE_TwoStrings 
EXTERN_GUID( WMSCRIPTTYPE_TwoStrings, 
0x82f38a70,0xc29f,0x11d1,0x97,0xad,0x00,0xa0,0xc9,0x5e,0xa8,0x50); 
// 0000000A-0000-0010-8000-00AA00389B71        WMMEDIASUBTYPE_WMSP1 
EXTERN_GUID( WMMEDIASUBTYPE_WMSP1, 
0x0000000A,0x0000,0x0010,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71); 
EXTERN_GUID( IID_IWMMediaProps,         0x96406bce,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMVideoMediaProps,    0x96406bcf,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriter,             0x96406bd4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMInputMediaProps,    0x96406bd5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReader,             0x96406bd6,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMSyncReader,         0x9397f121,0x7705,0x4dc9,0xb0,0x49,0x98,0xb6,0x98,0x18,0x84,0x14 );
EXTERN_GUID( IID_IWMOutputMediaProps,   0x96406bd7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStatusCallback,     0x6d7cdc70,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMReaderCallback,     0x96406bd8,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMCredentialCallback, 0x342e0eb7,0xe651,0x450c,0x97,0x5b,0x2a,0xce,0x2c,0x90,0xc4,0x8e );
EXTERN_GUID( IID_IWMMetadataEditor,     0x96406bd9,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMMetadataEditor2,    0x203cffe3,0x2e18,0x4fdf,0xb5,0x9d,0x6e,0x71,0x53,0x05,0x34,0xcf );
EXTERN_GUID( IID_IWMHeaderInfo,         0x96406bda,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMHeaderInfo2,        0x15cf9781,0x454e,0x482e,0xb3,0x93,0x85,0xfa,0xe4,0x87,0xa8,0x10 );
EXTERN_GUID( IID_IWMHeaderInfo3,        0xe67103a5,0xfd4b,0x4be7,0x91,0x82,0x77,0x2b,0x6a,0x6d,0xd3,0x8d );
EXTERN_GUID( IID_IWMProfileManager,     0xd16679f2,0x6ca0,0x472d,0x8d,0x31,0x2f,0x5d,0x55,0xae,0xe1,0x55 );
EXTERN_GUID( IID_IWMProfileManager2,    0x7a924e51,0x73c1,0x494d,0x80,0x19,0x23,0xd3,0x7e,0xd9,0xb8,0x9a );
EXTERN_GUID( IID_IWMProfile,            0x96406bdb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMProfile2,           0x07e72d33,0xd94e,0x4be7,0x88,0x43,0x60,0xae,0x5f,0xf7,0xe5,0xf5 );
EXTERN_GUID( IID_IWMProfile3,           0x00ef96cc,0xa461,0x4546,0x8b,0xcd,0xc9,0xa2,0x8f,0x0e,0x06,0xf5 );
EXTERN_GUID( IID_IWMStreamConfig,       0x96406bdc,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStreamConfig2,      0x7688d8cb,0xfc0d,0x43bd,0x94,0x59,0x5a,0x8d,0xec,0x20,0x0c,0xfa );
EXTERN_GUID( IID_IWMStreamList,         0x96406bdd,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMMutualExclusion,    0x96406bde,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMMutualExclusion2,   0x302b57d,0x89d1,0x4ba2,0x85,0xc9,0x16,0x6f,0x2c,0x53,0xeb,0x91 );
EXTERN_GUID( IID_IWMBandwidthSharing,   0xad694af1,0xf8d9,0x42f8,0xbc,0x47,0x70,0x31,0x1b,0x0c,0x4f,0x9e );
EXTERN_GUID( IID_IWMStreamPrioritization, 0x8c1c6090,0xf9a8,0x4748,0x8e,0xc3,0xdd,0x11,0x08,0xba,0x1e,0x77 );
EXTERN_GUID( IID_IWMWriterAdvanced,     0x96406be3,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterAdvanced2,    0x962dc1ec,0xc046,0x4db8,0x9c,0xc7,0x26,0xce,0xae,0x50,0x08,0x17 );
EXTERN_GUID( IID_IWMWriterAdvanced3,    0x2cd6492d,0x7c37,0x4e76,0x9d,0x3b,0x59,0x26,0x11,0x83,0xa2,0x2e );
EXTERN_GUID( IID_IWMWriterPreprocess,   0xfc54a285,0x38c4,0x45b5,0xaa,0x23,0x85,0xb9,0xf7,0xcb,0x42,0x4b );
EXTERN_GUID( IID_IWMWriterSink,         0x96406be4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink,     0x96406be5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink2,    0x14282ba7,0x4aef,0x4205,0x8c,0xe5,0xc2,0x29,0x03,0x5a,0x05,0xbc );
EXTERN_GUID( IID_IWMWriterFileSink3,    0x3fea4feb,0x2945,0x47a7,0xa1,0xdd,0xc5,0x3a,0x8f,0xc4,0xc4,0x5c );
EXTERN_GUID( IID_IWMWriterNetworkSink,  0x96406be7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterPushSink,     0xdc10e6a5,0x072c,0x467d,0xbf,0x57,0x63,0x30,0xa9,0xdd,0xe1,0x2a );
EXTERN_GUID( IID_IWMDRMWriter,      0xd6ea5dd0,0x12a0,0x43f4,0x90,0xab,0xa3,0xfd,0x45,0x1e,0x6a,0x07 );
EXTERN_GUID( IID_IWMClientConnections,  0x73c66010,0xa299,0x41df,0xb1,0xf0,0xcc,0xf0,0x3b,0x09,0xc1,0xc6 );
EXTERN_GUID( IID_IWMReaderAdvanced,     0x96406bea,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderAdvanced2,    0xae14a945,0xb90c,0x4d0d,0x91,0x27,0x80,0xd6,0x65,0xf7,0xd7,0x3e );
EXTERN_GUID( IID_IWMReaderAdvanced3,    0x5dc0674b,0xf04b,0x4a4e,0x9f,0x2a,0xb1,0xaf,0xde,0x2c,0x81,0x00 );
EXTERN_GUID( IID_IWMDRMReader,          0xd2827540,0x3ee7,0x432c,0xb1,0x4c,0xdc,0x17,0xf0,0x85,0xd3,0xb3 );
EXTERN_GUID( IID_IWMReaderCallbackAdvanced, 0x96406beb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderNetworkConfig,0x96406bec,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderNetworkConfig2,0xd979a853,0x042b,0x4050,0x83,0x87,0xc9,0x39,0xdb,0x22,0x01,0x3f );
EXTERN_GUID( IID_IWMReaderStreamClock,  0x96406bed,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMIndexer,            0x6d7cdc71,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMIndexer2,           0xb70f1e42,0x6255,0x4df0,0xa6,0xb9,0x02,0xb2,0x12,0xd9,0xe2,0xbb );
EXTERN_GUID( IID_IWMReaderAllocatorEx,  0x9f762fa7,0xa22e,0x428d,0x93,0xc9,0xac,0x82,0xf3,0xaa,0xfe,0x5a );
EXTERN_GUID( IID_IWMReaderTypeNegotiation, 0xfdbe5592,0x81a1,0x41ea,0x93,0xbd,0x73,0x5c,0xad,0x1a,0xdc,0x5 );
EXTERN_GUID( IID_IWMLicenseBackup,      0x05E5AC9F,0x3FB6,0x4508,0xBB,0x43,0xA4,0x06,0x7B,0xA1,0xEB,0xE8);
EXTERN_GUID( IID_IWMLicenseRestore,     0xC70B6334,0xa22e,0x4efb,0xA2,0x45,0x15,0xE6,0x5A,0x00,0x4A,0x13);
EXTERN_GUID( IID_IWMBackupRestoreProps, 0x3C8E0DA6,0x996F,0x4ff3,0xA1,0xAF,0x48,0x38,0xF9,0x37,0x7e,0x2e);
EXTERN_GUID( IID_IWMPacketSize,         0xcdfb97ab,0x188f,0x40b3,0xb6,0x43,0x5b,0x79,0x03,0x97,0x5c,0x59);
EXTERN_GUID( IID_IWMPacketSize2,        0x8bfc2b9e,0xb646,0x4233,0xa8,0x77,0x1c,0x6a,0x7,0x96,0x69,0xdc);
EXTERN_GUID( IID_IWMRegisterCallback,   0xcf4b1f99,0x4de2,0x4e49,0xa3,0x63,0x25,0x27,0x40,0xd9,0x9b,0xc1);
EXTERN_GUID( IID_IWMWriterPostView,     0x81e20ce4,0x75ef,0x491a,0x80,0x04,0xfc,0x53,0xc4,0x5b,0xdc,0x3e);
EXTERN_GUID( IID_IWMWriterPostViewCallback, 0xd9d6549d,0xa193,0x4f24,0xb3,0x08,0x03,0x12,0x3d,0x9b,0x7f,0x8d);
EXTERN_GUID( IID_IWMCodecInfo,          0xa970f41e,0x34de,0x4a98,0xb3,0xba,0xe4,0xb3,0xca,0x75,0x28,0xf0);
EXTERN_GUID( IID_IWMCodecInfo2,         0xaa65e273,0xb686,0x4056,0x91,0xec,0xdd,0x76,0x8d,0x4d,0xf7,0x10);
EXTERN_GUID( IID_IWMCodecInfo3,         0x7e51f487,0x4d93,0x4f98,0x8a,0xb4,0x27,0xd0,0x56,0x5a,0xdc,0x51);
EXTERN_GUID( IID_IWMPropertyVault,      0x72995A79,0x5090,0x42a4,0x9C,0x8C,0xD9,0xD0,0xB6,0xD3,0x4B,0xE5 );
EXTERN_GUID( IID_IWMIStreamProps,       0x6816dad3,0x2b4b,0x4c8e,0x81,0x49,0x87,0x4c,0x34,0x83,0xa7,0x53 );
EXTERN_GUID( CLSID_WMMUTEX_Language, 0xD6E22A00,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
EXTERN_GUID( CLSID_WMMUTEX_Bitrate, 0xD6E22A01,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
EXTERN_GUID( CLSID_WMMUTEX_Presentation, 0xD6E22A02,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
EXTERN_GUID( CLSID_WMMUTEX_Unknown, 0xD6E22A03,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
EXTERN_GUID( CLSID_WMBandwidthSharing_Exclusive, 0xaf6060aa,0x5197,0x11d2,0xb6,0xaf,0x00,0xc0,0x4f,0xd9,0x08,0xe9 );
EXTERN_GUID( CLSID_WMBandwidthSharing_Partial, 0xaf6060ab,0x5197,0x11d2,0xb6,0xaf,0x00,0xc0,0x4f,0xd9,0x08,0xe9 );
#define WM_MAX_VIDEO_STREAMS            0x07f
#define WM_MAX_STREAMS                  0x07f
HRESULT STDMETHODCALLTYPE WMCreateCertificate( IUnknown** pUnkCert );
HRESULT STDMETHODCALLTYPE WMCreateWriter( IUnknown* pUnkCert, IWMWriter **ppWriter );
HRESULT STDMETHODCALLTYPE WMCreateReader( IUnknown* pUnkCert, DWORD dwRights, IWMReader **ppReader );
HRESULT STDMETHODCALLTYPE WMCreateSyncReader( IUnknown* pUnkCert, DWORD dwRights, IWMSyncReader **ppSyncReader );
HRESULT STDMETHODCALLTYPE WMCreateEditor( IWMMetadataEditor **ppEditor );
HRESULT STDMETHODCALLTYPE WMCreateIndexer( IWMIndexer **ppIndexer );
HRESULT STDMETHODCALLTYPE WMCreateBackupRestorer( IUnknown *pCallback, IWMLicenseBackup **ppBackup );
HRESULT STDMETHODCALLTYPE WMCreateProfileManager( IWMProfileManager **ppProfileManager );
HRESULT STDMETHODCALLTYPE WMCreateWriterFileSink( IWMWriterFileSink **ppSink );
HRESULT STDMETHODCALLTYPE WMCreateWriterNetworkSink( IWMWriterNetworkSink **ppSink );
HRESULT STDMETHODCALLTYPE WMCreateWriterPushSink( IWMWriterPushSink **ppSink );


extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_v0_0_s_ifspec;

#ifndef __IWMMediaProps_INTERFACE_DEFINED__
#define __IWMMediaProps_INTERFACE_DEFINED__

/* interface IWMMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMediaProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID __RPC_FAR *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        END_INTERFACE
    } IWMMediaPropsVtbl;

    interface IWMMediaProps
    {
        CONST_VTBL struct IWMMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMediaProps_GetType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidType);


void __RPC_STUB IWMMediaProps_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMediaProps_GetMediaType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
    /* [out][in] */ DWORD __RPC_FAR *pcbType);


void __RPC_STUB IWMMediaProps_GetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMediaProps_SetMediaType_Proxy( 
    IWMMediaProps __RPC_FAR * This,
    /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);


void __RPC_STUB IWMMediaProps_SetMediaType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMVideoMediaProps_INTERFACE_DEFINED__
#define __IWMVideoMediaProps_INTERFACE_DEFINED__

/* interface IWMVideoMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMVideoMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCF-2B2B-11d3-B36B-00C04F6108FF")
    IWMVideoMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxKeyFrameSpacing( 
            /* [out] */ LONGLONG __RPC_FAR *pllTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxKeyFrameSpacing( 
            /* [in] */ LONGLONG llTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuality( 
            /* [out] */ DWORD __RPC_FAR *pdwQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQuality( 
            /* [in] */ DWORD dwQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMVideoMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMVideoMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMVideoMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ LONGLONG __RPC_FAR *pllTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ LONGLONG llTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuality )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwQuality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetQuality )( 
            IWMVideoMediaProps __RPC_FAR * This,
            /* [in] */ DWORD dwQuality);
        
        END_INTERFACE
    } IWMVideoMediaPropsVtbl;

    interface IWMVideoMediaProps
    {
        CONST_VTBL struct IWMVideoMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMVideoMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMVideoMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMVideoMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMVideoMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMVideoMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMVideoMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMVideoMediaProps_GetMaxKeyFrameSpacing(This,pllTime)	\
    (This)->lpVtbl -> GetMaxKeyFrameSpacing(This,pllTime)

#define IWMVideoMediaProps_SetMaxKeyFrameSpacing(This,llTime)	\
    (This)->lpVtbl -> SetMaxKeyFrameSpacing(This,llTime)

#define IWMVideoMediaProps_GetQuality(This,pdwQuality)	\
    (This)->lpVtbl -> GetQuality(This,pdwQuality)

#define IWMVideoMediaProps_SetQuality(This,dwQuality)	\
    (This)->lpVtbl -> SetQuality(This,dwQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_GetMaxKeyFrameSpacing_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [out] */ LONGLONG __RPC_FAR *pllTime);


void __RPC_STUB IWMVideoMediaProps_GetMaxKeyFrameSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_SetMaxKeyFrameSpacing_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [in] */ LONGLONG llTime);


void __RPC_STUB IWMVideoMediaProps_SetMaxKeyFrameSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_GetQuality_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwQuality);


void __RPC_STUB IWMVideoMediaProps_GetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMVideoMediaProps_SetQuality_Proxy( 
    IWMVideoMediaProps __RPC_FAR * This,
    /* [in] */ DWORD dwQuality);


void __RPC_STUB IWMVideoMediaProps_SetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMVideoMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMWriter_INTERFACE_DEFINED__
#define __IWMWriter_INTERFACE_DEFINED__

/* interface IWMWriter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProfileByID( 
            /* [in] */ REFGUID guidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProfile( 
            /* [in] */ IWMProfile __RPC_FAR *pProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputFilename( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputCount( 
            /* [out] */ DWORD __RPC_FAR *pcInputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps __RPC_FAR *pInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormatCount( 
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormat( 
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateSample( 
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSample( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProfileByID )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProfile )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputFilename )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputCount )( 
            IWMWriter __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcInputs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputProps )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputProps )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps __RPC_FAR *pInput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputFormatCount )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputFormat )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginWriting )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndWriting )( 
            IWMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateSample )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteSample )( 
            IWMWriter __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IWMWriter __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterVtbl;

    interface IWMWriter
    {
        CONST_VTBL struct IWMWriterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriter_SetProfileByID(This,guidProfile)	\
    (This)->lpVtbl -> SetProfileByID(This,guidProfile)

#define IWMWriter_SetProfile(This,pProfile)	\
    (This)->lpVtbl -> SetProfile(This,pProfile)

#define IWMWriter_SetOutputFilename(This,pwszFilename)	\
    (This)->lpVtbl -> SetOutputFilename(This,pwszFilename)

#define IWMWriter_GetInputCount(This,pcInputs)	\
    (This)->lpVtbl -> GetInputCount(This,pcInputs)

#define IWMWriter_GetInputProps(This,dwInputNum,ppInput)	\
    (This)->lpVtbl -> GetInputProps(This,dwInputNum,ppInput)

#define IWMWriter_SetInputProps(This,dwInputNum,pInput)	\
    (This)->lpVtbl -> SetInputProps(This,dwInputNum,pInput)

#define IWMWriter_GetInputFormatCount(This,dwInputNumber,pcFormats)	\
    (This)->lpVtbl -> GetInputFormatCount(This,dwInputNumber,pcFormats)

#define IWMWriter_GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps)	\
    (This)->lpVtbl -> GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps)

#define IWMWriter_BeginWriting(This)	\
    (This)->lpVtbl -> BeginWriting(This)

#define IWMWriter_EndWriting(This)	\
    (This)->lpVtbl -> EndWriting(This)

#define IWMWriter_AllocateSample(This,dwSampleSize,ppSample)	\
    (This)->lpVtbl -> AllocateSample(This,dwSampleSize,ppSample)

#define IWMWriter_WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)

#define IWMWriter_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriter_SetProfileByID_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ REFGUID guidProfile);


void __RPC_STUB IWMWriter_SetProfileByID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetProfile_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ IWMProfile __RPC_FAR *pProfile);


void __RPC_STUB IWMWriter_SetProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetOutputFilename_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMWriter_SetOutputFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputCount_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcInputs);


void __RPC_STUB IWMWriter_GetInputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputProps_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *ppInput);


void __RPC_STUB IWMWriter_GetInputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_SetInputProps_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ IWMInputMediaProps __RPC_FAR *pInput);


void __RPC_STUB IWMWriter_SetInputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputFormatCount_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMWriter_GetInputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_GetInputFormat_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMInputMediaProps __RPC_FAR *__RPC_FAR *pProps);


void __RPC_STUB IWMWriter_GetInputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_BeginWriting_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_BeginWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_EndWriting_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_EndWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_AllocateSample_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwSampleSize,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample);


void __RPC_STUB IWMWriter_AllocateSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_WriteSample_Proxy( 
    IWMWriter __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample);


void __RPC_STUB IWMWriter_WriteSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriter_Flush_Proxy( 
    IWMWriter __RPC_FAR * This);


void __RPC_STUB IWMWriter_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriter_INTERFACE_DEFINED__ */


#ifndef __IWMInputMediaProps_INTERFACE_DEFINED__
#define __IWMInputMediaProps_INTERFACE_DEFINED__

/* interface IWMInputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMInputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD5-2B2B-11d3-B36B-00C04F6108FF")
    IWMInputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMInputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMInputMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMInputMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGroupName )( 
            IWMInputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        END_INTERFACE
    } IWMInputMediaPropsVtbl;

    interface IWMInputMediaProps
    {
        CONST_VTBL struct IWMInputMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMInputMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMInputMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMInputMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMInputMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMInputMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMInputMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMInputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName)

#define IWMInputMediaProps_GetGroupName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetGroupName(This,pwszName,pcchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMInputMediaProps_GetConnectionName_Proxy( 
    IWMInputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMInputMediaProps_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMInputMediaProps_GetGroupName_Proxy( 
    IWMInputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMInputMediaProps_GetGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMInputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMPropertyVault_INTERFACE_DEFINED__
#define __IWMPropertyVault_INTERFACE_DEFINED__

/* interface IWMPropertyVault */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPropertyVault;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72995A79-5090-42a4-9C8C-D9D0B6D34BE5")
    IWMPropertyVault : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyCount( 
            /* [in] */ DWORD __RPC_FAR *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyByName( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE pType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pdwNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyPropertiesFrom( 
            /* [in] */ IWMPropertyVault __RPC_FAR *pIWMPropertyVault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPropertyVaultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPropertyVault __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPropertyVault __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyCount )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyByName )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE pType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyByIndex )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pszName,
            /* [out][in] */ DWORD __RPC_FAR *pdwNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyPropertiesFrom )( 
            IWMPropertyVault __RPC_FAR * This,
            /* [in] */ IWMPropertyVault __RPC_FAR *pIWMPropertyVault);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IWMPropertyVault __RPC_FAR * This);
        
        END_INTERFACE
    } IWMPropertyVaultVtbl;

    interface IWMPropertyVault
    {
        CONST_VTBL struct IWMPropertyVaultVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPropertyVault_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPropertyVault_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPropertyVault_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPropertyVault_GetPropertyCount(This,pdwCount)	\
    (This)->lpVtbl -> GetPropertyCount(This,pdwCount)

#define IWMPropertyVault_GetPropertyByName(This,pszName,pType,pValue,pdwSize)	\
    (This)->lpVtbl -> GetPropertyByName(This,pszName,pType,pValue,pdwSize)

#define IWMPropertyVault_SetProperty(This,pszName,pType,pValue,dwSize)	\
    (This)->lpVtbl -> SetProperty(This,pszName,pType,pValue,dwSize)

#define IWMPropertyVault_GetPropertyByIndex(This,dwIndex,pszName,pdwNameLen,pType,pValue,pdwSize)	\
    (This)->lpVtbl -> GetPropertyByIndex(This,dwIndex,pszName,pdwNameLen,pType,pValue,pdwSize)

#define IWMPropertyVault_CopyPropertiesFrom(This,pIWMPropertyVault)	\
    (This)->lpVtbl -> CopyPropertiesFrom(This,pIWMPropertyVault)

#define IWMPropertyVault_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPropertyVault_GetPropertyCount_Proxy( 
    IWMPropertyVault __RPC_FAR * This,
    /* [in] */ DWORD __RPC_FAR *pdwCount);


void __RPC_STUB IWMPropertyVault_GetPropertyCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_GetPropertyByName_Proxy( 
    IWMPropertyVault __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize);


void __RPC_STUB IWMPropertyVault_GetPropertyByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_SetProperty_Proxy( 
    IWMPropertyVault __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE pType,
    /* [in] */ BYTE __RPC_FAR *pValue,
    /* [in] */ DWORD dwSize);


void __RPC_STUB IWMPropertyVault_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_GetPropertyByIndex_Proxy( 
    IWMPropertyVault __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ LPWSTR pszName,
    /* [out][in] */ DWORD __RPC_FAR *pdwNameLen,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize);


void __RPC_STUB IWMPropertyVault_GetPropertyByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_CopyPropertiesFrom_Proxy( 
    IWMPropertyVault __RPC_FAR * This,
    /* [in] */ IWMPropertyVault __RPC_FAR *pIWMPropertyVault);


void __RPC_STUB IWMPropertyVault_CopyPropertiesFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPropertyVault_Clear_Proxy( 
    IWMPropertyVault __RPC_FAR * This);


void __RPC_STUB IWMPropertyVault_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPropertyVault_INTERFACE_DEFINED__ */


#ifndef __IWMIStreamProps_INTERFACE_DEFINED__
#define __IWMIStreamProps_INTERFACE_DEFINED__

/* interface IWMIStreamProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMIStreamProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6816dad3-2b4b-4c8e-8149-874c3483a753")
    IWMIStreamProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIStreamPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMIStreamProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMIStreamProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMIStreamProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IWMIStreamProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize);
        
        END_INTERFACE
    } IWMIStreamPropsVtbl;

    interface IWMIStreamProps
    {
        CONST_VTBL struct IWMIStreamPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIStreamProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIStreamProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIStreamProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIStreamProps_GetProperty(This,pszName,pType,pValue,pdwSize)	\
    (This)->lpVtbl -> GetProperty(This,pszName,pType,pValue,pdwSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIStreamProps_GetProperty_Proxy( 
    IWMIStreamProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize);


void __RPC_STUB IWMIStreamProps_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIStreamProps_INTERFACE_DEFINED__ */


#ifndef __IWMReader_INTERFACE_DEFINED__
#define __IWMReader_INTERFACE_DEFINED__

/* interface IWMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD6-2B2B-11d3-B36B-00C04F6108FF")
    IWMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCount( 
            /* [out] */ DWORD __RPC_FAR *pcOutputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormatCount( 
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormat( 
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputCount )( 
            IWMReader __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcOutputs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputProps )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputProps )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputFormatCount )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputFormat )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IWMReader __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IWMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IWMReader __RPC_FAR * This);
        
        END_INTERFACE
    } IWMReaderVtbl;

    interface IWMReader
    {
        CONST_VTBL struct IWMReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReader_Open(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> Open(This,pwszURL,pCallback,pvContext)

#define IWMReader_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMReader_GetOutputCount(This,pcOutputs)	\
    (This)->lpVtbl -> GetOutputCount(This,pcOutputs)

#define IWMReader_GetOutputProps(This,dwOutputNum,ppOutput)	\
    (This)->lpVtbl -> GetOutputProps(This,dwOutputNum,ppOutput)

#define IWMReader_SetOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> SetOutputProps(This,dwOutputNum,pOutput)

#define IWMReader_GetOutputFormatCount(This,dwOutputNumber,pcFormats)	\
    (This)->lpVtbl -> GetOutputFormatCount(This,dwOutputNumber,pcFormats)

#define IWMReader_GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)	\
    (This)->lpVtbl -> GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)

#define IWMReader_Start(This,cnsStart,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> Start(This,cnsStart,cnsDuration,fRate,pvContext)

#define IWMReader_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IWMReader_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IWMReader_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReader_Open_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszURL,
    /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReader_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Close_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputCount_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcOutputs);


void __RPC_STUB IWMReader_GetOutputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputProps_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput);


void __RPC_STUB IWMReader_GetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_SetOutputProps_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMReader_SetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormatCount_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMReader_GetOutputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_GetOutputFormat_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps);


void __RPC_STUB IWMReader_GetOutputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Start_Proxy( 
    IWMReader __RPC_FAR * This,
    /* [in] */ QWORD cnsStart,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReader_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Stop_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Pause_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReader_Resume_Proxy( 
    IWMReader __RPC_FAR * This);


void __RPC_STUB IWMReader_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReader_INTERFACE_DEFINED__ */


#ifndef __IWMSyncReader_INTERFACE_DEFINED__
#define __IWMSyncReader_INTERFACE_DEFINED__

/* interface IWMSyncReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMSyncReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9397F121-7705-4dc9-B049-98B698188414")
    IWMSyncReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRange( 
            /* [in] */ QWORD cnsStartTime,
            /* [in] */ LONGLONG cnsDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRangeByFrame( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD qwFrameNumber,
            /* [in] */ LONGLONG cFramesToRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextSample( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample,
            /* [out] */ QWORD __RPC_FAR *pcnsSampleTime,
            /* [out] */ QWORD __RPC_FAR *pcnsDuration,
            /* [out] */ DWORD __RPC_FAR *pdwFlags,
            /* [out] */ DWORD __RPC_FAR *pdwOutputNum,
            /* [out] */ WORD __RPC_FAR *pwStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamsSelected( 
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSelected( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReadCompressedSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fCompressed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReadCompressedSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfCompressed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCount( 
            /* [out] */ DWORD __RPC_FAR *pcOutputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormatCount( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormat( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD dwFormatNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenStream( 
            /* [in] */ IStream __RPC_FAR *pStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSyncReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMSyncReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMSyncReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMSyncReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRange )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ QWORD cnsStartTime,
            /* [in] */ LONGLONG cnsDuration);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRangeByFrame )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD qwFrameNumber,
            /* [in] */ LONGLONG cFramesToRead);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextSample )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample,
            /* [out] */ QWORD __RPC_FAR *pcnsSampleTime,
            /* [out] */ QWORD __RPC_FAR *pcnsDuration,
            /* [out] */ DWORD __RPC_FAR *pdwFlags,
            /* [out] */ DWORD __RPC_FAR *pdwOutputNum,
            /* [out] */ WORD __RPC_FAR *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReadCompressedSamples )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fCompressed);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReadCompressedSamples )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfCompressed);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSetting )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSetting )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputCount )( 
            IWMSyncReader __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcOutputs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputProps )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputProps )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputFormatCount )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputFormat )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD dwFormatNum,
            /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenStream )( 
            IWMSyncReader __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream);
        
        END_INTERFACE
    } IWMSyncReaderVtbl;

    interface IWMSyncReader
    {
        CONST_VTBL struct IWMSyncReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSyncReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMSyncReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMSyncReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMSyncReader_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#define IWMSyncReader_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMSyncReader_SetRange(This,cnsStartTime,cnsDuration)	\
    (This)->lpVtbl -> SetRange(This,cnsStartTime,cnsDuration)

#define IWMSyncReader_SetRangeByFrame(This,wStreamNum,qwFrameNumber,cFramesToRead)	\
    (This)->lpVtbl -> SetRangeByFrame(This,wStreamNum,qwFrameNumber,cFramesToRead)

#define IWMSyncReader_GetNextSample(This,wStreamNum,ppSample,pcnsSampleTime,pcnsDuration,pdwFlags,pdwOutputNum,pwStreamNum)	\
    (This)->lpVtbl -> GetNextSample(This,wStreamNum,ppSample,pcnsSampleTime,pcnsDuration,pdwFlags,pdwOutputNum,pwStreamNum)

#define IWMSyncReader_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMSyncReader_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMSyncReader_SetReadCompressedSamples(This,wStreamNum,fCompressed)	\
    (This)->lpVtbl -> SetReadCompressedSamples(This,wStreamNum,fCompressed)

#define IWMSyncReader_GetReadCompressedSamples(This,wStreamNum,pfCompressed)	\
    (This)->lpVtbl -> GetReadCompressedSamples(This,wStreamNum,pfCompressed)

#define IWMSyncReader_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMSyncReader_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMSyncReader_GetOutputCount(This,pcOutputs)	\
    (This)->lpVtbl -> GetOutputCount(This,pcOutputs)

#define IWMSyncReader_GetOutputProps(This,dwOutputNum,ppOutput)	\
    (This)->lpVtbl -> GetOutputProps(This,dwOutputNum,ppOutput)

#define IWMSyncReader_SetOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> SetOutputProps(This,dwOutputNum,pOutput)

#define IWMSyncReader_GetOutputFormatCount(This,dwOutputNum,pcFormats)	\
    (This)->lpVtbl -> GetOutputFormatCount(This,dwOutputNum,pcFormats)

#define IWMSyncReader_GetOutputFormat(This,dwOutputNum,dwFormatNum,ppProps)	\
    (This)->lpVtbl -> GetOutputFormat(This,dwOutputNum,dwFormatNum,ppProps)

#define IWMSyncReader_OpenStream(This,pStream)	\
    (This)->lpVtbl -> OpenStream(This,pStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMSyncReader_Open_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMSyncReader_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_Close_Proxy( 
    IWMSyncReader __RPC_FAR * This);


void __RPC_STUB IWMSyncReader_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetRange_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ QWORD cnsStartTime,
    /* [in] */ LONGLONG cnsDuration);


void __RPC_STUB IWMSyncReader_SetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetRangeByFrame_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD qwFrameNumber,
    /* [in] */ LONGLONG cFramesToRead);


void __RPC_STUB IWMSyncReader_SetRangeByFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetNextSample_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppSample,
    /* [out] */ QWORD __RPC_FAR *pcnsSampleTime,
    /* [out] */ QWORD __RPC_FAR *pcnsDuration,
    /* [out] */ DWORD __RPC_FAR *pdwFlags,
    /* [out] */ DWORD __RPC_FAR *pdwOutputNum,
    /* [out] */ WORD __RPC_FAR *pwStreamNum);


void __RPC_STUB IWMSyncReader_GetNextSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetStreamsSelected_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ WORD cStreamCount,
    /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);


void __RPC_STUB IWMSyncReader_SetStreamsSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetStreamSelected_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);


void __RPC_STUB IWMSyncReader_GetStreamSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetReadCompressedSamples_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fCompressed);


void __RPC_STUB IWMSyncReader_SetReadCompressedSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetReadCompressedSamples_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL __RPC_FAR *pfCompressed);


void __RPC_STUB IWMSyncReader_GetReadCompressedSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputSetting_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMSyncReader_GetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetOutputSetting_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMSyncReader_SetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputCount_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcOutputs);


void __RPC_STUB IWMSyncReader_GetOutputCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputProps_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppOutput);


void __RPC_STUB IWMSyncReader_GetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_SetOutputProps_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMSyncReader_SetOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputFormatCount_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMSyncReader_GetOutputFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_GetOutputFormat_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD dwFormatNum,
    /* [out] */ IWMOutputMediaProps __RPC_FAR *__RPC_FAR *ppProps);


void __RPC_STUB IWMSyncReader_GetOutputFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMSyncReader_OpenStream_Proxy( 
    IWMSyncReader __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IWMSyncReader_OpenStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMSyncReader_INTERFACE_DEFINED__ */


#ifndef __IWMOutputMediaProps_INTERFACE_DEFINED__
#define __IWMOutputMediaProps_INTERFACE_DEFINED__

/* interface IWMOutputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMOutputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD7-2B2B-11d3-B36B-00C04F6108FF")
    IWMOutputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamGroupName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMOutputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMOutputMediaProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMOutputMediaProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WM_MEDIA_TYPE __RPC_FAR *pType,
            /* [out][in] */ DWORD __RPC_FAR *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMediaType )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamGroupName )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMOutputMediaProps __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        END_INTERFACE
    } IWMOutputMediaPropsVtbl;

    interface IWMOutputMediaProps
    {
        CONST_VTBL struct IWMOutputMediaPropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMOutputMediaProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMOutputMediaProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMOutputMediaProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMOutputMediaProps_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMOutputMediaProps_GetMediaType(This,pType,pcbType)	\
    (This)->lpVtbl -> GetMediaType(This,pType,pcbType)

#define IWMOutputMediaProps_SetMediaType(This,pType)	\
    (This)->lpVtbl -> SetMediaType(This,pType)


#define IWMOutputMediaProps_GetStreamGroupName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetStreamGroupName(This,pwszName,pcchName)

#define IWMOutputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetStreamGroupName_Proxy( 
    IWMOutputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMOutputMediaProps_GetStreamGroupName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMOutputMediaProps_GetConnectionName_Proxy( 
    IWMOutputMediaProps __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMOutputMediaProps_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMOutputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMStatusCallback_INTERFACE_DEFINED__
#define __IWMStatusCallback_INTERFACE_DEFINED__

/* interface IWMStatusCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc70-9888-11d3-8edc-00c04f6109cf")
    IWMStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStatusCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStatusCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStatusCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMStatusCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMStatusCallbackVtbl;

    interface IWMStatusCallback
    {
        CONST_VTBL struct IWMStatusCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStatusCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStatusCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStatusCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStatusCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStatusCallback_OnStatus_Proxy( 
    IWMStatusCallback __RPC_FAR * This,
    /* [in] */ WMT_STATUS Status,
    /* [in] */ HRESULT hr,
    /* [in] */ WMT_ATTR_DATATYPE dwType,
    /* [in] */ BYTE __RPC_FAR *pValue,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMStatusCallback_OnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStatusCallback_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallback_INTERFACE_DEFINED__
#define __IWMReaderCallback_INTERFACE_DEFINED__

/* interface IWMReaderCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD8-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSample( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSample )( 
            IWMReaderCallback __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackVtbl;

    interface IWMReaderCallback
    {
        CONST_VTBL struct IWMReaderCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)


#define IWMReaderCallback_OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderCallback_OnSample_Proxy( 
    IWMReaderCallback __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallback_OnSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderCallback_INTERFACE_DEFINED__ */


#ifndef __IWMCredentialCallback_INTERFACE_DEFINED__
#define __IWMCredentialCallback_INTERFACE_DEFINED__

/* interface IWMCredentialCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCredentialCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("342e0eb7-e651-450c-975b-2ace2c90c48e")
    IWMCredentialCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireCredentials( 
            /* [in] */ WCHAR __RPC_FAR *pwszRealm,
            /* [in] */ WCHAR __RPC_FAR *pwszSite,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCredentialCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCredentialCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCredentialCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCredentialCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcquireCredentials )( 
            IWMCredentialCallback __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszRealm,
            /* [in] */ WCHAR __RPC_FAR *pwszSite,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD __RPC_FAR *pdwFlags);
        
        END_INTERFACE
    } IWMCredentialCallbackVtbl;

    interface IWMCredentialCallback
    {
        CONST_VTBL struct IWMCredentialCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCredentialCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCredentialCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCredentialCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCredentialCallback_AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags)	\
    (This)->lpVtbl -> AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCredentialCallback_AcquireCredentials_Proxy( 
    IWMCredentialCallback __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszRealm,
    /* [in] */ WCHAR __RPC_FAR *pwszSite,
    /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszUser,
    /* [in] */ DWORD cchUser,
    /* [size_is][out][in] */ WCHAR __RPC_FAR *pwszPassword,
    /* [in] */ DWORD cchPassword,
    /* [in] */ HRESULT hrStatus,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IWMCredentialCallback_AcquireCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCredentialCallback_INTERFACE_DEFINED__ */


#ifndef __IWMMetadataEditor_INTERFACE_DEFINED__
#define __IWMMetadataEditor_INTERFACE_DEFINED__

/* interface IWMMetadataEditor */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMetadataEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD9-2B2B-11d3-B36B-00C04F6108FF")
    IWMMetadataEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMetadataEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMetadataEditor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMMetadataEditor __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IWMMetadataEditor __RPC_FAR * This);
        
        END_INTERFACE
    } IWMMetadataEditorVtbl;

    interface IWMMetadataEditor
    {
        CONST_VTBL struct IWMMetadataEditorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMetadataEditor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMetadataEditor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMetadataEditor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMetadataEditor_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#define IWMMetadataEditor_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMMetadataEditor_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Open_Proxy( 
    IWMMetadataEditor __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMMetadataEditor_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Close_Proxy( 
    IWMMetadataEditor __RPC_FAR * This);


void __RPC_STUB IWMMetadataEditor_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMetadataEditor_Flush_Proxy( 
    IWMMetadataEditor __RPC_FAR * This);


void __RPC_STUB IWMMetadataEditor_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMetadataEditor_INTERFACE_DEFINED__ */


#ifndef __IWMMetadataEditor2_INTERFACE_DEFINED__
#define __IWMMetadataEditor2_INTERFACE_DEFINED__

/* interface IWMMetadataEditor2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMetadataEditor2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("203CFFE3-2E18-4fdf-B59D-6E71530534CF")
    IWMMetadataEditor2 : public IWMMetadataEditor
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenEx( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ DWORD dwShareMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMetadataEditor2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMetadataEditor2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMetadataEditor2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMetadataEditor2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMMetadataEditor2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMMetadataEditor2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IWMMetadataEditor2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenEx )( 
            IWMMetadataEditor2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ DWORD dwShareMode);
        
        END_INTERFACE
    } IWMMetadataEditor2Vtbl;

    interface IWMMetadataEditor2
    {
        CONST_VTBL struct IWMMetadataEditor2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMetadataEditor2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMetadataEditor2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMetadataEditor2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMetadataEditor2_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#define IWMMetadataEditor2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMMetadataEditor2_Flush(This)	\
    (This)->lpVtbl -> Flush(This)


#define IWMMetadataEditor2_OpenEx(This,pwszFilename,dwDesiredAccess,dwShareMode)	\
    (This)->lpVtbl -> OpenEx(This,pwszFilename,dwDesiredAccess,dwShareMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMetadataEditor2_OpenEx_Proxy( 
    IWMMetadataEditor2 __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename,
    /* [in] */ DWORD dwDesiredAccess,
    /* [in] */ DWORD dwShareMode);


void __RPC_STUB IWMMetadataEditor2_OpenEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMetadataEditor2_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo_INTERFACE_DEFINED__
#define __IWMHeaderInfo_INTERFACE_DEFINED__

/* interface IWMHeaderInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDA-2B2B-11d3-B36B-00C04F6108FF")
    IWMHeaderInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCount( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByIndex( 
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByName( 
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarkerCount( 
            /* [out] */ WORD __RPC_FAR *pcMarkers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarker( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMarker( 
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMarker( 
            /* [in] */ WORD wIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptCount( 
            /* [out] */ WORD __RPC_FAR *pcScripts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScript( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScript( 
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveScript( 
            /* [in] */ WORD wIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMHeaderInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMHeaderInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByIndex )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByName )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttribute )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMarker )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptCount )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveScript )( 
            IWMHeaderInfo __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        END_INTERFACE
    } IWMHeaderInfoVtbl;

    interface IWMHeaderInfo
    {
        CONST_VTBL struct IWMHeaderInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMHeaderInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMHeaderInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMHeaderInfo_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes)

#define IWMHeaderInfo_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMHeaderInfo_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)

#define IWMHeaderInfo_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#define IWMHeaderInfo_GetMarkerCount(This,pcMarkers)	\
    (This)->lpVtbl -> GetMarkerCount(This,pcMarkers)

#define IWMHeaderInfo_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)

#define IWMHeaderInfo_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime)

#define IWMHeaderInfo_RemoveMarker(This,wIndex)	\
    (This)->lpVtbl -> RemoveMarker(This,wIndex)

#define IWMHeaderInfo_GetScriptCount(This,pcScripts)	\
    (This)->lpVtbl -> GetScriptCount(This,pcScripts)

#define IWMHeaderInfo_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)

#define IWMHeaderInfo_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime)

#define IWMHeaderInfo_RemoveScript(This,wIndex)	\
    (This)->lpVtbl -> RemoveScript(This,wIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WORD __RPC_FAR *pcAttributes);


void __RPC_STUB IWMHeaderInfo_GetAttributeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeByIndex_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMHeaderInfo_GetAttributeByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetAttributeByName_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMHeaderInfo_GetAttributeByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_SetAttribute_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMHeaderInfo_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetMarkerCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcMarkers);


void __RPC_STUB IWMHeaderInfo_GetMarkerCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
    /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
    /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);


void __RPC_STUB IWMHeaderInfo_GetMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_AddMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
    /* [in] */ QWORD cnsMarkerTime);


void __RPC_STUB IWMHeaderInfo_AddMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_RemoveMarker_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex);


void __RPC_STUB IWMHeaderInfo_RemoveMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetScriptCount_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcScripts);


void __RPC_STUB IWMHeaderInfo_GetScriptCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_GetScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszType,
    /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
    /* [out] */ WCHAR __RPC_FAR *pwszCommand,
    /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
    /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);


void __RPC_STUB IWMHeaderInfo_GetScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_AddScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszType,
    /* [in] */ WCHAR __RPC_FAR *pwszCommand,
    /* [in] */ QWORD cnsScriptTime);


void __RPC_STUB IWMHeaderInfo_AddScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo_RemoveScript_Proxy( 
    IWMHeaderInfo __RPC_FAR * This,
    /* [in] */ WORD wIndex);


void __RPC_STUB IWMHeaderInfo_RemoveScript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMHeaderInfo_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo2_INTERFACE_DEFINED__
#define __IWMHeaderInfo2_INTERFACE_DEFINED__

/* interface IWMHeaderInfo2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15CF9781-454E-482e-B393-85FAE487A810")
    IWMHeaderInfo2 : public IWMHeaderInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [out] */ DWORD __RPC_FAR *pcCodecInfos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfo( 
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pcchName,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchDescription,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
            /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
            /* [out] */ BYTE __RPC_FAR *pbCodecInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMHeaderInfo2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMHeaderInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD __RPC_FAR *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByIndex )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributeByName )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out][in] */ WORD __RPC_FAR *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAttribute )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [out][in] */ WORD __RPC_FAR *pcchMarkerNameLen,
            /* [out] */ QWORD __RPC_FAR *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMarker )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszType,
            /* [out][in] */ WORD __RPC_FAR *pcchTypeLen,
            /* [out] */ WCHAR __RPC_FAR *pwszCommand,
            /* [out][in] */ WORD __RPC_FAR *pcchCommandLen,
            /* [out] */ QWORD __RPC_FAR *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszType,
            /* [in] */ WCHAR __RPC_FAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveScript )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcCodecInfos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfo )( 
            IWMHeaderInfo2 __RPC_FAR * This,
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD __RPC_FAR *pcchName,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchDescription,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
            /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
            /* [out] */ BYTE __RPC_FAR *pbCodecInfo);
        
        END_INTERFACE
    } IWMHeaderInfo2Vtbl;

    interface IWMHeaderInfo2
    {
        CONST_VTBL struct IWMHeaderInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMHeaderInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMHeaderInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMHeaderInfo2_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes)

#define IWMHeaderInfo2_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMHeaderInfo2_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)

#define IWMHeaderInfo2_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#define IWMHeaderInfo2_GetMarkerCount(This,pcMarkers)	\
    (This)->lpVtbl -> GetMarkerCount(This,pcMarkers)

#define IWMHeaderInfo2_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)

#define IWMHeaderInfo2_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime)

#define IWMHeaderInfo2_RemoveMarker(This,wIndex)	\
    (This)->lpVtbl -> RemoveMarker(This,wIndex)

#define IWMHeaderInfo2_GetScriptCount(This,pcScripts)	\
    (This)->lpVtbl -> GetScriptCount(This,pcScripts)

#define IWMHeaderInfo2_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)

#define IWMHeaderInfo2_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime)

#define IWMHeaderInfo2_RemoveScript(This,wIndex)	\
    (This)->lpVtbl -> RemoveScript(This,wIndex)


#define IWMHeaderInfo2_GetCodecInfoCount(This,pcCodecInfos)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,pcCodecInfos)

#define IWMHeaderInfo2_GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)	\
    (This)->lpVtbl -> GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMHeaderInfo2_GetCodecInfoCount_Proxy( 
    IWMHeaderInfo2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcCodecInfos);


void __RPC_STUB IWMHeaderInfo2_GetCodecInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMHeaderInfo2_GetCodecInfo_Proxy( 
    IWMHeaderInfo2 __RPC_FAR * This,
    /* [in] */ DWORD wIndex,
    /* [out][in] */ WORD __RPC_FAR *pcchName,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchDescription,
    /* [out] */ WCHAR __RPC_FAR *pwszDescription,
    /* [out] */ WMT_CODEC_INFO_TYPE __RPC_FAR *pCodecType,
    /* [out][in] */ WORD __RPC_FAR *pcbCodecInfo,
    /* [out] */ BYTE __RPC_FAR *pbCodecInfo);


void __RPC_STUB IWMHeaderInfo2_GetCodecInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMHeaderInfo2_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager_INTERFACE_DEFINED__
#define __IWMProfileManager_INTERFACE_DEFINED__

/* interface IWMProfileManager */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d16679f2-6ca0-472d-8d31-2f5d55aee155")
    IWMProfileManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEmptyProfile( 
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByID( 
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByData( 
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveProfile( 
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileCount( 
            /* [out] */ DWORD __RPC_FAR *pcProfiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadSystemProfile( 
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfileManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfileManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEmptyProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByID )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByData )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileCount )( 
            IWMProfileManager __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadSystemProfile )( 
            IWMProfileManager __RPC_FAR * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        END_INTERFACE
    } IWMProfileManagerVtbl;

    interface IWMProfileManager
    {
        CONST_VTBL struct IWMProfileManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfileManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfileManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfileManager_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile)

#define IWMProfileManager_LoadProfileByID(This,guidProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile)

#define IWMProfileManager_LoadProfileByData(This,pwszProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile)

#define IWMProfileManager_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)

#define IWMProfileManager_GetSystemProfileCount(This,pcProfiles)	\
    (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles)

#define IWMProfileManager_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfileManager_CreateEmptyProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ WMT_VERSION dwVersion,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_CreateEmptyProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadProfileByID_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ REFGUID guidProfile,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadProfileByID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadProfileByData_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadProfileByData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_SaveProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
    /* [in] */ WCHAR __RPC_FAR *pwszProfile,
    /* [out][in] */ DWORD __RPC_FAR *pdwLength);


void __RPC_STUB IWMProfileManager_SaveProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_GetSystemProfileCount_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcProfiles);


void __RPC_STUB IWMProfileManager_GetSystemProfileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager_LoadSystemProfile_Proxy( 
    IWMProfileManager __RPC_FAR * This,
    /* [in] */ DWORD dwProfileIndex,
    /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);


void __RPC_STUB IWMProfileManager_LoadSystemProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfileManager_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager2_INTERFACE_DEFINED__
#define __IWMProfileManager2_INTERFACE_DEFINED__

/* interface IWMProfileManager2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A924E51-73C1-494d-8019-23D37ED9B89A")
    IWMProfileManager2 : public IWMProfileManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileVersion( 
            WMT_VERSION __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSystemProfileVersion( 
            WMT_VERSION dwVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfileManager2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfileManager2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEmptyProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByID )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadProfileByData )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszProfile,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ IWMProfile __RPC_FAR *pIWMProfile,
            /* [in] */ WCHAR __RPC_FAR *pwszProfile,
            /* [out][in] */ DWORD __RPC_FAR *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileCount )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadSystemProfile )( 
            IWMProfileManager2 __RPC_FAR * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile __RPC_FAR *__RPC_FAR *ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemProfileVersion )( 
            IWMProfileManager2 __RPC_FAR * This,
            WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSystemProfileVersion )( 
            IWMProfileManager2 __RPC_FAR * This,
            WMT_VERSION dwVersion);
        
        END_INTERFACE
    } IWMProfileManager2Vtbl;

    interface IWMProfileManager2
    {
        CONST_VTBL struct IWMProfileManager2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfileManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfileManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfileManager2_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile)

#define IWMProfileManager2_LoadProfileByID(This,guidProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile)

#define IWMProfileManager2_LoadProfileByData(This,pwszProfile,ppProfile)	\
    (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile)

#define IWMProfileManager2_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)

#define IWMProfileManager2_GetSystemProfileCount(This,pcProfiles)	\
    (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles)

#define IWMProfileManager2_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile)


#define IWMProfileManager2_GetSystemProfileVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetSystemProfileVersion(This,pdwVersion)

#define IWMProfileManager2_SetSystemProfileVersion(This,dwVersion)	\
    (This)->lpVtbl -> SetSystemProfileVersion(This,dwVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfileManager2_GetSystemProfileVersion_Proxy( 
    IWMProfileManager2 __RPC_FAR * This,
    WMT_VERSION __RPC_FAR *pdwVersion);


void __RPC_STUB IWMProfileManager2_GetSystemProfileVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfileManager2_SetSystemProfileVersion_Proxy( 
    IWMProfileManager2 __RPC_FAR * This,
    WMT_VERSION dwVersion);


void __RPC_STUB IWMProfileManager2_SetSystemProfileVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfileManager2_INTERFACE_DEFINED__ */


#ifndef __IWMProfile_INTERFACE_DEFINED__
#define __IWMProfile_INTERFACE_DEFINED__

/* interface IWMProfile */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDB-2B2B-11d3-B36B-00C04F6108FF")
    IWMProfile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ const WCHAR __RPC_FAR *pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD __RPC_FAR *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamByNumber( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamByNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReconfigStream( 
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewStream( 
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusionCount( 
            /* [out] */ DWORD __RPC_FAR *pcME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusion( 
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMutualExclusion( 
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMutualExclusion( 
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewMutualExclusion( 
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamCount )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamByNumber )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStreamByNumber )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReconfigStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewStream )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusionCount )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewMutualExclusion )( 
            IWMProfile __RPC_FAR * This,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        END_INTERFACE
    } IWMProfileVtbl;

    interface IWMProfile
    {
        CONST_VTBL struct IWMProfileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile_GetVersion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);


void __RPC_STUB IWMProfile_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetName_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ DWORD __RPC_FAR *pcchName);


void __RPC_STUB IWMProfile_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_SetName_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszName);


void __RPC_STUB IWMProfile_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetDescription_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszDescription,
    /* [out][in] */ DWORD __RPC_FAR *pcchName);


void __RPC_STUB IWMProfile_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_SetDescription_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszDescription);


void __RPC_STUB IWMProfile_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStreamCount_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcStreams);


void __RPC_STUB IWMProfile_GetStreamCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ DWORD dwStreamIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_GetStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetStreamByNumber_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_GetStreamByNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_RemoveStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveStreamByNumber_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMProfile_RemoveStreamByNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_AddStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_AddStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_ReconfigStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);


void __RPC_STUB IWMProfile_ReconfigStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_CreateNewStream_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ REFGUID guidStreamType,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);


void __RPC_STUB IWMProfile_CreateNewStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetMutualExclusionCount_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcME);


void __RPC_STUB IWMProfile_GetMutualExclusionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_GetMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ DWORD dwMEIndex,
    /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);


void __RPC_STUB IWMProfile_GetMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_RemoveMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMMutualExclusion __RPC_FAR *pME);


void __RPC_STUB IWMProfile_RemoveMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_AddMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [in] */ IWMMutualExclusion __RPC_FAR *pME);


void __RPC_STUB IWMProfile_AddMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile_CreateNewMutualExclusion_Proxy( 
    IWMProfile __RPC_FAR * This,
    /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);


void __RPC_STUB IWMProfile_CreateNewMutualExclusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile_INTERFACE_DEFINED__ */


#ifndef __IWMProfile2_INTERFACE_DEFINED__
#define __IWMProfile2_INTERFACE_DEFINED__

/* interface IWMProfile2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07E72D33-D94E-4be7-8843-60AE5FF7E5F5")
    IWMProfile2 : public IWMProfile
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProfileID( 
            /* [out] */ GUID __RPC_FAR *pguidID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfile2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfile2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfile2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamCount )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamByNumber )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStreamByNumber )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReconfigStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewStream )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusionCount )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewMutualExclusion )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProfileID )( 
            IWMProfile2 __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidID);
        
        END_INTERFACE
    } IWMProfile2Vtbl;

    interface IWMProfile2
    {
        CONST_VTBL struct IWMProfile2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile2_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile2_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile2_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile2_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile2_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile2_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile2_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile2_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile2_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile2_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile2_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile2_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile2_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile2_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile2_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile2_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile2_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile2_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)


#define IWMProfile2_GetProfileID(This,pguidID)	\
    (This)->lpVtbl -> GetProfileID(This,pguidID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile2_GetProfileID_Proxy( 
    IWMProfile2 __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidID);


void __RPC_STUB IWMProfile2_GetProfileID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile2_INTERFACE_DEFINED__ */


#ifndef __IWMProfile3_INTERFACE_DEFINED__
#define __IWMProfile3_INTERFACE_DEFINED__

/* interface IWMProfile3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00EF96CC-A461-4546-8BCD-C9A28F0E06F5")
    IWMProfile3 : public IWMProfile2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStorageFormat( 
            /* [out] */ WMT_STORAGE_FORMAT __RPC_FAR *pnStorageFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStorageFormat( 
            /* [in] */ WMT_STORAGE_FORMAT nStorageFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidthSharingCount( 
            /* [out] */ DWORD __RPC_FAR *pcBS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidthSharing( 
            /* [in] */ DWORD dwBSIndex,
            /* [out] */ IWMBandwidthSharing __RPC_FAR *__RPC_FAR *ppBS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveBandwidthSharing( 
            /* [in] */ IWMBandwidthSharing __RPC_FAR *pBS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddBandwidthSharing( 
            /* [in] */ IWMBandwidthSharing __RPC_FAR *pBS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewBandwidthSharing( 
            /* [out] */ IWMBandwidthSharing __RPC_FAR *__RPC_FAR *ppBS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamPrioritization( 
            /* [out] */ IWMStreamPrioritization __RPC_FAR *__RPC_FAR *ppSP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamPrioritization( 
            /* [in] */ IWMStreamPrioritization __RPC_FAR *pSP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamPrioritization( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewStreamPrioritization( 
            /* [out] */ IWMStreamPrioritization __RPC_FAR *__RPC_FAR *ppSP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpectedPacketCount( 
            /* [in] */ QWORD msDuration,
            /* [out] */ QWORD __RPC_FAR *pcPackets) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfile3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMProfile3 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMProfile3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVersion )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ WMT_VERSION __RPC_FAR *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszDescription,
            /* [out][in] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamCount )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStream )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamByNumber )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStreamByNumber )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReconfigStream )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ IWMStreamConfig __RPC_FAR *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewStream )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusionCount )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMutualExclusion )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveMutualExclusion )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMutualExclusion )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ IWMMutualExclusion __RPC_FAR *pME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewMutualExclusion )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ IWMMutualExclusion __RPC_FAR *__RPC_FAR *ppME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProfileID )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorageFormat )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ WMT_STORAGE_FORMAT __RPC_FAR *pnStorageFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStorageFormat )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ WMT_STORAGE_FORMAT nStorageFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBandwidthSharingCount )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcBS);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBandwidthSharing )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ DWORD dwBSIndex,
            /* [out] */ IWMBandwidthSharing __RPC_FAR *__RPC_FAR *ppBS);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveBandwidthSharing )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ IWMBandwidthSharing __RPC_FAR *pBS);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddBandwidthSharing )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ IWMBandwidthSharing __RPC_FAR *pBS);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewBandwidthSharing )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ IWMBandwidthSharing __RPC_FAR *__RPC_FAR *ppBS);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamPrioritization )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ IWMStreamPrioritization __RPC_FAR *__RPC_FAR *ppSP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamPrioritization )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ IWMStreamPrioritization __RPC_FAR *pSP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStreamPrioritization )( 
            IWMProfile3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNewStreamPrioritization )( 
            IWMProfile3 __RPC_FAR * This,
            /* [out] */ IWMStreamPrioritization __RPC_FAR *__RPC_FAR *ppSP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExpectedPacketCount )( 
            IWMProfile3 __RPC_FAR * This,
            /* [in] */ QWORD msDuration,
            /* [out] */ QWORD __RPC_FAR *pcPackets);
        
        END_INTERFACE
    } IWMProfile3Vtbl;

    interface IWMProfile3
    {
        CONST_VTBL struct IWMProfile3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMProfile3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMProfile3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMProfile3_GetVersion(This,pdwVersion)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersion)

#define IWMProfile3_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMProfile3_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMProfile3_GetDescription(This,pwszDescription,pcchName)	\
    (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName)

#define IWMProfile3_SetDescription(This,pwszDescription)	\
    (This)->lpVtbl -> SetDescription(This,pwszDescription)

#define IWMProfile3_GetStreamCount(This,pcStreams)	\
    (This)->lpVtbl -> GetStreamCount(This,pcStreams)

#define IWMProfile3_GetStream(This,dwStreamIndex,ppConfig)	\
    (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig)

#define IWMProfile3_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig)

#define IWMProfile3_RemoveStream(This,pConfig)	\
    (This)->lpVtbl -> RemoveStream(This,pConfig)

#define IWMProfile3_RemoveStreamByNumber(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum)

#define IWMProfile3_AddStream(This,pConfig)	\
    (This)->lpVtbl -> AddStream(This,pConfig)

#define IWMProfile3_ReconfigStream(This,pConfig)	\
    (This)->lpVtbl -> ReconfigStream(This,pConfig)

#define IWMProfile3_CreateNewStream(This,guidStreamType,ppConfig)	\
    (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig)

#define IWMProfile3_GetMutualExclusionCount(This,pcME)	\
    (This)->lpVtbl -> GetMutualExclusionCount(This,pcME)

#define IWMProfile3_GetMutualExclusion(This,dwMEIndex,ppME)	\
    (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME)

#define IWMProfile3_RemoveMutualExclusion(This,pME)	\
    (This)->lpVtbl -> RemoveMutualExclusion(This,pME)

#define IWMProfile3_AddMutualExclusion(This,pME)	\
    (This)->lpVtbl -> AddMutualExclusion(This,pME)

#define IWMProfile3_CreateNewMutualExclusion(This,ppME)	\
    (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME)


#define IWMProfile3_GetProfileID(This,pguidID)	\
    (This)->lpVtbl -> GetProfileID(This,pguidID)


#define IWMProfile3_GetStorageFormat(This,pnStorageFormat)	\
    (This)->lpVtbl -> GetStorageFormat(This,pnStorageFormat)

#define IWMProfile3_SetStorageFormat(This,nStorageFormat)	\
    (This)->lpVtbl -> SetStorageFormat(This,nStorageFormat)

#define IWMProfile3_GetBandwidthSharingCount(This,pcBS)	\
    (This)->lpVtbl -> GetBandwidthSharingCount(This,pcBS)

#define IWMProfile3_GetBandwidthSharing(This,dwBSIndex,ppBS)	\
    (This)->lpVtbl -> GetBandwidthSharing(This,dwBSIndex,ppBS)

#define IWMProfile3_RemoveBandwidthSharing(This,pBS)	\
    (This)->lpVtbl -> RemoveBandwidthSharing(This,pBS)

#define IWMProfile3_AddBandwidthSharing(This,pBS)	\
    (This)->lpVtbl -> AddBandwidthSharing(This,pBS)

#define IWMProfile3_CreateNewBandwidthSharing(This,ppBS)	\
    (This)->lpVtbl -> CreateNewBandwidthSharing(This,ppBS)

#define IWMProfile3_GetStreamPrioritization(This,ppSP)	\
    (This)->lpVtbl -> GetStreamPrioritization(This,ppSP)

#define IWMProfile3_SetStreamPrioritization(This,pSP)	\
    (This)->lpVtbl -> SetStreamPrioritization(This,pSP)

#define IWMProfile3_RemoveStreamPrioritization(This)	\
    (This)->lpVtbl -> RemoveStreamPrioritization(This)

#define IWMProfile3_CreateNewStreamPrioritization(This,ppSP)	\
    (This)->lpVtbl -> CreateNewStreamPrioritization(This,ppSP)

#define IWMProfile3_GetExpectedPacketCount(This,msDuration,pcPackets)	\
    (This)->lpVtbl -> GetExpectedPacketCount(This,msDuration,pcPackets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMProfile3_GetStorageFormat_Proxy( 
    IWMProfile3 __RPC_FAR * This,
    /* [out] */ WMT_STORAGE_FORMAT __RPC_FAR *pnStorageFormat);


void __RPC_STUB IWMProfile3_GetStorageFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_SetStorageFormat_Proxy( 
    IWMProfile3 __RPC_FAR * This,
    /* [in] */ WMT_STORAGE_FORMAT nStorageFormat);


void __RPC_STUB IWMProfile3_SetStorageFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_GetBandwidthSharingCount_Proxy( 
    IWMProfile3 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcBS);


void __RPC_STUB IWMProfile3_GetBandwidthSharingCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_GetBandwidthSharing_Proxy( 
    IWMProfile3 __RPC_FAR * This,
    /* [in] */ DWORD dwBSIndex,
    /* [out] */ IWMBandwidthSharing __RPC_FAR *__RPC_FAR *ppBS);


void __RPC_STUB IWMProfile3_GetBandwidthSharing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_RemoveBandwidthSharing_Proxy( 
    IWMProfile3 __RPC_FAR * This,
    /* [in] */ IWMBandwidthSharing __RPC_FAR *pBS);


void __RPC_STUB IWMProfile3_RemoveBandwidthSharing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_AddBandwidthSharing_Proxy( 
    IWMProfile3 __RPC_FAR * This,
    /* [in] */ IWMBandwidthSharing __RPC_FAR *pBS);


void __RPC_STUB IWMProfile3_AddBandwidthSharing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_CreateNewBandwidthSharing_Proxy( 
    IWMProfile3 __RPC_FAR * This,
    /* [out] */ IWMBandwidthSharing __RPC_FAR *__RPC_FAR *ppBS);


void __RPC_STUB IWMProfile3_CreateNewBandwidthSharing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_GetStreamPrioritization_Proxy( 
    IWMProfile3 __RPC_FAR * This,
    /* [out] */ IWMStreamPrioritization __RPC_FAR *__RPC_FAR *ppSP);


void __RPC_STUB IWMProfile3_GetStreamPrioritization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_SetStreamPrioritization_Proxy( 
    IWMProfile3 __RPC_FAR * This,
    /* [in] */ IWMStreamPrioritization __RPC_FAR *pSP);


void __RPC_STUB IWMProfile3_SetStreamPrioritization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_RemoveStreamPrioritization_Proxy( 
    IWMProfile3 __RPC_FAR * This);


void __RPC_STUB IWMProfile3_RemoveStreamPrioritization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_CreateNewStreamPrioritization_Proxy( 
    IWMProfile3 __RPC_FAR * This,
    /* [out] */ IWMStreamPrioritization __RPC_FAR *__RPC_FAR *ppSP);


void __RPC_STUB IWMProfile3_CreateNewStreamPrioritization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMProfile3_GetExpectedPacketCount_Proxy( 
    IWMProfile3 __RPC_FAR * This,
    /* [in] */ QWORD msDuration,
    /* [out] */ QWORD __RPC_FAR *pcPackets);


void __RPC_STUB IWMProfile3_GetExpectedPacketCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMProfile3_INTERFACE_DEFINED__ */


#ifndef __IWMStreamConfig_INTERFACE_DEFINED__
#define __IWMStreamConfig_INTERFACE_DEFINED__

/* interface IWMStreamConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDC-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamType( 
            /* [out] */ GUID __RPC_FAR *pguidStreamType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamNumber( 
            /* [out] */ WORD __RPC_FAR *pwStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamName( 
            /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
            /* [out][in] */ WORD __RPC_FAR *pcchStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamName( 
            /* [in] */ WCHAR __RPC_FAR *pwszStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR __RPC_FAR *pwszInputName,
            /* [out][in] */ WORD __RPC_FAR *pcchInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionName( 
            /* [in] */ WCHAR __RPC_FAR *pwszInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBitrate( 
            /* [out] */ DWORD __RPC_FAR *pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBitrate( 
            /* [in] */ DWORD pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferWindow( 
            /* [out] */ DWORD __RPC_FAR *pmsBufferWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferWindow( 
            /* [in] */ DWORD msBufferWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStreamConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStreamConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamType )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidStreamType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamNumber )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamNumber )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
            /* [out][in] */ WORD __RPC_FAR *pcchStreamName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszStreamName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszInputName,
            /* [out][in] */ WORD __RPC_FAR *pcchInputName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConnectionName )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszInputName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBitrate )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBitrate )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ DWORD pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferWindow )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferWindow )( 
            IWMStreamConfig __RPC_FAR * This,
            /* [in] */ DWORD msBufferWindow);
        
        END_INTERFACE
    } IWMStreamConfigVtbl;

    interface IWMStreamConfig
    {
        CONST_VTBL struct IWMStreamConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamConfig_GetStreamType(This,pguidStreamType)	\
    (This)->lpVtbl -> GetStreamType(This,pguidStreamType)

#define IWMStreamConfig_GetStreamNumber(This,pwStreamNum)	\
    (This)->lpVtbl -> GetStreamNumber(This,pwStreamNum)

#define IWMStreamConfig_SetStreamNumber(This,wStreamNum)	\
    (This)->lpVtbl -> SetStreamNumber(This,wStreamNum)

#define IWMStreamConfig_GetStreamName(This,pwszStreamName,pcchStreamName)	\
    (This)->lpVtbl -> GetStreamName(This,pwszStreamName,pcchStreamName)

#define IWMStreamConfig_SetStreamName(This,pwszStreamName)	\
    (This)->lpVtbl -> SetStreamName(This,pwszStreamName)

#define IWMStreamConfig_GetConnectionName(This,pwszInputName,pcchInputName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszInputName,pcchInputName)

#define IWMStreamConfig_SetConnectionName(This,pwszInputName)	\
    (This)->lpVtbl -> SetConnectionName(This,pwszInputName)

#define IWMStreamConfig_GetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> GetBitrate(This,pdwBitrate)

#define IWMStreamConfig_SetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> SetBitrate(This,pdwBitrate)

#define IWMStreamConfig_GetBufferWindow(This,pmsBufferWindow)	\
    (This)->lpVtbl -> GetBufferWindow(This,pmsBufferWindow)

#define IWMStreamConfig_SetBufferWindow(This,msBufferWindow)	\
    (This)->lpVtbl -> SetBufferWindow(This,msBufferWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamType_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidStreamType);


void __RPC_STUB IWMStreamConfig_GetStreamType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamNumber_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwStreamNum);


void __RPC_STUB IWMStreamConfig_GetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetStreamNumber_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamConfig_SetStreamNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetStreamName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
    /* [out][in] */ WORD __RPC_FAR *pcchStreamName);


void __RPC_STUB IWMStreamConfig_GetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetStreamName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszStreamName);


void __RPC_STUB IWMStreamConfig_SetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetConnectionName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszInputName,
    /* [out][in] */ WORD __RPC_FAR *pcchInputName);


void __RPC_STUB IWMStreamConfig_GetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetConnectionName_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszInputName);


void __RPC_STUB IWMStreamConfig_SetConnectionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetBitrate_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwBitrate);


void __RPC_STUB IWMStreamConfig_GetBitrate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetBitrate_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ DWORD pdwBitrate);


void __RPC_STUB IWMStreamConfig_SetBitrate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_GetBufferWindow_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pmsBufferWindow);


void __RPC_STUB IWMStreamConfig_GetBufferWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig_SetBufferWindow_Proxy( 
    IWMStreamConfig __RPC_FAR * This,
    /* [in] */ DWORD msBufferWindow);


void __RPC_STUB IWMStreamConfig_SetBufferWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamConfig_INTERFACE_DEFINED__ */


#ifndef __IWMStreamConfig2_INTERFACE_DEFINED__
#define __IWMStreamConfig2_INTERFACE_DEFINED__

/* interface IWMStreamConfig2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamConfig2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7688D8CB-FC0D-43BD-9459-5A8DEC200CFA")
    IWMStreamConfig2 : public IWMStreamConfig
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTransportType( 
            /* [out] */ WMT_TRANSPORT_TYPE __RPC_FAR *pnTransportType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportType( 
            /* [in] */ WMT_TRANSPORT_TYPE nTransportType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimeBase( 
            /* [out] */ WMT_TIMEBASE __RPC_FAR *pTimeBase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeBase( 
            /* [in] */ WMT_TIMEBASE __RPC_FAR *pTimeBase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageID( 
            /* [out] */ WCHAR __RPC_FAR *pwszRFC1766LangID,
            /* [out][in] */ DWORD __RPC_FAR *pcchLangID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLanguageID( 
            /* [in] */ WCHAR __RPC_FAR *pwszRFC1766LangID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDataUnitExtension( 
            /* [in] */ GUID guidExtensionSystemID,
            /* [in] */ WORD cbExtensionDataSize,
            /* [in] */ BYTE __RPC_FAR *pbExtensionSystemInfo,
            /* [in] */ DWORD cbExtensionSystemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataUnitExtensionCount( 
            /* [out] */ WORD __RPC_FAR *pcDataUnitExtensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataUnitExtension( 
            /* [in] */ WORD wDataUnitExtensionNumber,
            /* [out] */ GUID __RPC_FAR *pguidExtensionSystemID,
            /* [out] */ WORD __RPC_FAR *pcbExtensionDataSize,
            /* [out] */ BYTE __RPC_FAR *pbExtensionSystemInfo,
            /* [out] */ DWORD __RPC_FAR *pcbExtensionSystemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllDataUnitExtensions( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamConfig2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStreamConfig2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStreamConfig2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamType )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidStreamType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamNumber )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamNumber )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamName )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszStreamName,
            /* [out][in] */ WORD __RPC_FAR *pcchStreamName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamName )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszStreamName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionName )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszInputName,
            /* [out][in] */ WORD __RPC_FAR *pcchInputName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConnectionName )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszInputName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBitrate )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBitrate )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [in] */ DWORD pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferWindow )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferWindow )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [in] */ DWORD msBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransportType )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [out] */ WMT_TRANSPORT_TYPE __RPC_FAR *pnTransportType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTransportType )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [in] */ WMT_TRANSPORT_TYPE nTransportType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTimeBase )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [out] */ WMT_TIMEBASE __RPC_FAR *pTimeBase);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimeBase )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [in] */ WMT_TIMEBASE __RPC_FAR *pTimeBase);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguageID )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszRFC1766LangID,
            /* [out][in] */ DWORD __RPC_FAR *pcchLangID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLanguageID )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszRFC1766LangID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddDataUnitExtension )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [in] */ GUID guidExtensionSystemID,
            /* [in] */ WORD cbExtensionDataSize,
            /* [in] */ BYTE __RPC_FAR *pbExtensionSystemInfo,
            /* [in] */ DWORD cbExtensionSystemInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataUnitExtensionCount )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcDataUnitExtensions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataUnitExtension )( 
            IWMStreamConfig2 __RPC_FAR * This,
            /* [in] */ WORD wDataUnitExtensionNumber,
            /* [out] */ GUID __RPC_FAR *pguidExtensionSystemID,
            /* [out] */ WORD __RPC_FAR *pcbExtensionDataSize,
            /* [out] */ BYTE __RPC_FAR *pbExtensionSystemInfo,
            /* [out] */ DWORD __RPC_FAR *pcbExtensionSystemInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllDataUnitExtensions )( 
            IWMStreamConfig2 __RPC_FAR * This);
        
        END_INTERFACE
    } IWMStreamConfig2Vtbl;

    interface IWMStreamConfig2
    {
        CONST_VTBL struct IWMStreamConfig2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamConfig2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamConfig2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamConfig2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamConfig2_GetStreamType(This,pguidStreamType)	\
    (This)->lpVtbl -> GetStreamType(This,pguidStreamType)

#define IWMStreamConfig2_GetStreamNumber(This,pwStreamNum)	\
    (This)->lpVtbl -> GetStreamNumber(This,pwStreamNum)

#define IWMStreamConfig2_SetStreamNumber(This,wStreamNum)	\
    (This)->lpVtbl -> SetStreamNumber(This,wStreamNum)

#define IWMStreamConfig2_GetStreamName(This,pwszStreamName,pcchStreamName)	\
    (This)->lpVtbl -> GetStreamName(This,pwszStreamName,pcchStreamName)

#define IWMStreamConfig2_SetStreamName(This,pwszStreamName)	\
    (This)->lpVtbl -> SetStreamName(This,pwszStreamName)

#define IWMStreamConfig2_GetConnectionName(This,pwszInputName,pcchInputName)	\
    (This)->lpVtbl -> GetConnectionName(This,pwszInputName,pcchInputName)

#define IWMStreamConfig2_SetConnectionName(This,pwszInputName)	\
    (This)->lpVtbl -> SetConnectionName(This,pwszInputName)

#define IWMStreamConfig2_GetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> GetBitrate(This,pdwBitrate)

#define IWMStreamConfig2_SetBitrate(This,pdwBitrate)	\
    (This)->lpVtbl -> SetBitrate(This,pdwBitrate)

#define IWMStreamConfig2_GetBufferWindow(This,pmsBufferWindow)	\
    (This)->lpVtbl -> GetBufferWindow(This,pmsBufferWindow)

#define IWMStreamConfig2_SetBufferWindow(This,msBufferWindow)	\
    (This)->lpVtbl -> SetBufferWindow(This,msBufferWindow)


#define IWMStreamConfig2_GetTransportType(This,pnTransportType)	\
    (This)->lpVtbl -> GetTransportType(This,pnTransportType)

#define IWMStreamConfig2_SetTransportType(This,nTransportType)	\
    (This)->lpVtbl -> SetTransportType(This,nTransportType)

#define IWMStreamConfig2_GetTimeBase(This,pTimeBase)	\
    (This)->lpVtbl -> GetTimeBase(This,pTimeBase)

#define IWMStreamConfig2_SetTimeBase(This,pTimeBase)	\
    (This)->lpVtbl -> SetTimeBase(This,pTimeBase)

#define IWMStreamConfig2_GetLanguageID(This,pwszRFC1766LangID,pcchLangID)	\
    (This)->lpVtbl -> GetLanguageID(This,pwszRFC1766LangID,pcchLangID)

#define IWMStreamConfig2_SetLanguageID(This,pwszRFC1766LangID)	\
    (This)->lpVtbl -> SetLanguageID(This,pwszRFC1766LangID)

#define IWMStreamConfig2_AddDataUnitExtension(This,guidExtensionSystemID,cbExtensionDataSize,pbExtensionSystemInfo,cbExtensionSystemInfo)	\
    (This)->lpVtbl -> AddDataUnitExtension(This,guidExtensionSystemID,cbExtensionDataSize,pbExtensionSystemInfo,cbExtensionSystemInfo)

#define IWMStreamConfig2_GetDataUnitExtensionCount(This,pcDataUnitExtensions)	\
    (This)->lpVtbl -> GetDataUnitExtensionCount(This,pcDataUnitExtensions)

#define IWMStreamConfig2_GetDataUnitExtension(This,wDataUnitExtensionNumber,pguidExtensionSystemID,pcbExtensionDataSize,pbExtensionSystemInfo,pcbExtensionSystemInfo)	\
    (This)->lpVtbl -> GetDataUnitExtension(This,wDataUnitExtensionNumber,pguidExtensionSystemID,pcbExtensionDataSize,pbExtensionSystemInfo,pcbExtensionSystemInfo)

#define IWMStreamConfig2_RemoveAllDataUnitExtensions(This)	\
    (This)->lpVtbl -> RemoveAllDataUnitExtensions(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamConfig2_GetTransportType_Proxy( 
    IWMStreamConfig2 __RPC_FAR * This,
    /* [out] */ WMT_TRANSPORT_TYPE __RPC_FAR *pnTransportType);


void __RPC_STUB IWMStreamConfig2_GetTransportType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_SetTransportType_Proxy( 
    IWMStreamConfig2 __RPC_FAR * This,
    /* [in] */ WMT_TRANSPORT_TYPE nTransportType);


void __RPC_STUB IWMStreamConfig2_SetTransportType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_GetTimeBase_Proxy( 
    IWMStreamConfig2 __RPC_FAR * This,
    /* [out] */ WMT_TIMEBASE __RPC_FAR *pTimeBase);


void __RPC_STUB IWMStreamConfig2_GetTimeBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_SetTimeBase_Proxy( 
    IWMStreamConfig2 __RPC_FAR * This,
    /* [in] */ WMT_TIMEBASE __RPC_FAR *pTimeBase);


void __RPC_STUB IWMStreamConfig2_SetTimeBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_GetLanguageID_Proxy( 
    IWMStreamConfig2 __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszRFC1766LangID,
    /* [out][in] */ DWORD __RPC_FAR *pcchLangID);


void __RPC_STUB IWMStreamConfig2_GetLanguageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_SetLanguageID_Proxy( 
    IWMStreamConfig2 __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszRFC1766LangID);


void __RPC_STUB IWMStreamConfig2_SetLanguageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_AddDataUnitExtension_Proxy( 
    IWMStreamConfig2 __RPC_FAR * This,
    /* [in] */ GUID guidExtensionSystemID,
    /* [in] */ WORD cbExtensionDataSize,
    /* [in] */ BYTE __RPC_FAR *pbExtensionSystemInfo,
    /* [in] */ DWORD cbExtensionSystemInfo);


void __RPC_STUB IWMStreamConfig2_AddDataUnitExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_GetDataUnitExtensionCount_Proxy( 
    IWMStreamConfig2 __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcDataUnitExtensions);


void __RPC_STUB IWMStreamConfig2_GetDataUnitExtensionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_GetDataUnitExtension_Proxy( 
    IWMStreamConfig2 __RPC_FAR * This,
    /* [in] */ WORD wDataUnitExtensionNumber,
    /* [out] */ GUID __RPC_FAR *pguidExtensionSystemID,
    /* [out] */ WORD __RPC_FAR *pcbExtensionDataSize,
    /* [out] */ BYTE __RPC_FAR *pbExtensionSystemInfo,
    /* [out] */ DWORD __RPC_FAR *pcbExtensionSystemInfo);


void __RPC_STUB IWMStreamConfig2_GetDataUnitExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamConfig2_RemoveAllDataUnitExtensions_Proxy( 
    IWMStreamConfig2 __RPC_FAR * This);


void __RPC_STUB IWMStreamConfig2_RemoveAllDataUnitExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamConfig2_INTERFACE_DEFINED__ */


#ifndef __IWMPacketSize_INTERFACE_DEFINED__
#define __IWMPacketSize_INTERFACE_DEFINED__

/* interface IWMPacketSize */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPacketSize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CDFB97AB-188F-40b3-B643-5B7903975C59")
    IWMPacketSize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxPacketSize( 
            /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxPacketSize( 
            /* [in] */ DWORD dwMaxPacketSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPacketSizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPacketSize __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPacketSize __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPacketSize __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxPacketSize )( 
            IWMPacketSize __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxPacketSize )( 
            IWMPacketSize __RPC_FAR * This,
            /* [in] */ DWORD dwMaxPacketSize);
        
        END_INTERFACE
    } IWMPacketSizeVtbl;

    interface IWMPacketSize
    {
        CONST_VTBL struct IWMPacketSizeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPacketSize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPacketSize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPacketSize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPacketSize_GetMaxPacketSize(This,pdwMaxPacketSize)	\
    (This)->lpVtbl -> GetMaxPacketSize(This,pdwMaxPacketSize)

#define IWMPacketSize_SetMaxPacketSize(This,dwMaxPacketSize)	\
    (This)->lpVtbl -> SetMaxPacketSize(This,dwMaxPacketSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPacketSize_GetMaxPacketSize_Proxy( 
    IWMPacketSize __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize);


void __RPC_STUB IWMPacketSize_GetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPacketSize_SetMaxPacketSize_Proxy( 
    IWMPacketSize __RPC_FAR * This,
    /* [in] */ DWORD dwMaxPacketSize);


void __RPC_STUB IWMPacketSize_SetMaxPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPacketSize_INTERFACE_DEFINED__ */


#ifndef __IWMPacketSize2_INTERFACE_DEFINED__
#define __IWMPacketSize2_INTERFACE_DEFINED__

/* interface IWMPacketSize2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPacketSize2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8BFC2B9E-B646-4233-A877-1C6A079669DC")
    IWMPacketSize2 : public IWMPacketSize
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMinPacketSize( 
            /* [out] */ DWORD __RPC_FAR *pdwMinPacketSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMinPacketSize( 
            /* [in] */ DWORD dwMinPacketSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPacketSize2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMPacketSize2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMPacketSize2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMPacketSize2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxPacketSize )( 
            IWMPacketSize2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMaxPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxPacketSize )( 
            IWMPacketSize2 __RPC_FAR * This,
            /* [in] */ DWORD dwMaxPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMinPacketSize )( 
            IWMPacketSize2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMinPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMinPacketSize )( 
            IWMPacketSize2 __RPC_FAR * This,
            /* [in] */ DWORD dwMinPacketSize);
        
        END_INTERFACE
    } IWMPacketSize2Vtbl;

    interface IWMPacketSize2
    {
        CONST_VTBL struct IWMPacketSize2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPacketSize2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMPacketSize2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMPacketSize2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMPacketSize2_GetMaxPacketSize(This,pdwMaxPacketSize)	\
    (This)->lpVtbl -> GetMaxPacketSize(This,pdwMaxPacketSize)

#define IWMPacketSize2_SetMaxPacketSize(This,dwMaxPacketSize)	\
    (This)->lpVtbl -> SetMaxPacketSize(This,dwMaxPacketSize)


#define IWMPacketSize2_GetMinPacketSize(This,pdwMinPacketSize)	\
    (This)->lpVtbl -> GetMinPacketSize(This,pdwMinPacketSize)

#define IWMPacketSize2_SetMinPacketSize(This,dwMinPacketSize)	\
    (This)->lpVtbl -> SetMinPacketSize(This,dwMinPacketSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMPacketSize2_GetMinPacketSize_Proxy( 
    IWMPacketSize2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMinPacketSize);


void __RPC_STUB IWMPacketSize2_GetMinPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMPacketSize2_SetMinPacketSize_Proxy( 
    IWMPacketSize2 __RPC_FAR * This,
    /* [in] */ DWORD dwMinPacketSize);


void __RPC_STUB IWMPacketSize2_SetMinPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMPacketSize2_INTERFACE_DEFINED__ */


#ifndef __IWMStreamList_INTERFACE_DEFINED__
#define __IWMStreamList_INTERFACE_DEFINED__

/* interface IWMStreamList */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDD-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreams( 
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStreamList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStreamList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreams )( 
            IWMStreamList __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMStreamList __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        END_INTERFACE
    } IWMStreamListVtbl;

    interface IWMStreamList
    {
        CONST_VTBL struct IWMStreamListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamList_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMStreamList_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMStreamList_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamList_GetStreams_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
    /* [out][in] */ WORD __RPC_FAR *pcStreams);


void __RPC_STUB IWMStreamList_GetStreams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamList_AddStream_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamList_AddStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamList_RemoveStream_Proxy( 
    IWMStreamList __RPC_FAR * This,
    /* [in] */ WORD wStreamNum);


void __RPC_STUB IWMStreamList_RemoveStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamList_INTERFACE_DEFINED__ */


#ifndef __IWMMutualExclusion_INTERFACE_DEFINED__
#define __IWMMutualExclusion_INTERFACE_DEFINED__

/* interface IWMMutualExclusion */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMutualExclusion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMutualExclusion : public IWMStreamList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID __RPC_FAR *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ REFGUID guidType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMutualExclusionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMutualExclusion __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMutualExclusion __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreams )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetType )( 
            IWMMutualExclusion __RPC_FAR * This,
            /* [in] */ REFGUID guidType);
        
        END_INTERFACE
    } IWMMutualExclusionVtbl;

    interface IWMMutualExclusion
    {
        CONST_VTBL struct IWMMutualExclusionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMutualExclusion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMutualExclusion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMutualExclusion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMutualExclusion_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMMutualExclusion_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMMutualExclusion_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)


#define IWMMutualExclusion_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMutualExclusion_SetType(This,guidType)	\
    (This)->lpVtbl -> SetType(This,guidType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMutualExclusion_GetType_Proxy( 
    IWMMutualExclusion __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidType);


void __RPC_STUB IWMMutualExclusion_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion_SetType_Proxy( 
    IWMMutualExclusion __RPC_FAR * This,
    /* [in] */ REFGUID guidType);


void __RPC_STUB IWMMutualExclusion_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMutualExclusion_INTERFACE_DEFINED__ */


#ifndef __IWMMutualExclusion2_INTERFACE_DEFINED__
#define __IWMMutualExclusion2_INTERFACE_DEFINED__

/* interface IWMMutualExclusion2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMutualExclusion2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0302B57D-89D1-4ba2-85C9-166F2C53EB91")
    IWMMutualExclusion2 : public IWMMutualExclusion
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ WCHAR __RPC_FAR *pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCount( 
            /* [out] */ WORD __RPC_FAR *pwRecordCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRecord( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveRecord( 
            /* [in] */ WORD wRecordNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordName( 
            /* [in] */ WORD wRecordNumber,
            /* [out] */ WCHAR __RPC_FAR *pwszRecordName,
            /* [out][in] */ WORD __RPC_FAR *pcchRecordName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecordName( 
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WCHAR __RPC_FAR *pwszRecordName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamsForRecord( 
            /* [in] */ WORD wRecordNumber,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStreamForRecord( 
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WORD wStreamNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamForRecord( 
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WORD wStreamNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMutualExclusion2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMMutualExclusion2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMMutualExclusion2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreams )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetType )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [in] */ WCHAR __RPC_FAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecordCount )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwRecordCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRecord )( 
            IWMMutualExclusion2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveRecord )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [in] */ WORD wRecordNumber);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecordName )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [in] */ WORD wRecordNumber,
            /* [out] */ WCHAR __RPC_FAR *pwszRecordName,
            /* [out][in] */ WORD __RPC_FAR *pcchRecordName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRecordName )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WCHAR __RPC_FAR *pwszRecordName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamsForRecord )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [in] */ WORD wRecordNumber,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStreamForRecord )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WORD wStreamNumber);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStreamForRecord )( 
            IWMMutualExclusion2 __RPC_FAR * This,
            /* [in] */ WORD wRecordNumber,
            /* [in] */ WORD wStreamNumber);
        
        END_INTERFACE
    } IWMMutualExclusion2Vtbl;

    interface IWMMutualExclusion2
    {
        CONST_VTBL struct IWMMutualExclusion2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMutualExclusion2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMMutualExclusion2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMMutualExclusion2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMMutualExclusion2_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMMutualExclusion2_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMMutualExclusion2_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)


#define IWMMutualExclusion2_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMMutualExclusion2_SetType(This,guidType)	\
    (This)->lpVtbl -> SetType(This,guidType)


#define IWMMutualExclusion2_GetName(This,pwszName,pcchName)	\
    (This)->lpVtbl -> GetName(This,pwszName,pcchName)

#define IWMMutualExclusion2_SetName(This,pwszName)	\
    (This)->lpVtbl -> SetName(This,pwszName)

#define IWMMutualExclusion2_GetRecordCount(This,pwRecordCount)	\
    (This)->lpVtbl -> GetRecordCount(This,pwRecordCount)

#define IWMMutualExclusion2_AddRecord(This)	\
    (This)->lpVtbl -> AddRecord(This)

#define IWMMutualExclusion2_RemoveRecord(This,wRecordNumber)	\
    (This)->lpVtbl -> RemoveRecord(This,wRecordNumber)

#define IWMMutualExclusion2_GetRecordName(This,wRecordNumber,pwszRecordName,pcchRecordName)	\
    (This)->lpVtbl -> GetRecordName(This,wRecordNumber,pwszRecordName,pcchRecordName)

#define IWMMutualExclusion2_SetRecordName(This,wRecordNumber,pwszRecordName)	\
    (This)->lpVtbl -> SetRecordName(This,wRecordNumber,pwszRecordName)

#define IWMMutualExclusion2_GetStreamsForRecord(This,wRecordNumber,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreamsForRecord(This,wRecordNumber,pwStreamNumArray,pcStreams)

#define IWMMutualExclusion2_AddStreamForRecord(This,wRecordNumber,wStreamNumber)	\
    (This)->lpVtbl -> AddStreamForRecord(This,wRecordNumber,wStreamNumber)

#define IWMMutualExclusion2_RemoveStreamForRecord(This,wRecordNumber,wStreamNumber)	\
    (This)->lpVtbl -> RemoveStreamForRecord(This,wRecordNumber,wStreamNumber)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_GetName_Proxy( 
    IWMMutualExclusion2 __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchName);


void __RPC_STUB IWMMutualExclusion2_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_SetName_Proxy( 
    IWMMutualExclusion2 __RPC_FAR * This,
    /* [in] */ WCHAR __RPC_FAR *pwszName);


void __RPC_STUB IWMMutualExclusion2_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_GetRecordCount_Proxy( 
    IWMMutualExclusion2 __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pwRecordCount);


void __RPC_STUB IWMMutualExclusion2_GetRecordCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_AddRecord_Proxy( 
    IWMMutualExclusion2 __RPC_FAR * This);


void __RPC_STUB IWMMutualExclusion2_AddRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_RemoveRecord_Proxy( 
    IWMMutualExclusion2 __RPC_FAR * This,
    /* [in] */ WORD wRecordNumber);


void __RPC_STUB IWMMutualExclusion2_RemoveRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_GetRecordName_Proxy( 
    IWMMutualExclusion2 __RPC_FAR * This,
    /* [in] */ WORD wRecordNumber,
    /* [out] */ WCHAR __RPC_FAR *pwszRecordName,
    /* [out][in] */ WORD __RPC_FAR *pcchRecordName);


void __RPC_STUB IWMMutualExclusion2_GetRecordName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_SetRecordName_Proxy( 
    IWMMutualExclusion2 __RPC_FAR * This,
    /* [in] */ WORD wRecordNumber,
    /* [in] */ WCHAR __RPC_FAR *pwszRecordName);


void __RPC_STUB IWMMutualExclusion2_SetRecordName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_GetStreamsForRecord_Proxy( 
    IWMMutualExclusion2 __RPC_FAR * This,
    /* [in] */ WORD wRecordNumber,
    /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
    /* [out][in] */ WORD __RPC_FAR *pcStreams);


void __RPC_STUB IWMMutualExclusion2_GetStreamsForRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_AddStreamForRecord_Proxy( 
    IWMMutualExclusion2 __RPC_FAR * This,
    /* [in] */ WORD wRecordNumber,
    /* [in] */ WORD wStreamNumber);


void __RPC_STUB IWMMutualExclusion2_AddStreamForRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMMutualExclusion2_RemoveStreamForRecord_Proxy( 
    IWMMutualExclusion2 __RPC_FAR * This,
    /* [in] */ WORD wRecordNumber,
    /* [in] */ WORD wStreamNumber);


void __RPC_STUB IWMMutualExclusion2_RemoveStreamForRecord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMMutualExclusion2_INTERFACE_DEFINED__ */


#ifndef __IWMBandwidthSharing_INTERFACE_DEFINED__
#define __IWMBandwidthSharing_INTERFACE_DEFINED__

/* interface IWMBandwidthSharing */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMBandwidthSharing;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AD694AF1-F8D9-42F8-BC47-70311B0C4F9E")
    IWMBandwidthSharing : public IWMStreamList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID __RPC_FAR *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ REFGUID guidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidth( 
            /* [out] */ DWORD __RPC_FAR *pdwBitrate,
            /* [out] */ DWORD __RPC_FAR *pmsBufferWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBandwidth( 
            /* [in] */ DWORD dwBitrate,
            /* [in] */ DWORD msBufferWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMBandwidthSharingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMBandwidthSharing __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMBandwidthSharing __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMBandwidthSharing __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreams )( 
            IWMBandwidthSharing __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pwStreamNumArray,
            /* [out][in] */ WORD __RPC_FAR *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStream )( 
            IWMBandwidthSharing __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStream )( 
            IWMBandwidthSharing __RPC_FAR * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IWMBandwidthSharing __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetType )( 
            IWMBandwidthSharing __RPC_FAR * This,
            /* [in] */ REFGUID guidType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBandwidth )( 
            IWMBandwidthSharing __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwBitrate,
            /* [out] */ DWORD __RPC_FAR *pmsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBandwidth )( 
            IWMBandwidthSharing __RPC_FAR * This,
            /* [in] */ DWORD dwBitrate,
            /* [in] */ DWORD msBufferWindow);
        
        END_INTERFACE
    } IWMBandwidthSharingVtbl;

    interface IWMBandwidthSharing
    {
        CONST_VTBL struct IWMBandwidthSharingVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMBandwidthSharing_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMBandwidthSharing_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMBandwidthSharing_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMBandwidthSharing_GetStreams(This,pwStreamNumArray,pcStreams)	\
    (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams)

#define IWMBandwidthSharing_AddStream(This,wStreamNum)	\
    (This)->lpVtbl -> AddStream(This,wStreamNum)

#define IWMBandwidthSharing_RemoveStream(This,wStreamNum)	\
    (This)->lpVtbl -> RemoveStream(This,wStreamNum)


#define IWMBandwidthSharing_GetType(This,pguidType)	\
    (This)->lpVtbl -> GetType(This,pguidType)

#define IWMBandwidthSharing_SetType(This,guidType)	\
    (This)->lpVtbl -> SetType(This,guidType)

#define IWMBandwidthSharing_GetBandwidth(This,pdwBitrate,pmsBufferWindow)	\
    (This)->lpVtbl -> GetBandwidth(This,pdwBitrate,pmsBufferWindow)

#define IWMBandwidthSharing_SetBandwidth(This,dwBitrate,msBufferWindow)	\
    (This)->lpVtbl -> SetBandwidth(This,dwBitrate,msBufferWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMBandwidthSharing_GetType_Proxy( 
    IWMBandwidthSharing __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguidType);


void __RPC_STUB IWMBandwidthSharing_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBandwidthSharing_SetType_Proxy( 
    IWMBandwidthSharing __RPC_FAR * This,
    /* [in] */ REFGUID guidType);


void __RPC_STUB IWMBandwidthSharing_SetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBandwidthSharing_GetBandwidth_Proxy( 
    IWMBandwidthSharing __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwBitrate,
    /* [out] */ DWORD __RPC_FAR *pmsBufferWindow);


void __RPC_STUB IWMBandwidthSharing_GetBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBandwidthSharing_SetBandwidth_Proxy( 
    IWMBandwidthSharing __RPC_FAR * This,
    /* [in] */ DWORD dwBitrate,
    /* [in] */ DWORD msBufferWindow);


void __RPC_STUB IWMBandwidthSharing_SetBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMBandwidthSharing_INTERFACE_DEFINED__ */


#ifndef __IWMStreamPrioritization_INTERFACE_DEFINED__
#define __IWMStreamPrioritization_INTERFACE_DEFINED__

/* interface IWMStreamPrioritization */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamPrioritization;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8C1C6090-F9A8-4748-8EC3-DD1108BA1E77")
    IWMStreamPrioritization : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPriorityRecords( 
            /* [out] */ WM_STREAM_PRIORITY_RECORD __RPC_FAR *pRecordArray,
            /* [out] */ WORD __RPC_FAR *pcRecords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriorityRecords( 
            /* [in] */ WM_STREAM_PRIORITY_RECORD __RPC_FAR *pRecordArray,
            /* [in] */ WORD cRecords) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamPrioritizationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMStreamPrioritization __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMStreamPrioritization __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMStreamPrioritization __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPriorityRecords )( 
            IWMStreamPrioritization __RPC_FAR * This,
            /* [out] */ WM_STREAM_PRIORITY_RECORD __RPC_FAR *pRecordArray,
            /* [out] */ WORD __RPC_FAR *pcRecords);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPriorityRecords )( 
            IWMStreamPrioritization __RPC_FAR * This,
            /* [in] */ WM_STREAM_PRIORITY_RECORD __RPC_FAR *pRecordArray,
            /* [in] */ WORD cRecords);
        
        END_INTERFACE
    } IWMStreamPrioritizationVtbl;

    interface IWMStreamPrioritization
    {
        CONST_VTBL struct IWMStreamPrioritizationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamPrioritization_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMStreamPrioritization_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMStreamPrioritization_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMStreamPrioritization_GetPriorityRecords(This,pRecordArray,pcRecords)	\
    (This)->lpVtbl -> GetPriorityRecords(This,pRecordArray,pcRecords)

#define IWMStreamPrioritization_SetPriorityRecords(This,pRecordArray,cRecords)	\
    (This)->lpVtbl -> SetPriorityRecords(This,pRecordArray,cRecords)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMStreamPrioritization_GetPriorityRecords_Proxy( 
    IWMStreamPrioritization __RPC_FAR * This,
    /* [out] */ WM_STREAM_PRIORITY_RECORD __RPC_FAR *pRecordArray,
    /* [out] */ WORD __RPC_FAR *pcRecords);


void __RPC_STUB IWMStreamPrioritization_GetPriorityRecords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMStreamPrioritization_SetPriorityRecords_Proxy( 
    IWMStreamPrioritization __RPC_FAR * This,
    /* [in] */ WM_STREAM_PRIORITY_RECORD __RPC_FAR *pRecordArray,
    /* [in] */ WORD cRecords);


void __RPC_STUB IWMStreamPrioritization_SetPriorityRecords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMStreamPrioritization_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced_INTERFACE_DEFINED__
#define __IWMWriterAdvanced_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE3-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSinkCount( 
            /* [out] */ DWORD __RPC_FAR *pcSinks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSink( 
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSink( 
            /* [in] */ IWMWriterSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSink( 
            /* [in] */ IWMWriterSink __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLiveSource( 
            BOOL fIsLiveSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL __RPC_FAR *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriterTime( 
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncTolerance( 
            /* [in] */ DWORD msWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncTolerance( 
            /* [out] */ DWORD __RPC_FAR *pmsWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSinkCount )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSink )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteStreamSample )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLiveSource )( 
            IWMWriterAdvanced __RPC_FAR * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWriterTime )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSyncTolerance )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSyncTolerance )( 
            IWMWriterAdvanced __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsWindow);
        
        END_INTERFACE
    } IWMWriterAdvancedVtbl;

    interface IWMWriterAdvanced
    {
        CONST_VTBL struct IWMWriterAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSinkCount_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcSinks);


void __RPC_STUB IWMWriterAdvanced_GetSinkCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwSinkNum,
    /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);


void __RPC_STUB IWMWriterAdvanced_GetSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_AddSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ IWMWriterSink __RPC_FAR *pSink);


void __RPC_STUB IWMWriterAdvanced_AddSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_RemoveSink_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ IWMWriterSink __RPC_FAR *pSink);


void __RPC_STUB IWMWriterAdvanced_RemoveSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_WriteStreamSample_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD msSampleSendTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample);


void __RPC_STUB IWMWriterAdvanced_WriteStreamSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_SetLiveSource_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    BOOL fIsLiveSource);


void __RPC_STUB IWMWriterAdvanced_SetLiveSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_IsRealTime_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfRealTime);


void __RPC_STUB IWMWriterAdvanced_IsRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetWriterTime_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);


void __RPC_STUB IWMWriterAdvanced_GetWriterTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetStatistics_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);


void __RPC_STUB IWMWriterAdvanced_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_SetSyncTolerance_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [in] */ DWORD msWindow);


void __RPC_STUB IWMWriterAdvanced_SetSyncTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced_GetSyncTolerance_Proxy( 
    IWMWriterAdvanced __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pmsWindow);


void __RPC_STUB IWMWriterAdvanced_GetSyncTolerance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced2_INTERFACE_DEFINED__
#define __IWMWriterAdvanced2_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("962dc1ec-c046-4db8-9cc7-26ceae500817")
    IWMWriterAdvanced2 : public IWMWriterAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterAdvanced2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSinkCount )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSink )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteStreamSample )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLiveSource )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWriterTime )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSyncTolerance )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSyncTolerance )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputSetting )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputSetting )( 
            IWMWriterAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        END_INTERFACE
    } IWMWriterAdvanced2Vtbl;

    interface IWMWriterAdvanced2
    {
        CONST_VTBL struct IWMWriterAdvanced2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced2_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced2_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced2_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced2_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced2_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced2_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced2_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced2_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced2_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced2_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced2_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)


#define IWMWriterAdvanced2_GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)

#define IWMWriterAdvanced2_SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced2_GetInputSetting_Proxy( 
    IWMWriterAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMWriterAdvanced2_GetInputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced2_SetInputSetting_Proxy( 
    IWMWriterAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMWriterAdvanced2_SetInputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced3_INTERFACE_DEFINED__
#define __IWMWriterAdvanced3_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2cd6492d-7c37-4e76-9d3b-59261183a22e")
    IWMWriterAdvanced3 : public IWMWriterAdvanced2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatisticsEx( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS_EX __RPC_FAR *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNonBlocking( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvanced3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterAdvanced3 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterAdvanced3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSinkCount )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSink )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink __RPC_FAR *__RPC_FAR *ppSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSink )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveSink )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [in] */ IWMWriterSink __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteStreamSample )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLiveSource )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWriterTime )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS __RPC_FAR *pStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSyncTolerance )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSyncTolerance )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pmsWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputSetting )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInputSetting )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatisticsEx )( 
            IWMWriterAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS_EX __RPC_FAR *pStats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNonBlocking )( 
            IWMWriterAdvanced3 __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterAdvanced3Vtbl;

    interface IWMWriterAdvanced3
    {
        CONST_VTBL struct IWMWriterAdvanced3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterAdvanced3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterAdvanced3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterAdvanced3_GetSinkCount(This,pcSinks)	\
    (This)->lpVtbl -> GetSinkCount(This,pcSinks)

#define IWMWriterAdvanced3_GetSink(This,dwSinkNum,ppSink)	\
    (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink)

#define IWMWriterAdvanced3_AddSink(This,pSink)	\
    (This)->lpVtbl -> AddSink(This,pSink)

#define IWMWriterAdvanced3_RemoveSink(This,pSink)	\
    (This)->lpVtbl -> RemoveSink(This,pSink)

#define IWMWriterAdvanced3_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)

#define IWMWriterAdvanced3_SetLiveSource(This,fIsLiveSource)	\
    (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource)

#define IWMWriterAdvanced3_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterAdvanced3_GetWriterTime(This,pcnsCurrentTime)	\
    (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime)

#define IWMWriterAdvanced3_GetStatistics(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats)

#define IWMWriterAdvanced3_SetSyncTolerance(This,msWindow)	\
    (This)->lpVtbl -> SetSyncTolerance(This,msWindow)

#define IWMWriterAdvanced3_GetSyncTolerance(This,pmsWindow)	\
    (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow)


#define IWMWriterAdvanced3_GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)

#define IWMWriterAdvanced3_SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)


#define IWMWriterAdvanced3_GetStatisticsEx(This,wStreamNum,pStats)	\
    (This)->lpVtbl -> GetStatisticsEx(This,wStreamNum,pStats)

#define IWMWriterAdvanced3_SetNonBlocking(This)	\
    (This)->lpVtbl -> SetNonBlocking(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterAdvanced3_GetStatisticsEx_Proxy( 
    IWMWriterAdvanced3 __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WM_WRITER_STATISTICS_EX __RPC_FAR *pStats);


void __RPC_STUB IWMWriterAdvanced3_GetStatisticsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterAdvanced3_SetNonBlocking_Proxy( 
    IWMWriterAdvanced3 __RPC_FAR * This);


void __RPC_STUB IWMWriterAdvanced3_SetNonBlocking_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterAdvanced3_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPreprocess_INTERFACE_DEFINED__
#define __IWMWriterPreprocess_INTERFACE_DEFINED__

/* interface IWMWriterPreprocess */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPreprocess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc54a285-38c4-45b5-aa23-85b9f7cb424b")
    IWMWriterPreprocess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxPreprocessingPasses( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD __RPC_FAR *pdwMaxNumPasses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNumPreprocessingPasses( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwNumPasses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginPreprocessingPass( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PreprocessSample( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndPreprocessingPass( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPreprocessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterPreprocess __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterPreprocess __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterPreprocess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxPreprocessingPasses )( 
            IWMWriterPreprocess __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD __RPC_FAR *pdwMaxNumPasses);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNumPreprocessingPasses )( 
            IWMWriterPreprocess __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwNumPasses);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginPreprocessingPass )( 
            IWMWriterPreprocess __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PreprocessSample )( 
            IWMWriterPreprocess __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndPreprocessingPass )( 
            IWMWriterPreprocess __RPC_FAR * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IWMWriterPreprocessVtbl;

    interface IWMWriterPreprocess
    {
        CONST_VTBL struct IWMWriterPreprocessVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPreprocess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPreprocess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPreprocess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPreprocess_GetMaxPreprocessingPasses(This,dwInputNum,dwFlags,pdwMaxNumPasses)	\
    (This)->lpVtbl -> GetMaxPreprocessingPasses(This,dwInputNum,dwFlags,pdwMaxNumPasses)

#define IWMWriterPreprocess_SetNumPreprocessingPasses(This,dwInputNum,dwFlags,dwNumPasses)	\
    (This)->lpVtbl -> SetNumPreprocessingPasses(This,dwInputNum,dwFlags,dwNumPasses)

#define IWMWriterPreprocess_BeginPreprocessingPass(This,dwInputNum,dwFlags)	\
    (This)->lpVtbl -> BeginPreprocessingPass(This,dwInputNum,dwFlags)

#define IWMWriterPreprocess_PreprocessSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)	\
    (This)->lpVtbl -> PreprocessSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)

#define IWMWriterPreprocess_EndPreprocessingPass(This,dwInputNum,dwFlags)	\
    (This)->lpVtbl -> EndPreprocessingPass(This,dwInputNum,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPreprocess_GetMaxPreprocessingPasses_Proxy( 
    IWMWriterPreprocess __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ DWORD dwFlags,
    /* [out] */ DWORD __RPC_FAR *pdwMaxNumPasses);


void __RPC_STUB IWMWriterPreprocess_GetMaxPreprocessingPasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPreprocess_SetNumPreprocessingPasses_Proxy( 
    IWMWriterPreprocess __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwNumPasses);


void __RPC_STUB IWMWriterPreprocess_SetNumPreprocessingPasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPreprocess_BeginPreprocessingPass_Proxy( 
    IWMWriterPreprocess __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMWriterPreprocess_BeginPreprocessingPass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPreprocess_PreprocessSample_Proxy( 
    IWMWriterPreprocess __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample);


void __RPC_STUB IWMWriterPreprocess_PreprocessSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPreprocess_EndPreprocessingPass_Proxy( 
    IWMWriterPreprocess __RPC_FAR * This,
    /* [in] */ DWORD dwInputNum,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMWriterPreprocess_EndPreprocessingPass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPreprocess_INTERFACE_DEFINED__ */


#ifndef __IWMDRMWriter_INTERFACE_DEFINED__
#define __IWMDRMWriter_INTERFACE_DEFINED__

/* interface IWMDRMWriter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMDRMWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d6ea5dd0-12a0-43f4-90ab-a3fd451e6a07")
    IWMDRMWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GenerateKeySeed( 
            /* [out] */ WCHAR __RPC_FAR *pwszKeySeed,
            /* [out][in] */ DWORD __RPC_FAR *pcwchLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateKeyID( 
            /* [out] */ WCHAR __RPC_FAR *pwszKeyID,
            /* [out][in] */ DWORD __RPC_FAR *pcwchLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateSigningKeyPair( 
            /* [out] */ WCHAR __RPC_FAR *pwszPrivKey,
            /* [out][in] */ DWORD __RPC_FAR *pcwchPrivKeyLength,
            /* [out] */ WCHAR __RPC_FAR *pwszPubKey,
            /* [out][in] */ DWORD __RPC_FAR *pcwchPubKeyLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDRMAttribute( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDRMWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDRMWriter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDRMWriter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDRMWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateKeySeed )( 
            IWMDRMWriter __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszKeySeed,
            /* [out][in] */ DWORD __RPC_FAR *pcwchLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateKeyID )( 
            IWMDRMWriter __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszKeyID,
            /* [out][in] */ DWORD __RPC_FAR *pcwchLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateSigningKeyPair )( 
            IWMDRMWriter __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszPrivKey,
            /* [out][in] */ DWORD __RPC_FAR *pcwchPrivKeyLength,
            /* [out] */ WCHAR __RPC_FAR *pwszPubKey,
            /* [out][in] */ DWORD __RPC_FAR *pcwchPubKeyLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDRMAttribute )( 
            IWMDRMWriter __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        END_INTERFACE
    } IWMDRMWriterVtbl;

    interface IWMDRMWriter
    {
        CONST_VTBL struct IWMDRMWriterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDRMWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDRMWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDRMWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDRMWriter_GenerateKeySeed(This,pwszKeySeed,pcwchLength)	\
    (This)->lpVtbl -> GenerateKeySeed(This,pwszKeySeed,pcwchLength)

#define IWMDRMWriter_GenerateKeyID(This,pwszKeyID,pcwchLength)	\
    (This)->lpVtbl -> GenerateKeyID(This,pwszKeyID,pcwchLength)

#define IWMDRMWriter_GenerateSigningKeyPair(This,pwszPrivKey,pcwchPrivKeyLength,pwszPubKey,pcwchPubKeyLength)	\
    (This)->lpVtbl -> GenerateSigningKeyPair(This,pwszPrivKey,pcwchPrivKeyLength,pwszPubKey,pcwchPubKeyLength)

#define IWMDRMWriter_SetDRMAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetDRMAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDRMWriter_GenerateKeySeed_Proxy( 
    IWMDRMWriter __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszKeySeed,
    /* [out][in] */ DWORD __RPC_FAR *pcwchLength);


void __RPC_STUB IWMDRMWriter_GenerateKeySeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMWriter_GenerateKeyID_Proxy( 
    IWMDRMWriter __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszKeyID,
    /* [out][in] */ DWORD __RPC_FAR *pcwchLength);


void __RPC_STUB IWMDRMWriter_GenerateKeyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMWriter_GenerateSigningKeyPair_Proxy( 
    IWMDRMWriter __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszPrivKey,
    /* [out][in] */ DWORD __RPC_FAR *pcwchPrivKeyLength,
    /* [out] */ WCHAR __RPC_FAR *pwszPubKey,
    /* [out][in] */ DWORD __RPC_FAR *pcwchPubKeyLength);


void __RPC_STUB IWMDRMWriter_GenerateSigningKeyPair_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMWriter_SetDRMAttribute_Proxy( 
    IWMDRMWriter __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMDRMWriter_SetDRMAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDRMWriter_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_INTERFACE_DEFINED__
#define __IWMWriterPostViewCallback_INTERFACE_DEFINED__

/* interface IWMWriterPostViewCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostViewCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D9D6549D-A193-4f24-B308-03123D9B7F8D")
    IWMWriterPostViewCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPostViewSample( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForPostView( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterPostViewCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterPostViewCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatus )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE __RPC_FAR *pValue,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnPostViewSample )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForPostView )( 
            IWMWriterPostViewCallback __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMWriterPostViewCallbackVtbl;

    interface IWMWriterPostViewCallback
    {
        CONST_VTBL struct IWMWriterPostViewCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostViewCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPostViewCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPostViewCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPostViewCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext)


#define IWMWriterPostViewCallback_OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#define IWMWriterPostViewCallback_AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPostViewCallback_OnPostViewSample_Proxy( 
    IWMWriterPostViewCallback __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostViewCallback_OnPostViewSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostViewCallback_AllocateForPostView_Proxy( 
    IWMWriterPostViewCallback __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostViewCallback_AllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPostViewCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostView_INTERFACE_DEFINED__
#define __IWMWriterPostView_INTERFACE_DEFINED__

/* interface IWMWriterPostView */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81E20CE4-75EF-491a-8004-FC53C45BDC3E")
    IWMWriterPostView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPostViewCallback( 
            IWMWriterPostViewCallback __RPC_FAR *pCallback,
            void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps __RPC_FAR *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormatCount( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormat( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterPostView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterPostView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPostViewCallback )( 
            IWMWriterPostView __RPC_FAR * This,
            IWMWriterPostViewCallback __RPC_FAR *pCallback,
            void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceivePostViewSamples )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceivePostViewSamples )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewProps )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPostViewProps )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps __RPC_FAR *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewFormatCount )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD __RPC_FAR *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPostViewFormat )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForPostView )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForPostView )( 
            IWMWriterPostView __RPC_FAR * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        END_INTERFACE
    } IWMWriterPostViewVtbl;

    interface IWMWriterPostView
    {
        CONST_VTBL struct IWMWriterPostViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPostView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPostView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPostView_SetPostViewCallback(This,pCallback,pvContext)	\
    (This)->lpVtbl -> SetPostViewCallback(This,pCallback,pvContext)

#define IWMWriterPostView_SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples)	\
    (This)->lpVtbl -> SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples)

#define IWMWriterPostView_GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples)	\
    (This)->lpVtbl -> GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples)

#define IWMWriterPostView_GetPostViewProps(This,wStreamNumber,ppOutput)	\
    (This)->lpVtbl -> GetPostViewProps(This,wStreamNumber,ppOutput)

#define IWMWriterPostView_SetPostViewProps(This,wStreamNumber,pOutput)	\
    (This)->lpVtbl -> SetPostViewProps(This,wStreamNumber,pOutput)

#define IWMWriterPostView_GetPostViewFormatCount(This,wStreamNumber,pcFormats)	\
    (This)->lpVtbl -> GetPostViewFormatCount(This,wStreamNumber,pcFormats)

#define IWMWriterPostView_GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps)	\
    (This)->lpVtbl -> GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps)

#define IWMWriterPostView_SetAllocateForPostView(This,wStreamNumber,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForPostView(This,wStreamNumber,fAllocate)

#define IWMWriterPostView_GetAllocateForPostView(This,wStreamNumber,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForPostView(This,wStreamNumber,pfAllocate)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetPostViewCallback_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    IWMWriterPostViewCallback __RPC_FAR *pCallback,
    void __RPC_FAR *pvContext);


void __RPC_STUB IWMWriterPostView_SetPostViewCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetReceivePostViewSamples_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fReceivePostViewSamples);


void __RPC_STUB IWMWriterPostView_SetReceivePostViewSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetReceivePostViewSamples_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL __RPC_FAR *pfReceivePostViewSamples);


void __RPC_STUB IWMWriterPostView_GetReceivePostViewSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewProps_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppOutput);


void __RPC_STUB IWMWriterPostView_GetPostViewProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetPostViewProps_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ IWMMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMWriterPostView_SetPostViewProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewFormatCount_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ DWORD __RPC_FAR *pcFormats);


void __RPC_STUB IWMWriterPostView_GetPostViewFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetPostViewFormat_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ DWORD dwFormatNumber,
    /* [out] */ IWMMediaProps __RPC_FAR *__RPC_FAR *ppProps);


void __RPC_STUB IWMWriterPostView_GetPostViewFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_SetAllocateForPostView_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMWriterPostView_SetAllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPostView_GetAllocateForPostView_Proxy( 
    IWMWriterPostView __RPC_FAR * This,
    /* [in] */ WORD wStreamNumber,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMWriterPostView_GetAllocateForPostView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPostView_INTERFACE_DEFINED__ */


#ifndef __IWMWriterSink_INTERFACE_DEFINED__
#define __IWMWriterSink_INTERFACE_DEFINED__

/* interface IWMWriterSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnHeader( 
            /* [in] */ INSSBuffer __RPC_FAR *pHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL __RPC_FAR *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateDataUnit( 
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataUnit( 
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndWriting( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterSinkVtbl;

    interface IWMWriterSink
    {
        CONST_VTBL struct IWMWriterSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterSink_OnHeader_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ INSSBuffer __RPC_FAR *pHeader);


void __RPC_STUB IWMWriterSink_OnHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_IsRealTime_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfRealTime);


void __RPC_STUB IWMWriterSink_IsRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_AllocateDataUnit_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ DWORD cbDataUnit,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);


void __RPC_STUB IWMWriterSink_AllocateDataUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_OnDataUnit_Proxy( 
    IWMWriterSink __RPC_FAR * This,
    /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);


void __RPC_STUB IWMWriterSink_OnDataUnit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterSink_OnEndWriting_Proxy( 
    IWMWriterSink __RPC_FAR * This);


void __RPC_STUB IWMWriterSink_OnEndWriting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterSink_INTERFACE_DEFINED__ */


#ifndef __IWMRegisterCallback_INTERFACE_DEFINED__
#define __IWMRegisterCallback_INTERFACE_DEFINED__

/* interface IWMRegisterCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMRegisterCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF4B1F99-4DE2-4e49-A363-252740D99BC1")
    IWMRegisterCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRegisterCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMRegisterCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMRegisterCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IWMRegisterCallback __RPC_FAR * This,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMRegisterCallbackVtbl;

    interface IWMRegisterCallback
    {
        CONST_VTBL struct IWMRegisterCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRegisterCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMRegisterCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMRegisterCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMRegisterCallback_Advise(This,pCallback,pvContext)	\
    (This)->lpVtbl -> Advise(This,pCallback,pvContext)

#define IWMRegisterCallback_Unadvise(This,pCallback,pvContext)	\
    (This)->lpVtbl -> Unadvise(This,pCallback,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMRegisterCallback_Advise_Proxy( 
    IWMRegisterCallback __RPC_FAR * This,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMRegisterCallback_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMRegisterCallback_Unadvise_Proxy( 
    IWMRegisterCallback __RPC_FAR * This,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMRegisterCallback_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMRegisterCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink_INTERFACE_DEFINED__
#define __IWMWriterFileSink_INTERFACE_DEFINED__

/* interface IWMWriterFileSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE5-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterFileSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterFileSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterFileSink __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        END_INTERFACE
    } IWMWriterFileSinkVtbl;

    interface IWMWriterFileSink
    {
        CONST_VTBL struct IWMWriterFileSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink_Open_Proxy( 
    IWMWriterFileSink __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMWriterFileSink_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink2_INTERFACE_DEFINED__
#define __IWMWriterFileSink2_INTERFACE_DEFINED__

/* interface IWMWriterFileSink2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14282BA7-4AEF-4205-8CE5-C229035A05BC")
    IWMWriterFileSink2 : public IWMWriterFileSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ QWORD cnsStopTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsStopped( 
            /* [out] */ BOOL __RPC_FAR *pfStopped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileDuration( 
            /* [out] */ QWORD __RPC_FAR *pcnsDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileSize( 
            /* [out] */ QWORD __RPC_FAR *pcbFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClosed( 
            /* [out] */ BOOL __RPC_FAR *pfClosed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSink2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStartTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStopTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsStopped )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfStopped);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileDuration )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsDuration);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileSize )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcbFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMWriterFileSink2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClosed )( 
            IWMWriterFileSink2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfClosed);
        
        END_INTERFACE
    } IWMWriterFileSink2Vtbl;

    interface IWMWriterFileSink2
    {
        CONST_VTBL struct IWMWriterFileSink2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink2_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink2_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink2_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink2_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink2_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink2_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)


#define IWMWriterFileSink2_Start(This,cnsStartTime)	\
    (This)->lpVtbl -> Start(This,cnsStartTime)

#define IWMWriterFileSink2_Stop(This,cnsStopTime)	\
    (This)->lpVtbl -> Stop(This,cnsStopTime)

#define IWMWriterFileSink2_IsStopped(This,pfStopped)	\
    (This)->lpVtbl -> IsStopped(This,pfStopped)

#define IWMWriterFileSink2_GetFileDuration(This,pcnsDuration)	\
    (This)->lpVtbl -> GetFileDuration(This,pcnsDuration)

#define IWMWriterFileSink2_GetFileSize(This,pcbFile)	\
    (This)->lpVtbl -> GetFileSize(This,pcbFile)

#define IWMWriterFileSink2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMWriterFileSink2_IsClosed(This,pfClosed)	\
    (This)->lpVtbl -> IsClosed(This,pfClosed)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Start_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStartTime);


void __RPC_STUB IWMWriterFileSink2_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Stop_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStopTime);


void __RPC_STUB IWMWriterFileSink2_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_IsStopped_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfStopped);


void __RPC_STUB IWMWriterFileSink2_IsStopped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_GetFileDuration_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsDuration);


void __RPC_STUB IWMWriterFileSink2_GetFileDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_GetFileSize_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcbFile);


void __RPC_STUB IWMWriterFileSink2_GetFileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_Close_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This);


void __RPC_STUB IWMWriterFileSink2_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink2_IsClosed_Proxy( 
    IWMWriterFileSink2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfClosed);


void __RPC_STUB IWMWriterFileSink2_IsClosed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink3_INTERFACE_DEFINED__
#define __IWMWriterFileSink3_INTERFACE_DEFINED__

/* interface IWMWriterFileSink3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3FEA4FEB-2945-47A7-A1DD-C53A8FC4C45C")
    IWMWriterFileSink3 : public IWMWriterFileSink2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAutoIndexing( 
            /* [in] */ BOOL fDoAutoIndexing) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAutoIndexing( 
            /* [out] */ BOOL __RPC_FAR *pfAutoIndexing) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMode( 
            /* [out] */ DWORD __RPC_FAR *pdwFileSinkMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataUnitEx( 
            /* [in] */ WMT_FILESINK_DATA_UNIT __RPC_FAR *pFileSinkDataUnit) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSink3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterFileSink3 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterFileSink3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterFileSink3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [in] */ QWORD cnsStartTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [in] */ QWORD cnsStopTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsStopped )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfStopped);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileDuration )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsDuration);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileSize )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcbFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMWriterFileSink3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClosed )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfClosed);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAutoIndexing )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [in] */ BOOL fDoAutoIndexing);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAutoIndexing )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfAutoIndexing);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMode )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwFileSinkMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnitEx )( 
            IWMWriterFileSink3 __RPC_FAR * This,
            /* [in] */ WMT_FILESINK_DATA_UNIT __RPC_FAR *pFileSinkDataUnit);
        
        END_INTERFACE
    } IWMWriterFileSink3Vtbl;

    interface IWMWriterFileSink3
    {
        CONST_VTBL struct IWMWriterFileSink3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterFileSink3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterFileSink3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterFileSink3_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterFileSink3_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterFileSink3_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterFileSink3_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterFileSink3_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterFileSink3_Open(This,pwszFilename)	\
    (This)->lpVtbl -> Open(This,pwszFilename)


#define IWMWriterFileSink3_Start(This,cnsStartTime)	\
    (This)->lpVtbl -> Start(This,cnsStartTime)

#define IWMWriterFileSink3_Stop(This,cnsStopTime)	\
    (This)->lpVtbl -> Stop(This,cnsStopTime)

#define IWMWriterFileSink3_IsStopped(This,pfStopped)	\
    (This)->lpVtbl -> IsStopped(This,pfStopped)

#define IWMWriterFileSink3_GetFileDuration(This,pcnsDuration)	\
    (This)->lpVtbl -> GetFileDuration(This,pcnsDuration)

#define IWMWriterFileSink3_GetFileSize(This,pcbFile)	\
    (This)->lpVtbl -> GetFileSize(This,pcbFile)

#define IWMWriterFileSink3_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IWMWriterFileSink3_IsClosed(This,pfClosed)	\
    (This)->lpVtbl -> IsClosed(This,pfClosed)


#define IWMWriterFileSink3_SetAutoIndexing(This,fDoAutoIndexing)	\
    (This)->lpVtbl -> SetAutoIndexing(This,fDoAutoIndexing)

#define IWMWriterFileSink3_GetAutoIndexing(This,pfAutoIndexing)	\
    (This)->lpVtbl -> GetAutoIndexing(This,pfAutoIndexing)

#define IWMWriterFileSink3_GetMode(This,pdwFileSinkMode)	\
    (This)->lpVtbl -> GetMode(This,pdwFileSinkMode)

#define IWMWriterFileSink3_OnDataUnitEx(This,pFileSinkDataUnit)	\
    (This)->lpVtbl -> OnDataUnitEx(This,pFileSinkDataUnit)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_SetAutoIndexing_Proxy( 
    IWMWriterFileSink3 __RPC_FAR * This,
    /* [in] */ BOOL fDoAutoIndexing);


void __RPC_STUB IWMWriterFileSink3_SetAutoIndexing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_GetAutoIndexing_Proxy( 
    IWMWriterFileSink3 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfAutoIndexing);


void __RPC_STUB IWMWriterFileSink3_GetAutoIndexing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_GetMode_Proxy( 
    IWMWriterFileSink3 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwFileSinkMode);


void __RPC_STUB IWMWriterFileSink3_GetMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterFileSink3_OnDataUnitEx_Proxy( 
    IWMWriterFileSink3 __RPC_FAR * This,
    /* [in] */ WMT_FILESINK_DATA_UNIT __RPC_FAR *pFileSinkDataUnit);


void __RPC_STUB IWMWriterFileSink3_OnDataUnitEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterFileSink3_INTERFACE_DEFINED__ */


#ifndef __IWMWriterNetworkSink_INTERFACE_DEFINED__
#define __IWMWriterNetworkSink_INTERFACE_DEFINED__

/* interface IWMWriterNetworkSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterNetworkSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE7-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterNetworkSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMaximumClients( 
            /* [in] */ DWORD dwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaximumClients( 
            /* [out] */ DWORD __RPC_FAR *pdwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkProtocol( 
            /* [in] */ WMT_NET_PROTOCOL protocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkProtocol( 
            /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostURL( 
            /* [out] */ WCHAR __RPC_FAR *pwszURL,
            /* [out][in] */ DWORD __RPC_FAR *pcchURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [out][in] */ DWORD __RPC_FAR *pdwPortNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterNetworkSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaximumClients )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ DWORD dwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaximumClients )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNetworkProtocol )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [in] */ WMT_NET_PROTOCOL protocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNetworkProtocol )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHostURL )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszURL,
            /* [out][in] */ DWORD __RPC_FAR *pcchURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IWMWriterNetworkSink __RPC_FAR * This,
            /* [out][in] */ DWORD __RPC_FAR *pdwPortNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IWMWriterNetworkSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterNetworkSinkVtbl;

    interface IWMWriterNetworkSink
    {
        CONST_VTBL struct IWMWriterNetworkSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterNetworkSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterNetworkSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterNetworkSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterNetworkSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterNetworkSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterNetworkSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterNetworkSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterNetworkSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterNetworkSink_SetMaximumClients(This,dwMaxClients)	\
    (This)->lpVtbl -> SetMaximumClients(This,dwMaxClients)

#define IWMWriterNetworkSink_GetMaximumClients(This,pdwMaxClients)	\
    (This)->lpVtbl -> GetMaximumClients(This,pdwMaxClients)

#define IWMWriterNetworkSink_SetNetworkProtocol(This,protocol)	\
    (This)->lpVtbl -> SetNetworkProtocol(This,protocol)

#define IWMWriterNetworkSink_GetNetworkProtocol(This,pProtocol)	\
    (This)->lpVtbl -> GetNetworkProtocol(This,pProtocol)

#define IWMWriterNetworkSink_GetHostURL(This,pwszURL,pcchURL)	\
    (This)->lpVtbl -> GetHostURL(This,pwszURL,pcchURL)

#define IWMWriterNetworkSink_Open(This,pdwPortNum)	\
    (This)->lpVtbl -> Open(This,pdwPortNum)

#define IWMWriterNetworkSink_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IWMWriterNetworkSink_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_SetMaximumClients_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [in] */ DWORD dwMaxClients);


void __RPC_STUB IWMWriterNetworkSink_SetMaximumClients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetMaximumClients_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMaxClients);


void __RPC_STUB IWMWriterNetworkSink_GetMaximumClients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_SetNetworkProtocol_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [in] */ WMT_NET_PROTOCOL protocol);


void __RPC_STUB IWMWriterNetworkSink_SetNetworkProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetNetworkProtocol_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ WMT_NET_PROTOCOL __RPC_FAR *pProtocol);


void __RPC_STUB IWMWriterNetworkSink_GetNetworkProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_GetHostURL_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszURL,
    /* [out][in] */ DWORD __RPC_FAR *pcchURL);


void __RPC_STUB IWMWriterNetworkSink_GetHostURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Open_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This,
    /* [out][in] */ DWORD __RPC_FAR *pdwPortNum);


void __RPC_STUB IWMWriterNetworkSink_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Disconnect_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This);


void __RPC_STUB IWMWriterNetworkSink_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterNetworkSink_Close_Proxy( 
    IWMWriterNetworkSink __RPC_FAR * This);


void __RPC_STUB IWMWriterNetworkSink_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterNetworkSink_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPushSink_INTERFACE_DEFINED__
#define __IWMWriterPushSink_INTERFACE_DEFINED__

/* interface IWMWriterPushSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPushSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc10e6a5-072c-467d-bf57-6330a9dde12a")
    IWMWriterPushSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ LPCWSTR pwszTemplateURL,
            /* [in] */ BOOL fAutoDestroy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndSession( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPushSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMWriterPushSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMWriterPushSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMWriterPushSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnHeader )( 
            IWMWriterPushSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsRealTime )( 
            IWMWriterPushSink __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateDataUnit )( 
            IWMWriterPushSink __RPC_FAR * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataUnit )( 
            IWMWriterPushSink __RPC_FAR * This,
            /* [in] */ INSSBuffer __RPC_FAR *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndWriting )( 
            IWMWriterPushSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IWMWriterPushSink __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ LPCWSTR pwszTemplateURL,
            /* [in] */ BOOL fAutoDestroy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IWMWriterPushSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndSession )( 
            IWMWriterPushSink __RPC_FAR * This);
        
        END_INTERFACE
    } IWMWriterPushSinkVtbl;

    interface IWMWriterPushSink
    {
        CONST_VTBL struct IWMWriterPushSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPushSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMWriterPushSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMWriterPushSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMWriterPushSink_OnHeader(This,pHeader)	\
    (This)->lpVtbl -> OnHeader(This,pHeader)

#define IWMWriterPushSink_IsRealTime(This,pfRealTime)	\
    (This)->lpVtbl -> IsRealTime(This,pfRealTime)

#define IWMWriterPushSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit)

#define IWMWriterPushSink_OnDataUnit(This,pDataUnit)	\
    (This)->lpVtbl -> OnDataUnit(This,pDataUnit)

#define IWMWriterPushSink_OnEndWriting(This)	\
    (This)->lpVtbl -> OnEndWriting(This)


#define IWMWriterPushSink_Connect(This,pwszURL,pwszTemplateURL,fAutoDestroy)	\
    (This)->lpVtbl -> Connect(This,pwszURL,pwszTemplateURL,fAutoDestroy)

#define IWMWriterPushSink_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IWMWriterPushSink_EndSession(This)	\
    (This)->lpVtbl -> EndSession(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMWriterPushSink_Connect_Proxy( 
    IWMWriterPushSink __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszURL,
    /* [in] */ LPCWSTR pwszTemplateURL,
    /* [in] */ BOOL fAutoDestroy);


void __RPC_STUB IWMWriterPushSink_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPushSink_Disconnect_Proxy( 
    IWMWriterPushSink __RPC_FAR * This);


void __RPC_STUB IWMWriterPushSink_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMWriterPushSink_EndSession_Proxy( 
    IWMWriterPushSink __RPC_FAR * This);


void __RPC_STUB IWMWriterPushSink_EndSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMWriterPushSink_INTERFACE_DEFINED__ */


#ifndef __IWMClientConnections_INTERFACE_DEFINED__
#define __IWMClientConnections_INTERFACE_DEFINED__

/* interface IWMClientConnections */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMClientConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73C66010-A299-41df-B1F0-CCF03B09C1C6")
    IWMClientConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClientCount( 
            /* [out] */ DWORD __RPC_FAR *pcClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClientProperties( 
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMClientConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMClientConnections __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMClientConnections __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMClientConnections __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientCount )( 
            IWMClientConnections __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcClients);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientProperties )( 
            IWMClientConnections __RPC_FAR * This,
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties);
        
        END_INTERFACE
    } IWMClientConnectionsVtbl;

    interface IWMClientConnections
    {
        CONST_VTBL struct IWMClientConnectionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMClientConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMClientConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMClientConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMClientConnections_GetClientCount(This,pcClients)	\
    (This)->lpVtbl -> GetClientCount(This,pcClients)

#define IWMClientConnections_GetClientProperties(This,dwClientNum,pClientProperties)	\
    (This)->lpVtbl -> GetClientProperties(This,dwClientNum,pClientProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMClientConnections_GetClientCount_Proxy( 
    IWMClientConnections __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcClients);


void __RPC_STUB IWMClientConnections_GetClientCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMClientConnections_GetClientProperties_Proxy( 
    IWMClientConnections __RPC_FAR * This,
    /* [in] */ DWORD dwClientNum,
    /* [out] */ WM_CLIENT_PROPERTIES __RPC_FAR *pClientProperties);


void __RPC_STUB IWMClientConnections_GetClientProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMClientConnections_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced_INTERFACE_DEFINED__
#define __IWMReaderAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEA-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetUserProvidedClock( 
            /* [in] */ BOOL fUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserProvidedClock( 
            /* [out] */ BOOL __RPC_FAR *pfUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeliverTime( 
            /* [in] */ QWORD cnsTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetManualStreamSelection( 
            /* [in] */ BOOL fSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManualStreamSelection( 
            /* [out] */ BOOL __RPC_FAR *pfSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamsSelected( 
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSelected( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveSelectionCallbacks( 
            /* [in] */ BOOL fGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveSelectionCallbacks( 
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForStream( 
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForStream( 
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientInfo( 
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxOutputSampleSize( 
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxStreamSampleSize( 
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyLateDelivery( 
            QWORD cnsLateness) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced __RPC_FAR * This,
            QWORD cnsLateness);
        
        END_INTERFACE
    } IWMReaderAdvancedVtbl;

    interface IWMReaderAdvanced
    {
        CONST_VTBL struct IWMReaderAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetUserProvidedClock_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fUserClock);


void __RPC_STUB IWMReaderAdvanced_SetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetUserProvidedClock_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfUserClock);


void __RPC_STUB IWMReaderAdvanced_GetUserProvidedClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_DeliverTime_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ QWORD cnsTime);


void __RPC_STUB IWMReaderAdvanced_DeliverTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetManualStreamSelection_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fSelection);


void __RPC_STUB IWMReaderAdvanced_SetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetManualStreamSelection_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfSelection);


void __RPC_STUB IWMReaderAdvanced_GetManualStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetStreamsSelected_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD cStreamCount,
    /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);


void __RPC_STUB IWMReaderAdvanced_SetStreamsSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStreamSelected_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);


void __RPC_STUB IWMReaderAdvanced_GetStreamSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL fGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_SetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveSelectionCallbacks_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);


void __RPC_STUB IWMReaderAdvanced_GetReceiveSelectionCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ BOOL fReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_SetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetReceiveStreamSamples_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);


void __RPC_STUB IWMReaderAdvanced_GetReceiveStreamSamples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForOutput_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForOutput_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetAllocateForStream_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD dwStreamNum,
    /* [in] */ BOOL fAllocate);


void __RPC_STUB IWMReaderAdvanced_SetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetAllocateForStream_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD dwSreamNum,
    /* [out] */ BOOL __RPC_FAR *pfAllocate);


void __RPC_STUB IWMReaderAdvanced_GetAllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetStatistics_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);


void __RPC_STUB IWMReaderAdvanced_GetStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_SetClientInfo_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);


void __RPC_STUB IWMReaderAdvanced_SetClientInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxOutputSampleSize_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutput,
    /* [out] */ DWORD __RPC_FAR *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxOutputSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_GetMaxStreamSampleSize_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStream,
    /* [out] */ DWORD __RPC_FAR *pcbMax);


void __RPC_STUB IWMReaderAdvanced_GetMaxStreamSampleSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced_NotifyLateDelivery_Proxy( 
    IWMReaderAdvanced __RPC_FAR * This,
    QWORD cnsLateness);


void __RPC_STUB IWMReaderAdvanced_NotifyLateDelivery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced2_INTERFACE_DEFINED__
#define __IWMReaderAdvanced2_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae14a945-b90c-4d0d-9127-80d665f7d73e")
    IWMReaderAdvanced2 : public IWMReaderAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPlayMode( 
            /* [in] */ WMT_PLAY_MODE Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayMode( 
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSaveAsProgress( 
            /* [out] */ DWORD __RPC_FAR *pdwPercent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveFileAs( 
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProtocolName( 
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAtMarker( 
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Preroll( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogClientID( 
            /* [in] */ BOOL fLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogClientID( 
            /* [out] */ BOOL __RPC_FAR *pfLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopBuffering( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenStream( 
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            QWORD cnsLateness);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayMode )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WMT_PLAY_MODE Mode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayMode )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDownloadProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaveAsProgress )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveFileAs )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtocolName )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAtMarker )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSetting )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSetting )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Preroll )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogClientID )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ BOOL fLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogClientID )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopBuffering )( 
            IWMReaderAdvanced2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenStream )( 
            IWMReaderAdvanced2 __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderAdvanced2Vtbl;

    interface IWMReaderAdvanced2
    {
        CONST_VTBL struct IWMReaderAdvanced2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced2_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced2_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced2_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced2_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced2_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced2_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced2_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced2_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced2_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced2_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced2_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced2_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced2_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced2_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced2_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced2_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced2_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced2_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced2_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)


#define IWMReaderAdvanced2_SetPlayMode(This,Mode)	\
    (This)->lpVtbl -> SetPlayMode(This,Mode)

#define IWMReaderAdvanced2_GetPlayMode(This,pMode)	\
    (This)->lpVtbl -> GetPlayMode(This,pMode)

#define IWMReaderAdvanced2_GetBufferProgress(This,pdwPercent,pcnsBuffering)	\
    (This)->lpVtbl -> GetBufferProgress(This,pdwPercent,pcnsBuffering)

#define IWMReaderAdvanced2_GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)	\
    (This)->lpVtbl -> GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)

#define IWMReaderAdvanced2_GetSaveAsProgress(This,pdwPercent)	\
    (This)->lpVtbl -> GetSaveAsProgress(This,pdwPercent)

#define IWMReaderAdvanced2_SaveFileAs(This,pwszFilename)	\
    (This)->lpVtbl -> SaveFileAs(This,pwszFilename)

#define IWMReaderAdvanced2_GetProtocolName(This,pwszProtocol,pcchProtocol)	\
    (This)->lpVtbl -> GetProtocolName(This,pwszProtocol,pcchProtocol)

#define IWMReaderAdvanced2_StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)

#define IWMReaderAdvanced2_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMReaderAdvanced2_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMReaderAdvanced2_Preroll(This,cnsStart,cnsDuration,fRate)	\
    (This)->lpVtbl -> Preroll(This,cnsStart,cnsDuration,fRate)

#define IWMReaderAdvanced2_SetLogClientID(This,fLogClientID)	\
    (This)->lpVtbl -> SetLogClientID(This,fLogClientID)

#define IWMReaderAdvanced2_GetLogClientID(This,pfLogClientID)	\
    (This)->lpVtbl -> GetLogClientID(This,pfLogClientID)

#define IWMReaderAdvanced2_StopBuffering(This)	\
    (This)->lpVtbl -> StopBuffering(This)

#define IWMReaderAdvanced2_OpenStream(This,pStream,pCallback,pvContext)	\
    (This)->lpVtbl -> OpenStream(This,pStream,pCallback,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetPlayMode_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ WMT_PLAY_MODE Mode);


void __RPC_STUB IWMReaderAdvanced2_SetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetPlayMode_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);


void __RPC_STUB IWMReaderAdvanced2_GetPlayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetBufferProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent,
    /* [out] */ QWORD __RPC_FAR *pcnsBuffering);


void __RPC_STUB IWMReaderAdvanced2_GetBufferProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetDownloadProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent,
    /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
    /* [out] */ QWORD __RPC_FAR *pcnsDownload);


void __RPC_STUB IWMReaderAdvanced2_GetDownloadProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetSaveAsProgress_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwPercent);


void __RPC_STUB IWMReaderAdvanced2_GetSaveAsProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SaveFileAs_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszFilename);


void __RPC_STUB IWMReaderAdvanced2_SaveFileAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetProtocolName_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
    /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);


void __RPC_STUB IWMReaderAdvanced2_GetProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StartAtMarker_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ WORD wMarkerIndex,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAdvanced2_StartAtMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetOutputSetting_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMReaderAdvanced2_GetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetOutputSetting_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMReaderAdvanced2_SetOutputSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_Preroll_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ QWORD cnsStart,
    /* [in] */ QWORD cnsDuration,
    /* [in] */ float fRate);


void __RPC_STUB IWMReaderAdvanced2_Preroll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_SetLogClientID_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ BOOL fLogClientID);


void __RPC_STUB IWMReaderAdvanced2_SetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_GetLogClientID_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfLogClientID);


void __RPC_STUB IWMReaderAdvanced2_GetLogClientID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_StopBuffering_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This);


void __RPC_STUB IWMReaderAdvanced2_StopBuffering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced2_OpenStream_Proxy( 
    IWMReaderAdvanced2 __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAdvanced2_OpenStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced3_INTERFACE_DEFINED__
#define __IWMReaderAdvanced3_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5DC0674B-F04B-4a4e-9F2A-B1AFDE2C8100")
    IWMReaderAdvanced3 : public IWMReaderAdvanced2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StopNetStreaming( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAtPosition( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ void __RPC_FAR *pvOffsetStart,
            /* [in] */ void __RPC_FAR *pvDuration,
            /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvanced3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserProvidedClock )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserProvidedClock )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeliverTime )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetManualStreamSelection )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetManualStreamSelection )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStreamsSelected )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD __RPC_FAR *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION __RPC_FAR *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL __RPC_FAR *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveStreamSamples )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveStreamSamples )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL __RPC_FAR *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForOutput )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForOutput )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllocateForStream )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllocateForStream )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL __RPC_FAR *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatistics )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WM_READER_STATISTICS __RPC_FAR *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClientInfo )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WM_READER_CLIENTINFO __RPC_FAR *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD __RPC_FAR *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyLateDelivery )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            QWORD cnsLateness);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayMode )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WMT_PLAY_MODE Mode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPlayMode )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ WMT_PLAY_MODE __RPC_FAR *pMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferProgress )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pcnsBuffering);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDownloadProgress )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent,
            /* [out] */ QWORD __RPC_FAR *pqwBytesDownloaded,
            /* [out] */ QWORD __RPC_FAR *pcnsDownload);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaveAsProgress )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwPercent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveFileAs )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtocolName )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocol,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAtMarker )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSetting )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSetting )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Preroll )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogClientID )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ BOOL fLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogClientID )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopBuffering )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenStream )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IWMReaderCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopNetStreaming )( 
            IWMReaderAdvanced3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAtPosition )( 
            IWMReaderAdvanced3 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ void __RPC_FAR *pvOffsetStart,
            /* [in] */ void __RPC_FAR *pvDuration,
            /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
            /* [in] */ float fRate,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderAdvanced3Vtbl;

    interface IWMReaderAdvanced3
    {
        CONST_VTBL struct IWMReaderAdvanced3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAdvanced3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAdvanced3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAdvanced3_SetUserProvidedClock(This,fUserClock)	\
    (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock)

#define IWMReaderAdvanced3_GetUserProvidedClock(This,pfUserClock)	\
    (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock)

#define IWMReaderAdvanced3_DeliverTime(This,cnsTime)	\
    (This)->lpVtbl -> DeliverTime(This,cnsTime)

#define IWMReaderAdvanced3_SetManualStreamSelection(This,fSelection)	\
    (This)->lpVtbl -> SetManualStreamSelection(This,fSelection)

#define IWMReaderAdvanced3_GetManualStreamSelection(This,pfSelection)	\
    (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection)

#define IWMReaderAdvanced3_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)

#define IWMReaderAdvanced3_GetStreamSelected(This,wStreamNum,pSelection)	\
    (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection)

#define IWMReaderAdvanced3_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks)

#define IWMReaderAdvanced3_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks)

#define IWMReaderAdvanced3_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)

#define IWMReaderAdvanced3_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)

#define IWMReaderAdvanced3_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate)

#define IWMReaderAdvanced3_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate)

#define IWMReaderAdvanced3_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate)

#define IWMReaderAdvanced3_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate)

#define IWMReaderAdvanced3_GetStatistics(This,pStatistics)	\
    (This)->lpVtbl -> GetStatistics(This,pStatistics)

#define IWMReaderAdvanced3_SetClientInfo(This,pClientInfo)	\
    (This)->lpVtbl -> SetClientInfo(This,pClientInfo)

#define IWMReaderAdvanced3_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax)

#define IWMReaderAdvanced3_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax)

#define IWMReaderAdvanced3_NotifyLateDelivery(This,cnsLateness)	\
    (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness)


#define IWMReaderAdvanced3_SetPlayMode(This,Mode)	\
    (This)->lpVtbl -> SetPlayMode(This,Mode)

#define IWMReaderAdvanced3_GetPlayMode(This,pMode)	\
    (This)->lpVtbl -> GetPlayMode(This,pMode)

#define IWMReaderAdvanced3_GetBufferProgress(This,pdwPercent,pcnsBuffering)	\
    (This)->lpVtbl -> GetBufferProgress(This,pdwPercent,pcnsBuffering)

#define IWMReaderAdvanced3_GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)	\
    (This)->lpVtbl -> GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)

#define IWMReaderAdvanced3_GetSaveAsProgress(This,pdwPercent)	\
    (This)->lpVtbl -> GetSaveAsProgress(This,pdwPercent)

#define IWMReaderAdvanced3_SaveFileAs(This,pwszFilename)	\
    (This)->lpVtbl -> SaveFileAs(This,pwszFilename)

#define IWMReaderAdvanced3_GetProtocolName(This,pwszProtocol,pcchProtocol)	\
    (This)->lpVtbl -> GetProtocolName(This,pwszProtocol,pcchProtocol)

#define IWMReaderAdvanced3_StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)

#define IWMReaderAdvanced3_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)

#define IWMReaderAdvanced3_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)

#define IWMReaderAdvanced3_Preroll(This,cnsStart,cnsDuration,fRate)	\
    (This)->lpVtbl -> Preroll(This,cnsStart,cnsDuration,fRate)

#define IWMReaderAdvanced3_SetLogClientID(This,fLogClientID)	\
    (This)->lpVtbl -> SetLogClientID(This,fLogClientID)

#define IWMReaderAdvanced3_GetLogClientID(This,pfLogClientID)	\
    (This)->lpVtbl -> GetLogClientID(This,pfLogClientID)

#define IWMReaderAdvanced3_StopBuffering(This)	\
    (This)->lpVtbl -> StopBuffering(This)

#define IWMReaderAdvanced3_OpenStream(This,pStream,pCallback,pvContext)	\
    (This)->lpVtbl -> OpenStream(This,pStream,pCallback,pvContext)


#define IWMReaderAdvanced3_StopNetStreaming(This)	\
    (This)->lpVtbl -> StopNetStreaming(This)

#define IWMReaderAdvanced3_StartAtPosition(This,wStreamNum,pvOffsetStart,pvDuration,dwOffsetFormat,fRate,pvContext)	\
    (This)->lpVtbl -> StartAtPosition(This,wStreamNum,pvOffsetStart,pvDuration,dwOffsetFormat,fRate,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAdvanced3_StopNetStreaming_Proxy( 
    IWMReaderAdvanced3 __RPC_FAR * This);


void __RPC_STUB IWMReaderAdvanced3_StopNetStreaming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAdvanced3_StartAtPosition_Proxy( 
    IWMReaderAdvanced3 __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ void __RPC_FAR *pvOffsetStart,
    /* [in] */ void __RPC_FAR *pvDuration,
    /* [in] */ WMT_OFFSET_FORMAT dwOffsetFormat,
    /* [in] */ float fRate,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAdvanced3_StartAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAdvanced3_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_INTERFACE_DEFINED__
#define __IWMReaderAllocatorEx_INTERFACE_DEFINED__

/* interface IWMReaderAllocatorEx */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAllocatorEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F762FA7-A22E-428d-93C9-AC82F3AAFE5A")
    IWMReaderAllocatorEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateForStreamEx( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutputEx( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAllocatorExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderAllocatorEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderAllocatorEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForStreamEx )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForOutputEx )( 
            IWMReaderAllocatorEx __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderAllocatorExVtbl;

    interface IWMReaderAllocatorEx
    {
        CONST_VTBL struct IWMReaderAllocatorExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAllocatorEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderAllocatorEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderAllocatorEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderAllocatorEx_AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#define IWMReaderAllocatorEx_AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    (This)->lpVtbl -> AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForStreamEx_Proxy( 
    IWMReaderAllocatorEx __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForStreamEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderAllocatorEx_AllocateForOutputEx_Proxy( 
    IWMReaderAllocatorEx __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwFlags,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderAllocatorEx_AllocateForOutputEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderAllocatorEx_INTERFACE_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_INTERFACE_DEFINED__
#define __IWMReaderTypeNegotiation_INTERFACE_DEFINED__

/* interface IWMReaderTypeNegotiation */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderTypeNegotiation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FDBE5592-81A1-41ea-93BD-735CAD1ADC05")
    IWMReaderTypeNegotiation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TryOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderTypeNegotiationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderTypeNegotiation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderTypeNegotiation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderTypeNegotiation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TryOutputProps )( 
            IWMReaderTypeNegotiation __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);
        
        END_INTERFACE
    } IWMReaderTypeNegotiationVtbl;

    interface IWMReaderTypeNegotiation
    {
        CONST_VTBL struct IWMReaderTypeNegotiationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderTypeNegotiation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderTypeNegotiation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderTypeNegotiation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderTypeNegotiation_TryOutputProps(This,dwOutputNum,pOutput)	\
    (This)->lpVtbl -> TryOutputProps(This,dwOutputNum,pOutput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderTypeNegotiation_TryOutputProps_Proxy( 
    IWMReaderTypeNegotiation __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ IWMOutputMediaProps __RPC_FAR *pOutput);


void __RPC_STUB IWMReaderTypeNegotiation_TryOutputProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderTypeNegotiation_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__
#define __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderCallbackAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallbackAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEB-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallbackAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTime( 
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStreamSelection( 
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD __RPC_FAR *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnOutputPropsChanged( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForStream( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStreamSample )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer __RPC_FAR *pSample,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTime )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStreamSelection )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD __RPC_FAR *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnOutputPropsChanged )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForStream )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateForOutput )( 
            IWMReaderCallbackAdvanced __RPC_FAR * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ void __RPC_FAR *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackAdvancedVtbl;

    interface IWMReaderCallbackAdvanced
    {
        CONST_VTBL struct IWMReaderCallbackAdvancedVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallbackAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderCallbackAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderCallbackAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderCallbackAdvanced_OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    (This)->lpVtbl -> OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)

#define IWMReaderCallbackAdvanced_OnTime(This,cnsCurrentTime,pvContext)	\
    (This)->lpVtbl -> OnTime(This,cnsCurrentTime,pvContext)

#define IWMReaderCallbackAdvanced_OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)	\
    (This)->lpVtbl -> OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)

#define IWMReaderCallbackAdvanced_OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)	\
    (This)->lpVtbl -> OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)

#define IWMReaderCallbackAdvanced_AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)	\
    (This)->lpVtbl -> AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSample_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ QWORD cnsSampleTime,
    /* [in] */ QWORD cnsSampleDuration,
    /* [in] */ DWORD dwFlags,
    /* [in] */ INSSBuffer __RPC_FAR *pSample,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnTime_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ QWORD cnsCurrentTime,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnStreamSelection_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamCount,
    /* [in] */ WORD __RPC_FAR *pStreamNumbers,
    /* [in] */ WMT_STREAM_SELECTION __RPC_FAR *pSelections,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnStreamSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_OnOutputPropsChanged_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ WM_MEDIA_TYPE __RPC_FAR *pMediaType,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_OnOutputPropsChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForStream_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderCallbackAdvanced_AllocateForOutput_Proxy( 
    IWMReaderCallbackAdvanced __RPC_FAR * This,
    /* [in] */ DWORD dwOutputNum,
    /* [in] */ DWORD cbBuffer,
    /* [out] */ INSSBuffer __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMReaderCallbackAdvanced_AllocateForOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMDRMReader_INTERFACE_DEFINED__
#define __IWMDRMReader_INTERFACE_DEFINED__

/* interface IWMDRMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMDRMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2827540-3EE7-432c-B14C-DC17F085D3B3")
    IWMDRMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireLicense( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Individualize( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelIndividualization( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelMonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out] */ WORD __RPC_FAR *pcbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDRMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMDRMReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AcquireLicense )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Individualize )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelIndividualization )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MonitorLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelMonitorLicenseAcquisition )( 
            IWMDRMReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDRMProperty )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDRMProperty )( 
            IWMDRMReader __RPC_FAR * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out] */ WORD __RPC_FAR *pcbLength);
        
        END_INTERFACE
    } IWMDRMReaderVtbl;

    interface IWMDRMReader
    {
        CONST_VTBL struct IWMDRMReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDRMReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMDRMReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMDRMReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMDRMReader_AcquireLicense(This,dwFlags)	\
    (This)->lpVtbl -> AcquireLicense(This,dwFlags)

#define IWMDRMReader_CancelLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelLicenseAcquisition(This)

#define IWMDRMReader_Individualize(This,dwFlags)	\
    (This)->lpVtbl -> Individualize(This,dwFlags)

#define IWMDRMReader_CancelIndividualization(This)	\
    (This)->lpVtbl -> CancelIndividualization(This)

#define IWMDRMReader_MonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> MonitorLicenseAcquisition(This)

#define IWMDRMReader_CancelMonitorLicenseAcquisition(This)	\
    (This)->lpVtbl -> CancelMonitorLicenseAcquisition(This)

#define IWMDRMReader_SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)	\
    (This)->lpVtbl -> SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)

#define IWMDRMReader_GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMDRMReader_AcquireLicense_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_AcquireLicense_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_Individualize_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IWMDRMReader_Individualize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelIndividualization_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelIndividualization_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_MonitorLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_MonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_CancelMonitorLicenseAcquisition_Proxy( 
    IWMDRMReader __RPC_FAR * This);


void __RPC_STUB IWMDRMReader_CancelMonitorLicenseAcquisition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_SetDRMProperty_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [in] */ WMT_ATTR_DATATYPE dwType,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMDRMReader_SetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMDRMReader_GetDRMProperty_Proxy( 
    IWMDRMReader __RPC_FAR * This,
    /* [in] */ LPCWSTR pwstrName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pdwType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMDRMReader_GetDRMProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMDRMReader_INTERFACE_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_INTERFACE_DEFINED__
#define __IWMReaderNetworkConfig_INTERFACE_DEFINED__

/* interface IWMReaderNetworkConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderNetworkConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEC-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderNetworkConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBufferingTime( 
            /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferingTime( 
            /* [in] */ QWORD cnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUDPPortRanges( 
            /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [out][in] */ DWORD __RPC_FAR *pcRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUDPPortRanges( 
            /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [in] */ DWORD cRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszHostName,
            /* [out][in] */ DWORD __RPC_FAR *pcchHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
            /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL __RPC_FAR *pfBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForceRerunAutoProxyDetection( 
            /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForceRerunAutoProxyDetection( 
            /* [in] */ BOOL fForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableMulticast( 
            /* [out] */ BOOL __RPC_FAR *pfEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableMulticast( 
            /* [in] */ BOOL fEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableHTTP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableHTTP( 
            /* [in] */ BOOL fEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableUDP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableUDP( 
            /* [in] */ BOOL fEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableTCP( 
            /* [out] */ BOOL __RPC_FAR *pfEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableTCP( 
            /* [in] */ BOOL fEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetProtocolRollover( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionBandwidth( 
            /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionBandwidth( 
            /* [in] */ DWORD dwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumProtocolsSupported( 
            /* [out] */ DWORD __RPC_FAR *pcProtocols) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedProtocolName( 
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddLoggingUrl( 
            /* [in] */ LPCWSTR pwszUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrl( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD __RPC_FAR *pcchUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrlCount( 
            /* [out] */ DWORD __RPC_FAR *pdwUrlCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetLoggingUrlList( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderNetworkConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferingTime )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferingTime )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ QWORD cnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUDPPortRanges )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [out][in] */ DWORD __RPC_FAR *pcRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUDPPortRanges )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [in] */ DWORD cRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxySettings )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxySettings )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyHostName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszHostName,
            /* [out][in] */ DWORD __RPC_FAR *pcchHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyHostName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyPort )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyPort )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyExceptionList )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
            /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyExceptionList )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyBypassForLocal )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL __RPC_FAR *pfBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyBypassForLocal )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableMulticast )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableMulticast )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableHTTP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableHTTP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableUDP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableUDP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableTCP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableTCP )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ BOOL fEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetProtocolRollover )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionBandwidth )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConnectionBandwidth )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumProtocolsSupported )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProtocols);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSupportedProtocolName )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddLoggingUrl )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrl )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD __RPC_FAR *pcchUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrlCount )( 
            IWMReaderNetworkConfig __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwUrlCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetLoggingUrlList )( 
            IWMReaderNetworkConfig __RPC_FAR * This);
        
        END_INTERFACE
    } IWMReaderNetworkConfigVtbl;

    interface IWMReaderNetworkConfig
    {
        CONST_VTBL struct IWMReaderNetworkConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderNetworkConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderNetworkConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderNetworkConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderNetworkConfig_GetBufferingTime(This,pcnsBufferingTime)	\
    (This)->lpVtbl -> GetBufferingTime(This,pcnsBufferingTime)

#define IWMReaderNetworkConfig_SetBufferingTime(This,cnsBufferingTime)	\
    (This)->lpVtbl -> SetBufferingTime(This,cnsBufferingTime)

#define IWMReaderNetworkConfig_GetUDPPortRanges(This,pRangeArray,pcRanges)	\
    (This)->lpVtbl -> GetUDPPortRanges(This,pRangeArray,pcRanges)

#define IWMReaderNetworkConfig_SetUDPPortRanges(This,pRangeArray,cRanges)	\
    (This)->lpVtbl -> SetUDPPortRanges(This,pRangeArray,cRanges)

#define IWMReaderNetworkConfig_GetProxySettings(This,pwszProtocol,pProxySetting)	\
    (This)->lpVtbl -> GetProxySettings(This,pwszProtocol,pProxySetting)

#define IWMReaderNetworkConfig_SetProxySettings(This,pwszProtocol,ProxySetting)	\
    (This)->lpVtbl -> SetProxySettings(This,pwszProtocol,ProxySetting)

#define IWMReaderNetworkConfig_GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)	\
    (This)->lpVtbl -> GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)

#define IWMReaderNetworkConfig_SetProxyHostName(This,pwszProtocol,pwszHostName)	\
    (This)->lpVtbl -> SetProxyHostName(This,pwszProtocol,pwszHostName)

#define IWMReaderNetworkConfig_GetProxyPort(This,pwszProtocol,pdwPort)	\
    (This)->lpVtbl -> GetProxyPort(This,pwszProtocol,pdwPort)

#define IWMReaderNetworkConfig_SetProxyPort(This,pwszProtocol,dwPort)	\
    (This)->lpVtbl -> SetProxyPort(This,pwszProtocol,dwPort)

#define IWMReaderNetworkConfig_GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)	\
    (This)->lpVtbl -> GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)

#define IWMReaderNetworkConfig_SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)	\
    (This)->lpVtbl -> SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)

#define IWMReaderNetworkConfig_GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)	\
    (This)->lpVtbl -> GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)

#define IWMReaderNetworkConfig_SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)	\
    (This)->lpVtbl -> SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)

#define IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)	\
    (This)->lpVtbl -> GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)

#define IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection(This,fForceRerunDetection)	\
    (This)->lpVtbl -> SetForceRerunAutoProxyDetection(This,fForceRerunDetection)

#define IWMReaderNetworkConfig_GetEnableMulticast(This,pfEnableMulticast)	\
    (This)->lpVtbl -> GetEnableMulticast(This,pfEnableMulticast)

#define IWMReaderNetworkConfig_SetEnableMulticast(This,fEnableMulticast)	\
    (This)->lpVtbl -> SetEnableMulticast(This,fEnableMulticast)

#define IWMReaderNetworkConfig_GetEnableHTTP(This,pfEnableHTTP)	\
    (This)->lpVtbl -> GetEnableHTTP(This,pfEnableHTTP)

#define IWMReaderNetworkConfig_SetEnableHTTP(This,fEnableHTTP)	\
    (This)->lpVtbl -> SetEnableHTTP(This,fEnableHTTP)

#define IWMReaderNetworkConfig_GetEnableUDP(This,pfEnableUDP)	\
    (This)->lpVtbl -> GetEnableUDP(This,pfEnableUDP)

#define IWMReaderNetworkConfig_SetEnableUDP(This,fEnableUDP)	\
    (This)->lpVtbl -> SetEnableUDP(This,fEnableUDP)

#define IWMReaderNetworkConfig_GetEnableTCP(This,pfEnableTCP)	\
    (This)->lpVtbl -> GetEnableTCP(This,pfEnableTCP)

#define IWMReaderNetworkConfig_SetEnableTCP(This,fEnableTCP)	\
    (This)->lpVtbl -> SetEnableTCP(This,fEnableTCP)

#define IWMReaderNetworkConfig_ResetProtocolRollover(This)	\
    (This)->lpVtbl -> ResetProtocolRollover(This)

#define IWMReaderNetworkConfig_GetConnectionBandwidth(This,pdwConnectionBandwidth)	\
    (This)->lpVtbl -> GetConnectionBandwidth(This,pdwConnectionBandwidth)

#define IWMReaderNetworkConfig_SetConnectionBandwidth(This,dwConnectionBandwidth)	\
    (This)->lpVtbl -> SetConnectionBandwidth(This,dwConnectionBandwidth)

#define IWMReaderNetworkConfig_GetNumProtocolsSupported(This,pcProtocols)	\
    (This)->lpVtbl -> GetNumProtocolsSupported(This,pcProtocols)

#define IWMReaderNetworkConfig_GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)	\
    (This)->lpVtbl -> GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)

#define IWMReaderNetworkConfig_AddLoggingUrl(This,pwszUrl)	\
    (This)->lpVtbl -> AddLoggingUrl(This,pwszUrl)

#define IWMReaderNetworkConfig_GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)	\
    (This)->lpVtbl -> GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)

#define IWMReaderNetworkConfig_GetLoggingUrlCount(This,pdwUrlCount)	\
    (This)->lpVtbl -> GetLoggingUrlCount(This,pdwUrlCount)

#define IWMReaderNetworkConfig_ResetLoggingUrlList(This)	\
    (This)->lpVtbl -> ResetLoggingUrlList(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetBufferingTime_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_GetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetBufferingTime_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ QWORD cnsBufferingTime);


void __RPC_STUB IWMReaderNetworkConfig_SetBufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
    /* [out][in] */ DWORD __RPC_FAR *pcRanges);


void __RPC_STUB IWMReaderNetworkConfig_GetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetUDPPortRanges_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
    /* [in] */ DWORD cRanges);


void __RPC_STUB IWMReaderNetworkConfig_SetUDPPortRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxySettings_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_GetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxySettings_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    LPCWSTR pwszProtocol,
    WMT_PROXY_SETTINGS ProxySetting);


void __RPC_STUB IWMReaderNetworkConfig_SetProxySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyHostName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR __RPC_FAR *pwszHostName,
    /* [out][in] */ DWORD __RPC_FAR *pcchHostName);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyHostName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszHostName);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyHostName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyPort_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwPort);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyPort_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ DWORD dwPort);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
    /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyExceptionList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ LPCWSTR pwszExceptionList);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyExceptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [out] */ BOOL __RPC_FAR *pfBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_GetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetProxyBypassForLocal_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszProtocol,
    /* [in] */ BOOL fBypassForLocal);


void __RPC_STUB IWMReaderNetworkConfig_SetProxyBypassForLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fForceRerunDetection);


void __RPC_STUB IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableMulticast_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableMulticast);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableMulticast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableHTTP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableHTTP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableUDP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableUDP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableUDP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableUDP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetEnableTCP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_GetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetEnableTCP_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ BOOL fEnableTCP);


void __RPC_STUB IWMReaderNetworkConfig_SetEnableTCP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetProtocolRollover_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetProtocolRollover_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_GetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_SetConnectionBandwidth_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwConnectionBandwidth);


void __RPC_STUB IWMReaderNetworkConfig_SetConnectionBandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetNumProtocolsSupported_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcProtocols);


void __RPC_STUB IWMReaderNetworkConfig_GetNumProtocolsSupported_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetSupportedProtocolName_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwProtocolNum,
    /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
    /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName);


void __RPC_STUB IWMReaderNetworkConfig_GetSupportedProtocolName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_AddLoggingUrl_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl);


void __RPC_STUB IWMReaderNetworkConfig_AddLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrl_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ LPWSTR pwszUrl,
    /* [out][in] */ DWORD __RPC_FAR *pcchUrl);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_GetLoggingUrlCount_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwUrlCount);


void __RPC_STUB IWMReaderNetworkConfig_GetLoggingUrlCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig_ResetLoggingUrlList_Proxy( 
    IWMReaderNetworkConfig __RPC_FAR * This);


void __RPC_STUB IWMReaderNetworkConfig_ResetLoggingUrlList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderNetworkConfig_INTERFACE_DEFINED__ */


#ifndef __IWMReaderNetworkConfig2_INTERFACE_DEFINED__
#define __IWMReaderNetworkConfig2_INTERFACE_DEFINED__

/* interface IWMReaderNetworkConfig2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderNetworkConfig2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d979a853-042b-4050-8387-c939db22013f")
    IWMReaderNetworkConfig2 : public IWMReaderNetworkConfig
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEnableContentCaching( 
            /* [out] */ BOOL __RPC_FAR *pfEnableContentCaching) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableContentCaching( 
            /* [in] */ BOOL fEnableContentCaching) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableOpportunisticStreaming( 
            /* [out] */ BOOL __RPC_FAR *pfEnableOppStreaming) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableOpportunisticStreaming( 
            /* [in] */ BOOL fEnableOppStreaming) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAcceleratedStreamingDuration( 
            /* [out] */ QWORD __RPC_FAR *pcnsAccelDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAcceleratedStreamingDuration( 
            /* [in] */ QWORD cnsAccelDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAutoReconnectLimit( 
            /* [out] */ LONG __RPC_FAR *plAutoReconnectLimit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAutoReconnectLimit( 
            /* [in] */ LONG lAutoReconnectLimit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableResends( 
            /* [out] */ BOOL __RPC_FAR *pfEnableResends) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableResends( 
            /* [in] */ BOOL fEnableResends) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableThinning( 
            /* [out] */ BOOL __RPC_FAR *pfEnableThinning) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableThinning( 
            /* [in] */ BOOL fEnableThinning) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFECSpan( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ DWORD __RPC_FAR *pdwFECSpan,
            /* [out] */ DWORD __RPC_FAR *pdwFECPacketsPerSpan) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFECSpan( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD dwFECSpan,
            /* [in] */ DWORD dwFECPacketsPerSpan) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxNetPacketSize( 
            /* [out] */ DWORD __RPC_FAR *pdwMaxNetPacketSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQOSMode( 
            /* [out] */ WMT_QOS_MODE __RPC_FAR *pQOSMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderNetworkConfig2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferingTime )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferingTime )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ QWORD cnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUDPPortRanges )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [out][in] */ DWORD __RPC_FAR *pcRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUDPPortRanges )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ WM_PORT_NUMBER_RANGE __RPC_FAR *pRangeArray,
            /* [in] */ DWORD cRanges);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxySettings )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS __RPC_FAR *pProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxySettings )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyHostName )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszHostName,
            /* [out][in] */ DWORD __RPC_FAR *pcchHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyHostName )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyPort )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD __RPC_FAR *pdwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyPort )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyExceptionList )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR __RPC_FAR *pwszExceptionList,
            /* [out][in] */ DWORD __RPC_FAR *pcchExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyExceptionList )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProxyBypassForLocal )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL __RPC_FAR *pfBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProxyBypassForLocal )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ BOOL fForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableMulticast )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableMulticast )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ BOOL fEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableHTTP )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableHTTP )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ BOOL fEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableUDP )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableUDP )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ BOOL fEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableTCP )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableTCP )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ BOOL fEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetProtocolRollover )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConnectionBandwidth )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConnectionBandwidth )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ DWORD dwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumProtocolsSupported )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcProtocols);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSupportedProtocolName )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR __RPC_FAR *pwszProtocolName,
            /* [out][in] */ DWORD __RPC_FAR *pcchProtocolName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddLoggingUrl )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrl )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD __RPC_FAR *pcchUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLoggingUrlCount )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwUrlCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetLoggingUrlList )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableContentCaching )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableContentCaching);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableContentCaching )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ BOOL fEnableContentCaching);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableOpportunisticStreaming )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableOppStreaming);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableOpportunisticStreaming )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ BOOL fEnableOppStreaming);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAcceleratedStreamingDuration )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ QWORD __RPC_FAR *pcnsAccelDuration);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAcceleratedStreamingDuration )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ QWORD cnsAccelDuration);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAutoReconnectLimit )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ LONG __RPC_FAR *plAutoReconnectLimit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAutoReconnectLimit )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ LONG lAutoReconnectLimit);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableResends )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableResends);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableResends )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ BOOL fEnableResends);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnableThinning )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfEnableThinning);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnableThinning )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ BOOL fEnableThinning);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFECSpan )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ DWORD __RPC_FAR *pdwFECSpan,
            /* [out] */ DWORD __RPC_FAR *pdwFECPacketsPerSpan);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFECSpan )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD dwFECSpan,
            /* [in] */ DWORD dwFECPacketsPerSpan);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxNetPacketSize )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMaxNetPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQOSMode )( 
            IWMReaderNetworkConfig2 __RPC_FAR * This,
            /* [out] */ WMT_QOS_MODE __RPC_FAR *pQOSMode);
        
        END_INTERFACE
    } IWMReaderNetworkConfig2Vtbl;

    interface IWMReaderNetworkConfig2
    {
        CONST_VTBL struct IWMReaderNetworkConfig2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderNetworkConfig2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderNetworkConfig2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderNetworkConfig2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderNetworkConfig2_GetBufferingTime(This,pcnsBufferingTime)	\
    (This)->lpVtbl -> GetBufferingTime(This,pcnsBufferingTime)

#define IWMReaderNetworkConfig2_SetBufferingTime(This,cnsBufferingTime)	\
    (This)->lpVtbl -> SetBufferingTime(This,cnsBufferingTime)

#define IWMReaderNetworkConfig2_GetUDPPortRanges(This,pRangeArray,pcRanges)	\
    (This)->lpVtbl -> GetUDPPortRanges(This,pRangeArray,pcRanges)

#define IWMReaderNetworkConfig2_SetUDPPortRanges(This,pRangeArray,cRanges)	\
    (This)->lpVtbl -> SetUDPPortRanges(This,pRangeArray,cRanges)

#define IWMReaderNetworkConfig2_GetProxySettings(This,pwszProtocol,pProxySetting)	\
    (This)->lpVtbl -> GetProxySettings(This,pwszProtocol,pProxySetting)

#define IWMReaderNetworkConfig2_SetProxySettings(This,pwszProtocol,ProxySetting)	\
    (This)->lpVtbl -> SetProxySettings(This,pwszProtocol,ProxySetting)

#define IWMReaderNetworkConfig2_GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)	\
    (This)->lpVtbl -> GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)

#define IWMReaderNetworkConfig2_SetProxyHostName(This,pwszProtocol,pwszHostName)	\
    (This)->lpVtbl -> SetProxyHostName(This,pwszProtocol,pwszHostName)

#define IWMReaderNetworkConfig2_GetProxyPort(This,pwszProtocol,pdwPort)	\
    (This)->lpVtbl -> GetProxyPort(This,pwszProtocol,pdwPort)

#define IWMReaderNetworkConfig2_SetProxyPort(This,pwszProtocol,dwPort)	\
    (This)->lpVtbl -> SetProxyPort(This,pwszProtocol,dwPort)

#define IWMReaderNetworkConfig2_GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)	\
    (This)->lpVtbl -> GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)

#define IWMReaderNetworkConfig2_SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)	\
    (This)->lpVtbl -> SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)

#define IWMReaderNetworkConfig2_GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)	\
    (This)->lpVtbl -> GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)

#define IWMReaderNetworkConfig2_SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)	\
    (This)->lpVtbl -> SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)

#define IWMReaderNetworkConfig2_GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)	\
    (This)->lpVtbl -> GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)

#define IWMReaderNetworkConfig2_SetForceRerunAutoProxyDetection(This,fForceRerunDetection)	\
    (This)->lpVtbl -> SetForceRerunAutoProxyDetection(This,fForceRerunDetection)

#define IWMReaderNetworkConfig2_GetEnableMulticast(This,pfEnableMulticast)	\
    (This)->lpVtbl -> GetEnableMulticast(This,pfEnableMulticast)

#define IWMReaderNetworkConfig2_SetEnableMulticast(This,fEnableMulticast)	\
    (This)->lpVtbl -> SetEnableMulticast(This,fEnableMulticast)

#define IWMReaderNetworkConfig2_GetEnableHTTP(This,pfEnableHTTP)	\
    (This)->lpVtbl -> GetEnableHTTP(This,pfEnableHTTP)

#define IWMReaderNetworkConfig2_SetEnableHTTP(This,fEnableHTTP)	\
    (This)->lpVtbl -> SetEnableHTTP(This,fEnableHTTP)

#define IWMReaderNetworkConfig2_GetEnableUDP(This,pfEnableUDP)	\
    (This)->lpVtbl -> GetEnableUDP(This,pfEnableUDP)

#define IWMReaderNetworkConfig2_SetEnableUDP(This,fEnableUDP)	\
    (This)->lpVtbl -> SetEnableUDP(This,fEnableUDP)

#define IWMReaderNetworkConfig2_GetEnableTCP(This,pfEnableTCP)	\
    (This)->lpVtbl -> GetEnableTCP(This,pfEnableTCP)

#define IWMReaderNetworkConfig2_SetEnableTCP(This,fEnableTCP)	\
    (This)->lpVtbl -> SetEnableTCP(This,fEnableTCP)

#define IWMReaderNetworkConfig2_ResetProtocolRollover(This)	\
    (This)->lpVtbl -> ResetProtocolRollover(This)

#define IWMReaderNetworkConfig2_GetConnectionBandwidth(This,pdwConnectionBandwidth)	\
    (This)->lpVtbl -> GetConnectionBandwidth(This,pdwConnectionBandwidth)

#define IWMReaderNetworkConfig2_SetConnectionBandwidth(This,dwConnectionBandwidth)	\
    (This)->lpVtbl -> SetConnectionBandwidth(This,dwConnectionBandwidth)

#define IWMReaderNetworkConfig2_GetNumProtocolsSupported(This,pcProtocols)	\
    (This)->lpVtbl -> GetNumProtocolsSupported(This,pcProtocols)

#define IWMReaderNetworkConfig2_GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)	\
    (This)->lpVtbl -> GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)

#define IWMReaderNetworkConfig2_AddLoggingUrl(This,pwszUrl)	\
    (This)->lpVtbl -> AddLoggingUrl(This,pwszUrl)

#define IWMReaderNetworkConfig2_GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)	\
    (This)->lpVtbl -> GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)

#define IWMReaderNetworkConfig2_GetLoggingUrlCount(This,pdwUrlCount)	\
    (This)->lpVtbl -> GetLoggingUrlCount(This,pdwUrlCount)

#define IWMReaderNetworkConfig2_ResetLoggingUrlList(This)	\
    (This)->lpVtbl -> ResetLoggingUrlList(This)


#define IWMReaderNetworkConfig2_GetEnableContentCaching(This,pfEnableContentCaching)	\
    (This)->lpVtbl -> GetEnableContentCaching(This,pfEnableContentCaching)

#define IWMReaderNetworkConfig2_SetEnableContentCaching(This,fEnableContentCaching)	\
    (This)->lpVtbl -> SetEnableContentCaching(This,fEnableContentCaching)

#define IWMReaderNetworkConfig2_GetEnableOpportunisticStreaming(This,pfEnableOppStreaming)	\
    (This)->lpVtbl -> GetEnableOpportunisticStreaming(This,pfEnableOppStreaming)

#define IWMReaderNetworkConfig2_SetEnableOpportunisticStreaming(This,fEnableOppStreaming)	\
    (This)->lpVtbl -> SetEnableOpportunisticStreaming(This,fEnableOppStreaming)

#define IWMReaderNetworkConfig2_GetAcceleratedStreamingDuration(This,pcnsAccelDuration)	\
    (This)->lpVtbl -> GetAcceleratedStreamingDuration(This,pcnsAccelDuration)

#define IWMReaderNetworkConfig2_SetAcceleratedStreamingDuration(This,cnsAccelDuration)	\
    (This)->lpVtbl -> SetAcceleratedStreamingDuration(This,cnsAccelDuration)

#define IWMReaderNetworkConfig2_GetAutoReconnectLimit(This,plAutoReconnectLimit)	\
    (This)->lpVtbl -> GetAutoReconnectLimit(This,plAutoReconnectLimit)

#define IWMReaderNetworkConfig2_SetAutoReconnectLimit(This,lAutoReconnectLimit)	\
    (This)->lpVtbl -> SetAutoReconnectLimit(This,lAutoReconnectLimit)

#define IWMReaderNetworkConfig2_GetEnableResends(This,pfEnableResends)	\
    (This)->lpVtbl -> GetEnableResends(This,pfEnableResends)

#define IWMReaderNetworkConfig2_SetEnableResends(This,fEnableResends)	\
    (This)->lpVtbl -> SetEnableResends(This,fEnableResends)

#define IWMReaderNetworkConfig2_GetEnableThinning(This,pfEnableThinning)	\
    (This)->lpVtbl -> GetEnableThinning(This,pfEnableThinning)

#define IWMReaderNetworkConfig2_SetEnableThinning(This,fEnableThinning)	\
    (This)->lpVtbl -> SetEnableThinning(This,fEnableThinning)

#define IWMReaderNetworkConfig2_GetFECSpan(This,wStreamNum,pdwFECSpan,pdwFECPacketsPerSpan)	\
    (This)->lpVtbl -> GetFECSpan(This,wStreamNum,pdwFECSpan,pdwFECPacketsPerSpan)

#define IWMReaderNetworkConfig2_SetFECSpan(This,wStreamNum,dwFECSpan,dwFECPacketsPerSpan)	\
    (This)->lpVtbl -> SetFECSpan(This,wStreamNum,dwFECSpan,dwFECPacketsPerSpan)

#define IWMReaderNetworkConfig2_GetMaxNetPacketSize(This,pdwMaxNetPacketSize)	\
    (This)->lpVtbl -> GetMaxNetPacketSize(This,pdwMaxNetPacketSize)

#define IWMReaderNetworkConfig2_GetQOSMode(This,pQOSMode)	\
    (This)->lpVtbl -> GetQOSMode(This,pQOSMode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetEnableContentCaching_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableContentCaching);


void __RPC_STUB IWMReaderNetworkConfig2_GetEnableContentCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetEnableContentCaching_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [in] */ BOOL fEnableContentCaching);


void __RPC_STUB IWMReaderNetworkConfig2_SetEnableContentCaching_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetEnableOpportunisticStreaming_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableOppStreaming);


void __RPC_STUB IWMReaderNetworkConfig2_GetEnableOpportunisticStreaming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetEnableOpportunisticStreaming_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [in] */ BOOL fEnableOppStreaming);


void __RPC_STUB IWMReaderNetworkConfig2_SetEnableOpportunisticStreaming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetAcceleratedStreamingDuration_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [out] */ QWORD __RPC_FAR *pcnsAccelDuration);


void __RPC_STUB IWMReaderNetworkConfig2_GetAcceleratedStreamingDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetAcceleratedStreamingDuration_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [in] */ QWORD cnsAccelDuration);


void __RPC_STUB IWMReaderNetworkConfig2_SetAcceleratedStreamingDuration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetAutoReconnectLimit_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [out] */ LONG __RPC_FAR *plAutoReconnectLimit);


void __RPC_STUB IWMReaderNetworkConfig2_GetAutoReconnectLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetAutoReconnectLimit_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [in] */ LONG lAutoReconnectLimit);


void __RPC_STUB IWMReaderNetworkConfig2_SetAutoReconnectLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetEnableResends_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableResends);


void __RPC_STUB IWMReaderNetworkConfig2_GetEnableResends_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetEnableResends_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [in] */ BOOL fEnableResends);


void __RPC_STUB IWMReaderNetworkConfig2_SetEnableResends_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetEnableThinning_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfEnableThinning);


void __RPC_STUB IWMReaderNetworkConfig2_GetEnableThinning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetEnableThinning_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [in] */ BOOL fEnableThinning);


void __RPC_STUB IWMReaderNetworkConfig2_SetEnableThinning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetFECSpan_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [out] */ DWORD __RPC_FAR *pdwFECSpan,
    /* [out] */ DWORD __RPC_FAR *pdwFECPacketsPerSpan);


void __RPC_STUB IWMReaderNetworkConfig2_GetFECSpan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_SetFECSpan_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ DWORD dwFECSpan,
    /* [in] */ DWORD dwFECPacketsPerSpan);


void __RPC_STUB IWMReaderNetworkConfig2_SetFECSpan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetMaxNetPacketSize_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMaxNetPacketSize);


void __RPC_STUB IWMReaderNetworkConfig2_GetMaxNetPacketSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderNetworkConfig2_GetQOSMode_Proxy( 
    IWMReaderNetworkConfig2 __RPC_FAR * This,
    /* [out] */ WMT_QOS_MODE __RPC_FAR *pQOSMode);


void __RPC_STUB IWMReaderNetworkConfig2_GetQOSMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderNetworkConfig2_INTERFACE_DEFINED__ */


#ifndef __IWMReaderStreamClock_INTERFACE_DEFINED__
#define __IWMReaderStreamClock_INTERFACE_DEFINED__

/* interface IWMReaderStreamClock */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderStreamClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BED-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderStreamClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [in] */ QWORD __RPC_FAR *pcnsNow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimer( 
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void __RPC_FAR *pvParam,
            /* [out] */ DWORD __RPC_FAR *pdwTimerId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KillTimer( 
            /* [in] */ DWORD dwTimerId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderStreamClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMReaderStreamClock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMReaderStreamClock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTime )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ QWORD __RPC_FAR *pcnsNow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimer )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void __RPC_FAR *pvParam,
            /* [out] */ DWORD __RPC_FAR *pdwTimerId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KillTimer )( 
            IWMReaderStreamClock __RPC_FAR * This,
            /* [in] */ DWORD dwTimerId);
        
        END_INTERFACE
    } IWMReaderStreamClockVtbl;

    interface IWMReaderStreamClock
    {
        CONST_VTBL struct IWMReaderStreamClockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderStreamClock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMReaderStreamClock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMReaderStreamClock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMReaderStreamClock_GetTime(This,pcnsNow)	\
    (This)->lpVtbl -> GetTime(This,pcnsNow)

#define IWMReaderStreamClock_SetTimer(This,cnsWhen,pvParam,pdwTimerId)	\
    (This)->lpVtbl -> SetTimer(This,cnsWhen,pvParam,pdwTimerId)

#define IWMReaderStreamClock_KillTimer(This,dwTimerId)	\
    (This)->lpVtbl -> KillTimer(This,dwTimerId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_GetTime_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ QWORD __RPC_FAR *pcnsNow);


void __RPC_STUB IWMReaderStreamClock_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_SetTimer_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ QWORD cnsWhen,
    /* [in] */ void __RPC_FAR *pvParam,
    /* [out] */ DWORD __RPC_FAR *pdwTimerId);


void __RPC_STUB IWMReaderStreamClock_SetTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMReaderStreamClock_KillTimer_Proxy( 
    IWMReaderStreamClock __RPC_FAR * This,
    /* [in] */ DWORD dwTimerId);


void __RPC_STUB IWMReaderStreamClock_KillTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMReaderStreamClock_INTERFACE_DEFINED__ */


#ifndef __IWMIndexer_INTERFACE_DEFINED__
#define __IWMIndexer_INTERFACE_DEFINED__

/* interface IWMIndexer */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMIndexer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc71-9888-11d3-8edc-00c04f6109cf")
    IWMIndexer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartIndexing( 
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIndexerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMIndexer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMIndexer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMIndexer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartIndexing )( 
            IWMIndexer __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            IWMIndexer __RPC_FAR * This);
        
        END_INTERFACE
    } IWMIndexerVtbl;

    interface IWMIndexer
    {
        CONST_VTBL struct IWMIndexerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIndexer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIndexer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIndexer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIndexer_StartIndexing(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> StartIndexing(This,pwszURL,pCallback,pvContext)

#define IWMIndexer_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIndexer_StartIndexing_Proxy( 
    IWMIndexer __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwszURL,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
    /* [in] */ void __RPC_FAR *pvContext);


void __RPC_STUB IWMIndexer_StartIndexing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMIndexer_Cancel_Proxy( 
    IWMIndexer __RPC_FAR * This);


void __RPC_STUB IWMIndexer_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIndexer_INTERFACE_DEFINED__ */


#ifndef __IWMIndexer2_INTERFACE_DEFINED__
#define __IWMIndexer2_INTERFACE_DEFINED__

/* interface IWMIndexer2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMIndexer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B70F1E42-6255-4df0-A6B9-02B212D9E2BB")
    IWMIndexer2 : public IWMIndexer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ WMT_INDEXER_TYPE nIndexerType,
            /* [in] */ void __RPC_FAR *pvInterval,
            /* [in] */ void __RPC_FAR *pvIndexType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIndexer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMIndexer2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMIndexer2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMIndexer2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartIndexing )( 
            IWMIndexer2 __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwszURL,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback,
            /* [in] */ void __RPC_FAR *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            IWMIndexer2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IWMIndexer2 __RPC_FAR * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ WMT_INDEXER_TYPE nIndexerType,
            /* [in] */ void __RPC_FAR *pvInterval,
            /* [in] */ void __RPC_FAR *pvIndexType);
        
        END_INTERFACE
    } IWMIndexer2Vtbl;

    interface IWMIndexer2
    {
        CONST_VTBL struct IWMIndexer2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIndexer2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMIndexer2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMIndexer2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMIndexer2_StartIndexing(This,pwszURL,pCallback,pvContext)	\
    (This)->lpVtbl -> StartIndexing(This,pwszURL,pCallback,pvContext)

#define IWMIndexer2_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)


#define IWMIndexer2_Configure(This,wStreamNum,nIndexerType,pvInterval,pvIndexType)	\
    (This)->lpVtbl -> Configure(This,wStreamNum,nIndexerType,pvInterval,pvIndexType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMIndexer2_Configure_Proxy( 
    IWMIndexer2 __RPC_FAR * This,
    /* [in] */ WORD wStreamNum,
    /* [in] */ WMT_INDEXER_TYPE nIndexerType,
    /* [in] */ void __RPC_FAR *pvInterval,
    /* [in] */ void __RPC_FAR *pvIndexType);


void __RPC_STUB IWMIndexer2_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMIndexer2_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseBackup_INTERFACE_DEFINED__
#define __IWMLicenseBackup_INTERFACE_DEFINED__

/* interface IWMLicenseBackup */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseBackup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05E5AC9F-3FB6-4508-BB43-A4067BA1EBE8")
    IWMLicenseBackup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BackupLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseBackup( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseBackupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMLicenseBackup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BackupLicenses )( 
            IWMLicenseBackup __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseBackup )( 
            IWMLicenseBackup __RPC_FAR * This);
        
        END_INTERFACE
    } IWMLicenseBackupVtbl;

    interface IWMLicenseBackup
    {
        CONST_VTBL struct IWMLicenseBackupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseBackup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseBackup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseBackup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseBackup_BackupLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> BackupLicenses(This,dwFlags,pCallback)

#define IWMLicenseBackup_CancelLicenseBackup(This)	\
    (This)->lpVtbl -> CancelLicenseBackup(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseBackup_BackupLicenses_Proxy( 
    IWMLicenseBackup __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);


void __RPC_STUB IWMLicenseBackup_BackupLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseBackup_CancelLicenseBackup_Proxy( 
    IWMLicenseBackup __RPC_FAR * This);


void __RPC_STUB IWMLicenseBackup_CancelLicenseBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseBackup_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseRestore_INTERFACE_DEFINED__
#define __IWMLicenseRestore_INTERFACE_DEFINED__

/* interface IWMLicenseRestore */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C70B6334-0544-4efb-A245-15E65A004A13")
    IWMLicenseRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RestoreLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseRestore( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMLicenseRestore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestoreLicenses )( 
            IWMLicenseRestore __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelLicenseRestore )( 
            IWMLicenseRestore __RPC_FAR * This);
        
        END_INTERFACE
    } IWMLicenseRestoreVtbl;

    interface IWMLicenseRestore
    {
        CONST_VTBL struct IWMLicenseRestoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseRestore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMLicenseRestore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMLicenseRestore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMLicenseRestore_RestoreLicenses(This,dwFlags,pCallback)	\
    (This)->lpVtbl -> RestoreLicenses(This,dwFlags,pCallback)

#define IWMLicenseRestore_CancelLicenseRestore(This)	\
    (This)->lpVtbl -> CancelLicenseRestore(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMLicenseRestore_RestoreLicenses_Proxy( 
    IWMLicenseRestore __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IWMStatusCallback __RPC_FAR *pCallback);


void __RPC_STUB IWMLicenseRestore_RestoreLicenses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMLicenseRestore_CancelLicenseRestore_Proxy( 
    IWMLicenseRestore __RPC_FAR * This);


void __RPC_STUB IWMLicenseRestore_CancelLicenseRestore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMLicenseRestore_INTERFACE_DEFINED__ */


#ifndef __IWMBackupRestoreProps_INTERFACE_DEFINED__
#define __IWMBackupRestoreProps_INTERFACE_DEFINED__

/* interface IWMBackupRestoreProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMBackupRestoreProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C8E0DA6-996F-4ff3-A1AF-4838F9377E2E")
    IWMBackupRestoreProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropCount( 
            /* [out] */ WORD __RPC_FAR *pcProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByIndex( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByName( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProp( 
            /* [in] */ LPCWSTR pcwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllProps( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMBackupRestorePropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropCount )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [out] */ WORD __RPC_FAR *pcProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropByIndex )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR __RPC_FAR *pwszName,
            /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropByName )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ WORD __RPC_FAR *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE __RPC_FAR *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProp )( 
            IWMBackupRestoreProps __RPC_FAR * This,
            /* [in] */ LPCWSTR pcwszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllProps )( 
            IWMBackupRestoreProps __RPC_FAR * This);
        
        END_INTERFACE
    } IWMBackupRestorePropsVtbl;

    interface IWMBackupRestoreProps
    {
        CONST_VTBL struct IWMBackupRestorePropsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMBackupRestoreProps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMBackupRestoreProps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMBackupRestoreProps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMBackupRestoreProps_GetPropCount(This,pcProps)	\
    (This)->lpVtbl -> GetPropCount(This,pcProps)

#define IWMBackupRestoreProps_GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_GetPropByName(This,pszName,pType,pValue,pcbLength)	\
    (This)->lpVtbl -> GetPropByName(This,pszName,pType,pValue,pcbLength)

#define IWMBackupRestoreProps_SetProp(This,pszName,Type,pValue,cbLength)	\
    (This)->lpVtbl -> SetProp(This,pszName,Type,pValue,cbLength)

#define IWMBackupRestoreProps_RemoveProp(This,pcwszName)	\
    (This)->lpVtbl -> RemoveProp(This,pcwszName)

#define IWMBackupRestoreProps_RemoveAllProps(This)	\
    (This)->lpVtbl -> RemoveAllProps(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropCount_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [out] */ WORD __RPC_FAR *pcProps);


void __RPC_STUB IWMBackupRestoreProps_GetPropCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByIndex_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ WORD wIndex,
    /* [out] */ WCHAR __RPC_FAR *pwszName,
    /* [out][in] */ WORD __RPC_FAR *pcchNameLen,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_GetPropByName_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ WORD __RPC_FAR *pcbLength);


void __RPC_STUB IWMBackupRestoreProps_GetPropByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_SetProp_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ WMT_ATTR_DATATYPE Type,
    /* [in] */ const BYTE __RPC_FAR *pValue,
    /* [in] */ WORD cbLength);


void __RPC_STUB IWMBackupRestoreProps_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveProp_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This,
    /* [in] */ LPCWSTR pcwszName);


void __RPC_STUB IWMBackupRestoreProps_RemoveProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMBackupRestoreProps_RemoveAllProps_Proxy( 
    IWMBackupRestoreProps __RPC_FAR * This);


void __RPC_STUB IWMBackupRestoreProps_RemoveAllProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMBackupRestoreProps_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo_INTERFACE_DEFINED__
#define __IWMCodecInfo_INTERFACE_DEFINED__

/* interface IWMCodecInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A970F41E-34DE-4a98-B3BA-E4B3CA7528F0")
    IWMCodecInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatCount( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormat( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCodecInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCodecInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatCount )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormat )( 
            IWMCodecInfo __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);
        
        END_INTERFACE
    } IWMCodecInfoVtbl;

    interface IWMCodecInfo
    {
        CONST_VTBL struct IWMCodecInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCodecInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCodecInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCodecInfo_GetCodecInfoCount(This,guidType,pcCodecs)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs)

#define IWMCodecInfo_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)

#define IWMCodecInfo_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecInfoCount_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [out] */ DWORD __RPC_FAR *pcCodecs);


void __RPC_STUB IWMCodecInfo_GetCodecInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormatCount_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [out] */ DWORD __RPC_FAR *pcFormat);


void __RPC_STUB IWMCodecInfo_GetCodecFormatCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo_GetCodecFormat_Proxy( 
    IWMCodecInfo __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ DWORD dwFormatIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);


void __RPC_STUB IWMCodecInfo_GetCodecFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCodecInfo_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo2_INTERFACE_DEFINED__
#define __IWMCodecInfo2_INTERFACE_DEFINED__

/* interface IWMCodecInfo2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA65E273-B686-4056-91EC-DD768D4DF710")
    IWMCodecInfo2 : public IWMCodecInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecName( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ WCHAR __RPC_FAR *wszName,
            /* [out] */ DWORD __RPC_FAR *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatDesc( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig,
            /* [out] */ WCHAR __RPC_FAR *wszDesc,
            /* [out][in] */ DWORD __RPC_FAR *pcchDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCodecInfo2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCodecInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatCount )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormat )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecName )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ WCHAR __RPC_FAR *wszName,
            /* [out] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatDesc )( 
            IWMCodecInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig,
            /* [out] */ WCHAR __RPC_FAR *wszDesc,
            /* [out][in] */ DWORD __RPC_FAR *pcchDesc);
        
        END_INTERFACE
    } IWMCodecInfo2Vtbl;

    interface IWMCodecInfo2
    {
        CONST_VTBL struct IWMCodecInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCodecInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCodecInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCodecInfo2_GetCodecInfoCount(This,guidType,pcCodecs)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs)

#define IWMCodecInfo2_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)

#define IWMCodecInfo2_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)


#define IWMCodecInfo2_GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName)	\
    (This)->lpVtbl -> GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName)

#define IWMCodecInfo2_GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc)	\
    (This)->lpVtbl -> GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCodecInfo2_GetCodecName_Proxy( 
    IWMCodecInfo2 __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [out] */ WCHAR __RPC_FAR *wszName,
    /* [out] */ DWORD __RPC_FAR *pcchName);


void __RPC_STUB IWMCodecInfo2_GetCodecName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo2_GetCodecFormatDesc_Proxy( 
    IWMCodecInfo2 __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ DWORD dwFormatIndex,
    /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig,
    /* [out] */ WCHAR __RPC_FAR *wszDesc,
    /* [out][in] */ DWORD __RPC_FAR *pcchDesc);


void __RPC_STUB IWMCodecInfo2_GetCodecFormatDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCodecInfo2_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo3_INTERFACE_DEFINED__
#define __IWMCodecInfo3_INTERFACE_DEFINED__

/* interface IWMCodecInfo3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7e51f487-4d93-4f98-8ab4-27d0565adc51")
    IWMCodecInfo3 : public IWMCodecInfo2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatProp( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecProp( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfo3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWMCodecInfo3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWMCodecInfo3 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWMCodecInfo3 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInfoCount )( 
            IWMCodecInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD __RPC_FAR *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatCount )( 
            IWMCodecInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD __RPC_FAR *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormat )( 
            IWMCodecInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecName )( 
            IWMCodecInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ WCHAR __RPC_FAR *wszName,
            /* [out] */ DWORD __RPC_FAR *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatDesc )( 
            IWMCodecInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig __RPC_FAR *__RPC_FAR *ppIStreamConfig,
            /* [out] */ WCHAR __RPC_FAR *wszDesc,
            /* [out][in] */ DWORD __RPC_FAR *pcchDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecFormatProp )( 
            IWMCodecInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecProp )( 
            IWMCodecInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
            /* [out] */ BYTE __RPC_FAR *pValue,
            /* [out][in] */ DWORD __RPC_FAR *pdwSize);
        
        END_INTERFACE
    } IWMCodecInfo3Vtbl;

    interface IWMCodecInfo3
    {
        CONST_VTBL struct IWMCodecInfo3Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWMCodecInfo3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWMCodecInfo3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWMCodecInfo3_GetCodecInfoCount(This,guidType,pcCodecs)	\
    (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs)

#define IWMCodecInfo3_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)

#define IWMCodecInfo3_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)


#define IWMCodecInfo3_GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName)	\
    (This)->lpVtbl -> GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName)

#define IWMCodecInfo3_GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc)	\
    (This)->lpVtbl -> GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc)


#define IWMCodecInfo3_GetCodecFormatProp(This,guidType,dwCodecIndex,dwFormatIndex,pszName,pType,pValue,pdwSize)	\
    (This)->lpVtbl -> GetCodecFormatProp(This,guidType,dwCodecIndex,dwFormatIndex,pszName,pType,pValue,pdwSize)

#define IWMCodecInfo3_GetCodecProp(This,guidType,dwCodecIndex,pszName,pType,pValue,pdwSize)	\
    (This)->lpVtbl -> GetCodecProp(This,guidType,dwCodecIndex,pszName,pType,pValue,pdwSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWMCodecInfo3_GetCodecFormatProp_Proxy( 
    IWMCodecInfo3 __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ DWORD dwFormatIndex,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize);


void __RPC_STUB IWMCodecInfo3_GetCodecFormatProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWMCodecInfo3_GetCodecProp_Proxy( 
    IWMCodecInfo3 __RPC_FAR * This,
    /* [in] */ REFGUID guidType,
    /* [in] */ DWORD dwCodecIndex,
    /* [in] */ LPCWSTR pszName,
    /* [out] */ WMT_ATTR_DATATYPE __RPC_FAR *pType,
    /* [out] */ BYTE __RPC_FAR *pValue,
    /* [out][in] */ DWORD __RPC_FAR *pdwSize);


void __RPC_STUB IWMCodecInfo3_GetCodecProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWMCodecInfo3_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\adler32.c ===
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* $Id: adler32.c,v 1.10 1996/05/22 11:52:18 me Exp $ */

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#include "zlib.h"

#define BASE 65521L /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* ========================================================================= */
uLong adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
    unsigned long s1 = adler & 0xffff;
    unsigned long s2 = (adler >> 16) & 0xffff;
    int k;

    if (buf == Z_NULL) return 1L;

    while (len > 0) {
        k = len < NMAX ? len : NMAX;
        len -= k;
        while (k >= 16) {
            DO16(buf);
	    buf += 16;
            k -= 16;
        }
        if (k != 0) do {
            s1 += *buf++;
	    s2 += s1;
        } while (--k);
        s1 %= BASE;
        s2 %= BASE;
    }
    return (s2 << 16) | s1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\crc32.c ===
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

// new
#define ZEXPORT
//////

#include "zlib.h"


#define local static

#ifdef DYNAMIC_CRC_TABLE

local int crc_table_empty = 1;
local uLongf crc_table[256];
local void make_crc_table OF((void));

/*
  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The table is simply the CRC of all possible eight bit values.  This is all
  the information needed to generate CRC's on data a byte at a time for all
  combinations of CRC register values and incoming bytes.
*/
local void make_crc_table()
{
  uLong c;
  int n, k;
  uLong poly;            /* polynomial exclusive-or pattern */
  /* terms of polynomial defining this crc (except x^32): */
  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

  /* make exclusive-or pattern from polynomial (0xedb88320L) */
  poly = 0L;
  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
    poly |= 1L << (31 - p[n]);
 
  for (n = 0; n < 256; n++)
  {
    c = (uLong)n;
    for (k = 0; k < 8; k++)
      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    crc_table[n] = c;
  }
  crc_table_empty = 0;
}
#else
/* ========================================================================
 * Table of CRC-32's of all single-byte values (made by make_crc_table)
 */
local const uLongf crc_table[256] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
  0x2d02ef8dL
};
#endif

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const uLongf * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
  if (crc_table_empty) make_crc_table();
#endif
  return (const uLongf *)crc_table;
}

/* ========================================================================= */
#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

/* ========================================================================= */
uLong ZEXPORT crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
    if (buf == Z_NULL) return 0L;
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
    } while (--len);
    return crc ^ 0xffffffffL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\csdpsrc.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        csdpsrc.cpp

    Abstract:

        This module implements the announcement object.

    Author:

        James Meyer (a-jmeyer)

    Revision History:

        

--*/

#include "stdafx.h"
#include "csdpsrc.h"
#include <math.h>
#include <stdio.h>

#include "DbgStuff.h"
#include "AtvefMsg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// -------------------------------------------------------------------------

//
// Constructor
//
CSDPSource::CSDPSource()
{
	HRESULT		hr = S_OK;			// parameters really set in InitAll()

	m_uiSessionID = 0;
	m_fDeleteAnnc = false;

	m_fConLID = 1.0;
	m_bPrimary = TRUE;
	m_uiSecondsToEnd = 0;
	m_usMsgIDHash = 0;

	m_bSDAPacket = TRUE;			// if FALSE, generating a Session Description Deletion Packet

	m_cConfAttrib = 1;						// starts at 1;

	m_lAnncPort				= 0;
	m_uiAnncTTL				= 0;			// scope ?
	m_ulAnncMaxBandwidth	= 0;			// unused so far ???

	m_langIDSessionLang		= 0;
	m_langIDSDPLang			= 0;

//	m_cATVEFMediaDescs = 0;

} // (Constructor)

HRESULT CSDPSource::FinalConstruct()
{
	HRESULT hr;

	IATVEFAttrListPtr spAttrList = IATVEFAttrListPtr(CLSID_ATVEFAttrList);
	if(NULL == spAttrList) {
		m_spalExtraAttributes = NULL;	
		return E_OUTOFMEMORY;
	} else {		
		m_spalExtraAttributes = spAttrList;
	}

	IATVEFAttrListPtr spAttrList1 = IATVEFAttrListPtr(CLSID_ATVEFAttrList);
	if(NULL == spAttrList) {
		m_spalExtraFlags = NULL;	
		return E_OUTOFMEMORY;
	} else {		
		m_spalExtraFlags = spAttrList1;
	}

	IATVEFAttrListPtr spAttrList2 = IATVEFAttrListPtr(CLSID_ATVEFAttrList);
	if(NULL == spAttrList2) {
		m_spalEmailAddresses = NULL;	
		return E_OUTOFMEMORY;
	} else {		
		m_spalEmailAddresses = spAttrList2;
	}

	IATVEFAttrListPtr spAttrList3 = IATVEFAttrListPtr(CLSID_ATVEFAttrList);
	if(NULL == spAttrList3) {
		m_spalPhoneNumbers = NULL;	
		return E_OUTOFMEMORY;
	} else {		
		m_spalPhoneNumbers = spAttrList3;
	}

	IATVEFStartStopListPtr spSSList = IATVEFStartStopListPtr(CLSID_ATVEFStartStopList);
	if(NULL == spSSList) {
		m_splStartStop = NULL;	
		return E_OUTOFMEMORY;
	} else {		
		m_splStartStop = spSSList;
	}

				// ATVEFMedias do not have CoClasses
	CComObject<CATVEFMedias> *pMedias;
	hr = CComObject<CATVEFMedias>::CreateInstance(&pMedias);
	if(FAILED(hr))
		return hr;
	hr = pMedias->QueryInterface(&m_spMedias);			// typesafe QI
	if(FAILED(hr)) {
		delete pMedias;
		return hr;
	}

	return S_OK;
}

HRESULT CSDPSource::FinalRelease()
{
		// Free up e-mail bstrs (CComBSTR's - they free automagically)
	m_spalEmailAddresses = NULL;
	m_spalPhoneNumbers = NULL;
	m_spalExtraAttributes = NULL;
	m_spalExtraFlags = NULL;
	m_splStartStop = NULL;
	return S_OK;
}

CSDPSource::~CSDPSource()
{

/*
	// Delete the Media Descriptions
	if(m_cMedDescs)
	{
		for(i = 0; i < m_cMedDescs; i++)
		{
			if(m_paMedDescs[i])
			{
				delete m_paMedDescs[i];
			}
		}
	}
*/

}  //~CSDPSource

//
//  Internal Methods
//


//
// ITVEAnnouncement Implementation
//


/*
HRESULT CSDPSource::GetMediaCount(UINT *piMediaCount)
{
	*piMediaCount = m_cMedDescs;
	return S_OK;
}
*/



HRESULT	CSDPSource::put_SendingIPULONG(ULONG ulIP)
{
	BSTR bstrX;
	HRESULT	hr = ConvertLONGIPToBSTR(ulIP, &bstrX);
	if(!FAILED(hr))
		m_spbsSendingIP = bstrX;
	return hr;
}

HRESULT	CSDPSource::get_SendingIPULONG(ULONG *pulIP)
{
	HRESULT hr = ConvertBSTRToLONGIP(m_spbsSendingIP, (LONG *) pulIP);
	return hr;
}

HRESULT	CSDPSource::put_SAPSendingIPULONG(ULONG ulIP)
{
	BSTR bstrX;
	HRESULT	hr = ConvertLONGIPToBSTR(ulIP, &bstrX);
	if(!FAILED(hr))
		m_spbsSAPSendingIP = bstrX;
	return hr;
}

HRESULT	CSDPSource::get_SAPSendingIPULONG(ULONG *pulIP)
{
	HRESULT hr = ConvertBSTRToLONGIP(m_spbsSAPSendingIP, (LONG *) pulIP);
	return hr;
}
HRESULT CSDPSource::put_UserName(BSTR bstrUserName)
{
	HRESULT		hr = S_OK;	
	m_spbsUserName = bstrUserName;
	WCHAR *wch = m_spbsUserName.m_str;
	while(*wch) {
		if(isspace(*wch)) { *wch = '_';	hr = E_INVALIDARG;}	// no spaces allowed!
		wch++;
	}
	return hr;
}

HRESULT CSDPSource::get_UserName(BSTR *pbstrUserName)
{
	return m_spbsUserName.CopyTo(pbstrUserName);
}

HRESULT CSDPSource::put_SessionID(UINT uiSessionID)
{
	m_uiSessionID = uiSessionID;
	return S_OK;
}

HRESULT CSDPSource::get_SessionID(UINT *puiSessionID)
{
	*puiSessionID = m_uiSessionID;
	return S_OK;
}


HRESULT	CSDPSource::put_SessionVersion(UINT iVersion)
{
	m_uiVersionID = iVersion;
	return S_OK;
}


HRESULT	CSDPSource::get_SessionVersion(UINT *piVersion)
{
	*piVersion = m_uiVersionID;
	return S_OK;
}


HRESULT CSDPSource::put_SessionName(BSTR bstrName)
{
	m_spbsSessionName = bstrName;
	return S_OK;
}

HRESULT CSDPSource::get_SessionName(BSTR *pbstrName)
{
	return m_spbsSessionName.CopyTo(pbstrName);
}


HRESULT CSDPSource::put_SessionURL(BSTR bstrURL)
{
	m_spbsURL = bstrURL;
	return S_OK;
}

HRESULT CSDPSource::get_SessionURL(BSTR *pbstrURL)
{
	return m_spbsURL.CopyTo(pbstrURL);
}

// ----------------
//   Uses email address as a map key.  Hence will fail if attempt to
//	  add more than one emailaddr/emailname pair with same email address.
HRESULT CSDPSource::AddEMail(BSTR bstrEMailAddress, BSTR bstrEMailName)
{
	HRESULT		hr = S_OK;

	// EMail Address is required
	if(!bstrEMailAddress)
	{
		return E_FAIL;
	}
	return m_spalEmailAddresses->Add(bstrEMailAddress, bstrEMailName);
}

HRESULT CSDPSource::get_EmailAddresses(IUnknown **ppVal)
{
 	HRESULT hr;
 	if (ppVal == NULL)
		return E_POINTER;
	try {
        hr = m_spalEmailAddresses->QueryInterface(ppVal);
    } catch(...) {
        return E_POINTER;
    }
	return hr;
}



// ----------------
//   Uses phone number as a list key.  Hence will fail if attempt to
//	  add more than one phone number/name pair with same phone number.
HRESULT CSDPSource::AddPhone(BSTR bstrPhoneNumber, BSTR bstrName)
{

	return m_spalPhoneNumbers->Add(bstrPhoneNumber, bstrName);
}

HRESULT CSDPSource::get_PhoneNumbers(IUnknown **ppVal)
{
 	HRESULT hr;
 	if (ppVal == NULL)
		return E_POINTER;
	try {
        hr = m_spalPhoneNumbers->QueryInterface(ppVal);
    } catch(...) {
        return E_POINTER;
    }
	return hr;
}

// ----------------
//   Uses key a map key.  Hence will fail if attempt to
//	  add more than one key/name pair with same key.
HRESULT CSDPSource::AddExtraAttribute(BSTR bstrKey, BSTR bstrValue)
{
	return m_spalExtraAttributes->Add(bstrKey, bstrValue);
}

HRESULT CSDPSource::get_ExtraAttributes(IUnknown **ppVal)
{
 	HRESULT hr;
 	if (ppVal == NULL)
		return E_POINTER;
	try {
        hr = m_spalExtraAttributes->QueryInterface(ppVal);
    } catch(...) {
        return E_POINTER;
    }
	return hr;
}


// use the flag "x=' as the key. Will fail if adding more than one 'key' with the same value... (don't use for 'a')
HRESULT CSDPSource::AddExtraFlag(BSTR bstrKey, BSTR bstrValue)
{
	return m_spalExtraFlags->Add(bstrKey, bstrValue);
}

HRESULT CSDPSource::get_ExtraFlags(IUnknown **ppVal)
{
 	HRESULT hr;
 	if (ppVal == NULL)
		return E_POINTER;
	try {
        hr = m_spalExtraFlags->QueryInterface(ppVal);
    } catch(...) {
        return E_POINTER;
    }
	return hr;
}



//	AddStartStopTime
//
//	This method allows the user to add pairs of start/stop times for the session.
//
//
//
HRESULT CSDPSource::AddStartStopTime(DATE dtStartTime, DATE dtStopTime)
{

	m_splStartStop->Add(dtStartTime, dtStopTime);

	return S_OK;
}

HRESULT CSDPSource::GetStartStopTime(int iLoc, DATE *pdtStartTime, DATE *pdtStopTime)
{
	HRESULT hr = S_OK;
	CComVariant cvLoc(iLoc);		// rather inefficent interface - rewrite one of these days...
	hr = m_splStartStop->get_Key(cvLoc, pdtStartTime);
	if(S_OK != hr) {
		*pdtStartTime = 0.0;
		*pdtStopTime = 0.0;
		return S_FALSE;
	}
	return m_splStartStop->get_Item(cvLoc, pdtStopTime);
}

HRESULT CSDPSource::put_UUID(BSTR bstrGuid)
{
	HRESULT		hr = S_OK;

	m_spbsSessionUUID.Empty();
	CComBSTR bstrT(L"{");		// need to pack the "{}" around the guid
	bstrT += bstrGuid;
	bstrT += L"}";
//	hr = CLSIDFromString(bstrT, &m_guidSessionUUID);	// convert to numerical format
	if(!FAILED(hr)) {
		m_spbsSessionUUID = bstrGuid;
	} else {
//		m_guidSessionUUID = CLSID_NULL;				// if failed, set everything to NULL
		LPOLESTR	lpolestr = NULL;
		StringFromCLSID(CLSID_NULL, &lpolestr);
				// strip off the braces
		WCHAR *pwc = lpolestr;
		int ilen = wcslen(lpolestr);
		*(pwc+ilen-1) = L'\0';
		pwc++;
		m_spbsSessionUUID = lpolestr;
		CoTaskMemFree(lpolestr);
	}

	return hr;
}

HRESULT CSDPSource::get_UUID(BSTR *pbstrGuid)
{
	return m_spbsSessionUUID.CopyTo(pbstrGuid);
}

HRESULT CSDPSource::put_LangID(LANGID langid)
{
	BSTR		bstrNewLangBSTR;
	HRESULT		hr;

	hr = GetLangBSTRFromLangID(&bstrNewLangBSTR, langid);
	if(FAILED(hr))
		return hr;

	m_spbsSessionLang = bstrNewLangBSTR;
	m_langIDSessionLang = langid;

	return S_OK;
}

HRESULT CSDPSource::get_LangID(LANGID *plangid)
{
	*plangid = m_langIDSessionLang;

	return S_OK;
}

HRESULT CSDPSource::put_SDPLangID(LANGID langid)
{
	BSTR		bstrNewLangBSTR;
	HRESULT		hr;

	hr = GetLangBSTRFromLangID(&bstrNewLangBSTR, langid);
	if(FAILED(hr))
		return hr;

	m_spbsSDPLang = bstrNewLangBSTR;
	m_langIDSDPLang = langid;

	return hr;
}

HRESULT CSDPSource::get_SDPLangID(LANGID *plangid)
{
	HRESULT hr = S_OK;
	*plangid = m_langIDSDPLang;

	return S_OK;
}

HRESULT	CSDPSource::put_ContentLevelID(FLOAT fConLID)
{
	m_fConLID = fConLID;
	return S_OK;
}

HRESULT	CSDPSource::get_ContentLevelID(FLOAT *pfConLID)
{
	*pfConLID = m_fConLID;
	return S_OK;
}

HRESULT CSDPSource::put_Primary(BOOL bPrimary)
{
	m_bPrimary = bPrimary;
	return S_OK;
}

HRESULT CSDPSource::get_Primary(BOOL *pbPrimary)
{
	*pbPrimary = m_bPrimary;
	return S_OK;
}

HRESULT CSDPSource::put_SecondsToEnd(UINT uiSecondsToEnd)
{
	m_uiSecondsToEnd = uiSecondsToEnd;
	return S_OK;
}

HRESULT CSDPSource::get_SecondsToEnd(UINT *puiSecondsToEnd)
{
	*puiSecondsToEnd = m_uiSecondsToEnd;
	return S_OK;
}

HRESULT	CSDPSource::put_CacheSize(ULONG ulSize)
{
	if(ulSize > 1000000)
		return E_INVALIDARG;
	m_ulSize = ulSize;
	return S_OK;
}

HRESULT	CSDPSource::get_CacheSize(ULONG *pulSize)
{
	*pulSize = m_ulSize;
	return S_OK;
}

HRESULT CSDPSource::put_SessionLabel(BSTR bstrLabel)
{
    m_spbsSessionLabel = bstrLabel;
    return S_OK ;
}
HRESULT CSDPSource::get_SessionLabel(BSTR *pbstrLabel)
{
	return m_spbsSessionLabel.CopyTo(pbstrLabel);
}

// ------------------------------------------------------------------
// Use to override the default IP address/port used for ATVEF
//		
// 
// ------------------------------------------------------------------
HRESULT 
CSDPSource::SetAnncStrmAddULONG(ULONG ulIP, UINT uiTTL, LONG lPort, ULONG ulMaxBandwidth)
{
	HRESULT		hr;

	BSTR bstrX;
	hr = ConvertLONGIPToBSTR(ulIP, &bstrX);

	if(FAILED(hr))
		return hr;
	m_spbsAnncAddIP		 = bstrX;
	m_lAnncPort			 = lPort;
	m_uiAnncTTL			 = uiTTL;
	m_ulAnncMaxBandwidth = ulMaxBandwidth;

	return hr;
}

HRESULT 
CSDPSource::GetAnncStrmAddULONG(ULONG *pulIP, UINT *puiTTL, LONG *plPort, ULONG *pulMaxBandwidth)
{
	HRESULT		hr = S_OK;
	if(plPort)				*plPort				= m_lAnncPort;
	if(puiTTL)				*puiTTL				= m_uiAnncTTL;
	if(pulMaxBandwidth)		*pulMaxBandwidth	= m_ulAnncMaxBandwidth ;

	if(pulIP)
		hr = ConvertBSTRToLONGIP(m_spbsAnncAddIP, (LONG *) pulIP);
	if(FAILED(hr))
		return hr;

	
	return S_OK;
}

// -------------------------------------------------------------------
//  GetAnnouncement()
//
//		Main routine - converts parameters in data structure into
//		a valid SAP/SDP object.  (Note - first 8 bytes of returned
//		announcement may contain zeros.  Hence strlen is wrong.)
//
// ---------------------------------------------------------------------
HRESULT CSDPSource::GetAnnouncement(UINT *puiSize, char **ppAnnouncement)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;

#define MAX_WORKING_SIZE	5000		// SDP Spec says text payload should not exceed 1k
#define MAX_SDP_ANNC_SIZE	1024+8		// so.. 8 byte SAP header plus 1k sdp

	char		*pcAnnce, *pcInsert, *buffer;
	int			j;
	ULONG		ul;
	int			decimal, sign;
	_bstr_t		bstrt;

	if(NULL == ppAnnouncement) return E_POINTER;
	*ppAnnouncement = NULL;

	// Validate the announcement
	int iErrLoc;
	if(!AnncValid(&iErrLoc)) {
									// see AnncValid for what I'm doing here.
		if(iErrLoc < 10)
			return (ATVEFSEND_E_ANNC_INVALID_SENDINGIP + iErrLoc);
		if((iErrLoc%10) < 5)
			return ATVEFSEND_E_MEDIA_INVALID_DATAPARAM;		// could provide even more info here
		if((iErrLoc%10) >= 5)
			return ATVEFSEND_E_MEDIA_INVALID_TRIGGERPARAM;
		return E_FAIL;
	}

	// Allocate mondo buffer
	pcAnnce = new char[MAX_WORKING_SIZE];
	if(!pcAnnce)
		return E_OUTOFMEMORY;
	pcInsert = pcAnnce;
	if(!pcInsert)
		return E_OUTOFMEMORY;
	int iDeleteAnnc = 0;									// ATVEF does not provide for delete announcements

	// Start with the the SAP Header
	int iLen;
	hr = AppendSAPHeader(&iLen, pcInsert);
	pcInsert += iLen;
	
	// Build the SDP Packet.
	strcpy(pcInsert, "v=0\no=");
	pcInsert+= sizeof("v=0\no=")-1;
	// build originator string
	if(m_spbsUserName)
	{
		bstrt = m_spbsUserName;
		strcpy(pcInsert, (char*)bstrt);
		pcInsert += bstrt.length();
		*pcInsert++ = ' ';
	}
	else	// default User name is "-"
	{
		*pcInsert++ = '-';
		*pcInsert++ = ' ';
	}
		// Session ID
	ul = m_uiSessionID;
//	ultoa(ul, pcInsert, 10);
	_ultoa(ul, pcInsert,10);
	while(*pcInsert) pcInsert++;
	*pcInsert++ = ' ';
		// Version Number
	ul = m_uiVersionID;
//	ultoa(ul, pcInsert, 10);
	_ultoa(ul, pcInsert, 10);
	while(*pcInsert) pcInsert++;
	strcpy(pcInsert, " IN IP4 ");
	pcInsert += strlen(" IN IP4 ");

	strcpy(pcInsert, W2A(m_spbsSendingIP));  
	pcInsert += m_spbsSendingIP.Length();

	// Session Name
	strcpy(pcInsert, "\ns=");
	pcInsert += sizeof("\ns=") - 1;
	bstrt = m_spbsSessionName;
	strcpy(pcInsert, (char*)bstrt);
	pcInsert += bstrt.length();
	*pcInsert++ = '\n';

	// enhancement UUID
	if(m_spbsURL)
	{
		strcpy(pcInsert, "u=");
		pcInsert += sizeof("u=")-1;
		bstrt = m_spbsURL;
		strcpy(pcInsert, bstrt);
		pcInsert += bstrt.length();
		*pcInsert++ = '\n';
	}

	{
		LONG cAttrs;
		m_spalEmailAddresses->get_Count(&cAttrs);	
		if(cAttrs > 0) 
		{
			CComBSTR spbsInsert;
			for(int i = 0; i < cAttrs; i++) {
				CComBSTR spbsKey, spbsItem;		// address, name
				CComVariant id(i);
				m_spalEmailAddresses->get_Key(id, &spbsKey);
				m_spalEmailAddresses->get_Item(id, &spbsItem);
				spbsInsert = L"e=";
				spbsInsert += spbsKey;
				if(spbsItem.Length()) {
					spbsInsert += L" (";
					spbsInsert += spbsItem;
					spbsInsert += L")";
				}
				spbsInsert += L"\n";
				strcpy(pcInsert, W2A(spbsInsert));
				pcInsert += spbsInsert.Length();
			}
		}
	}
	{
		LONG cAttrs;
		m_spalPhoneNumbers->get_Count(&cAttrs);	
		if(cAttrs > 0) 
		{
			CComBSTR spbsInsert;
			for(int i = 0; i < cAttrs; i++) {
				CComBSTR spbsKey, spbsItem;		// address, name
				CComVariant id(i);
				m_spalPhoneNumbers->get_Key(id, &spbsKey);
				m_spalPhoneNumbers->get_Item(id, &spbsItem);
				spbsInsert = L"p=";
				spbsInsert += spbsKey;
				if(spbsItem.Length()) {
					spbsInsert += L" (";
					spbsInsert += spbsItem;
					spbsInsert += L")";
				}
				spbsInsert += L"\n";
				strcpy(pcInsert, W2A(spbsInsert));
				pcInsert += spbsInsert.Length();
			}
		}
	}
					// extra attributes
	{
		LONG cAttrs;
		m_spalExtraAttributes->get_Count(&cAttrs);	
		if(cAttrs > 0) 
		{
			CComBSTR spbsInsert;
			for(int i = 0; i < cAttrs; i++) {
				CComBSTR spbsKey, spbsItem;		// address, name
				CComVariant id(i);
				m_spalExtraAttributes->get_Key(id, &spbsKey);
				m_spalExtraAttributes->get_Item(id, &spbsItem);
				spbsInsert = L"a=";
				spbsInsert += spbsKey;
				if(spbsItem && (spbsItem.Length() > 0)) 
				{
					spbsInsert += L":";
					spbsInsert += spbsItem;
				}
				spbsInsert += L"\n";
				strcpy(pcInsert, W2A(spbsInsert));
				pcInsert += spbsInsert.Length();
			}
		}
	}

					// extra flags
	{
		LONG cAttrs;
		m_spalExtraFlags->get_Count(&cAttrs);	
		if(cAttrs > 0) 
		{
			for(int i = 0; i < cAttrs; i++) {
				CComBSTR spbsKey, spbsItem;		// address, name
				CComVariant id(i);
				m_spalExtraFlags->get_Key(id, &spbsKey);
				m_spalExtraFlags->get_Item(id, &spbsItem);
				CComBSTR spbsInsert;
				spbsInsert += spbsKey;
				spbsInsert += L"=";			// don't do += '=' here, CComBSTR does bad things...
				spbsInsert += spbsItem;
				spbsInsert += L"\n";			
				strcpy(pcInsert, W2A(spbsInsert));
				pcInsert += spbsInsert.Length();
			}
		}
	}
	// Start/Stop Times
	ULONG ulStart, ulStop;
	{
		int i = 0;
		DATE dateStart, dateStop;
		while(S_OK == GetStartStopTime(i, &dateStart, &dateStop))
		{
			ulStart = DATEtoNTP(dateStart);
			if(dateStop == 0.0)
				ulStop = 0;							// atvef Spec.
			else
				ulStop = DATEtoNTP(dateStop);
			
			strcpy(pcInsert, "t=");
			pcInsert += sizeof("t=")-1;
			_ultoa(ulStart, pcInsert, 10);
			while(*pcInsert) pcInsert++;			// search to the end of the string
			*pcInsert++ = ' ';
			_ultoa(ulStop, pcInsert, 10);
			while(*pcInsert) pcInsert++;			// search to the end of the string
			*pcInsert++ = '\n';

			i++;
		}
	}

	// GUID
	if(m_spbsSessionUUID)
	{
		strcpy(pcInsert, "a=UUID:");
		pcInsert += sizeof("a=UUID:")-1;
		strcpy(pcInsert, W2A(m_spbsSessionUUID));
		pcInsert += m_spbsSessionUUID.Length();
		*pcInsert++ = '\n';
	}
	// required, non-modifiable string
	strcpy(pcInsert, "a=type:tve\n");
	pcInsert += sizeof("a=type:tve\n")-1;
	// Languages: lang and sdplang
	if(m_spbsSessionLang)
	{
		strcpy(pcInsert, "a=lang:");
		pcInsert += sizeof("a=lang:")-1;
		bstrt =	m_spbsSessionLang;
		strcpy(pcInsert, bstrt);
		pcInsert += bstrt.length();
		*pcInsert++ = '\n';
	}
	if(m_spbsSDPLang)
	{
		strcpy(pcInsert, "a=sdplang:");
		pcInsert += sizeof("a=sdplang:")-1;
		bstrt =	m_spbsSDPLang;
		strcpy(pcInsert, bstrt);
		pcInsert += bstrt.length();
		*pcInsert++ = '\n';
	}
    //  show label
    if (m_spbsSessionLabel) {
        strcpy (pcInsert, "i=") ;
        pcInsert += sizeof ("i=") - 1 ;
        bstrt = m_spbsSessionLabel ;
        strcpy (pcInsert, bstrt) ;
        pcInsert += bstrt.length () ;
        * pcInsert ++ = '\n' ;
    }

	// type:primary 
	//		Default: TRUE (currently all webtv announcements are of type primary)
	if(m_bPrimary)
	{
		strcpy(pcInsert, "a=tve-type:primary\n");
		pcInsert += sizeof("a=tve-type:primary\n")-1;
	}

	// Size: high-water cache size estimate
	strcpy(pcInsert, "a=tve-size:");
	pcInsert += sizeof("a=tve-size:")-1;
	_ultoa(m_ulSize, pcInsert, 10);
	while(*pcInsert) pcInsert++;			// search to the end of the string
	*pcInsert++ = '\n';

	// Content Level Identifier
	buffer = _fcvt( m_fConLID, 1, &decimal, &sign );
	strcpy(pcInsert, "a=tve-level:");
	pcInsert+= sizeof("a=tve-level:")-1;
	for(j = 0; j < decimal; j++)
		*pcInsert++ = *buffer++;
	*pcInsert++ = '.';
	strcpy(pcInsert, buffer);
	while(*pcInsert) pcInsert++;
	*pcInsert++ = '\n';

	// Seconds to End
	if(m_uiSecondsToEnd != 0)
	{
		strcpy(pcInsert, "a=tve-ends:");
		pcInsert += sizeof("a=tve-ends:")-1;
		ul = m_uiSecondsToEnd;
		_ultoa(ul, pcInsert, 10);
		while(*pcInsert) pcInsert++;
		*pcInsert++ = '\n';
	}

	if(m_spMedias)
	{
		long cMedias;
		m_spMedias->get_Count(&cMedias);			// using ITVECollection class here..
		for(long j = 0; j < cMedias; j++)
		{
			IATVEFMediaPtr spMedia;
			CComVariant cv(j);
			m_spMedias->get_Item(cv,&spMedia);
			CComBSTR bstrMedia;
			spMedia->MediaToBSTR(&bstrMedia);
			bstrt = bstrMedia;
			strcpy (pcInsert, bstrt) ;
 			while(*pcInsert) pcInsert++;

		}
	}

	*pcInsert++ = 0;					// Null Terminate for paranoia
	*pcInsert++ = 0;					// Null Terminate for paranoia

	*ppAnnouncement = new char[pcInsert-pcAnnce];
	*puiSize = pcInsert-pcAnnce;

	if(!*ppAnnouncement)
	{
		delete pcAnnce;
		return E_OUTOFMEMORY;
	}
	// copy to sized-to-fit buffer
	if(*puiSize > MAX_SDP_ANNC_SIZE)	// Check to see if the Annc is too large
	{
		*puiSize = 0;
	//	delete pcAnnce;
	//	*ppAnnouncement = NULL;
		hr = ATVEFSEND_E_ANNOUNCEMENT_TOO_LONG;
	}

	memcpy(*ppAnnouncement, pcAnnce, *puiSize);
	delete[] pcAnnce;
	return hr;
}

// -------------------------------------------------------------------
//  GetRawAnnouncement()
//
//		Main routine - converts raw announcement string into
//		a valid SAP/SDP object.  (Note - first 8 bytes of returned
//		announcement may contain zeros.  Hence strlen is wrong.)
//
// ---------------------------------------------------------------------
HRESULT CSDPSource::GetRawAnnouncement(UINT *puiSize, char **ppAnnouncement, BSTR bstrAnnouncement)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;

#define MAX_WORKING_SIZE	5000		// SDP Spec says text payload should not exceed 1k
#define MAX_SDP_ANNC_SIZE	1024+8		// so.. 8 byte SAP header plus 1k sdp

	char		*pcAnnce, *pcInsert;
	_bstr_t		bstrt;

	if(NULL == ppAnnouncement) return E_POINTER;
	*ppAnnouncement = NULL;

	// Allocate mondo buffer
	pcAnnce = new char[MAX_WORKING_SIZE];
	if(!pcAnnce)
		return E_OUTOFMEMORY;
	pcInsert = pcAnnce;
	if(!pcInsert) {
		delete[] pcAnnce;
		return E_OUTOFMEMORY;
	}
	int iDeleteAnnc = 0;									// ATVEF does not provide for delete announcements

	// Start with the the SAP Header
	int iLen;
	hr = AppendSAPHeader(&iLen, pcInsert);
	pcInsert += iLen;
	
	// Build the SDP Packet.

	strcpy(pcInsert, W2A(bstrAnnouncement));
	pcInsert += strlen(W2A(bstrAnnouncement))-1;

	*pcInsert++ = 0;					// Null Terminate for paranoia
	*pcInsert++ = 0;					// Null Terminate for paranoia

	*ppAnnouncement = new char[pcInsert-pcAnnce];
	*puiSize = pcInsert-pcAnnce;

	if(!*ppAnnouncement)
	{
		delete[] pcAnnce;
		return E_OUTOFMEMORY;
	}
	// copy to sized-to-fit buffer
	if(*puiSize > MAX_SDP_ANNC_SIZE)	// Check to see if the Annc is too large
	{
		*puiSize = 0;
	//	delete pcAnnce;
	//	*ppAnnouncement = NULL;
		hr = ATVEFSEND_E_ANNOUNCEMENT_TOO_LONG;
	}

	memcpy(*ppAnnouncement, pcAnnce, *puiSize);
	delete[] pcAnnce;
	return hr;
}


HRESULT CSDPSource::put_SAPMsgIDHash(USHORT usHash)
{
	m_usMsgIDHash = usHash;
	return S_OK;
}

HRESULT CSDPSource::get_SAPMsgIDHash(USHORT *pusHash)
{
	*pusHash = m_usMsgIDHash;
	return S_OK;
}

HRESULT CSDPSource::put_SAPDeleteAnnc(BOOL fDelete)
{
	m_fDeleteAnnc = fDelete;
	return S_OK;
}

HRESULT CSDPSource::get_SAPDeleteAnnc(BOOL *pfDelete)
{
	*pfDelete = m_fDeleteAnnc;
	return S_OK;
}
HRESULT CSDPSource::InitAll(VOID)
{
	// Reset current memory block, set default values

	m_uiSessionID = 0;
	m_uiVersionID = 0;
	m_usMsgIDHash = 0;
	m_fConLID = 1.0;							// Default
	
	m_spbsSAPSendingIP.Empty();
	m_spbsUserName.Empty();
	m_spbsSessionName.Empty();
	m_spbsSessionLabel.Empty();
	m_spbsSessionDescription.Empty();
	m_spbsSessionUUID.Empty();
	m_spbsURL.Empty();
	m_spbsSendingIP.Empty();
	m_spbsSessionLang.Empty();
	m_spbsSDPLang.Empty();
  
	m_bPrimary = TRUE;
	m_uiSecondsToEnd = 0;

	m_bSDAPacket = TRUE;			// if FALSE, generating a Session Description Deletion Packet

	ClearTimes();						// clear out all times
	ClearEmailAddresses();				// Remove e-mail addresses
	ClearPhoneNumbers();				// Remove phone numbers
	ClearExtraAttributes();				// Remove any extra attributes
	ClearExtraFlags();					// Remove any extra flags
	ClearAllMedia();					// clean out the media descriptors

	m_cConfAttrib = 1;					// Current Conf Attribute index starts at 1

	// Variables associated with the REQUIRED m=/c= field

	m_ulSize = 0;
//	memset(&m_guidSessionUUID,0,sizeof(m_guidSessionUUID));

//	m_cATVEFMediaDescs = 0;

	// default values
	m_spbsAnncAddIP		= ATVEF_ANNOUNCEMENT_IP;		// ATVEF defaults ("224.0.1.113")
	m_lAnncPort			= ATVEF_ANNOUNCEMENT_PORT;		//				  (2670)
	m_uiAnncTTL			= ATVEF_ANNOUNCEMENT_TTL;		// scope ?
	m_ulAnncMaxBandwidth = ATVEF_ANNOUNCEMENT_BANDWIDTH;							// unused so far ???

	m_spbsUserName = L"-";
	
	m_langIDSessionLang = 0;
	m_langIDSDPLang = 0;

	return S_OK;
}

HRESULT	CSDPSource::ClearTimes()				// clears the times values (t=)
{
	if(m_splStartStop) m_splStartStop->RemoveAll();
	return S_OK;
}

HRESULT	CSDPSource::ClearEmailAddresses()				// clears the e-mail values (e=)
{
	if(m_spalEmailAddresses) m_spalEmailAddresses->RemoveAll();
	return S_OK;
}

HRESULT	CSDPSource::ClearPhoneNumbers()				// clears the phone values (p=)
{
	if(m_spalPhoneNumbers)   m_spalPhoneNumbers->RemoveAll();
	return S_OK;
}

HRESULT	CSDPSource::ClearExtraAttributes()			// clears extra attributes (a=<not elsewhere defined>)
{
	if(m_spalExtraAttributes)     m_spalExtraAttributes->RemoveAll();
	return S_OK;
}

HRESULT	CSDPSource::ClearExtraFlags()			// clears extra attributes (a=<not elsewhere defined>)
{
	if(m_spalExtraFlags)     m_spalExtraFlags->RemoveAll();
	return S_OK;
}


HRESULT	CSDPSource::ClearAllMedia()					// clears media definitions
{
	HRESULT hr;
	if(m_spMedias) {
		long cMedias;
		hr = m_spMedias->get_Count(&cMedias);
		if(FAILED(hr)) 
			return hr;
		for(long c = cMedias-1; c >= 0; --c) {
			CComVariant cv(c);
			m_spMedias->Remove(cv);
		}
	}
	return S_OK;
}
//  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//
//	PRIVATE METHODS SECTION
//
//  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

// AnncValid(int *piErrLoc)
// return:
//	TRUE:	ATVEF required info has been supplied
//	FALSE:  Not complete
//	  returns location of first error.
BOOL CSDPSource::AnncValid(int *piErrLoc)
{
			// spbs are CComBSTR's- !operator overloaded to identify NULL strings
	if(piErrLoc == NULL) return false;		// must provide!
	*piErrLoc = 0;
	if(!m_spbsSendingIP)						return false;  (*piErrLoc)++;	//0
	if(!m_spbsSessionName)						return false;  (*piErrLoc)++;	//1

	long iNumEmail, iNumPhone;
	m_spalEmailAddresses->get_Count(&iNumEmail);
	m_spalPhoneNumbers->get_Count(&iNumPhone);
	if(0 == iNumEmail && 0 == iNumPhone)		return false;  (*piErrLoc)++;	//2

	long iNumTimes;
	m_splStartStop->get_Count(&iNumTimes);
	if(0 == iNumTimes)							return false;	(*piErrLoc)++;	//3
	if(!m_ulSize)								return false;	(*piErrLoc)++;	//4
	if(m_uiSecondsToEnd < 0)					return false;	(*piErrLoc)++;	//5

	long cMedias;
	m_spMedias->get_Count(&cMedias);
	if(cMedias < 1)								return false;   (*piErrLoc)++;	//6
	for(int j = 0; j < cMedias; j++)
	{
		*piErrLoc = (j+1)*10;	
		IATVEFMediaPtr spMedia;
		CComVariant cv(j);		
		HRESULT hr = m_spMedias->get_Item(cv,&spMedia);
		if(FAILED(hr))
			return false; (*piErrLoc)++;	// M0
		LONG ip; SHORT port; INT ttl; LONG maxBitRate;
		spMedia->GetDataTransmission(&ip,&port,&ttl,&maxBitRate);
		if(!ttl)						return false;	(*piErrLoc)++;	//M1				
		if(!port)						return false;	(*piErrLoc)++;	//M2
		if(!maxBitRate)					return false;	(*piErrLoc)++;	//M3
		if(!ip)							return false;	(*piErrLoc)++;	//M4
		spMedia->GetTriggerTransmission(&ip,&port,&ttl,&maxBitRate);
		if(!ttl)						return false;	(*piErrLoc)++;	//M5				
		if(!port)						return false;	(*piErrLoc)++;	//M6
		if(!maxBitRate)					return false;	(*piErrLoc)++;	//M7
		if(!ip)							return false;	(*piErrLoc)++;	//M8
	}
	return true;
}

// Converts DATE to NTP
ULONG CSDPSource::DATEtoNTP(DATE x)
{
	//  commented code: NTPtoDate
	//	double d = x / (24*60*60) +2;
	//	return d;
	if(x<2.0) x=2.0;									// Underflow prevention (See bug 239407)				
	ULONG	ul = (ULONG)((x-2) * (24*60*60));			// PBUG
	return ul;
}


// -------------------------------------------------------
// AppendSAPHeader
//
//		Adds the sap header to a string
// 
//		Currently 8 bytes of stuff.  Returns number modified string,
//		and number of bytes added to it.
//
//		Use like this:  cspS->AppendSapHeader(&iLen,buff);  buff+=iLen;
//   
//		Assumes buff is long enough for this data

HRESULT CSDPSource::AppendSAPHeader(int *piLen, char *pchar)
{
	// This is an eight byte piece of data in front of the text SDP data
	// 

	USES_CONVERSION;
	int fDelete = (m_fDeleteAnnc) ? 1 : 0;

	SAPHeaderBits SAPHead;
	SAPHead.s.Version		= SAPVERSION;	// must be 1.
	SAPHead.s.AddressType	= 0;			// IPv4 (not IPv6)
	SAPHead.s.Reserved		= 0;			// must be zero for senders
	SAPHead.s.MessageType	= fDelete;		// session announcement packet (not delete packet)
	SAPHead.s.Encrypted		= 0;			// not  encrypted
	SAPHead.s.Compressed	= 0;			// not ZLIB compressed

	char			*pcharStart = pchar;
	USHORT			*pshort;			

	*pchar++ = SAPHead.uc;					// First byte: SAP version, Delete/Not, Encrypted, Compressed
	*pchar++ = 0;							// zero length SAP Authentication Header

	pshort = (USHORT*) pchar;				// Copy in hash
	*pshort = m_usMsgIDHash;
	pchar += sizeof(USHORT);

	in_addr inAddr;
	if(0 != m_spbsSAPSendingIP.Length() )
		inAddr.S_un.S_addr = inet_addr(W2A(m_spbsSAPSendingIP));		// default to SendingIP if not specified
	else
		inAddr.S_un.S_addr = inet_addr(W2A(m_spbsSendingIP));

	*pchar++ = (char) inAddr.S_un.S_un_b.s_b1;							// Originating IP--4 bytes
	*pchar++ = (char) inAddr.S_un.S_un_b.s_b2;	 
	*pchar++ = (char) inAddr.S_un.S_un_b.s_b3;	
	*pchar++ = (char) inAddr.S_un.S_un_b.s_b4;	 

	*piLen = pchar - pcharStart;		
	return S_OK;
}

// **************************************************
//  Media Stuff
// **************************************************
	// Returns the number of media currently configured.
HRESULT CSDPSource::get_MediaCount(/*[out]*/ long *pcMedia)
{
	return m_spMedias->get_Count(pcMedia);
}
	// Returns the iLoc'th media attribute, where the count starts at zero. (QI for IATVEFMedia).  Will return an error if iLoc < 0 or >= count.
HRESULT CSDPSource::get_Media(/*[in]*/ long iLoc, /*[out]*/ IATVEFMedia **ppIDsp)
{
	HRESULT hr;
	long cMedia;

	if(!ppIDsp)
		return E_INVALIDARG;

	hr = m_spMedias->get_Count(&cMedia);
	if(FAILED(hr)) 
		return hr;

	if(iLoc < 0 || iLoc >= cMedia)
		return E_INVALIDARG;

	CComVariant cv(iLoc);

	hr = m_spMedias->get_Item(cv, ppIDsp);

	return hr;
}
	// Creates a new media object, appending it to the end of the list managed by GetMedia and returning it.  You must set parameters on this media type (at least it's trigger and data IP address) for it to be valid.
HRESULT CSDPSource::get_NewMedia(/*[out]*/ IATVEFMedia **ppIMedia)
{
	HRESULT hr = S_OK;
			// create a new default media type
	IATVEFMediaPtr spMedia = IATVEFMediaPtr(CLSID_ATVEFMedia);
	if(NULL == spMedia) {
		return E_OUTOFMEMORY;
	}
	
			// add it into our collection
	hr = m_spMedias->Add(spMedia);
	if(FAILED(hr))
		return hr;

			// return it...
	if(NULL != ppIMedia)
	{
		spMedia->AddRef();			
		*ppIMedia = spMedia;	
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\deflate.c ===
/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-1996 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin & Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */

/* $Id: deflate.c,v 1.15 1996/07/24 13:40:58 me Exp $ */

#include "deflate.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//char deflate_copyright[] = " deflate 1.0.4 Copyright 1995-1996 Jean-loup Gailly ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/* ===========================================================================
 *  Function prototypes.
 */
typedef enum {
    need_more,      /* block not completed, need more input or more output */
    block_done,     /* block flush performed */
    finish_started, /* finish started, need only more output at next deflate */
    finish_done     /* finish done, accept no more input or output */
} block_state;

typedef block_state (*compress_func) OF((deflate_state *s, int flush));
/* Compression function. Returns the block state after the call. */

local void fill_window    OF((deflate_state *s));
local block_state deflate_stored OF((deflate_state *s, int flush));
local block_state deflate_fast   OF((deflate_state *s, int flush));
local block_state deflate_slow   OF((deflate_state *s, int flush));
local void lm_init        OF((deflate_state *s));
local uInt longest_match  OF((deflate_state *s, IPos cur_match));
local void putShortMSB    OF((deflate_state *s, uInt b));
local void flush_pending  OF((z_streamp strm));
local int read_buf        OF((z_streamp strm, charf *buf, unsigned size));
#ifdef ASMV
      void match_init OF((void)); /* asm code initialization */
#endif

#ifdef DEBUG
local  void check_match OF((deflate_state *s, IPos start, IPos match,
                            int length));
#endif

/* ===========================================================================
 * Local data
 */

#define NIL 0
/* Tail of hash chains */

#ifndef TOO_FAR
#  define TOO_FAR 4096
#endif
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */

#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
typedef struct config_s {
   ush good_length; /* reduce lazy search above this match length */
   ush max_lazy;    /* do not perform lazy search above this match length */
   ush nice_length; /* quit search above this match length */
   ush max_chain;
   compress_func func;
} config;

local config configuration_table[10] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},

/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */

/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
 * meaning.
 */

#define EQUAL 0
/* result of memcmp for equal strings */

struct static_tree_desc_s {int dummy;}; /* for buggy compilers */

/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */
#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)


/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of str are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))

/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */
#define CLEAR_HASH(s) \
    s->head[s->hash_size-1] = NIL; \
    zmemzero((charf *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));

/* ========================================================================= */
int deflateInit_(strm, level, version, stream_size)
    z_streamp strm;
    int level;
    const char *version;
    int stream_size;
{
    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
			 Z_DEFAULT_STRATEGY, version, stream_size);
    /* To do: ignore strm->next_in if we use it as window */
}

/* ========================================================================= */
int deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
		  version, stream_size)
    z_streamp strm;
    int  level;
    int  method;
    int  windowBits;
    int  memLevel;
    int  strategy;
    const char *version;
    int stream_size;
{
    deflate_state *s;
    int noheader = 0;

    ushf *overlay;
    /* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is <= 24 bits.
     */

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != sizeof(z_stream)) {
	return Z_VERSION_ERROR;
    }
    if (strm == Z_NULL) return Z_STREAM_ERROR;

    strm->msg = Z_NULL;
    if (strm->zalloc == Z_NULL) {
	strm->zalloc = zcalloc;
	strm->opaque = (voidpf)0;
    }
    if (strm->zfree == Z_NULL) strm->zfree = zcfree;

    if (level == Z_DEFAULT_COMPRESSION) level = 6;

    if (windowBits < 0) { /* undocumented feature: suppress zlib header */
        noheader = 1;
        windowBits = -windowBits;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
	strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
        return Z_STREAM_ERROR;
    }
    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
    if (s == Z_NULL) return Z_MEM_ERROR;
    strm->state = (struct internal_state FAR *)s;
    s->strm = strm;

    s->noheader = noheader;
    s->w_bits = windowBits;
    s->w_size = 1 << s->w_bits;
    s->w_mask = s->w_size - 1;

    s->hash_bits = memLevel + 7;
    s->hash_size = 1 << s->hash_bits;
    s->hash_mask = s->hash_size - 1;
    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
    s->pending_buf = (uchf *) overlay;

    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
        s->pending_buf == Z_NULL) {
        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
        deflateEnd (strm);
        return Z_MEM_ERROR;
    }
    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

    s->level = level;
    s->strategy = strategy;
    s->method = (Byte)method;

    return deflateReset(strm);
}

/* ========================================================================= */
int deflateSetDictionary (strm, dictionary, dictLength)
    z_streamp strm;
    const Bytef *dictionary;
    uInt  dictLength;
{
    deflate_state *s;
    uInt length = dictLength;
    uInt n;
    IPos hash_head = 0;

    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;

    s = strm->state;
    strm->adler = adler32(strm->adler, dictionary, dictLength);

    if (length < MIN_MATCH) return Z_OK;
    if (length > MAX_DIST(s)) {
	length = MAX_DIST(s);
	dictionary += dictLength - length;
    }
    zmemcpy((charf *)s->window, dictionary, length);
    s->strstart = length;
    s->block_start = (long)length;

    /* Insert all strings in the hash table (except for the last two bytes).
     * s->lookahead stays null, so s->ins_h will be recomputed at the next
     * call of fill_window.
     */
    s->ins_h = s->window[0];
    UPDATE_HASH(s, s->ins_h, s->window[1]);
    for (n = 0; n <= length - MIN_MATCH; n++) {
	INSERT_STRING(s, n, hash_head);
    }
    if (hash_head) hash_head = 0;  /* to make compiler happy */
    return Z_OK;
}

/* ========================================================================= */
int deflateReset (strm)
    z_streamp strm;
{
    deflate_state *s;
    
    if (strm == Z_NULL || strm->state == Z_NULL ||
        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;

    strm->total_in = strm->total_out = 0;
    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
    strm->data_type = Z_UNKNOWN;

    s = (deflate_state *)strm->state;
    s->pending = 0;
    s->pending_out = s->pending_buf;

    if (s->noheader < 0) {
        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */
    }
    s->status = s->noheader ? BUSY_STATE : INIT_STATE;
    strm->adler = 1;
    s->last_flush = Z_NO_FLUSH;

    _tr_init(s);
    lm_init(s);

    return Z_OK;
}

/* ========================================================================= */
int deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;

    if (level == Z_DEFAULT_COMPRESSION) {
	level = 6;
    }
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
	return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;

    if (func != configuration_table[level].func && strm->total_in != 0) {
	/* Flush the last buffer: */
	err = deflate(strm, Z_PARTIAL_FLUSH);
    }
    if (s->level != level) {
	s->level = level;
	s->max_lazy_match   = configuration_table[level].max_lazy;
	s->good_match       = configuration_table[level].good_length;
	s->nice_match       = configuration_table[level].nice_length;
	s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
local void putShortMSB (s, b)
    deflate_state *s;
    uInt b;
{
    put_byte(s, (Byte)(b >> 8));
    put_byte(s, (Byte)(b & 0xff));
}   

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->next_out buffer and copying into it.
 * (See also read_buf()).
 */
local void flush_pending(strm)
    z_streamp strm;
{
    unsigned len = strm->state->pending;

    if (len > strm->avail_out) len = strm->avail_out;
    if (len == 0) return;

    zmemcpy(strm->next_out, strm->state->pending_out, len);
    strm->next_out  += len;
    strm->state->pending_out  += len;
    strm->total_out += len;
    strm->avail_out  -= len;
    strm->state->pending -= len;
    if (strm->state->pending == 0) {
        strm->state->pending_out = strm->state->pending_buf;
    }
}

/* ========================================================================= */
int deflate (strm, flush)
    z_streamp strm;
    int flush;
{
    int old_flush; /* value of flush param for previous deflate call */
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL ||
	flush > Z_FINISH || flush < 0) {
        return Z_STREAM_ERROR;
    }
    s = strm->state;

    if (strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
	(s->status == FINISH_STATE && flush != Z_FINISH)) {
        ERR_RETURN(strm, Z_STREAM_ERROR);
    }
    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

    s->strm = strm; /* just in case */
    old_flush = s->last_flush;
    s->last_flush = flush;

    /* Write the zlib header */
    if (s->status == INIT_STATE) {

        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
        uInt level_flags = (s->level-1) >> 1;

        if (level_flags > 3) level_flags = 3;
        header |= (level_flags << 6);
	if (s->strstart != 0) header |= PRESET_DICT;
        header += 31 - (header % 31);

        s->status = BUSY_STATE;
        putShortMSB(s, header);

	/* Save the adler32 of the preset dictionary: */
	if (s->strstart != 0) {
	    putShortMSB(s, (uInt)(strm->adler >> 16));
	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
	}
	strm->adler = 1L;
    }

    /* Flush as much pending output as possible */
    if (s->pending != 0) {
        flush_pending(strm);
        if (strm->avail_out == 0) {
	    /* Since avail_out is 0, deflate will be called again with
	     * more output space, but possibly with both pending and
	     * avail_in equal to zero. There won't be anything to do,
	     * but this is not an error situation so make sure we
	     * return OK instead of BUF_ERROR at next call of deflate:
             */
	    s->last_flush = -1;
	    return Z_OK;
	}

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUFF_ERROR.
     */
    } else if (strm->avail_in == 0 && flush <= old_flush &&
	       flush != Z_FINISH) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* User must not provide more input after the first FINISH: */
    if (s->status == FINISH_STATE && strm->avail_in != 0) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* Start a new block or continue the current one.
     */
    if (strm->avail_in != 0 || s->lookahead != 0 ||
        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
        block_state bstate;

	bstate = (*(configuration_table[s->level].func))(s, flush);

        if (bstate == finish_started || bstate == finish_done) {
            s->status = FINISH_STATE;
        }
        if (bstate == need_more || bstate == finish_started) {
	    if (strm->avail_out == 0) {
	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
	    }
	    return Z_OK;
	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	     * of deflate should use the same flush parameter to make sure
	     * that the flush is complete. So we don't have to output an
	     * empty block here, this will be done at next call. This also
	     * ensures that for a very small output buffer, we emit at most
	     * one empty block.
	     */
	}
        if (bstate == block_done) {
            if (flush == Z_PARTIAL_FLUSH) {
                _tr_align(s);
            } else { /* FULL_FLUSH or SYNC_FLUSH */
                _tr_stored_block(s, (char*)0, 0L, 0);
                /* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */
                if (flush == Z_FULL_FLUSH) {
                    CLEAR_HASH(s);             /* forget history */
                }
            }
            flush_pending(strm);
	    if (strm->avail_out == 0) {
	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	      return Z_OK;
	    }
        }
    }
    Assert(strm->avail_out > 0, "bug2");

    if (flush != Z_FINISH) return Z_OK;
    if (s->noheader) return Z_STREAM_END;

    /* Write the zlib trailer (adler32) */
    putShortMSB(s, (uInt)(strm->adler >> 16));
    putShortMSB(s, (uInt)(strm->adler & 0xffff));
    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */
    s->noheader = -1; /* write the trailer only once! */
    return s->pending != 0 ? Z_OK : Z_STREAM_END;
}

/* ========================================================================= */
int deflateEnd (strm)
    z_streamp strm;
{
    int status;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

    /* Deallocate in reverse order of allocations: */
    TRY_FREE(strm, strm->state->pending_buf);
    TRY_FREE(strm, strm->state->head);
    TRY_FREE(strm, strm->state->prev);
    TRY_FREE(strm, strm->state->window);

    status = strm->state->status;
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;

    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
}

/* ========================================================================= */
int deflateCopy (dest, source)
    z_streamp dest;
    z_streamp source;
{
    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
        return Z_STREAM_ERROR;
    }
    *dest = *source;
    return Z_STREAM_ERROR; /* to be implemented */
#if 0
    dest->state = (struct internal_state FAR *)
        (*dest->zalloc)(1, sizeof(deflate_state));
    if (dest->state == Z_NULL) return Z_MEM_ERROR;

    *(dest->state) = *(source->state);
    return Z_OK;
#endif
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->next_in buffer and copying from it.
 * (See also flush_pending()).
 */
local int read_buf(strm, buf, size)
    z_streamp strm;
    charf *buf;
    unsigned size;
{
    unsigned len = strm->avail_in;

    if (len > size) len = size;
    if (len == 0) return 0;

    strm->avail_in  -= len;

    if (!strm->state->noheader) {
        strm->adler = adler32(strm->adler, strm->next_in, len);
    }
    zmemcpy(buf, strm->next_in, len);
    strm->next_in  += len;
    strm->total_in += len;

    return (int)len;
}

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
local void lm_init (s)
    deflate_state *s;
{
    s->window_size = (ulg)2L*s->w_size;

    CLEAR_HASH(s);

    /* Set the default configuration parameters:
     */
    s->max_lazy_match   = configuration_table[s->level].max_lazy;
    s->good_match       = configuration_table[s->level].good_length;
    s->nice_match       = configuration_table[s->level].nice_length;
    s->max_chain_length = configuration_table[s->level].max_chain;

    s->strstart = 0;
    s->block_start = 0L;
    s->lookahead = 0;
    s->match_length = s->prev_length = MIN_MATCH-1;
    s->match_available = 0;
    s->ins_h = 0;
#ifdef ASMV
    match_init(); /* initialize the asm code */
#endif
}

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
#ifndef ASMV
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
 * match.S. The code will be functionally equivalent.
 */
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    unsigned chain_length = s->max_chain_length;/* max hash chain length */
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    int best_len = s->prev_length;              /* best match length so far */
    int nice_match = s->nice_match;             /* stop if match long enough */
    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
        s->strstart - (IPos)MAX_DIST(s) : NIL;
    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    Posf *prev = s->prev;
    uInt wmask = s->w_mask;

#ifdef UNALIGNED_OK
    /* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
    register ush scan_start = *(ushf*)scan;
    register ush scan_end   = *(ushf*)(scan+best_len-1);
#else
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
    register Byte scan_end1  = scan[best_len-1];
    register Byte scan_end   = scan[best_len];
#endif

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */
    if (s->prev_length >= s->good_match) {
        chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    do {
        Assert(cur_match < s->strstart, "no future");
        match = s->window + cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2:
         */
#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        /* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */
        if (*(ushf*)(match+best_len-1) != scan_end ||
            *(ushf*)match != scan_start) continue;

        /* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */
        Assert(scan[2] == match[2], "scan[2]?");
        scan++, match++;
        do {
        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 scan < strend);
        /* The funny "do {}" generates better code on most compilers */

        /* Here, scan <= window+strstart+257 */
        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
        if (*scan == *match) scan++;

        len = (MAX_MATCH - 1) - (int)(strend-scan);
        scan = strend - (MAX_MATCH-1);

#else /* UNALIGNED_OK */

        if (match[best_len]   != scan_end  ||
            match[best_len-1] != scan_end1 ||
            *match            != *scan     ||
            *++match          != scan[1])      continue;

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2, match++;
        Assert(*scan == *match, "match[2]?");

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
        } while (*++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 scan < strend);

        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (int)(strend - scan);
        scan = strend - MAX_MATCH;

#endif /* UNALIGNED_OK */

        if (len > best_len) {
            s->match_start = cur_match;
            best_len = len;
            if (len >= nice_match) break;
#ifdef UNALIGNED_OK
            scan_end = *(ushf*)(scan+best_len-1);
#else
            scan_end1  = scan[best_len-1];
            scan_end   = scan[best_len];
#endif
        }
    } while ((cur_match = prev[cur_match & wmask]) > limit
             && --chain_length != 0);

    if ((uInt)best_len <= s->lookahead) return best_len;
    return s->lookahead;
}
#endif /* ASMV */

#ifdef DEBUG
/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */
local void check_match(s, start, match, length)
    deflate_state *s;
    IPos start, match;
    int length;
{
    /* check that the match is indeed a match */
    if (zmemcmp((charf *)s->window + match,
                (charf *)s->window + start, length) != EQUAL) {
        fprintf(stderr, " start %u, match %u, length %d\n",
		start, match, length);
        do {
	    fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
	} while (--length != 0);
        z_error("invalid match");
    }
    if (verbose > 1) {
        fprintf(stderr,"\\[%d,%d]", start-match, length);
        do { putc(s->window[start++], stderr); } while (--length != 0);
    }
}
#else
#  define check_match(s, start, match, length)
#endif

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
local void fill_window(s)
    deflate_state *s;
{
    register unsigned n, m;
    register Posf *p;
    unsigned more;    /* Amount of free space at the end of the window. */
    uInt wsize = s->w_size;

    do {
        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

        /* Deal with !@#$% 64K limit: */
        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
            more = wsize;

        } else if (more == (unsigned)(-1)) {
            /* Very unlikely, but possible on 16 bit machine if strstart == 0
             * and lookahead == 1 (input done one byte at time)
             */
            more--;

        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        } else if (s->strstart >= wsize+MAX_DIST(s)) {

            zmemcpy((charf *)s->window, (charf *)s->window+wsize,
                   (unsigned)wsize);
            s->match_start -= wsize;
            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */

            s->block_start -= (long) wsize;

            /* Slide the hash table (could be avoided with 32 bit values
               at the expense of memory usage):
             */
            n = s->hash_size;
            p = &s->head[n];
            do {
                m = *--p;
                *p = (Pos)(m >= wsize ? m-wsize : NIL);
            } while (--n);

            n = wsize;
            p = &s->prev[n];
            do {
                m = *--p;
                *p = (Pos)(m >= wsize ? m-wsize : NIL);
                /* If n is not on any hash chain, prev[n] is garbage but
                 * its value will never be used.
                 */
            } while (--n);

            more += wsize;
        }
        if (s->strm->avail_in == 0) return;

        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        Assert(more >= 2, "more < 2");

        n = read_buf(s->strm, (charf *)s->window + s->strstart + s->lookahead,
                     more);
        s->lookahead += n;

        /* Initialize the hash value now that we have some input: */
        if (s->lookahead >= MIN_MATCH) {
            s->ins_h = s->window[s->strstart];
            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
            Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
        }
        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */

    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
}

/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */
#define FLUSH_BLOCK_ONLY(s, eof) { \
   _tr_flush_block(s, (s->block_start >= 0L ? \
                   (charf *)&s->window[(unsigned)s->block_start] : \
                   (charf *)Z_NULL), \
		(ulg)((long)s->strstart - s->block_start), \
		(eof)); \
   s->block_start = s->strstart; \
   flush_pending(s->strm); \
   Tracev((stderr,"[FLUSH]")); \
}

/* Same but force premature exit if necessary. */
#define FLUSH_BLOCK(s, eof) { \
   FLUSH_BLOCK_ONLY(s, eof); \
   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying.
 */
local block_state deflate_stored(s, flush)
    deflate_state *s;
    int flush;
{
    for (;;) {
        /* Fill the window as much as possible: */
        if (s->lookahead <= 1) {

            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
		   s->block_start >= (long)s->w_size, "slide too late");

            fill_window(s);
            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

            if (s->lookahead == 0) break; /* flush the current block */
        }
	Assert(s->block_start >= 0L, "block gone");

	s->strstart += s->lookahead;
	s->lookahead = 0;

        /* Stored blocks are limited to 0xffff bytes: */
        if (s->strstart == 0 || s->strstart > 0xfffe) {
	    /* strstart == 0 is possible when wraparound on 16-bit machine */
	    s->lookahead = s->strstart - 0xffff;
	    s->strstart = 0xffff;
	}

	/* Emit a stored block if it is large enough: */
        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
            FLUSH_BLOCK(s, 0);
	}
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
local block_state deflate_fast(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head = NIL; /* head of the hash chain */
    int bflush;           /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	        return need_more;
	    }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */
        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            if (s->strategy != Z_HUFFMAN_ONLY) {
                s->match_length = longest_match (s, hash_head);
            }
            /* longest_match() sets match_start */
        }
        if (s->match_length >= MIN_MATCH) {
            check_match(s, s->strstart, s->match_start, s->match_length);

            bflush = _tr_tally(s, s->strstart - s->match_start,
                               s->match_length - MIN_MATCH);

            s->lookahead -= s->match_length;

            /* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */
            if (s->match_length <= s->max_insert_length &&
                s->lookahead >= MIN_MATCH) {
                s->match_length--; /* string at strstart already in hash table */
                do {
                    s->strstart++;
                    INSERT_STRING(s, s->strstart, hash_head);
                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */
                } while (--s->match_length != 0);
                s->strstart++; 
            } else {
                s->strstart += s->match_length;
                s->match_length = 0;
                s->ins_h = s->window[s->strstart];
                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
                Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */
            }
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            bflush = _tr_tally (s, 0, s->window[s->strstart]);
            s->lookahead--;
            s->strstart++; 
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
local block_state deflate_slow(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head = NIL;    /* head of hash chain */
    int bflush;              /* set if current block must be flushed */

    /* Process the input block. */
    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	        return need_more;
	    }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         */
        s->prev_length = s->match_length, s->prev_match = s->match_start;
        s->match_length = MIN_MATCH-1;

        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
            s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            if (s->strategy != Z_HUFFMAN_ONLY) {
                s->match_length = longest_match (s, hash_head);
            }
            /* longest_match() sets match_start */

            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
                 (s->match_length == MIN_MATCH &&
                  s->strstart - s->match_start > TOO_FAR))) {

                /* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */
                s->match_length = MIN_MATCH-1;
            }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */

            check_match(s, s->strstart-1, s->prev_match, s->prev_length);

            bflush = _tr_tally(s, s->strstart -1 - s->prev_match,
                               s->prev_length - MIN_MATCH);

            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */
            s->lookahead -= s->prev_length-1;
            s->prev_length -= 2;
            do {
                if (++s->strstart <= max_insert) {
                    INSERT_STRING(s, s->strstart, hash_head);
                }
            } while (--s->prev_length != 0);
            s->match_available = 0;
            s->match_length = MIN_MATCH-1;
            s->strstart++;

            if (bflush) FLUSH_BLOCK(s, 0);

        } else if (s->match_available) {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            Tracevv((stderr,"%c", s->window[s->strstart-1]));
            if (_tr_tally (s, 0, s->window[s->strstart-1])) {
                FLUSH_BLOCK_ONLY(s, 0);
            }
            s->strstart++;
            s->lookahead--;
            if (s->strm->avail_out == 0) return need_more;
        } else {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            s->match_available = 1;
            s->strstart++;
            s->lookahead--;
        }
    }
    Assert (flush != Z_NO_FLUSH, "no flush?");
    if (s->match_available) {
        Tracevv((stderr,"%c", s->window[s->strstart-1]));
        _tr_tally (s, 0, s->window[s->strstart-1]);
        s->match_available = 0;
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\atvefsend.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// ATVEFSend.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ATVEFSendps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ATVEFSend.h"

#include "ATVEFSend_i.c"

#include "TVEPack.h"
#include "TVEAnnc.h"
#include "TVEAttrM.h"
#include "TVEAttrL.h"
#include "TVESSList.h"
#include "TVEMedia.h"
#include "TVEMedias.h"


#include "TVEMCast.h"
#include "TVEInsert.h"
#include "TVERouter.h"
#include "TVELine21.h"

#include "TveDbg.h"						// new tracing systems...
DBG_INIT(_T("AtvefSend"));

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ATVEFPackage,			CATVEFPackage)
OBJECT_ENTRY(CLSID_ATVEFAnnouncement,		CATVEFAnnouncement)
OBJECT_ENTRY(CLSID_ATVEFMedia,				CATVEFMedia)

OBJECT_ENTRY(CLSID_ATVEFAttrMap,			CATVEFAttrMap)
OBJECT_ENTRY(CLSID_ATVEFAttrList,			CATVEFAttrList)
OBJECT_ENTRY(CLSID_ATVEFStartStopList,		CATVEFStartStopList)

OBJECT_ENTRY(CLSID_ATVEFAnnouncement,		CATVEFAnnouncement)
OBJECT_ENTRY(CLSID_ATVEFInserterSession,	CATVEFInserterSession)
OBJECT_ENTRY(CLSID_ATVEFRouterSession,		CATVEFRouterSession)
OBJECT_ENTRY(CLSID_ATVEFLine21Session,		CATVEFLine21Session)
OBJECT_ENTRY(CLSID_ATVEFMulticastSession,	CATVEFMulticastSession)
//OBJECT_ENTRY(CLSID_ATVEFMedias, CATVEFMedias)

END_OBJECT_MAP()

// ----------------------------------------------------------
//  Rich Error Handling Object
// ----------------------------------------------------------
WCHAR * 
GetTVEError(HRESULT hr, ...)		// returns static string containing error message
{
	va_list arglist;
	va_start(arglist, hr);

	static WCHAR wbuff[1024];   
	HMODULE hMod = GetModuleHandle(_T("AtvefSend.dll"));		
	if(NULL == hMod)										// try again...
		hMod = GetModuleHandle(NULL);

//	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD)hr, 
//				 0L, szFormat, MAX_PATH, NULL);

	if(0 == FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM 
					     | FORMAT_MESSAGE_FROM_HMODULE,
					 hMod, //NULL, //g_hTVESendModule,
					 hr,
					 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //LANG_NEUTRAL,
					 wbuff,
					 sizeof(wbuff) / sizeof(wbuff[0]) -1,
					 &arglist))
	{
		int err = GetLastError();
		swprintf(wbuff,L"Unknown ATVEFSend Error 0x%08x (%d)",hr,hr);
	}

	return wbuff;
};
/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ATVEFSENDLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\csdpsrc.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        csdpsrc.h

    Abstract:

        This module 

    Author:

        James Meyer (a-jmeyer)

    Revision History:
		J.Bradstreet (johnbrad) lots of changes for ATVEFSend

--*/

#ifndef __CSDPSRC_H_
#define __CSDPSRC_H_

#include <comdef.h>
#include <time.h>
#include <crtdbg.h>
#include <tchar.h>

#include "ATVEFSend.h"		// TVEAttrMap3 and other interfaces
//#include "TveAttrM.h"
#include "TveAttrL.h"
#include "TveSSList.h"

#include "TVEMedias.h"
#include <WinSock2.h>

_COM_SMARTPTR_TYPEDEF(IATVEFAttrMap, __uuidof(IATVEFAttrMap));
_COM_SMARTPTR_TYPEDEF(IATVEFAttrList, __uuidof(IATVEFAttrList));
_COM_SMARTPTR_TYPEDEF(IATVEFStartStopList, __uuidof(IATVEFStartStopList));
_COM_SMARTPTR_TYPEDEF(IATVEFMedia, __uuidof(IATVEFMedia));
_COM_SMARTPTR_TYPEDEF(IATVEFMedias, __uuidof(IATVEFMedias));


/////////////////////////////////////////////////////////////////////////////
//  SAP header (http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sap-v2-02.txt)

struct SAPHeaderBits				// first 8 bits in the SAP header (comments indicate ATVEF state)
{
	union {
		struct {
			unsigned Compressed:1;		// if 1, SAP packet is compressed (0 only) 
			unsigned Encrypted:1;		// if 1, SAP packet is encrypted (0 only) 
			unsigned MessageType:1;		// if 0, session announcement packet, if 1, session deletion packet (0 only)
			unsigned Reserved:1;		// must be 0, readers ignore this	(ignored)
			unsigned AddressType:1;		// if 0, 32bit IPv4 address, if 1, 128-bit IPv6 (0 only)
			unsigned Version:3;			// must be 1  (1 only)
		} s; 
		unsigned char uc;
	};
};


#ifndef ASSERT
  #define ASSERT	_ASSERT
#endif  // ASSERT

const	int		SAPVERSION = 1;			// Version of the SAP spec.
const	int		SAPHEADERSIZE = 8;		// Size of SAP header
const	int		MAX_TIMES = 50;			// Maximum of 50 start/stop times per annc.

struct IPAdd
{
	short	sIP1;
	short	sIP2;
	short	sIP3;
	short	sIP4;
};


class CSDPOutPin;

EXTERN_C const CLSID CLSID_SDPSource;

typedef enum AnncString {
    USER_NAME = 0,
    SESSION_NAME,
    SESSION_DESC,
	NUM_ANNC_STRINGS
} AnncString;

#define ATVEF_ANNOUNCEMENT_IP           L"224.0.1.113"			// spec'ed ATVEF 1.0 values
#define ATVEF_ANNOUNCEMENT_PORT         2670 
#define ATVEF_ANNOUNCEMENT_TTL			3						// random - but ok default
#define ATVEF_ANNOUNCEMENT_BANDWIDTH	28000					// random - but default

class CSDPSource
// : public CBaseFilter, public ITVEAnnouncement
{

public:

	CSDPSource();
	HRESULT FinalConstruct();
	HRESULT FinalRelease();
	~CSDPSource();
// ==================================
// REQUIRED BY ATVEF (OR WEBTV) SPEC
// ==================================
	// o= tag (originator)
//	HRESULT SetUserNameBSTR(BSTR bstrUserName);		// REQUIRED field, but defaults to "-"
	HRESULT put_SessionID(UINT uiSessionID);
	HRESULT get_SessionID(UINT *puiSessionID);
	HRESULT	put_SessionVersion(UINT iVersion);
	HRESULT	get_SessionVersion(UINT *piVersion);
	HRESULT	put_SendingIPULONG(ULONG ulIP);
	HRESULT	get_SendingIPULONG(ULONG *pulIP);

	// s= tag
	HRESULT put_SessionName(BSTR bstrName);
 	HRESULT get_SessionName(BSTR *pbstrName);
     //  i= tag
	HRESULT put_SessionLabel (BSTR bstrLabel = NULL);
	HRESULT get_SessionLabel (BSTR *pbstrLabel);
	// e= or p=
		// NOTE: at least one e-mail or phone required. Can have multiple of either/both
	HRESULT AddEMail(BSTR bstrEMailAddress, BSTR bstrEMailName = NULL);
	HRESULT AddPhone(BSTR bstrPhoneNumber, BSTR bstrName = NULL);
	HRESULT AddExtraAttribute(BSTR bstrKey, BSTR bstrValue = NULL);		// add 'a=key:value' to extra attributes
	HRESULT AddExtraFlag(BSTR bstrKey, BSTR bstrValue);					// add 'key=value' to extra flags

	HRESULT get_EmailAddresses(IUnknown **ppVal);		// ? should be ITVEAttrMap3 here?
	HRESULT get_PhoneNumbers(IUnknown **ppVal);
	HRESULT get_ExtraAttributes(IUnknown **ppVal);		// other 'a=key:value'
	HRESULT get_ExtraFlags(IUnknown **ppVal);			// other 'key=value',  key != 'a' parameters
	// t=
		// NOTE: WebTV usually expects dStopTime=0.  
	HRESULT AddStartStopTime(DATE dStartTime, DATE dStopTime = 0.0);
	HRESULT GetStartStopTime(int iLoc, DATE *pdStartTime, DATE *pdStopTime); // returns S_FALSE if iLoc out of bounds
	//a-tve-size
		// NOTE: Estimate of high water mark of cache storage in K that will 
		// be required during playing of the announcement
	HRESULT	put_CacheSize(ULONG ulSize);
	HRESULT	get_CacheSize(ULONG *pulSize);
	// a=tve-ends:
		// NOTE: ATVEF:Optional, WebTV: REQUIRED
	HRESULT put_SecondsToEnd(UINT uiSecondsToEnd);
	HRESULT get_SecondsToEnd(UINT *puiSecondsToEnd);
	// m=data <port value> tve-file/tve-trigger
	// NOTE: Must call SetSingle OR call both SetData and SetTrig

// ==================================
// OPTIONAL tags
// ==================================
	// o= tag (originator)
	HRESULT put_UserName(BSTR bstrUserName);		// defaults to "-"
	HRESULT get_UserName(BSTR *pbstrUserName);		
	// u=		URL where user can get more info
	HRESULT put_SessionURL(BSTR bstrURL);
	HRESULT get_SessionURL(BSTR *pbstrURL);
	// a=UUID:	UUID which uniquely identifies the enhancement
	HRESULT put_UUID(BSTR bstrGuid);
	HRESULT get_UUID(BSTR *bstrGuid);

	// a=lang:
	HRESULT put_LangID(LANGID langid);
	HRESULT get_LangID(LANGID *plangid);
//	HRESULT SetLangBSTR(BSTR bstrLang);
	// a=sdplang:
	HRESULT put_SDPLangID(LANGID langid);
	HRESULT get_SDPLangID(LANGID *plangid);
//	HRESULT SetSDPLangBSTR(BSTR bstrLang);
	// a=tve-level:			Content level Identifier.
	HRESULT	put_ContentLevelID(FLOAT fConLID);
	HRESULT	get_ContentLevelID(FLOAT *pfConLID);
// ==================================
// OTHER TAGS
// ==================================
	// v= tag  SDP Version Required, but not user definable.  always v=0
	
	// a=tve-type:primary
		// For WebTV Purposes this tag is always included, unless, user calls
		// SetPrimary(FALSE) in which case the tag will NOT be included at all.
	HRESULT put_Primary(BOOL bPrimary);
	HRESULT get_Primary(BOOL *pbPrimary);

// ==================================
// OTHER PUBLIC METHODS
// ==================================

	HRESULT GetAnnouncement(UINT *puiSize, char **ppAnnouncement);
	HRESULT GetRawAnnouncement(UINT *puiSize, char **ppAnnouncement, BSTR bstrAnnouncement);

	BOOL	AnncValid(int *piErrLoc);		// Validate the announcement
	HRESULT InitAll(VOID);					// resets all fields
	HRESULT	ClearTimes();					// clears the times values (t=)
	HRESULT	ClearEmailAddresses();			// clears the e-mail values (e=)
	HRESULT	ClearPhoneNumbers();			// clears the phone values (p=)
	HRESULT	ClearExtraAttributes();			// clears the extra attributes (a=)
	HRESULT ClearExtraFlags();				// clears the random extra falgs ('x'=)
	HRESULT	ClearAllMedia();				// clears all media objects (m=,c=,b=,i=,a=,'x'=)

	HRESULT put_SAPMsgIDHash(USHORT usHash);	// ID Hash in the SAP header. Default=0
	HRESULT get_SAPMsgIDHash(USHORT *pusHash);	
	HRESULT	put_SAPSendingIPULONG(ULONG ulIP);
	HRESULT	get_SAPSendingIPULONG(ULONG *pulIP);
	HRESULT	put_SAPDeleteAnnc(BOOL fDelete);	// send delete announcement (defaults to false)
	HRESULT	get_SAPDeleteAnnc(BOOL *pfDelete);

	// extra routines to overide default ATVEF properties... 
	HRESULT SetAnncStrmAddULONG(ULONG ulIP, UINT uiTTL, LONG lPort, ULONG ulMaxBandwidth);
	HRESULT GetAnncStrmAddULONG(ULONG *pulIP, UINT *puiTTL, LONG *plPort, ULONG *pulMaxBandwidth);

	// media stuff
	HRESULT get_Medias(/*[out, retval]*/ IDispatch* *ppVal)
	{ 
		return m_spMedias->QueryInterface(ppVal);
	}
	HRESULT get_MediaCount(long *pcMedia);			// perhaps move into IATVEFAnnouncement
	HRESULT get_Media(long iLoc,  IATVEFMedia **ppIDsp);
	HRESULT get_NewMedia(/*[out]*/ IATVEFMedia **ppIDsp);

// ==================================
// PRIVATE METHODS AND PROPERTIES
// ==================================

  private:
	ULONG	DATEtoNTP(DATE x);				// return a NTP time from a DATE
	HRESULT AppendSAPHeader(int *piLen, char *pBuff);		// adds SapHeader to string
  private:

	UINT		m_uiVersionID;						// Version ID
	UINT		m_uiSessionID;						// Session ID
	INT			m_cConfAttrib;						// Current Conference Attribute item index

	BOOL		m_bSDAPacket;						// default = true; if FALSE, generating a Session Description Deletion Packet

//	DOUBLE		m_dSessionMaxBandwidth;


	CComPtr<IATVEFStartStopList>	m_splStartStop;			// Start/Stop time pairs

	CComPtr<IATVEFAttrList>			m_spalEmailAddresses;	// e: parameters
	CComPtr<IATVEFAttrList>			m_spalPhoneNumbers;		// p: parameters
	CComPtr<IATVEFAttrList>			m_spalExtraAttributes;	// other random a: attributes
	CComPtr<IATVEFAttrList>			m_spalExtraFlags;		// other random 'x=???' flags (non a:)

// SAP value
	CComBSTR	m_spbsSAPSendingIP;				// sending IP in the SAP header (defaults to spbsSendingIP if null)
	USHORT		m_usMsgIDHash;					// message hash contained in the SAP header
	BOOL		m_fDeleteAnnc;					// sets 'delete bit' in SAP header

	// Session Attribute Values
	CComBSTR	m_spbsUserName;					// User Name
	CComBSTR	m_spbsSessionName;				// Session Name
	CComBSTR	m_spbsSessionDescription;		// Session Description
	CComBSTR	m_spbsSendingIP;				// IP address of the sender in SDP (o=) 
	
	CComBSTR	m_spbsURL;						// (u=)
	CComBSTR	m_spbsSessionUUID;				// 
//	GUID		m_guidSessionUUID;				// -- same data as m_spbsSessionUUID ---

	LANGID		m_langIDSessionLang;
	CComBSTR	m_spbsSessionLang;
	LANGID		m_langIDSDPLang;
	CComBSTR	m_spbsSDPLang;					// string version of above

	BOOL		m_bPrimary;
	INT			m_uiSecondsToEnd;
	ULONG		m_ulSize;						// a=tve-size:
	FLOAT		m_fConLID;
    CComBSTR    m_spbsSessionLabel;				// i=

	//
	//   Announcment IP/port information
	//
	CComBSTR	m_spbsAnncAddIP;				// ATVEF specifies 224.0.1.113 
	LONG		m_lAnncPort;					// ATVEF specifies 2670
	UINT		m_uiAnncTTL;					// original code uses 2 here 
	ULONG		m_ulAnncMaxBandwidth;
	//
	// Data/Trigger Address Information
	//
	CComPtr<IATVEFMedias>	m_spMedias;			// down tree collection pointer

	private:

}; // CSPDSource

#endif  //  __CSDPSRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\deflate.h ===
/* deflate.h -- internal compression state
 * Copyright (C) 1995-1996 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* $Id: deflate.h,v 1.10 1996/07/02 12:41:00 me Exp $ */

#ifndef _DEFLATE_H
#define _DEFLATE_H

#include "zutil.h"

/* ===========================================================================
 * Internal compression state.
 */

#define LENGTH_CODES 29
/* number of length codes, not counting the special END_BLOCK code */

#define LITERALS  256
/* number of literal bytes 0..255 */

#define L_CODES (LITERALS+1+LENGTH_CODES)
/* number of Literal or Length codes, including the END_BLOCK code */

#define D_CODES   30
/* number of distance codes */

#define BL_CODES  19
/* number of codes used to transfer the bit lengths */

#define HEAP_SIZE (2*L_CODES+1)
/* maximum heap size */

#define MAX_BITS 15
/* All codes must not exceed MAX_BITS bits */

#define INIT_STATE    42
#define BUSY_STATE   113
#define FINISH_STATE 666
/* Stream status */


/* Data structure describing a single value and its code string. */
typedef struct ct_data_s {
    union {
        ush  freq;       /* frequency count */
        ush  code;       /* bit string */
    } fc;
    union {
        ush  dad;        /* father node in Huffman tree */
        ush  len;        /* length of bit string */
    } dl;
} FAR ct_data;

#define Freq fc.freq
#define Code fc.code
#define Dad  dl.dad
#define Len  dl.len

typedef struct static_tree_desc_s  static_tree_desc;

typedef struct tree_desc_s {
    ct_data *dyn_tree;           /* the dynamic tree */
    int     max_code;            /* largest code with non zero frequency */
    static_tree_desc *stat_desc; /* the corresponding static tree */
} FAR tree_desc;

typedef ush Pos;
typedef Pos FAR Posf;
typedef unsigned IPos;

/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */

typedef struct internal_state {
    z_streamp strm;      /* pointer back to this zlib stream */
    int   status;        /* as the name implies */
    Bytef *pending_buf;  /* output still pending */
    Bytef *pending_out;  /* next pending byte to output to the stream */
    int   pending;       /* nb of bytes in the pending buffer */
    int   noheader;      /* suppress zlib header and adler32 */
    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */
    Byte  method;        /* STORED (for zip only) or DEFLATED */
    int   last_flush;    /* value of flush param for previous deflate call */

                /* used by deflate.c: */

    uInt  w_size;        /* LZ77 window size (32K by default) */
    uInt  w_bits;        /* log2(w_size)  (8..16) */
    uInt  w_mask;        /* w_size - 1 */

    Bytef *window;
    /* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size. Also, it limits
     * the window size to 64K, which is quite useful on MSDOS.
     * To do: use the user input buffer as sliding window.
     */

    ulg window_size;
    /* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */

    Posf *prev;
    /* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */

    Posf *head; /* Heads of the hash chains or NIL. */

    uInt  ins_h;          /* hash index of string to be inserted */
    uInt  hash_size;      /* number of elements in hash table */
    uInt  hash_bits;      /* log2(hash_size) */
    uInt  hash_mask;      /* hash_size-1 */

    uInt  hash_shift;
    /* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH >= hash_bits
     */

    long block_start;
    /* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */

    uInt match_length;           /* length of best match */
    IPos prev_match;             /* previous match */
    int match_available;         /* set if previous match exists */
    uInt strstart;               /* start of string to insert */
    uInt match_start;            /* start of matching string */
    uInt lookahead;              /* number of valid bytes ahead in window */

    uInt prev_length;
    /* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */

    uInt max_chain_length;
    /* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */

    uInt max_lazy_match;
    /* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels >= 4.
     */
#   define max_insert_length  max_lazy_match
    /* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels <= 3.
     */

    int level;    /* compression level (1..9) */
    int strategy; /* favor or force Huffman coding*/

    uInt good_match;
    /* Use a faster search when the previous match is longer than this */

    int nice_match; /* Stop searching when current match exceeds this */

                /* used by trees.c: */
    /* Didn't use ct_data typedef below to supress compiler warning */
    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

    struct tree_desc_s l_desc;               /* desc. for literal tree */
    struct tree_desc_s d_desc;               /* desc. for distance tree */
    struct tree_desc_s bl_desc;              /* desc. for bit length tree */

    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
    int heap_len;               /* number of elements in the heap */
    int heap_max;               /* element of largest frequency */
    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */

    uch depth[2*L_CODES+1];
    /* Depth of each subtree used as tie breaker for trees of equal frequency
     */

    uchf *l_buf;          /* buffer for literals or lengths */

    uInt  lit_bufsize;
    /* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */

    uInt last_lit;      /* running index in l_buf */

    ushf *d_buf;
    /* Buffer for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */

    ulg opt_len;        /* bit length of current block with optimal trees */
    ulg static_len;     /* bit length of current block with static trees */
    ulg compressed_len; /* total bit length of compressed file */
    uInt matches;       /* number of string matches in current block */
    int last_eob_len;   /* bit length of EOB code for last block */

#ifdef DEBUG
    ulg bits_sent;      /* bit length of the compressed data */
#endif

    ush bi_buf;
    /* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */
    int bi_valid;
    /* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */

} FAR deflate_state;

/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */
#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}


#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */

        /* in trees.c */
void _tr_init         OF((deflate_state *s));
int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
ulg  _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
			  int eof));
void _tr_align        OF((deflate_state *s));
void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
                          int eof));
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\gzmime.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        gzmime.cpp

    Abstract:

        

    Author:

        Chris Kauffman  (chrisk)

    Revision History:

		  JB.  6/22/00		-- Prefix bug fixes, Also fixed two minor memory leaks 
			   9/10/00		-- Prefix bug fixes.  Two more minor memory leaks.

		  ToDo --- need to update string code in filenames
				   to use CComBSTR's and better unicode.
				   instead of all the ugly lstrlen() code

		  

--*/

#include "stdafx.h"				// new jb

#include "zlib.h"
#include "time.h"				// new jb
#include "gzmime.h"
#include "zutil.h"				// for DEF_MEM_LEVEL

#include "DbgStuff.h"

#ifdef HRESULT
#undef HRESULT
#endif
typedef long HRESULT; 

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static char kDIRTERM = '\\';			// Directory terminating character in Set...Location()

static
char * g_MonthString [] = {
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
} ;

static
char * g_DayString [] = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
} ;

static
void
FormatSystemTime (
    IN  SYSTEMTIME *    pSystemTime,
    OUT char *          achbuffer
    )
/*++
    writes the contents of * pSystemTime to achbuffer in the following format:

        Sun, 06 Nov 1994 08:49:37 GMT

    reference (rfc822) :

         day         =  "Mon"  / "Tue" /  "Wed"  / "Thu"
                     /  "Fri"  / "Sat" /  "Sun"


         month       =  "Jan"  /  "Feb" /  "Mar"  /  "Apr"
                     /  "May"  /  "Jun" /  "Jul"  /  "Aug"
                     /  "Sep"  /  "Oct" /  "Nov"  /  "Dec"

--*/
{
    assert (pSystemTime) ;
    assert (achbuffer) ;

    sprintf (achbuffer,
             "%s, %02u %s %4u %02u:%02u:%02u GMT",
             g_DayString [pSystemTime -> wDayOfWeek],
             pSystemTime -> wDay,
             g_MonthString [pSystemTime -> wMonth - 1],
             pSystemTime -> wYear,
             pSystemTime -> wHour,
             pSystemTime -> wMinute,
             pSystemTime -> wSecond
             ) ;
}


/////////////////////////////////////////////////////////////////////////////
// CTVEContentSource

HRESULT CTVEContentSource::SetFilename(LPSTR lpstrFilename)
{
	HRESULT hr = S_OK;

	if (NULL != lpstrFilename)
	{
		CTVEDelete(m_lpstrFilename);
		if (NULL != (m_lpstrFilename = new CHAR[lstrlenA(lpstrFilename) + sizeof CHAR]))
		{
			lstrcpyA(m_lpstrFilename,lpstrFilename);
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	return hr;
}

		// creates a '/' terminated directory string (simply retuns if passed null string)
HRESULT CTVEContentSource::SetSourceLocation(LPSTR lpstrSourceLocation)
{
	HRESULT hr = S_OK;

	if (NULL != lpstrSourceLocation)
	{
		CTVEDelete(m_lpstrSourceLocation);		
		int ilen = lstrlenA(lpstrSourceLocation);
		m_lpstrSourceLocation = new CHAR[ilen + 2];		// +1  for '\' if need it, +1 for end NULL
		if(m_lpstrSourceLocation) 
		{
			if(ilen > 0)								// non-null input string
			{
				CHAR cEnd = lpstrSourceLocation[ilen-1];
				if(cEnd == '\\' || cEnd == '/') {
					delete m_lpstrSourceLocation;				// delete old string
					m_lpstrSourceLocation = new CHAR[ilen + 1];	// create new one the right length
					if(m_lpstrSourceLocation) 
						lstrcpyA(m_lpstrSourceLocation, lpstrSourceLocation);
					else {
						CTVEDelete(m_lpstrSourceLocation);	
						hr = HRESULT_FROM_WIN32(GetLastError());
						return hr;
					}
				} else {				// tack a '/' on to the end of the dir name
					if(m_lpstrSourceLocation) { 
						lstrcpyA(m_lpstrSourceLocation, lpstrSourceLocation);
						m_lpstrSourceLocation[ilen++] = kDIRTERM;	
					}
				}
			}
			m_lpstrSourceLocation[ilen] = 0;				// add null terminator for paranoia
		} else {
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	return hr;
}

		// creates a '/' terminated directory string
HRESULT CTVEContentSource::SetMIMEContentLocation(LPSTR lpstrMIMEContentLocation)
{
	HRESULT hr = S_OK;

	if (NULL != lpstrMIMEContentLocation)
	{
		CTVEDelete(m_lpstrMIMEContentLocation);		
		int ilen = lstrlenA(lpstrMIMEContentLocation);
		m_lpstrMIMEContentLocation = new CHAR[ilen + 2];		// +1  for '\' if need it, +1 for end NULL
		if(m_lpstrMIMEContentLocation) 
		{
			if(ilen > 0)							// null input string
			{
				CHAR cEnd = lpstrMIMEContentLocation[ilen-1];
				if(cEnd == '\\' || cEnd == '/') {
					delete m_lpstrMIMEContentLocation;					// delete old string
					m_lpstrMIMEContentLocation = new CHAR[ilen + 1];	// create new one of right length
					if(m_lpstrMIMEContentLocation) 
						lstrcpyA(m_lpstrMIMEContentLocation, lpstrMIMEContentLocation);
					else 
					{
						CTVEDelete(m_lpstrMIMEContentLocation);
						hr = HRESULT_FROM_WIN32(GetLastError());
						return hr;
					}
				} else {				// tack a '\' on to the end of the dir name
						if(m_lpstrMIMEContentLocation) { 
						lstrcpyA(m_lpstrMIMEContentLocation, lpstrMIMEContentLocation);
						m_lpstrMIMEContentLocation[ilen++] = kDIRTERM;	
					}
				}
			}
			m_lpstrMIMEContentLocation[ilen] = 0;				// add null terminator for paranoia
		} else {
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	return hr;
}
HRESULT CTVEContentSource::SetLang(long langid)
{
	HRESULT hr = S_OK;
	CHAR sLang[4];

	m_lLang = langid;

	if (0 != GetLocaleInfoA(langid,LOCALE_SABBREVLANGNAME,sLang,sizeof(sLang)/sizeof(CHAR)))
	{
		//
		// Trim third character in order to conform to ISO 639
		//
		sLang[2] = 0;
		assert(lstrlenA(sLang) == 2);
		CTVEDelete(m_lpstrLang);

		if (NULL != (m_lpstrLang = new CHAR[lstrlenA(sLang) + sizeof CHAR]))
		{
			lstrcpyA(m_lpstrLang,sLang);
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}

HRESULT CTVEContentSource::SetLangLPSTR(LPSTR lpstrLang)
{
	HRESULT hr = S_OK;

	//
	// Clear previous values
	//
	m_lLang = 0;
	CTVEDelete(m_lpstrLang);
	m_lpstrLang = NULL;

	//
	// Record new values
	//
	if (NULL != lpstrLang)
	{
		if (NULL != (m_lpstrLang = new CHAR[lstrlenA(lpstrLang) + sizeof CHAR]))
		{
			lstrcpyA(m_lpstrLang,lpstrLang);
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}

	return hr;
}

HRESULT CTVEContentSource::SetExpiresDate(DATE * pDate)
{
	m_dDate = * pDate;

	return S_OK;
}

HRESULT CTVEContentSource::SetPackageExpiresDate(DATE * pDate)
{
    m_dPackageExpiresDate = * pDate ;
    return S_OK ;
}

HRESULT CTVEContentSource::SetType(LPSTR lpstrType)
{
	HRESULT hr = S_OK;
    LPSTR   psz ;

    CTVEDelete(m_lpstrType);

    //  only want to put something in m_lpstrType if we have valid data to
    //  put in there.

    if (lpstrType == NULL) {
        return S_OK ;
    }

    //  0-length string ?
    if (lstrlenA (lpstrType) == 0) {
        return S_OK ;
    }

    //  skip over white space
    psz = lpstrType ;
    while (* psz == ' ' &&
           * psz != '\0') psz++ ;

    //  if there's nothing left, return
    if (lstrlenA (psz) == 0) {
        return S_OK ;
    }

	if (NULL != (m_lpstrType = new CHAR[lstrlenA(psz) + sizeof CHAR]))
	{
		lstrcpyA(m_lpstrType,psz);
	}
	else
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}

HRESULT CTVEContentSource::SetEncoding(LPSTR lpstrEncoding)
{
	HRESULT hr = S_OK;

    CTVEDelete(m_lpstrEncoding);

    if (lpstrEncoding == NULL) {
        return S_OK ;
    }

	if (NULL != (m_lpstrEncoding = new CHAR[lstrlenA(lpstrEncoding) + sizeof CHAR]))
	{
		lstrcpyA(m_lpstrEncoding,lpstrEncoding);
	}
	else
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}


HRESULT CTVEContentSource::GetSourceLocation(LPSTR* plpstrSourceLocation)
{
	HRESULT hr = S_OK;
	if (NULL != plpstrSourceLocation)
	{
		if (NULL != (*plpstrSourceLocation = new CHAR[1 + lstrlenA(m_lpstrSourceLocation) + sizeof CHAR]))
		{
			lstrcpyA(*plpstrSourceLocation,m_lpstrSourceLocation);
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

	return hr;
}

HRESULT CTVEContentSource::GetMIMEContentLocation(LPSTR* plpstrMIMEContentLocation)
{
	HRESULT hr = S_OK;
	if (NULL != plpstrMIMEContentLocation)
	{
		if (NULL != (*plpstrMIMEContentLocation = new CHAR[1 + lstrlenA(m_lpstrMIMEContentLocation) + sizeof CHAR]))
		{
			lstrcpyA(*plpstrMIMEContentLocation,m_lpstrMIMEContentLocation);
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

	return hr;
}

HRESULT CTVEContentSource::GetType(LPSTR* plpstrType)
{
	HRESULT hr = S_OK;
	if (NULL != plpstrType)
	{
        * plpstrType = NULL ;

        if (m_lpstrType) {
		    if (NULL != (*plpstrType = new CHAR[1 + lstrlenA(m_lpstrType) + sizeof CHAR]))
		    {
			    lstrcpyA(*plpstrType,m_lpstrType);
		    }
		    else
		    {
			    hr = HRESULT_FROM_WIN32(GetLastError());
		    }
        }
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

	return hr;
}

HRESULT CTVEContentSource::GetLanguage(LPSTR* plpstrLang)
{
	HRESULT hr = S_OK;
	if (NULL != plpstrLang)
	{
		if (NULL != (*plpstrLang = new CHAR[1 + lstrlenA(m_lpstrLang) + sizeof CHAR]))
		{
			lstrcpyA(*plpstrLang,m_lpstrLang);
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

	return hr;
}

HRESULT CTVEContentSource::GetEncoding(LPSTR* plpstrEncoding)
{
	HRESULT hr = S_OK;
	if (NULL != plpstrEncoding)
	{
        * plpstrEncoding = NULL ;

        if (m_lpstrEncoding) {
		    if (NULL != (*plpstrEncoding = new CHAR[1 + lstrlenA(m_lpstrEncoding) + sizeof CHAR]))
		    {
			    lstrcpyA(*plpstrEncoding,m_lpstrEncoding);
		    }
		    else
		    {
			    hr = HRESULT_FROM_WIN32(GetLastError());
		    }
        }
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

	return hr;
}

HRESULT CTVEContentSource::GetExpiresDate(DATE * pdDate)
{
	if (NULL != pdDate)
	{
		*pdDate = m_dDate;
		return S_OK;
	}
	else
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}
}

HRESULT CTVEContentSource::GetPackageExpiresDate(DATE * pdDate)
{
	if (NULL != pdDate)
	{
		*pdDate = m_dPackageExpiresDate;
		return S_OK;
	}
	else
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}
}


HRESULT CTVEContentSource::GetFilename(LPSTR* plpstrFilename)
{
	HRESULT hr = S_OK;
	if (NULL != plpstrFilename)
	{
		if (NULL != (*plpstrFilename = new CHAR[1 + lstrlenA(m_lpstrFilename) + sizeof CHAR]))
		{
			lstrcpyA(*plpstrFilename,m_lpstrFilename);
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CTVEComPack

HRESULT CTVEComPack::Init(DATE ExpiresDate)
{
	DEFINE_HR;

	//
	// Initialize Buffers
	//
    CTVEDelete(m_pInBuffer) ;
    CTVEDelete(m_pOutBuffer) ;

	m_pInBuffer = (BYTE*) new BYTE[CGzipMIMEComPack_IN_BUFFER_DEFAULT];

	if (NULL == m_pInBuffer)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto InitExit;
	}

	m_pOutBuffer = (BYTE*) new BYTE[CGzipMIMEComPack_OUT_BUFFER_DEFAULT];

	if (NULL == m_pOutBuffer)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto InitExit;
	}

    m_ExpiresDate = ExpiresDate ;

InitExit:
	return hr;
}

HRESULT CTVEComPack::WriteStream(CTVEContentSource* pSource, BOOL fCompress)
{
	HRESULT	hr=S_OK;
	LONG 	lCurrentStreamSizePlaceHolder = 0;
	DWORD	dwSize = 0;
	INT		idx = 0;
	USES_CONVERSION;


	hr = DoesFileExist(pSource);
	if(S_OK != hr)
		return hr;

	//
	// Is there a package already in progress
	//

	if (0 == m_dwBytesInOutputBuffer)
	{
		//
		// No package has been started
		//
		CreateNewTempFile();
		CreateNewMIMEBoundry(m_szBoundry, sizeof(m_szBoundry));

        pSource -> SetPackageExpiresDate (& m_ExpiresDate) ;
		WritePackageHeader(pSource,m_szBoundry);
	}

	//
	// UNDONE: add missing information to headers
	//

    if (fCompress) {
	    pSource->SetEncoding("gzip");
    }
    else {
	    pSource->SetEncoding(NULL);
    }

	//
	// Write MIME header
	//
	if (FAILED(hr = WriteStreamHeader(pSource, m_szBoundry, &lCurrentStreamSizePlaceHolder )))
	{
		goto CompressStreamExit;
	}

	//
	// Compress and write body contents
	//
	if (FAILED(hr = WriteStreamBody(pSource, &dwSize, fCompress)))
	{
		goto CompressStreamExit;
	}

	//
	// Write length into place holder
	//

	WriteStreamSize(dwSize, lCurrentStreamSizePlaceHolder );

	//
	// MIME Boundry
	//
	WriteStringToBuffer(PACKAGE_DASH_DASH);
	WriteStringToBuffer(m_szBoundry);

CompressStreamExit:
	return hr;
}

HRESULT CTVEComPack::WriteStreamHeader(CTVEContentSource* pSource, LPCSTR lpszBoundry, LONG* lpSizePlaceHolder)
{
	DEFINE_HR;
	VARIANT vSrc, vDest;
	LPSTR lpstrTemp = NULL;
	VariantInit(&vSrc);
	VariantInit(&vDest);
	SYSTEMTIME systime = {0};
    char achbuffer [64] ;

	WriteStringToBuffer(PACKAGE_CRLF);
	//
	// Content Location
	//
	WriteStringToBuffer(PACKAGE_CONTENT_LOCATION);

    pSource->GetMIMEContentLocation(&lpstrTemp);
	WriteStringToBuffer(lpstrTemp);
	RELEASE_LPSTR(lpstrTemp);

	pSource->GetFilename(&lpstrTemp);
	WriteStringToBuffer(lpstrTemp);
	RELEASE_LPSTR(lpstrTemp);

	WriteStringToBuffer(PACKAGE_CRLF);

	//
	// Content Length
	//
	WriteStringToBuffer(PACKAGE_LENGTH_HEADER);
	*lpSizePlaceHolder = m_dwCurrentPos;
	WriteStringToBuffer(PACKAGE_LENGTH_PLACEHOLDER);
	WriteStringToBuffer(PACKAGE_CRLF);

    //  
    //  Expires Date
    //
	vSrc.vt = VT_DATE;
	pSource->GetExpiresDate(&(vSrc.date));
    if (vSrc.date != 0.0) {
        VariantTimeToSystemTime (vSrc.date, & systime) ;

        FormatSystemTime (
            & systime,
            achbuffer
            ) ;

        WriteStringToBuffer (PACKAGE_CONTENT_EXPIRES) ;
        WriteStringToBuffer (achbuffer) ;
        WriteStringToBuffer (PACKAGE_CRLF) ;
    }

    //
    //  Date (now)
    //
	GetSystemTime(&systime);

    FormatSystemTime (
        & systime,
        achbuffer
        ) ;

    WriteStringToBuffer (PACKAGE_CONTENT_DATE) ;
    WriteStringToBuffer (achbuffer) ;
    WriteStringToBuffer (PACKAGE_CRLF) ;


	//
	// Content Type
	//
	pSource->GetType(&lpstrTemp);
	if (NULL != lpstrTemp)
	{
		WriteStringToBuffer(PACKAGE_CONTENT_TYPE);
		WriteStringToBuffer(lpstrTemp);					// PBUG - should be application//octet-stream for compression
		WriteStringToBuffer(PACKAGE_CRLF);
		RELEASE_LPSTR(lpstrTemp);
	}

	//
	// Content Language
	//
	pSource->GetLanguage(&lpstrTemp);
	if (NULL != lpstrTemp)
	{
		WriteStringToBuffer(PACKAGE_CONTENT_LANGUAGE);
		WriteStringToBuffer(lpstrTemp);
		WriteStringToBuffer(PACKAGE_CRLF);
		RELEASE_LPSTR(lpstrTemp);
	}

	//
	// Content Encoding
	//
	pSource->GetEncoding(&lpstrTemp);
	if (NULL != lpstrTemp)
	{
		WriteStringToBuffer(PACKAGE_CONTENT_ENCODING);
		WriteStringToBuffer(lpstrTemp);
		WriteStringToBuffer(PACKAGE_CRLF);
		RELEASE_LPSTR(lpstrTemp);
	}

	WriteStringToBuffer(PACKAGE_CRLF);

	return hr;
}

HRESULT CTVEComPack::WriteStringToBuffer(LPCSTR lpszContent)
{
	DEFINE_HR;
/*
#ifdef UNICODE
	CHAR* lpszTemp;
	
	lpszTemp = (CHAR*)new CHAR[lstrlen(lpszContent) + sizeof CHAR];

	if (NULL != lpszTemp)
	{
		//
		// Convert to ANSI
		//
		WideCharToMultiByte(CP_ACP,
							NULL,
							lpszContent,
							lstrlenW(lpszContent) + 1,
							lpszTemp,
							lstrlenW(lpszContent) + 1,
							NULL,					// default CHAR
							NULL);					// is default CHAR used

		hr = WriteToBuffer(lpszTemp,lstrlenA(lpszTemp));

		delete lpszTemp;
	}
	else
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}
#else 
*/
	hr = WriteToBuffer((LPVOID)lpszContent,lstrlenA(lpszContent));
//#endif // UNICODE

	return hr;
}

HRESULT CTVEComPack::WriteBSTRToBuffer(BSTR bstr)
{
	DEFINE_HR;

	CHAR* lpszTemp;
	
	lpszTemp = (CHAR*)new CHAR[SysStringLen(bstr) + sizeof CHAR];

	if (NULL != lpszTemp)
	{
		//
		// Convert to ANSI
		//
		if (0 == WideCharToMultiByte(CP_ACP,
							NULL,
							bstr,
							SysStringLen(bstr) + 1,
							lpszTemp,
							SysStringLen(bstr) + 1,
							NULL,					// default CHAR
							NULL))					// is default CHAR used
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
		else
		{
			lpszTemp[SysStringLen(bstr)] = '\0';
			hr = WriteToBuffer(lpszTemp,lstrlenA(lpszTemp));
		}

		delete lpszTemp;
	}
	else
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}
	return hr;
}

HRESULT CTVEComPack::WriteToBuffer(LPVOID pvContent, DWORD dwContentSize)
{
	DEFINE_HR;
	DWORD dwWritten = 0;

	//
	// Validate parameters and available size
	//
	if (NULL == pvContent || dwContentSize > 0x80000000)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		goto WriteToBufferExit;
	}

	//
	// Write to buffer
	//
	WriteFile(m_hFile,pvContent,dwContentSize,&dwWritten,NULL);

	//
	// Update count and pointers
	//
	m_dwBytesInOutputBuffer += dwContentSize;
	m_dwBytesInPackageLength += dwContentSize;
	m_dwCurrentPos = ((DWORD)m_dwCurrentPos + (DWORD)dwContentSize);

WriteToBufferExit:
	return hr;
}

HRESULT CTVEComPack::CreateNewTempFile()
{
	CHAR szPath[MAX_PATH+1];

	if (0 != GetTempPathA(MAX_PATH,szPath))
	{
		if (0 != GetTempFileNameA(szPath,"TVE",0,m_TempFileName))
		{
            
			m_hFile = CreateFileA(
				m_TempFileName,
				GENERIC_WRITE,
				NULL,// read sharing for debug purposes
				NULL,			// security attributes
				CREATE_ALWAYS,
				FILE_ATTRIBUTE_TEMPORARY |		// optimization
				FILE_FLAG_RANDOM_ACCESS,
				NULL);
			if (INVALID_HANDLE_VALUE == m_hFile)
			{
				return HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	return S_OK;
}

HRESULT CTVEComPack::CreateNewMIMEBoundry(CHAR *pcBuffer,INT iBufferSize)
{
	DEFINE_HR;
	INT idx;
	//CHAR szLegalChars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'()+_,-./:=?";
//	CHAR szLegalChars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
	CHAR szLegalChars[] = "ValiIsALove1yDOrkBCEFGHJKMNPQRSTUWXYZbcdfghjmnpqtuwxz023456789";
	CHAR *pc = pcBuffer;
	//
	// Validate Parameters
	//
	if (iBufferSize < 2)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		goto CreateNewMIMEBoundryExit;
	}

	//
	// Create boundry
	//
	srand((unsigned int) time(NULL));		// Win64 cast here (JB 2/15/00)
	for (idx = 0; idx < (iBufferSize - 1); idx++)
	{
		*pc++ = szLegalChars[(rand()%(lstrlenA(szLegalChars) * 2)) >> 1];
	}

	for(idx = 0; idx < 17; idx++)
		pcBuffer[idx*2+1] = szLegalChars[idx]; 

	//
	// NULL Terminator
	//
	*pc = '\0';

CreateNewMIMEBoundryExit:
	return hr;
}

HRESULT CTVEComPack::WritePackageHeader(CTVEContentSource *pSource,LPCSTR lpszBoundry)
{
	DEFINE_HR;
    char achbuffer [128] ;
    VARIANT vSrc ;
    SYSTEMTIME systime ;

	WriteStringToBuffer(PACKAGE_LENGTH_HEADER);

	//
	// Keep track of the where the placehold is, that will contain the length of the package
	//
	m_dwSizeOfPackage = m_dwCurrentPos;

	WriteStringToBuffer(PACKAGE_LENGTH_PLACEHOLDER);
	WriteStringToBuffer(PACKAGE_CRLF);

	//
	// Content Expires; write if non-zero
	//

	vSrc.vt = VT_DATE;
	pSource->GetPackageExpiresDate(&(vSrc.date));
    if (vSrc.date != 0.0) {
        VariantTimeToSystemTime (vSrc.date, & systime) ;

        FormatSystemTime (
            & systime,
            achbuffer
            ) ;

        WriteStringToBuffer (PACKAGE_CONTENT_EXPIRES) ;
        WriteStringToBuffer (achbuffer) ;
        WriteStringToBuffer (PACKAGE_CRLF) ;
    }

	//
	// Content Date
	// This value is always set to the current time at Coordinated Universal Time (UTC)
	//
	GetSystemTime(&systime);

    FormatSystemTime (
        & systime,
        achbuffer
        ) ;

    WriteStringToBuffer (PACKAGE_CONTENT_DATE) ;
    WriteStringToBuffer (achbuffer) ;
    WriteStringToBuffer (PACKAGE_CRLF) ;


	WriteStringToBuffer(PACKAGE_TYPE_HEADER);

	// WriteStringToBuffer("\"");		// opening quote marks			// PBUG (WebTV doesn't like this)
	WriteStringToBuffer(lpszBoundry);
	// WriteStringToBuffer("\"");		// closing quote marks			// PBUG

	//WriteStringToBuffer(PACKAGE_CRLF);
	//WriteStringToBuffer(PACKAGE_PREAMBLE);
	WriteStringToBuffer(PACKAGE_CRLF);
	WriteStringToBuffer(PACKAGE_CRLF);

	//
	// At this point, reset the output bytes counter.
	//
	m_dwBytesInPackageLength = 0;

	//
	// MIME Boundry
	//
	WriteStringToBuffer(PACKAGE_DASH_DASH);
	WriteStringToBuffer(lpszBoundry);

	return hr;
}

HRESULT CTVEComPack::WriteStreamBody(CTVEContentSource* pSource, LPDWORD lpdwSize, BOOL fCompress)
{
	DEFINE_HR;

	*lpdwSize = 0;



    if (fCompress) {
	    hr = CompressToBuffer(pSource, lpdwSize);
    }
    else {
        hr = ClearTextToBuffer (pSource, lpdwSize) ;
    }

	if (FAILED(hr))
	{
		goto WriteStreamBodyExit;
	}

	//
	// Terminating CR/LF
	//
	hr = WriteStringToBuffer(PACKAGE_CRLF);

WriteStreamBodyExit:
	return hr;
}


HRESULT CTVEComPack::DoesFileExist(CTVEContentSource *pSource)
{
    HANDLE  hFile ;
    LPSTR   lpstrFilename = NULL ;
    LPSTR   lpstrLocation = NULL ;

	HRESULT   hr = S_OK;
    hFile = INVALID_HANDLE_VALUE ;

	pSource->GetSourceLocation (& lpstrLocation) ;		// '/' terminated string
    pSource->GetFilename (& lpstrFilename) ;

    //  open the file for reading
    if (NULL != lpstrFilename) {
		char *szBuff = new char[strlen(lpstrFilename) + strlen(lpstrLocation) + 1];
        if(!szBuff) {
			hr = HRESULT_FROM_WIN32 (GetLastError ()) ;
			goto cleanup;
		}
		strcpy(szBuff, lpstrLocation);
		strcat(szBuff, lpstrFilename);

        hFile = CreateFileA (
                    szBuff,
                    GENERIC_READ,
                    NULL,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL) ;

		delete szBuff;
        if (hFile == INVALID_HANDLE_VALUE) {
			long x = GetLastError();
			hr = HRESULT_FROM_WIN32(x) ;
            goto cleanup ;
        }
    }
    else {
        hr = E_INVALIDARG ;
        goto cleanup ;
    }

cleanup :

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle (hFile) ;
    }

    return hr ;
}

HRESULT CTVEComPack::ClearTextToBuffer (CTVEContentSource *pSource, LPDWORD lpdwSize)
{
    HANDLE  hFile ;
    LPSTR   lpstrFilename = NULL ;
    LPSTR   lpstrLocation = NULL ;
	DEFINE_HR ;
    DWORD   gulpRead ;
    BOOL    r ;

    hFile = INVALID_HANDLE_VALUE ;

	pSource -> GetSourceLocation (& lpstrLocation) ;		// '/' terminated string
    pSource -> GetFilename (& lpstrFilename) ;

    //  open the file for reading
    if (NULL != lpstrFilename) {
		char *szBuff = new char[strlen(lpstrFilename) + strlen(lpstrLocation) + 1];
        if(!szBuff) {
			hr = HRESULT_FROM_WIN32 (GetLastError ()) ;
			goto cleanup;
		}
		strcpy(szBuff, lpstrLocation);
		strcat(szBuff, lpstrFilename);

        hFile = CreateFileA (
                    szBuff,
                    GENERIC_READ,
                    NULL,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL) ;

		delete szBuff;
        if (hFile == INVALID_HANDLE_VALUE) {
            hr = HRESULT_FROM_WIN32 (GetLastError ()) ;
            goto cleanup ;
        }
    }
    else {
        hr = E_INVALIDARG ;
        goto cleanup ;
    }

    //  copy the contents of the buffer to our output file
    for (;;) {
        r = ReadFile (
                hFile,
                m_pInBuffer,
                CGzipMIMEComPack_IN_BUFFER_DEFAULT,
                & gulpRead,
                NULL
                ) ;
        if (r == FALSE ||
            gulpRead == 0) {

            break ;
        }

        hr = WriteToBuffer (m_pInBuffer, gulpRead) ;
        if (FAILED (hr)) {
            break ;
        }

        * lpdwSize += gulpRead ;
    }

    cleanup :

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle (hFile) ;
    }

    return hr ;
}

static									// GZIP BUG - turn off adler32 using '-' MAX_WBITS
int DeflateInitForCRC(z_streamp strm,int level)
{
    return deflateInit2(strm, level, Z_DEFLATED, 
						- MAX_WBITS,					// '-' turns off Adler32 so we can do it ourselves
							DEF_MEM_LEVEL,
						 Z_DEFAULT_STRATEGY);
}

HRESULT CTVEComPack::CompressToBuffer(CTVEContentSource *pSource, LPDWORD lpdwSize)
{
	DEFINE_HR;
	z_stream stream;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	ULONG ulBytesWritten = 0;
	DWORD dwFileBytesWritten = 0;
	int iRC = 0;
	BYTE rbInputSize[4] = {0,0,0,0};
	DWORD dwHeaderSize = 0;
	IUnknown *punk = NULL;
	LPSTR lpstrFilename = NULL;
	LPSTR lpstrLocation = NULL;
	BOOL bEndPhase = FALSE;

	uLong crc = crc32(0L, Z_NULL, 0);			// GZIP bug - initialize the CRC

	ZeroMemory(&stream,sizeof(stream));

	if (FAILED(hr = WriteGZipHeader(&dwHeaderSize)))
	{
		goto CompressToBufferExit;
	}

	//
	// Open the content source
	//
	pSource -> GetSourceLocation (& lpstrLocation) ;
	pSource -> GetFilename (& lpstrFilename) ;
 
	if (0 != lpstrFilename)
	{
		char *szBuff = new char[strlen(lpstrFilename) + strlen(lpstrLocation) + 1];
		if(!szBuff) {
			hr = HRESULT_FROM_WIN32 (GetLastError ()) ;
			goto CompressToBufferExit;
		}
		strcpy(szBuff, lpstrLocation);
		strcat(szBuff, lpstrFilename);

		hFile = CreateFileA(
			szBuff,
			GENERIC_READ,
			NULL,
			NULL,			// security
			OPEN_EXISTING,
			FILE_FLAG_SEQUENTIAL_SCAN,
			NULL);			// template

		delete szBuff;
		if (INVALID_HANDLE_VALUE == hFile)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto CompressToBufferExit;
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		goto CompressToBufferExit;
	}

	//
	// Initiaize compression
	//

	stream.next_out = (BYTE*)m_pOutBuffer;
	stream.avail_out = CGzipMIMEComPack_OUT_BUFFER_DEFAULT;

	stream.zalloc = (alloc_func)0;
	stream.zfree = (free_func)0;
	stream.opaque = (voidpf)0;

	iRC = DeflateInitForCRC(&stream,Z_DEFAULT_COMPRESSION);
	if (Z_OK != iRC)
	{
		goto CompressToBufferExit;
	}

	//
	// Read and write data
	//
	ulBytesWritten = 1;
	while ( !FAILED(hr) && 
			(Z_OK == iRC || Z_STREAM_END == iRC) &&
			ulBytesWritten > 0)
	{
		if (FALSE == bEndPhase)
		{
			if (INVALID_HANDLE_VALUE != hFile)
			{
				if (0 == ReadFile(hFile,m_pInBuffer,CGzipMIMEComPack_IN_BUFFER_DEFAULT,&ulBytesWritten,NULL))
				{
					hr = HRESULT_FROM_WIN32(GetLastError());
				}
			}
		}
		crc = crc32(crc, m_pInBuffer, ulBytesWritten);			// GZIP bug - compute the CRC

		if (!FAILED(hr) )
		{
			if (ulBytesWritten > 0 && FALSE == bEndPhase)
			{
				//
				// Setup parameters for compression
				//
				stream.next_in = m_pInBuffer;
				stream.avail_in = ulBytesWritten;
			}
			else
			{
				stream.next_in = m_pInBuffer;
				stream.avail_in = 0;
				bEndPhase = TRUE;
			}



			while (0 != stream.avail_in || (TRUE == bEndPhase && iRC != Z_STREAM_END))
			{
				// compute the CRC of the buffer


				// Compress contents
				//
				if (TRUE == bEndPhase)
				{
					iRC = deflate(&stream,Z_FINISH);
				}
				else
				{
					iRC = deflate(&stream,Z_NO_FLUSH);
				}


				//
				// Write any compressed content to file
				//
				if (stream.next_out != m_pOutBuffer)
				{
					dwFileBytesWritten = 0;
					if (0 == WriteFile(m_hFile, m_pOutBuffer,
									   (DWORD) (stream.next_out - m_pOutBuffer),	// new cast for Win64 (JB 2/15/00)
									   &dwFileBytesWritten,
									   NULL))
					{
						hr = HRESULT_FROM_WIN32(GetLastError());
					}
					//
					// reset output buffer
					//
#ifdef DEBUG 
					CopyMemory(m_pOutBuffer,"sobesobesobe\0",13);
#endif
					stream.next_out = (BYTE*)m_pOutBuffer;
					stream.avail_out = CGzipMIMEComPack_OUT_BUFFER_DEFAULT;
				}
			}; // while there is something to write
		}
	};	// while there is something to do

	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;

		RELEASE_LPSTR(lpstrFilename);
	}

	if ((Z_OK == iRC || Z_STREAM_END == iRC)
		&& 0 == stream.avail_in)
	{
		//
		// Compress worked, update pointers and sizes
		//
		m_dwBytesInOutputBuffer += stream.total_out;
		m_dwBytesInPackageLength += stream.total_out;
		m_dwCurrentPos += stream.total_out;
		iRC = Z_OK;
	}

	deflateEnd(&stream);
	
																	// GZIP bug - tack on the CRC
	rbInputSize[3] = (BYTE)(crc >> 24) & 0xFF;
	rbInputSize[2] = (BYTE)(crc >> 16) & 0xFF;
	rbInputSize[1] = (BYTE)(crc >> 8) & 0xFF;
	rbInputSize[0] = (BYTE)(crc) & 0xFF;
	WriteToBuffer(rbInputSize,sizeof(rbInputSize));
	//
	// Write uncompressed size to file
	//
/*	rbInputSize[0] = (BYTE)(stream.total_in >> 24) & 0xFF;			// GZIP bug - bytes in wrong order
	rbInputSize[1] = (BYTE)(stream.total_in >> 16) & 0xFF;
	rbInputSize[2] = (BYTE)(stream.total_in >> 8) & 0xFF;
	rbInputSize[3] = (BYTE)stream.total_in & 0xFF; */

	rbInputSize[3] = (BYTE)(stream.total_in >> 24) & 0xFF;
	rbInputSize[2] = (BYTE)(stream.total_in >> 16) & 0xFF;
	rbInputSize[1] = (BYTE)(stream.total_in >> 8) & 0xFF;
	rbInputSize[0] = (BYTE)(stream.total_in) & 0xFF;

	WriteToBuffer(rbInputSize,sizeof(rbInputSize));

	*lpdwSize = stream.total_out + dwHeaderSize + sizeof(rbInputSize) + sizeof(rbInputSize);	// GZIP bug - add size of CRC

 CompressToBufferExit:
	return hr;
}

HRESULT CTVEComPack::WriteGZipHeader(LPDWORD lpdwHeaderSize)
{
	DEFINE_HR;
	BYTE rgHeader[] = {	0x1f,	// magic number
						0x8B,	// magic number
						0x08,	// deflate compression
						0x00,	// flags
						0x00,	// file modification time
						0x00,	// file modification time
						0x00,	// file modification time
						0x00,	// file modification time
						0x00,	// extra flags (for compression)
						0x0B};	// OS type 0x0B = Win32

	hr = WriteToBuffer((LPVOID)rgHeader,sizeof(rgHeader));	

	*lpdwHeaderSize = sizeof(rgHeader);

	return hr;
}

HRESULT CTVEComPack::WriteStreamSize(DWORD dwSize, LONG lCurrentStreamSizePlaceHolder )
{
	DEFINE_HR;

	CHAR szTemp[1024];
	DWORD dwCurrent = 0;
	INT idx = 0;

	wsprintfA(szTemp,"%d",dwSize);	// THIS IS ANSI on PURPOSE

	if (lstrlenA(PACKAGE_LENGTH_PLACEHOLDER) < (lstrlenA(szTemp) + 1))
	{
		hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	}
	else
	{
		//
		// Get the current position in the output file
		//
		dwCurrent = SetFilePointer(m_hFile, 0, NULL, FILE_CURRENT) ;

		//
		// Move to where the x's start
		//
		SetFilePointer(m_hFile,lCurrentStreamSizePlaceHolder ,NULL,FILE_BEGIN);

		WriteToBuffer(szTemp,lstrlenA(szTemp));

		//
		// Replace the trailing NULL and x's with spaces
		//
		for (idx = lstrlenA(szTemp); idx < lstrlenA(PACKAGE_LENGTH_PLACEHOLDER); idx++)
		{
			WriteToBuffer(" ",1);
		}


		//
		// Do not add this size to the current file position
		//
		m_dwCurrentPos -= lstrlenA(PACKAGE_LENGTH_PLACEHOLDER);

		//
		// Move pointer back
		//
		SetFilePointer(m_hFile, dwCurrent, NULL, FILE_BEGIN);
	}
	return hr;
}

HRESULT 
CTVEComPack::FinishPackage (
    OUT CHAR * pTempFilename       // assumed to be of MAX_PATH length
    )
{
	DEFINE_HR;
	INT idx = 0;

    if (pTempFilename == NULL) {

        return E_INVALIDARG ;
    }

    if (m_hFile != INVALID_HANDLE_VALUE) {
        
        assert (strlen (m_TempFileName)) ;

	    hr = WriteStringToBuffer(PACKAGE_DASH_DASH) ;

	    //
	    // Write length into place holder
	    //
	    if(!FAILED(hr))
			WriteStreamSize(m_dwBytesInPackageLength, m_dwSizeOfPackage) ;

        if(0 == CloseHandle (m_hFile))
		{
			int err = GetLastError();
			hr = HRESULT_FROM_WIN32(err);
			hr = S_OK;							// don't cry if fail
		}
        m_hFile = INVALID_HANDLE_VALUE ;

        strcpy (pTempFilename, m_TempFileName) ;
    }

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\ipvbi.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        session.cpp

    Abstract:

        This module implements the IP/UDP header generation, IP-VBI 
        compression, and SLIP encoding.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        15-Apr-1999     created

--*/

#include "stdafx.h"
#include "ipvbi.h"

#include "DbgStuff.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static LONG g_IPidentification ;

static
WORD 
ComputeInternetChecksum (
    IN  LPBYTE data, 
    IN  DWORD length
    )
{
	WORD	word;
	DWORD	sum;

	sum = 0;
	while (length >= 2) {
		word = (((WORD) data[0]) << 8) | data[1];
		sum += word;

		data += 2;
		length -= 2;
	}

	// perform end-around carry
	sum = (sum & 0xFFFF) + (sum >> 16);
    sum += (sum >> 16) ;
	return (WORD) ((~sum) & 0xFFFF);
}

static
void
ComputeIPChecksum_ (
    IN  IP_HEADER * pIPHeader
    )
{
    assert (pIPHeader) ;
    pIPHeader -> Checksum = ComputeInternetChecksum ((BYTE *) pIPHeader, pIPHeader -> HeaderLength * 4) ;
    pIPHeader -> Checksum = htons (pIPHeader -> Checksum) ;
}

static
int 
__cdecl 
QSortCompareKey (
    const void * a, 
    const void * b
    )
/*++
    
    Routine Description:

        this routine is used by the crt qsort function to the m_ppStreamList
        array.

    Parameters:

        a       IP_VBI_STREAM_NODE **
        b       IP_VBI_STREAM_NODE **

    Return Values:

        ** see the IP_VBI_KEY data structure.

        -1      a < b
        0       a = b
        1       a > b

--*/
{
    return IP_VBI_KEY::Compare (& ((* (IP_VBI_STREAM_NODE **) a) -> NodeValue), & ((* (IP_VBI_STREAM_NODE **) b) -> NodeValue));
}


// ----------------------------------------------------------------------------
//      C I P V B I
// ----------------------------------------------------------------------------
CIPVBI::CIPVBI (
    ) : m_pSLIPFrame (NULL),
        m_pAllocatedKeys (NULL),
        m_StreamListLength (0),
        m_CompressionCountCycle (DEFAULT_COMPRESSION_COUNT_CYCLE)
/*++
    
    Routine Description:

        constructor; initializes non-failable properties and values

    Parameters:

        none

--*/
{
}

CIPVBI::~CIPVBI (
    )
/*++
    
    Routine Description:

        destructor; frees allocated memory

    Parameters:

    Return Values:

--*/
{
    delete m_pAllocatedKeys ;
    delete m_pSLIPFrame ;
}

HRESULT
CIPVBI::Initialize (
    IN  ULONG   SourceIP,                                               //  host order
    IN  USHORT  SourcePort,                                             //  host order
    IN  BYTE    CompressionKeyMin,
    IN  BYTE    CompressionKeyMax,
    IN  DWORD   CompressedUncompressedRatio,
    IN  SHORT   MaxUDPPayloadLength
    )
/*++

    Routine Description:

        This routine initializes the object.  This is failable call.  A
        failure most likely will be a memory allocation failure of some
        type.

    Parameters:

        SourceIP                source IP for IP header

        SourcePort              source port for UDP header

        CompressionKeyMin       IP-VBI compression low key; default is 0x00;
                                inclusive

        CompressionKeyMax       IP-VBI compression high key; default is 0x7f;
                                inclusive

        CompressedUncompressedRatio

        MaxUDPPayloadLength     this provides an upper bound on the size of the
                                SLIP frame; default is ethernet udp mtu: 1472 bytes

    Return Values:

        S_OK            success

        error code      failure

--*/
{
    HRESULT hr ;
    int     i ;

    //  validate the parameters
    if (CompressionKeyMin > CompressionKeyMax ||
        SourceIP == 0 ||
        MaxUDPPayloadLength == 0 ||
        CompressionKeyMax > 0x7f) {

        hr = E_INVALIDARG ;
        goto error ;
    }

    //  free these up, though this should really be an assert that these
    //  values are NULL
    DELETE_RESET (m_pSLIPFrame) ;
    DELETE_RESET (m_pAllocatedKeys) ;

    //  compression count cycle is set
    m_CompressionCountCycle = CompressedUncompressedRatio ;

    //  initialize our queues (don't populate either yet)
    hr = m_FreeQueue.Initialize () ;
    GOTO_NE (hr, S_OK, error) ;

    hr = m_BusyQueue.Initialize () ;
    GOTO_NE (hr, S_OK, error) ;

    //
    //  allocate our memory
    //

    m_UDPPayloadMaxLength = MaxUDPPayloadLength + sizeof IP_HEADER + sizeof UDP_HEADER ;
    m_SLIPFrameMaxLength = (m_UDPPayloadMaxLength + sizeof IP_HEADER + sizeof UDP_HEADER) * 2 + 2 ;

    //  we know we won't exceed twice the max datagram size, but still ..
    m_pSLIPFrame = new BYTE [m_SLIPFrameMaxLength] ;
    m_pAllocatedKeys = new IP_VBI_STREAM_NODE [CompressionKeyMax - CompressionKeyMin + 1] ;

    //  make sure both allocations succeeded
    if (m_pSLIPFrame            == NULL ||
        m_pAllocatedKeys        == NULL) {

        hr = E_OUTOFMEMORY ;
        goto error ;
    }

    //
    //  we now initialize all data structures
    //

    //  first initialize the compression keys and queues; only the free
    //  queue is populated, obviously; this loop initializes the compression
    //  key values in the streams; it will not be touched again, only the
    //  destination ip/port will be updated
    for (i = 0; i <= CompressionKeyMax - CompressionKeyMin; i++) {
        m_pAllocatedKeys [i].Key = CompressionKeyMin + i ;
        m_FreeQueue.InsertHead (& m_pAllocatedKeys [i]) ;
    }

    //  now initialize our static IP/UDP header fields which will not change
    //  for the lifetime of our object.

    //  field values which will never change for the lifetime of this object:
    //      1. IP:  Version
    //      2. IP:  HeaderLength
    //      3. IP:  TypeOfService
    //      4. IP:  Offset
    //      5. IP:  Flags
    //      6. IP:  Protocol
    //      7. IP:  SourceIP
    //      8. UDP: SourcePort
    //      9. UDP: Checksum

    ZeroMemory (& m_StaticIPHeader, sizeof m_StaticIPHeader) ;
    m_StaticIPHeader.Version        = 4 ;
    m_StaticIPHeader.HeaderLength   = 5 ;       //  20 bytes
    m_StaticIPHeader.TypeOfService  = 0 ;
    m_StaticIPHeader.Offset         = 0 ;       //  fragmentation is not supported here
    m_StaticIPHeader.Flags          = 0 ;       //  fragmentation is not supported here
    m_StaticIPHeader.Protocol       = IPPROTO_UDP ;
    m_StaticIPHeader.SourceIP       = htonl (SourceIP) ;

    ZeroMemory (& m_StaticUDPHeader, sizeof m_StaticUDPHeader) ;
    m_StaticUDPHeader.SourcePort    = htons (SourcePort) ;
    m_StaticUDPHeader.Checksum      = 0 ;

    //  our compression schema never changes either
    m_Header.IpVbiHeader.CompressedHeader.Common.Schema = SCHEMA_IPVBI_IETF_PROPOSAL ;

    //  success
    return S_OK ;

    error :

    DELETE_RESET (m_pAllocatedKeys) ;
    DELETE_RESET (m_pSLIPFrame) ;

    //  failure
    return hr ;
}

HRESULT
CIPVBI::Encode (
    IN  BYTE *  pUDPPayload,
    IN  INT     iUDPPayloadLength,
    IN  ULONG   DestinationIP,
    IN  USHORT  DestinationPort,
    IN  INT     TTL,
    IN  BOOL    fCompressionEnabled,
    OUT BYTE ** ppSLIPFrame,
    OUT INT *   piSLIPFrameLength
    )
/*++

    Routine Description:

        This routine encodes a UDP payload by performing the following steps:

            1. prepend UDP header
            2. prepend IP header
            3. compresses the header per the IP-VBI specification
            4. SLIP encodes the resulting frame

    Parameters:

        pUDPPayload         UDP payload to be encoded

        iUDPPayloadLength   UDP payload length

        DestinationIP       destination IP (for IP header)

        DestinationPort     destination Port (for UDP header)

        TTL                 TTL (for IP header); not decremented during this 
                            call

        fCompressionEnabled 

        ppSLIPFrame         returned SLIP frame; valid only until this method 
                            is called again

        piSLIPFrameLength   returned SLIP frame length

    Return Values:

        S_OK            success

        error code      failure; ppSLIPFrame and piSLIPFrameLength are
                        undefined in this case

--*/
{
    IP_HEADER *     pIPHeader ;
    UDP_HEADER *    pUDPHeader ;

    assert (VALID_MULTICAST_IP (DestinationIP)) ;
    assert (iUDPPayloadLength <= m_UDPPayloadMaxLength) ;
    assert ((iUDPPayloadLength & 0xffff0000) == 0) ;
    assert ((TTL & 0xffffff00) == 0) ;

    pIPHeader = & IPVBI_IP_HEADER (m_Header) ;
    pUDPHeader = & IPVBI_UDP_HEADER (m_Header) ;

    //
    //  set the IP header fields
    //

    //  increment and set the ID
    m_StaticIPHeader.Identification = (WORD) InterlockedIncrement (& g_IPidentification) ;
    m_StaticIPHeader.Identification = htons (m_StaticIPHeader.Identification) ;

    //  copy in our static header
    memcpy (pIPHeader, & m_StaticIPHeader,  sizeof IP_HEADER) ;

    //
    //  set this particular datagram's fields
    //

    pIPHeader -> DestinationIP      = htonl (DestinationIP) ;

    pIPHeader -> DatagramLength     = iUDPPayloadLength + sizeof IP_HEADER + sizeof UDP_HEADER ;
    pIPHeader -> DatagramLength     = htons (pIPHeader -> DatagramLength) ;

    pIPHeader -> TimeToLive         = (BYTE) TTL ;

    pIPHeader -> Checksum           = ComputeInternetChecksum ((BYTE *) pIPHeader, pIPHeader -> HeaderLength * 4) ;
    pIPHeader -> Checksum           = htons (pIPHeader -> Checksum) ;

    //
    //  set the UDP header fields
    //

    //  copy in our static header
    memcpy (pUDPHeader, & m_StaticUDPHeader, sizeof UDP_HEADER) ;

    //  and set this datagram's fields

    pUDPHeader -> DestinationPort   = htons (DestinationPort) ;

    pUDPHeader -> UDPLength         = (unsigned short) (iUDPPayloadLength + sizeof UDP_HEADER) ;  // Win64 cast (JB 2/15/00)
    pUDPHeader -> UDPLength         = htons (pUDPHeader -> UDPLength) ;

    //  compress
    GenerateHeaderFields_ (fCompressionEnabled) ;

    //  encode
    * piSLIPFrameLength = SLIPEncode_ (pUDPPayload, iUDPPayloadLength) ;
    * ppSLIPFrame = m_pSLIPFrame ;

    return S_OK ;
}

void
CIPVBI::GenerateHeaderFields_ (
    IN  BOOL    fCompressionEnabled
    )
/*++
    
    Routine Description:

        Possibly compresses a header per the IP-VBI specification.

        The header may not be compressed for various reasons:
            1. first time we see a packet for this address
            2. nth packet on this stream, which we transmit uncompressed
                so the client can cache it
            3. etc...

    Parameters:

        fCompressionEnabled     true/false value; if true, we check the
                                compression key cycle; if false, we never
                                compress

    Return Value:

        none

--*/
{
    IP_HEADER *             pIPHeader ;
    UDP_HEADER *            pUDPHeader ;
    IP_VBI_STREAM_NODE *    pNode ;
    WORD                    IP_id ;
    WORD                    UDP_crc ;

    pIPHeader = & IPVBI_IP_HEADER (m_Header) ;
    pUDPHeader = & IPVBI_UDP_HEADER (m_Header) ;

    //  find a key for this IP/port
    pNode = FindKey_ (pIPHeader, pUDPHeader) ;

    //  if none was found, get a new key; this may mean recycling the most
    //  stale from the busy queue, or grabbing one from the free queue (if
    //  there are NODEs left)
    if (pNode == NULL) {
        pNode = GetNewKey_ (pIPHeader, pUDPHeader) ;
    }

    assert (pNode) ;

    //  this flag is passed in by the caller; if compression is enabled, and the
    //  compression count has not passed our threshold, we compress, otherwise
    //  we don't
    if (fCompressionEnabled) {
        //  only compress if we're within the compression count cycle
        COMPRESSION_BIT (m_Header) = pNode -> CompressionCount++ < m_CompressionCountCycle ;
    }
    else {
        COMPRESSION_BIT (m_Header) = 0 ;
    }

    //  compressed ?
    if (COMPRESSION_BIT (m_Header)) {
        //
        //  yes
        //

        //  set the IP identifier; UDP crc values
        IP_id = pIPHeader -> Identification ;
        UDP_crc = pUDPHeader -> Checksum ;

        m_Header.IpVbiHeader.CompressedHeader.IP_id     = IP_id ;
        m_Header.IpVbiHeader.CompressedHeader.UDP_crc   = UDP_crc ;

        //  update this value so we know how many bytes to SLIP encode
        m_Header.HeaderLength = sizeof COMPRESSED_HEADER ;

        //  set the compression key
        m_Header.IpVbiHeader.CompressedHeader.Common.CompressionKey = pNode -> Key ;
    }
    else {
        //
        //  no
        //

        //  the full IP/UDP headers are there already

        //  reset the compression count
        pNode -> CompressionCount = 0 ;
    
        //  update this value so we know how many bytes to SLIP encode
        m_Header.HeaderLength = sizeof UNCOMPRESSED_HEADER ;

        //  set the compression key
        m_Header.IpVbiHeader.UncompressedHeader.Common.CompressionKey = pNode -> Key ;
    }
}

IP_VBI_STREAM_NODE *
CIPVBI::FindKey_ (
    IN  IP_HEADER *     pIPHeader,
    IN  UDP_HEADER *    pUDPHeader
    )
/*++
    
    Routine Description:

        this routine performs a binary search on the m_ppStreamList dense
        array of active streams.

    Parameters:

        pIPHeader       IP header
        pUDPHeader      UDP header

    Return Values:

--*/
{
    IP_VBI_KEY          FindKey ;
    DWORD               Start ;
    DWORD               End ;
    DWORD               Current ;
    int                 ret ;

    assert (pIPHeader) ;
    assert (pUDPHeader) ;

    //  set the fields in our findkey
    FindKey.DestinationIP   = ntohl (pIPHeader -> DestinationIP) ;
    FindKey.DestinationPort = ntohs (pUDPHeader -> DestinationPort) ;

    //  if we have at least 1 live stream
    if (m_StreamListLength > 0) {

        //
        //  perform a binary search
        //

        Start = 0 ;
        End = m_StreamListLength ;

        for (;;) {
            Current = (End + Start) / 2 ;

            if (Current >= End) {
                break ;
            }

            assert (m_ppStreamList [Current]) ;
            ret = IP_VBI_KEY::Compare (& m_ppStreamList [Current] -> NodeValue, & FindKey) ;

            if (ret == 0) {
                return m_ppStreamList [Current] ;
            }
            else if (ret > 0) {
                End = Current ;
            }
            else {
                Start = Current + 1 ;
            }
        }
    }

    return NULL ;
}

IP_VBI_STREAM_NODE *
CIPVBI::GetNewKey_ (
    IN  IP_HEADER *     pIPHeader,
    IN  UDP_HEADER *    pUDPHeader
    )
/*++
    
    Routine Description:

        This routine is called if a stream does not exist which is associated
        with the passed IP/UDP headers.

        If the free queue is empty, we extract a stream from that, otherwise
        we remove the most stale from the busy list.  We measure "staleness"
        by time-of-insertion i.e. it might be possible for a stream to be very
        active, but still end up at the tail of the queue.  This type of
        activity should settle down however with the busiest streams ending
        up towards the front of the queue.

    Parameters:

        pIPHeader       IP header pointer
        pUDPHeader      UDP header pointer

    Return Values:

        stream NODE

--*/
{
    IP_VBI_STREAM_NODE *    pNode ;

    assert (pIPHeader) ;
    assert (pUDPHeader) ;

    pNode = NULL ;

    //  
    //  obtain a new key; we get this either from the free queue if not all
    //  streams are consumed, or from the tail of the busy queue, if all
    //  are maxed out, stream wise
    //

    if (m_FreeQueue.IsListEmpty () == FALSE) {

        //  remove from the free queue tail
        pNode = m_FreeQueue.RemoveTail () ;

        //  and insert into array of pointers to live stream keys
        m_ppStreamList [m_StreamListLength++] = pNode ;

        //
        //  note that once the free queue is emptied, it never again will have
        //  any nodes in it.  This happens because the busy queue contains all
        //  in-used streams.  Everything migrates free -> busy, and once free
        //  is empty, busy -> busy.
        //
    }
    else {
        //  remove from the busy queue tail
        pNode = m_BusyQueue.RemoveTail () ;

        //  no need to insert into array of pointers to live stream keys 
        //  because it already is in the array; we will now change the
        //  key values, and resort the array
    }

    assert (pNode) ;

    pNode -> NodeValue.DestinationIP   = ntohl (pIPHeader -> DestinationIP) ;
    pNode -> NodeValue.DestinationPort = ntohs (pUDPHeader -> DestinationPort) ;

    //  artificially set this high so the first packet in the stream goes
    //  out uncompressed
    pNode -> CompressionCount = m_CompressionCountCycle + 1 ;

    //  insert the node into the busy list head
    m_BusyQueue.InsertHead (pNode) ;

    //  sort the list
    SortStreamList_ () ;

    return pNode ;
}

void
CIPVBI::SLIPAddEscByte_ (
    IN  BYTE    b
    )
/*++
    
    Routine Description:

        this routine updates the CRC value, and SLIP-encodes the byte

    Parameters:

        b   byte value to be SLIP encoded

    Return Values:

        none

--*/
{
    m_MpegCrc.Update (& b, 1) ;

    switch (b) {
        case SLIP_END :
            SLIPAddRawByte_ (SLIP_ESC) ;
            SLIPAddRawByte_ (SLIP_ESC_END) ;
            break ;

        case SLIP_ESC :
            SLIPAddRawByte_ (SLIP_ESC) ;
            SLIPAddRawByte_ (SLIP_ESC_ESC) ;
            break ;

        default :
            SLIPAddRawByte_ (b) ;
            break ;
    } ;
}

void
CIPVBI::SLIPAddRawByte_ (
    IN  BYTE    b
    )
/*++
    
    Routine Description:

        This routine writes the passed byte to the SLIP frame without SLIP 
        encoding; this occurs for the framing bytes (c0), and all bytes
        in between which are SLIP encoded already.

    Parameters:

        b   byte to add

    Return Values:

        none

--*/
{
    * m_pbSLIPFrameCurrent++ = b ;
}

int
CIPVBI::SLIPEncode_ (
    IN  BYTE *  pUDPPayload,
    IN  INT     iUDPPayloadLength
    )
/*++
    
    Routine Description:

        This routine SLIP encodes the UDP payload that is passed; it first
        will SLIP encode the IP-VBI header (m_Header), and thus assumes that
        the compression has already been done.

    Parameters:

        pUDPPayload         UDP payload byte array
        iUDPPayloadLength   length of UDP payload

    Return Values:

        length of SLIP frame, including framing bytes (c0)

--*/
{
    int     i ;
    union   crc {
        DWORD   val ;
        BYTE    byte [4] ;
    } crc ;

    assert (m_pSLIPFrame) ;

    //  initialize
    m_pbSLIPFrameCurrent = m_pSLIPFrame ;
    m_MpegCrc.Reset () ;

    //  frame begin
    SLIPAddRawByte_ (SLIP_END) ;

    //  IP-VBI header (schema, compression key/bit, compressed/uncompressed 
    //  ip/udp headers)
    for (i = 0; i < m_Header.HeaderLength; i++) {
        SLIPAddEscByte_ (m_Header.IpVbiHeader.byte [i]) ;
    }

    //  UDP payload
    for (i = 0; i < iUDPPayloadLength; i++) {
        SLIPAddEscByte_ (pUDPPayload [i]) ;
    }
    
    //  compute the final CRC
    crc.val = m_MpegCrc.CRC () ;
    crc.val = htonl (crc.val) ;

    //  and include it in the payload
    SLIPAddEscByte_ (crc.byte [0]) ;
    SLIPAddEscByte_ (crc.byte [1]) ;
    SLIPAddEscByte_ (crc.byte [2]) ;
    SLIPAddEscByte_ (crc.byte [3]) ;

    //  frame end
    SLIPAddRawByte_ (SLIP_END) ;

    assert (m_pbSLIPFrameCurrent - m_pSLIPFrame <= m_SLIPFrameMaxLength) ;

    return (int)(m_pbSLIPFrameCurrent - m_pSLIPFrame);		// Win64 cast (JB 2/15/00)
}

void
CIPVBI::SortStreamList_ (
    )
/*++
    
    Routine Description:

        This routine sorts m_ppStreamList using crt qsort.  It is called after
        a new key is appended to m_ppStreamList.

    Parameters:

        none

    Return Values:

        none

--*/
{
    assert (m_StreamListLength > 0) ;
    qsort (& m_ppStreamList, m_StreamListLength, sizeof (IP_VBI_STREAM_NODE *), QSortCompareKey) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\ipvbi.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        session.cpp

    Abstract:

        This module implements the IP/UDP header generation, IP-VBI 
        compression, and SLIP encoding.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        15-Apr-1999     created

--*/

#ifndef _atvefsnd__ipvbi_h
#define _atvefsnd__ipvbi_h

#include "mpegcrc.h"
#include <WinSock2.h>

#define SCHEMA_IPVBI_IETF_PROPOSAL          0
#define COMPRESSION_KEY_MIN                 0x00
#define COMPRESSION_KEY_MAX                 0x7f

//  arbitrary value; this results in 1 non-compressed, 4 compressed,
//  1 non-compressed, etc...
#define DEFAULT_COMPRESSION_COUNT_CYCLE     4

//  SLIP esc characters
//
//  transmission of a SLIP frame:
//  first:  SLIP_END
//  SLIP_END -> SLIP_ESC SLIP_ESC_END
//  SLIP_ESC -> SLIP_ESC SLIP_ESC_ESC
//  last:   SLIP_END
//  
#define SLIP_END                0xC0
#define SLIP_ESC                0xDB
#define SLIP_ESC_END            0xDC
#define SLIP_ESC_ESC            0xDD

#pragma pack (push)

//  we want all the following structs to be packed in on byte boundaries.
#pragma pack (1)

//  IP header
//  bitfields allocated in reverse because MSVC allocates in little-endian
typedef 
struct {
    BYTE    HeaderLength    : 4,
            Version         : 4 ;
    BYTE    TypeOfService ;
    WORD    DatagramLength ;
    WORD    Identification ;
    WORD    Offset  : 13,
            Flags   : 3 ;
    BYTE    TimeToLive ;
    BYTE    Protocol ;
    WORD    Checksum ;
    DWORD   SourceIP ;
    DWORD   DestinationIP ;
} IP_HEADER ;

//  UDP header
typedef 
struct {
    WORD    SourcePort ;
    WORD    DestinationPort ;
    WORD    UDPLength ;
    WORD    Checksum ;
} UDP_HEADER ;

//  IP-VBI common; excludes the compressed/non-compressed IP/UDP headers
//  bitfields allocated in reverse because MSVC allocates in little-endian
typedef
struct {
    BYTE    Schema ;
    BYTE    CompressionKey : 7,
            CompressionBit : 1 ;
} IP_VBI_COMMON ;

//  uncompressed header
typedef
struct {
    IP_VBI_COMMON   Common ;
    IP_HEADER       IpHeader ;
    UDP_HEADER      UdpHeader ;
} UNCOMPRESSED_HEADER ;

//  compressed header
typedef
struct {
    IP_VBI_COMMON   Common ;
    WORD            IP_id ;
    WORD            UDP_crc ;
} COMPRESSED_HEADER ;

//  union - compressed & uncompressed map to byte array which will be
//  SLIP encoded
typedef
union {
    BYTE                byte [sizeof UNCOMPRESSED_HEADER] ;
    UNCOMPRESSED_HEADER UncompressedHeader ;
    COMPRESSED_HEADER   CompressedHeader ;
} IP_VBI_HEADER ;

//  restore packing
#pragma pack (pop)

//  everything will be referenced via this 
typedef
struct {
    IP_VBI_HEADER   IpVbiHeader ;
    INT             HeaderLength ;
} IPVBI_HEADER_REF ;

//  header field macros
#define IPVBI_IP_HEADER(r)      ((r).IpVbiHeader.UncompressedHeader.IpHeader)
#define IPVBI_UDP_HEADER(r)     ((r).IpVbiHeader.UncompressedHeader.UdpHeader)
#define COMPRESSION_BIT(r)      ((r).IpVbiHeader.UncompressedHeader.Common.CompressionBit)

//  this data structure is used as a "stream" key for the IP-VBI compression
//  i.e. the 2nd byte in the stream.  Since all transmissions originate from
//  this host, only the destination ip/port are used to compute a "value"
//  for a compression key when used for searches and in sorting the streams.
typedef 
struct 
IP_VBI_KEY {
    ULONG           DestinationIP ;     //  host order
    USHORT          DestinationPort ;   //  host order

    IP_VBI_KEY (
        ULONG   DestIP = 0,
        USHORT  DestPort = 0
        ) : DestinationIP (DestIP),
            DestinationPort (DestPort) {}

    static
    int
    Compare (
        IP_VBI_KEY *    pKey1,
        IP_VBI_KEY *    pKey2
        )
    /*++
        Return Values:

            -1      pKey1 < pKey2
            1       pKey1 > pKey2
            0       pKey1 = pKey2
    --*/
    {
        assert (pKey1) ;
        assert (pKey2) ;

        if (pKey1 -> DestinationIP < pKey2 -> DestinationIP) return -1 ;
        if (pKey1 -> DestinationIP > pKey2 -> DestinationIP) return 1 ;
        if (pKey1 -> DestinationPort < pKey2 -> DestinationPort) return -1 ;
        if (pKey1 -> DestinationPort > pKey2 -> DestinationPort) return 1 ;
        return 0 ;
    }

} IP_VBI_KEY ;

//  this data structure is the NODE for a particular stream when referenced
//  by various functions;  the NODE consists of (1) pointers to/from the
//  adjacent NODEs, (2) a key value, which is the actual value written into
//  2nd byte of the pre-SLIP encoded frame, (3) a node value, which is used
//  for searching, sorting, etc...
typedef 
struct 
IP_VBI_STREAM_NODE {
    BYTE                    Key ;
    IP_VBI_KEY              NodeValue ;     //  used for comparison purposes
    IP_VBI_STREAM_NODE *    flink ;
    IP_VBI_STREAM_NODE *    blink ;
    DWORD                   CompressionCount ;

    IP_VBI_STREAM_NODE (
        )
    {
        flink = blink = this ;
    }

} IP_VBI_STREAM_NODE ;

//  simple queue class used to store stream NODEs; we will have 2 queues:
//  (1) a free queue, containing unused streams, (2) a busy queue, containing
//  streams which are in use; the queue contains 1 dummy node
class CKeyQueue
{
    IP_VBI_STREAM_NODE *    m_pHead ;
    IP_VBI_STREAM_NODE *    m_pTail ;

    public :

        CKeyQueue (
            ) : m_pHead (NULL),
                m_pTail (NULL)
        {
        }

        ~CKeyQueue (
            )
        {
            delete m_pHead ;
        }

        BOOL
        IsListEmpty (
            )
        {
            return m_pHead == m_pTail ;
        }

        HRESULT
        Initialize (
            )
        {
            DELETE_RESET (m_pHead) ;

            m_pHead = new IP_VBI_STREAM_NODE () ;
            if (m_pHead == NULL) {
                return E_OUTOFMEMORY ;
            }

            return NO_ERROR ;
        }

        void
        InsertHead (
            IP_VBI_STREAM_NODE *    pNew
            )
        {
            assert (pNew) ;
            assert (m_pHead) ;

            pNew -> flink = m_pHead -> flink ;
            pNew -> blink = m_pHead ;

            m_pHead -> flink -> blink = pNew ;
            m_pHead -> flink = pNew ;

            m_pTail = m_pHead -> blink ;
        }

        IP_VBI_STREAM_NODE *
        RemoveTail (
            )
        {
            IP_VBI_STREAM_NODE *    pKey ;

            pKey = NULL ;

            if (IsListEmpty () == FALSE) {
                pKey = m_pTail ;
                m_pTail -> flink -> blink = m_pTail -> blink ;
                m_pTail -> blink -> flink = m_pTail -> flink ;

                m_pTail = m_pTail -> blink ;

                pKey -> flink = pKey -> blink = pKey ;

                assert (m_pTail = m_pHead -> blink) ;
            }

            return pKey ;
        }
} ;

/*++

    This class is the primary class used to generate streams which are 
    compliant with the IP-VBI proposal.

    In general, a UDP payload is presented to this class for encoding.
    The class returns a SLIP frame (a pointer to a byte array), with a
    length.  The SLIP frame is valid only until the ::Encode method is
    called again.  This is a valid constraint since the CEnhancementSession
    child that is using this class, serializes all transmissions i.e.
    the process of transmitting a UDP payload is serialized for
    announcements, packages and triggers - no case can occur in which
    a SLIP encoded buffer is not transmitted before the session call
    returns.

    To encode a payload, this class performs the following steps:

    1. generate the IP/UDP headers
    2. find a stream; this is a new stream if there is no existing
        stream associated with the destination IP/port, or an existing
        stream if there's already one there
    3. generate the header IP-VBI fields; this may/may not compress
        them, depending on various parameters, transmission history,
        etc...
    4. SLIP encode the IP-VBI header, and the UDP payload
    5. return a pointer to the SLIP frame, with length

--*/
class CIPVBI
{
    CKeyQueue               m_FreeQueue ;                   //  streams which are not in use
    CKeyQueue               m_BusyQueue ;                   //  streams which are in use
    INT                     m_UDPPayloadMaxLength ;         //  set when the object is initialized; 
                                                            //  used to compute the max SLIP frame length
    INT                     m_SLIPFrameMaxLength ;          //  max SLIP frame length; used to allocate a buffer
    BYTE *                  m_pSLIPFrame ;                  //  SLIP frame byte pointer
    BYTE *                  m_pbSLIPFrameCurrent ;          //  pointer to the next open SLIP frame slot
    IP_VBI_STREAM_NODE *    m_pAllocatedKeys ;              //  allocated keys (array)
    IP_VBI_STREAM_NODE *    m_ppStreamList [COMPRESSION_KEY_MAX - COMPRESSION_KEY_MIN + 1] ;    //  dense array; sorted
    DWORD                   m_StreamListLength ;            //  length of m_ppStreamList
public:
	IP_HEADER               m_StaticIPHeader ;              //  static IP header; includes fields which do not change
    UDP_HEADER              m_StaticUDPHeader ;             //  static UDP header; includes fields which do not change
private:
    IPVBI_HEADER_REF        m_Header ;                      //  IP-VBI header; will be SLIP encoded
    DWORD                   m_CompressionCountCycle ;       //  # compressed / uncompressed cycle rate; default is 4
    MPEGCRC                 m_MpegCrc ;                     //  MPEG2 CRC (slow version); replace with a table-driven
                                                            //  model if > VBI speeds become a factor

    void
    GenerateHeaderFields_ (
        IN  BOOL    fCompressionEnabled
        ) ;

    IP_VBI_STREAM_NODE *
    FindKey_ (
        IN  IP_HEADER *     pIPHeader,
        IN  UDP_HEADER *    pUDPHeader
        ) ;

    IP_VBI_STREAM_NODE *
    GetNewKey_ (
        IN  IP_HEADER *     pIPHeader,
        IN  UDP_HEADER *    pUDPHeader
        ) ;

    int
    SLIPEncode_ (
        IN  BYTE *  pUDPPayload,
        IN  INT     iUDPPayloadLength
        ) ;

    void
    SLIPAddEscByte_ (
        IN  BYTE    b
        ) ;

    void
    SLIPAddRawByte_ (
        IN  BYTE    b
        ) ;

    void
    SortStreamList_ (
        ) ;

    public :

        CIPVBI () ;
        ~CIPVBI () ;

        HRESULT
        Initialize (
            IN  ULONG   SourceIP,                                               //  host order
            IN  USHORT  SourcePort,                                             //  host order
            IN  BYTE    CompressionKeyLow,
            IN  BYTE    CompressionKeyHigh,
            IN  DWORD   CompressedUncompressedRatio,
            IN  SHORT   MaxUDPPayloadLength = ETHERNET_MTU_UDP_PAYLOAD_SIZE
            ) ;

        HRESULT
        Encode (
            IN  BYTE *  pUDPPayload,
            IN  INT     iUDPPayloadLength,
            IN  ULONG   DestinationIP,          //  host order
            IN  USHORT  DestinationPort,        //  host order
            IN  INT     TTL,
            IN  BOOL    fCompressionEnabled,
            OUT BYTE ** ppSLIPFrame,
            OUT INT *   piSLIPFrameLength
            ) ;
} ;

#endif  //  _atvefsnd__ipvbi_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\gzmime.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        gzmime.h

    Abstract:

        This module 

    Author:

        Chris Kauffman  (ChrisK)

    Revision History:


--*/

//#include "queue.h"

#ifndef _atvef__pack_h
#define _atvef__pack_h

#define CGzipMIMEComPack_IN_BUFFER_DEFAULT 80000
#define CGzipMIMEComPack_OUT_BUFFER_DEFAULT 80000
#define CGzipMIMEComPack_SEMAPHORE_NAME "CGzipMIMEComPack_SEMAPHORE"
#define	MIME_BOUNDRY_SIZE 70

#define PACKAGE_LENGTH_HEADER ("Content-Length: ")
#define PACKAGE_LENGTH_PLACEHOLDER ("xxxxxxxxxxxxxxxx")
#define PACKAGE_CRLF ("\r\n")
#define PACKAGE_TYPE_HEADER ("Content-Type: multipart/related; boundary=")		// PBUG - removed the opening quote (add in code)
#define PACKAGE_PREAMBLE ("Created with Microsoft AtvefSend")
#define PACKAGE_DASH_DASH ("--")
#define PACKAGE_CONTENT_LOCATION ("Content-Location: ")
#define PACKAGE_CONTENT_TYPE ("Content-Type: ")
#define PACKAGE_CONTENT_LANGUAGE ("Content-Language: ")
#define PACKAGE_CONTENT_ENCODING ("Content-Encoding: ")
#define PACKAGE_CONTENT_DATE ("Date: ")
#define PACKAGE_CONTENT_EXPIRES ("Expires: ")
#define PACKAGE_CONTENT_LAST_MODIFIED ("Last-Modified: ")

#define DEFINE_HR HRESULT hr = S_OK

#define CTVEDelete(x) if (NULL != x) delete x;
#define RELEASE_LPSTR(x) CTVEDelete(x); x = NULL;

class CTVEContentSource 
{
public:
	CTVEContentSource()
	{
		m_lpstrFilename = NULL;
		m_lpstrSourceLocation = NULL;
		m_lpstrMIMEContentLocation = NULL;
		m_lLang = 0;
		m_lpstrLang = NULL;
		m_dDate = 0;
        m_dPackageExpiresDate = 0 ;
		m_lpstrType = NULL;
		m_lpstrEncoding = NULL;
	}

	~CTVEContentSource()
	{
		CTVEDelete(m_lpstrFilename);
		CTVEDelete(m_lpstrSourceLocation);
		CTVEDelete(m_lpstrMIMEContentLocation);
		CTVEDelete(m_lpstrLang);
		CTVEDelete(m_lpstrType);
		CTVEDelete(m_lpstrEncoding);

		return;
	}


// CTVEContentSource
public:
	HRESULT GetFilename (LPSTR* plpstrFilename);
	HRESULT GetExpiresDate (DATE *pdDate);
	HRESULT GetPackageExpiresDate (DATE *pdDate);
	HRESULT GetEncoding (LPSTR *plpstrEncoding);
	HRESULT SetEncoding (LPSTR lpstrEncoding);
	HRESULT GetLanguage (LPSTR* plpstrLang);
	HRESULT GetType (LPSTR* plpstrType);
	HRESULT GetSourceLocation (LPSTR* plpstrLocation);
	HRESULT SetSourceLocation (LPSTR lpstrLocation);
	HRESULT GetMIMEContentLocation (LPSTR* plpstrMIMEContentLocation);
	HRESULT SetMIMEContentLocation (LPSTR lpstrMIMEContentLocation);
	HRESULT SetFilename (LPSTR lpstrFilename);
	HRESULT SetLang (long langid);
	HRESULT SetLangLPSTR (LPSTR lpstrLang);
	HRESULT SetExpiresDate (DATE * pdDate);
	HRESULT SetPackageExpiresDate (DATE * pdDate);
	HRESULT SetType (LPSTR lpstrType);

private:

	LPSTR   m_lpstrFilename;
	LPSTR   m_lpstrSourceLocation;
	LPSTR   m_lpstrMIMEContentLocation;
	long    m_lLang;
	LPSTR   m_lpstrLang;
	DATE    m_dDate;
	DATE    m_dPackageExpiresDate;
	LPSTR   m_lpstrType;
	LPSTR   m_lpstrEncoding;
};

class CTVEComPack
{
public:
	CTVEComPack()
	{
		m_pInBuffer = NULL;
        m_pOutBuffer = NULL ;

		m_TempFileName[0] = '\0';
		m_hFile = INVALID_HANDLE_VALUE;

		m_dwCurrentPos = NULL;
		m_dwBytesInOutputBuffer = 0;
		m_dwBytesInPackageLength = 0;
		m_dwSizeOfPackage = NULL;

		m_szBoundry[0] = '\0';
	}

	~CTVEComPack()
    {
        if (m_hFile != INVALID_HANDLE_VALUE) {
			USES_CONVERSION;
            CloseHandle (m_hFile) ;
            
            assert (strlen (m_TempFileName)) ;
            DeleteFileA (m_TempFileName) ;
        }

        CTVEDelete(m_pInBuffer) ;
        CTVEDelete(m_pOutBuffer) ;
    }


public:
	HRESULT Init(DATE ExpiresDate);

	HRESULT DoesFileExist(CTVEContentSource *pSource);
	HRESULT WriteStream(CTVEContentSource* pSource, BOOL fCompress);
	HRESULT WriteStreamHeader(CTVEContentSource* pSource, LPCSTR lpszBoundry, LONG* lpSizePlaceHolder);
	HRESULT WriteStringToBuffer(LPCSTR lpszContent);
	HRESULT WriteBSTRToBuffer(BSTR bstr);
	HRESULT WriteToBuffer(LPVOID pvContent, DWORD dwContentSize);
	HRESULT CreateNewTempFile();
	HRESULT CreateNewMIMEBoundry(CHAR *pcBuffer,INT iBufferSize);
	HRESULT WritePackageHeader(CTVEContentSource *pSource, LPCSTR lpszBoundry);
	HRESULT WriteStreamBody(CTVEContentSource *pSource, LPDWORD lpdwSize, BOOL fCompress);
    HRESULT ClearTextToBuffer (CTVEContentSource *pSource, LPDWORD lpdwSize) ;
	HRESULT CompressToBuffer(CTVEContentSource *pSource, LPDWORD lpdwSize);
	HRESULT WriteGZipHeader(LPDWORD lpdwHeaderSize);
	HRESULT WriteStreamSize(DWORD dwSize, LONG lCurrentStreamSizePlaceHolder );
	HRESULT FinishPackage (CHAR * ppTempFilename);

private:

	BYTE*	m_pInBuffer;
	BYTE*	m_pOutBuffer;

	CHAR	m_TempFileName[MAX_PATH+1];
	HANDLE	m_hFile;

	DWORD	m_dwCurrentPos;
	DWORD	m_dwBytesInOutputBuffer;
	DWORD	m_dwBytesInPackageLength;
	DWORD	m_dwSizeOfPackage;

	CHAR	m_szBoundry[MIME_BOUNDRY_SIZE];
    DATE    m_ExpiresDate ;
};

#endif  //  _atvef__pack_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\mgatesdefs.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//---------------------------------------------------------
//  MGatesDefs.h
//
//			Debug definitions - used to be in precomp.h
// --------------------------------------------------------

#ifndef __MGATESDEFS_H__
#define __MGATESDEFS_H__

#define ATVEFSEND_DESCRIPTION           L"ATVEF-compliant transmitter (v2)"

//  ethernet MTU - sizeof IP_header - sizeof UDP_header
//  1500         - 20               - 8                 = 1472
#define ETHERNET_MTU_UDP_PAYLOAD_SIZE             1472

//  these three required because MSBDNAPI does not always convert a WIN32 
//  error to an HRESULT before returning the error; we know that NO_ERROR ==
//  S_OK
#define FAILED_CODE_TO_HRESULT(hr)              (FAILED(hr) ? (hr) : ((hr) = HRESULT_FROM_WIN32(hr)))
#define FAILED_HR(hr)                           ((hr) != S_OK ? FAILED(FAILED_CODE_TO_HRESULT(hr)) : FALSE)
#define SUCCEEDED_HR(hr)                        (!FAILED_HR(hr))

#define DELETE_RESET(p)                         if (p) { delete (p) ; (p) = NULL ; }
#define RESET_SOCKET(s)                         if ((s) != INVALID_SOCKET) { closesocket (s) ; (s) = INVALID_SOCKET ; }
#define RELEASE_AND_CLEAR(p)                    if (p) { (p) -> Release () ; (p) = NULL ; }
#define GOTO_NE(val,comp,label)                 if (val != comp) goto label
#define GOTO_EQ(val,comp,label)                 if (val == comp) goto label
#define GOTO_EQ_SET(val,comp,label,hr,error)    if (val == comp) { hr = error; goto label ; }
#define FAILED_HR_GOTO(val,comp,label)          if (FAILED_HR(hr)) goto label
#define VALID_MULTICAST_IP(ip)                  (((ip) >> 24) >= 0xE0)
#define CLOSE_IF_OPEN(h)                        if ((h) != INVALID_HANDLE_VALUE) { CloseHandle(h);h = INVALID_HANDLE_VALUE;}
#define SETLASTERROR_GOTO_EQ(val,cmp,label)     if ((val) == (cmp)) { SetLastError (val); goto label ; }
#define SETLASTERROR_GOTO_NE(val,cmp,label)     if ((val) != (cmp)) { SetLastError (val); goto label ; }
#define IN_BOUNDS(v,min,max)                    ((min) <= (v) && (v) <= (max))

//#define LOCK_HELD(l)                            ((l).RecursionCount > 0)
#define LOCK_HELD(l)                            TRUE

#define IS_HRESULT(hr)                          ((hr) != S_OK ? FAILED(hr) : TRUE)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\mpegcrc.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        mpegcrc.h

    Abstract:

        This module 

    Author:

        Lee Acton       (leeac)

    Revision History:


--*/

#ifndef __MPEGCRC_H__
#define __MPEGCRC_H__

// generator polynomial: 0000 0100 1100 0001 0001 1101 1011 0111
const ULONG kCRCPolynomial = 0x04c11db7;

class MPEGCRC
{
public:
    MPEGCRC()
        {
        m_crc = 0xFFFFFFFF;
        }
    
    ULONG CRC()
        {
        return m_crc;
        }

    void Reset()
        {
        m_crc = 0xFFFFFFFF;
        }

    ULONG Update(BYTE *pb, int cb)
        {

        while (cb--)
            m_crc = crc_32(m_crc, *pb++);

        return m_crc;
        }

    ULONG crc_32(ULONG crc, BYTE b)
        {
        ULONG mask = 0x80;

        while (mask)
            {
            if (!(crc & 0x80000000) ^ !(b & mask))
                {
                crc = crc << 1;
                crc = crc ^ kCRCPolynomial;
                }
            else
                crc = crc << 1;
            
            mask = mask >> 1;
            }
        
        return crc;
        }

protected:
    ULONG m_crc;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\msbdnapi_i.c ===
/* Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved. */
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Apr 29 19:03:59 1999
 */
/* Compiler settings for ..\idl\msbdnapi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IBdnHostLocator = {0x88edcc66,0xaa64,0x11d1,{0x91,0x51,0x00,0xa0,0xc9,0x25,0x5d,0x05}};


const IID IID_IBdnApplication = {0xb027fd2e,0xaa64,0x11d1,{0x91,0x51,0x00,0xa0,0xc9,0x25,0x5d,0x05}};


const IID IID_IBdnAddressReserve = {0xbe4e359c,0xa21f,0x11d1,{0x91,0x4a,0x00,0xa0,0xc9,0x25,0x5d,0x05}};


const IID IID_IBdnRouter = {0x602c99f6,0xaa64,0x11d1,{0x91,0x51,0x00,0xa0,0xc9,0x25,0x5d,0x05}};


const IID IID_IBdnTunnel = {0x3f947340,0xaa65,0x11d1,{0x91,0x51,0x00,0xa0,0xc9,0x25,0x5d,0x05}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\msbdnapi.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Apr 07 12:12:04 1999
 */
/* Compiler settings for ..\idl\msbdnapi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msbdnapi_h__
#define __msbdnapi_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IBdnHostLocator_FWD_DEFINED__
#define __IBdnHostLocator_FWD_DEFINED__
typedef interface IBdnHostLocator IBdnHostLocator;
#endif 	/* __IBdnHostLocator_FWD_DEFINED__ */


#ifndef __IBdnApplication_FWD_DEFINED__
#define __IBdnApplication_FWD_DEFINED__
typedef interface IBdnApplication IBdnApplication;
#endif 	/* __IBdnApplication_FWD_DEFINED__ */


#ifndef __IBdnAddressReserve_FWD_DEFINED__
#define __IBdnAddressReserve_FWD_DEFINED__
typedef interface IBdnAddressReserve IBdnAddressReserve;
#endif 	/* __IBdnAddressReserve_FWD_DEFINED__ */


#ifndef __IBdnRouter_FWD_DEFINED__
#define __IBdnRouter_FWD_DEFINED__
typedef interface IBdnRouter IBdnRouter;
#endif 	/* __IBdnRouter_FWD_DEFINED__ */


#ifndef __IBdnTunnel_FWD_DEFINED__
#define __IBdnTunnel_FWD_DEFINED__
typedef interface IBdnTunnel IBdnTunnel;
#endif 	/* __IBdnTunnel_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_msbdnapi_0000 */
/* [local] */ 

typedef DWORD BDN_IP_ADDRESS;

typedef struct  BDN_ARS_LEASE
    {
    BDN_IP_ADDRESS Address;
    DWORD LeaseID;
    FILETIME TimeStart;
    FILETIME TimeEnd;
    }	BDN_ARS_LEASE;

typedef 
enum BDN_RESV_POLICY
    {	BDN_RESV_POLICY_REGULATED_GUARANTEED	= 0,
	BDN_RESV_POLICY_REGULATED_OPPORTUNISTIC	= BDN_RESV_POLICY_REGULATED_GUARANTEED + 1,
	BDN_RESV_POLICY_GUARANTEED	= BDN_RESV_POLICY_REGULATED_OPPORTUNISTIC + 1
    }	BDN_RESV_POLICY;

typedef struct  BDN_ROUTE
    {
    BDN_IP_ADDRESS Address;
    DWORD VifID;
    DWORD ReservationID;
    }	BDN_ROUTE;

typedef struct  BDN_VIF
    {
    LPOLESTR DisplayName;
    DWORD VifID;
    }	BDN_VIF;

typedef struct  BDN_RESV
    {
    DWORD ReservationID;
    DWORD VifID;
    BDN_RESV_POLICY Policy;
    DWORD BitRate;
    FILETIME TimeBegin;
    FILETIME TimeEnd;
    }	BDN_RESV;


enum __MIDL___MIDL_itf_msbdnapi_0000_0001
    {	BDN_ROUTE_ALL	= 0,
	BDN_ROUTE_VIF	= BDN_ROUTE_ALL + 1,
	BDN_ROUTE_RESV	= BDN_ROUTE_VIF + 1,
	BDN_ROUTE_IP_ADDRESS	= BDN_ROUTE_RESV + 1
    };


extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0000_v0_0_s_ifspec;

#ifndef __IBdnHostLocator_INTERFACE_DEFINED__
#define __IBdnHostLocator_INTERFACE_DEFINED__

/* interface IBdnHostLocator */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IBdnHostLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88edcc66-aa64-11d1-9151-00a0c9255d05")
    IBdnHostLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetServer( 
            /* [in] */ LPCOLESTR __MIDL_0000) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServer( 
            /* [out] */ LPOLESTR __RPC_FAR *__MIDL_0001) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindServer( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBdnHostLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBdnHostLocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBdnHostLocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBdnHostLocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetServer )( 
            IBdnHostLocator __RPC_FAR * This,
            /* [in] */ LPCOLESTR __MIDL_0000);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServer )( 
            IBdnHostLocator __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *__MIDL_0001);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindServer )( 
            IBdnHostLocator __RPC_FAR * This);
        
        END_INTERFACE
    } IBdnHostLocatorVtbl;

    interface IBdnHostLocator
    {
        CONST_VTBL struct IBdnHostLocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBdnHostLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBdnHostLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBdnHostLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBdnHostLocator_SetServer(This,__MIDL_0000)	\
    (This)->lpVtbl -> SetServer(This,__MIDL_0000)

#define IBdnHostLocator_GetServer(This,__MIDL_0001)	\
    (This)->lpVtbl -> GetServer(This,__MIDL_0001)

#define IBdnHostLocator_FindServer(This)	\
    (This)->lpVtbl -> FindServer(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBdnHostLocator_SetServer_Proxy( 
    IBdnHostLocator __RPC_FAR * This,
    /* [in] */ LPCOLESTR __MIDL_0000);


void __RPC_STUB IBdnHostLocator_SetServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnHostLocator_GetServer_Proxy( 
    IBdnHostLocator __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *__MIDL_0001);


void __RPC_STUB IBdnHostLocator_GetServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnHostLocator_FindServer_Proxy( 
    IBdnHostLocator __RPC_FAR * This);


void __RPC_STUB IBdnHostLocator_FindServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBdnHostLocator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msbdnapi_0009 */
/* [local] */ 

#define	IMPLEMENT_IBDNHOSTLOCATOR() public: \
	STDMETHODIMP	SetServer	(LPCOLESTR); \
	STDMETHODIMP	GetServer	(LPOLESTR *); \
	STDMETHODIMP	FindServer	(void);


extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0009_v0_0_s_ifspec;

#ifndef __IBdnApplication_INTERFACE_DEFINED__
#define __IBdnApplication_INTERFACE_DEFINED__

/* interface IBdnApplication */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IBdnApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b027fd2e-aa64-11d1-9151-00a0c9255d05")
    IBdnApplication : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetApplicationID( 
            /* [in] */ const GUID __RPC_FAR *__MIDL_0002) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationID( 
            /* [out] */ GUID __RPC_FAR *__MIDL_0003) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StoreDescription( 
            /* [in] */ LPCOLESTR __MIDL_0004) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteDescription( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBdnApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBdnApplication __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBdnApplication __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBdnApplication __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetApplicationID )( 
            IBdnApplication __RPC_FAR * This,
            /* [in] */ const GUID __RPC_FAR *__MIDL_0002);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetApplicationID )( 
            IBdnApplication __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *__MIDL_0003);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StoreDescription )( 
            IBdnApplication __RPC_FAR * This,
            /* [in] */ LPCOLESTR __MIDL_0004);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteDescription )( 
            IBdnApplication __RPC_FAR * This);
        
        END_INTERFACE
    } IBdnApplicationVtbl;

    interface IBdnApplication
    {
        CONST_VTBL struct IBdnApplicationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBdnApplication_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBdnApplication_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBdnApplication_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBdnApplication_SetApplicationID(This,__MIDL_0002)	\
    (This)->lpVtbl -> SetApplicationID(This,__MIDL_0002)

#define IBdnApplication_GetApplicationID(This,__MIDL_0003)	\
    (This)->lpVtbl -> GetApplicationID(This,__MIDL_0003)

#define IBdnApplication_StoreDescription(This,__MIDL_0004)	\
    (This)->lpVtbl -> StoreDescription(This,__MIDL_0004)

#define IBdnApplication_DeleteDescription(This)	\
    (This)->lpVtbl -> DeleteDescription(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBdnApplication_SetApplicationID_Proxy( 
    IBdnApplication __RPC_FAR * This,
    /* [in] */ const GUID __RPC_FAR *__MIDL_0002);


void __RPC_STUB IBdnApplication_SetApplicationID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnApplication_GetApplicationID_Proxy( 
    IBdnApplication __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *__MIDL_0003);


void __RPC_STUB IBdnApplication_GetApplicationID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnApplication_StoreDescription_Proxy( 
    IBdnApplication __RPC_FAR * This,
    /* [in] */ LPCOLESTR __MIDL_0004);


void __RPC_STUB IBdnApplication_StoreDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnApplication_DeleteDescription_Proxy( 
    IBdnApplication __RPC_FAR * This);


void __RPC_STUB IBdnApplication_DeleteDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBdnApplication_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msbdnapi_0010 */
/* [local] */ 

#define	IMPLEMENT_IBDNAPPLICATION() public: \
	STDMETHODIMP	SetApplicationID	(const GUID *); \
	STDMETHODIMP	GetApplicationID	(GUID *); \
	STDMETHODIMP	StoreDescription	(LPCOLESTR); \
	STDMETHODIMP	DeleteDescription	(void);


extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0010_v0_0_s_ifspec;

#ifndef __IBdnAddressReserve_INTERFACE_DEFINED__
#define __IBdnAddressReserve_INTERFACE_DEFINED__

/* interface IBdnAddressReserve */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IBdnAddressReserve;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("be4e359c-a21f-11d1-914a-00a0c9255d05")
    IBdnAddressReserve : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeleteAllLeases( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumLeases( 
            /* [out] */ DWORD __RPC_FAR *count,
            /* [size_is][size_is][out] */ BDN_ARS_LEASE __RPC_FAR *__RPC_FAR *array) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteLease( 
            /* [in] */ DWORD lease_id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryLease( 
            /* [in] */ DWORD lease_id,
            /* [out] */ BDN_ARS_LEASE __RPC_FAR *lease) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestLease( 
            /* [out][in] */ BDN_ARS_LEASE __RPC_FAR *lease) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBdnAddressReserveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBdnAddressReserve __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBdnAddressReserve __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBdnAddressReserve __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllLeases )( 
            IBdnAddressReserve __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumLeases )( 
            IBdnAddressReserve __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *count,
            /* [size_is][size_is][out] */ BDN_ARS_LEASE __RPC_FAR *__RPC_FAR *array);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteLease )( 
            IBdnAddressReserve __RPC_FAR * This,
            /* [in] */ DWORD lease_id);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryLease )( 
            IBdnAddressReserve __RPC_FAR * This,
            /* [in] */ DWORD lease_id,
            /* [out] */ BDN_ARS_LEASE __RPC_FAR *lease);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestLease )( 
            IBdnAddressReserve __RPC_FAR * This,
            /* [out][in] */ BDN_ARS_LEASE __RPC_FAR *lease);
        
        END_INTERFACE
    } IBdnAddressReserveVtbl;

    interface IBdnAddressReserve
    {
        CONST_VTBL struct IBdnAddressReserveVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBdnAddressReserve_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBdnAddressReserve_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBdnAddressReserve_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBdnAddressReserve_DeleteAllLeases(This)	\
    (This)->lpVtbl -> DeleteAllLeases(This)

#define IBdnAddressReserve_EnumLeases(This,count,array)	\
    (This)->lpVtbl -> EnumLeases(This,count,array)

#define IBdnAddressReserve_DeleteLease(This,lease_id)	\
    (This)->lpVtbl -> DeleteLease(This,lease_id)

#define IBdnAddressReserve_QueryLease(This,lease_id,lease)	\
    (This)->lpVtbl -> QueryLease(This,lease_id,lease)

#define IBdnAddressReserve_RequestLease(This,lease)	\
    (This)->lpVtbl -> RequestLease(This,lease)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBdnAddressReserve_DeleteAllLeases_Proxy( 
    IBdnAddressReserve __RPC_FAR * This);


void __RPC_STUB IBdnAddressReserve_DeleteAllLeases_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnAddressReserve_EnumLeases_Proxy( 
    IBdnAddressReserve __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *count,
    /* [size_is][size_is][out] */ BDN_ARS_LEASE __RPC_FAR *__RPC_FAR *array);


void __RPC_STUB IBdnAddressReserve_EnumLeases_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnAddressReserve_DeleteLease_Proxy( 
    IBdnAddressReserve __RPC_FAR * This,
    /* [in] */ DWORD lease_id);


void __RPC_STUB IBdnAddressReserve_DeleteLease_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnAddressReserve_QueryLease_Proxy( 
    IBdnAddressReserve __RPC_FAR * This,
    /* [in] */ DWORD lease_id,
    /* [out] */ BDN_ARS_LEASE __RPC_FAR *lease);


void __RPC_STUB IBdnAddressReserve_QueryLease_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnAddressReserve_RequestLease_Proxy( 
    IBdnAddressReserve __RPC_FAR * This,
    /* [out][in] */ BDN_ARS_LEASE __RPC_FAR *lease);


void __RPC_STUB IBdnAddressReserve_RequestLease_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBdnAddressReserve_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msbdnapi_0011 */
/* [local] */ 

#define	IMPLEMENT_IBDNADDRESSRESERVE() public: \
	STDMETHODIMP	DeleteAllLeases		(void); \
	STDMETHODIMP	EnumLeases			(DWORD *, BDN_ARS_LEASE **); \
	STDMETHODIMP	DeleteLease			(DWORD); \
	STDMETHODIMP	QueryLease			(DWORD, BDN_ARS_LEASE *); \
	STDMETHODIMP	RequestLease		(BDN_ARS_LEASE *);


extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0011_v0_0_s_ifspec;

#ifndef __IBdnRouter_INTERFACE_DEFINED__
#define __IBdnRouter_INTERFACE_DEFINED__

/* interface IBdnRouter */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IBdnRouter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("602c99f6-aa64-11d1-9151-00a0c9255d05")
    IBdnRouter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumVif( 
            /* [out] */ DWORD __RPC_FAR *array_count,
            /* [size_is][size_is][out] */ BDN_VIF __RPC_FAR *__RPC_FAR *array) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryVif( 
            /* [in] */ DWORD vif_id,
            /* [out] */ BDN_VIF __RPC_FAR *vif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryVifByDisplayName( 
            /* [in] */ LPCWSTR display_name,
            /* [out] */ DWORD __RPC_FAR *vif_id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRoute( 
            /* [in] */ BDN_ROUTE __RPC_FAR *route) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteRoute( 
            /* [in] */ BDN_ROUTE __RPC_FAR *route) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRoute( 
            /* [in] */ DWORD flags,
            /* [in] */ BDN_IP_ADDRESS ip_address,
            /* [in] */ DWORD vif_id,
            /* [in] */ DWORD resv_id,
            /* [out] */ DWORD __RPC_FAR *array_count,
            /* [size_is][size_is][out] */ BDN_ROUTE __RPC_FAR *__RPC_FAR *array) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteRouteAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteResvAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateResv( 
            /* [in] */ BDN_RESV __RPC_FAR *__MIDL_0005,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0006) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteResv( 
            /* [in] */ DWORD resv_id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryResv( 
            /* [in] */ DWORD resv_id,
            /* [out] */ BDN_RESV __RPC_FAR *__MIDL_0007) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumResv( 
            /* [out] */ DWORD __RPC_FAR *count,
            /* [size_is][size_is][out] */ BDN_RESV __RPC_FAR *__RPC_FAR *__MIDL_0008) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBdnRouterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBdnRouter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBdnRouter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBdnRouter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumVif )( 
            IBdnRouter __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *array_count,
            /* [size_is][size_is][out] */ BDN_VIF __RPC_FAR *__RPC_FAR *array);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryVif )( 
            IBdnRouter __RPC_FAR * This,
            /* [in] */ DWORD vif_id,
            /* [out] */ BDN_VIF __RPC_FAR *vif);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryVifByDisplayName )( 
            IBdnRouter __RPC_FAR * This,
            /* [in] */ LPCWSTR display_name,
            /* [out] */ DWORD __RPC_FAR *vif_id);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateRoute )( 
            IBdnRouter __RPC_FAR * This,
            /* [in] */ BDN_ROUTE __RPC_FAR *route);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteRoute )( 
            IBdnRouter __RPC_FAR * This,
            /* [in] */ BDN_ROUTE __RPC_FAR *route);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRoute )( 
            IBdnRouter __RPC_FAR * This,
            /* [in] */ DWORD flags,
            /* [in] */ BDN_IP_ADDRESS ip_address,
            /* [in] */ DWORD vif_id,
            /* [in] */ DWORD resv_id,
            /* [out] */ DWORD __RPC_FAR *array_count,
            /* [size_is][size_is][out] */ BDN_ROUTE __RPC_FAR *__RPC_FAR *array);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteRouteAll )( 
            IBdnRouter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteResvAll )( 
            IBdnRouter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateResv )( 
            IBdnRouter __RPC_FAR * This,
            /* [in] */ BDN_RESV __RPC_FAR *__MIDL_0005,
            /* [out] */ DWORD __RPC_FAR *__MIDL_0006);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteResv )( 
            IBdnRouter __RPC_FAR * This,
            /* [in] */ DWORD resv_id);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResv )( 
            IBdnRouter __RPC_FAR * This,
            /* [in] */ DWORD resv_id,
            /* [out] */ BDN_RESV __RPC_FAR *__MIDL_0007);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumResv )( 
            IBdnRouter __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *count,
            /* [size_is][size_is][out] */ BDN_RESV __RPC_FAR *__RPC_FAR *__MIDL_0008);
        
        END_INTERFACE
    } IBdnRouterVtbl;

    interface IBdnRouter
    {
        CONST_VTBL struct IBdnRouterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBdnRouter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBdnRouter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBdnRouter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBdnRouter_EnumVif(This,array_count,array)	\
    (This)->lpVtbl -> EnumVif(This,array_count,array)

#define IBdnRouter_QueryVif(This,vif_id,vif)	\
    (This)->lpVtbl -> QueryVif(This,vif_id,vif)

#define IBdnRouter_QueryVifByDisplayName(This,display_name,vif_id)	\
    (This)->lpVtbl -> QueryVifByDisplayName(This,display_name,vif_id)

#define IBdnRouter_CreateRoute(This,route)	\
    (This)->lpVtbl -> CreateRoute(This,route)

#define IBdnRouter_DeleteRoute(This,route)	\
    (This)->lpVtbl -> DeleteRoute(This,route)

#define IBdnRouter_EnumRoute(This,flags,ip_address,vif_id,resv_id,array_count,array)	\
    (This)->lpVtbl -> EnumRoute(This,flags,ip_address,vif_id,resv_id,array_count,array)

#define IBdnRouter_DeleteRouteAll(This)	\
    (This)->lpVtbl -> DeleteRouteAll(This)

#define IBdnRouter_DeleteResvAll(This)	\
    (This)->lpVtbl -> DeleteResvAll(This)

#define IBdnRouter_CreateResv(This,__MIDL_0005,__MIDL_0006)	\
    (This)->lpVtbl -> CreateResv(This,__MIDL_0005,__MIDL_0006)

#define IBdnRouter_DeleteResv(This,resv_id)	\
    (This)->lpVtbl -> DeleteResv(This,resv_id)

#define IBdnRouter_QueryResv(This,resv_id,__MIDL_0007)	\
    (This)->lpVtbl -> QueryResv(This,resv_id,__MIDL_0007)

#define IBdnRouter_EnumResv(This,count,__MIDL_0008)	\
    (This)->lpVtbl -> EnumResv(This,count,__MIDL_0008)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBdnRouter_EnumVif_Proxy( 
    IBdnRouter __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *array_count,
    /* [size_is][size_is][out] */ BDN_VIF __RPC_FAR *__RPC_FAR *array);


void __RPC_STUB IBdnRouter_EnumVif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnRouter_QueryVif_Proxy( 
    IBdnRouter __RPC_FAR * This,
    /* [in] */ DWORD vif_id,
    /* [out] */ BDN_VIF __RPC_FAR *vif);


void __RPC_STUB IBdnRouter_QueryVif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnRouter_QueryVifByDisplayName_Proxy( 
    IBdnRouter __RPC_FAR * This,
    /* [in] */ LPCWSTR display_name,
    /* [out] */ DWORD __RPC_FAR *vif_id);


void __RPC_STUB IBdnRouter_QueryVifByDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnRouter_CreateRoute_Proxy( 
    IBdnRouter __RPC_FAR * This,
    /* [in] */ BDN_ROUTE __RPC_FAR *route);


void __RPC_STUB IBdnRouter_CreateRoute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnRouter_DeleteRoute_Proxy( 
    IBdnRouter __RPC_FAR * This,
    /* [in] */ BDN_ROUTE __RPC_FAR *route);


void __RPC_STUB IBdnRouter_DeleteRoute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnRouter_EnumRoute_Proxy( 
    IBdnRouter __RPC_FAR * This,
    /* [in] */ DWORD flags,
    /* [in] */ BDN_IP_ADDRESS ip_address,
    /* [in] */ DWORD vif_id,
    /* [in] */ DWORD resv_id,
    /* [out] */ DWORD __RPC_FAR *array_count,
    /* [size_is][size_is][out] */ BDN_ROUTE __RPC_FAR *__RPC_FAR *array);


void __RPC_STUB IBdnRouter_EnumRoute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnRouter_DeleteRouteAll_Proxy( 
    IBdnRouter __RPC_FAR * This);


void __RPC_STUB IBdnRouter_DeleteRouteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnRouter_DeleteResvAll_Proxy( 
    IBdnRouter __RPC_FAR * This);


void __RPC_STUB IBdnRouter_DeleteResvAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnRouter_CreateResv_Proxy( 
    IBdnRouter __RPC_FAR * This,
    /* [in] */ BDN_RESV __RPC_FAR *__MIDL_0005,
    /* [out] */ DWORD __RPC_FAR *__MIDL_0006);


void __RPC_STUB IBdnRouter_CreateResv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnRouter_DeleteResv_Proxy( 
    IBdnRouter __RPC_FAR * This,
    /* [in] */ DWORD resv_id);


void __RPC_STUB IBdnRouter_DeleteResv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnRouter_QueryResv_Proxy( 
    IBdnRouter __RPC_FAR * This,
    /* [in] */ DWORD resv_id,
    /* [out] */ BDN_RESV __RPC_FAR *__MIDL_0007);


void __RPC_STUB IBdnRouter_QueryResv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnRouter_EnumResv_Proxy( 
    IBdnRouter __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *count,
    /* [size_is][size_is][out] */ BDN_RESV __RPC_FAR *__RPC_FAR *__MIDL_0008);


void __RPC_STUB IBdnRouter_EnumResv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBdnRouter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msbdnapi_0012 */
/* [local] */ 

#define	IMPLEMENT_IBDNROUTER() public: \
	STDMETHODIMP	EnumVif			(DWORD *, BDN_VIF **); \
	STDMETHODIMP	QueryVif		(DWORD, BDN_VIF *); \
	STDMETHODIMP	QueryVifByDisplayName	(LPCWSTR, DWORD *); \
	STDMETHODIMP	CreateRoute		(BDN_ROUTE *); \
	STDMETHODIMP	DeleteRoute		(BDN_ROUTE *); \
	STDMETHODIMP	EnumRoute		(DWORD, BDN_IP_ADDRESS, DWORD, DWORD, DWORD *, BDN_ROUTE **); \
	STDMETHODIMP	CreateResv		(BDN_RESV *, DWORD *);\
	STDMETHODIMP	DeleteResv		(DWORD); \
	STDMETHODIMP	QueryResv		(DWORD, BDN_RESV *); \
	STDMETHODIMP	EnumResv		(DWORD *, BDN_RESV **); \
	STDMETHODIMP	DeleteRouteAll	(void); \
	STDMETHODIMP	DeleteResvAll	(void);
typedef 
enum BDN_TUNNEL_MESSAGE_TYPE
    {	BDN_TUNNEL_MESSAGE_UDP_PAYLOAD	= 0
    }	BDN_TUNNEL_MESSAGE_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0012_v0_0_s_ifspec;

#ifndef __IBdnTunnel_INTERFACE_DEFINED__
#define __IBdnTunnel_INTERFACE_DEFINED__

/* interface IBdnTunnel */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IBdnTunnel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3f947340-aa65-11d1-9151-00a0c9255d05")
    IBdnTunnel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocalAddress( 
            DWORD __MIDL_0009) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Send( 
            const BYTE __RPC_FAR *data,
            DWORD len,
            BDN_TUNNEL_MESSAGE_TYPE __MIDL_0010) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDestinationAddress( 
            DWORD ip_address,
            WORD udp_port) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDestinationAddress( 
            DWORD __RPC_FAR *ip_address,
            WORD __RPC_FAR *udp_port) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBdnTunnelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBdnTunnel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBdnTunnel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBdnTunnel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IBdnTunnel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IBdnTunnel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLocalAddress )( 
            IBdnTunnel __RPC_FAR * This,
            DWORD __MIDL_0009);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Send )( 
            IBdnTunnel __RPC_FAR * This,
            const BYTE __RPC_FAR *data,
            DWORD len,
            BDN_TUNNEL_MESSAGE_TYPE __MIDL_0010);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDestinationAddress )( 
            IBdnTunnel __RPC_FAR * This,
            DWORD ip_address,
            WORD udp_port);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDestinationAddress )( 
            IBdnTunnel __RPC_FAR * This,
            DWORD __RPC_FAR *ip_address,
            WORD __RPC_FAR *udp_port);
        
        END_INTERFACE
    } IBdnTunnelVtbl;

    interface IBdnTunnel
    {
        CONST_VTBL struct IBdnTunnelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBdnTunnel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBdnTunnel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBdnTunnel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBdnTunnel_Connect(This)	\
    (This)->lpVtbl -> Connect(This)

#define IBdnTunnel_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define IBdnTunnel_SetLocalAddress(This,__MIDL_0009)	\
    (This)->lpVtbl -> SetLocalAddress(This,__MIDL_0009)

#define IBdnTunnel_Send(This,data,len,__MIDL_0010)	\
    (This)->lpVtbl -> Send(This,data,len,__MIDL_0010)

#define IBdnTunnel_SetDestinationAddress(This,ip_address,udp_port)	\
    (This)->lpVtbl -> SetDestinationAddress(This,ip_address,udp_port)

#define IBdnTunnel_GetDestinationAddress(This,ip_address,udp_port)	\
    (This)->lpVtbl -> GetDestinationAddress(This,ip_address,udp_port)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBdnTunnel_Connect_Proxy( 
    IBdnTunnel __RPC_FAR * This);


void __RPC_STUB IBdnTunnel_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnTunnel_Disconnect_Proxy( 
    IBdnTunnel __RPC_FAR * This);


void __RPC_STUB IBdnTunnel_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnTunnel_SetLocalAddress_Proxy( 
    IBdnTunnel __RPC_FAR * This,
    DWORD __MIDL_0009);


void __RPC_STUB IBdnTunnel_SetLocalAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnTunnel_Send_Proxy( 
    IBdnTunnel __RPC_FAR * This,
    const BYTE __RPC_FAR *data,
    DWORD len,
    BDN_TUNNEL_MESSAGE_TYPE __MIDL_0010);


void __RPC_STUB IBdnTunnel_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnTunnel_SetDestinationAddress_Proxy( 
    IBdnTunnel __RPC_FAR * This,
    DWORD ip_address,
    WORD udp_port);


void __RPC_STUB IBdnTunnel_SetDestinationAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBdnTunnel_GetDestinationAddress_Proxy( 
    IBdnTunnel __RPC_FAR * This,
    DWORD __RPC_FAR *ip_address,
    WORD __RPC_FAR *udp_port);


void __RPC_STUB IBdnTunnel_GetDestinationAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBdnTunnel_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msbdnapi_0013 */
/* [local] */ 

#define	IMPLEMENT_IBDNTUNNEL() public: \
	STDMETHODIMP	Connect		(void); \
	STDMETHODIMP	Disconnect	(void); \
	STDMETHODIMP	SetLocalAddress	(DWORD); \
	STDMETHODIMP	Send (const BYTE * data, DWORD len, BDN_TUNNEL_MESSAGE_TYPE message_type); \
	STDMETHODIMP	SetDestinationAddress		(DWORD, WORD); \
	STDMETHODIMP	GetDestinationAddress		(DWORD *, WORD *);
// {b46aa12a-ae5c-11d1-9155-00a0c9255d05}
DEFINE_GUID (CLSID_BdnRouter,
0xb46aa12a, 0xae5c, 0x11d1, 0x91, 0x55, 0x00, 0xa0, 0xc9, 0x25, 0x5d, 0x05);
#define TEXT_CLSID_BdnRouter _T("{b46aa12a-ae5c-11d1-9155-00a0c9255d05}")
// {b46aa12b-ae5c-11d1-9155-00a0c9255d05}
DEFINE_GUID (CLSID_BdnAddressReserve,
0xb46aa12b, 0xae5c, 0x11d1, 0x91, 0x55, 0x00, 0xa0, 0xc9, 0x25, 0x5d, 0x05);
#define TEXT_CLSID_BdnAddressReserve _T("{b46aa12b-ae5c-11d1-9155-00a0c9255d05}")
// {48559702-e815-11d1-8fde-00c04fc9da3f}
DEFINE_GUID (CLSID_BdnTunnel,
	0x48559702, 0xe815, 0x11d1, 0x8f, 0xde, 0x00, 0xc0, 0x4f, 0xc9, 0xda, 0x3f);
#define TEXT_CLSID_BdnTunnel _T("{48559702-e815-11d1-8fde-00c04fc9da3f}")


extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msbdnapi_0013_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__FF67761C_608C_47E9_AA2C_E03C29A33EF9__INCLUDED_)
#define AFX_STDAFX_H__FF67761C_608C_47E9_AA2C_E03C29A33EF9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <WinSock2.h>
#include <atlbase.h>  
//#include "MyAtlBase.h"

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <comdef.h>
#include "valid.h"

#include <assert.h>
#include "MGatesDefs.h"		// some of MGates macros...  try to remove if possible

WCHAR * GetTVEError(HRESULT hr, ...);			//  Extended Error Message Handler

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__FF67761C_608C_47E9_AA2C_E03C29A33EF9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tcpconn.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.

#ifndef _atvefsnd__tcpconn_h
#define _atvefsnd__tcpconn_h

#include <winsock2.h>
/*++
    simple synchronous tcp class;
    not thread safe, but we should be protected by CEnhancementSession
--*/
class CTCPConnection
{
    ULONG   m_InserterIP ;      //  host order
    USHORT  m_InserterPort ;    //  host order
    SOCKET  m_hSocket ;
    BOOL    m_fWinsockStartup ;

    public :
        
        CTCPConnection () ;
        ~CTCPConnection () ;

        HRESULT
        Connect (
            IN  ULONG   InserterIP,
            IN  USHORT  InserterPort
            ) ;

        HRESULT
        Connect (
            ) ;

        HRESULT 
        Send (
            IN LPBYTE   pbBuffer,
            IN INT      iLength
            ) ;

        HRESULT
        Disconnect (
            ) ;

        BOOL
        IsConnected (
            ) ;
} ;


#endif  //  _atvefsnd__tcpconn_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ATVEFSend.rc
//
#define IDS_PROJNAME                    100
#define IDR_TVEPACKAGE                  101
#define IDS_INVALIDOBJECT_NOT_INITIALIZED 101
#define IDR_TVEANNOUNCEMENT             102
#define IDS_INVALIDOBJECT_INITIALIZED   102
#define IDR_TVEATTRMAP3                 103
#define IDS_INVALIDPACKAGE_CLOSED       103
#define IDS_INVALIDPACKAGE_CANNOT_BE_CLOSED 104
#define IDS_INVALIDPACKAGE_CANNOT_FETCH_DATAGRAM 105
#define IDS_INVALIDPACKAGE_DOES_NOT_EXIST 106
#define IDS_INVALIDANNOUNCEMENT_IS_NOT_VALID 107
#define IDS_INVALIDOBJECT_NOT_CONNECTED 108
#define IDS_INVALIDPACKAGE_NOT_CLOSED   109
#define IDR_TVEATTRLIST                 110
#define IDR_TVEMULTICASTSESSION         111
#define IDR_TVESTARTSTOPLIST            112
#define IDR_ATVEFINSERTERSESSION        113
#define IDR_ATVEFROUTERSESSION          114
#define IDR_ATVEFLINE21SESSION          115
#define IDR_ATVEFMULTICASTSESSION       116
#define IDR_ATVEFANNOUNCEMENT           117
#define IDR_ATVEFPACKAGE                118
#define IDR_ATVEFATTRMAP                119
#define IDR_ATVEFATTRLIST               120
#define IDR_ATVEFSTARTSTOPLIST          121
#define IDR_ATVEFMEDIA                  122
#define IDR_ATVEFMEDIAS                 123

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           124
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\throttle.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        throttle.h

    Abstract:

		The throttle is supposed to solve two problems
			1) prevent from sending data too fast (limit average speed to BitsPerSecond)
			2) prevent from sending too many tiny packets... (queue stuff up in a bucket until big enough)
		It works inside the packet sending loop of some transmission system, and 
		performs both tasks by simply sleeping a computed amount of time. 

		Most problems with this code stem from the conflicting nature of the above two requirements.


    Author:

        Matthijs Gates  (mgates)

    Revision History:

        02-Apr-1999     created
		01-Nov-1999		renamed, redid, and refreshed... (JB)


  Description:

	Works using concept of a 'leaky' bucket, where amount of bits in the bucket reflects the number
	of bits we can send at any one time.		

	The bucket is filled with bits as time passes, ...
	

--*/

#ifndef __throttle_h
#define __throttle_h

class CThrottle
{
    enum {
        MAX_BUCKET_DEPTH = 1500*5			// initial/max size, don't throttle until empty all these bits
    } ;

    INT     m_Bucket ;
    DWORD   m_BitsPerSecond ;
    DWORD   m_LastUpdateTicks ;

    DWORD  SetCurrTickCount(IN  DWORD   CurrentTicks);

    INT    RemoveBitsFromBucket(IN  INT Size);

    public :
        
        CThrottle (
            DWORD   BitsPerSecond = 0
            ) : m_BitsPerSecond (BitsPerSecond),
                m_Bucket (MAX_BUCKET_DEPTH),
                m_LastUpdateTicks (-1)
        {
        }

        //  blocks until sufficient quota exists in leaky bucket to transmit
        //  payload
        void
        Throttle (IN  INT BitsToSend);

        DWORD
        SetBitRate (IN  DWORD   BitsPerSecond)
        {
            m_BitsPerSecond		= BitsPerSecond ;
            m_Bucket			= MAX_BUCKET_DEPTH ;
            m_LastUpdateTicks	= -1 ;

            return m_BitsPerSecond ;
        }
} ;

#endif  //  __throttle_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\trace.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        trace.h

    Abstract:

        This module contains declarations used for tracing

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        02-Apr-99   created        

--*/

#ifndef __atvefsnd_trace_h
#define __atvefsnd_trace_h

// output device bitmask values
#define OUTPUT_DEVICE_STDOUT    0x00000001
#define OUTPUT_DEVICE_DEBUG     0x00000002
#define OUTPUT_DEVICE_ALL       0xffffffff

// tracing macros

#define ATVEFSND_TRACE_CLASS_FACTORY            0x00000001
#define ATVEFSND_TRACE_THREAD_SYNC              0x00000002
#define ATVEFSND_TRACE_IUNKNOWN                 0x00000004
#define ATVEFSND_TRACE_UHTTP                    0x00000008
#define ATVEFSND_TRACE_CONFIGURATION            0x00000010
#define ATVEFSND_TRACE_ANNOUNCEMENT             0x00000020
#define ATVEFSND_TRACE_TRIGGER                  0x00000040
#define ATVEFSND_TRACE_PACKAGE                  0x00000080
#define ATVEFSND_TRACE_ENTER                    0x00000100
#define ATVEFSND_TRACE_LEAVE                    0x00000200
#define ATVEFSND_TRACE_DLL                      0x00000400

//  tracing macros
#ifdef _DEBUG

#define _TRACE_0(b,sp,field,fmt)                    TracePrintf ## b(ATVEFSND_TRACE_ ## field,sp ## "%08XH: " fmt sp ## "\n", GetCurrentThreadId())
#define _TRACE_1(b,sp,field,fmt,a1)                 TracePrintf ## b(ATVEFSND_TRACE_ ## field,sp ## "%08XH: " fmt sp ## "\n", GetCurrentThreadId(),a1)
#define _TRACE_2(b,sp,field,fmt,a1,a2)              TracePrintf ## b(ATVEFSND_TRACE_ ## field,sp ## "%08XH: " fmt sp ## "\n", GetCurrentThreadId(),a1,a2)
#define _TRACE_3(b,sp,field,fmt,a1,a2,a3)           TracePrintf ## b(ATVEFSND_TRACE_ ## field,sp ## "%08XH: " fmt sp ## "\n", GetCurrentThreadId(),a1,a2,a3)
#define _TRACE_4(b,sp,field,fmt,a1,a2,a3,a4)        TracePrintf ## b(ATVEFSND_TRACE_ ## field,sp ## "%08XH: " fmt sp ## "\n", GetCurrentThreadId(),a1,a2,a3,a4)
#define _TRACE_5(b,sp,field,fmt,a1,a2,a3,a4,a5)     TracePrintf ## b(ATVEFSND_TRACE_ ## field,sp ## "%08XH: " fmt sp ## "\n", GetCurrentThreadId(),a1,a2,a3,a4,a5)
#define _TRACE_6(b,sp,field,fmt,a1,a2,a3,a4,a5,a6)  TracePrintf ## b(ATVEFSND_TRACE_ ## field,sp ## "%08XH: " fmt sp ## "\n", GetCurrentThreadId(),a1,a2,a3,a4,a5,a6)

#else

#define _TRACE_0(b,sp,field,fmt)
#define _TRACE_1(b,sp,field,fmt,a1)
#define _TRACE_2(b,sp,field,fmt,a1,a2)
#define _TRACE_3(b,sp,field,fmt,a1,a2,a3)
#define _TRACE_4(b,sp,field,fmt,a1,a2,a3,a4)
#define _TRACE_5(b,sp,field,fmt,a1,a2,a3,a4,a5)
#define _TRACE_6(b,sp,field,fmt,a1,a2,a3,a4,a5,a6)

#endif  //  _DEBUG

//  critical section macros
#ifdef _DEBUG

#define ENTER_CRITICAL_SECTION(lock,func)                                          \
            TRACEW_2(THREAD_SYNC,L"ENTERING CriticalSection (%s); %s ()",L#lock,L#func) ; \
            EnterCriticalSection(&lock) ;                                 \
            TRACEW_2(THREAD_SYNC,L"HAVE CriticalSection (%s); %s ()",L#lock,L#func) ;

#define LEAVE_CRITICAL_SECTION(lock,func)                                          \
            LeaveCriticalSection(&lock) ;                                 \
            TRACEW_2(THREAD_SYNC,L"LEAVING CriticalSection (%s); %s ()",L#lock,L#func) ;

#else

#define ENTER_CRITICAL_SECTION(lock,func)                                          \
            EnterCriticalSection(&lock) ;                                 \

#define LEAVE_CRITICAL_SECTION(lock,func)                                          \
            LeaveCriticalSection(&lock) ;                                 \

#endif  // __DEBUG

#define _TRACE_OBJ_0(b,sp,field,fmt)                _TRACE_1(b,sp,field, sp ## " this: %08XH; " fmt,this)
#define _TRACE_OBJ_1(b,sp,field,fmt,a1)             _TRACE_2(b,sp,field, sp ## " this: %08XH; " fmt,this,a1)
#define _TRACE_OBJ_2(b,sp,field,fmt,a1,a2)          _TRACE_3(b,sp,field, sp ## " this: %08XH; " fmt,this,a1,a2)
#define _TRACE_OBJ_3(b,sp,field,fmt,a1,a2,a3)       _TRACE_4(b,sp,field, sp ## " this: %08XH; " fmt,this,a1,a2,a3)
#define _TRACE_OBJ_4(b,sp,field,fmt,a1,a2,a3,a4)    _TRACE_5(b,sp,field, sp ## " this: %08XH; " fmt,this,a1,a2,a3,a4)
#define _TRACE_OBJ_5(b,sp,field,fmt,a1,a2,a3,a4,a5) _TRACE_6(b,sp,field, sp ## " this: %08XH; " fmt,this,a1,a2,a3,a4,a5)

#define _ENTER_0(b,sp,fmt)                          _TRACE_0(b,sp,ENTER, sp ## "ENTER: " fmt)
#define _ENTER_1(b,sp,fmt,a1)                       _TRACE_1(b,sp,ENTER, sp ## "ENTER: " fmt,a1)
#define _ENTER_2(b,sp,fmt,a1,a2)                    _TRACE_2(b,sp,ENTER, sp ## "ENTER: " fmt,a1,a2)
#define _ENTER_3(b,sp,fmt,a1,a2,a3)                 _TRACE_3(b,sp,ENTER, sp ## "ENTER: " fmt,a1,a2,a3)
#define _ENTER_4(b,sp,fmt,a1,a2,a3,a4)              _TRACE_4(b,sp,ENTER, sp ## "ENTER: " fmt,a1,a2,a3,a4)
#define _ENTER_5(b,sp,fmt,a1,a2,a3,a4,a5)           _TRACE_5(b,sp,ENTER, sp ## "ENTER: " fmt,a1,a2,a3,a4,a5)
#define _ENTER_6(b,sp,fmt,a1,a2,a3,a4,a5,a6)        _TRACE_6(b,sp,ENTER, sp ## "ENTER: " fmt,a1,a2,a3,a4,a5,a6)

#define _ENTER_OBJ_0(b,sp,fmt)                      _ENTER_1(b,sp, sp ## " this: %08XH; " fmt, this)
#define _ENTER_OBJ_1(b,sp,fmt,a1)                   _ENTER_2(b,sp, sp ## " this: %08XH; " fmt, this,a1)
#define _ENTER_OBJ_2(b,sp,fmt,a1,a2)                _ENTER_3(b,sp, sp ## " this: %08XH; " fmt, this,a1,a2)
#define _ENTER_OBJ_3(b,sp,fmt,a1,a2,a3)             _ENTER_4(b,sp, sp ## " this: %08XH; " fmt, this,a1,a2,a3)
#define _ENTER_OBJ_4(b,sp,fmt,a1,a2,a3,a4)          _ENTER_5(b,sp, sp ## " this: %08XH; " fmt, this,a1,a2,a3,a4)
#define _ENTER_OBJ_5(b,sp,fmt,a1,a2,a3,a4,a5)       _ENTER_6(b,sp, sp ## " this: %08XH; " fmt, this,a1,a2,a3,a4,a5)

#define _LEAVE_0(b,sp,fmt)                          _TRACE_0(b,sp,LEAVE, sp ## "LEAVE: " fmt)
#define _LEAVE_1(b,sp,fmt,a1)                       _TRACE_1(b,sp,LEAVE, sp ## "LEAVE: " fmt,a1)
#define _LEAVE_2(b,sp,fmt,a1,a2)                    _TRACE_2(b,sp,LEAVE, sp ## "LEAVE: " fmt,a1,a2)
#define _LEAVE_3(b,sp,fmt,a1,a2,a3)                 _TRACE_3(b,sp,LEAVE, sp ## "LEAVE: " fmt,a1,a2,a3)
#define _LEAVE_4(b,sp,fmt,a1,a2,a3,a4)              _TRACE_4(b,sp,LEAVE, sp ## "LEAVE: " fmt,a1,a2,a3.a4)

#define _LEAVE_OBJ_0(b,sp,fmt)                      _LEAVE_1(b,sp, sp ## " this: %08XH; " fmt, this)
#define _LEAVE_OBJ_1(b,sp,fmt,a1)                   _LEAVE_2(b,sp, sp ## " this: %08XH; " fmt, this,a1)
#define _LEAVE_OBJ_2(b,sp,fmt,a1,a2)                _LEAVE_3(b,sp, sp ## " this: %08XH; " fmt, this,a1,a2)
#define _LEAVE_OBJ_3(b,sp,fmt,a1,a2,a3)             _LEAVE_4(b,sp, sp ## " this: %08XH; " fmt, this,a1,a2,a3)

//  ANSI
#define TRACEA_0(field,fmt)                         _TRACE_0(A,"",field,fmt)
#define TRACEA_1(field,fmt,a1)                      _TRACE_1(A,"",field,fmt,a1)
#define TRACEA_2(field,fmt,a1,a2)                   _TRACE_2(A,"",field,fmt,a1,a2)
#define TRACEA_3(field,fmt,a1,a2,a3)                _TRACE_3(A,"",field,fmt,a1,a2,a3)
#define TRACEA_4(field,fmt,a1,a2,a3,a4)             _TRACE_4(A,"",field,fmt,a1,a2,a3,a4)

#define TRACEA_OBJ_0(field,fmt)                     _TRACE_OBJ_0(A,"",field,fmt)
#define TRACEA_OBJ_1(field,fmt,a1)                  _TRACE_OBJ_1(A,"",field,fmt,a1)   
#define TRACEA_OBJ_2(field,fmt,a1,a2)               _TRACE_OBJ_2(A,"",field,fmt,a1,a2)
#define TRACEA_OBJ_3(field,fmt,a1,a2,a3)            _TRACE_OBJ_3(A,"",field,fmt,a1,a2,a3)

#define ENTERA_0(fmt)                               _ENTER_0(A,"",fmt)
#define ENTERA_1(fmt,a1)                            _ENTER_1(A,"",fmt,a1)
#define ENTERA_2(fmt,a1,a2)                         _ENTER_2(A,"",fmt,a1,a2)
#define ENTERA_3(fmt,a1,a2,a3)                      _ENTER_3(A,"",fmt,a1,a2,a3)

#define ENTERA_OBJ_0(fmt)                           _ENTER_OBJ_0(A,"",fmt)
#define ENTERA_OBJ_1(fmt,a1)                        _ENTER_OBJ_1(A,"",fmt,a1)
#define ENTERA_OBJ_2(fmt,a1,a2)                     _ENTER_OBJ_2(A,"",fmt,a1,a2)
#define ENTERA_OBJ_3(fmt,a1,a2,a3)                  _ENTER_OBJ_3(A,"",fmt,a1,a2,a3)

#define LEAVEA_0(fmt)                               _LEAVE_0(A,"",fmt)
#define LEAVEA_1(fmt,a1)                            _LEAVE_1(A,"",fmt,a1)
#define LEAVEA_2(fmt,a1,a2)                         _LEAVE_2(A,"",fmt,a1,a2)
#define LEAVEA_3(fmt,a1,a2,a3)                      _LEAVE_3(A,"",fmt,a1,a2,a3)

#define LEAVEA_OBJ_0(fmt)                           _LEAVE_OBJ_0(A,"",fmt)
#define LEAVEA_OBJ_1(fmt,a1)                        _LEAVE_OBJ_1(A,"",fmt,a1)
#define LEAVEA_OBJ_2(fmt,a1,a2)                     _LEAVE_OBJ_2(A,"",fmt,a1,a2)
#define LEAVEA_OBJ_3(fmt,a1,a2,a3)                  _LEAVE_OBJ_3(A,"",fmt,a1,a2,a3)

//  UNICODE / OLECHAR
#define TRACEW_0(field,fmt)                         _TRACE_0(W,L,field,fmt)
#define TRACEW_1(field,fmt,a1)                      _TRACE_1(W,L,field,fmt,a1)
#define TRACEW_2(field,fmt,a1,a2)                   _TRACE_2(W,L,field,fmt,a1,a2)
#define TRACEW_3(field,fmt,a1,a2,a3)                _TRACE_3(W,L,field,fmt,a1,a2,a3)
#define TRACEW_4(field,fmt,a1,a2,a3,a4)             _TRACE_4(W,L,field,fmt,a1,a2,a3,a4)

#define TRACEW_OBJ_0(field,fmt)                     _TRACE_OBJ_0(W,L,field,fmt)
#define TRACEW_OBJ_1(field,fmt,a1)                  _TRACE_OBJ_1(W,L,field,fmt,a1)   
#define TRACEW_OBJ_2(field,fmt,a1,a2)               _TRACE_OBJ_2(W,L,field,fmt,a1,a2)
#define TRACEW_OBJ_3(field,fmt,a1,a2,a3)            _TRACE_OBJ_3(W,L,field,fmt,a1,a2,a3)

#define ENTERW_0(fmt)                               _ENTER_0(W,L,fmt)
#define ENTERW_1(fmt,a1)                            _ENTER_1(W,L,fmt,a1)
#define ENTERW_2(fmt,a1,a2)                         _ENTER_2(W,L,fmt,a1,a2)
#define ENTERW_3(fmt,a1,a2,a3)                      _ENTER_3(W,L,fmt,a1,a2,a3)

#define ENTERW_OBJ_0(fmt)                           _ENTER_OBJ_0(W,L,fmt)
#define ENTERW_OBJ_1(fmt,a1)                        _ENTER_OBJ_1(W,L,fmt,a1)
#define ENTERW_OBJ_2(fmt,a1,a2)                     _ENTER_OBJ_2(W,L,fmt,a1,a2)
#define ENTERW_OBJ_3(fmt,a1,a2,a3)                  _ENTER_OBJ_3(W,L,fmt,a1,a2,a3)
#define ENTERW_OBJ_4(fmt,a1,a2,a3,a4)               _ENTER_OBJ_4(W,L,fmt,a1,a2,a3,a4)
#define ENTERW_OBJ_5(fmt,a1,a2,a3,a4,a5)            _ENTER_OBJ_5(W,L,fmt,a1,a2,a3,a4,a5)

#define LEAVEW_0(fmt)                               _LEAVE_0(W,L,fmt)
#define LEAVEW_1(fmt,a1)                            _LEAVE_1(W,L,fmt,a1)
#define LEAVEW_2(fmt,a1,a2)                         _LEAVE_2(W,L,fmt,a1,a2)
#define LEAVEW_3(fmt,a1,a2,a3)                      _LEAVE_3(W,L,fmt,a1,a2,a3)

#define LEAVEW_OBJ_0(fmt)                           _LEAVE_OBJ_0(W,L,fmt)
#define LEAVEW_OBJ_1(fmt,a1)                        _LEAVE_OBJ_1(W,L,fmt,a1)
#define LEAVEW_OBJ_2(fmt,a1,a2)                     _LEAVE_OBJ_2(W,L,fmt,a1,a2)
#define LEAVEW_OBJ_3(fmt,a1,a2,a3)                  _LEAVE_OBJ_3(W,L,fmt,a1,a2,a3)

void
TracePrintfA (
    DWORD   dwFieldMask,
    CHAR *  szFormat,
    ...
    ) ;

void
TracePrintfW (
    DWORD   dwFieldMask,
    WCHAR * szFormat,
    ...
    ) ;

#endif  // __atvefsnd_trace_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\trace.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        trace.cpp

    Abstract:

        This module 

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        02-Apr-1999     created

--*/

#include "stdafx.h"				// new jb
#include <stdio.h>				// needed in release build
#include "trace.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static DWORD g_dwInformationMask    = -1 ;						// BUGBUG: make configurable
static DWORD g_dwWarningLevel       = 5 ;						// BUGBUG: make configurable
static DWORD g_dwOutputDevice       = OUTPUT_DEVICE_DEBUG;      // BUGBUG: make this configurable
static DWORD g_dwTraceFields        = -1 ;						// BUGBUG: make this configurable

// functions

void
TracePrintfA (
    DWORD   dwFieldMask,
    LPSTR   szFormat,
    ...
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    va_list va ;
    CHAR    buffer [1024] ;

    if (dwFieldMask & g_dwTraceFields) {

        // for now just to console
        va_start (va, szFormat) ;
        vsprintf (buffer, szFormat, va) ;
        va_end (va) ;

        if (g_dwOutputDevice & OUTPUT_DEVICE_DEBUG) {
            OutputDebugStringA (buffer) ;
        }

        if (g_dwOutputDevice & OUTPUT_DEVICE_STDOUT) {
            fprintf (stdout, buffer) ;
        }
    }
}

void
TracePrintfW (
    DWORD   dwFieldMask,
    LPWSTR  szFormat,
    ...
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    va_list va ;
    WCHAR   buffer [1024] ;

    if (dwFieldMask & g_dwTraceFields) {

        // for now just to console
        va_start (va, szFormat) ;
        vswprintf (buffer, szFormat, va) ;
        va_end (va) ;

        if (g_dwOutputDevice & OUTPUT_DEVICE_DEBUG) {
            OutputDebugStringW (buffer) ;
        }

        if (g_dwOutputDevice & OUTPUT_DEVICE_STDOUT) {
            fwprintf (stdout, buffer) ;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tcpconn.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// ----------------------------------------------------------
// tcpconn.cpp
// ----------------------------------------------------------

#include "stdafx.h"
#include "tcpconn.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CTCPConnection::CTCPConnection (
    ) : m_InserterIP (0),
        m_InserterPort (0),
        m_hSocket (INVALID_SOCKET),
        m_fWinsockStartup (FALSE)
{
}

CTCPConnection::~CTCPConnection (
    )
{   
    RESET_SOCKET (m_hSocket) ;

    if (m_fWinsockStartup) {
        WSACleanup () ;
    }
}

BOOL
CTCPConnection::IsConnected (
    )
{
    return m_hSocket != INVALID_SOCKET ;
}

HRESULT
CTCPConnection::Connect (
    IN  ULONG   InserterIP,
    IN  USHORT  InserterPort
    )
{
    int     retval ;
    WSADATA wsadata ;

    if (InserterIP == 0) {
        return E_INVALIDARG ;
    }

    if (m_hSocket != INVALID_SOCKET) {
        return E_UNEXPECTED ;
    }

    if (m_fWinsockStartup == FALSE) {
        retval = WSAStartup (MAKEWORD (2,0), & wsadata) ;
        if (retval != 0) {
            return HRESULT_FROM_WIN32 (retval) ;
        }

        m_fWinsockStartup = TRUE ;
    }

    m_InserterIP = InserterIP ;
    m_InserterPort = InserterPort ;

    return Connect () ;
}

HRESULT
CTCPConnection::Connect ()
{
    SOCKADDR_IN addr = {0} ;
    int         retval ;

    if (m_hSocket != INVALID_SOCKET) {
        return E_UNEXPECTED ;
    }

    //  create the socket
    m_hSocket = WSASocket (AF_INET,
                           SOCK_STREAM,
                           IPPROTO_TCP,
                           NULL,
                           0,
                           NULL) ;
    GOTO_EQ (m_hSocket, INVALID_SOCKET, error) ;

    //  bind it up
    addr.sin_family         = AF_INET ;
    addr.sin_port           = htons (0) ;
    addr.sin_addr.s_addr    = INADDR_ANY ;

    retval = bind (m_hSocket,
                   (SOCKADDR *) & addr,
                   sizeof addr
                   ) ;
    GOTO_EQ (retval, SOCKET_ERROR, error) ;
    
    //  connect it
    addr.sin_family         = AF_INET ;
    addr.sin_port           = htons (m_InserterPort) ;
    addr.sin_addr.s_addr    = htonl (m_InserterIP) ;

    //  this should be a blocking call ..
    retval = connect (m_hSocket, 
                      (SOCKADDR *) & addr, 
                      sizeof addr
                      ) ;
    GOTO_EQ (retval, SOCKET_ERROR, error) ;
    return S_OK ;

error :

    retval = WSAGetLastError () ;
    RESET_SOCKET(m_hSocket) ;

    return HRESULT_FROM_WIN32 (retval) ;
}

HRESULT 
CTCPConnection::Send (
    IN LPBYTE   pbBuffer,
    IN INT      iLength
    )
{
    int     retval ;

    assert (m_hSocket != INVALID_SOCKET) ;

    retval = send (
                m_hSocket,
                (const char *) pbBuffer,
                iLength,
                NULL
                ) ;

    if (retval != iLength) {
        retval = WSAGetLastError () ;
        Disconnect () ;

        return HRESULT_FROM_WIN32 (retval) ;
    }

    return S_OK ;
}

HRESULT
CTCPConnection::Disconnect (
    )
{
    RESET_SOCKET(m_hSocket) ;
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\trees.c ===
/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-1996 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */

/* $Id: trees.c,v 1.11 1996/07/24 13:41:06 me Exp $ */

#include "deflate.h"

#ifdef DEBUG
#  include <ctype.h>
#endif


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/* ===========================================================================
 * Constants
 */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

local int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

local int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

local int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

local uch bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

#define Buf_size (8 * 2*sizeof(char))
/* Number of bits used within bi_buf. (bi_buf might be implemented on
 * more than 16 bits on some systems.)
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

local ct_data static_ltree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

local ct_data static_dtree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

local uch dist_code[512];
/* distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

local uch length_code[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

local int base_length[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

local int base_dist[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

struct static_tree_desc_s {
    ct_data *static_tree;        /* static tree or NULL */
    intf    *extra_bits;         /* extra bits for each code or NULL */
    int     extra_base;          /* base index for extra_bits */
    int     elems;               /* max number of elements in the tree */
    int     max_length;          /* max bit length for the codes */
};

local static_tree_desc  static_l_desc =
{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

local static_tree_desc  static_d_desc =
{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

local static_tree_desc  static_bl_desc =
{(ct_data *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS};

/* ===========================================================================
 * Local (static) routines in this file.
 */

local void tr_static_init OF((void));
local void init_block     OF((deflate_state *s));
local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
local void build_tree     OF((deflate_state *s, tree_desc *desc));
local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local int  build_bl_tree  OF((deflate_state *s));
local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                              int blcodes));
local void compress_block OF((deflate_state *s, ct_data *ltree,
                              ct_data *dtree));
local void set_data_type  OF((deflate_state *s));
local unsigned bi_reverse OF((unsigned value, int length));
local void bi_windup      OF((deflate_state *s));
local void bi_flush       OF((deflate_state *s));
local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
                              int header));

#ifndef DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   /* Send a code of the given tree. c and tree must not have side effects */

#else /* DEBUG */
#  define send_code(s, c, tree) \
     { if (verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif

#define d_code(dist) \
   ((dist) < 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])
/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. dist_code[256] and dist_code[257] are never
 * used.
 */

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
#define put_short(s, w) { \
    put_byte(s, (uch)((w) & 0xff)); \
    put_byte(s, (uch)((ush)(w) >> 8)); \
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
#ifdef DEBUG
local void send_bits      OF((deflate_state *s, int value, int length));

local void send_bits(s, value, length)
    deflate_state *s;
    int value;  /* value to send */
    int length; /* number of bits */
{
    Tracevv((stderr," l %2d v %4x ", length, value));
    Assert(length > 0 && length <= 15, "invalid length");
    s->bits_sent += (ulg)length;

    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if (s->bi_valid > (int)Buf_size - length) {
        s->bi_buf |= (value << s->bi_valid);
        put_short(s, s->bi_buf);
        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
        s->bi_valid += length - Buf_size;
    } else {
        s->bi_buf |= value << s->bi_valid;
        s->bi_valid += length;
    }
}
#else /* !DEBUG */
						// Win64 compile - added (ush) cast in the s->bi_buf = call JB 2/15/00

#define send_bits(s, value, length) \
{ int len = length;\
  if (s->bi_valid > (int)Buf_size - len) {\
    int val = value;\
    s->bi_buf |= (val << s->bi_valid);\
    put_short(s, s->bi_buf);\
    s->bi_buf = (ush) ((ush)val >> (Buf_size - s->bi_valid));\
    s->bi_valid += len - Buf_size;\
  } else {\
    s->bi_buf |= (value) << s->bi_valid;\
    s->bi_valid += len;\
  }\
}
#endif /* DEBUG */


#define MAX(a,b) (a >= b ? a : b)
/* the arguments must not have side effects */

/* ===========================================================================
 * Initialize the various 'constant' tables. In a multi-threaded environment,
 * this function may be called by two threads concurrently, but this is
 * harmless since both invocations do exactly the same thing.
 */
local void tr_static_init()
{
    static int static_init_done = 0;
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */
    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    if (static_init_done) return;

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            length_code[length++] = (uch)code;
        }
    }
    Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    length_code[length-1] = (uch)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            dist_code[dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            dist_code[256 + dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
    n = 0;
    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        static_dtree[n].Len = 5;
        static_dtree[n].Code = (ush) bi_reverse((unsigned)n, 5);
    }
    static_init_done = 1;
}

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
void _tr_init(s)
    deflate_state *s;
{
    tr_static_init();

    s->compressed_len = 0L;

    s->l_desc.dyn_tree = s->dyn_ltree;
    s->l_desc.stat_desc = &static_l_desc;

    s->d_desc.dyn_tree = s->dyn_dtree;
    s->d_desc.stat_desc = &static_d_desc;

    s->bl_desc.dyn_tree = s->bl_tree;
    s->bl_desc.stat_desc = &static_bl_desc;

    s->bi_buf = 0;
    s->bi_valid = 0;
    s->last_eob_len = 8; /* enough lookahead for inflate */
#ifdef DEBUG
    s->bits_sent = 0L;
#endif

    /* Initialize the first block of the first file: */
    init_block(s);
}

/* ===========================================================================
 * Initialize a new block.
 */
local void init_block(s)
    deflate_state *s;
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

    s->dyn_ltree[END_BLOCK].Freq = 1;
    s->opt_len = s->static_len = 0L;
    s->last_lit = s->matches = 0;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top) \
{\
    top = s->heap[SMALLEST]; \
    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth) \
   (tree[n].Freq < tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
local void pqdownheap(s, tree, k)
    deflate_state *s;
    ct_data *tree;  /* the tree to restore */
    int k;               /* node to move down */
{
    int v = s->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= s->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s->heap_len &&
            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s->heap[j], s->depth)) break;

        /* Exchange v with the smallest son */
        s->heap[k] = s->heap[j];  k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    s->heap[k] = v;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
local void gen_bitlen(s, desc)
    deflate_state *s;
    tree_desc *desc;    /* the tree descriptor */
{
    ct_data *tree  = desc->dyn_tree;
    int max_code   = desc->max_code;
    ct_data *stree = desc->stat_desc->static_tree;
    intf *extra    = desc->stat_desc->extra_bits;
    int base       = desc->stat_desc->extra_base;
    int max_length = desc->stat_desc->max_length;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    ush f;              /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        n = s->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (ush)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) continue; /* not a leaf node */

        s->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        s->opt_len += (ulg)f * (bits + xbits);
        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
    }
    if (overflow == 0) return;

    Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (s->bl_count[bits] == 0) bits--;
        s->bl_count[bits]--;      /* move one leaf down the tree */
        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        s->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = s->bl_count[bits];
        while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if (tree[m].Len != (unsigned) bits) {
                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s->opt_len += ((long)bits - (long)tree[m].Len)
                              *(long)tree[m].Freq;
                tree[m].Len = (ush)bits;
            }
            n--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
local void gen_codes (tree, max_code, bl_count)
    ct_data *tree;             /* the tree to decorate */
    int max_code;              /* largest code with non zero frequency */
    ushf *bl_count;            /* number of codes at each bit length */
{
    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
    ush code = 0;              /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = (ush) bi_reverse(next_code[len]++, len);

        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
local void build_tree(s, desc)
    deflate_state *s;
    tree_desc *desc; /* the tree descriptor */
{
    ct_data *tree   = desc->dyn_tree;
    ct_data *stree  = desc->stat_desc->static_tree;
    int elems       = desc->stat_desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s->heap_len = 0, s->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s->heap_len < 2) {
        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
        tree[node].Freq = 1;
        s->depth[node] = 0;
        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        /* node is 0 or 1 so it does not have extra bits */
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
        pqremove(s, tree, n);  /* n = node of least frequency */
        m = s->heap[SMALLEST]; /* m = node of next least frequency */

        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        s->heap[--(s->heap_max)] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = tree[n].Freq + tree[m].Freq;
        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (ush)node;
#ifdef DUMP_BL_TREE
        if (tree == s->bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        s->heap[SMALLEST] = node++;
        pqdownheap(s, tree, SMALLEST);

    } while (s->heap_len >= 2);

    s->heap[--(s->heap_max)] = s->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, (tree_desc *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes ((ct_data *)tree, max_code, s->bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
local void scan_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree;   /* the tree to be scanned */
    int max_code;    /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (ush)0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            s->bl_tree[curlen].Freq += (ush) count;
        } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
        } else {
            s->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
local void send_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree; /* the tree to be scanned */
    int max_code;       /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(s, curlen, s->bl_tree); count--;
            }
            Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

        } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
local int build_bl_tree(s)
    deflate_state *s;
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, (tree_desc *)(&(s->bl_desc)));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    s->opt_len += 3*(max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            s->opt_len, s->static_len));

    return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
local void send_all_trees(s, lcodes, dcodes, blcodes)
    deflate_state *s;
    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
    int rank;                    /* index in bl_order */

    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes-1,   5);
    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Send a stored block
 */
void _tr_stored_block(s, buf, stored_len, eof)
    deflate_state *s;
    charf *buf;       /* input block */
    ulg stored_len;   /* length of input block */
    int eof;          /* true if this is the last block for a file */
{
    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
    s->compressed_len += (stored_len + 4) << 3;

    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 * The current inflate code requires 9 bits of lookahead. If the
 * last two codes for the previous block (real code plus EOB) were coded
 * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
 * the last real code. In this case we send two empty static blocks instead
 * of one. (There are no problems if the previous block is stored or fixed.)
 * To simplify the code, we assume the worst case of last real code encoded
 * on one bit only.
 */
void _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
    bi_flush(s);
    /* Of the 10 bits for the empty block, we have already sent
     * (10 - bi_valid) bits. The lookahead for the last real code (before
     * the EOB of the previous block) was thus at least one plus the length
     * of the EOB plus what we have just sent of the empty static block.
     */
    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
        send_bits(s, STATIC_TREES<<1, 3);
        send_code(s, END_BLOCK, static_ltree);
        s->compressed_len += 10L;
        bi_flush(s);
    }
    s->last_eob_len = 7;
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file. This function
 * returns the total compressed length for the file so far.
 */
ulg _tr_flush_block(s, buf, stored_len, eof)
    deflate_state *s;
    charf *buf;       /* input block, or NULL if too old */
    ulg stored_len;   /* length of input block */
    int eof;          /* true if this is the last block for a file */
{
    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex = 0;  /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s->level > 0) {

	 /* Check if the file is ascii or binary */
	if (s->data_type == Z_UNKNOWN) set_data_type(s);

	/* Construct the literal and distance trees */
	build_tree(s, (tree_desc *)(&(s->l_desc)));
	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));

	build_tree(s, (tree_desc *)(&(s->d_desc)));
	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));
	/* At this point, opt_len and static_len are the total bit lengths of
	 * the compressed block data, excluding the tree representations.
	 */

	/* Build the bit length tree for the above two trees, and get the index
	 * in bl_order of the last bit length code to send.
	 */
	max_blindex = build_bl_tree(s);

	/* Determine the best encoding. Compute first the block length in bytes*/
	opt_lenb = (s->opt_len+3+7)>>3;
	static_lenb = (s->static_len+3+7)>>3;

	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
		s->last_lit));

	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

    } else {
        Assert(buf != (char*)0, "lost buf");
	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

    /* If compression failed and this is the first and last block,
     * and if the .zip file can be seeked (to rewrite the local header),
     * the whole file is transformed into a stored file:
     */
#ifdef STORED_FILE_OK
#  ifdef FORCE_STORED_FILE
    if (eof && s->compressed_len == 0L) { /* force stored file */
#  else
    if (stored_len <= opt_lenb && eof && s->compressed_len==0L && seekable()) {
#  endif
        /* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
        if (buf == (charf*)0) error ("block vanished");

        copy_block(buf, (unsigned)stored_len, 0); /* without header */
        s->compressed_len = stored_len << 3;
        s->method = STORED;
    } else
#endif /* STORED_FILE_OK */

#ifdef FORCE_STORED
    if (buf != (char*)0) { /* force stored block */
#else
    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
                       /* 4: two words for the lengths */
#endif
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, eof);

#ifdef FORCE_STATIC
    } else if (static_lenb >= 0) { /* force static trees */
#else
    } else if (static_lenb == opt_lenb) {
#endif
        send_bits(s, (STATIC_TREES<<1)+eof, 3);
        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
        s->compressed_len += 3 + s->static_len;
    } else {
        send_bits(s, (DYN_TREES<<1)+eof, 3);
        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                       max_blindex+1);
        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
        s->compressed_len += 3 + s->opt_len;
    }
    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    init_block(s);

    if (eof) {
        bi_windup(s);
        s->compressed_len += 7;  /* align on byte boundary */
    }
    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
           s->compressed_len-7*eof));

    return s->compressed_len >> 3;
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int _tr_tally (s, dist, lc)
    deflate_state *s;
    unsigned dist;  /* distance of matched string */
    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
    s->d_buf[s->last_lit] = (ush)dist;
    s->l_buf[s->last_lit++] = (uch)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        s->dyn_ltree[lc].Freq++;
    } else {
        s->matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert((ush)dist < (ush)MAX_DIST(s) &&
               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s->dyn_ltree[length_code[lc]+LITERALS+1].Freq++;
        s->dyn_dtree[d_code(dist)].Freq++;
    }

    /* Try to guess if it is profitable to stop the current block here */
    if (s->level > 2 && (s->last_lit & 0xfff) == 0) {
        /* Compute an upper bound for the compressed length */
        ulg out_length = (ulg)s->last_lit*8L;
        ulg in_length = (ulg)((long)s->strstart - s->block_start);
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                (5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               s->last_lit, in_length, out_length,
               100L - out_length*100L/in_length));
        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
    }
    return (s->last_lit == s->lit_bufsize-1);
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
local void compress_block(s, ltree, dtree)
    deflate_state *s;
    ct_data *ltree; /* literal tree */
    ct_data *dtree; /* distance tree */
{
    unsigned dist;      /* distance of matched string */
    int lc;             /* match length or unmatched char (if dist == 0) */
    unsigned lx = 0;    /* running index in l_buf */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */

    if (s->last_lit != 0) do {
        dist = s->d_buf[lx];
        lc = s->l_buf[lx++];
        if (dist == 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = length_code[lc];
            send_code(s, code+LITERALS+1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra != 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra != 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);   /* send the extra distance bits */
            }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        Assert(s->pending < (int) (s->lit_bufsize + 2*lx), "pendingBuf overflow");

    } while (lx < s->last_lit);

    send_code(s, END_BLOCK, ltree);
    s->last_eob_len = ltree[END_BLOCK].Len;
}

/* ===========================================================================
 * Set the data type to ASCII or BINARY, using a crude approximation:
 * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
 * IN assertion: the fields freq of dyn_ltree are set and the total of all
 * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
 */
local void set_data_type(s)
    deflate_state *s;
{
    int n = 0;
    unsigned ascii_freq = 0;
    unsigned bin_freq = 0;
    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
local unsigned bi_reverse(code, len)
    unsigned code; /* the value to invert */
    int len;       /* its bit length */
{
    register unsigned res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return res >> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
local void bi_flush(s)
    deflate_state *s;
{
    if (s->bi_valid == 16) {
        put_short(s, s->bi_buf);
        s->bi_buf = 0;
        s->bi_valid = 0;
    } else if (s->bi_valid >= 8) {
        put_byte(s, (Byte)s->bi_buf);
        s->bi_buf >>= 8;
        s->bi_valid -= 8;
    }
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
local void bi_windup(s)
    deflate_state *s;
{
    if (s->bi_valid > 8) {
        put_short(s, s->bi_buf);
    } else if (s->bi_valid > 0) {
        put_byte(s, (Byte)s->bi_buf);
    }
    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
local void copy_block(s, buf, len, header)
    deflate_state *s;
    charf    *buf;    /* the input data */
    unsigned len;     /* its length */
    int      header;  /* true if block header must be written */
{
    bi_windup(s);        /* align on byte boundary */
    s->last_eob_len = 8; /* enough lookahead for inflate */

    if (header) {
        put_short(s, (ush)len);   
        put_short(s, (ush)~len);
#ifdef DEBUG
        s->bits_sent += 2*16;
#endif
    }
#ifdef DEBUG
    s->bits_sent += (ulg)len<<3;
#endif
    while (len--) {
        put_byte(s, *buf++);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tveattrl.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEAttrL.cpp : Implementation of CATVEFAttrList
#include "stdafx.h"
#include "ATVEFSend.h"
#include "TVEAttrL.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CATVEFAttrList

STDMETHODIMP CATVEFAttrList::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATVEFAttrList
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tveannc.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEAnnc.cpp : Implementation of CATVEFAnnouncement
#include "stdafx.h"
#include "ATVEFSend.h"
#include "TVEAnnc.h"
#include "ATVEFMsg.h"		// error codes (generated from the .mc file)
#include "TVEPack.h"
#include "TVESupport.h"

#include "cSdpSrc.h"
#include "trace.h"
#include "..\common\address.h"		// trigger CRC code
#include "..\common\isotime.h"
#include "valid.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
	
#if 1								// if 1, don't always disconnect on set's
#define MAYBE_DISCONNECT	if(0)
#else
#define MAYBE_DISCONNECT
#endif

/////////////////////////////////////////////////////////////////////////////
// CATVEFAnnouncement

GUID    g_NullGUID ;

static HRESULT
ToHRESULT (
    HRESULT hr
    )
{
    return (hr != S_OK ? (FAILED (hr) ? hr : HRESULT_FROM_WIN32 (hr)) : hr) ;
}

static HRESULT 
HrConvertLONGIPToBSTR(ULONG ulIP, BSTR *pbstr)
{
	IN_ADDR  iaddr;
	CComBSTR spbsT;
	if(pbstr == NULL)
		return E_POINTER;

	iaddr.s_addr = htonl(ulIP);
	char	*pcIPString = inet_ntoa(iaddr);		// convert network address as ULONG to a string
	if(pcIPString != NULL)
		spbsT = pcIPString;
	else {
		spbsT = L"<Invalid>";
		return E_INVALIDARG;
	}
	
	*pbstr = spbsT;			// may need a .Transfer() here.

	return S_OK;
}

STDMETHODIMP CATVEFAnnouncement::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATVEFAnnouncement
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

// 		HRESULT MediaCount([out, retval] ULONG* pVal);
//		HRESULT Media([in] int iLoc, [out, retval] IATVEFMedia* *pVal);

STDMETHODIMP 
CATVEFAnnouncement::get_MediaCount (OUT /*retval*/ LONG *pVal)
{
	HRESULT hr;
	ENTER_API {
		ValidateOutPtr( pVal,(LONG) 0);
		Lock_ () ;
		hr = m_csdpSource.get_MediaCount(pVal);
		Unlock_();
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::get_Media(IN LONG iLoc, OUT /*retval*/ IATVEFMedia **ppVal)
{
	HRESULT hr;
	long cMedia;
	ENTER_API {
		ValidateOutPtr( ppVal,(IATVEFMedia *) NULL);
		Lock_ () ;
		hr = m_csdpSource.get_MediaCount(&cMedia);
		if(FAILED(hr))
			return hr;

		if(iLoc == cMedia)					// create a new media object if iLoc is current.
		{
			hr = m_csdpSource.get_NewMedia(ppVal);
		} else { 
			hr = m_csdpSource.get_Media(iLoc, ppVal);
		}
		Unlock_();
	} EXIT_API_(hr);
}

// -------------------------------

// get the iLoc'th start/stop time.  Will return S_FALSE (and zero) if it doesn't exist
STDMETHODIMP CATVEFAnnouncement::GetStartStopTime(int iLoc, DATE *pdateStart, DATE *pdateStop)
{
	HRESULT hr = S_OK;

	ENTER_API {
		ValidateOutPtr( pdateStart,(DATE) 0.0);
		ValidateOutPtr( pdateStop,(DATE) 0.0);

		Lock_ ();
		hr = m_csdpSource.GetStartStopTime(iLoc, pdateStart, pdateStop);
		Unlock_();
		if(S_OK == hr) 
			return S_OK;
		else 
			hr = S_FALSE;
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP CATVEFAnnouncement::AddStartStopTime(DATE dtStart, DATE dtEnd)
{
	HRESULT hr = S_OK;
	ENTER_API {	
		Lock_() ;
		hr =	m_csdpSource.AddStartStopTime(dtStart, dtEnd);
		Unlock_();

		if(FAILED(hr))
			Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	} EXIT_API_(hr);
}


//////////////////////////////////////////////////////////////////////////////////


CATVEFAnnouncement::CATVEFAnnouncement () 
{
    ENTERW_OBJ_0 (L"CATVEFAnnouncement::CATVEFAnnouncement") ;

	m_State			= STATE_UNINITIALIZED;
	m_punkParent	= NULL;
    ZeroMemory (& m_Transmitter, sizeof m_Transmitter) ;	
	m_csdpSource.InitAll();
}

HRESULT 
CATVEFAnnouncement::FinalConstruct()
{	
	InitializeCriticalSection (& m_crt) ;
	HRESULT hr = m_csdpSource.FinalConstruct();			// create maps and things...

	return hr;
}
HRESULT 
CATVEFAnnouncement::FinalRelease()
{
	m_punkParent= NULL;									// not a smart pointer...
	return S_OK;
}

CATVEFAnnouncement::~CATVEFAnnouncement ()
{
    ENTERW_OBJ_0 (L"CATVEFAnnouncement::~CATVEFAnnouncement") ;

    DeleteCriticalSection (& m_crt) ;
}

//  ---------------------------------------------------------------------------
//      I S e n d A T V E F A n n o u n c e m e n t                       BEGIN
//  ---------------------------------------------------------------------------

STDMETHODIMP 
CATVEFAnnouncement::put_SAPSendingIP (
    IN  LONG   IP
    )
{
    HRESULT hr  = S_OK;

 	ENTER_API {	
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.put_SAPSendingIPULONG (IP) ;
		Unlock_ ()  ;
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_SAPSendingIP (
    OUT LONG   *pIP
    )
{
    HRESULT hr ;
	ENTER_API {
		ValidateOutPtr( pIP,(LONG) 0);
		Lock_ () ;
		hr = m_csdpSource.get_SAPSendingIPULONG ((ULONG *) pIP) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}


STDMETHODIMP 
CATVEFAnnouncement::put_SendingIP (
    IN  LONG   IP
    )
{
    HRESULT hr  = S_OK;

 	ENTER_API {	
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.put_SendingIPULONG (IP) ;
		Unlock_ ()  ;
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_SendingIP (
    OUT LONG   *pIP
    )
{
    HRESULT hr ;
	ENTER_API {
		ValidateOutPtr( pIP,(LONG) 0);
		Lock_ () ;
		hr = m_csdpSource.get_SendingIPULONG ((ULONG *) pIP) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}


STDMETHODIMP 
CATVEFAnnouncement::put_UserName (
    IN  BSTR    bstrUserName
    )
{
    HRESULT hr = S_OK ;
 
  	ENTER_API {	   
		if (bstrUserName == NULL ||				// PBUG
			bstrUserName [0] == L'\0') 
		{
			hr = E_INVALIDARG ;
		}
		
		if(!FAILED(hr))
		{
			Lock_ () ;
			MAYBE_DISCONNECT DisconnectLocked_ () ;
			hr = m_csdpSource.put_UserName(bstrUserName) ;
			Unlock_ ()  ;
		}

	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_UserName (
    IN  BSTR    *pbstrUserName
    )
{
    HRESULT hr ;
 	ENTER_API {
		ValidateOutPtr( pbstrUserName,(BSTR) NULL);

		Lock_ () ;
		hr = m_csdpSource.get_UserName(pbstrUserName) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::put_SessionID (
    IN  INT    SessionID
    )
{
    HRESULT hr  = S_OK;

  	ENTER_API {	   
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.put_SessionID (SessionID) ;
		Unlock_ ()  ;
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_SessionID (
    OUT  INT    *pSessionID
    )
{
    HRESULT hr ;

	ENTER_API {
		ValidateOutPtr( pSessionID,(INT) 0);
		Lock_ () ;
		hr = m_csdpSource.get_SessionID ((UINT *) pSessionID) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::put_SessionVersion (
    IN  INT    Version
    )
{
    HRESULT hr  = S_OK;

   	ENTER_API {	 
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.put_SessionVersion (Version) ;
		Unlock_ ()  ;
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_SessionVersion (
    OUT  INT    *pVersion
    )
{
    HRESULT hr ;

	ENTER_API {
		ValidateOutPtr( pVersion,(INT) 0);
		Lock_ () ;
		hr = m_csdpSource.get_SessionVersion ((UINT *) pVersion) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::put_SessionURL (
    IN  BSTR    bstrSessionURL
    )
{
    HRESULT hr  = S_OK;

   	ENTER_API {	   
		if (bstrSessionURL == NULL ||					// PBUG
			bstrSessionURL [0] == L'\0') 
		{
			hr = E_INVALIDARG ;
		}
		
		if(!FAILED(hr)) {
			Lock_ () ;
			MAYBE_DISCONNECT DisconnectLocked_ () ;
			hr = m_csdpSource.put_SessionURL (bstrSessionURL) ;
			Unlock_ ()  ;
		}

	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_SessionURL (
    OUT  BSTR    *pbstrSessionURL
    )
{
    HRESULT hr ;

	ENTER_API {
		ValidateOutPtr( pbstrSessionURL,(BSTR) NULL);
		Lock_ () ;
		hr = m_csdpSource.get_SessionURL (pbstrSessionURL) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::put_SessionName (
    IN  BSTR    bstrSessionName
    )
{
    HRESULT hr  = S_OK;

   	ENTER_API {	  
		if (bstrSessionName == NULL ||						// PBUG
			bstrSessionName [0] == L'\0') 
		{
			return E_INVALIDARG ;
		}

		if(!FAILED(hr))
		{
			Lock_ () ;
			MAYBE_DISCONNECT DisconnectLocked_ () ;
			hr = m_csdpSource.put_SessionName (bstrSessionName) ;
			Unlock_ ();
		}
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_SessionName (
    OUT  BSTR    *pbstrSessionName
    )
{
    HRESULT hr ;

	ENTER_API {
		ValidateOutPtr( pbstrSessionName,(BSTR) NULL);
		Lock_ () ;
		hr = m_csdpSource.get_SessionName (pbstrSessionName) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::AddEmailAddress (
    IN  BSTR    bstrName, 
    IN  BSTR    bstrAddress
    )
{
    HRESULT hr = S_OK;

    if (bstrAddress == NULL ||
        wcslen (bstrAddress) == 0) 
	{
        hr = E_INVALIDARG ;
    }


    if(!FAILED(hr)) 
	{
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.AddEMail (bstrAddress, bstrName) ;
		Unlock_ ()  ;
	}

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

    return hr ;
}

STDMETHODIMP 
CATVEFAnnouncement::AddPhoneNumber (
    IN  BSTR    bstrName, 
    IN  BSTR    bstrPhoneNumber
    )
{
	HRESULT hr = S_OK;

	if (bstrPhoneNumber == NULL ||
        wcslen (bstrPhoneNumber) == 0) 
	{
        hr = E_INVALIDARG ;
    }

    if(!FAILED(hr))
	{
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.AddPhone (bstrPhoneNumber, bstrName) ;
		Unlock_ ()  ;
	}

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

    return hr ;
}

STDMETHODIMP 
CATVEFAnnouncement::AddExtraAttribute (
    IN  BSTR    bstrKey, 
    IN  BSTR    bstrValue					// may be NULL
    )
{
	HRESULT hr = S_OK;

	if (bstrKey == NULL) 
	{
        hr = E_INVALIDARG ;
    }

    if(!FAILED(hr)) {
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.AddExtraAttribute (bstrKey, bstrValue) ;
		Unlock_ ()  ;
	}

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

    return hr ;
}

STDMETHODIMP 
CATVEFAnnouncement::AddExtraFlag (
    IN  BSTR    bstrKey, 
    IN  BSTR    bstrValue				
    )
{
	HRESULT hr = S_OK;

	if (bstrKey == NULL || bstrValue == NULL) 
	{
        hr = E_INVALIDARG;
    }

	if(wcslen(bstrKey) != 1)				// type (key) is always one character and is case significant (1998 SDP spec, section 6)
	{
		hr = E_INVALIDARG;
	}

    if(!FAILED(hr)) {
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.AddExtraFlag (bstrKey, bstrValue) ;
		Unlock_ ()  ;
	}

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

    return hr ;
}



/*
STDMETHODIMP 
CATVEFAnnouncement::SetStartStopTime (
    IN  DATE    Start, 
    IN  DATE    Stop
    )
{
    HRESULT hr ;

    Lock_ () ;
    DisconnectLocked_ () ;
    hr = m_csdpSource.AddTime (Start, Stop) ;
    Unlock_ ()  ;

    return hr ;
}
*/

STDMETHODIMP 
CATVEFAnnouncement::put_MaxCacheSize (
    IN  LONG   ulSize
    )
{
    HRESULT hr  = S_OK;

 	ENTER_API {
		if (ulSize == 0) {
			hr = E_INVALIDARG ;
		}

		if(!FAILED(hr))
		{
			Lock_ () ;
			MAYBE_DISCONNECT DisconnectLocked_ () ;
			hr = m_csdpSource.put_CacheSize (ulSize) ;
			Unlock_ ()  ;
		} 
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_MaxCacheSize (
    OUT  LONG   *pulSize
    )
{
    HRESULT hr ;

	ENTER_API {
		ValidateOutPtr( pulSize,(LONG) 0);
		if (pulSize == NULL) 
			return E_POINTER ;

		Lock_ () ;
		hr = m_csdpSource.get_CacheSize ((ULONG *) pulSize) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::put_ContentLevelID  (
    IN  FLOAT   flLevelID
    )
{
    HRESULT hr ;

    Lock_ () ;
    DisconnectLocked_ () ;
    hr = m_csdpSource.put_ContentLevelID (flLevelID) ;
    Unlock_ ()  ;

    return hr ;
}

STDMETHODIMP 
CATVEFAnnouncement::get_ContentLevelID  (
    OUT  FLOAT   *pflLevelID
    )
{
    HRESULT hr ;

 	ENTER_API {
		ValidateOutPtr( pflLevelID,(FLOAT) 0.0f);
		
		Lock_ () ;
		DisconnectLocked_ () ;
		hr = m_csdpSource.get_ContentLevelID (pflLevelID) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::put_SAPMessageIDHash (
    IN  SHORT   MessageIDHash
    )
{
    HRESULT hr  = S_OK;

  	ENTER_API {	   
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.put_SAPMsgIDHash (MessageIDHash) ;
		Unlock_ ()  ;
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

    return hr ;
}

STDMETHODIMP 
CATVEFAnnouncement::get_SAPMessageIDHash (
    OUT  SHORT   *pMessageIDHash
    )
{
    HRESULT hr ;

 	ENTER_API {
		ValidateOutPtr( pMessageIDHash,(SHORT) 0);
		Lock_ () ;
		hr = m_csdpSource.get_SAPMsgIDHash ((USHORT *) pMessageIDHash) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::get_SAPDeleteAnnc (
    OUT  BOOL   *pfDelete
    )
{
    HRESULT hr ;

 	ENTER_API {
		ValidateOutPtr( pfDelete,(BOOL) false);
		Lock_ () ;
		hr = m_csdpSource.get_SAPDeleteAnnc ((BOOL *) pfDelete) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::put_SAPDeleteAnnc (
    IN  BOOL   fDelete
    )
{
    HRESULT hr  = S_OK;

 	ENTER_API {
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.put_SAPDeleteAnnc (fDelete) ;
		Unlock_ ()  ;
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);


    return hr ;
}


STDMETHODIMP 
CATVEFAnnouncement::put_LangID (
    IN  SHORT  LangID
    )
{
    HRESULT hr  = S_OK ;

 	ENTER_API { 
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.put_LangID (LangID) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::get_LangID (
    OUT  SHORT  *pLangID
    )
{
    HRESULT hr ;

 	ENTER_API {
		ValidateOutPtr( pLangID,(SHORT) 0);
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.get_LangID ((USHORT *) pLangID) ;
		Unlock_ ()  ;
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}



STDMETHODIMP 
CATVEFAnnouncement::put_SDPLangID (
    IN  SHORT  LangID
    )
{
    HRESULT hr  = S_OK;

 	ENTER_API {
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.put_SDPLangID (LangID) ;
		Unlock_ ()  ;
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_SDPLangID (
    OUT  SHORT  *pLangID
    )
{
    HRESULT hr ;

 	ENTER_API {
		ValidateOutPtr( pLangID,(SHORT) 0);
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.get_SDPLangID ((USHORT *) pLangID) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::put_Primary (
    IN  BOOL    fPrimary
    )
{
    HRESULT hr  = S_OK;

 	ENTER_API {
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.put_Primary (fPrimary) ;
		Unlock_ ()  ;
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_Primary (
    OUT  BOOL    *pfPrimary
    )
{
    HRESULT hr ;

	ENTER_API {
		ValidateOutPtr( pfPrimary,(BOOL) 0);
		Lock_ () ;
		hr = m_csdpSource.get_Primary (pfPrimary) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::put_SecondsToEnd (
    IN  INT    Seconds
    )
{
    HRESULT hr  = S_OK;

 	ENTER_API {
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.put_SecondsToEnd (Seconds) ;
		Unlock_ ()  ;
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_SecondsToEnd (
    OUT  INT    *pSeconds
    )
{
    HRESULT hr ;

 	ENTER_API {
		ValidateOutPtr( pSeconds,(INT) 0);   
		Lock_ () ;
		hr = m_csdpSource.get_SecondsToEnd ((UINT *) pSeconds) ;
		Unlock_ ()  ;
	} EXIT_API_(hr);
}


STDMETHODIMP
CATVEFAnnouncement::put_SessionLabel (
    IN  BSTR    bstrLabel     //  can be NULL or 0-length
    )
{
    HRESULT hr  = S_OK;

 	ENTER_API {
		if (bstrLabel == NULL ||						// PBUG
			bstrLabel [0] == L'\0') 
		{
			hr =  E_INVALIDARG ;
		}

		if(!FAILED(hr))
		{
			Lock_ () ;
			MAYBE_DISCONNECT DisconnectLocked_ () ;
			hr = m_csdpSource.put_SessionLabel (bstrLabel) ;
			Unlock_ () ;
		}
	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP
CATVEFAnnouncement::get_SessionLabel (
    OUT  BSTR    *pbstrLabel     
    )
{
    HRESULT hr ;

 	ENTER_API {
		ValidateOutPtr( pbstrLabel,(BSTR) NULL);  
		Lock_ () ;
		hr = m_csdpSource.get_SessionLabel (pbstrLabel) ;
		Unlock_ () ;
	} EXIT_API_(hr);
}


// -------------------------------------------------
//  ConfigureAnncTransmission
//
//   Use to override the default ATVEF announcement address (224.0.1.113)
//		and port (2670).  In general, you don't have to ever call this.
// ----------------------------------------------------- 
STDMETHODIMP 
CATVEFAnnouncement::ConfigureAnncTransmission (
    IN  LONG		IP,						//  host order
    IN  SHORT		Port,                   //  host order
    IN  INT			MulticastScope,
	IN  LONG		MaxBitRate				//	cannot be 0
	)
{
    HRESULT hr = S_OK;

	ENTER_API {

		if (m_State != STATE_UNINITIALIZED) {
		   hr = ATVEFSEND_E_OBJECT_INITIALIZED;
		}

		if(!FAILED(hr))
		{
			Lock_ () ;
			DisconnectLocked_ () ;

			hr = m_csdpSource.SetAnncStrmAddULONG (IP, MulticastScope, Port, MaxBitRate) ;
			Unlock_ () ;
		}

		if(FAILED(hr))
			Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	} EXIT_API_(hr);
}

// -------------------------------------------------
//  ConfigureDataAndTriggerTransmission
//  ConfigureTriggerTransmission 
//	ConfigureDataTransmission
//
//		The following three routines are support for the old way to
//	do things where we only had one media (variation).  They create a 
//  new one if it's not there, else they always muck with the first (#0)
//	media object.  See CATVEFMedia::ConfigureDataAndTriggerTransmission() for 
//	more help.
// ------------------------------------------------------------------

STDMETHODIMP
CATVEFAnnouncement::SetCurrentMedia(long lMediaID)
{
	HRESULT hr;

	ENTER_API {
		Lock_ () ;
		DisconnectLocked_ () ;	
		hr = SetCurrentMediaLocked_(lMediaID);
		Unlock_ () ;
	} EXIT_API_(hr);
}

HRESULT				// switches the media to some other type... lMediaID must be in range from 0 to get_MediaCount();
CATVEFAnnouncement::SetCurrentMediaLocked_(long lMediaID)
{
    HRESULT hr, hrD, hrT;
	IATVEFMediaPtr spMedia;
	LONG lIP; 
	SHORT sPort; 
	INT iTTL; 
	LONG lMaxBandwidth;
	
	ENTER_API {
		hr = get_Media(lMediaID, &spMedia);	
		if(FAILED(hr)) 
			return hr;

		hrD = spMedia->GetDataTransmission(&lIP, &sPort, &iTTL, &lMaxBandwidth);
		if(hrD != S_FALSE) {	// case here Trigger set, but not data and called from SetTrigg
			if (FAILED (hrD) ||
				FAILED (hr = SetIPLocked_                (ENH_PACKAGE, lIP))             ||
				FAILED (hr = SetPortLocked_              (ENH_PACKAGE, sPort))           ||
				FAILED (hr = SetMulticastScopeLocked_    (ENH_PACKAGE, iTTL))			  ||
				FAILED (hr = SetBitRateLocked_           (ENH_PACKAGE, lMaxBandwidth)))
			{
				return hr;
			}
		}

		hrT = spMedia->GetTriggerTransmission(&lIP, &sPort, &iTTL, &lMaxBandwidth);
		if(hrT != S_FALSE) {
 			if (FAILED (hrT) ||
				FAILED (hr = SetIPLocked_                (ENH_TRIGGER, lIP))             ||
				FAILED (hr = SetPortLocked_              (ENH_TRIGGER, sPort))			  ||      // by spec, this must be incremented on the all-in-one
				FAILED (hr = SetMulticastScopeLocked_    (ENH_TRIGGER, iTTL))			  ||
				FAILED (hr = SetBitRateLocked_           (ENH_TRIGGER, lMaxBandwidth))) 
			{
				return hr;
			}
		}
		if(hrT == S_FALSE && hrD == S_FALSE)
			return E_INVALIDARG;			// need to set at least one of these!
	} EXIT_API_(hr);
}

STDMETHODIMP
CATVEFAnnouncement::ConfigureDataAndTriggerTransmission(LONG lIP, SHORT sPort, INT iTTL, LONG lMaxBandwidth)
{
    HRESULT hr  = S_OK;
	IATVEFMediaPtr spMedia;

	ENTER_API {
		Lock_ () ;
		DisconnectLocked_ () ;	
									// if haven't created a media yet, do so
									// else just muck with the first on
		hr = get_Media(0, &spMedia);	
		if(FAILED(hr))
			goto exit_this;
									// write it into a media object
		hr = spMedia->ConfigureDataAndTriggerTransmission (lIP, sPort, iTTL, lMaxBandwidth);
		if(FAILED(hr))
			goto exit_this;
									// set it into the current parameters
		hr = SetCurrentMediaLocked_(0);

	exit_this:
		Unlock_ () ;

		if(FAILED(hr))
			Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	} EXIT_API_(hr);
}

STDMETHODIMP
CATVEFAnnouncement::ConfigureDataTransmission(LONG lIP, SHORT sPort, INT iTTL, LONG lMaxBandwidth)
{
    HRESULT hr  = S_OK;
	IATVEFMediaPtr spMedia;

	ENTER_API {
		Lock_ () ;
		DisconnectLocked_ () ;

									// if haven't created a media yet, do so
									// else just muck with the first on
		hr = get_Media(0, &spMedia);	
		if(FAILED(hr))
			goto exit_this;
		if(FAILED(hr))
			goto exit_this;
		
		hr = spMedia->ConfigureDataTransmission(lIP, sPort, iTTL, lMaxBandwidth);
		if(FAILED(hr))
			goto exit_this;

		hr = SetCurrentMediaLocked_(0);				// use this media ID

	exit_this:
		Unlock_ () ;

		if(FAILED(hr))
			Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	} EXIT_API_(hr);
}

STDMETHODIMP
CATVEFAnnouncement::ConfigureTriggerTransmission(LONG lIP, SHORT sPort, INT iTTL, LONG lMaxBandwidth)
{
	HRESULT hr  = S_OK;
	IATVEFMediaPtr spMedia;

	ENTER_API {
		Lock_ () ;
		DisconnectLocked_ () ;
									// if haven't created a media yet, do so
									// else just muck with the first on
		hr = get_Media(0, &spMedia);	
		if(FAILED(hr))
			goto exit_this;
		
		hr = spMedia->ConfigureTriggerTransmission (lIP, sPort, iTTL, lMaxBandwidth);
		if(FAILED(hr))
			goto exit_this;

		hr = SetCurrentMediaLocked_(0);
	exit_this:
		Unlock_ () ;

		if(FAILED(hr))
			Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::put_UUID (
    IN  BSTR bstrUUID
    )
{
    HRESULT hr = S_OK ;
    
	ENTER_API {
		if (bstrUUID == NULL ||				// PBUG
			bstrUUID [0] == L'\0') 
		{
			hr = E_INVALIDARG ;
		}
		if(!FAILED(hr)) {
			Lock_ () ;
			MAYBE_DISCONNECT DisconnectLocked_ () ;
			hr = m_csdpSource.put_UUID (bstrUUID) ;
			Unlock_ () ;
		}

	} LEAVE_API;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	return hr;
}

STDMETHODIMP 
CATVEFAnnouncement::get_UUID (
    OUT  BSTR *pbstrUUID
    )
{
    HRESULT hr ;
    
 	ENTER_API {
		ValidateOutPtr( pbstrUUID,(BSTR) NULL);  
		Lock_ () ;
		hr = m_csdpSource.get_UUID (pbstrUUID) ;
		Unlock_ () ;
	} EXIT_API_(hr);
}

STDMETHODIMP CATVEFAnnouncement::get_EmailAddresses(IDispatch **ppVal)
{
	HRESULT hr = S_OK;

 	ENTER_API {
		ValidateOutPtr( ppVal,(IDispatch *) NULL);  

		IUnknownPtr spUnk;

		Lock_();
		hr = m_csdpSource.get_EmailAddresses(&spUnk);
		Unlock_();

		if(!FAILED(hr)) {
			try {
				hr = spUnk->QueryInterface(ppVal);
			} catch(...) {
				return E_POINTER;
			}
		}
	} EXIT_API_(hr);
}

STDMETHODIMP CATVEFAnnouncement::get_PhoneNumbers(IDispatch **ppVal)
{
	IUnknownPtr spUnk;
	HRESULT hr = S_OK;

	ENTER_API {
		ValidateOutPtr( ppVal,(IDispatch *) NULL); 
		Lock_();
		hr = m_csdpSource.get_PhoneNumbers(&spUnk);
		Unlock_();

		if(!FAILED(hr)) {
			try {
				hr = spUnk->QueryInterface(ppVal);
			} catch(...) {
				return E_POINTER;
			}
		}
	} EXIT_API_(hr);
}

STDMETHODIMP CATVEFAnnouncement::get_ExtraAttributes(IDispatch **ppVal)
{
	IUnknownPtr spUnk;
	HRESULT hr = S_OK;

	ENTER_API {
		ValidateOutPtr( ppVal,(IDispatch *) NULL); 
		Lock_();
		hr = m_csdpSource.get_ExtraAttributes(&spUnk);
		Unlock_();

		if(!FAILED(hr)) {
			try {
				hr = spUnk->QueryInterface(ppVal);
			} catch(...) {
				return E_POINTER;
			}
		}
	} EXIT_API_(hr);
}

STDMETHODIMP CATVEFAnnouncement::get_ExtraFlags(IDispatch **ppVal)
{
	IUnknownPtr spUnk;
	HRESULT hr = S_OK;

	ENTER_API {
		ValidateOutPtr( ppVal,(IDispatch *) NULL); 
		Lock_();
		hr = m_csdpSource.get_ExtraFlags(&spUnk);
		Unlock_();

		if(!FAILED(hr)) {
			try {
				hr = spUnk->QueryInterface(ppVal);
			} catch(...) {
				return E_POINTER;
			}
		}
	} EXIT_API_(hr);
}
STDMETHODIMP 
CATVEFAnnouncement::ClearTimes (  )
{
    HRESULT hr  = S_OK;
    
 	ENTER_API {
		Lock_ () ;
		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.ClearTimes () ;
		Unlock_ () ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::ClearEmailAddresses (
    )
{
    HRESULT hr  = S_OK;
    
 	ENTER_API {
		Lock_ () ;

		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.ClearEmailAddresses () ;

		Unlock_ () ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::ClearPhoneNumbers ( )
{
    HRESULT hr ;
    
 	ENTER_API {
		Lock_ () ;

		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.ClearPhoneNumbers () ;

		Unlock_ () ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::ClearExtraAttributes ( )
{
    HRESULT hr ;
    
 	ENTER_API {
		Lock_ () ;

		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.ClearExtraAttributes () ;

		Unlock_ () ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::ClearExtraFlags ( )
{
    HRESULT hr ;
    
 	ENTER_API {
		Lock_ () ;

		MAYBE_DISCONNECT DisconnectLocked_ () ;
		hr = m_csdpSource.ClearExtraFlags () ;

		Unlock_ () ;
	} EXIT_API_(hr);
}

STDMETHODIMP 
CATVEFAnnouncement::DumpToBSTR(BSTR *pBstrBuff)
{
	ENTER_API {
		ValidateOutPtr( pBstrBuff,(BSTR) NULL); 		
		
		const int kMaxChars = 1024;
		WCHAR tBuff[kMaxChars];
		CComBSTR spbsOut;
		CComBSTR spbsTmp;

		if(NULL == pBstrBuff) 
			return E_POINTER;

		spbsOut.Empty();

		CComBSTR spbsX;
		BOOL fX;
		INT iX;
		LONG lX;
		float rX;
		SHORT sX;

		Lock_() ;

		ULONG ulIP = 0;		// init, GetAnncStrmAddULONG won't set if null string for this value 
		UINT  uiTTL; 
		LONG lPort; 
		ULONG ulMaxBandwidth;

		m_csdpSource.GetAnncStrmAddULONG(&ulIP, &uiTTL, &lPort, &ulMaxBandwidth);
		HrConvertLONGIPToBSTR(ulIP, &spbsX);

		swprintf(tBuff,L"Announcement: (IP %s Port %d TTL %d Bandwidth %d)\n",
					spbsX, lPort, uiTTL, ulMaxBandwidth);
		spbsOut.Append(tBuff);

		get_SAPMessageIDHash(&sX);
		swprintf(tBuff,L"SAP Msg ID Hash  : 0x%04x\n",sX);		spbsOut.Append(tBuff);
		
	//	_stprintf(tBuff,_T("Protocol Version : %d\n",iX);			spbsOut.Append(tBuff);
		get_SessionLabel(&spbsX); 
		swprintf(tBuff,L"Session Label    : %s\n",spbsX);		spbsOut.Append(tBuff);
		get_SessionID(&iX);
		swprintf(tBuff,L"Session ID       : %u\n",iX);			spbsOut.Append(tBuff);
		get_SessionVersion(&iX);
		swprintf(tBuff,L"Session Version  : %d\n",iX);			spbsOut.Append(tBuff);

		get_SendingIP(&lX); 
		HrConvertLONGIPToBSTR(lX, &spbsX);
		swprintf(tBuff,L"Sending IP       : %s\n",spbsX);		spbsOut.Append(tBuff);
	//	_stprintf(tBuff,L"Machine Address  : %s\n",m_spbsMachineAddress);	spbsOut.Append(tBuff);
		get_SessionName(&spbsX); 
		swprintf(tBuff,L"Session Name     : %s\n",spbsX);		spbsOut.Append(tBuff);
		get_SessionURL(&spbsX); 
		swprintf(tBuff,L"Session URL      : %s\n",spbsX);		spbsOut.Append(tBuff);

		get_UserName(&spbsX);
		swprintf(tBuff,L"User Name        : %s\n",spbsX);		spbsOut.Append(tBuff);

		get_Primary(&fX); 
		swprintf(tBuff,L"IsPrimary        : %s\n",fX ? L"TRUE" : L"false"); spbsOut.Append(tBuff);
		get_UUID(&spbsX);
		swprintf(tBuff,L"UUID             : %s\n",spbsX);					spbsOut.Append(tBuff);

		{
			IDispatchPtr spIDP;
			HRESULT hr = get_EmailAddresses(&spIDP);
			IATVEFAttrListPtr spIAL;
			if(!FAILED(hr))
				spIAL = spIDP;

			LONG cAttrs;
			if(spIAL) {
				spIAL->get_Count(&cAttrs);	
				if(cAttrs > 0) 
				{
					CComBSTR spbsInsert;
					for(int i = 0; i < cAttrs; i++) {
						CComBSTR spbsKey, spbsItem;		// address, name
						CComVariant id(i);
						spIAL->get_Key(id, &spbsKey);
						spIAL->get_Item(id, &spbsItem);
						swprintf(tBuff,L"EMail(%d)         : %s (%s)\n",i,spbsKey,spbsItem); spbsOut.Append(tBuff);
					}
				}
			}
		}
		{
			IDispatchPtr spIDP;
			HRESULT hr = get_PhoneNumbers(&spIDP);
			IATVEFAttrListPtr spIAL;
			if(!FAILED(hr))
				spIAL = spIDP;

			LONG cAttrs;
			if(spIAL) {
				spIAL->get_Count(&cAttrs);	
				if(cAttrs > 0) 
				{
					CComBSTR spbsInsert;
					for(int i = 0; i < cAttrs; i++) {
						CComBSTR spbsKey, spbsItem;		// address, name
						CComVariant id(i);
						spIAL->get_Key(id, &spbsKey);
						spIAL->get_Item(id, &spbsItem);
						swprintf(tBuff,L"Phone(%d)         : %s (%s)\n",i,spbsKey,spbsItem); spbsOut.Append(tBuff);
					}
				}
			}
		}
		{
			IDispatchPtr spIDP;
			HRESULT hr = get_ExtraAttributes(&spIDP);
			IATVEFAttrListPtr spIAL;
			if(!FAILED(hr))
				spIAL = spIDP;

			LONG cAttrs;
			if(spIAL) {
				spIAL->get_Count(&cAttrs);	
				if(cAttrs > 0) 
				{
					CComBSTR spbsInsert;
					for(int i = 0; i < cAttrs; i++) {
						CComBSTR spbsKey, spbsItem;		// address, name
						CComVariant id(i);
						spIAL->get_Key(id, &spbsKey);
						spIAL->get_Item(id, &spbsItem);
						swprintf(tBuff,L"Extra Attr's(%d)  : %s (%s)\n",i,spbsKey,spbsItem); spbsOut.Append(tBuff);
					}
				}
			}
		}

		{
			IDispatchPtr spIDP;
			HRESULT hr = get_ExtraFlags(&spIDP);
			IATVEFAttrListPtr spIAL;
			if(!FAILED(hr))
				spIAL = spIDP;

			LONG cAttrs;
			if(spIAL) {
				spIAL->get_Count(&cAttrs);	
				if(cAttrs > 0) 
				{
					CComBSTR spbsInsert;
					for(int i = 0; i < cAttrs; i++) {
						CComBSTR spbsKey, spbsItem;		// address, name
						CComVariant id(i);
						spIAL->get_Key(id, &spbsKey);
						spIAL->get_Item(id, &spbsItem);
						swprintf(tBuff,L"Extra Flags(%d)   : %s (%s)\n",i,spbsKey,spbsItem); spbsOut.Append(tBuff);
					}
				}
			}
		}
		
		{
			int i = 0;
			DATE dateStart, dateStop;
			while(S_OK == GetStartStopTime(i, &dateStart, &dateStop))
			{
				swprintf(tBuff,L"Start Time       : %s (%s)\n",
						DateToBSTR(dateStart), DateToDiffBSTR(dateStart));		spbsOut.Append(tBuff);
 				swprintf(tBuff,L"Stop Time        : %s (%s)\n",
						DateToBSTR(dateStop), DateToDiffBSTR(dateStop));		spbsOut.Append(tBuff);
				i++;
			}
		}
		get_SecondsToEnd(&iX);
		swprintf(tBuff,L"Seconds To End   : %d\n",iX);				    	spbsOut.Append(tBuff);

	// tve-typeAttributes
	//	swprintf(tBuff,"Type             : %s\n",m_spbsType);				spbsOut.Append(tBuff);
	//	swprintf(tBuff,"tve-type         : %s\n",m_spbsTveType);			spbsOut.Append(tBuff);

		get_MaxCacheSize(&lX);
		swprintf(tBuff,L"tve-Size         : %d\n",lX);						spbsOut.Append(tBuff);
		get_ContentLevelID(&rX);
		swprintf(tBuff,L"tve-Level        : %-5.1f\n",rX);					spbsOut.Append(tBuff);
	//	swprintf(tBuff,"tve-Profile      : %d\n",m_ulTveProfile);			spbsOut.Append(tBuff);


		get_LangID(&sX);
		GetLangBSTRFromLangID(&spbsX, sX);
		swprintf(tBuff,L"Lang             : %s\n",spbsX);			spbsOut.Append(tBuff);
		get_SDPLangID(&sX);
		GetLangBSTRFromLangID(&spbsX, sX);
		swprintf(tBuff,L"SDP Lang         : %s\n",spbsX);			spbsOut.Append(tBuff);

		long cMedia;
		HRESULT hr = get_MediaCount(&cMedia);
		for(long j = 0; j < cMedia; j++) {
			IATVEFMediaPtr spMedia;
			hr = get_Media(j, &spMedia);
			LONG ip; SHORT port; INT scope; LONG maxBitRate;
			swprintf(tBuff,L"<Media %d>\n",j);							spbsOut.Append(tBuff);		
			spMedia->get_MediaLabel(&spbsX);
			swprintf(tBuff,L"   Label         : %s\n",spbsX);						spbsOut.Append(tBuff);
			spMedia->get_LangID(&sX);
			GetLangBSTRFromLangID(&spbsX, sX);
			swprintf(tBuff,L"   Lang          : %s\n",spbsX);			spbsOut.Append(tBuff);
			spMedia->get_SDPLangID(&sX);
			GetLangBSTRFromLangID(&spbsX, sX);
			swprintf(tBuff,L"   SDP Lang      : %s\n",spbsX);			spbsOut.Append(tBuff);
			spMedia->get_MaxCacheSize(&lX);
			swprintf(tBuff,L"   Cache Size    : %d\n",lX);				spbsOut.Append(tBuff);
			spMedia->GetDataTransmission(&ip,&port,&scope,&maxBitRate);
			HrConvertLONGIPToBSTR(ip, &spbsX);
			swprintf(tBuff,L"   Data IP       : %s:%d\n",spbsX,port);   spbsOut.Append(tBuff);
			swprintf(tBuff,L"        Hops     : %d\n",scope);           spbsOut.Append(tBuff);
			swprintf(tBuff,L"        BitRate  : %d\n",maxBitRate);      spbsOut.Append(tBuff);
			spMedia->GetTriggerTransmission(&ip,&port,&scope,&maxBitRate);
			HrConvertLONGIPToBSTR(ip, &spbsX);
			swprintf(tBuff,L"   Trig IP       : %s:%d\n",spbsX,port);   spbsOut.Append(tBuff);
			swprintf(tBuff,L"        Hops     : %d\n",scope);           spbsOut.Append(tBuff);
			swprintf(tBuff,L"        BitRate  : %d\n",maxBitRate);      spbsOut.Append(tBuff);
		}

		spbsOut.CopyTo(pBstrBuff);

		Unlock_ () ;

	} EXIT_API;
}

STDMETHODIMP								// dumps formated announcement string
CATVEFAnnouncement::AnncToBSTR(BSTR *pBstrBuff)
{
	HRESULT hr = S_OK;
	ENTER_API {
		ValidateOutPtr( pBstrBuff,(BSTR) NULL); 		

		CComBSTR spbsOut;

		UINT uiSize;
		char *pAnnouncement;		// SAP header (with null's) followed by text

		Lock_() ;
		hr = m_csdpSource.GetAnnouncement(&uiSize, &pAnnouncement);
		Unlock_();

		if(!FAILED(hr)) {
			unsigned char *pcRead = (unsigned char *) pAnnouncement;
			TCHAR tBuff[256];
			spbsOut.Empty();
			
		// Uncreate the SAP Header
			_stprintf(tBuff,_T("SAP Header (%02x %02x %02x %02x %08x)\n"),
				*(pcRead), *(pcRead+1),*(pcRead+2), *(pcRead+3), *(((int*) pcRead)+1) );
			spbsOut.Append(tBuff);

			SAPHeaderBits SAPHead;
			SAPHead.uc = *pcRead; 
			_stprintf(tBuff,_T("   SAP Version         : %d\n"), (*pcRead)>>5);      	spbsOut.Append(tBuff);
			_stprintf(tBuff,_T("   IPv6 Address  (bit4): %d\n"),((*pcRead)>>4) & 0x1); 	spbsOut.Append(tBuff);
			_stprintf(tBuff,_T("   Reserved      (bit3): %d\n"),((*pcRead)>>3) & 0x1); 	spbsOut.Append(tBuff);
			_stprintf(tBuff,_T("   Delete Packet (bit2): %d\n"),((*pcRead)>>2) & 0x1); 	spbsOut.Append(tBuff);
			_stprintf(tBuff,_T("   Encrypted     (bit1): %d\n"),((*pcRead)>>1) & 0x1); 	spbsOut.Append(tBuff);
			_stprintf(tBuff,_T("   Compressed    (bit0): %d\n"),((*pcRead)>>0) & 0x1); 	spbsOut.Append(tBuff);
			pcRead++;
			_stprintf(tBuff,_T("   Auth Length         : %d\n"),*pcRead);					spbsOut.Append(tBuff);
			pcRead++;
			_stprintf(tBuff,_T("   MsgIDHash           : 0x%04x\n"),*pcRead | ((*(pcRead+1))<<8)); spbsOut.Append(tBuff);
			pcRead += 2;

			_stprintf(tBuff,_T("   Sending IP          : %u.%u.%u.%u  (0x%8x)\n"),
				*(pcRead+0),*(pcRead+1),*(pcRead+2),*(pcRead+3), *((int*) pcRead)); 
			spbsOut.Append(tBuff);
			
			spbsOut.Append(pAnnouncement + 8);		// sizeof SapHeader...
			delete pAnnouncement;
		} else {
			spbsOut = L"AnncToBSTR Error: ***Invalid Announcement***\n";
			if(ATVEFSEND_E_ANNOUNCEMENT_TOO_LONG == hr)
				spbsOut += L"          Announcement Too Long (>1024 characters)\n";
		}
		spbsOut.CopyTo(pBstrBuff);

		if(FAILED(hr))
			Error(GetTVEError(hr), IID_IATVEFAnnouncement);

	} EXIT_API_(hr);
}

// ///////////////////////////////////////////////////////////////////////
// ------------------------------------------------------------------------
// protected methods to communicate/talk to IP ports
//
//		Each announcement object holds on to 3 IP ports (managed
//		by the class CMulticastTransmitter):
//
//			 ENH_ANNOUNCEMENT for sending Announcements
//			 ENH_PACKAGE for sending data packages
//			 ENH_TRIGGER for sending triggers
//			
//		The xxxLocked_ methods assume that the lock on the ATVEFAnnouncement
//		object is held.
//
//
//		Simple State Engine (m_State)
//
//							UNINITIALIZED
//						|					^
//						v					|
//							INITIALIZED		
//		ConnectLocked_	|				    ^
//						v				    |  DisconnectLocked_								
//							 CONNECTED		
// ------------------------------------------------------------------------
//  must hold the lock before making the call; state must be connecting;
//  if over a tunnel, route should be created

HRESULT
CATVEFAnnouncement::ConnectLocked_ ( )
/*++
    
    Routine Description:

        The purpose of this routine is to connect all transmitters in the
        m_Transmitter array.  Transmitters are disconnected explicitely via
        call to ::Disconnect, or implicitely via an announcement field update.

        This routine is called by ::Connect, which must be explicitely called
        for a session object to become connected and be able to transmit.

        The announcement fields are checked for validity.  This is a 
        prerequisite for the successful completion of this routine.  Validity
        of the announcement is checked via the announcement object, and also
        for length to make sure it does not exceed the ethernet UDP mtu.

        Once the announcement has been validated, all transmitters are 
        connected.  If a failure occurs during this phase, transmitters are
        disconnected, except for the announcement object and the error code
        is returned.

        The object lock must be held when this routine is called.

    Parameters:

        none

    Return Values:

        S_OK            success; all transmitters are connected and the
                        announcement object is valid

        failure code    failure; package and trigger transmitters are not
                        connected

--*/
{
	DWORD           Component ;
	HRESULT         hr ;
	UINT            Length ;

	ENTERW_OBJ_0 (
		L"CEnhancementSession::ConnectLocked_"
		) ;

	assert (LOCK_HELD (m_crt)) ;

	if (m_State < STATE_INITIALIZED) {
		return ATVEFSEND_E_OBJECT_NOT_INITIALIZED ;
	}

	if (m_State == STATE_CONNECTED) {
		return S_OK ;
	}

	//  fail out if the announcement is not valid
	{
		BYTE *  pAnnouncement = NULL ;
		hr = m_csdpSource.GetAnnouncement (&Length, (CHAR **) & pAnnouncement) ;
//		assert (SUCCEEDED (hr)) ;
		delete pAnnouncement ;
	}

	if(FAILED(hr)) {
		return hr;
	}

	// before actually connecting, default to the first media
//	hr = SetCurrentMediaLocked_(0);	// paranoia..			// BUGFIX - JB 8-01-2000... Commented out.
//	assert (SUCCEEDED (hr)) ;								//     (was forcing media id back to zero all the time)

	ULONG ulIP;
	hr = GetIPLocked_(1, &ulIP);					// make sure we have a valid one...
	assert(SUCCEEDED(hr));
	if(0 == ulIP)
		hr = SetCurrentMediaLocked_(0);
	assert(SUCCEEDED(hr));


	//  now connect all the components; we include the announcement here in case
	//  the connection was broken between initialization and this call; the 
	//  transmitters are written to immediately disconnect if a transmission 
	//  problem occurs

	for (Component = ENH_ANNOUNCEMENT; Component < ENH_COMPONENT_COUNT; Component++) {
		assert (m_Transmitter [Component]) ;
		hr = m_Transmitter [Component] -> Connect () ;
		if (FAILED (hr)) {
			goto error ;
		}
	}

	m_State = STATE_CONNECTED ;

	//  expected state
	assert (m_Transmitter [ENH_ANNOUNCEMENT] -> IsConnected ()) ;
	assert (m_Transmitter [ENH_TRIGGER] -> IsConnected ()) ;
	assert (m_Transmitter [ENH_PACKAGE] -> IsConnected ()) ;

	return S_OK ;

error:

	assert (IS_HRESULT (hr)) ;

	//  disconnect all components except for the announcement (???)
	for (Component = ENH_ANNOUNCEMENT; Component < ENH_COMPONENT_COUNT; Component++) 
//	for (Component = ENH_ANNOUNCEMENT + 1; Component < ENH_COMPONENT_COUNT; Component++) 
	{
		assert (m_Transmitter [Component]) ;
		m_Transmitter [Component] -> Disconnect () ;
	}

	//  expected state
//	assert (m_Transmitter [ENH_ANNOUNCEMENT] -> IsConnected ()) ;
	assert (m_Transmitter [ENH_ANNOUNCEMENT] -> IsConnected () == FALSE) ;
	assert (m_Transmitter [ENH_TRIGGER] -> IsConnected () == FALSE) ;
	assert (m_Transmitter [ENH_PACKAGE] -> IsConnected () == FALSE) ;

    return hr ;
}

//  must hold the lock before making the call
HRESULT
CATVEFAnnouncement::DisconnectLocked_ ()
/*++

    Routine Description:

        The purpose of this routine is disconnect the transmitters, except
        for the announcement transmitter.  Transmitters are (and future ones
        should be) coded up to not fail a disconnect.  Details on this can be
        obtained by examining the transmitter objects.

        This routine does not disconnect the announcement transmitter.  <BUGFIX 3/02/2000 - now disconnects>

        This routine is called explicitely, via client call to ::Disconnect, or
        implicitely when an announcement field is updated.

    Arguments:

        none

    Return values:

        S_OK            success; all but the announcement transmitter should be
                        disconnected.

        error code      only occurs if the object is not initialized.

--*/
{
    DWORD   Component ;

    ENTERW_OBJ_0 (L"CEnhancementSession::DisconnectLocked_") ;

    //  lock not held if called from destructor
    //assert (LOCK_HELD (m_crt)) ;

    if (m_State < STATE_INITIALIZED) {
         return ATVEFSEND_E_OBJECT_NOT_INITIALIZED ;
    }

	if (m_State == STATE_INITIALIZED) {
       return S_OK ;
    }

	for (Component = ENH_ANNOUNCEMENT; Component < ENH_COMPONENT_COUNT; Component++) {			// disconnect even tha announcement
//	for (Component = ENH_ANNOUNCEMENT + 1; Component < ENH_COMPONENT_COUNT; Component++) {
        assert (m_Transmitter [Component]) ;

        //  close the connection
        m_Transmitter [Component] -> Disconnect () ;
    }

    //  expected state (transmitters cannot fail a ::Disconnect call)
   // assert (m_Transmitter [ENH_ANNOUNCEMENT] -> IsConnected ()) ;
    assert (m_Transmitter [ENH_ANNOUNCEMENT] -> IsConnected () == FALSE) ;
    assert (m_Transmitter [ENH_TRIGGER] -> IsConnected () == FALSE) ;
    assert (m_Transmitter [ENH_PACKAGE] -> IsConnected () == FALSE) ;

    m_State = STATE_INITIALIZED ;

    return S_OK ;
}


HRESULT
CATVEFAnnouncement::GetIPLocked_ (
    IN  DWORD   Component,
    OUT ULONG * pIP
    )

{
    assert (LOCK_HELD (m_crt)) ;
 //   assert (IN_BOUNDS (Component, ENH_ANNOUNCEMENT, ENH_TRIGGER)) ;
    assert (pIP) ;

    ENTERW_OBJ_2 (L"CEnhancementSession::GetIPLocked_ (%u, %08XH)", Component, pIP) ;

    * pIP = 0 ;

	// paranoia, make sure initalized to get
	if (m_State < STATE_INITIALIZED) {
       return ATVEFSEND_E_OBJECT_NOT_INITIALIZED ;
    }

    return m_Transmitter [Component] -> GetMulticastIP (pIP) ;
}

HRESULT
CATVEFAnnouncement::SetIPLocked_ (
    IN  DWORD   Component,
    IN  ULONG   IP
    )

{
    HRESULT hr ;

    assert (LOCK_HELD (m_crt)) ;
 //   assert(IN_BOUNDS (Component, ENH_ANNOUNCEMENT, ENH_TRIGGER)) ;

    ENTERW_OBJ_2 (L"CEnhancementSession::SetIPLocked_ (%u, %08XH)", Component, IP) ;

    //  must be initialized to set the IP
    if (m_State < STATE_INITIALIZED) {
       return ATVEFSEND_E_OBJECT_NOT_INITIALIZED ;
    }

    hr = m_Transmitter [Component] -> SetMulticastIP (IP) ;

    return hr ;
}

HRESULT
CATVEFAnnouncement::GetPortLocked_ (
    IN  DWORD       Component,
    OUT USHORT *    pPort
    )

{
    assert (LOCK_HELD (m_crt)) ;
 //   assert (IN_BOUNDS (Component, ENH_ANNOUNCEMENT, ENH_TRIGGER)) ;
    assert (pPort) ;

    ENTERW_OBJ_2 (L"CEnhancementSession::GetPortLocked_ (%u, %08XH)", Component, pPort) ;

    * pPort = 0 ;

	// paranoia, make sure initalized to get
	if (m_State < STATE_INITIALIZED) {
       return ATVEFSEND_E_OBJECT_NOT_INITIALIZED ;
    }

    return m_Transmitter [Component] -> GetPort (pPort) ; ;
}

HRESULT
CATVEFAnnouncement::SetPortLocked_ (
    IN  DWORD   Component,
    IN  USHORT  Port
    )

{
    HRESULT hr ;

    assert (LOCK_HELD (m_crt)) ;
 //   assert(IN_BOUNDS (Component, ENH_ANNOUNCEMENT, ENH_TRIGGER)) ;

    ENTERW_OBJ_2 (L"CEnhancementSession::SetPortLocked_ (%u, %04XH)", Component, Port) ;

   if (m_State < STATE_INITIALIZED) {
       return ATVEFSEND_E_OBJECT_NOT_INITIALIZED ;
    }

    hr = m_Transmitter [Component] -> SetPort (Port) ;

    return hr ;
}

HRESULT
CATVEFAnnouncement::SetBitRateLocked_ (
    IN  DWORD   Component,
    IN  DWORD   BitRate
    )

{
    HRESULT hr ;

    assert (LOCK_HELD (m_crt)) ;
 //   assert(IN_BOUNDS (Component, ENH_ANNOUNCEMENT, ENH_TRIGGER)) ;

    ENTERW_OBJ_2 (L"CEnhancementSession::SetBitRateLocked_ (%u, %u)", Component, BitRate) ;

    //  must be initialized to set 
	if (m_State < STATE_INITIALIZED) {
       return ATVEFSEND_E_OBJECT_NOT_INITIALIZED ;
    }

    hr = m_Transmitter [Component] -> SetBitRate (BitRate) ;

    return hr ;
}

HRESULT
CATVEFAnnouncement::SetMulticastScopeLocked_ (
    IN  DWORD   Component,
    IN  INT     MulticastScope
    )

{
    HRESULT hr ;

    assert (LOCK_HELD (m_crt)) ;
 //   assert(IN_BOUNDS (Component, ENH_ANNOUNCEMENT, ENH_TRIGGER)) ;

    ENTERW_OBJ_2 (L"CEnhancementSession::SetMulticastScopeLocked_ (%u, %u)", Component, MulticastScope) ;

    //  must be initialized to set 
	if (m_State < STATE_INITIALIZED) {
       return ATVEFSEND_E_OBJECT_NOT_INITIALIZED ;
    }

    hr = m_Transmitter [Component] -> SetMulticastScope (MulticastScope) ;

    return hr ;
}

HRESULT				// scope is hop-count I think...
CATVEFAnnouncement::GetMulticastScopeLocked_ (		
    IN  DWORD   Component,
    OUT INT *   pMulticastScope
    )

{
    assert (LOCK_HELD (m_crt)) ;
 //   assert (IN_BOUNDS (Component, ENH_ANNOUNCEMENT, ENH_TRIGGER)) ;
    assert (pMulticastScope) ;

    ENTERW_OBJ_2 (L"CEnhancementSession::GetMulticastScopeLocked_ (%u, %08XH)", Component, pMulticastScope) ;

    * pMulticastScope = 0 ;

	// paranoia, make sure initalized to get
	if (m_State < STATE_INITIALIZED) {
       return ATVEFSEND_E_OBJECT_NOT_INITIALIZED ;
    }

    return m_Transmitter [Component] -> GetMulticastScope (pMulticastScope) ; ;
}

//  announcement IP and port remains constant for the duration
HRESULT
CATVEFAnnouncement::InitializeLocked_ (
    IN  CMulticastTransmitter * pAnnouncementTransmitter,
    IN  CMulticastTransmitter * pPackageTransmitter,
    IN  CMulticastTransmitter * pTriggerTransmitter
    )
/*++

    Routine Description:

        The purpose of this routine is to initialize the session object.  A
        session cannot be used until it is successfully initialized.  Once
        successfully initialized, it cannot be re-initialized.

        This routine is called by the child object that is instantiated via
        call to CoCreateInstance.  The child object is expected to initialize
        the transmitters prior to calling this routine.  This routine connects
        the announcement transmitter, and thus will fail if the transmitters
        have not been successfully initialized.

        If the initialization succeeds, this object will copy the transmitter
        pointers into the m_Transmitter array and take ownership of them.  If
        the initialization fails, this object leaves m_Transmitter 0'd out,
        but does not delete the transmitters.  This task is left to the caller
        in the case of a failure.

        The class lock must be held when this routine is called.

    Parameters:

        pAnnouncementTransmitter    announcement transmitter
        pPackageTransmitter         package transmitter
        pTriggerTransmitter         trigger transmitter

    Return Values:

        S_OK                success
        failure code        failure
--*/
{
    HRESULT hr ;

    ENTERW_OBJ_0 (L"CEnhancementSession::InitializeLocked_ ()") ;

    //  expected state
    assert (m_State == STATE_UNINITIALIZED) ;
    assert (pAnnouncementTransmitter) ;
    assert (pPackageTransmitter) ;
    assert (pTriggerTransmitter) ;
    assert (LOCK_HELD (m_crt)) ;
    assert (m_Transmitter [ENH_ANNOUNCEMENT] == NULL) ;
    assert (m_Transmitter [ENH_PACKAGE] == NULL) ;
    assert (m_Transmitter [ENH_TRIGGER] == NULL) ;

	ULONG ulIP=0;
	UINT uiTTL;
	LONG lPort;
	ULONG ulMaxBandwidth;

	hr = m_csdpSource.GetAnncStrmAddULONG(&ulIP, &uiTTL, &lPort, &ulMaxBandwidth);		// should return ATVEF default values
	if(FAILED(hr))
		return hr;			// should never happen, PREFIX bug fix.

    //  set the ip and port for the announcement transmitter
    if (FAILED (hr = pAnnouncementTransmitter -> SetMulticastIP (ulIP)) ||
        FAILED (hr = pAnnouncementTransmitter -> SetPort (lPort)) ||
        FAILED (hr = pAnnouncementTransmitter -> SetMulticastScope (uiTTL)) ||
		FAILED (hr = pAnnouncementTransmitter -> SetBitRate (ulMaxBandwidth)) )		// bit rate not needed unless using SendThrottle
 	{
        goto cleanup ;
    }

	//  now connect the announcement transmitter
    hr = pAnnouncementTransmitter -> Connect () ;
    GOTO_NE (hr, S_OK, cleanup) ;

cleanup:

    if (SUCCEEDED (hr)) {
        //  assign the transmitters; we now own these memory allocations and will
        //  free them when we shutdown
        m_Transmitter [ENH_ANNOUNCEMENT]    = pAnnouncementTransmitter ;
        m_Transmitter [ENH_PACKAGE]         = pPackageTransmitter ;
        m_Transmitter [ENH_TRIGGER]         = pTriggerTransmitter ;

		m_State = STATE_INITIALIZED;
    }

	
    assert (IS_HRESULT (hr)) ;

    return hr ;
}

// -------------------------------
//  returns error codes in the range of:
//		

HRESULT
CATVEFAnnouncement::SendAnnouncementLocked_ ()
{
	HRESULT hr;
	UCHAR *pAnnouncement = NULL;
	UINT ulLength;

    if (m_State != STATE_CONNECTED) {

        hr = ATVEFSEND_E_OBJECT_NOT_CONNECTED ;
        goto cleanup ;
    }

    hr = m_csdpSource.GetAnnouncement (&ulLength, (CHAR **) & pAnnouncement) ;
	if(FAILED(hr)) 
		goto cleanup;

    //  all of these were checked during connection
    assert (SUCCEEDED (hr)) ;
    assert (pAnnouncement) ;
    assert (ulLength > 0) ;

 //   hr = m_Transmitter [ENH_ANNOUNCEMENT] -> Send (pAnnouncement, ulLength) ;
    hr = m_Transmitter [ENH_ANNOUNCEMENT] -> SendThrottled (pAnnouncement, ulLength) ;
    delete pAnnouncement ;

 cleanup :

	return hr;
}


HRESULT
CATVEFAnnouncement::SendRawAnnouncementLocked_ (
        IN  BSTR    bstrAnnouncement
        )
{
        HRESULT hr;
        UCHAR *pAnnouncement = NULL;
        UINT ulLength;

    if (m_State != STATE_CONNECTED) {

        hr = ATVEFSEND_E_OBJECT_NOT_CONNECTED ;
        goto cleanup ;
    }

    hr = m_csdpSource.GetRawAnnouncement (&ulLength, (CHAR **) & pAnnouncement, bstrAnnouncement) ;
        if(FAILED(hr))
                goto cleanup;

    //  all of these were checked during connection
    assert (SUCCEEDED (hr)) ;
    assert (pAnnouncement) ;
    assert (ulLength > 0) ;

 //   hr = m_Transmitter [ENH_ANNOUNCEMENT] -> Send (pAnnouncement, ulLength) ;
    hr = m_Transmitter [ENH_ANNOUNCEMENT] -> SendThrottled (pAnnouncement, ulLength) ;
    delete pAnnouncement ;

 cleanup :

        return hr;
}
// compare this code with CTVETrigger::ParseTrigger() which reverses what this does.
//			if rTVELevel is 0.0 (or less) doesn't send the tve level flag.  For transportA, should be exactly 1.0
//			if fAppendCRC is true, adds CRC field to the trigger
HRESULT
CATVEFAnnouncement::SendTriggerLocked_ (BSTR bstrURL, BSTR bstrName, BSTR bstrScript, DATE dateExpires, float rTVELevel, BOOL fAppendCRC)
{
    HRESULT     hr ;
    CHAR        achBuffer [MAX_TRIGGER_LENGTH];

	if (bstrURL == NULL || bstrURL [0] == L'\0') 
	{
        return E_INVALIDARG ;
    }

     if (m_State != STATE_CONNECTED) {
        return ATVEFSEND_E_OBJECT_NOT_CONNECTED ;
    }

	hr = GenTrigger(achBuffer,  MAX_TRIGGER_LENGTH, 
					bstrURL, bstrName, bstrScript, dateExpires, 
					/* fShortForm*/ false,  /*rTVELevel*/ 0, /*fAppendCRC*/ false);

	if(FAILED(hr))
		return hr;

    //  and transmit
    hr = m_Transmitter [ENH_TRIGGER]->SendThrottled ((BYTE *) achBuffer, strlen (achBuffer) + 1) ;

    return hr ;

}

HRESULT
CATVEFAnnouncement::SendRawTriggerLocked_(BSTR bstrRawTrigger, BOOL fAppendCRC)
{
	USES_CONVERSION;
	HRESULT hr;

    if (m_State != STATE_CONNECTED) {
        return ATVEFSEND_E_OBJECT_NOT_CONNECTED ;
    }

	if (bstrRawTrigger == NULL || bstrRawTrigger [0] == L'\0') 
        return E_INVALIDARG ;
 
	int len = wcslen(bstrRawTrigger);
	if(len > MAX_TRIGGER_LENGTH - (fAppendCRC ? 6 : 0)) 
		return ATVEFSEND_E_TRIGGER_TOO_LONG;

	BYTE *pszChar = (BYTE *) W2A(bstrRawTrigger);
	BYTE *pszLast = pszChar + len;

	if(fAppendCRC)
	{
		CComBSTR spbsCRC = ChkSumA((char *) pszChar);
		*pszLast++ = '[';
		for(int i = 0; i < 4; i++)
			*pszLast++ = spbsCRC[i];
		*pszLast++ = ']';
		*pszLast = 0;			// cap it off

		len += 6;				
	}

	hr = m_Transmitter [ENH_TRIGGER] -> SendThrottled (pszChar, len + 1) ;
	return hr;
}

// -----------------------------------------------------------------------
// -----------------------------------------------------------------------

_COM_SMARTPTR_TYPEDEF(IATVEFPackage_Helper, __uuidof(IATVEFPackage_Helper));
_COM_SMARTPTR_TYPEDEF(IATVEFPackage_Test, __uuidof(IATVEFPackage_Test));

HRESULT 
CATVEFAnnouncement::SendPackageLocked_(IATVEFPackage *pITVEPackage)
{
    INT             iLength ;
    HRESULT         hr ;
 

    ENTERW_OBJ_1 (L"CATVEFAnnouncement::SendPackage (%08XH)", pITVEPackage) ;

    if (pITVEPackage == NULL) {
        return E_POINTER ;
    }

 	IATVEFPackage_HelperPtr spPkgHlpr;
	hr = pITVEPackage->QueryInterface(&spPkgHlpr);
	if(FAILED(hr)) 
		return hr;

    Lock_ () ;
    spPkgHlpr->Lock() ;


    //  look for the immediate disqualifier
    if (m_State != STATE_CONNECTED) {
        hr = ATVEFSEND_E_OBJECT_NOT_CONNECTED ;
        goto cleanup ;
    }

    assert (m_Transmitter [ENH_PACKAGE]) ;

    //  in case some datagrams have already been sent out of this package, reset npw
    hr = spPkgHlpr -> ResetDatagramFetch () ;
    if (FAILED (hr)) {
        goto cleanup ;
    }

    //  loop and send all datagrams
	{
		CComBSTR bstrBuff;
 
#if 1 // Added by a-clardi
		long nPacket = 0;
#endif
		for (;;) {
			hr = spPkgHlpr -> FetchNextDatagram (&bstrBuff, &iLength) ;

			if (FAILED (hr) || iLength == 0) {
				break ;		// all done
			}

#if 1 // Added by a-clardi
			// If it is in corrupt mode, get the packets to corrupt
			CComQIPtr<IATVEFPackage_Test> pPkgTest(pITVEPackage);
			if (pPkgTest != NULL)
			{					
				INT bMode = 0; 
					
				hr = pPkgTest->GetCorruptMode(nPacket, &bMode);
				nPacket++;
				if (bMode == 2)
				{
					bstrBuff.m_str[0] ^= 0xff;
				}

				if (bMode != 1)
				{
					hr = m_Transmitter [ENH_PACKAGE] -> SendThrottled ((unsigned char *) bstrBuff.m_str, iLength) ;
				}
			}
			else
				hr = m_Transmitter [ENH_PACKAGE] -> SendThrottled ((unsigned char *) bstrBuff.m_str, iLength) ;
#else
			hr = m_Transmitter [ENH_PACKAGE] -> SendThrottled ((unsigned char *) bstrBuff.m_str, iLength) ;
#endif					
			if (FAILED (hr)) {
				break ;
			}
		}
	}

 cleanup :

    spPkgHlpr -> Unlock () ;
    Unlock_ () ;
	
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tveattrm.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEAttrM.cpp : Implementation of CATVEFAttrMap
#include "stdafx.h"
#include "ATVEFSend.h"
#include "TVEAttrM.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CATVEFAttrMap

STDMETHODIMP CATVEFAttrMap::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATVEFAttrMap
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tveattrl.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEAttrL.h : Declaration of the CATVEFAttrList
//
//		A BSTR (key) to BSTR (value) list  (not a map)
//			This class contains a list of key/value pairs, where both keys and values are BSTRs.
//			The keys don't need to be unique. However, searching on the key will only
//			return the first value entered.
//	
//			Implemented as a list of key/value pairs.
//
//			This supports a threadsafe standard enumerator, which returns values in the map
//			in inserted order.  
//
//
//	Problem -  The NEXT method on the enumerator only returns the values of the (key/value) pair.  
//		This sort of makes the enumerator worthless.  Use the Key() and Item() methods yourself
//		with a numeric index to get both.
//
//
//	Was templated - supports types of:
//		TVal	- CComBSTR
//		TKey	- CComBSTR
//
//	This supports the interface members of:
//
//		get_Count(long *plCount)
//				Returns number of elements in this collection.
//		get__NewEnum(IUnknown **ppunk)
//				Returns a standard, threadsafe enumerator to this collecion.  (It copies the whole
//				map). BUG the Enumerator only returns the Values, not the keys!
//
//		get_Item(VARIANT var, TVal *pT )
//				Supported input variant types are strings and numeric values.  If of string type, then
//				it returns the value associated with BSTR key.  If numeric, returns the n'th
//				item's value (in inserted order).   Access is not
//				fast, particularly for all elements in the collection.   
//				This method returns S_OK if success, and S_FALSE if the 
//				item with the specifed key (or index) isn't in the collection.
//		get_Key(VARIANT var, TKey *pT)
//				This does reverse lookup, returning the key associated with a given value.
//				Supported var variant types are strings and numeric values.  If of string type, then
//				it returns the *first* key whose value matches that passed in (it may not be a 1-1 mapping
//			    of values back to keys).  If numeric, returns the n'th keys's value (in 
//				inserted order).   This returns S_OK if success, 
//				and S_FALSE if the item with the specifed value (or index) isn't in the collection.
//				--> This method is intended for debugging only - it is not fast.  
//		Add(TKey rKey, TVal rVal)		
//				Appends a new <key,value> pair to the list.  It doesn't check for duplicate 
//				values.
//
//		Add1(TVal rVal)		
//				Adds a new <value> to the list, creating a unique key for it.
//				(Key is ID number in "NNN" format, such as "007").  This allows the
//				map to be used to contain simple arrays of TVals, accessed with the 
//				number variant version of get_Item().  It's possible to mix two forms 
//				in the same collection, but avoid keys of 'NNN'.  (Assumes less than 1000 elements
//				in the map, sort will fail if larger. - change %03d to something larger.)
//				For best results remember: shaken, not stirred.
//
//		Replace(TKey rKey, TVal rVal)
//				Replaces the value at the given key in the list, and if successful, returns S_OK.
//			    If the key can not be found in the list, it adds a new key/value and returns S_FALSE.  
//				(E.g. this is like Add(), but it overwrites the old value.)
//		Remove(VARIANT varIn)
//				Removes either element in the list with the given key if varIn is a string form,
//				otherwise the n'th element (alphabetical order) if it's numeric.  It returns S_FALSE
//				if the item isn't there to remove.	Strange effects with Add1 key number here.
//		RemoveAll()
//				Removes all elements in the collection (just what did you expect?)
//
//	local methods
//
//		get_Item(BSTR bstr, TVal *pT )		
//				This returns the value associated with a given key.  This
//				is algorithmically fastest method to retreive values from this collection.
//				This returns S_FALSE if the item with the specified key isn't in the collection.
//
//		Item(VARIANT var, TVal *pT)
//		Key(VARIANT var, TKey *pK)
//			return the given value/first-key given the associated key/value or 
//			an index into the list
//
//		ItemIter(VARIANT varIn, ListT::iterator &iIter)
//		ItemKey(VARIANT varIn, ListT::iterator &iIter)
//			return iterator to the given value/first-key given the associated key/value 
//			or index into the list.
//
//		DumpToBSTR(BSTR *pBstr)
//			Returns a string containing all the elements in the list, suitable for debugging
//			of the form {key1:val1 | key2:val2 | ... keyN:valN}
//			This string must be free'ed by the caller.
//			
//
//	Note : this class is almost templatized.  What's stopping me is the comparison ('=') operator
//		on the Key and Value data types.  Currently, it's hardcoded to wcscmp().
//
//	----------------------------------------
#ifndef __ATVEFATTRLIST_H_
#define __ATVEFATTRLIST_H_

#include "resource.h"       // main symbols

#include "comdef.h"
#include "valid.h"		// ENTER_API, EXIT_API classes

#include <list>					// std List class
#include <vector>
#include <map>
// --------------------------------------------------------------------
//  IEnumVARIANT implementation
// ---------------------------------------------------------------------
class CSafeEnumTVEList :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_ATVEFSENDLib>
{

	typedef CSafeEnumTVEList				ThisClassSEALTVE;
	typedef	IATVEFAttrList					BaseT;

	typedef BSTR							TKey;
	typedef BSTR							TVal;
	typedef	std::pair<CComBSTR, CComBSTR>	PairT;
	typedef std::list<PairT>				ListT;				
		

public:
	CSafeEnumTVEList()
	{
		m_punk		= NULL;
		m_iIterCur	= m_listT.begin();
		m_iCur		= 0;
	}

	~CSafeEnumTVEList()  
	{
	}

	void FinalRelease()
	{
		m_listT.clear();

		if (m_punk != NULL)
			m_punk->Release();
	}

	void Init(IUnknown *punk, ListT *plistT)		// change to const ListT &rmapT???
	{
		if (m_punk != NULL)
		{
			m_punk->Release();
			m_punk = NULL;
		}

		if(NULL == plistT) return;		// bogus!!!

		if (punk != NULL)				// back pointer to containing class
		{
//			punk->AddRef();
//			m_punk = punk;
		}
		
								// copy the whole list (this is slow but safe!)
		EnterCriticalSection(&_Module.m_csTypeInfoHolder);
		{	
//			m_listT = *plistT;					// wonder if this will work?
			ListT::iterator iIter;
			for(iIter = plistT->begin(); iIter != plistT->end(); iIter++)
			{
				TKey   key = (*iIter).first;  
				TVal   val = (*iIter).second;
				
				PairT	p(key,val);
			//	ListT::value_type keyval(key, val);
				m_listT.push_back(p);
				
//				m_listT.insert((*iIter));
			}
		}	
		LeaveCriticalSection(&_Module.m_csTypeInfoHolder);

		m_iCur = 0;
		m_iIterCur = m_listT.begin();
	}

BEGIN_COM_MAP(ThisClassSEALTVE)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

	// IEnumUnknown interface  -- get the next celt elements  -- BUG: Only returns the values!
	STDMETHOD(Next)(ULONG celt, VARIANT *pvar, ULONG *pceltFetched)
		{
		ENTER_API
			{
			ULONG celtFetched = 0;
			int iMax = m_listT.size();

			if ((pvar == NULL) || ((celt > 1) && (pceltFetched == NULL)))
				return E_POINTER;
			
			for (ULONG l=0; l < celt; l++)
				VariantInit( &pvar[l] ) ;

			while ((m_iCur < iMax) && (celtFetched < celt))
			{
				TKey tvK = (*m_iIterCur).first;
				TVal tvT = (*m_iIterCur).second;

							// stuff into a variant...
				CComVariant *pcvvar = (CComVariant *) pvar;
				*pcvvar = tvT;

				pvar++;
				celtFetched++;
				m_iIterCur++;	m_iCur++;
			}
			
			if (pceltFetched != NULL)
				*pceltFetched = celtFetched;
			
			return (celtFetched == celt) ? S_OK : S_FALSE;
			}
		EXIT_API
		}
	
	STDMETHOD(Skip)(ULONG celt)
		{
		ENTER_API
			{
				m_iCur += celt;
			
				if(m_iCur < m_listT.size())
				{
					for(int i = 0; i < celt; i++)
						m_iIterCur++;
					return S_OK;
				} else {
					m_iIterCur = m_listT.end();
					return S_FALSE;
				}
			}
		EXIT_API
		}
	
	STDMETHOD(Reset)(void)
		{
		ENTER_API
			{
				m_iCur = 0;
				m_iIterCur = m_listT.begin();
				return S_OK;
			}
		EXIT_API
		}
	
	STDMETHOD(Clone)(IEnumVARIANT **ppenum)
		{
		ENTER_API
			{
				static char THIS_FILE[] = __FILE__;	// for debug version of NewComObject
				ThisClassSEALTVE *penum = NewComObject(ThisClassSEALTVE);

				if (penum == NULL)
					return E_OUTOFMEMORY;

				penum->Init(m_punk, &m_listT);
				penum->m_iCur = m_iCur;
				for(int i = 0; i < m_iCur; i++)
					penum->m_iIterCur++;

				HRESULT hr = penum->QueryInterface(IID_IEnumVARIANT, (void **)ppenum);
				if(!FAILED(hr)) 
					penum->Release();
				return hr;
			}
		EXIT_API
		}

protected:
	IUnknown		*m_punk;			// back pointer to list class, to keep it alive
	ListT			m_listT;			// complete copy of the list, not pointer!
	ListT::iterator	m_iIterCur;			// actual iterator into m_listT  -- keep these 2 in sync --
	int				m_iCur;				// index of location into list   -- keep these 2 in sync --
};
/////////////////////////////////////////////////////////////////////////////
// CATVEFAttrList
class ATL_NO_VTABLE CATVEFAttrList : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATVEFAttrList, &CLSID_ATVEFAttrList>,
	public ISupportErrorInfo,
	public IDispatchImpl<IATVEFAttrList, &IID_IATVEFAttrList, &LIBID_ATVEFSENDLib>
{
	typedef	IATVEFAttrList					BaseT;
	typedef CATVEFAttrList					ThisClassTVEAM;

	typedef BSTR							TKey;
	typedef BSTR							TVal;

	typedef	std::pair<CComBSTR, CComBSTR>	PairT;		// nasty here, not exactly same as TKey,TVal 
	typedef std::list<PairT>				ListT;
	typedef CSafeEnumTVEList				EnumTVEListT;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_ATVEFATTRLIST)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATVEFAttrList)
	COM_INTERFACE_ENTRY(IATVEFAttrList)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IATVEFAttrList
public:
	CATVEFAttrList()
	{
		m_cLast = 0;
	}

	~CATVEFAttrList()
	{
		RemoveAll();
	}


	virtual BOOL FOkToRemove()
	{
		return TRUE;
	}
	

	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
	{
		ENTER_API
		{
			HRESULT hr;
			ValidateOutPtr<IUnknown *>(ppunk, NULL);

			static char THIS_FILE[] = __FILE__;	// for debug version of NewComObject
			EnumTVEListT *penum = NewComObject(EnumTVEListT);
			if (penum == NULL)
				return E_OUTOFMEMORY;
			
			penum->Init((IUnknown *)(BaseT *)this, &m_listT);

//			hr =  penum->QueryInterface(IID_IEnumString, (void **)ppunk);
			hr =  penum->QueryInterface(IID_IEnumVARIANT, (void **)ppunk);
			penum->Release();			// need this...
			return hr;
		}
		EXIT_API
	}
	
	STDMETHOD(get_Count)(long *plCount)
	{
		ENTER_API
		{
			ValidateOutPtr<long>(plCount, NULL);

			if (plCount == NULL)
				return E_POINTER;
			
			*plCount = m_listT.size();
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(TKey key, TVal *pT )			// slow - Find uses simple O(N) string match
	{
		ENTER_API
		{	
			ValidateOutPtr<TVal>(pT, NULL);

			ListT::iterator iterFind = Find(key); 
			if(iterFind != m_listT.end()) 
			{
				CComBSTR spB = (*iterFind).second;		// create copy of object (bad - no typedef here)	
				*pT = spB.Detach();						// copies pointer
			} else {
				return S_FALSE;
			}
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(VARIANT varKey, TVal *pT )
	{
		return Item(varKey, pT);		// all inline, error handling down lower...
	}

	STDMETHOD(get_Key)(VARIANT varValue, TVal *pT )
	{
		return Key(varValue, pT);
	}

	STDMETHOD(Add)(TKey rKey, TVal rVal)		// returns S_FALSE if key already in use, but doesn't overwrite old one
	{
		ENTER_API
		{
			ListT::value_type keyval(rKey, rVal);
			m_listT.push_back(keyval);
			return S_OK;
		}
		EXIT_API
	}
	
	STDMETHOD(Add1)(TVal rVal)		// returns S_FALSE if key already in use, but doesn't overwrite old one
	{
		ENTER_API
		{
			TKey rKey;
			wchar_t wcsbuff[10];
			swprintf(wcsbuff,L"%03d",m_cLast++);
			rKey = wcsbuff;

			ListT::value_type keyval(rKey, rVal);
			m_listT.push_back(keyval);
			return S_OK;
		}
		EXIT_API
	}

	STDMETHOD(Replace)(TKey rKey, TVal rVal)		// returns S_FALSE if key not there yet.
	{
		ENTER_API
		{
			BOOL fAlreadyThere = (m_listT.end() != Find(rKey));
//			m_listT[rKey] = rVal;					// cool overloaded operator
			return fAlreadyThere ? S_OK : S_FALSE ;	// if not already there, (and we added it), return S_FALSE instead 
		}
		EXIT_API
	}
	
	STDMETHOD(Remove)(VARIANT varIn)
	{
		ENTER_API
		{
			CComVariant var(varIn);
			switch (var.vt)
			{
			case VT_BSTR:		// only works for STRING type keys
				{
					var.ChangeType(VT_BSTR);			// blow up perhaps if wrong casting
					
					ListT::iterator iIter = Find(var.bstrVal);
					if(m_listT.end() != iIter) {
						m_listT.erase(iIter);
						return S_OK;
					} else {
						return S_FALSE;
					}
				}
				break;

			default:				// slight different that above, since this only removes 1 object (by iter)
				{					//   and the above erase removes all keys with the same name
					ListT::iterator iIter;
					HRESULT hr = ItemIter(var, iIter);
					if(S_OK == hr) 
					{
						if(m_listT.end() != m_listT.erase(iIter))	// returns end() if item not there
							return S_OK;
						else
							return E_UNEXPECTED;				// this should never happen
					} else {
						return hr;
					}
				}
				break;
			}					// end switch
		return E_FAIL;		// should never get here...
			return E_NOTIMPL;
		}
		EXIT_API
	}
	
	STDMETHOD(RemoveAll)()
	{
		ENTER_API
		{
			//if(!m_listT.empty())
			//	m_listT.erase(m_listT.begin(),m_listT.end());
			m_listT.clear();
			m_cLast = 0;			// restart the Add1 count...
			return S_OK;
		}
		EXIT_API
	}

	STDMETHOD(Item)(VARIANT varKey, TVal *pT)
	{
		ENTER_API
		{
			ValidateOutPtr<TVal>(pT, NULL);

			ListT::iterator iIter;
			HRESULT hr = ItemIter(varKey, iIter);
			if(S_OK == hr) {
				CComBSTR spB = (*iIter).second;			// creates new copy of the value
				*pT = spB.Detach();						// copies pointer
			} 
			return hr;
		}
		EXIT_API
	}


	STDMETHOD(Key)(VARIANT varValue, TVal *pT)
	{
		ENTER_API
		{
			ValidateOutPtr<TVal>(pT, NULL);

			ListT::iterator iIter;
			HRESULT hr = KeyIter(varValue, iIter);
			if(S_OK == hr) {
				CComBSTR spB = (*iIter).first;			// creates new copy of the key
				*pT = spB.Detach();						// copies pointer
			} 
			return hr;
		}
		EXIT_API
	}
								// local routine to set iter to given item
	HRESULT ItemIter(VARIANT varIn, ListT::iterator &iIter)
	{
		CComVariant var(varIn);
		int index;

		switch (var.vt)
		{
		case VT_BSTR:		// only works for STRING type keys
			{
				var.ChangeType(VT_BSTR);			// blow up perhaps if wrong casting
				
									// use iter to find matching key...
				ListT::iterator iterLoop;
				for(iIter = m_listT.begin(); iIter != m_listT.end(); iIter++)
				{
					TKey *pKey = &((*iIter).first);	
					if(0 == wcscmp(var.bstrVal, *pKey))		// find first value matching input one
					{										//  (there may be more)
						return S_OK;
					}
				}
				iIter = m_listT.end();
				return S_FALSE;				// didn't find it..
			}
			break;

		default:
			{
				var.ChangeType(VT_I4);
				index = var.lVal;


				if(index < 0 || index >= m_listT.size())
					return S_FALSE;

				// use iterator here to get n'th value  
				for(iIter = m_listT.begin(); 
					 index > 0 /*&& iter != m_listT.end()*/; 
					--index, iIter++)
					{
						;
					}
				return S_OK;
			}
			break;
		}					// end switch
		return E_FAIL;		// should never get here...
	}						// end function

	
								// local routine to return iter to given item
	HRESULT KeyIter(VARIANT varIn, ListT::iterator &iIter)
	{
		CComVariant var(varIn);
		int index;

		switch (var.vt)
		{
		case VT_BSTR:		// only works for STRING type keys
			{
				var.ChangeType(VT_BSTR);			// blow up perhaps if wrong casting

				ListT::iterator iterLoop;
				for(iIter = m_listT.begin(); iIter != m_listT.end(); iIter++)
				{
					TVal *pValue = &((*iIter).second);	
					if(0 == wcscmp(var.bstrVal, *pValue))	// find first value matching input one
					{										//  (there may be more)
						return S_OK;
					}
				}
				iIter = m_listT.end();
				return S_FALSE;				// didn't find it..
			}
			break;

		default:
			{
				var.ChangeType(VT_I4);
				index = var.lVal;


				if(index < 0 || index >= m_listT.size())
				{
					iIter = m_listT.end();
					return S_FALSE;
				}

				// use iterator here to get n'th value  (slow, but hey... better than nothing)
				for(iIter = m_listT.begin(); 
					 index > 0/*&& iter != m_listT.end()*/; 
					--index, iIter++)
						;
						
				return S_OK;
			}
			break;
		}					// end switch
		return E_FAIL;		// should never get here...
	}						// end function

								// local routine to set iter to given item
	ListT::iterator Find(TKey &rKey)
	{
									// use iter to find matching key...
		ListT::iterator iterLoop;
		const TKey crKey = rKey;
		for(iterLoop = m_listT.begin(); iterLoop != m_listT.end(); iterLoop++)
		{
			TKey *pKey = &((*iterLoop).first);	
			if(0 == wcscmp(crKey, *pKey))		// find first value matching input one
			{									//  (there may be more)
				return iterLoop;
			}
		}
		iterLoop = m_listT.end();
		return iterLoop;					// didn't find it..
	}
	
	STDMETHOD(DumpToBSTR)(BSTR *pBstrBuff)			// should be in a _helper interface
	{
		char *pLeak1 = new char[100];
		memset(pLeak1,1,100);
		delete pLeak1;

		char *pLeak2 = new char[100];
		memset(pLeak2,1,100);

		const int kMaxChars=256;
		TCHAR tBuff[kMaxChars];
		CComBSTR bstrOut;
		bstrOut.Empty();

		ListT::iterator iIter;
		int i = 0;
		bstrOut.Append("{");
		for(iIter = m_listT.begin(); iIter != m_listT.end(); iIter++, i++)
		{
			if(i != 0) { _stprintf(tBuff,_T(" | ")); bstrOut.Append(tBuff); }
			_stprintf(tBuff,_T("%S:%S"),(*iIter).first,(*iIter).second);
			bstrOut.Append(tBuff);
		}
		bstrOut.Append("}");
		bstrOut.CopyTo(pBstrBuff);
		return S_OK;
	}

	ListT	m_listT;							// base collection object..
	int		m_cLast;						// last Add1() item (to handle deletes)

};

#endif //__ATVEFATTRLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\trees.cpp ===
/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-1996 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */

/* $Id: trees.c,v 1.11 1996/07/24 13:41:06 me Exp $ */

#include "stdafx.h"
#include "deflate.h"

#ifdef DEBUG
#  include <ctype.h>
#endif


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/* ===========================================================================
 * Constants
 */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

local int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

local int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

local int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

local uch bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

#define Buf_size (8 * 2*sizeof(char))
/* Number of bits used within bi_buf. (bi_buf might be implemented on
 * more than 16 bits on some systems.)
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

local ct_data static_ltree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

local ct_data static_dtree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

local uch dist_code[512];
/* distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

local uch length_code[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

local int base_length[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

local int base_dist[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

struct static_tree_desc_s {
    ct_data *static_tree;        /* static tree or NULL */
    intf    *extra_bits;         /* extra bits for each code or NULL */
    int     extra_base;          /* base index for extra_bits */
    int     elems;               /* max number of elements in the tree */
    int     max_length;          /* max bit length for the codes */
};

local static_tree_desc  static_l_desc =
{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

local static_tree_desc  static_d_desc =
{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

local static_tree_desc  static_bl_desc =
{(ct_data *)0, extra_blbits, 0,      BL_CODES, MAX_BL_BITS};

/* ===========================================================================
 * Local (static) routines in this file.
 */

local void tr_static_init OF((void));
local void init_block     OF((deflate_state *s));
local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
local void build_tree     OF((deflate_state *s, tree_desc *desc));
local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local int  build_bl_tree  OF((deflate_state *s));
local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                              int blcodes));
local void compress_block OF((deflate_state *s, ct_data *ltree,
                              ct_data *dtree));
local void set_data_type  OF((deflate_state *s));
local unsigned bi_reverse OF((unsigned value, int length));
local void bi_windup      OF((deflate_state *s));
local void bi_flush       OF((deflate_state *s));
local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
                              int header));

#ifndef DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   /* Send a code of the given tree. c and tree must not have side effects */

#else /* DEBUG */
#  define send_code(s, c, tree) \
     { if (verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif

#define d_code(dist) \
   ((dist) < 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])
/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. dist_code[256] and dist_code[257] are never
 * used.
 */

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
#define put_short(s, w) { \
    put_byte(s, (uch)((w) & 0xff)); \
    put_byte(s, (uch)((ush)(w) >> 8)); \
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
#ifdef DEBUG
local void send_bits      OF((deflate_state *s, int value, int length));

local void send_bits(s, value, length)
    deflate_state *s;
    int value;  /* value to send */
    int length; /* number of bits */
{
    Tracevv((stderr," l %2d v %4x ", length, value));
    Assert(length > 0 && length <= 15, "invalid length");
    s->bits_sent += (ulg)length;

    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if (s->bi_valid > (int)Buf_size - length) {
        s->bi_buf |= (value << s->bi_valid);
        put_short(s, s->bi_buf);
        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
        s->bi_valid += length - Buf_size;
    } else {
        s->bi_buf |= value << s->bi_valid;
        s->bi_valid += length;
    }
}
#else /* !DEBUG */

#define send_bits(s, value, length) \
{ int len = length;\
  if (s->bi_valid > (int)Buf_size - len) {\
    int val = value;\
    s->bi_buf |= (val << s->bi_valid);\
    put_short(s, s->bi_buf);\
    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
    s->bi_valid += len - Buf_size;\
  } else {\
    s->bi_buf |= (value) << s->bi_valid;\
    s->bi_valid += len;\
  }\
}
#endif /* DEBUG */


#define MAX(a,b) (a >= b ? a : b)
/* the arguments must not have side effects */

/* ===========================================================================
 * Initialize the various 'constant' tables. In a multi-threaded environment,
 * this function may be called by two threads concurrently, but this is
 * harmless since both invocations do exactly the same thing.
 */
local void tr_static_init()
{
    static int static_init_done = 0;
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */
    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    if (static_init_done) return;

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            length_code[length++] = (uch)code;
        }
    }
    Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    length_code[length-1] = (uch)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            dist_code[dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            dist_code[256 + dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
    n = 0;
    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        static_dtree[n].Len = 5;
        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
    }
    static_init_done = 1;
}

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
void _tr_init(s)
    deflate_state *s;
{
    tr_static_init();

    s->compressed_len = 0L;

    s->l_desc.dyn_tree = s->dyn_ltree;
    s->l_desc.stat_desc = &static_l_desc;

    s->d_desc.dyn_tree = s->dyn_dtree;
    s->d_desc.stat_desc = &static_d_desc;

    s->bl_desc.dyn_tree = s->bl_tree;
    s->bl_desc.stat_desc = &static_bl_desc;

    s->bi_buf = 0;
    s->bi_valid = 0;
    s->last_eob_len = 8; /* enough lookahead for inflate */
#ifdef DEBUG
    s->bits_sent = 0L;
#endif

    /* Initialize the first block of the first file: */
    init_block(s);
}

/* ===========================================================================
 * Initialize a new block.
 */
local void init_block(s)
    deflate_state *s;
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

    s->dyn_ltree[END_BLOCK].Freq = 1;
    s->opt_len = s->static_len = 0L;
    s->last_lit = s->matches = 0;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top) \
{\
    top = s->heap[SMALLEST]; \
    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth) \
   (tree[n].Freq < tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
local void pqdownheap(s, tree, k)
    deflate_state *s;
    ct_data *tree;  /* the tree to restore */
    int k;               /* node to move down */
{
    int v = s->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= s->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s->heap_len &&
            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s->heap[j], s->depth)) break;

        /* Exchange v with the smallest son */
        s->heap[k] = s->heap[j];  k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    s->heap[k] = v;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
local void gen_bitlen(s, desc)
    deflate_state *s;
    tree_desc *desc;    /* the tree descriptor */
{
    ct_data *tree  = desc->dyn_tree;
    int max_code   = desc->max_code;
    ct_data *stree = desc->stat_desc->static_tree;
    intf *extra    = desc->stat_desc->extra_bits;
    int base       = desc->stat_desc->extra_base;
    int max_length = desc->stat_desc->max_length;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    ush f;              /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        n = s->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (ush)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) continue; /* not a leaf node */

        s->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        s->opt_len += (ulg)f * (bits + xbits);
        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
    }
    if (overflow == 0) return;

    Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (s->bl_count[bits] == 0) bits--;
        s->bl_count[bits]--;      /* move one leaf down the tree */
        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        s->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = s->bl_count[bits];
        while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if (tree[m].Len != (unsigned) bits) {
                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s->opt_len += ((long)bits - (long)tree[m].Len)
                              *(long)tree[m].Freq;
                tree[m].Len = (ush)bits;
            }
            n--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
local void gen_codes (tree, max_code, bl_count)
    ct_data *tree;             /* the tree to decorate */
    int max_code;              /* largest code with non zero frequency */
    ushf *bl_count;            /* number of codes at each bit length */
{
    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
    ush code = 0;              /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = bi_reverse(next_code[len]++, len);

        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
local void build_tree(s, desc)
    deflate_state *s;
    tree_desc *desc; /* the tree descriptor */
{
    ct_data *tree   = desc->dyn_tree;
    ct_data *stree  = desc->stat_desc->static_tree;
    int elems       = desc->stat_desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s->heap_len = 0, s->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s->heap_len < 2) {
        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
        tree[node].Freq = 1;
        s->depth[node] = 0;
        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        /* node is 0 or 1 so it does not have extra bits */
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
        pqremove(s, tree, n);  /* n = node of least frequency */
        m = s->heap[SMALLEST]; /* m = node of next least frequency */

        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        s->heap[--(s->heap_max)] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = tree[n].Freq + tree[m].Freq;
        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (ush)node;
#ifdef DUMP_BL_TREE
        if (tree == s->bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        s->heap[SMALLEST] = node++;
        pqdownheap(s, tree, SMALLEST);

    } while (s->heap_len >= 2);

    s->heap[--(s->heap_max)] = s->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, (tree_desc *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes ((ct_data *)tree, max_code, s->bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
local void scan_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree;   /* the tree to be scanned */
    int max_code;    /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (ush)0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            s->bl_tree[curlen].Freq += count;
        } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
        } else {
            s->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
local void send_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree; /* the tree to be scanned */
    int max_code;       /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(s, curlen, s->bl_tree); count--;
            }
            Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

        } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
local int build_bl_tree(s)
    deflate_state *s;
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, (tree_desc *)(&(s->bl_desc)));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    s->opt_len += 3*(max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            s->opt_len, s->static_len));

    return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
local void send_all_trees(s, lcodes, dcodes, blcodes)
    deflate_state *s;
    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
    int rank;                    /* index in bl_order */

    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes-1,   5);
    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Send a stored block
 */
void _tr_stored_block(s, buf, stored_len, eof)
    deflate_state *s;
    charf *buf;       /* input block */
    ulg stored_len;   /* length of input block */
    int eof;          /* true if this is the last block for a file */
{
    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
    s->compressed_len += (stored_len + 4) << 3;

    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 * The current inflate code requires 9 bits of lookahead. If the
 * last two codes for the previous block (real code plus EOB) were coded
 * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
 * the last real code. In this case we send two empty static blocks instead
 * of one. (There are no problems if the previous block is stored or fixed.)
 * To simplify the code, we assume the worst case of last real code encoded
 * on one bit only.
 */
void _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
    bi_flush(s);
    /* Of the 10 bits for the empty block, we have already sent
     * (10 - bi_valid) bits. The lookahead for the last real code (before
     * the EOB of the previous block) was thus at least one plus the length
     * of the EOB plus what we have just sent of the empty static block.
     */
    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
        send_bits(s, STATIC_TREES<<1, 3);
        send_code(s, END_BLOCK, static_ltree);
        s->compressed_len += 10L;
        bi_flush(s);
    }
    s->last_eob_len = 7;
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file. This function
 * returns the total compressed length for the file so far.
 */
ulg _tr_flush_block(s, buf, stored_len, eof)
    deflate_state *s;
    charf *buf;       /* input block, or NULL if too old */
    ulg stored_len;   /* length of input block */
    int eof;          /* true if this is the last block for a file */
{
    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex = 0;  /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s->level > 0) {

	 /* Check if the file is ascii or binary */
	if (s->data_type == Z_UNKNOWN) set_data_type(s);

	/* Construct the literal and distance trees */
	build_tree(s, (tree_desc *)(&(s->l_desc)));
	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));

	build_tree(s, (tree_desc *)(&(s->d_desc)));
	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));
	/* At this point, opt_len and static_len are the total bit lengths of
	 * the compressed block data, excluding the tree representations.
	 */

	/* Build the bit length tree for the above two trees, and get the index
	 * in bl_order of the last bit length code to send.
	 */
	max_blindex = build_bl_tree(s);

	/* Determine the best encoding. Compute first the block length in bytes*/
	opt_lenb = (s->opt_len+3+7)>>3;
	static_lenb = (s->static_len+3+7)>>3;

	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
		s->last_lit));

	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

    } else {
        Assert(buf != (char*)0, "lost buf");
	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

    /* If compression failed and this is the first and last block,
     * and if the .zip file can be seeked (to rewrite the local header),
     * the whole file is transformed into a stored file:
     */
#ifdef STORED_FILE_OK
#  ifdef FORCE_STORED_FILE
    if (eof && s->compressed_len == 0L) { /* force stored file */
#  else
    if (stored_len <= opt_lenb && eof && s->compressed_len==0L && seekable()) {
#  endif
        /* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
        if (buf == (charf*)0) error ("block vanished");

        copy_block(buf, (unsigned)stored_len, 0); /* without header */
        s->compressed_len = stored_len << 3;
        s->method = STORED;
    } else
#endif /* STORED_FILE_OK */

#ifdef FORCE_STORED
    if (buf != (char*)0) { /* force stored block */
#else
    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
                       /* 4: two words for the lengths */
#endif
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, eof);

#ifdef FORCE_STATIC
    } else if (static_lenb >= 0) { /* force static trees */
#else
    } else if (static_lenb == opt_lenb) {
#endif
        send_bits(s, (STATIC_TREES<<1)+eof, 3);
        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
        s->compressed_len += 3 + s->static_len;
    } else {
        send_bits(s, (DYN_TREES<<1)+eof, 3);
        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                       max_blindex+1);
        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
        s->compressed_len += 3 + s->opt_len;
    }
    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    init_block(s);

    if (eof) {
        bi_windup(s);
        s->compressed_len += 7;  /* align on byte boundary */
    }
    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
           s->compressed_len-7*eof));

    return s->compressed_len >> 3;
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int _tr_tally (s, dist, lc)
    deflate_state *s;
    unsigned dist;  /* distance of matched string */
    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
    s->d_buf[s->last_lit] = (ush)dist;
    s->l_buf[s->last_lit++] = (uch)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        s->dyn_ltree[lc].Freq++;
    } else {
        s->matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert((ush)dist < (ush)MAX_DIST(s) &&
               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s->dyn_ltree[length_code[lc]+LITERALS+1].Freq++;
        s->dyn_dtree[d_code(dist)].Freq++;
    }

    /* Try to guess if it is profitable to stop the current block here */
    if (s->level > 2 && (s->last_lit & 0xfff) == 0) {
        /* Compute an upper bound for the compressed length */
        ulg out_length = (ulg)s->last_lit*8L;
        ulg in_length = (ulg)((long)s->strstart - s->block_start);
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                (5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               s->last_lit, in_length, out_length,
               100L - out_length*100L/in_length));
        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
    }
    return (s->last_lit == s->lit_bufsize-1);
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
local void compress_block(s, ltree, dtree)
    deflate_state *s;
    ct_data *ltree; /* literal tree */
    ct_data *dtree; /* distance tree */
{
    unsigned dist;      /* distance of matched string */
    int lc;             /* match length or unmatched char (if dist == 0) */
    unsigned lx = 0;    /* running index in l_buf */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */

    if (s->last_lit != 0) do {
        dist = s->d_buf[lx];
        lc = s->l_buf[lx++];
        if (dist == 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = length_code[lc];
            send_code(s, code+LITERALS+1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra != 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra != 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);   /* send the extra distance bits */
            }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");

    } while (lx < s->last_lit);

    send_code(s, END_BLOCK, ltree);
    s->last_eob_len = ltree[END_BLOCK].Len;
}

/* ===========================================================================
 * Set the data type to ASCII or BINARY, using a crude approximation:
 * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
 * IN assertion: the fields freq of dyn_ltree are set and the total of all
 * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
 */
local void set_data_type(s)
    deflate_state *s;
{
    int n = 0;
    unsigned ascii_freq = 0;
    unsigned bin_freq = 0;
    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
local unsigned bi_reverse(code, len)
    unsigned code; /* the value to invert */
    int len;       /* its bit length */
{
    register unsigned res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return res >> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
local void bi_flush(s)
    deflate_state *s;
{
    if (s->bi_valid == 16) {
        put_short(s, s->bi_buf);
        s->bi_buf = 0;
        s->bi_valid = 0;
    } else if (s->bi_valid >= 8) {
        put_byte(s, (Byte)s->bi_buf);
        s->bi_buf >>= 8;
        s->bi_valid -= 8;
    }
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
local void bi_windup(s)
    deflate_state *s;
{
    if (s->bi_valid > 8) {
        put_short(s, s->bi_buf);
    } else if (s->bi_valid > 0) {
        put_byte(s, (Byte)s->bi_buf);
    }
    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
local void copy_block(s, buf, len, header)
    deflate_state *s;
    charf    *buf;    /* the input data */
    unsigned len;     /* its length */
    int      header;  /* true if block header must be written */
{
    bi_windup(s);        /* align on byte boundary */
    s->last_eob_len = 8; /* enough lookahead for inflate */

    if (header) {
        put_short(s, (ush)len);   
        put_short(s, (ush)~len);
#ifdef DEBUG
        s->bits_sent += 2*16;
#endif
    }
#ifdef DEBUG
    s->bits_sent += (ulg)len<<3;
#endif
    while (len--) {
        put_byte(s, *buf++);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tveannc.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEAnnc.h : Declaration of the CATVEFAnnouncement

#ifndef __ATVEFANNOUNCEMENT_H_
#define __ATVEFANNOUNCEMENT_H_

#include "resource.h"       // main symbols

#include <comdef.h>
#include <time.h>
#include <crtdbg.h>
#include <tchar.h>

#include "Trace.h"			// tracing stuff
#include "CSdpSrc.h"

#include "xmit.h"			// CMulticastTransmitter

class CATVEFMulticastSession;
class CATVEFInserterSession;
class CATVEFRouterSession;
class CATVEFLine21Session;


/////////////////////////////////////////////////////////////////////////////
// CATVEFAnnouncement
class ATL_NO_VTABLE CATVEFAnnouncement : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATVEFAnnouncement, &CLSID_ATVEFAnnouncement>,
	public ISupportErrorInfo,
	public IDispatchImpl<IATVEFAnnouncement, &IID_IATVEFAnnouncement, &LIBID_ATVEFSENDLib>
{
public:
	friend CATVEFMulticastSession;
	friend CATVEFInserterSession;
	friend CATVEFRouterSession;
	friend CATVEFLine21Session;

	CATVEFAnnouncement();
	CATVEFAnnouncement::~CATVEFAnnouncement ();

	HRESULT FinalConstruct();
	HRESULT	FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_ATVEFANNOUNCEMENT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATVEFAnnouncement)
	COM_INTERFACE_ENTRY(IATVEFAnnouncement)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IATVEFAnnouncement
	STDMETHOD(get_SAPMessageIDHash)(/*[out, retval]*/ SHORT *pVal);
	STDMETHOD(put_SAPMessageIDHash)(/*[in]*/ SHORT newVal);
	STDMETHOD(get_SAPSendingIP)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_SAPSendingIP)(/*[in]*/ LONG newVal);
	STDMETHOD(get_SAPDeleteAnnc)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_SAPDeleteAnnc)(/*[in]*/ BOOL newVal);

	STDMETHOD(get_SendingIP)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_SendingIP)(/*[in]*/ LONG newVal);
	STDMETHOD(get_SessionVersion)(/*[out, retval]*/ INT *pVal);
	STDMETHOD(put_SessionVersion)(/*[in]*/ INT newVal);
	STDMETHOD(get_SessionURL)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SessionURL)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_MaxCacheSize)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_MaxCacheSize)(/*[in]*/ LONG newVal);
	STDMETHOD(get_ContentLevelID)(/*[out, retval]*/ float *pVal);
	STDMETHOD(put_ContentLevelID)(/*[in]*/ float newVal);
	STDMETHOD(get_LangID)(/*[out, retval]*/ SHORT *pVal);
	STDMETHOD(put_LangID)(/*[in]*/ SHORT newVal);
	STDMETHOD(get_SDPLangID)(/*[out, retval]*/ SHORT *pVal);
	STDMETHOD(put_SDPLangID)(/*[in]*/ SHORT newVal);
	STDMETHOD(get_Primary)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_Primary)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_SecondsToEnd)(/*[out, retval]*/ INT *pVal);
	STDMETHOD(put_SecondsToEnd)(/*[in]*/ INT newVal);
	STDMETHOD(get_SessionLabel)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SessionLabel)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_UUID)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_UUID)(/*[in]*/ BSTR newVal);
			// new properties
	STDMETHOD(get_SessionName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SessionName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SessionID)(/*[out, retval]*/ INT *pVal);
	STDMETHOD(put_SessionID)(/*[in]*/ INT newVal);
	STDMETHOD(get_UserName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_UserName)(/*[in]*/ BSTR newVal);
			// methods
	STDMETHOD(GetStartStopTime)(/*in*/ int iLoc, /*[out]*/ DATE *pStart, /*[out]*/ DATE *pStop);
	STDMETHOD(AddStartStopTime)(/*[in]*/ DATE dateStart,/*[in]*/ DATE dateStop);
	STDMETHOD(AddEmailAddress)(BSTR bstrName, BSTR bstrAddress);
	STDMETHOD(AddPhoneNumber)(BSTR bstrName, BSTR bstrPhoneNumber);
	STDMETHOD(AddExtraAttribute)(BSTR bstrKey, BSTR bstrValue);
	STDMETHOD(AddExtraFlag)(BSTR bstrKey, BSTR bstrValue);
	STDMETHOD(ClearTimes)();
	STDMETHOD(ClearEmailAddresses)();
	STDMETHOD(ClearPhoneNumbers)();
	STDMETHOD(ClearExtraAttributes)();
	STDMETHOD(ClearExtraFlags)();

	STDMETHOD(ConfigureDataAndTriggerTransmission)(LONG IP, SHORT Port, INT TTL, LONG MaxBandwidth);
	STDMETHOD(ConfigureDataTransmission)(LONG IP, SHORT Port, INT TTL, LONG MaxBandwidth);
	STDMETHOD(ConfigureTriggerTransmission)(LONG IP, SHORT Port, INT TTL, LONG MaxBandwidth);
	STDMETHOD(ConfigureAnncTransmission)(LONG IP, SHORT Port, INT scope, LONG MaxBitRate);

	STDMETHOD(get_EmailAddresses)(/*[out, retval]*/ IDispatch **ppVal);
	STDMETHOD(get_PhoneNumbers)(/*[out, retval]*/ IDispatch **ppVal);
	STDMETHOD(get_ExtraAttributes)(/*[out, retval]*/ IDispatch **ppVal);
	STDMETHOD(get_ExtraFlags)(/*[out, retval]*/ IDispatch **ppVal);

			// media messages
	STDMETHOD(get_MediaCount)(/*[out, retval]*/ LONG* pVal);
	STDMETHOD(get_Media)(/*[in]*/ LONG iLoc, /*[out, retval]*/ IATVEFMedia* *pVal);
	STDMETHOD(SetCurrentMedia)(/*[in]*/ long lMediaID);		

			// Helper methods
	STDMETHOD(DumpToBSTR)(/*[out]*/ BSTR *pBstrBuff);
	STDMETHOD(AnncToBSTR)(/*[out]*/ BSTR *pBstrBuff);


		//  class constants;
    enum {
        DEFAULT_SCOPE       = 2,
        MAX_TRIGGER_LENGTH  = ETHERNET_MTU_UDP_PAYLOAD_SIZE,  //  effective length = 1471 because of null-terminator
    } ;

protected:
     enum {
            ENH_ANNOUNCEMENT,
            ENH_PACKAGE,
            ENH_TRIGGER,
            ENH_COMPONENT_COUNT
     } ;

    //  member properties
    CRITICAL_SECTION            m_crt ;                                         //  class-wide lock
    CMulticastTransmitter *     m_Transmitter [ENH_COMPONENT_COUNT] ;           //
 
	void
    Shutdown_ ()
	  {} ;

    void
    Lock_ ()
    {
        ENTER_CRITICAL_SECTION (m_crt, CTVEAnnouncement::Lock_)
    }

    void
    Unlock_ ()
    {
        LEAVE_CRITICAL_SECTION (m_crt, CTVEAnnouncement::Unlock_)
    }


    //  states are updated by descendants ONLY
    enum  SESSION_STATE {
        STATE_UNINITIALIZED,    //  object is newly formed; must be 
                                //   initialized before it can be used

        STATE_INITIALIZED,      //  object was successfully initialized; it
                                //   may have gone through a connect/
                                //   disconnect cycle already; announcement
                                //   transmitter may be connected, but not
                                //   trigger and package transmitters

        STATE_CONNECTED,        //  all transmitters are connected and able
                                //   to transmit

        STATE_COUNT
    } ;
	SESSION_STATE               m_State ;  
	
	//  must hold the lock before making the call; state must be connecting;
    //  if over a tunnel, route should be created
    virtual HRESULT
    ConnectLocked_ () ;

    //  must hold the lock before making the call
    virtual HRESULT
    DisconnectLocked_ () ;

    HRESULT
    GetIPLocked_ (
        IN  DWORD       Component,
        OUT ULONG *     pIP
        ) ;

    //  must hold the lock before making the call
    HRESULT
    SetIPLocked_ (      
		IN  DWORD       Component,
        IN  ULONG      pIP
       ) ;

    HRESULT
    GetPortLocked_ (
        IN  DWORD       Component,
        OUT USHORT *    pPort
        ) ;

    //  must hold the lock before making the call
    HRESULT
    SetPortLocked_ (
        IN  DWORD   Component,
        IN  USHORT  Port
        ) ;

    HRESULT
    SetBitRateLocked_ (
        IN  DWORD   Component,
        IN  DWORD   BitRate
        ) ;

    HRESULT
    SetMulticastScopeLocked_ (
        IN  DWORD   Component,
        IN  INT     MulticastScope
        ) ;

    HRESULT
    GetMulticastScopeLocked_ (
        IN  DWORD   Component,
        OUT INT *   pMulticastScope
        ) ;

	HRESULT
	InitializeLocked_ (
		CMulticastTransmitter * pAnnouncementTransmitter,
		CMulticastTransmitter * pPackageTransmitter,
		CMulticastTransmitter * pTriggerTransmitter
		);

	HRESULT SetParent(IUnknown *punkParent)			// can only set once (can't change) - parent is not ref counted
	{
		if(punkParent != NULL) {assert(NULL == m_punkParent); return E_FAIL;}
		m_punkParent = punkParent; 
		return S_OK;
	} 

	HRESULT SetCurrentMediaLocked_(long lMediaID);
	HRESULT SendAnnouncementLocked_();
	HRESULT SendRawAnnouncementLocked_(BSTR bstrAnnouncement);
	HRESULT SendPackageLocked_(IATVEFPackage *pPackage);
	HRESULT SendTriggerLocked_(BSTR bstrURL, BSTR bstrName, BSTR bstrScript, DATE dateExpires, float rTVELevel, BOOL fAppendCRC);
	HRESULT SendRawTriggerLocked_(BSTR bstrRawTrigger, BOOL fAppendCRC);
private:
	IUnknown	*m_punkParent;			// containing object (not ref counted!)
	CSDPSource	m_csdpSource;
};

#endif //__ATVEFANNOUNCEMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tveattrm.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEAttrM.h : Declaration of the CATVEFAttrMap
//
//			This is a copy of TVEContr/TVEAttrMap... Just didn't want to have to load
//			that DLL into the TVEControl dll...
//
//		A BSTR (key) to BSTR (value) map
//			This class maps keys to values, where both keys and values are BSTRs.
//			The keys must be unique, (adding duplicate keys either returns S_FALSE
//			or overwrites the old key).  
//
//			This supports a threadsafe standard enumerator, which returns values in the map
//			in alphabetical order.  
//
//	Was templated - supports types of:
//		TVal	- CComBSTR
//		TKey	- CComBSTR
//
//	This supports the interface members of:
//
//		get_Count(long *plCount)
//				Returns number of elements in this collection.
//		get__NewEnum(IUnknown **ppunk)
//				Returns a standard, threadsafe enumerator to this collecion.  (It copies the whole
//				map).
//		get_Item(VARIANT var, TVal *pT )
//				Supported input variant types are strings and numeric values.  If of string type, then
//				it returns the value associated with BSTR key.  If numeric, returns the n'th
//				item's value (in alphabetical, rather than inserted order).   Numeric access is not
//				fast, particularly for all elements in the collection.   
//				This method returns S_OK if success, and S_FALSE if the 
//				item with the specifed key (or index) isn't in the collection.
//		get_Key(VARIANT var, TKey *pT)
//				This does reverse lookup, returning the key assoicated with a given value.
//				Supported var variant types are strings and numeric values.  If of string type, then
//				it returns the *first* key whose value matches that passed in (it may not be a 1-1 mapping
//			    of values back to keys).  If numeric, returns the n'th keys's value (in 
//				alphabetical, rather than inserted order).   This returns S_OK if success, 
//				and S_FALSE if the item with the specifed value (or index) isn't in the collection.
//				--> This method is intended for debugging only - it is not fast.  
//		Add(TKey rKey, TVal rVal)		
//				Adds a new <key,value> pair to the map.  If the key already in use, it
//				doesn't overwrite the old value.  Instead it returns S_FALSE.
//		Add1(TVal rVal)		
//				Adds a new <value> to the map, creating a unique key for it.
//				(Key is ID number in "NNN" format, such as "007").  This allows the
//				map to be used to contain simple arrays of TVals, accessed with the 
//				number variant version of get_Item().  It's possible to mix two forms 
//				in the same collection, but avoid keys of 'NNN'.  (Assumes less than 1000 elements
//				in the map, sort will fail if larger. - change %03d to something larger.)
//
//		Replace(TKey rKey, TVal rVal)
//				Replaces the value at the given key in the map, and if successful, returns S_OK.
//			    If the key can not be found in the map, it adds a new key/value and returns S_FALSE.  
//				(E.g. this is like Add(), but it overwrites the old value.)
//		Remove(VARIANT varIn)
//				Removes either element in the map with the given key if varIn is a string form,
//				otherwise the n'th element (alphabetical order) if it's numeric.  It returns S_FALSE
//				if the item isn't there to remove.	Strange effects with Add1 key number here.
//		RemoveAll()
//				Removes all elements in the collection (just what did you expect?)
//
//	local methods
//
//		get_Item(BSTR bstr, TVal *pT )		
//				This returns the value associated with a given key.  This
//				is algorithmically fastest method to retreive values from this collection.
//				This returns S_FALSE if the item with the specified key isn't in the collection.
//
//		Item(VARIANT var, TVal *pT)
//		Key(VARIANT var, TKey *pK)
//			return the given value/first-key given the associated key/value or 
//			an index into the map
//
//		ItemIter(VARIANT varIn, MapT::iterator &iIter)
//		ItemKey(VARIANT varIn, MapT::iterator &iIter)
//			return iterator to the given value/first-key given the associated key/value 
//			or index into the map
// 
#ifndef __ATVEFATTRMAP_H_
#define __ATVEFATTRMAP_H_

#include "resource.h"       // main symbols
#include "comdef.h"
#include "valid.h"		// ENTER_API, EXIT_API classes

#include <map>
// --------------------------------------------------------------------
//  IEnumVARIANT version
// ---------------------------------------------------------------------
class CSafeEnumTVEMap :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_ATVEFSENDLib>
{

	typedef BSTR							TKey;
	typedef BSTR							TVal;
	typedef	IATVEFAttrMap					BaseT;

	typedef std::map<CComBSTR, CComBSTR>	MapT;				
		
	typedef CSafeEnumTVEMap					ThisClassSEAMTVE;

public:
	CSafeEnumTVEMap()
	{
		m_punk		= NULL;
		m_iIterCur	= m_mapT.begin();
		m_iCur		= 0;
	}

	~CSafeEnumTVEMap()  
	{
	}

	void FinalRelease()
	{
		m_mapT.clear();

		if (m_punk != NULL)
			m_punk->Release();
	}

	void Init(IUnknown *punk, MapT *pmapT)		// change to const MapT &rmapT???
	{
		if (m_punk != NULL)
		{
			m_punk->Release();
			m_punk = NULL;
		}

		if(NULL == pmapT) return;		// bogus!!!

		if (punk != NULL)				// back pointer to containing class
		{
//			punk->AddRef();
//			m_punk = punk;
		}
		
								// copy the whole map (this is slow but safe!)
		EnterCriticalSection(&_Module.m_csTypeInfoHolder);
		{	
//			m_mapT = *pmapT;					// wonder if this will work?
			MapT::iterator iIter;
			for(iIter = pmapT->begin(); iIter != pmapT->end(); iIter++)
			{
	//			MapT::value_type keyval(rKey, rVal);
				m_mapT.insert((*iIter));
			}
		}	
		LeaveCriticalSection(&_Module.m_csTypeInfoHolder);

		m_iCur = 0;
		m_iIterCur = m_mapT.begin();
	}

BEGIN_COM_MAP(ThisClassSEAMTVE)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

	// IEnumUnknown interface  -- get the next celt elements
	STDMETHOD(Next)(ULONG celt, VARIANT *pvar, ULONG *pceltFetched)
		{
		ENTER_API
			{
			ULONG celtFetched = 0;
			int iMax = m_mapT.size();

			if ((pvar == NULL) || ((celt > 1) && (pceltFetched == NULL)))
				return E_POINTER;
			
			for (ULONG l=0; l < celt; l++)
				VariantInit( &pvar[l] ) ;

			while ((m_iCur < iMax) && (celtFetched < celt))
			{
				TKey tvK = (*m_iIterCur).first;
				TVal tvT = (*m_iIterCur).second;
				BSTR bstrVal(tvT);

			//	pvar = new CComVariant(tvT);		// doesn't work
				
			//	pvar->vt	  = VT_BSTR;					// major pain in the butt here
			//	pvar->bstrVal = ::SysAllocString(tvT);		//  the CComVariant above didn't work
															//  and no 'transfer' like function	

													// slightly more formal way (if not slower)
													// since it does better error handling
				CComVariant *pcvvar = (CComVariant *) pvar;
				*pcvvar = tvT;

				pvar++;
				celtFetched++;
				m_iIterCur++;	m_iCur++;
			}
			
			if (pceltFetched != NULL)
				*pceltFetched = celtFetched;
			
			return (celtFetched == celt) ? S_OK : S_FALSE;
			}
		EXIT_API
		}
	
	STDMETHOD(Skip)(ULONG celt)
		{
		ENTER_API
			{
				m_iCur += celt;
			
				if(m_iCur < m_mapT.size())
				{
					for(int i = 0; i < celt; i++)
						m_iIterCur++;
					return S_OK;
				} else {
					m_iIterCur = m_mapT.end();
					return S_FALSE;
				}
			}
		EXIT_API
		}
	
	STDMETHOD(Reset)(void)
		{
		ENTER_API
			{
				m_iCur = 0;
				m_iIterCur = m_mapT.begin();
				return S_OK;
			}
		EXIT_API
		}
	
	STDMETHOD(Clone)(IEnumVARIANT **ppenum)
		{
		ENTER_API
			{
				static char THIS_FILE[] = __FILE__;	// for debug version of NewComObject
				ThisClassSEAMTVE *penum = NewComObject(ThisClassSEAMTVE);

				if (penum == NULL)
					return E_OUTOFMEMORY;

				penum->Init(m_punk, &m_mapT);
				penum->m_iCur = m_iCur;
				for(int i = 0; i < m_iCur; i++)
					penum->m_iIterCur++;

				HRESULT hr = penum->QueryInterface(IID_IEnumVARIANT, (void **)ppenum);
				if(!FAILED(hr)) 
					penum->Release();
				return hr;
			}
		EXIT_API
		}

protected:
	IUnknown		*m_punk;			// back pointer to map class, to keep it alive
	MapT			m_mapT;				// complete copy of the map, not pointer!
	MapT::iterator	m_iIterCur;			// actual iterator into m_mapT  -- keep these 2 in sync --
	int				m_iCur;				// index of location into map   -- keep these 2 in sync --
};
/////////////////////////////////////////////////////////////////////////////
// CATVEFAttrMap
class ATL_NO_VTABLE CATVEFAttrMap : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATVEFAttrMap, &CLSID_ATVEFAttrMap>,
	public ISupportErrorInfo,
	public IDispatchImpl<IATVEFAttrMap, &IID_IATVEFAttrMap, &LIBID_ATVEFSENDLib>
{
	typedef BSTR							TKey;
	typedef BSTR							TVal;
	typedef	IATVEFAttrMap					BaseT;

	typedef CATVEFAttrMap					ThisClassTVEAM;
	typedef std::map<CComBSTR, CComBSTR>	MapT;
	typedef CSafeEnumTVEMap					EnumTVEMapT;

public:
DECLARE_REGISTRY_RESOURCEID(IDR_ATVEFATTRMAP)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATVEFAttrMap)
	COM_INTERFACE_ENTRY(IATVEFAttrMap)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IATVEFAttrMap
public:
	CATVEFAttrMap()
	{
		m_cLast = 0;
	}

	~CATVEFAttrMap()
	{
		RemoveAll();
	}


	virtual BOOL FOkToRemove()
	{
		return TRUE;
	}
	

	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
	{
		ENTER_API
		{
			HRESULT hr;
			ValidateOutPtr<IUnknown *>(ppunk, NULL);

			static char THIS_FILE[] = __FILE__;	// for debug version of NewComObject
			EnumTVEMapT *penum = NewComObject(EnumTVEMapT);
			if (penum == NULL)
				return E_OUTOFMEMORY;
			
			penum->Init((IUnknown *)(BaseT *)this, &m_mapT);

//			hr =  penum->QueryInterface(IID_IEnumString, (void **)ppunk);
			hr =  penum->QueryInterface(IID_IEnumVARIANT, (void **)ppunk);
			penum->Release();			// need this...
			return hr;
		}
		EXIT_API
	}
	
	STDMETHOD(get_Count)(long *plCount)
	{
		ENTER_API
		{
			ValidateOutPtr<long>(plCount, NULL);

			if (plCount == NULL)
				return E_POINTER;
			
			*plCount = m_mapT.size();
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(BSTR bstr, TVal *pT )			// fast (but for string-compares) - uses map
	{
		ENTER_API
		{	
			ValidateOutPtr<TVal>(pT, NULL);

			MapT::iterator iterFind = m_mapT.find(bstr); 
			if(iterFind != m_mapT.end()) 
			{
				CComBSTR spB = (*iterFind).second;
				*pT = spB.Detach();				// copies pointer
			} else {
				return S_FALSE;
			}
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(VARIANT varKey, TVal *pT )
	{
		return Item(varKey, pT);		// all inline, error handling down lower...
	}

	STDMETHOD(get_Key)(VARIANT varValue, TVal *pT )
	{
		return Key(varValue, pT);
	}

	STDMETHOD(Add)(TKey rKey, TVal rVal)		// returns S_FALSE if key already in use, but doesn't overwrite old one
	{
		ENTER_API
		{
			MapT::iterator mit = m_mapT.find(rKey);
			if(mit != m_mapT.end())
				return S_FALSE;
			std::pair<MapT::iterator, bool> pi;
			MapT::value_type keyval(rKey, rVal);
			pi = m_mapT.insert(keyval);
//			if(pi.second == false) return E_UNEXPECTED;
			return S_OK;
		}
		EXIT_API
	}
	
	STDMETHOD(Add1)(TVal rVal)		// returns S_FALSE if key already in use, but doesn't overwrite old one
	{
		ENTER_API
		{
			TKey rKey;
			wchar_t wcsbuff[10];
			swprintf(wcsbuff,L"%03d",m_cLast++);
			rKey = wcsbuff;

			MapT::iterator mit = m_mapT.find(rKey);		// paranoia...
			if(mit != m_mapT.end())
				return E_UNEXPECTED;

			std::pair<MapT::iterator, bool> pi;
			MapT::value_type keyval(rKey, rVal);
			pi = m_mapT.insert(keyval);
			return S_OK;
		}
		EXIT_API
	}

	STDMETHOD(Replace)(TKey rKey, TVal rVal)		// returns S_FALSE if key not there yet.
	{
		ENTER_API
		{
			BOOL fAlreadyThere = (m_mapT.end() != m_mapT.find(rKey));
			m_mapT[rKey] = rVal;					// cool overloaded operator
			return fAlreadyThere ? S_OK : S_FALSE ;	// if not already there, (and we added it), return S_FALSE instead 
		}
		EXIT_API
	}
	
	STDMETHOD(Remove)(VARIANT varIn)
	{
		ENTER_API
		{
			CComVariant var(varIn);
			switch (var.vt)
			{
			case VT_BSTR:		// only works for STRING type keys
				{
					var.ChangeType(VT_BSTR);			// blow up perhaps if wrong casting
					
					int iRemove = m_mapT.erase(var.bstrVal);
					if(iRemove > 0) {
						return S_OK;
					} else {
						return S_FALSE;
					}
				}
				break;

			default:				// slight different that above, since this only removes 1 object (by iter)
				{					//   and the above erase removes all keys with the same name
					MapT::iterator iIter;
					HRESULT hr = ItemIter(var, iIter);
					if(S_OK == hr) 
					{
						if(m_mapT.end() != m_mapT.erase(iIter))	// returns end() if item not there
							return S_OK;
						else
							return E_UNEXPECTED;				// this should never happen
					} else {
						return hr;
					}
				}
				break;
			}					// end switch
		return E_FAIL;		// should never get here...
			return E_NOTIMPL;
		}
		EXIT_API
	}
	
	STDMETHOD(RemoveAll)()
	{
		ENTER_API
		{
			//if(!m_mapT.empty())
			//	m_mapT.erase(m_mapT.begin(),m_mapT.end());
			m_mapT.clear();
			m_cLast = 0;			// restart the Add1 count...
			return S_OK;
		}
		EXIT_API
	}

	STDMETHOD(Item)(VARIANT varKey, TVal *pT)
	{
		ENTER_API
		{
			ValidateOutPtr<TVal>(pT, NULL);

			MapT::iterator iIter;
			HRESULT hr = ItemIter(varKey, iIter);
			if(S_OK == hr) {
				CComBSTR spB = (*iIter).second;			// creates new copy of the value
				*pT = spB.Detach();						// copies pointer
			} 
			return hr;
		}
		EXIT_API
	}


	STDMETHOD(Key)(VARIANT varValue, TVal *pT)
	{
		ENTER_API
		{
			ValidateOutPtr<TVal>(pT, NULL);

			MapT::iterator iIter;
			HRESULT hr = KeyIter(varValue, iIter);
			if(S_OK == hr) {
				CComBSTR spB = (*iIter).first;			// creates new copy of the key
				*pT = spB.Detach();						// copies pointer
			} 
			return hr;
		}
		EXIT_API
	}
								// local routine to set iter to given item
	HRESULT ItemIter(VARIANT varIn, MapT::iterator &iIter)
	{
		CComVariant var(varIn);
		int index;

		switch (var.vt)
		{
		case VT_BSTR:		// only works for STRING type keys
			{
				var.ChangeType(VT_BSTR);			// blow up perhaps if wrong casting
				
				iIter = m_mapT.find(var.bstrVal);
				if(iIter != m_mapT.end()) {
					return S_OK;
				} else {
					return S_FALSE;
				}
			}
			break;

		default:
			{
				var.ChangeType(VT_I4);
				index = var.lVal;


				if(index < 0 || index >= m_mapT.size())
					return S_FALSE;

				// use iterator here to get n'th value  (slow, but hey... better than nothing)
				for(iIter = m_mapT.begin(); 
					 index > 0 /*&& iter != m_mapT.end()*/; 
					--index, iIter++)
					{
						;
					}
				return S_OK;
			}
			break;
		}					// end switch
		return E_FAIL;		// should never get here...
	}						// end function

	
								// local routine to return iter to given item
	HRESULT KeyIter(VARIANT varIn, MapT::iterator &iIter)
	{
		CComVariant var(varIn);
		int index;

		switch (var.vt)
		{
		case VT_BSTR:		// only works for STRING type keys
			{
				var.ChangeType(VT_BSTR);			// blow up perhaps if wrong casting

				MapT::iterator iterLoop;
				for(iIter = m_mapT.begin(); iIter != m_mapT.end(); iIter++)
				{
					BSTR *pValue = &((*iIter).second);	
					if(0 == wcscmp(var.bstrVal, *pValue))	// find first value matching input one
					{										//  (there may be more)
						return S_OK;
					}
				}
				iIter = m_mapT.end();
				return S_FALSE;				// didn't find it..
			}
			break;

		default:
			{
				var.ChangeType(VT_I4);
				index = var.lVal;


				if(index < 0 || index >= m_mapT.size())
				{
					iIter = m_mapT.end();
					return S_FALSE;
				}

				// use iterator here to get n'th value  (slow, but hey... better than nothing)
				for(iIter = m_mapT.begin(); 
					 index > 0/*&& iter != m_mapT.end()*/; 
					--index, iIter++)
						;
						
				return S_OK;
			}
			break;
		}					// end switch
		return E_FAIL;		// should never get here...
	}						// end function

	STDMETHOD(DumpToBSTR)(BSTR *pBstrBuff)			// should be in a _helper interface
	{
		const int kMaxChars=256;
		TCHAR tBuff[kMaxChars];
		CComBSTR bstrOut;
		bstrOut.Empty();

		MapT::iterator iIter;
		int i = 0;
		bstrOut.Append(L"{");
		for(iIter = m_mapT.begin(); iIter != m_mapT.end(); iIter++, i++)
		{
			if(i != 0) { _stprintf(tBuff,_T(" | ")); bstrOut.Append(tBuff); }
			_stprintf(tBuff,_T("%S:%S"),(*iIter).first,(*iIter).second);
			bstrOut.Append(tBuff);
		}
		bstrOut.Append(L"}");
		bstrOut.CopyTo(pBstrBuff);
		return S_OK;
	}

	MapT	m_mapT;							// base collection object..
	int		m_cLast;						// last Add1() item (to handle deletes)

};

#endif //__ATVEFATTRMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tveinsert.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEInsert.cpp : Implementation of CATVEFInserterSession
#include "stdafx.h"
#include "ATVEFSend.h"
#include "TVEInsert.h"

#include "DbgStuff.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CATVEFInserterSession



STDMETHODIMP CATVEFInserterSession::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATVEFInserterSession
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
// ----------------------------------------------------------------
HRESULT CATVEFInserterSession::FinalConstruct()
{		
	HRESULT hr = S_OK;

	CComObject<CATVEFAnnouncement> *pAnnc;
	hr = CComObject<CATVEFAnnouncement>::CreateInstance(&pAnnc);
	if(FAILED(hr))
		return hr;

	m_pcotveAnnc = pAnnc;
	m_pcotveAnnc->AddRef();			// strange we need this, doesn't createInstance do this?

				// would like to set the parent of m_pcotveAnnc back to *this here,
				//   but can't since ref-count of this is currently zero (inc'ed to 1)
				//   right after this call.  The QI to IUnknown does an AddRef, and
				//	 the release brings the ref count back to zero, causing *this to
				//	 be deleted...  Do it in the Initialize() call below.
	return hr;
}

HRESULT CATVEFInserterSession::FinalRelease()
{
	m_pcotveAnnc->SetParent(NULL);
	m_pcotveAnnc->Release();
	m_pcotveAnnc = NULL;
	return S_OK;
}
// ----------------------------------------------------------------
STDMETHODIMP CATVEFInserterSession::Initialize(	
	IN  LONG   InserterIP,
    IN  SHORT  InserterPort)
{
//	int *pILeak = new int[12345];
	return InitializeEx(InserterIP, InserterPort, 0x00, 0x7f, 0x04);
}

STDMETHODIMP CATVEFInserterSession::InitializeEx(    
	IN  LONG   InserterIP,
    IN  SHORT  InserterPort,
    IN  SHORT  CompressionIndexMin,					//  byte range - default 0x00
    IN  SHORT  CompressionIndexMax,					//  byte range - default 0x7f
    IN  SHORT  CompressedUncompressedRatio)        //  default 4
{
/*++

    Routine Description:

        The purpose of this routine is to initialize an inserter object.

        Initialization consists of (1) making a TCP connection to the inserter,
        (2) initialization of m_IpVbi, which is the object which constructs
        IP/UDP headers, compresses the stream, and SLIP encodes, 
        (3) instantiation and initialization of our transmitters, (4)
        initialization of our parent CEnhancementSession object.

        We share a TCP connection between our 3 transmitters because the
        Norpak inserter can only accept 1 connection per port.  We share 1
        IpVbi object for all transmitters because the compression keys cannot
        overlap when we insert via the same inserter.  If we had separate IpVbi
        objects, the announcement multicast group and the data multicast group
        might share the same compression key, resulting in bogus packets on the
        client.

        All multi-threaded protection of the TCP connection and IpVbi objects
        is performed by this object, and the CATVEFAnnouncement, which 
        serializes all transmissions.

        This routine is called as a result of COM call to ::Initialize or
        ::InitializeEx.

        The object lock must be held during this call.

    Parameters:

        InserterIP                      host order IP address for the inserter

        InserterPort                    host order port on the inserter

        CompressionIndexMin             inclusive minimum compression key;
                                        validation is performed in the
                                        ::InitializeEx method.

        CompressionIndexMax             inclusive maximum compression key;
                                        validation is performed in the
                                        ::InitializeEx method.

        CompressedUncompressedRatio     ratio of compressed/uncompressed 
                                        packets.

    Return Value:

        S_OK            success
        failure code    failure

--*/

	HRESULT         hr ;
	CIPVBIEncoder * pAnnouncementTransmitter ;
	CIPVBIEncoder * pPackageTransmitter ;
	CIPVBIEncoder * pTriggerTransmitter ;
	ULONG           SourceIP ;
	char            Hostname [256] ;
	HOSTENT *       pHostent ;
	BOOL			fLocked = false;

	ENTERW_OBJ_0 (L"CInserterSession::InitializeEx") ;

/*
	//  already initialized ??
	if (m_State >= STATE_INITIALIZED) {
		return ATVEFSND_E_OBJECT_INITIALIZED ;
	}
	assert (m_InserterConnection.IsConnected () == FALSE) ;
*/
	//  start initialization

	//  initialize our transmitter object pointers
	pAnnouncementTransmitter = NULL ;
	pPackageTransmitter = NULL ;
	pTriggerTransmitter = NULL ;

	ENTER_API {

		//  we make 1 connection to the inserter for the duration of the session;
		//  this is done because the norpak inserter can only accept 1 connection
		//  for each ip/port per inserter; the other objects actually create 3
		//  connections (announcement, trigger, data), and 
		hr = m_InserterConnection.Connect (InserterIP, InserterPort) ;
		GOTO_NE (hr, S_OK, cleanup) ;

		//  now obtain the IP address which will stamped into all IP headers;
		//  m_InserterConnection should have initialized winsock if we are to
		//  here

		if (gethostname (Hostname, 256)) {
			hr = HRESULT_FROM_WIN32 (WSAGetLastError ()) ;
			assert (FAILED (hr)) ;
			goto cleanup ;
		}

		pHostent = gethostbyname (Hostname) ;
		if (pHostent == NULL) {
			hr = HRESULT_FROM_WIN32 (WSAGetLastError ()) ;
			assert (FAILED (hr)) ;
			goto cleanup ;
		}

		//  assert on this because we should never have connected if this is not 
		//  true
		assert (pHostent -> h_addr_list [0]) ;

		//  grab the first
		SourceIP = ntohl (* (ULONG *) pHostent -> h_addr_list [0]) ;

		//  now initialize our IpVbi object
		hr = m_IpVbi.Initialize (
						SourceIP,
						(USHORT) SOURCE_PORT,
						CompressionIndexMin,
						CompressionIndexMax,
						CompressedUncompressedRatio
						) ;
		GOTO_NE (hr, S_OK, cleanup) ;

		//  instantiate and initialize our transmission objects
		pAnnouncementTransmitter = new CIPVBIEncoder () ;
		GOTO_EQ_SET (pAnnouncementTransmitter, NULL, cleanup, hr, E_OUTOFMEMORY) ;

		pPackageTransmitter = new CIPVBIEncoder () ;
		GOTO_EQ_SET (pPackageTransmitter, NULL, cleanup, hr, E_OUTOFMEMORY) ;

		pTriggerTransmitter = new CIPVBIEncoder () ;
		GOTO_EQ_SET (pTriggerTransmitter, NULL, cleanup, hr, E_OUTOFMEMORY) ;

		hr = (pAnnouncementTransmitter -> Initialize (& m_InserterConnection, & m_IpVbi, FALSE)) ;
		GOTO_NE (hr, S_OK, cleanup) ;

		hr = (pPackageTransmitter -> Initialize (& m_InserterConnection, & m_IpVbi, TRUE)) ;
		GOTO_NE (hr, S_OK, cleanup) ;

		hr = (pTriggerTransmitter -> Initialize (& m_InserterConnection, & m_IpVbi, TRUE)) ;
		GOTO_NE (hr, S_OK, cleanup) ;

		//  now initialize our parent
		m_pcotveAnnc->Lock_ () ;
		fLocked = true;

		hr = m_pcotveAnnc->InitializeLocked_(
				pAnnouncementTransmitter, 
				pPackageTransmitter, 
				pTriggerTransmitter
				) ;
		if(FAILED(hr)) 
			goto cleanup;
											// setup the parent pointer in the announcement
		IUnknown *punkThis;
		hr = this->QueryInterface(IID_IUnknown, (void**) &punkThis);		
		if(FAILED(hr)) 
			goto cleanup;

		m_pcotveAnnc->SetParent(punkThis);		// point it's parent back up to this
		punkThis->Release();					// parent pointer not ref'ed, so release it (shouldn't go away!)

	} LEAVE_API;		// fall through, don't exit

cleanup :
	if(fLocked)
		m_pcotveAnnc->Unlock_() ;

	if (FAILED(hr))
	{
		delete pAnnouncementTransmitter ;
		delete pPackageTransmitter ;
		delete pTriggerTransmitter ;
		m_InserterConnection.Disconnect () ;

		Error(GetTVEError(hr), IID_IATVEFInserterSession);
	}
	return hr;
}

STDMETHODIMP 
CATVEFInserterSession::SetCurrentMedia(LONG lMedia)
{
	return  m_pcotveAnnc->SetCurrentMedia(lMedia);
}

STDMETHODIMP 
CATVEFInserterSession::DumpToBSTR(BSTR *pBstrBuff)
{
	CComBSTR spbsOut;
	TCHAR tBuff[128];

	m_pcotveAnnc->Lock_ () ;

	CComBSTR spbsX;
	ULONG  ulIP   = ntohl(m_IpVbi.m_StaticIPHeader.SourceIP);  
	USHORT usPort = ntohs(m_IpVbi.m_StaticUDPHeader.SourcePort);

	IN_ADDR  iaddr;
	iaddr.s_addr = htonl(ulIP);
	char	*pcIPString = inet_ntoa(iaddr);

	_stprintf(tBuff,_T("CATVEFInserterSession: (IP %s Port %d)\n"),
				pcIPString, usPort);
	spbsOut.Append(tBuff);
	spbsOut.CopyTo(pBstrBuff);

    m_pcotveAnnc->Unlock_ () ;
	return S_OK;

}

// -------------------------------------------------------------------------

STDMETHODIMP CATVEFInserterSession::get_Announcement(IDispatch **pVal)
{
	return  m_pcotveAnnc->QueryInterface(pVal);
}

STDMETHODIMP CATVEFInserterSession::Connect()
{
    HRESULT hr = S_OK;
	ENTERW_OBJ_0 (L"CATVEFInserterSession::Connect") ;

    m_pcotveAnnc->Lock_ () ;
	ENTER_API {

		if(!m_InserterConnection.IsConnected ())
			hr = m_InserterConnection.Connect();		// PBUG - reconnect if disconnected



		if(!FAILED(hr))
			hr = m_pcotveAnnc->ConnectLocked_();
 
	} LEAVE_API;

	m_pcotveAnnc->Unlock_ () ;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFInserterSession);

	return hr;
}

STDMETHODIMP CATVEFInserterSession::Disconnect()
{
	// TODO: Add your implementation code here
    HRESULT hr = S_OK;

    ENTERW_OBJ_0 (L"CTVEMulticastSession::Disconnect") ;

    m_pcotveAnnc->Lock_ () ;
	ENTER_API {
		
		hr = m_pcotveAnnc->DisconnectLocked_() ;

		m_InserterConnection.Disconnect () ;			// PBUG	- disconnect for real

  	} LEAVE_API;		// fall through, don't exit
	m_pcotveAnnc->Unlock_ () ;


	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFInserterSession);

    return hr ;
} 

STDMETHODIMP CATVEFInserterSession::SendRawAnnouncement(BSTR bstrAnnouncement)
{
/*++

    Routine Description:

        The purpose of this routine is transmit an announcement.  The object
        must be connected for this call to succeed.

    Parameters:

        none

    Return Value:

        S_OK            success
        failure code    failure

--*/
    HRESULT hr = S_OK;

    ENTERW_OBJ_0 (L"CATVEFInserterSession::SendRawAnnouncement") ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendRawAnnouncementLocked_(bstrAnnouncement) ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFInserterSession::SendRawAnnouncement - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFInserterSession);

    return hr ;

}


STDMETHODIMP CATVEFInserterSession::SendAnnouncement()
{
/*++

    Routine Description:

        The purpose of this routine is transmit an announcement.  The object
        must be connected for this call to succeed.

    Parameters:

        none

    Return Value:

        S_OK            success
        failure code    failure

--*/
    HRESULT hr = S_OK;

    ENTERW_OBJ_0 (L"CATVEFInserterSession::SendAnnouncement") ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendAnnouncementLocked_() ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFInserterSession::SendAnnouncement - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFInserterSession);

    return hr ;

}

STDMETHODIMP CATVEFInserterSession::SendPackage(IATVEFPackage *pPackage)
{
/*++

    Routine Description:
    Parameters:
    Return Value:

--*/
	HRESULT hr = S_OK ;

    ENTERW_OBJ_0 (L"CATVEFInserterSession::SendPackage") ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendPackageLocked_(pPackage) ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFInserterSession::SendPackage - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 
	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFInserterSession);

    return hr ;

}

STDMETHODIMP CATVEFInserterSession::SendTrigger(BSTR bstrURL, BSTR bstrName, BSTR bstrScript, DATE dateExpires)
{
/*++

    Routine Description:

        Triggers, per the ATVEF specification must be as follows:

        <url>[name:name_str][expires:expire_tm][script:script_str][checksum]

        We do not append a checksum.

        The total length of the trigger cannot exceed 1472 bytes, including the
        null-terminator.  Transmitted as an ASCII string.

        Object must be connected for this call to succeed.

    Parameters:

        szURL       cannot be NULL;

        szName      can be NULL or 0 length

        szScript    can be NULL or 0 length

        Expires     can be 0'd out and will then be ignored

    Return Values:

        S_OK            success
        error code      failure

--*/

    HRESULT hr ;

 	ENTERW_OBJ_3 (L"CATVEFInserterSession::SendTrigger (\n\t\"%s\", \n\t\"%s\", \n\t\"%s\")", 
		bstrURL, bstrName, bstrScript) ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendTriggerLocked_( bstrURL,  bstrName,  bstrScript,  dateExpires, /*level*/ 0.0, /*appendCRC*/ false) ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFInserterSession::SendTrigger - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 
	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFInserterSession);

    return hr ;
}

STDMETHODIMP CATVEFInserterSession::SendRawTrigger(BSTR bstrTrigger)
{
    HRESULT hr = S_OK;

 	ENTERW_OBJ_1 (L"CATVEFInserterSession::SendRawTrigger (\n\t\"%s\")", bstrTrigger) ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendRawTriggerLocked_( bstrTrigger, /*appendCRC*/ false) ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFInserterSession::SendRawTrigger - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 
	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFInserterSession);

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvecollect.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//  TVECollect.h
//   From Lee's (bpc\ca\caman\templ.h) :
//
//	// same as version in TVEControl
//
//	These templates create a collection class and a threadsafe enumerator
//	on that class.  <note - can make faster, non-threadsafe enumerator too
//	by changing enumerator type in class TVECollection>
//
//
//	To create a collection object CXXs (e.g. CTVETracks) with Interface
//	of ICXXs (e.g. ITVETracks), containing a set of objects with interfaces 
//	of IXX (e.g. ITVETrack)	declare something like this:
//
// class CXXs : public TVECollection<ICXX, ICXXs>
// {
//    public:
//		.. additional functions and methods.
//
// }
//
//
//
// STDMETHODS to support ITVECollection
//
//		HRESULT get__NewEnum(IUnknown **ppunk);
//			returns a new enumerator of type IEnumVARIANT.
//			User must release this item.
//
//		HRESULT get_Count(long *plCount);
//			returns number of items in collection in *plCount;
//
//		HRESULT Item(long index, T **ppT);
//		HRESULT get_Item(long index, T **ppT)
//		HRESULT get_Item(VARIANT var, T **ppT )
//			returns the index'th(0 based) item from the collection.  Returns
//			E_INVALIDARG if index out of range (<0 or >= count).
//			User must release this item.
//
//		HRESULT Add(T *pT);
//		HRESULT Add(IUnknown *punk);
//			Adds a new object to the end of the collection.  Returns S_FALSE
//			if that item already in the collection.  IUnknown version may return
//			E_INTERFACE if wrong object type passed.
//
//		HRESULT Remove(VARIANT var);
//			Removes an item. Variant may be a number, or a IUnknown or IDispatch
//			interface to an object in the collection.  Returns E_FAIL if can't
//			find the object.  May return E_INTERFACE is variant is the wrong type.
//			
//
//		internal class methods
//

//		HRESULT ItemIndex(VARIANT varIn, int *piItem)
//			Returns the index for the given object buried in the variant.  Variant
//			must be of either VT_UNKNOWN or VT_DISPATCH type to query by objects,
//			or else of a numeric type that can be converted to VT_I4 type.
//			Will return E_FAIL if can't find object (and set *piItem to -1).
//			Will return E_INTERFACE if passed object doesn't support interface of 
//			type T.
//			
//
//		int Find(T *pT)
//			Returns the index for the given object.  Returnsv value of -1 if not found.
//
//		HRESULT Remove(T *pT)
//			Removes the given item if possible (see below).  If item is not in
//			the collection, returns E_FAIL.
//	
//		HRESULT Remove(int iItem)
//			Removes the item at the given index if possible. if index is out of range,
//			(< 0 or >= Count), returns E_INVALIDARG.  If not ok to remove (currently
//			always OK), returns E_FAIL.  
//
//
// The enumerator supports IEnumVARIANT, which has the following methods
//
//		HRESULT Next(ULONG cElt, 
//		             VARIANT *rgvar, 
//                   unsigned long * pceltFetched);
//			Get the next CElt elements (usually 1), returning them in the
//			given array.   The number actually returned is passed back in pCeltFetched.
//			This returns S_FALSE if *pCeltFetched is not equal to cElt.
//
//		HRESULT Skip(ULONG cElt);
//			Skip over cElt elements.  Returns S_FALSE if skipped over the end of
//			the list.
//
//		HRESULT Reset();
//			Sets the internal counter back to beginning.
//
//		HRESULT Clone(IEnumVARIANT **ppenum);
//			Clone the enumerator, including current position.  May return E_OUTOFMEMORY,
//			or any of the erros from QueryInterface.
// 
//
//
// ------------------------------------------------------------------------------
//  To use an enumerator in C++, try this:
//
//
//	Given object spXXs in class built on TVECollection<IXX, IXXs>
//
//					// create an enumerator
//		CComPtr<IXXs> spXXs;
//		spXXs = ???
//
//		CComQIPtr<IEnumVARIANT> speEnum; 
//		hr = spXXs->get__NewEnum((IUnknown **) &speEnum);
//		if(!FAILED(hr)) 
//		{
//			while(S_OK == speEnum->Next(1, &v, &cReturned))
//			{
//				if(1 != cReturned) break;		// did we get the object?
//				IUnknown *pUnk = v.punkVal;		// convert out of variant form
//
//				CComQIPtr<IXX> spXX = pUnk;		// convert over to desired form
//				if(!spXX) break;				// did it work?
//
//				spXX->DoSomething();
//
//				pUnk->Release();				// !!! remember to release it
//			}
//		}
 // 
// ------------------------------------------------------------------------------

#ifndef __TVECOLLECTION_H__
#define __TVECOLLECTION_H__

#include <vector>		// STL Vector class (for storing list of tracks

#include "valid.h"		// ENTER_API, EXIT_API classes

#pragma warning (disable : 4786)	// disable those warnings with STL id's > 255 chars

typedef std::vector<CComVariant> VarVector;				// fundamental collection storage class
template<class T> class EnumTVECollection;				// templates defined in this file
template<class T> class SafeEnumTVECollection;
template<class T, class BaseT> class TVECollection;

// -------------------------------------------------------------
//							



template<class T>					// non threadsafe version 
class EnumTVECollection :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_ATVEFSENDLib>
{
	typedef std::vector<T *>	 VectorPT;
	typedef EnumTVECollection<T> ThisClassETVEC;

public:
	EnumTVECollection()
		{
		m_punk = NULL;
		m_iCur = 0;
		}

	~EnumTVECollection()
		{
		if (m_punk != NULL)
			m_punk->Release();
		}

	void Init(IUnknown *punk, VectorPT *pvecpT)
		{
		if (m_punk != NULL)
			{
			m_punk->Release();
			m_punk = NULL;
			}

		if (punk != NULL)
			{
			punk->AddRef();
			m_punk = punk;
			}

		m_pvecpT = pvecpT;
		m_iCur = 0;
		}

BEGIN_COM_MAP(ThisClassETVEC)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

	// IEnumUnknown interface
	STDMETHOD(Next)(ULONG celt, VARIANT *pvar, ULONG *pceltFetched)
		{
		ENTER_API
			{
			ULONG celtFetched = 0;
			int iMax = m_pvecpT->size();

			if ((pvar == NULL) || ((celt > 1) && (pceltFetched == NULL)))
				return E_POINTER;
			
			
//			for (ULONG l=0; l < celt; l++)
//				VariantInit( &pvar[l] ) ;

			while ((m_iCur < iMax) && (celtFetched < celt))
				{
				T * pT = m_pvecpT->at(m_iCur++);
				IDispatch *pdispatch;
				pT->QueryInterface(IID_IDispatch, (void **) &pdispatch);
				CComVariant var(pdispatch);
				*pvar++ = var;
				celtFetched++;
				}
			
			if (pceltFetched != NULL)
				*pceltFetched = celtFetched;
			
			return (celtFetched == celt) ? S_OK : S_FALSE;
			}
		EXIT_API
		}
	
	STDMETHOD(Skip)(ULONG celt)
		{
		ENTER_API
			{
			m_iCur += celt;
			
			return (m_iCur < m_pvecpT->size()) ? S_OK : S_FALSE;
			}
		EXIT_API
		}
	
	STDMETHOD(Reset)(void)
		{
		ENTER_API
			{
			m_iCur = 0;

			return S_OK;
			}
		EXIT_API
		}
	
	STDMETHOD(Clone)(IEnumVARIANT **ppenum)
		{
		ENTER_API
			{
			ThisClassETVEC *penum = NewComObject(ThisClassETVEC);

			if (penum == NULL)
				return E_OUTOFMEMORY;

			penum->Init(m_punk, m_pvecpT);
			penum->m_iCur = m_iCur;

			return QueryInterface(IID_IEnumVARIANT, (void **)ppenum);
			}
		EXIT_API
		}

protected:
	IUnknown *m_punk;
	VectorPT *m_pvecpT;			// TODO - change this to a copy of the vector, not pointer!
	int m_iCur;
};

// -----------------------------------------------------------------

		// This is a thread safe enumerator.  It copies the collections internal
		//    data structure used to hold objects over so the collection can
		//	  change without affecting the enumerator list.  

template<class T>
class SafeEnumTVECollection :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_ATVEFSENDLib>
{
	typedef std::vector<T *>		 VectorPT;
	typedef SafeEnumTVECollection<T> ThisClassSETVE;

public:
	SafeEnumTVECollection()
	{
		m_punk = NULL;
		m_iCur = 0;
	}

	~SafeEnumTVECollection()
	{


	
	}

	void FinalRelease()
	{

		int iMax = m_vecpT.size();
		for(int i = 0; i < iMax; i++)
		{
			T * pt = m_vecpT.at(i);
			pt->Release();
		}
		if (m_punk != NULL)
			m_punk->Release();
	}

	void Init(IUnknown *punk, VectorPT *pvecpT)
	{
		if (m_punk != NULL)
		{
			m_punk->Release();
			m_punk = NULL;
		}

		if(NULL == pvecpT) return;
		if (punk != NULL)		// back pointer to containing class
		{
			punk->AddRef();
			m_punk = punk;
		}
	
		EnterCriticalSection(&_Module.m_csTypeInfoHolder);
		{						// TODO - make this clause threadsafe.
			m_vecpT = *pvecpT;		
			int iMax = m_vecpT.size();

			for(int i = 0; i < iMax; i++)
			{
				T * pt = m_vecpT.at(i);
				pt->AddRef();
			}
		}
		LeaveCriticalSection(&_Module.m_csTypeInfoHolder);

		m_iCur = 0;
	}

BEGIN_COM_MAP(ThisClassSETVE)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

	// IEnumUnknown interface
	STDMETHOD(Next)(ULONG celt, VARIANT *pvar, ULONG *pceltFetched)
		{
		ENTER_API
			{
			ULONG celtFetched = 0;
			int iMax = m_vecpT.size();

			if ((pvar == NULL) || ((celt > 1) && (pceltFetched == NULL)))
				return E_POINTER;
			
			while ((m_iCur < iMax) && (celtFetched < celt))
				{
				T * pT = m_vecpT.at(m_iCur++);
				IDispatch *pdispatch;
				pT->QueryInterface(IID_IDispatch, (void **) &pdispatch);
				CComVariant var(pdispatch);
				*pvar++ = var;
				celtFetched++;
				}
			
			if (pceltFetched != NULL)
				*pceltFetched = celtFetched;
			
			return (celtFetched == celt) ? S_OK : S_FALSE;
			}
		EXIT_API
		}
	
	STDMETHOD(Skip)(ULONG celt)
		{
		ENTER_API
			{
			m_iCur += celt;
			
			return (m_iCur < m_vecpT.size()) ? S_OK : S_FALSE;
			}
		EXIT_API
		}
	
	STDMETHOD(Reset)(void)
		{
		ENTER_API
			{
			m_iCur = 0;

			return S_OK;
			}
		EXIT_API
		}
	
	STDMETHOD(Clone)(IEnumVARIANT **ppenum)
		{
		ENTER_API
			{
				ThisClassSETVE *penum = NewComObject(ThisClassSETVE);

				if (penum == NULL)
					return E_OUTOFMEMORY;

				penum->Init(m_punk, &m_vecpT);
				penum->m_iCur = m_iCur;

		// was	//	return QueryInterface(IID_IEnumVARIANT, (void **)ppenum);
				HRESULT hr = penum->QueryInterface(IID_IEnumVARIANT, (void **)ppenum);
				if(!FAILED(hr)) penum->Release();
				return hr;
			}
		EXIT_API
		}

protected:
	IUnknown *m_punk;			// back pointer...
	VectorPT m_vecpT;			// copy of the vector, not pointer!
	int m_iCur;
};

// ----------------------------------------------------------------
//		TVECollection class
//
//			
//		
// ----------------------------------------------------------------

template<class T, class BaseT>
class TVECollection :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<BaseT, &__uuidof(BaseT), &LIBID_ATVEFSENDLib>
{
	typedef std::vector<T *>	 VectorPT;
	typedef TVECollection<T,BaseT> ThisClassTVEC;
//	typedef EnumTVECollection<T> EnumTVECollectionT;
	typedef SafeEnumTVECollection<T> EnumTVECollectionT;

public:
	TVECollection()
		{
		}
	
	~TVECollection()
		{
		RemoveAll();
		}
	
	void RemoveAll()
		{
		// Need to be carefull.  If the elements hold IUnknown pointers back to
		// the container. Releasing the element count cause the container's ref
		// count to drop to zero.  The container would then delete this Collection,
		// causing RemoveAll to be called again.
		// To handle this, we must clone the collection.
		int iMax = m_vecpT.size();

		if (iMax > 0)
			{
			VectorPT vecpT;
			
//			vecpT.Copy(m_vecpT);			<CArray version>
//			m_vecpT.RemoveAll();
			
			vecpT = m_vecpT;
			m_vecpT.erase(m_vecpT.begin(), m_vecpT.end());

			for (int iItem = 0; iItem < iMax; iItem++)
				{
				T *&pT = vecpT[iItem];

				pT->Release();
				pT = NULL;
				}
			
			}
		}
	
	virtual BOOL FOkToRemove(T *pT)
		{
		return TRUE;
		}
	

BEGIN_COM_MAP(ThisClassTVEC)
	COM_INTERFACE_ENTRY_IID(__uuidof(BaseT), BaseT)
	COM_INTERFACE_ENTRY(IDispatch)
//	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
	{
		ENTER_API
		{
			HRESULT hr;
			ValidateOutPtr<IUnknown *>(ppunk, NULL);

			EnumTVECollectionT *penum = NewComObject(EnumTVECollectionT);
			if (penum == NULL)
				return E_OUTOFMEMORY;
			
			penum->Init((IUnknown *)(BaseT *)this, &m_vecpT);

			hr =  penum->QueryInterface(IID_IEnumVARIANT, (void **)ppunk);
			penum->Release();
			return hr;
		}
		EXIT_API
	}
	
	STDMETHOD(get_Count)(long *plCount)
	{
		ENTER_API
		{
			if (plCount == NULL)
				return E_POINTER;
			
			*plCount = m_vecpT.size();
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(long index, T **ppT )
	{
		ENTER_API
		{	
			*ppT = NULL;
			if (ppT == NULL)
				return E_POINTER;
			if(index < 0 || index >= m_vecpT.size())
				return E_INVALIDARG;
			
			*ppT = m_vecpT[index];
			(*ppT)->AddRef();
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(VARIANT var, T **ppT )
	{
		ENTER_API
		{	
			ValidateOutPtr<T *>(ppT, NULL);

			*ppT = NULL;

			int iItem;
			HRESULT hr = ItemIndex(var, &iItem);
			if (FAILED(hr))	return hr;

			*ppT = m_vecpT[iItem];
			(*ppT)->AddRef();
		}
		EXIT_API
	}

	STDMETHOD(Add)(T *pT)
	{
		ENTER_API
		{
			if (Find(pT) >= 0)
				return S_FALSE;

			m_vecpT.push_back(pT);
			pT->AddRef();
		}
		EXIT_API
	}

	STDMETHOD(Add)(IUnknown *punk)
	{
		ENTER_API
		{
			HRESULT hr;
			T *pT;

			hr = punk->QueryInterface(__uuidof(T), (void **) &pT);
			if(FAILED(hr)) return hr;

			hr = Add(pT);
			pT->Release();
			return hr;
		}
		EXIT_API
	}
	
	STDMETHOD(Remove)(VARIANT var)
	{
		ENTER_API
		{
			int iRemove;
			HRESULT hr = ItemIndex(var, &iRemove);
			if (FAILED(hr))
				return hr;
			
			return Remove(iRemove);
		}
		EXIT_API
	}
	
	STDMETHOD(Item)(VARIANT var, T **ppT)
	{
		ENTER_API
		{
			ValidateOutPtr<T *>(ppT, NULL);

			int iItem;
			HRESULT hr = ItemIndex(var, &iItem);
			if (FAILED(hr))	return hr;

			*ppT = m_vecpT[iItem];
			(*ppT)->AddRef();
		}
		EXIT_API
	}
	
	HRESULT ItemIndex(VARIANT varIn, int *piItem)
	{
		HRESULT hr;
		CComVariant var(varIn);
		int iItem = -1;

		switch (var.vt)
		{
		case VT_UNKNOWN:
		case VT_DISPATCH:
			T *pT;

			hr = var.punkVal->QueryInterface(__uuidof(T), (void **)&pT);
			if (FAILED(hr))
				return hr;

			iItem = Find(pT);
			pT->Release();
			break;

		default:
			var.ChangeType(VT_I4);

			iItem = var.lVal;
			break;
		}


		if ((iItem < 0) || (iItem >= m_vecpT.size()))
			return E_FAIL;

		*piItem = iItem;
		return S_OK;
	}
	
	int Find(T *pT)
	{
		int iMax = m_vecpT.size();
		for (int i = 0; i < iMax; i++)
		{
			if (m_vecpT[i] == pT)
				return i;
		}
		
		return -1;
	}

	HRESULT Remove(T *pT)
	{
		int iItem = Find(pT);
		if (iItem < 0)
			return E_FAIL;
		
		return Remove(iItem);
	}
	
	HRESULT Remove(int iItem)
	{
		if(iItem < 0 || iItem >= m_vecpT.size())
			return E_INVALIDARG;

		T *pT = m_vecpT[iItem];

		if (!FOkToRemove(pT))
			return E_FAIL;

		m_vecpT.erase(m_vecpT.begin() + iItem);
		pT->Release();

		return S_OK;
	}

	VectorPT m_vecpT;						// base collection object..
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvemcast.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEFMCast.cpp : Implementation of CATVEFMulticastSession
#include "stdafx.h"
#include "ATVEFSend.h"
#include "TVEMCast.h"


#include "DbgStuff.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CATVEFMulticastSession

HRESULT CATVEFMulticastSession::FinalConstruct()
{		
	HRESULT hr = S_OK;

	CComObject<CATVEFAnnouncement> *pAnnc;
	hr = CComObject<CATVEFAnnouncement>::CreateInstance(&pAnnc);
	if(FAILED(hr))
		return hr;

	m_pcotveAnnc = pAnnc;
	m_pcotveAnnc->AddRef();			// strange we need this, doesn't createInstance do this?

				// would like to set the parent of m_pcotveAnnc back to *this here,
				//   but can't since ref-count of this is currently zero (inc'ed to 1)
				//   right after this call.  The QI to IUnknown does an AddRef, and
				//	 the release brings the ref count back to zero, causing *this to
				//	 be deleted...  Do it in the Initialize() call below.
	return hr;
}

HRESULT CATVEFMulticastSession::FinalRelease()
{
	m_pcotveAnnc->SetParent(NULL);
	m_pcotveAnnc->Release();
	m_pcotveAnnc = NULL;
	return S_OK;
}

STDMETHODIMP CATVEFMulticastSession::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATVEFMulticastSession
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CATVEFMulticastSession::SetCurrentMedia( LONG lMedia)
{
	return  m_pcotveAnnc->SetCurrentMedia(lMedia);
}

STDMETHODIMP 
CATVEFMulticastSession::DumpToBSTR(BSTR *pBstrBuff)
{
	CComBSTR bstrBuff;
	bstrBuff = L"CATVEFMulticastSession\n";
	m_pcotveAnnc->Lock_ () ;

	bstrBuff.CopyTo(pBstrBuff);

    m_pcotveAnnc->Unlock_ () ;
	return S_OK;
}

// --------------------------------------------------------------------------
STDMETHODIMP CATVEFMulticastSession::get_Announcement(IDispatch **pVal)
{
	HRESULT hr = m_pcotveAnnc->QueryInterface(pVal);

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFMulticastSession);

	return hr;
}

STDMETHODIMP CATVEFMulticastSession::Initialize(LONG lNetworkInterface)
{
/*++

    Routine Description:

        The purpose of this routine is to initialize a multicast session
        object.

        This routine instantiates and initializes 3 transmitter objects,
        then initializes the parent CEnhancementSession object.

        The object lock must be held for this call.

		It also sets up the parent pointer for the object

    Parameters:

        NetworkInterface    NIC, in network order, over which the data should
                            be multicast.

    Return Value:

        S_OK                success
        failure code        failure

--*/

	ULONG ulNetworkInterface = (ULONG) lNetworkInterface;  // vb casting

	HRESULT hr = S_OK;
	CNativeMulticast *  pAnnouncementTransmitter ;
	CNativeMulticast *  pPackageTransmitter ;
	CNativeMulticast *  pTriggerTransmitter ;
	BOOL				fLocked = false;

	pAnnouncementTransmitter = NULL ;
	pPackageTransmitter = NULL ;
	pTriggerTransmitter = NULL ;

	ENTER_API {
		ENTERW_OBJ_0 (L"CMulticastSession::Initialize" ) ;

		pAnnouncementTransmitter = new CNativeMulticast () ;
		GOTO_EQ_SET (pAnnouncementTransmitter, NULL, cleanup, hr, E_OUTOFMEMORY) ;

		pPackageTransmitter = new CNativeMulticast () ;
		GOTO_EQ_SET (pPackageTransmitter, NULL, cleanup, hr, E_OUTOFMEMORY) ;

		pTriggerTransmitter = new CNativeMulticast () ;
		GOTO_EQ_SET (pTriggerTransmitter, NULL, cleanup, hr, E_OUTOFMEMORY) ;

		if (FAILED (hr = pAnnouncementTransmitter -> Initialize (ulNetworkInterface)) ||
			FAILED (hr = pPackageTransmitter -> Initialize (ulNetworkInterface)) ||
			FAILED (hr = pTriggerTransmitter -> Initialize (ulNetworkInterface))) 
		{
			goto cleanup ;
		}

		m_pcotveAnnc->Lock_() ;
		fLocked = true;

		hr = m_pcotveAnnc->InitializeLocked_ 
			(
					pAnnouncementTransmitter, 
					pPackageTransmitter, 
					pTriggerTransmitter
			) ;
		if(FAILED(hr)) 
			goto cleanup;	
											// setup the parent pointer in the announcement
		IUnknown *punkThis;
		hr = this->QueryInterface(IID_IUnknown, (void**) &punkThis);		
		if(FAILED(hr)) 
			goto cleanup;

		m_pcotveAnnc->SetParent(punkThis);		// point it's parent back up to this
		punkThis->Release();					// parent pointer not ref'ed, so release it (shouldn't go away!)

	} LEAVE_API;			// fall through, don't exit

cleanup :
    if(fLocked)
		m_pcotveAnnc->Unlock_() ;

    if (FAILED(hr)) 
	{
        delete pAnnouncementTransmitter ;
        delete pPackageTransmitter ;
        delete pTriggerTransmitter ;

		Error(GetTVEError(hr), IID_IATVEFMulticastSession);
	}
    return hr ;
}

STDMETHODIMP CATVEFMulticastSession::Connect()
{
    HRESULT hr = S_OK;
	ENTERW_OBJ_0 (L"CATVEFMulticastSession::Connect") ;

    m_pcotveAnnc->Lock_ () ;

    hr = m_pcotveAnnc->ConnectLocked_ () ;

    m_pcotveAnnc->Unlock_ () ;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFMulticastSession);

	return hr;
}

STDMETHODIMP CATVEFMulticastSession::Disconnect()
{
	// TODO: Add your implementation code here
    HRESULT hr = S_OK ;

    ENTERW_OBJ_0 (L"CATVEFMulticastSession::Disconnect") ;

    m_pcotveAnnc->Lock_ () ;
    hr = m_pcotveAnnc->DisconnectLocked_() ;
    m_pcotveAnnc->Unlock_ () ;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFMulticastSession);

    return hr ;
} 

STDMETHODIMP CATVEFMulticastSession::SendRawAnnouncement(BSTR bstrAnnouncement)
{
/*++

    Routine Description:

        The purpose of this routine is transmit an announcement.  The object
        must be connected for this call to succeed.

    Parameters:

        none

    Return Value:

        S_OK            success
        failure code    failure

--*/
    HRESULT hr ;

    ENTERW_OBJ_0 (L"CATVEFMulticastSession::SendRawAnnouncement") ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendRawAnnouncementLocked_(bstrAnnouncement) ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFMulticastSession::SendRawAnnouncement - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 
	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFMulticastSession);

    return hr ;

}

STDMETHODIMP CATVEFMulticastSession::SendAnnouncement()
{
/*++

    Routine Description:

        The purpose of this routine is transmit an announcement.  The object
        must be connected for this call to succeed.

    Parameters:

        none

    Return Value:

        S_OK            success
        failure code    failure

--*/
    HRESULT hr ;

    ENTERW_OBJ_0 (L"CATVEFMulticastSession::SendAnnouncement") ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendAnnouncementLocked_() ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFMulticastSession::SendAnnouncement - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 
	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFMulticastSession);

    return hr ;

}

STDMETHODIMP CATVEFMulticastSession::SendPackage(IATVEFPackage *pPackage)
{
/*++

    Routine Description:
    Parameters:
    Return Value:

--*/
	HRESULT hr = S_OK ;

    ENTERW_OBJ_0 (L"CATVEFMulticastSession::SendPackage") ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendPackageLocked_(pPackage) ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFMulticastSession::SendPackage - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 
	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFMulticastSession);

    return hr ;

}


STDMETHODIMP CATVEFMulticastSession::SendTrigger(BSTR bstrURL, BSTR bstrName, BSTR bstrScript, DATE dateExpires)
{
/*++

    Routine Description:

        Triggers, per the ATVEF specification must be as follows:

        <url>[name:name_str][expires:expire_tm][script:script_str][checksum]

        We do not append a checksum.

        The total length of the trigger cannot exceed 1472 bytes, including the
        null-terminator.  Transmitted as an ASCII string.

        Object must be connected for this call to succeed.

    Parameters:

        szURL       cannot be NULL;

        szName      can be NULL or 0 length

        szScript    can be NULL or 0 length

        Expires     can be 0'd out and will then be ignored

    Return Values:

        S_OK            success
        error code      failure

--*/



    HRESULT hr  = S_OK;

 	ENTERW_OBJ_3 (L"CTVEAnnouncement::SendTrigger (\n\t\"%s\", \n\t\"%s\", \n\t\"%s\")", 
		bstrURL, bstrName, bstrScript) ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendTriggerLocked_( bstrURL,  bstrName,  bstrScript,  dateExpires, /*level*/ 0.0, /*appendCRC*/ false) ;	// todo - make true
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFMulticastSession::SendTrigger - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 
	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFMulticastSession);

    return hr ;
}

STDMETHODIMP CATVEFMulticastSession::SendRawTrigger(BSTR bstrTrigger)
{
    HRESULT hr = S_OK;

 	ENTERW_OBJ_1 (L"CATVEFMulticastSession::SendRawTrigger (\n\t\"%s\")", bstrTrigger) ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendRawTriggerLocked_( bstrTrigger, /*appendCRC*/ true) ;	// TODO - make false!
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFMulticastSession::SendRawTrigger - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 
	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFMulticastSession);

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tveinsert.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEInsert.h : Declaration of the CATVEFInserterSession

#ifndef __ATVEFINSERTERSESSION_H_
#define __ATVEFINSERTERSESSION_H_

#include "resource.h"       // main symbols
#include "TveAnnc.h"		// major objects
/////////////////////////////////////////////////////////////////////////////
// CATVEFInserterSession
class ATL_NO_VTABLE CATVEFInserterSession : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATVEFInserterSession, &CLSID_ATVEFInserterSession>,
	public ISupportErrorInfo,
	public IDispatchImpl<IATVEFInserterSession, &IID_IATVEFInserterSession, &LIBID_ATVEFSENDLib>
{
public:

	enum {
        SOURCE_PORT = 11111
    } ;

	CATVEFInserterSession() {m_pcotveAnnc = NULL;}
	HRESULT FinalConstruct();
	HRESULT FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_ATVEFINSERTERSESSION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATVEFInserterSession)
	COM_INTERFACE_ENTRY(IATVEFInserterSession)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IATVEFInserterSession
public:
	STDMETHOD(get_Announcement)(/*[out, retval]*/ IDispatch* *pVal);
	STDMETHOD(SetCurrentMedia)(/*[in]*/ LONG lMedia);
	STDMETHOD(SendTrigger)(/*[in]*/ BSTR bstrURL, /*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrScript, /*[in]*/ DATE dateExpires);
	STDMETHOD(SendRawTrigger)(/*[in]*/ BSTR bstrTrigger);
	STDMETHOD(SendPackage)(/*[in]*/ IATVEFPackage *pPackage);
	STDMETHOD(SendRawAnnouncement)(/*[in]*/ BSTR bstrAnnouncement);
	STDMETHOD(SendAnnouncement)();
	STDMETHOD(Disconnect)();
	STDMETHOD(Connect)();
	STDMETHOD(Initialize)(/*IN*/  LONG   InserterIP,
						  /*IN*/  SHORT  InserterPort);

	STDMETHOD(InitializeEx)(/*IN*/  LONG   InserterIP,
						/*IN*/	SHORT   InserterPort,
						/*IN*/  SHORT   CompressionIndexMin,                //  byte range - default 0x00
						/*IN*/  SHORT   CompressionIndexMax,                //  byte range - default 0x7f
						/*IN*/  SHORT   CompressedUncompressedRatio);        //  default 4);
			// Helper methods
	STDMETHOD(DumpToBSTR)(/*[out]*/ BSTR *pBstrBuff);

protected:
	CComObject<CATVEFAnnouncement>		*m_pcotveAnnc;		// down pointer

    CTCPConnection						m_InserterConnection ;
    CIPVBI								m_IpVbi ;

};

#endif //__ATVEFINSERTERSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvemcast.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEMCast.h : Declaration of the CATVEFMulticastSession

#ifndef __ATVEFMULTICASTSESSION_H_
#define __ATVEFMULTICASTSESSION_H_

#include "resource.h"       // main symbols
#include "TveAnnc.h"		// major objects
/////////////////////////////////////////////////////////////////////////////
// CATVEFMulticastSession
class ATL_NO_VTABLE CATVEFMulticastSession : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATVEFMulticastSession, &CLSID_ATVEFMulticastSession>,
	public ISupportErrorInfo,
	public IDispatchImpl<IATVEFMulticastSession, &IID_IATVEFMulticastSession, &LIBID_ATVEFSENDLib>
{
public:
	CATVEFMulticastSession() {m_pcotveAnnc = NULL;}
	HRESULT FinalConstruct();
	HRESULT FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_ATVEFMULTICASTSESSION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATVEFMulticastSession)
	COM_INTERFACE_ENTRY(IATVEFMulticastSession)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IATVEFMulticastSession
public:
	public:
	STDMETHOD(get_Announcement)(/*[out, retval]*/ IDispatch* *pVal);
	STDMETHOD(SetCurrentMedia)(/*[in]*/ LONG lMedia);
	STDMETHOD(SendTrigger)(/*[in]*/ BSTR bstrURL, /*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrScript, /*[in]*/ DATE dateExpires);
	STDMETHOD(SendRawTrigger)(/*[in]*/ BSTR bstrTrigger);
	STDMETHOD(SendPackage)(/*[in]*/ IATVEFPackage *pPackage);
	STDMETHOD(SendRawAnnouncement)(/*[in]*/ BSTR bstrAnnouncement);
	STDMETHOD(SendAnnouncement)();
	STDMETHOD(Disconnect)();
	STDMETHOD(Connect)();
	STDMETHOD(Initialize)(/*[in]*/LONG NetworkInterface);	// if 0, uses INADDR_ANY
			// Helper methods
	STDMETHOD(DumpToBSTR)(/*[out]*/ BSTR *pBstrBuff);

protected:
	CComObject<CATVEFAnnouncement>		*m_pcotveAnnc;		// down pointer
};

#endif //__ATVEFMULTICASTSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tveline21.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVELine21.h : Declaration of the CATVEFLine21Session

#ifndef __ATVEFLINE21SESSION_H_
#define __ATVEFLINE21SESSION_H_

#include "resource.h"       // main symbols
#include "TveAnnc.h"		// major objects
#include "XMit.h"

/////////////////////////////////////////////////////////////////////////////
// CATVEFLine21Session
class ATL_NO_VTABLE CATVEFLine21Session : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATVEFLine21Session, &CLSID_ATVEFLine21Session>,
	public ISupportErrorInfo,
	public IDispatchImpl<IATVEFLine21Session, &IID_IATVEFLine21Session, &LIBID_ATVEFSENDLib>
{
public:
	CATVEFLine21Session() {m_pTransmitter = NULL;}
	HRESULT FinalConstruct();
	HRESULT FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_ATVEFLINE21SESSION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATVEFLine21Session)
	COM_INTERFACE_ENTRY(IATVEFLine21Session)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
// IATVEFLine21Session
	STDMETHOD(SendTrigger)(/*[in]*/ BSTR bstrURL, /*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrScript, /*[in]*/ DATE dateExpires);
	STDMETHOD(SendTriggerEx)(/*[in]*/ BSTR bstrURL, /*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrScript, /*[in]*/ DATE dateExpires, /*[in]*/ double rTveLevel);
	STDMETHOD(SendRawTrigger)(/*[in]*/ BSTR bstrTrigger, /*[in]*/ BOOL fAppendCRC);
	STDMETHOD(Disconnect)();
	STDMETHOD(Connect)();
	STDMETHOD(Initialize)(/*IN*/  LONG   InserterIP,
						  /*IN*/  SHORT  InserterPort);
			// Helper methods
	STDMETHOD(DumpToBSTR)(/*[out]*/ BSTR *pBstrBuff);

protected:
		//  class constants;
    enum {
        MAX_TRIGGER_LENGTH  = ETHERNET_MTU_UDP_PAYLOAD_SIZE  //  effective length = 1471 because of null-terminator
    } ;
    
	CRITICAL_SECTION            m_crt ;                                         //  class-wide lock
    void
    Lock_ ()
    {
        ENTER_CRITICAL_SECTION (m_crt, CTVEAnnouncement::Lock_)
    }

    void
    Unlock_ ()
    {
        LEAVE_CRITICAL_SECTION (m_crt, CTVEAnnouncement::Unlock_)
    }

	HRESULT ConnectLocked();

	CTCPConnection						m_InserterConnection ;
	CIPLine21Encoder					*m_pTransmitter;
};

#endif //__ATVEFLINE21SESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tveline21.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVELine21.cpp : Implementation of CATVEFLine21Session
#include "stdafx.h"
#include "ATVEFSend.h"
#include "TVELine21.h"

#include "DbgStuff.h"
#include "ATVEFMsg.h"
#include "TVESupport.h"
#include "..\common\Address.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CATVEFLine21Session

STDMETHODIMP CATVEFLine21Session::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATVEFLine21Session
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

// ----------------------------------------------------------------
HRESULT CATVEFLine21Session::FinalConstruct()
{		
	HRESULT hr = S_OK;
	InitializeCriticalSection (& m_crt) ;
	return hr;
}

HRESULT CATVEFLine21Session::FinalRelease()
{
	return S_OK;
}
// ----------------------------------------------------------------
STDMETHODIMP CATVEFLine21Session::Initialize(	
	IN  LONG   InserterIP,
    IN  SHORT  InserterPort)
{
/*++
   Routine Description:

        The purpose of this routine is to initialize an inserter object for Line21 triggers

        Initialization consists of:
		(1) making a TCP connection to the inserter,
        (3) instantiation and initialization of our transmitters, 
		(4) initialization of our parent CEnhancementSession object.

        There is only one TCP connection for Line21 triggers.  

        All multi-threaded protection of the TCP connection 
        is performed by this object.

        The object lock must be held during this call.

    Parameters:

        InserterIP                      host order IP address for the inserter

        InserterPort                    host order port on the inserter

    Return Value:

        S_OK            success
        failure code    failure

--*/

	HRESULT         hr ;
	CIPVBIEncoder * pTriggerTransmitter ;
	BOOL			fLocked = false;

	ENTERW_OBJ_0 (L"CLine21Session::InitializeEx") ;
	const long		klMaxBandwidth = 128000;			// wicked fast!

	//  start initialization

	//  initialize our transmitter object pointer
	pTriggerTransmitter = NULL ;

	ENTER_API {

		//  we make 1 connection to the inserter for the duration of the session;

		hr = m_InserterConnection.Connect (InserterIP, InserterPort) ;
		GOTO_NE (hr, S_OK, cleanup) ;


		//  instantiate and initialize our transmission object
		m_pTransmitter = new CIPLine21Encoder();
		GOTO_EQ_SET (m_pTransmitter, NULL, cleanup, hr, E_OUTOFMEMORY) ;
		m_pTransmitter->Initialize(&m_InserterConnection);

		// need some sort of throttle rate for line21 triggers... (else hangs!)
		hr = m_pTransmitter->SetBitRate(klMaxBandwidth);

		GOTO_NE (hr, S_OK, cleanup) ;

	} LEAVE_API;		// fall through, don't exit

cleanup :
	if(fLocked)
		Unlock_() ;

	if (FAILED(hr))
	{
		delete pTriggerTransmitter ;
		m_InserterConnection.Disconnect () ;

		Error(GetTVEError(hr), IID_IATVEFLine21Session);
	}
	return hr;
}

STDMETHODIMP 
CATVEFLine21Session::DumpToBSTR(BSTR *pBstrBuff)
{
	CComBSTR bstrBuff;
	bstrBuff = L"CATVEFLine21Session\n";
	Lock_ () ;

	ENTER_API {
		bstrBuff.CopyTo(pBstrBuff);
	} LEAVE_API;		// fall through, don't exit

    Unlock_ () ;

	return S_OK;

}
// ------------------------------------------------------------------

STDMETHODIMP CATVEFLine21Session::Connect()
{
    HRESULT hr;
	ENTERW_OBJ_0 (L"CATVEFLine21Session::Connect") ;

    Lock_() ;
	ENTER_API {
		hr = ConnectLocked();
	} LEAVE_API;		// fall through, don't exit

	
	Unlock_() ;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFLine21Session);

	return hr;
}

HRESULT CATVEFLine21Session::ConnectLocked()
{
	HRESULT         hr ;

	//  connect in case the connection was broken between initialization and this call; 
	hr = m_InserterConnection.Connect();
	if (FAILED (hr)  && E_UNEXPECTED != hr)  // second test to avoid error of double-connection
		return hr;

	hr = m_pTransmitter->Connect () ;
	if (FAILED (hr))
		return hr;

	return S_OK ;
}

STDMETHODIMP CATVEFLine21Session::Disconnect()
{
    HRESULT hr ;

    ENTERW_OBJ_0 (L"CATVEFLine21Session::Disconnect") ;

	if(NULL == m_pTransmitter) {
		hr = ATVEFSEND_E_OBJECT_NOT_INITIALIZED;
		goto errorThingy;
	}


    Lock_ () ;

	ENTER_API {	
		hr = m_pTransmitter-> Disconnect () ;

		//  expected state (transmitters cannot fail a ::Disconnect call)
		assert (m_pTransmitter-> IsConnected () == FALSE) ;

		// new -- disconnect the inserter too (not done in InserterSession... Should it?)
		m_InserterConnection.Disconnect();
 
	} LEAVE_API;		// fall through, don't exit
   
	Unlock_ () ;

errorThingy:
	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFLine21Session);

    return hr ;
} 


STDMETHODIMP CATVEFLine21Session::SendTrigger(BSTR bstrURL, BSTR bstrName, 
											  BSTR bstrScript, DATE dateExpires)
{
	return SendTriggerEx(bstrURL, bstrName, bstrScript, dateExpires, 1.0);
}


STDMETHODIMP CATVEFLine21Session::SendTriggerEx(BSTR bstrURL, BSTR bstrName, 
											  BSTR bstrScript, DATE dateExpires,
											  double rTveLevel)
{
/*++

    Routine Description:

        Triggers, per the ATVEF specification must be as follows:

        ..header..<url>[name:name_str][expires:expire_tm][script:script_str][checksum]..trailer..

        We *do* append a checksum.

        The total length of the trigger cannot exceed 1472 bytes, including the
        null-terminator.  Transmitted as an ASCII string.

        Object must be connected for this call to succeed.

		..header../,,trailer..  is set for sending T2 data on Norpack Inserter 
	

    Parameters:

        bstrURL       cannot be NULL;

        bstrName      can be NULL or 0 length - encoded 

        bstrScript    can be NULL or 0 length

        dateExpires   can be 0'd out and will then be ignored

		rTveLevel	  if 0.0, not sent.  Should default to 1.0

    Return Values:

        S_OK            success
        error code      failure 
						ATVEFSEND_E_TRIGGER_TOO_LONG if trigger could be longer than 1472 bytes 

--*/



    HRESULT hr ;

 	ENTERW_OBJ_4 (L"CATVEFLine21Session::SendTrigger (\n\t\"%s\", \n\t\"%s\", \n\t\"%s\",\n\t%d)", 
		bstrURL, bstrName, bstrScript, rTveLevel) ;

	Lock_ () ;
 	try 
	{
		CHAR  achBuffer [MAX_TRIGGER_LENGTH];
	
		char *pach = achBuffer;
		*pach = 0;						// Init it!
		strcat(pach,"\001");
//		strcat(pach,"2 c1\r");			// fake usage for c1
		strcat(pach,"2 t2\r");			// correct usage for t2
		pach = achBuffer + strlen(pach);

				// short form, tve: parameter, and CRC
		hr = GenTrigger(pach,  MAX_TRIGGER_LENGTH - 15, 
						bstrURL, bstrName, bstrScript, dateExpires, 
						/* fShortForm*/ true, /*rTVELevel*/ rTveLevel, /*fAppendCRC*/ true);	
		strcat(pach,"\r\003\r");

		if(!FAILED(hr)) {
#ifdef _DEBUG
			USES_CONVERSION;
			static int iCount = 0;
			TCHAR szBuff[1600];
			_stprintf(szBuff,_T("%4d - Trigger : %s"),iCount,A2T(achBuffer));
			OutputDebugString(szBuff);
#endif
			hr = m_pTransmitter->Send ((BYTE *) achBuffer, strlen (achBuffer) + 1);
		}

	} catch (HRESULT hr2) {
		ENTERW_OBJ_0 (L"CATVEFLine21Session::SendTrigger - hr error!") ;
		hr = hr2;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFLine21Session::SendTrigger - error!") ;
		hr = E_FAIL;
	}
    Unlock_ () ;
 
	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFLine21Session);

    return hr ;
}

STDMETHODIMP CATVEFLine21Session::SendRawTrigger(BSTR bstrRawTrigger, BOOL fAppendCRC)
{
    HRESULT hr = S_OK;

 	ENTERW_OBJ_1 (L"CATVEFLine21Session::SendRawTrigger (\n\t\"%s\")", bstrRawTrigger) ;

	Lock_ () ;
 	try 
	{
		USES_CONVERSION;
		HRESULT hr;

		if (bstrRawTrigger == NULL || bstrRawTrigger [0] == L'\0') 
			return E_INVALIDARG ;
 
		int len = wcslen(bstrRawTrigger);
		if(len > CATVEFAnnouncement::MAX_TRIGGER_LENGTH - (fAppendCRC ? 6 : 0)) 
			return ATVEFSEND_E_TRIGGER_TOO_LONG;

		char *pszChar = (char *) W2A(bstrRawTrigger);	
		char *pszNew = pszChar;


		if(fAppendCRC && len>0)	 // if appending CRC, skip over heading and trailing junk <...>[][]
		{
			char* pszStart = strchr(pszChar,'<');	// look for first '<'
			if(NULL == pszStart)
				pszStart = strchr(pszChar,'[');	
			char* pszEnd   = strrchr(pszChar,']');	// look for last ']'
			if(NULL == pszEnd)						// if no ']', look for last '>'
				pszEnd = strchr(pszChar,'>');
			if(NULL == pszStart || NULL == pszEnd)
				return E_INVALIDARG;				// not a valid trigger -- don't even bother with the CRC

			ASSERT(pszEnd > pszStart);

			pszNew = new char[len+8];
			if(NULL == pszNew)
				throw(E_OUTOFMEMORY);
			strncpy(pszNew,pszStart,pszEnd-pszStart+1);		// copy center of string without header/trailer
			pszNew[pszEnd-pszStart+1] = NULL;				// 
			CComBSTR spbsCRC = ChkSumA((CHAR *) pszChar);	// get its CRC

			char *pszCurr = pszChar;
			char *pszNewCurr = pszNew;
			for(;pszCurr <= pszEnd; pszCurr++,pszNewCurr++)		// copy header and center string over
				*pszNewCurr = *pszCurr;

			
			*pszNewCurr++ = '[';								// tack on the CRC
			for(int i = 0; i < 4; i++)
				*pszNewCurr++ = spbsCRC[i];
			*pszNewCurr++ = ']';

			pszEnd++;										// add the trailing stuff
			while(*pszEnd != NULL) {
				*pszNewCurr = *pszEnd;		
				pszNewCurr++;
				pszEnd++;
			}
			*pszNewCurr = 0;									// cap it off with a NULL

			len += 6;				
		}

		hr = m_pTransmitter->SendThrottled((BYTE*) pszNew, len + 1) ;
		if(pszNew != pszChar) delete pszNew;
		return hr;
	} catch (HRESULT hr2) {
		ENTERW_OBJ_0 (L"CATVEFLine21Session::SendRawTrigger - Hr error!") ;
		hr = hr2;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFLine21Session::SendRawTrigger - error!") ;
		hr = E_FAIL;
	}
    Unlock_ () ;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFLine21Session);
	
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvemedias.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEMedias.cpp : Implementation of CATVEFMedias
#include "stdafx.h"

#include "ATVEFSend.h"
#include "TVEMedias.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CATVEFMedias

STDMETHODIMP CATVEFMedias::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATVEFMedias
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvemedia.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEMedia.h : Declaration of the CATVEFMedia

#ifndef __ATVEFMEDIA_H_
#define __ATVEFMEDIA_H_

#include "resource.h"       // main symbols
#include <WinSock2.h>
#include "TveAttrL.h"
//#include "CsdpSrc.h"

// ----------------------------------------------------------------------
//  helper methods
HRESULT ConvertLONGIPToBSTR(LONG lIP, BSTR *pbstr);
HRESULT ConvertBSTRToLONGIP(BSTR bstr, LONG *plIP);
HRESULT IPAddToBSTR(SHORT sIP1, SHORT sIP2, SHORT sIP3, SHORT sIP4, BSTR* pbstrDest);
HRESULT GetLangBSTRFromLangID(BSTR *pBstr, LANGID langid);
// -----------------------------------------------------------------------

_COM_SMARTPTR_TYPEDEF(IATVEFAttrMap, __uuidof(IATVEFAttrMap));
_COM_SMARTPTR_TYPEDEF(IATVEFAttrList, __uuidof(IATVEFAttrList));

/////////////////////////////////////////////////////////////////////////////
// CATVEFMedia
class ATL_NO_VTABLE CATVEFMedia : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATVEFMedia, &CLSID_ATVEFMedia>,
	public ISupportErrorInfo,
	public IDispatchImpl<IATVEFMedia, &IID_IATVEFMedia, &LIBID_ATVEFSENDLib>
{
public:
	CATVEFMedia()
	{
		m_bSingleDataTriggerAddress = false;
		m_langIDSDPLang		 = 0;
		m_langIDSessionLang  = 0;
		m_lDataPort			 = 0;
		m_lTrigPort			 = 0;
		m_ulDataMaxBandwidth = 0;
		m_ulSize			 = 0;
		m_ulTrigMaxBandwidth = 0;
		m_spbsDataAddIP.Empty();		// CComBSTR's, shouldn't really need to set
		m_spbsTrigAddIP.Empty();		//   however, test against these before being set

		IATVEFAttrListPtr spAttrList1 = IATVEFAttrListPtr(CLSID_ATVEFAttrList);
		if(NULL == spAttrList1) {
			m_spalExtraFlags = NULL;	
			return;
		} else {		
			m_spalExtraFlags = spAttrList1;
		}

		IATVEFAttrListPtr spAttrList2 = IATVEFAttrListPtr(CLSID_ATVEFAttrList);
		if(NULL == spAttrList2) {
			m_spalExtraAttributes = NULL;	
			return;
		} else {		
			m_spalExtraAttributes = spAttrList2;
		}

	}

DECLARE_REGISTRY_RESOURCEID(IDR_ATVEFMEDIA)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATVEFMedia)
	COM_INTERFACE_ENTRY(IATVEFMedia)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IATVEFMedia
public:
	STDMETHOD(ConfigureDataAndTriggerTransmission)(LONG lIP, SHORT sPort, INT iTTL, LONG lMaxBandwidth);
	STDMETHOD(ConfigureDataTransmission)(LONG lIP, SHORT sPort, INT iTTL, LONG lMaxBandwidth);
	STDMETHOD(ConfigureTriggerTransmission)(LONG lIP, SHORT sPort, INT iTTL, LONG lMaxBandwidth);

	STDMETHOD(GetDataTransmission)(LONG *plIP, SHORT *psPort, INT *piTTL, LONG *plMaxBandwidth);
	STDMETHOD(GetTriggerTransmission)(LONG *plIP, SHORT *psPort, INT *piTTL, LONG *plMaxBandwidth);

	// a=tve-size
		// NOTE: Estimate of high water mark of cache storage in K that will 
		// be required during playing of the announcement
	STDMETHOD(put_MaxCacheSize)(LONG ulSize);
	STDMETHOD(get_MaxCacheSize)(LONG *pulSize);

	// a=lang:
	STDMETHOD(put_LangID)(SHORT langid);
	STDMETHOD(get_LangID)(SHORT *plangid);

	// a=sdplang:
	STDMETHOD(put_SDPLangID)(SHORT langid);
	STDMETHOD(get_SDPLangID)(SHORT *plangid);

	// i=
	STDMETHOD(put_MediaLabel)(BSTR bstrLabel);
	STDMETHOD(get_MediaLabel)(BSTR *pbstrLabel);

	// a=???
	STDMETHOD(AddExtraAttribute)(BSTR bstrKey, BSTR bstrValue = NULL);
	// ?=???
	STDMETHOD(AddExtraFlag)(BSTR bstrKey, BSTR bstrValue);						// add 'key=value' to extra flags
	
	STDMETHOD(get_ExtraAttributes)(IDispatch **ppVal);		// other 'a=key:value'
	STDMETHOD(get_ExtraFlags)(IDispatch **ppVal);			// other 'key=value',  key != 'a' parameters


	STDMETHOD(MediaToBSTR)(BSTR *bstrVal);
			// helper
public:
	HRESULT	ClearExtraAttributes();			// clears the extra attributes (a=)
	HRESULT ClearExtraFlags();				// clears the random extra falgs ('x'=)

protected:
	BOOL		m_bSingleDataTriggerAddress;

	// These sets are used if there are separate data/trigger ips specified
	CComBSTR	m_spbsDataAddIP;
	UINT		m_uiDataTTL;
	LONG		m_lDataPort;
	ULONG		m_ulDataMaxBandwidth;

	CComBSTR	m_spbsTrigAddIP;
	UINT		m_uiTrigTTL;
	LONG		m_lTrigPort;
	ULONG		m_ulTrigMaxBandwidth;

	CComBSTR	m_spbsMediaLabel;

	LANGID		m_langIDSessionLang;
	CComBSTR	m_spbsSessionLang;
	LANGID		m_langIDSDPLang;
	CComBSTR	m_spbsSDPLang;					// string version of above

	ULONG		m_ulSize;						// a=tve-size:
//	CSDPSource *m_pcsdpSource;					// parent pointer

	CComPtr<IATVEFAttrList>			m_spalExtraAttributes;	// other random a: attributes
	CComPtr<IATVEFAttrList>			m_spalExtraFlags;		// other 'x:....' flags 

};

#endif //__ATVEFMEDIA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvemedias.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEMedias.h : Declaration of the CATVEFMedias

#ifndef __ATVEFMEDIAS_H_
#define __ATVEFMEDIAS_H_

#include "resource.h"       // main symbols
#include "TVECollect.h"		// collection template defs
#include "TVEMedia.h"		// base class

/////////////////////////////////////////////////////////////////////////////
// CATVEFMedias
class CATVEFMedias : public TVECollection<IATVEFMedia, IATVEFMedias>,
	public ISupportErrorInfo
{
public:

	DECLARE_REGISTRY_RESOURCEID(IDR_ATVEFMEDIAS)
	DECLARE_PROTECT_FINAL_CONSTRUCT()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

#endif //__ATVEFMEDIAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvemedia.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEMedia.cpp : Implementation of CATVEFMedia
#include "stdafx.h"
#include "ATVEFSend.h"
#include "TVEMedia.h"
#include "AtvefMsg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
// //////////////////////////////////////////////////////////////////////////
// Helper methods
// -------------------------------------------------------------------------------------------
// ConvertLONGIPToBSTR
// ConvertBSTRToLONGIP
//
//		converts between host order ULONG representations of IP address and string representations.
// --------------------------------------------------------------------------------------------
 HRESULT ConvertLONGIPToBSTR(LONG lIP, BSTR *pbstr)
{
	IN_ADDR  iaddr;
	CComBSTR spbsT;
	if(pbstr == NULL)
		return E_POINTER;

	iaddr.s_addr = htonl((ULONG) lIP);
	char	*pcIPString = inet_ntoa(iaddr);		// convert network address as ULONG to a string
	if(pcIPString != NULL)
		spbsT = pcIPString;
	else {
		spbsT = L"<Invalid>";
		return E_INVALIDARG;
	}
	
	*pbstr = spbsT;			// may need a .Transfer() here.
							// really need a .Transfer() here!!! BUGBUG!!
	return S_OK;
}

// returns address in

HRESULT ConvertBSTRToLONGIP(BSTR bstr, LONG *plIP)
{
	USES_CONVERSION;

	CComBSTR spbsT;
	ULONG ulAddr = inet_addr(W2A(bstr));
	if(INADDR_NONE == ulAddr) return E_INVALIDARG;

	*plIP = (LONG) ntohl(ulAddr);			// data returned in host, not network, order
	return S_OK;
}

LONG IPtoL(BSTR bstr)		// for VB...
{
	USES_CONVERSION;

	CComBSTR spbsT;
	ULONG ulAddr = inet_addr(W2A(bstr));
	if(INADDR_NONE == ulAddr) return E_INVALIDARG;

	return (LONG) ntohl(ulAddr);			// data returned in host, not network, order
}

HRESULT IPAddToBSTR(SHORT sIP1, SHORT sIP2, SHORT sIP3, SHORT sIP4, BSTR* pbstrDest)
{
//	CComBSTR	ccbstr;
//	_bstr_t		bstrtIP;
	CComBSTR	bstrtIP;
	char		str[8];

	_itoa((int)(sIP1), str, 10);

	bstrtIP += str;
	bstrtIP += _T(".");

	_itoa((int)(sIP2), str, 10);

	bstrtIP += str;
	bstrtIP += _T(".");

	_itoa((int)(sIP3), str, 10);

	bstrtIP += str;
	bstrtIP += _T(".");

	_itoa((int)(sIP4), str, 10);

	bstrtIP += str;

	*pbstrDest = SysAllocString(bstrtIP);

	if(*pbstrDest)
	{
		return S_OK;
	}
	else
	{
		return E_OUTOFMEMORY;
	}
}

HRESULT GetLangBSTRFromLangID(BSTR *pBstr, LANGID langid)
{
//	_bstr_t		bstrtLang;
	CComBSTR		bstrtLang;

	// Make LCID from a LangID
	LCID	lcid = ((DWORD)((WORD)(langid)) | (((DWORD)((WORD)(0)))<<16));

	char	chLang[4];

	int cChars = GetLocaleInfoA(lcid, LOCALE_SABBREVLANGNAME, (char*) &chLang, 4);

	// Should return three letter abbreviation
	if(4 != cChars)
	{
		return E_FAIL;
	}

	chLang[2] = 0;		// truncate last letter (sublang) leaving ISO 639 compatible code

	// convert to wide
	bstrtLang = (char*) &chLang;

	// Save the value
	*pBstr = SysAllocString((wchar_t*) bstrtLang);
	
	return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
// CATVEFMedia

STDMETHODIMP 
CATVEFMedia::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATVEFMedia
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/// ------------------------------------------

HRESULT	
CATVEFMedia::ClearExtraAttributes()			// clears extra attributes (a=<not elsewhere defined>)
{
	if(m_spalExtraAttributes)     m_spalExtraAttributes->RemoveAll();
	return S_OK;
}

HRESULT	
CATVEFMedia::ClearExtraFlags()			// clears extra attributes (a=<not elsewhere defined>)
{
	if(m_spalExtraFlags)     m_spalExtraFlags->RemoveAll();
	return S_OK;
}

//
// REQUIRED m=/c= methods: Set Data/Trigger stream addresses
//


STDMETHODIMP
CATVEFMedia::ConfigureDataTransmission(LONG lIP, SHORT sPort, INT iTTL, LONG lMaxBandwidth)
{
	HRESULT		hr;

	ENTER_API {
		BSTR bstrX;
		if(0xE != (0xF & (lIP>>(32-4))))		// top byte in range of 224-239
			return E_INVALIDARG; 

		hr = ConvertLONGIPToBSTR(lIP, &bstrX);
		if(FAILED(hr))
			return hr;

		m_bSingleDataTriggerAddress = FALSE;

		m_spbsDataAddIP				= bstrX;
		m_uiDataTTL					= iTTL;
		m_lDataPort					= sPort;
		m_ulDataMaxBandwidth		= lMaxBandwidth;
	} EXIT_API_(hr);
}

STDMETHODIMP
CATVEFMedia::ConfigureTriggerTransmission(LONG lIP, SHORT sPort, INT iTTL, LONG lMaxBandwidth)
{
	HRESULT		hr;

	ENTER_API {
		BSTR bstrX;
		if(0xE != (0xF & (lIP>>(32-4))))			// top byte in range of 224-239
			return ATVEFSEND_E_INVALID_MULTICAST_ADDRESS; 

		hr = ConvertLONGIPToBSTR(lIP, &bstrX);
		if(FAILED(hr))
			return hr;

		m_bSingleDataTriggerAddress = FALSE;

		m_spbsTrigAddIP				= bstrX;
		m_uiTrigTTL					= iTTL;
		m_lTrigPort					= sPort;
		m_ulTrigMaxBandwidth		= lMaxBandwidth;
	} EXIT_API_(hr);
}

STDMETHODIMP
CATVEFMedia::ConfigureDataAndTriggerTransmission(LONG lIP, SHORT sPort, INT iTTL, LONG lMaxBandwidth)
{
	HRESULT		hr;
	ENTER_API {
		BSTR bstrX;
		if(0xE != (0xF & (lIP>>(32-4))))			// top byte in range of 224-239
			return E_INVALIDARG; 

		hr = ConvertLONGIPToBSTR(lIP, &bstrX);

		if(FAILED(hr))
			return hr;
		m_bSingleDataTriggerAddress = TRUE;			// Mark True, so we know to use the compact form

		m_spbsDataAddIP				= bstrX;		// store info in Data field
		m_uiDataTTL					= iTTL;
		m_lDataPort					= sPort;
		m_ulDataMaxBandwidth		= lMaxBandwidth;

		m_spbsTrigAddIP				= bstrX;		// also store info in Data field
		m_uiTrigTTL					= iTTL;
		m_lTrigPort					= sPort + 1;	// second port is 1+ the firs tone
		m_ulTrigMaxBandwidth		= lMaxBandwidth;
	} EXIT_API_(hr);
}

// will return S_FALSE if haven't set them yet...  (and zero values).

STDMETHODIMP
CATVEFMedia::GetDataTransmission(LONG *plIP, SHORT *psPort, INT *piTTL, LONG *plMaxBandwidth)
{
	HRESULT		hr;
	LONG lIP;

	ENTER_API {
		ValidateOutPtr(plIP, (LONG) 0);
		ValidateOutPtr(psPort, (SHORT) 0);
		ValidateOutPtr(piTTL, (INT) 0);
		ValidateOutPtr(plMaxBandwidth, (LONG) 0);
		

		if(0 == m_spbsDataAddIP.Length())	// nothing set yet...
			return S_FALSE;	

		hr = ConvertBSTRToLONGIP(m_spbsDataAddIP, &lIP);

		if(FAILED(hr))
			return hr;
		*plIP				= lIP;
		*piTTL				= (INT) m_uiDataTTL;
		*psPort				= (SHORT) m_lDataPort;
		*plMaxBandwidth		= (LONG)  m_ulDataMaxBandwidth;
		return S_OK;

	} EXIT_API_(hr);
}

STDMETHODIMP
CATVEFMedia::GetTriggerTransmission(LONG *plIP, SHORT *psPort, INT *piTTL, LONG *plMaxBandwidth)
{
	HRESULT		hr;
	LONG lIP;

	ENTER_API {
		ValidateOutPtr(plIP, (LONG) 0);
		ValidateOutPtr(psPort, (SHORT) 0);
		ValidateOutPtr(piTTL, (INT) 0);
		ValidateOutPtr(plMaxBandwidth, (LONG) 0);
		
		if(0 == m_spbsTrigAddIP.Length())	// nothing set yet...
			return S_FALSE;	

		hr = ConvertBSTRToLONGIP(m_spbsTrigAddIP, &lIP);

		if(FAILED(hr))
			return hr;
		*plIP				= lIP;
		*piTTL				= (INT) m_uiTrigTTL;
		*psPort				= (SHORT) m_lTrigPort;
		*plMaxBandwidth		= (LONG) m_ulTrigMaxBandwidth;
		return S_OK;

	} EXIT_API_(hr);
}

STDMETHODIMP
CATVEFMedia::put_LangID(SHORT slangid)
{
	BSTR		bstrNewLangBSTR;
	HRESULT		hr;

	LANGID		langid = slangid;		// cast, athough LANGID is a USHORT

	hr = GetLangBSTRFromLangID(&bstrNewLangBSTR, langid);
	if(FAILED(hr)) 
		return hr;

	m_spbsSessionLang = bstrNewLangBSTR;
	m_langIDSessionLang = langid;

	return S_OK;
}

STDMETHODIMP
CATVEFMedia::get_LangID(SHORT *pslangid)
{
	ENTER_API {
		ValidateOutPtr(pslangid, (SHORT) 0);
		*pslangid = m_langIDSessionLang;
	} EXIT_API;
}

STDMETHODIMP
CATVEFMedia::put_SDPLangID(SHORT slangid)
{
	BSTR		bstrNewLangBSTR;
	HRESULT		hr;

	ENTER_API {
		LANGID langid = slangid;
		hr = GetLangBSTRFromLangID(&bstrNewLangBSTR, langid);
		if(FAILED(hr))
			return hr;

		m_spbsSDPLang = bstrNewLangBSTR;
		m_langIDSDPLang = langid;
	} EXIT_API_(hr);
}

STDMETHODIMP
CATVEFMedia::get_SDPLangID(SHORT *puslangid)
{
	HRESULT hr = S_OK;
	ENTER_API {
		ValidateOutPtr(puslangid, (SHORT) 0);
		*puslangid = m_langIDSDPLang;
	} EXIT_API_(hr);
}

STDMETHODIMP
CATVEFMedia::put_MaxCacheSize(LONG lSize)
{
	if(lSize > 1000000)
		return E_INVALIDARG;
	m_ulSize = (ULONG) lSize;
	return S_OK;
}

STDMETHODIMP
CATVEFMedia::get_MaxCacheSize(LONG *plSize)
{
	ENTER_API {
		ValidateOutPtr(plSize, (LONG) 0);
		*plSize = (LONG) m_ulSize;
	} EXIT_API;
}


STDMETHODIMP 
CATVEFMedia::put_MediaLabel (
    IN  BSTR    bstrMediaLabel
    )
{
	ENTER_API {
		m_spbsMediaLabel = bstrMediaLabel;
	} EXIT_API;
}

STDMETHODIMP 
CATVEFMedia::get_MediaLabel (
    OUT  BSTR    *pbstrMediaLabel
    )
{
	HRESULT hr;
	ENTER_API {
		ValidateOutPtr(pbstrMediaLabel, (BSTR) NULL);
		hr = m_spbsMediaLabel.CopyTo(pbstrMediaLabel);
	} EXIT_API_(hr);
}


// ----------------
//   Uses key a map key.  Hence will fail if attempt to
//	  add more than one key/name pair with same key.
STDMETHODIMP 
CATVEFMedia::AddExtraAttribute(BSTR bstrKey, BSTR bstrValue)
{
	try {
		return m_spalExtraAttributes->Add(bstrKey, bstrValue);
	} catch(...) {
        return E_POINTER;
    }
}

STDMETHODIMP 
CATVEFMedia::get_ExtraAttributes(IDispatch **ppVal)
{
 	HRESULT hr;
 	if (ppVal == NULL)
		return E_POINTER;
	try {
        hr = m_spalExtraAttributes->QueryInterface(ppVal);
    } catch(...) {
        return E_POINTER;
    }
	return hr;
}


STDMETHODIMP 
CATVEFMedia::AddExtraFlag(BSTR bstrKey, BSTR bstrValue)
{
	if(NULL == bstrKey || wcslen(bstrKey) != 1)				// type (key) is always one character and is case significant (1998 SDP spec, section 6)
	{
		return E_INVALIDARG;
	}
	if(NULL == bstrValue || wcslen(bstrValue) < 1)
	{
		return E_INVALIDARG;
	}
	
	try {
		return m_spalExtraFlags->Add(bstrKey, bstrValue);
	} catch(...) {
        return E_POINTER;
    }
}

STDMETHODIMP 
CATVEFMedia::get_ExtraFlags(IDispatch **ppVal)
{
 	HRESULT hr;
 	if (ppVal == NULL)
		return E_POINTER;
	try {
        hr = m_spalExtraAttributes->QueryInterface(ppVal);
    } catch(...) {
        return E_POINTER;
    }
	return hr;
}

STDMETHODIMP 
CATVEFMedia::MediaToBSTR(BSTR *bstrVal)
{
	CComBSTR bstrM(256);
	char pcBuff[256];
	HRESULT hr;

	ENTER_API {
		ValidateOutPtr(bstrVal, (BSTR) NULL);

		if(m_bSingleDataTriggerAddress)			// use 'data' info here
		{
			bstrM = L"m=data ";
			_ltoa(m_lDataPort, pcBuff, 10);
			bstrM += CComBSTR(pcBuff);

			bstrM += L"/2 tve-file/tve-trigger\n";

			bstrM += L"c=IN IP4 ";
			bstrM += m_spbsDataAddIP;
			bstrM += L"/";

			ULONG ul = m_uiDataTTL;
			_ultoa(ul, pcBuff, 10);
			bstrM += CComBSTR(pcBuff);

			bstrM += L"\n";

			// Max Bandwidth
			bstrM += "b=CT:";

			_ultoa(m_ulDataMaxBandwidth, pcBuff, 10);
			bstrM += CComBSTR(pcBuff);
			bstrM += L"\n";
		}
		else
		{
						// file part
			bstrM = L"m=data ";
			_ltoa(m_lDataPort, pcBuff, 10);
			bstrM += CComBSTR(pcBuff);

			bstrM += L" tve-file\n";

			bstrM += L"c=IN IP4 ";
			bstrM += m_spbsDataAddIP;
			bstrM += L"/";

			ULONG ul = m_uiDataTTL;
			_ultoa(ul, pcBuff, 10);
			bstrM += CComBSTR(pcBuff);
			bstrM += L"\n";

			bstrM += "b=CT:";
			_ultoa(m_ulDataMaxBandwidth, pcBuff, 10);
			bstrM += CComBSTR(pcBuff);
			bstrM += L"\n";

							// trigger part
			bstrM += L"m=data ";
			_ltoa(m_lTrigPort, pcBuff, 10);
			bstrM += CComBSTR(pcBuff);

			bstrM += L" tve-trigger\n";

			bstrM += L"c=IN IP4 ";
			bstrM += m_spbsTrigAddIP;
			bstrM += L"/";

			ul = m_uiTrigTTL;
			_ultoa(ul, pcBuff, 10);
			bstrM += CComBSTR(pcBuff);

			bstrM += L"\n";
			bstrM += "b=CT:";

			_ultoa(m_ulTrigMaxBandwidth, pcBuff, 10);
			bstrM += CComBSTR(pcBuff);
			bstrM += L"\n";
		}

		//  show label
		if (0 != m_spbsMediaLabel.Length()) {
			bstrM +=  L"i=";
			bstrM +=  m_spbsMediaLabel ;
			bstrM +=  L"\n";
		}
		if(0 != m_spbsSessionLang.Length())
		{
			bstrM += L"a=lang:";
			bstrM += m_spbsSessionLang;
			bstrM +=  L"\n";
		}
		if(0 != m_spbsSDPLang.Length())
		{
			bstrM += L"a=sdplang:";
			bstrM += m_spbsSDPLang;
			bstrM += L"\n";
		}


		LONG cAttrs = 0;
		if(m_spalExtraAttributes) m_spalExtraAttributes->get_Count(&cAttrs);
		if(0 != cAttrs)
		{
			for(int i = 0; i < cAttrs; i++) {
				CComBSTR spbsKey, spbsItem;		// address, name
				CComVariant id(i);
				m_spalExtraAttributes->get_Key(id, &spbsKey);
				m_spalExtraAttributes->get_Item(id, &spbsItem);
				bstrM += L"a=";
				bstrM += spbsKey;
				if(spbsItem && (spbsItem.Length() > 0)) 
				{
					bstrM += L":";
					bstrM += spbsItem;
				}
				bstrM += L"\n";
			}
		}

		cAttrs = 0;
		if(m_spalExtraFlags) m_spalExtraFlags->get_Count(&cAttrs);
		if(0 != cAttrs)
		{
			for(int i = 0; i < cAttrs; i++) {
				CComBSTR spbsKey, spbsItem;		// address, name
				CComVariant id(i);
				m_spalExtraFlags->get_Key(id, &spbsKey);
				m_spalExtraFlags->get_Item(id, &spbsItem);
				bstrM += spbsKey;
				bstrM += L"=";
				bstrM += spbsItem;
				bstrM += L"\n";
			}
		}
	
		hr = bstrM.CopyTo(bstrVal);
	} EXIT_API_(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tverouter.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVERouter.h : Declaration of the CATVEFRouterSession

#ifndef __ATVEFROUTERSESSION_H_
#define __ATVEFROUTERSESSION_H_

#include "resource.h"       // main symbols
#include "TveAnnc.h"		// major objects

/////////////////////////////////////////////////////////////////////////////
// CATVEFRouterSession
class ATL_NO_VTABLE CATVEFRouterSession : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATVEFRouterSession, &CLSID_ATVEFRouterSession>,
	public ISupportErrorInfo,
	public IDispatchImpl<IATVEFRouterSession, &IID_IATVEFRouterSession, &LIBID_ATVEFSENDLib>
{
public:
	CATVEFRouterSession() {m_pcotveAnnc = NULL;}
	HRESULT FinalConstruct();
	HRESULT FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_ATVEFROUTERSESSION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATVEFRouterSession)
	COM_INTERFACE_ENTRY(IATVEFRouterSession)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IATVEFRouterSession
public:
	STDMETHOD(get_Announcement)(/*[out, retval]*/ IDispatch* *pVal);
	STDMETHOD(SetCurrentMedia)(/*[in]*/ LONG lMedia);
	STDMETHOD(SendTrigger)(/*[in]*/ BSTR bstrURL, /*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrScript, /*[in]*/ DATE dateExpires);
	STDMETHOD(SendRawTrigger)(/*[in]*/ BSTR bstrTrigger);
	STDMETHOD(SendPackage)(/*[in]*/ IATVEFPackage *pPackage);
	STDMETHOD(SendAnnouncement)();
	STDMETHOD(Disconnect)();
	STDMETHOD(Connect)();
	STDMETHOD(Initialize)(BSTR bstrRouterHostname);
			// Helper methods
	STDMETHOD(DumpToBSTR)(/*[out]*/ BSTR *pBstrBuff);

protected:
	CComObject<CATVEFAnnouncement>		*m_pcotveAnnc;		// down pointer

};

#endif //__ATVEFROUTERSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvepack.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEPack.h : Declaration of the CATVEFPackage

#ifndef __ATVEFPACKAGE_H_
#define __ATVEFPACKAGE_H_

#include "resource.h"       // main symbols

#include "uhttpfrg.h"
#include "gzmime.h"
#include "trace.h"
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  VBuffer
//  
//  This template provides an array of class T objects, either from
//  an internally allocated buffer, or a heap-allocated buffer, in the
//  case where the requested allocation is longer than the internally
//  allocated size.

template <class T, int InitMax>			// todo - replace with an STL vector...
class VBuffer
{
    T   m_Buffer [InitMax] ;
    T * m_pBuffer ;
    int m_AllocatedLength ;

    public :

        VBuffer ()
        {
            m_pBuffer = & m_Buffer [0] ;
            m_AllocatedLength = InitMax ;
        }

        ~VBuffer ()
        {
            if (m_pBuffer != & m_Buffer [0]) {
                delete m_pBuffer ;
            }
        }

        HRESULT
        Get (
            IN OUT  int *   plength,
            OUT     T **    ppb
            )
        {
            assert (ppb) ;
            assert (plength > 0) ;

            if (* plength > m_AllocatedLength) {
                if (m_pBuffer != & m_Buffer [0]) {
                    delete m_pBuffer ;
                }

                m_pBuffer = new T [* plength] ;
                if (m_pBuffer == NULL) {

                    m_AllocatedLength = InitMax ;
                    m_pBuffer = & m_Buffer [0] ;
                    * ppb = NULL ;

                    return E_OUTOFMEMORY ;
                }

                m_AllocatedLength = * plength ;
            }

            * ppb = m_pBuffer ;
            * plength = m_AllocatedLength ;

            return S_OK ;
        }
} ;

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

//  not thread-safe
class CPackage
{
    enum PACKAGE_STATE {
        STATE_EMPTY,        //  no files in the package
        STATE_FILLING,      //  package is open and filling i.e. >= 1 file has
                            //   been successfully packed
        STATE_CLOSED,       //  package has >= 1 file and is closed to more 
                            //   additions
        STATE_FRAGMENTED,   //  package was filled with >= 1 file and was 
                            //   successfully fragmented
        STATE_COUNT
    } ;


    PACKAGE_STATE       m_State ;
    CTVEComPack *       m_pCTVEComPack ;
    CHAR                m_GzipMIMEEncodedFile [MAX_PATH] ;
    DATE                m_ExpiresDate ;
	CComBSTR			m_spbsPackageUUID;		// these two should be in sync
	GUID				m_guidPackageUUID;
	LONG				m_cPacketsPerXORSet;	// 0 means pick default
	
	DWORD				m_dwFragmentedSize;

    public :
        
        CPackage () ;
        ~CPackage () ;

    CUHTTPFragment *    m_pUHTTPFragment ;

    HRESULT
    FragmentPackage_ (
        ) ;


        HRESULT
        InitializeEx (
            IN  DATE		ExpiresDate,
			IN	LONG		cPacketsPerXORSet,
			IN  LPOLESTR	bstrPackageUUID
            ) ;

		HRESULT
		get_PackageUUID (
			OUT  BSTR    *pbstrPackageUUID    
		);

        HRESULT
        AddFile (
            IN  LPOLESTR    szFilename,
			IN  LPOLESTR	szSourceLocation,
			IN  LPOLESTR    szMimeContentLocation,  
            IN  LPOLESTR    szMimeType,
            IN  DATE        ExpiresDate,
            IN  LONG        lLangID,
            IN  BOOL        fCompress
            ) ;

        HRESULT
        Close (
            ) ;

        HRESULT
        FetchNextDatagram (
            OUT LPBYTE *    ppbBuffer,
            OUT INT *       piLength
            ) ;

        HRESULT
        ResetDatagramFetch (
            ) ;

        HRESULT
        GetTransmitSize (
            OUT DWORD * TransmitBytes
            ) ;

		HRESULT 
		DumpToBSTR(
			OUT BSTR *pBstrBuff
			) ;

#ifdef SUPPORT_UHTTP_EXT  // a-clardi
		HRESULT
		AddExtensionHeader(
			IN BOOL		ExtHeaderFollows, 
			IN USHORT	ExtHeaderType,
			IN USHORT	ExtDataLength,
			IN BSTR		ExtHeaderData);

private :

		// Network byte order
		typedef struct tagUHTTP_ExtHEADER {
				USHORT   ExtHeaderType		: 15,
						 ExtFollows          : 1;
				USHORT	 ExtHeaderDataSize;
		} UHTTP_ExtHEADER, * LPUHTTP_ExtHEADER ;

        void HToNS(UHTTP_ExtHEADER *pHeader);            // convert whole header over..

		USHORT	m_nExtensionHeaderSize;
		BYTE*	m_pbExtensionData;
		BOOL	m_fExtensionExists;

#endif
} ;
/////////////////////////////////////////////////////////////////////////////
// CATVEFPackage
class ATL_NO_VTABLE CATVEFPackage : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATVEFPackage, &CLSID_ATVEFPackage>,
	public IATVEFPackage_Helper,
	public IATVEFPackage_Test,
	public ISupportErrorInfo,
	public IDispatchImpl<IATVEFPackage, &IID_IATVEFPackage, &LIBID_ATVEFSENDLib>
{
public:
	CATVEFPackage();
	~CATVEFPackage();

DECLARE_REGISTRY_RESOURCEID(IDR_ATVEFPACKAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATVEFPackage)
	COM_INTERFACE_ENTRY(IATVEFPackage)
	COM_INTERFACE_ENTRY(IATVEFPackage_Helper)
	COM_INTERFACE_ENTRY(IATVEFPackage_Test)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IATVEFPackage
public:

	STDMETHOD(TransmitTime)(/*[in]*/ float rExpectedTransmissionBitRate, /*[out]*/ float* prTransmissionTimeSeconds);
	STDMETHOD(Close)();
	STDMETHOD(AddFile)(/*[in]*/ BSTR bstrFilename, /*[in]*/ BSTR bstrSourceLocation, /*[in]*/ BSTR bstrMIMEContentLocation, 
					  /*[in]*/ BSTR bstrMIMEeContentType, /*[in]*/ DATE dateExpires, /*[in]*/ LONG lMIMEContentLanguageId, /*[in]*/ BOOL fCompress);
	STDMETHOD(AddDir)(/*[in]*/ BSTR bstrSourceDirname, /*[in]*/ BSTR bstrMIMEContentLocation, 
					  /*[in]*/ DATE dateExpires, /*[in]*/ LONG lMIMEContentLanguageId, /*[in]*/ BOOL fCompress);
	STDMETHOD(get_PackageUUID)(/*[out, retval]*/ BSTR *pbstrPackageUUID);

	STDMETHOD(Initialize)(/*[in]*/ DATE MimeContentExpires);
	STDMETHOD(InitializeEx)(/*[in]*/ DATE MimeContentExpires, /*[in]*/ LONG cPacketsPerXORSet, /*[in]*/ BSTR bstrPackageUUID);


			// Helper methods
	STDMETHOD(DumpToBSTR)(/*[out]*/ BSTR *pBstrBuff);


protected:
    CPackage *          m_pPackage ;
    CRITICAL_SECTION    m_crt ;

#if 1  // Added by a-clardi
	long m_cPacketsTotal;
	BYTE*		m_rgbCorruptMode;
#endif



	HRESULT AddLotsOFiles(BSTR bstrDirFilename,					// Recursive routine... Dir name
							BSTR bstrMIMEContentLocation,		// destination ("lid:/test")
							DATE dateExpires, 
							LONG lMIMEContentLanguageId,
							BOOL fCompress,
							long depth);	
  
public:
// IATVEFPackage_Helper
	STDMETHOD(Lock) ()
    {
        ENTER_CRITICAL_SECTION (m_crt, CTVEPackage::Lock);
		return S_OK;
    }

    STDMETHOD(Unlock) ()
    {
        LEAVE_CRITICAL_SECTION (m_crt, CTVEPackage::Unlock);
		return S_OK;
	}

	STDMETHOD(ResetDatagramFetch) ()
	{
#if 1 // Added by a-clardi
		m_cPacketsTotal = 0;
		return m_pPackage->ResetDatagramFetch();
#endif
	}

	STDMETHOD(FetchNextDatagram) (/*OUT*/ BSTR *pbstrData, /*out*/ int *piLengthBytes)		// not optimal code, does copy
	{
		BYTE *pbBuff;
		unsigned int iLength;
		HRESULT hr  = m_pPackage->FetchNextDatagram(&pbBuff, (int *) &iLength);
		*piLengthBytes = iLength;

		if(S_OK != hr || iLength == 0)  
		{
			if(FAILED(hr))
				Error(GetTVEError(hr), IID_IATVEFPackage);
			return hr;
		}
							// still copy data, but avoid lots of reallocs...
		if(!pbstrData || SysStringLen(*pbstrData)*2 < iLength)
		{
			CComBSTR bstrX((iLength+1)/2, (unsigned short *) pbBuff);
			*pbstrData = bstrX;	
		} else {
			memcpy((BYTE *) *pbstrData, pbBuff, iLength);
		}

		return S_OK;
    }

#if 1 // Added by a-clardi

public:
// IATVEFPackage_Test
	STDMETHOD(GetCorruptMode)(/*[in]*/ LONG nPacket, /*[out]*/ INT* bMode);
	STDMETHOD(get_NPackets)(/*[out]*/ LONG *pcPackets);
	STDMETHOD(CorruptPacket)(/*[in]*/ LONG nPacketID, /*[in	]*/ INT bMode);

	STDMETHOD(AddExtensionHeader) (/*[in]*/ BOOL ExtHeaderFollows, 
			/*[in]*/ USHORT	ExtHeaderType,
			/*[in]*/ USHORT	ExtDataLength,
			/*[in]*/ BSTR	ExtHeaderData);

#endif



};

#endif //__ATVEFPACKAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvepack.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEPack.cpp : Implementation of CATVEFPackage
#include "stdafx.h"
#include "ATVEFSend.h"
#include "TVEPack.h"

//#define _CRTDBG_MAP_ALLOC 
//#include "crtdbg.h"
#include "DbgStuff.h"

#include "ATVEFMsg.h"           // error codes (generated from the .mc file)
#include "valid.h"
#include <direct.h>
#include <io.h>                         // _finddata_t
#include <sys/types.h>
#include <sys/stat.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CPackage
/////////////////////////////////////////////////////////////////////////////
HRESULT
CPackage::FragmentPackage_ (
    )
/*++

    Routine Description:

        This routine fragments a gzipped, MIME-encode temp file.

        Private routine.

    Parameters:

        none

    Return Value:

        S_OK        success
        error code  failure

--*/
{
    HRESULT hr  = S_OK;

    ENTERW_OBJ_0 (L"CPackage::FragmentPackage_") ;

    //  make sure caller hasn't already called us once before
    assert (m_State == STATE_CLOSED) ;
    assert (m_pCTVEComPack == NULL) ;
    assert (strlen (m_GzipMIMEEncodedFile)) ;
    assert (m_pUHTTPFragment == NULL) ;

    m_pUHTTPFragment = new CUHTTPFragment ;
    if (m_pUHTTPFragment) 
	{

#ifdef SUPPORT_UHTTP_EXT
		if (m_fExtensionExists)
		{
			// Set extension header
			hr = m_pUHTTPFragment->SetExtensionHeader(
									m_nExtensionHeaderSize, m_pbExtensionData); 
		}
#endif
        hr = HRESULT_FROM_WIN32(m_pUHTTPFragment->Fragment(
                        m_GzipMIMEEncodedFile, 
                        m_cPacketsPerXORSet,
                        &m_guidPackageUUID)) ;
    }
    else {
        hr = E_OUTOFMEMORY ;
    }

    //  delete the tmp file regardless or success or failure
    DeleteFileA (m_GzipMIMEEncodedFile) ;
    m_GzipMIMEEncodedFile [0] = '\0' ;

    //  if the fragmentation failed, we're back to the empty state; cleanup
    //  and pass the error back
    if (FAILED (hr)) {

        m_State = STATE_EMPTY ;
        DELETE_RESET (m_pUHTTPFragment) ;
        return hr ;
    }

    //  successfully fragmented
    m_State = STATE_FRAGMENTED ;

    return hr ;
}
    
CPackage::CPackage (
    ) : m_ExpiresDate (0),
        m_pCTVEComPack (NULL),
        m_State (STATE_EMPTY),
        m_pUHTTPFragment (NULL),
                m_cPacketsPerXORSet(0),
                m_dwFragmentedSize(0),
#ifdef SUPPORT_UHTTP_EXT
		m_nExtensionHeaderSize(0),
		m_pbExtensionData(NULL),
		m_fExtensionExists(FALSE)
#endif
/*++

    Routine Description:

        constructor; non-failable

    Parameters:

        none

    Return Value:

        none

--*/
{
    ENTERW_OBJ_0 (L"CPackage::CPackage") ;

    m_GzipMIMEEncodedFile [0] = '\0' ;
        memset((void*)&m_guidPackageUUID ,0,sizeof(m_guidPackageUUID));
}

CPackage::~CPackage ()
/*++

    Routine Description:

        destructor; releases all allocated resources

    Parameters:

        none

    Return Value:

        none

--*/
{
    ENTERW_OBJ_0 (L"CPackage::~CPackage") ;
        int err;
        HRESULT hr = S_OK;

#ifdef SUPPORT_UHTTP_EXT
	delete [] m_pbExtensionData;
#endif

    if (m_State != STATE_EMPTY) {
        if (SUCCEEDED (Close ())) {
            if (strlen (m_GzipMIMEEncodedFile)) {
                err = DeleteFileA (m_GzipMIMEEncodedFile) ;
                                if(0 == err) {
                                        int errCode = GetLastError();
                                        hr = HRESULT_FROM_WIN32(errCode);               // keep track of error, although we can't do anything about it
                                }
            }
        }
    }

    DELETE_RESET (m_pCTVEComPack) ;
    DELETE_RESET (m_pUHTTPFragment) ;
}

HRESULT
CPackage::get_PackageUUID (
    OUT  BSTR    *pbstrPackageUUID    
    )
{
        return m_spbsPackageUUID.CopyTo(pbstrPackageUUID);
}

HRESULT
CPackage::InitializeEx (
    IN  DATE            ExpiresDate,
        IN      LONG            cPacketsPerXORSet,
        IN      LPOLESTR        bstrPackageUUID
    )
{
        HRESULT hr = S_OK, hrTotal = S_OK;

    m_ExpiresDate         = ExpiresDate ;
        m_spbsPackageUUID = bstrPackageUUID;            
        memset((void*)&m_guidPackageUUID ,0,sizeof(m_guidPackageUUID));

        CComBSTR bstrT(L"{");                                           // need to pack the "{}" around the guid
        bstrT += m_spbsPackageUUID;
        bstrT += L"}";

                                        // if passed in as string, convert to number format to verify it's a good one

        if(NULL != bstrPackageUUID && 0 != wcslen(bstrPackageUUID))
        {
                HRESULT hr = CLSIDFromString(bstrT, &m_guidPackageUUID);        // convert to numerical format
                if(FAILED(hr)) {
                        hrTotal = hr;                                                                   // if failed (bad syntax)
                        m_spbsPackageUUID = L"";                                                        //  set to null (regen a new one...)
                }
        }
                        // if it wasn't a good String Guid we passed in or we didn't pass one it at all,
                        //   generate a new one...
                        
        if(0 == m_spbsPackageUUID.Length())
        {
                if (FAILED (hr = CoCreateGuid (&m_guidPackageUUID)))
                         return hr;
                LPOLESTR lpstrTemp;
                hr = StringFromCLSID(m_guidPackageUUID,&lpstrTemp);
                if(FAILED(hr))
                        return hr;
                        // strip the "{" and "}"
                m_spbsPackageUUID = &lpstrTemp[1];              // skip the "{";
                CoTaskMemFree(lpstrTemp);

                int iLen = m_spbsPackageUUID.Length();
                m_spbsPackageUUID[iLen-1] = 0;                  // nuke the "}"
        }

    return hrTotal ;
}

HRESULT
CPackage::AddFile (
    IN  LPOLESTR    szFilename,
        IN  LPOLESTR    szSourceLocation,
    IN  LPOLESTR    szMIMEContentLocation,
    IN  LPOLESTR    szMIMEType,
    IN  DATE        ExpiresDate,
    IN  LONG        lLangID,
    IN  BOOL        fCompress
    )
/*++

    Routine Description:

        COM interface method called to submit the contents of a file to be 
        gzipped and MIME-encoded.

    Parameters:
        
            szFilename                                  base name of file
        szSourceLocation                        directory to read file from.  Ok if ""
                szMIMEContentLocation           MIME directory (http:\ or lid:\) to write file to
        szMimeType                                      OK if ""        
        ExpiresDate
        lLangID                                         
        fCompress                                       if true, compress file, else send it as uncompressed

    Return Value:

        

--*/
{
 
                /*      char *pLeak = new char[100];            
                        memset(pLeak,6,100);
                        delete pLeak;                                           // fails without the MSVCRTD.lib in the path
                */

        CTVEContentSource           Source ;
        VBuffer <CHAR, MAX_PATH>    Buffer ;
        HRESULT                     hr  = S_OK;

        USES_CONVERSION;

        ENTERW_OBJ_0 (L"CPackage::AddFile") ;

        //  check for NULL or 0-length parameters
        if (szFilename == NULL           || szFilename [0] == L'\0' ||
                szSourceLocation == NULL || 
                szMIMEContentLocation == NULL || szMIMEContentLocation [0] == L'\0' ||
                szMIMEType == NULL) {

                return E_INVALIDARG ;
        }

        if (m_State == STATE_CLOSED ||
                m_State == STATE_FRAGMENTED) {
                return ATVEFSEND_E_PACKAGE_CLOSED ;
        }

        //  convert to ansi

        //  filename
        if (wcslen (szFilename) + wcslen (szSourceLocation) > MAX_PATH - 2) {
//              Error(L"Invalid Arg", IID_IATVEFPackage);
                return E_INVALIDARG ;
        }

        hr = Source.SetFilename (W2A(szFilename)) ;
        if (FAILED (hr)) {
//              Error(L"Error in SetFilename", IID_IATVEFPackage);
                return hr ;
        }

        //  Source location

        hr = Source.SetSourceLocation (W2A(szSourceLocation)) ;         // add's the '\' if needed
        if (FAILED (hr)) {
//              Error(L"Error in SetSourceLocation", IID_IATVEFPackage);
                return hr ;
        }

        //  MIME Content location

        hr = Source.SetMIMEContentLocation (W2A(szMIMEContentLocation)) ;               // add's the '\' if needed
        if (FAILED (hr)) {
//              Error(L"Error in SetSourceLocation", IID_IATVEFPackage);
                return hr ;
        }

        //  type (treat as optional)
        if (szMIMEType) {
                hr = Source.SetType (W2A(szMIMEType)) ;
                if (FAILED (hr)) {
//                      Error(L"Error in SetType", IID_IATVEFPackage);
                        return hr ;
                }
        }
        else {
                hr = Source.SetType (NULL) ;
                if (FAILED (hr)) {
//                      Error(L"Error in SetType", IID_IATVEFPackage);
                        return hr ;
                }
        }

        //  expiration date
        if (ExpiresDate != 0.0) {
                Source.SetExpiresDate (& ExpiresDate) ;
        }

        //  make the last two settings

        if (SUCCEEDED (hr = Source.SetLang (lLangID))) {

                //  if this is our first file, we'll need to create a new instance
                //  of the packing object
                if (m_pCTVEComPack == NULL) {

                        assert (m_State == STATE_EMPTY) ;

                        m_pCTVEComPack = new CTVEComPack ;
                        if (m_pCTVEComPack == NULL) {
                                return E_OUTOFMEMORY ;
                        }

                        if (FAILED (hr = m_pCTVEComPack ->Init(m_ExpiresDate))) {
                                DELETE_RESET(m_pCTVEComPack) ;
//                              Error(L"Error in Setting Expire Date", IID_IATVEFPackage);
                                 return hr ;
                        }
                }

                hr = m_pCTVEComPack -> WriteStream (& Source, fCompress) ;

                if (SUCCEEDED(hr)) {
                        m_State = STATE_FILLING ;
                }
                else {          
//                      BUG Fix ... don't reset the state if failed... (JB. 2-22-00)
//                      DELETE_RESET (m_pCTVEComPack);
//                      m_State = STATE_EMPTY ;                 // new bug? what happens if fail on first file?
                }
        }

    return hr ;
}

HRESULT
CPackage::Close (
    )

{
    HRESULT hr  = S_OK;

        ENTERW_OBJ_0 (L"CPackage::Close") ;

        assert (((m_State == STATE_EMPTY || m_State == STATE_CLOSED || m_State == STATE_FRAGMENTED) && 
                          m_pCTVEComPack == NULL) ||
                        (m_State == STATE_FILLING && m_pCTVEComPack != NULL)) ;

        //  if we can't get to STATE_CLOSED from our current
        //  state, fail now
        if (m_State == STATE_EMPTY ||
                m_State == STATE_FRAGMENTED) {

                return ATVEFSEND_E_PACKAGE_CANNOT_BE_CLOSED ;
        }

        //  if we're already closed, return success
        if (m_State == STATE_CLOSED) {
                return S_OK ;
        }

        assert (m_State == STATE_FILLING) ;
        assert (m_pCTVEComPack) ;
        assert (strlen (m_GzipMIMEEncodedFile) == 0) ;

        hr = m_pCTVEComPack -> FinishPackage (m_GzipMIMEEncodedFile) ;
        DELETE_RESET (m_pCTVEComPack) ;

        //  if the above call failed but we still have a filename, delete it
        //  and null-terminate the filename
        if (FAILED (hr) &&
                strlen (m_GzipMIMEEncodedFile)) {

                DeleteFileA (m_GzipMIMEEncodedFile) ;
                m_GzipMIMEEncodedFile [0] = '\0' ;

                m_State = STATE_EMPTY ;
        }
        //  otherwise set our state to FULL
        else {
                m_State = STATE_CLOSED ;
        }

        assert ((hr == S_OK && m_State == STATE_CLOSED) ||
                        (FAILED (hr) && m_State == STATE_EMPTY)) ;

    return hr ; 
}


HRESULT
CPackage::FetchNextDatagram (
    OUT LPBYTE *    ppbBuffer,
    OUT INT *       piLength
    )

{
    HRESULT hr  = S_OK;

        ENTERW_OBJ_2 (L"CPackage::FetchNextDatagram (%08XH, %08XH)", ppbBuffer, piLength) ;

        if (ppbBuffer == NULL ||
                piLength == NULL) {

                return E_INVALIDARG ;
        }

        * ppbBuffer = NULL ;
        * piLength = 0 ;

        //  fragment if necessary
        if (m_State != STATE_FRAGMENTED) {

                //  but only if we have files and are not closed
                if (m_State == STATE_CLOSED) {
                        hr = FragmentPackage_ () ;
                        if (FAILED (hr)) {
                                return hr ;
                        }
                }
                else {
                   return ATVEFSEND_E_PACKAGE_CANNOT_FETCH_DATAGRAM ;
                }
        }
        HRESULT hrWIN32 = m_pUHTTPFragment -> GetNextDatagram (ppbBuffer, piLength);
        m_dwFragmentedSize += *piLength;

    //  and get the next datagram
    return HRESULT_FROM_WIN32 (hrWIN32) ;
}

HRESULT
CPackage::ResetDatagramFetch (
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    HRESULT hr = S_OK;

    ENTERW_OBJ_0 (L"CPackage::ResetDatagramFetch") ;

    //  we only have two states from which this operation can be performed
    if (m_State == STATE_FRAGMENTED) {
        hr = HRESULT_FROM_WIN32 (m_pUHTTPFragment -> Reset ()) ;
    }
    else if (m_State == STATE_CLOSED) {
        hr = FragmentPackage_ () ;
    }
    else {
        hr = E_FAIL ;
    }

        m_dwFragmentedSize = 0;

    return hr ;
}


HRESULT
CPackage::GetTransmitSize (
    OUT DWORD * TransmitBytes
    )
{
    HRESULT hr = S_OK;
    DWORD   FileSize ;
    HANDLE  hFile ;

    ENTERW_OBJ_0 (L"CPackage::GetTransmitSize") ;

    assert (TransmitBytes) ;

        if (m_State == STATE_FRAGMENTED)
        {
                *TransmitBytes = m_dwFragmentedSize;
                return S_OK;
        }

    if (m_State != STATE_CLOSED) {
        return ATVEFSEND_E_PACKAGE_NOT_CLOSED;
    }

    assert (m_GzipMIMEEncodedFile [0] != '\0') ;
    hFile = CreateFileA (
                m_GzipMIMEEncodedFile,
                GENERIC_READ,
                NULL,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL) ;
    assert (hFile) ;

    FileSize = GetFileSize (hFile, NULL) ;
    CloseHandle (hFile) ;

    hr = CUHTTPFragment::GetTransmitSize (
                                FileSize,
                                TransmitBytes
                                ) ;

    if (hr != NO_ERROR) {
        hr = HRESULT_FROM_WIN32 (hr) ;
    }

    return  hr ;
}

#ifdef SUPPORT_UHTTP_EXT  // a-clardi

static const int MAX_EXTDATA_SIZE = 1024;

    // converts the header to network byte order..
void CPackage::HToNS(UHTTP_ExtHEADER *pHeader)
{
    USHORT *px = (USHORT *) pHeader;
    *px = htons(*px);                   // flip data type and ExtHeaderFollows flag
    pHeader->ExtHeaderDataSize = htons(pHeader->ExtHeaderDataSize);
}

HRESULT
CPackage::AddExtensionHeader(
			IN BOOL		ExtHeaderFollows, 
			IN USHORT	ExtHeaderType,
			IN USHORT	ExtDataLength,
			IN BSTR		ExtHeaderData)
{
	HRESULT hr = NO_ERROR;

	m_fExtensionExists = TRUE;

	UHTTP_ExtHEADER sExtHeader;

	sExtHeader.ExtFollows = ExtHeaderFollows ? 1 : 0;               // these orignal in non network byte order
	sExtHeader.ExtHeaderType = ExtHeaderType;                       //  convert right before we write it...

	USHORT usLengthReal = 0, usLengthPadded = 0;
	if (ExtHeaderData)
	{
    	usLengthReal     = (USHORT) wcslen(ExtHeaderData);
    	usLengthPadded   = usLengthReal;
#ifndef _NOROUNDING
    	usLengthPadded = (usLengthPadded + 0x3) & ~0x3;		        // round up to nearest 4
#endif
	    if (usLengthPadded > MAX_EXTDATA_SIZE)
		    usLengthPadded = MAX_EXTDATA_SIZE;

	    if (usLengthReal > MAX_EXTDATA_SIZE)
		    usLengthReal = MAX_EXTDATA_SIZE;
    }

	sExtHeader.ExtHeaderDataSize = usLengthPadded;		           // write null padded size..

	// If first extension header
	if (m_nExtensionHeaderSize == 0)  
	{
		m_pbExtensionData = new BYTE [sizeof UHTTP_ExtHEADER + usLengthPadded];

		// Copy headers to a memory stream
		if (m_pbExtensionData)
		{
            HToNS(&sExtHeader);         // convert to network byte order and write it out
			memcpy(m_pbExtensionData, &sExtHeader, sizeof UHTTP_ExtHEADER);
                                        
			m_nExtensionHeaderSize = sizeof UHTTP_ExtHEADER + usLengthPadded;
			if (ExtHeaderData)
            {
    
		    	BYTE *p = (m_pbExtensionData + sizeof UHTTP_ExtHEADER);
			    for (USHORT i = 0; i < usLengthReal; i++)
			    {
				   *p++ = (BYTE)ExtHeaderData[i];           // copy data, converting WCHAR's to Chars
			    }
			    for(USHORT i = usLengthReal; i < usLengthPadded; i++)
			    {
				    *p++ = 0;					// NULL pad
			    }
		    }
        }
	}
	else 
	{
                                                // New size...
		int newSize = m_nExtensionHeaderSize + sizeof(UHTTP_ExtHEADER) + usLengthPadded;
                // should really assert that newSize < 1500 or so here, else no space for data!
                //  However, leave that for the next version...

		// Allocate new memory and copy old headers to new one
		BYTE *pbNew = new BYTE [newSize];
		if (pbNew)
		{
                        // copy old data
			memcpy(pbNew, m_pbExtensionData, m_nExtensionHeaderSize);
			delete [] m_pbExtensionData;

			m_pbExtensionData = pbNew;

            HToNS(&sExtHeader);                  // convert new header, and append it...
			memcpy(m_pbExtensionData + m_nExtensionHeaderSize, &sExtHeader, sizeof UHTTP_ExtHEADER);

			if (ExtHeaderData)
			{
				BYTE *p = (m_pbExtensionData + m_nExtensionHeaderSize + sizeof UHTTP_ExtHEADER);
				for (USHORT i = 0; i < usLengthReal; i++)
				{
					*p++ = (BYTE)ExtHeaderData[i];
				}
			    for(USHORT i = usLengthReal; i < usLengthPadded; i++)
			    {
				    *p++ = 0;					// NULL pad
			    }
			}
            m_nExtensionHeaderSize = (USHORT) newSize;
		}
	}

	return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CATVEFPackage
CATVEFPackage::CATVEFPackage () : 
		m_pPackage (NULL),
#if 1  // a-clardi
		m_rgbCorruptMode(NULL)
#endif 
{
    ENTERW_OBJ_0 (L"CATVEFPackage::CATVEFPackage") ;
        
//    InterlockedIncrement (& g_cComponents) ;
    InitializeCriticalSection (& m_crt) ;
}

CATVEFPackage::~CATVEFPackage()
{
#if 1 // Added by a-clardi
	if (m_rgbCorruptMode)
	{
		delete m_rgbCorruptMode;
	}
#endif

    ENTERW_OBJ_0 (L"CATVEFPackage::~CATVEFPackage") ;

    DELETE_RESET (m_pPackage) ;
    DeleteCriticalSection (& m_crt) ;

 //   InterlockedDecrement (& g_cComponents) ;
}

STDMETHODIMP CATVEFPackage::InterfaceSupportsErrorInfo(REFIID riid)
{
        static const IID* arr[] = 
        {
                &IID_IATVEFPackage,
                &IID_IATVEFPackage_Helper,
                &IID_IATVEFPackage_Test
        };
        for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
        {
                if (InlineIsEqualGUID(*arr[i],riid))
                        return S_OK;
        }
        return S_FALSE;
}

// -----------------------------------------------------------------
//  Initialize,InitializeEx
//
//              Creates a new package to store files in.  This package is
//              marked with an expire date, use '0' for never expires.
//
//              BstrPackageUUID specifies the unique UUID for this package.  If
//              it's null or empty string, then one is automatically created for it.  
//              Else it uses the supplied one as the unique guid of that package.
//
//
//              May return E_OUTOFMEMORY if unable to allocate resources.
//              May return ATVEFSEND_E_INVALID_UUID if the UUID passed to it is invalid.
//
//      Notes
//              This works by creating a local file on your disk along the lines
//              of $SYSTEMROOT:\Documents and Settings\$userName\Local Settings\???.tmp
//              (D:\Documents and Settings\johnbrad\Local Settings\???.tmp
// ------------------------------------------------------------------
STDMETHODIMP CATVEFPackage::Initialize(DATE     ExpiresDate)
{
        const int kDefaultPacketsPerXORSet = 5;

#if 1 // Added by a-clardi
		m_cPacketsTotal = 0;
		m_rgbCorruptMode = NULL;
#endif

        return InitializeEx(ExpiresDate, kDefaultPacketsPerXORSet, L"");
}

STDMETHODIMP CATVEFPackage::InitializeEx(DATE dateMimeContentExpires, LONG cPacketsPerXORSet, BSTR bstrPackageUUID)
{
        HRESULT hr = S_OK;
        
        ENTER_API {
                ENTERW_OBJ_0 (L"CATVEFPackage::PackageNew") ;

                Lock () ;

                if (m_pPackage == NULL) {
                        m_pPackage = new CPackage () ;
                        if (m_pPackage) {
                                hr = m_pPackage -> InitializeEx (dateMimeContentExpires, cPacketsPerXORSet, bstrPackageUUID) ;
                        }
                        else {
                                hr = E_OUTOFMEMORY ;
                        }
                }
                else {
        //              Error(IDS_INVALIDOBJECT_INITIALIZED, IID_IATVEFPackage);
                        hr = ATVEFSEND_E_OBJECT_INITIALIZED ;
                }

                Unlock () ;

                if(FAILED(hr))
                        Error(GetTVEError(hr), IID_IATVEFPackage);

        } EXIT_API_(hr);
}

// --------------------------------------------------------------------------
//  AddFile
STDMETHODIMP 
CATVEFPackage::get_PackageUUID (
    OUT  BSTR    *pbstrPackageUUID
    )
{
    HRESULT hr ;

        ENTER_API {
                ValidateOutPtr( pbstrPackageUUID,(BSTR) NULL);
                hr = m_pPackage->get_PackageUUID (pbstrPackageUUID) ;
        } EXIT_API_(hr);
}
// --------------------------------------------------------------------------
//  AddFile
//
//              Adds one file to the package, with source filename bstrFileLocation\bstrFilename, 
//              and stores it into the directory bstrMIMEContentLocation\bstrFilename.
//
//                      Typically:
//                              bstrFilename:                           simple file name (foo.bmp),  
//                              bstrFileLocation:                       source file directory (c:\files) (or "." for current dir)
//                              bstrMIMEContentLocation:        HTTP: or LID:   (lid:\Show1)
//                              bstrMIMEContentType:            text/html or image/jpg, ...
//
//              Use 0x400 for default language ID...
//
//              Will return:
//                      ATVEFSEND_E_OBJECT_INITIALIZED if package not initialized.
//                      ATVEFSEND_E_PACKAGE_CLOSED if package has been closed
//                      E_OUTOFMEMORY if unable to allocate enough resources.
//                      Various other system errors if it can't find or read the given file.
// --------------------------------------------------------------------------
STDMETHODIMP CATVEFPackage::AddFile(BSTR bstrFilename,                          // file name
                                                                    BSTR bstrFileLocation,                      // source directory
                                                                    BSTR bstrMIMEContentLocation,               // destination ("lid:/test")
                                                                    BSTR bstrMIMEContentType, 
                                                                    DATE dateExpires, 
                                                                    LONG lMIMEContentLanguageId,
                                                                    BOOL fCompress)
{
        HRESULT hr = S_OK;;

        ENTER_API {


                ENTERW_OBJ_5 (L"CATVEFPackage::PackageAdd (\"%s\", \"%s\", \"%s\", \"%s\", %08XH)", 
                                          bstrFilename, bstrFileLocation, bstrMIMEContentLocation, bstrMIMEContentType, lMIMEContentLanguageId) ;

                Lock () ;

                //  package must be initialized first
                if (m_pPackage == NULL) {
        //              Error(IDS_INVALIDOBJECT_INITIALIZED, IID_IATVEFPackage);
                        hr = ATVEFSEND_E_OBJECT_INITIALIZED ;
                        goto cleanup ;
                }

                assert (m_pPackage) ;

                hr =  m_pPackage -> AddFile (
                                                                bstrFilename, 
                                                                bstrFileLocation,
                                                                bstrMIMEContentLocation, 
                                                                bstrMIMEContentType, 
                                                                dateExpires,
                                                                lMIMEContentLanguageId,
                                                                fCompress
                                                                ) ;

                hr = HRESULT_FROM_WIN32(hr);

        cleanup :
                Unlock () ;

        if(FAILED(hr))
                Error(GetTVEError(hr), IID_IATVEFPackage);

        } EXIT_API_(hr);
}

STDMETHODIMP CATVEFPackage::AddDir(BSTR bstrSourceDirname,                              // Dir name
                                                                    BSTR bstrMIMEContentLocation,               // destination ("lid:/test")
                                                                    DATE dateExpires, 
                                                                    LONG lMIMEContentLanguageId,
                                                                    BOOL fCompress)
{
        HRESULT hr = S_OK;;

        ENTER_API {

                ENTERW_OBJ_3(L"CATVEFPackage::DirAdd (\"%s\", \"%s\",  %08XH)", 
                                          bstrSourceDirname, bstrMIMEContentLocation, lMIMEContentLanguageId) ;

                Lock () ;

                //  package must be initialized first
                if (m_pPackage == NULL) {
                        hr = ATVEFSEND_E_OBJECT_INITIALIZED ;
                        goto cleanup ;
                }

                assert (m_pPackage) ;

                hr = AddLotsOFiles(             bstrSourceDirname,
                                                                bstrMIMEContentLocation, 
                                                                dateExpires,
                                                                lMIMEContentLanguageId,
                                                                fCompress,
                                                                0                       // depth                                
                                                                ) ;

        cleanup :
                Unlock () ;

        if(FAILED(hr))
                        Error(GetTVEError(hr), IID_IATVEFPackage);

        } EXIT_API_(hr);
}


                                // PathDB::AddLotsOFiles
                                // recursive routine to traverses directory structure
                                //    starts from either ApplySearchRoot if its Non-NULL, else current directory.
                                //    works by enumerating current directory, and after resetting current dir for
                                //        each sub-dir, applying itself recursively. 
void MyRemoveTrailingSlash(TCHAR *szPath)
{
        int ilen = _tcslen(szPath);
        if(ilen > 0 && (szPath[ilen-1] == '\\' || szPath[ilen-1] == '/'))
                szPath[ilen-1] = 0;
}

// -----------------------------------------------------------------------------------
// AddLotsOFiles
//
//      Recursive helper function to all the files in the current directory and then in any
//  subdirectories below it using multiple calls to AddFile.
//
//      Note possible bug - it sets the Mime data type to "" because it doesn't know what else
//  to set it to.

HRESULT 
CATVEFPackage::AddLotsOFiles(BSTR bstrDirFilename,                              // Dir name
                                                        BSTR bstrMIMEContentLocation,           // destination ("lid:/test")
                                                        DATE dateExpires, 
                                                        LONG lMIMEContentLanguageId,
                                                        BOOL fCompress,
                                                        long depth)     
{    
        HRESULT hr = S_OK;
        struct _tfinddata_t tc_file;            
        long hFile;
        bool fDidINodePush = false;
        int iMaxDepth = 999;

        USES_CONVERSION;

        TCHAR *szApplySearchRoot = W2T(bstrDirFilename);
        TCHAR szSearchRoot[_MAX_PATH];
        const int kszSearchRoot = _MAX_PATH;
        if(szApplySearchRoot)
        {
                bool fOK = (0 == _tchdir(szApplySearchRoot));
                if(!fOK)
                {       
                        TRACEW_1(PACKAGE,L"Unable to CD to '%s'!", szApplySearchRoot);
                        return E_ACCESSDENIED;
                } 
                _tcsncpy(szSearchRoot, szApplySearchRoot, kszSearchRoot);
        }
        else                                                                                            // search from current directroy
        {
                bool fOK = (0 != _tgetcwd(szSearchRoot, kszSearchRoot));        
                if(!fOK) {              
                        TRACEW_3(PACKAGE,L"Can't get current directory '%s', error %d (0x%8x)\n",
                                szSearchRoot, errno, errno);
                        return E_ACCESSDENIED;
                } 
        } 

        if(depth == 0 && szSearchRoot[0] == NULL)
        {
                _ASSERT(false);
                return E_INVALIDARG;
        }

                                // if first time through, may need to clean up dir name..
        if(depth == 0 && szSearchRoot[0] != NULL)               // root dir case special...
        {       
                MyRemoveTrailingSlash(szSearchRoot);            // cleanup D:/ type root paths into just D: 
                int sLen = _tcslen(szSearchRoot);

                struct _stat statBuf;                                           
                int result = _tstat( szSearchRoot, &statBuf ); 
                if(result != 0 && errno == 2)                           // ucky stuff - need c:\, but c:\adir here
                {
                        szSearchRoot[sLen] = '\\'; sLen++;  szSearchRoot[sLen] = NULL;
                }

        }
        
        if(szApplySearchRoot != NULL)
        {
                struct _stat statBuf;
                memset(&statBuf,0,sizeof(statBuf));
                int result = _tstat( szSearchRoot, &statBuf ); 
                if(result != 0 && errno != 2) 
                {
                        TRACEW_OBJ_3(PACKAGE,L"Problem with stat of the root directory '%s' (errno %d 0x%x)",
                                szSearchRoot, errno, errno);
                        return E_INVALIDARG;

                } 

                tc_file.name[0] = 0;
                if(depth == 0)
                {
                        int maxChars2Copy = (int)(sizeof(tc_file.name)/sizeof(tc_file.name[0]) - _tcslen(tc_file.name) - 1);
                        _tcsncat(tc_file.name, szSearchRoot, maxChars2Copy);
                }
                else
                {
                        for(int i = _tcslen(szSearchRoot); i > 0; --i) 
                        {
                                if(szSearchRoot[i] == '\\' || szSearchRoot[i] == '/') 
                                {
                                        i++;
                                        break;
                                }
                        }
                        int maxChars2Copy = (int)(sizeof(tc_file.name)/sizeof(tc_file.name[0]) - _tcslen(tc_file.name) - 1);
                        _tcsncat(tc_file.name, &szSearchRoot[i], maxChars2Copy);
                }

                MyRemoveTrailingSlash(tc_file.name);            // hackery??? -- needed for above extra ad
                TRACEW_OBJ_2(PACKAGE,L"Working On Directory '%S' '%S' ",tc_file.name,szSearchRoot);

                fDidINodePush = true;
        }


                                        // work on all the normal files...
                                        // if using regular expression, get all files here, else let it use existing code
        if( (hFile = (long) _tfindfirst(_T("*.*") , &tc_file )) == -1L )
        {
        //      _tprintf( "XXX No %s files in '%s'!\n",szSearchString, szCWD );   
        }
        else   
        {
                TRACEW_OBJ_1(PACKAGE,L"Adding Dir '%S' ",szSearchRoot);
  
                do
                {
                        if(!(tc_file.attrib & _A_SUBDIR)) {
                                TRACEW_OBJ_3(PACKAGE,L"   File '%s '\' %s' -> '%s'",
                                        T2W(szSearchRoot), 
                                        T2W(tc_file.name), bstrMIMEContentLocation);    

                                CComBSTR bstrMimeType("");              // what else do we set it too?

                                hr =  m_pPackage->AddFile(T2W(tc_file.name),
                                                                                  T2W(szSearchRoot),
                                                                                  bstrMIMEContentLocation, 
                                                                                  bstrMimeType,
                                                                                  dateExpires,
                                                                                  lMIMEContentLanguageId,
                                                                                  fCompress
                                                                                  ) ;
        
                        }

                } while( _tfindnext( hFile, &tc_file ) == 0 );             
                _findclose( hFile );  
        }

                                        // work on all the sub directories.
        if(depth < iMaxDepth - 1)
        {
                if( (hFile = (long) _tfindfirst( _T("*.*"), &tc_file )) == -1L )
                {
                        TRACEW_OBJ_1(PACKAGE,L"No Files in '%S' ",szSearchRoot);

                }
                else   
                {
                           /* Find the rest of the .c files */
                        do              // hack here - assume first file returned in "*.*" is not a valid subdir
                        {          
                                if(tc_file.attrib & _A_SUBDIR )
                                {
                                                                // ignore '.' and '..' directories return from aboe enum..
                                        bool fStdDir = ((_tcslen(tc_file.name) == 1) && (tc_file.name[0] == '.')) ||
                                                                   ((_tcslen(tc_file.name) == 2) && (tc_file.name[0] == '.') && (tc_file.name[1] == '.'));

                                        if(!fStdDir)                                                            // if it's a valid subdirectory, enter it
                                        {
//                                              (*pFunc)(&c_file, this);                                        // apply func to the directory node
                                                bool fOK = (0 == _tchdir(tc_file.name));                // move down into the subdirectory      
                                                
                                                CComBSTR bstrMIMEContentLocationNew(bstrMIMEContentLocation);
                                                bstrMIMEContentLocationNew.Append("\\");
                                                bstrMIMEContentLocationNew.Append(T2W(tc_file.name));

                                                if(fOK) 
                                                        AddLotsOFiles(NULL,                                     // Dir name (NULL, so CD to it)
                                                         bstrMIMEContentLocationNew,            // destination ("lid:/test")
                                                         dateExpires, 
                                                         lMIMEContentLanguageId,
                                                         fCompress,
                                                         depth+1);      

                                                if(fOK) _tchdir(_T(".."));                                      // pop back up
                                        }
                                }
                        }  while( _tfindnext( hFile, &tc_file ) == 0 );
                } 
                _findclose( hFile );  
        }

        return S_OK;
}
// --------------------------------------------------------------
// --------------------------------------------------------------
STDMETHODIMP CATVEFPackage::Close()
{
        HRESULT hr = S_OK;

        ENTER_API {
                ENTERW_OBJ_0 (L"CATVEFPackage::PackageClose") ;

                Lock () ;

                if (m_pPackage) {
                        hr = m_pPackage -> Close () ;
                }
                else {
        //              Error(IDS_INVALIDOBJECT_INITIALIZED, IID_IATVEFPackage);
                        hr = ATVEFSEND_E_OBJECT_INITIALIZED ;
                }

                Unlock () ;

                if(FAILED(hr))
                        Error(GetTVEError(hr), IID_IATVEFPackage);

        } EXIT_API_(hr);
}



// ---------------------------------------------------------------------------
//  GetTransmitTime
//                      Returns the approximate time required to transmit the package
//              at a given rate.  If bitrate is given in bits/second, returns times in hour.
//              May be used to compute size of package in bytes by passing in 8, size 
//              in Killobytes by passing in 8092, size in UHTTP datagrams by passing in (1472*8), etc.
//
//              Note this size may seem very strange since the data is UHTTP encoded (with forward
//              error correction) in blocks of DEF_DATAGRAM_SIZE (1472 bytes).  
//              Minimum size is at least two blocks... (e.g. put lots of little objects in
//              the same package).
//              
//              Will return ATVEFSEND_E_OBJECT_INITIALIZED if not even created.
//              Will return ATVEFSEND_E_PACKAGE_NOT_CLOSED if package is not closed prior to this call. 
//              Will return E_INVALIDARG if passed zero for argument. 
// ---------------------------------------------------------------------------
STDMETHODIMP CATVEFPackage::TransmitTime(float rExpectedTransmissionBitRate, float *prTransmissionTimeSeconds)
{
        HRESULT hr = S_OK ;
    DWORD   TransmitBytes ;

        ENTER_API {
                ValidateOutPtr(prTransmissionTimeSeconds,(FLOAT) 0.0);

                Lock () ;

                if (prTransmissionTimeSeconds == NULL)
                        hr = E_POINTER ;

                if (SUCCEEDED(hr) && rExpectedTransmissionBitRate == 0.0f) 
                        hr = E_INVALIDARG ;

                if (SUCCEEDED(hr) && m_pPackage == NULL) 
                        hr = ATVEFSEND_E_OBJECT_INITIALIZED;

                if(SUCCEEDED(hr))
                        hr = m_pPackage->GetTransmitSize(&TransmitBytes);

                if (SUCCEEDED (hr)) 
                        *prTransmissionTimeSeconds = (TransmitBytes * 8.0f) / rExpectedTransmissionBitRate;

                Unlock () ;
                if(FAILED(hr))
                        Error(GetTVEError(hr), IID_IATVEFPackage);

        } LEAVE_API;            // leave, not exit.  Need to call the unlock() below


        return hr;
}

// ---------------------------------------------------------------------------
//  DumpToBSTR
// ---------------------------------------------------------------------------
STDMETHODIMP 
CATVEFPackage::DumpToBSTR(BSTR *pBstrBuff)
{
        HRESULT hr = S_OK;
        ValidateOutPtr( pBstrBuff,(BSTR) NULL); 
        Lock() ;
        ENTER_API {
                assert (m_pPackage) ;                           // humm.. Lock()/Unlock() outside of api block safer if
                hr = m_pPackage->DumpToBSTR(pBstrBuff); //   the dump throws, but now assume they never throw...        

                if(FAILED(hr))
                        Error(GetTVEError(hr), IID_IATVEFPackage);

        } LEAVE_API;
        Unlock() ;
        return S_OK;
}

HRESULT 
CPackage::DumpToBSTR(BSTR *pBstrBuff)
{
        const int kMaxChars = 1024;
        const int kMaxTotalChars = 1024*63;             // VB max string is approximately 65,400 bytes.
        CHAR szBuff[kMaxChars];
        CComBSTR spbsOut;

        if(NULL == pBstrBuff) 
                return E_POINTER;

        spbsOut.Empty();
                                        // package must be closed but not sent...

        if(m_State != STATE_CLOSED) 
                return E_FAIL;

        HANDLE      hFileIn ;
        DWORD       dwFileSize ;
        DWORD       dwFileSizeHigh ;
        DWORD       dwBytesRead ;
        USES_CONVERSION;

        hFileIn = INVALID_HANDLE_VALUE ;
        hFileIn = CreateFileA (m_GzipMIMEEncodedFile,
                                                        GENERIC_READ,
                                                        FILE_SHARE_READ,
                                                        NULL,
                                                        OPEN_EXISTING,
                                                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                                        NULL) ;
        if (hFileIn == INVALID_HANDLE_VALUE) {
                 return GetLastError () ;
        }

        dwFileSize = GetFileSize (hFileIn, & dwFileSizeHigh) ;
                //
                //  the UHTTP field for data size is a DWORD, so if the file is larger
                //  than can be specified in a DWORD, we fail
                //

        if (dwFileSizeHigh) {
                CloseHandle(hFileIn);
                return E_FAIL ;
        }

        dwBytesRead = 1;
        DWORD dwTotalBytesRead = 0;
        WCHAR wszBuff[kMaxChars+1];

        while(dwBytesRead != 0)
        {
                 BOOL fOK = ReadFile (hFileIn, szBuff, kMaxChars, &dwBytesRead, NULL) ;
                 if(dwBytesRead > 0) {
                         //WCHAR *wzT = A2W(szBuff);                            // doesn't work on binary sequences, do it by hand...
                         for(DWORD i = 0; i < dwBytesRead; i++)
                                 wszBuff[i] = (unsigned char) szBuff[i];
                         wszBuff[dwBytesRead] = 0;                                      // NULL terminate for paranoia
                         spbsOut.Append(wszBuff, dwBytesRead);
                         dwTotalBytesRead += dwBytesRead;
                 }
                 if(dwTotalBytesRead > kMaxTotalChars) {
                         spbsOut.Append(L"\n**** PACKAGE TOO LARGE - TRUNCATED THE DUMP ***\n");
                         dwBytesRead = 0; // cause it to break
                 }
        }

        CloseHandle(hFileIn);                                           // need this, else leak temp files
        spbsOut.CopyTo(pBstrBuff);
        return S_OK;
}



#if 1 // Added by a-clardi
STDMETHODIMP CATVEFPackage::get_NPackets(LONG *pcPackets)
{
        HRESULT hr = S_OK;

        ENTER_API 
		{

                Lock () ;

				if (m_cPacketsTotal == 0)
				{
					hr = m_pPackage->FragmentPackage_();      // make sure it gets fragmented
                    if(FAILED(hr))
                        return hr;

					CUHTTPFragment *pUHTTP = m_pPackage->m_pUHTTPFragment;
                    if(NULL == pUHTTP)
                        return E_FAIL;

					m_cPacketsTotal = pUHTTP->m_dwTotalDatagramCount;

					if (m_rgbCorruptMode)
						delete m_rgbCorruptMode;

					m_rgbCorruptMode = new BYTE[m_cPacketsTotal];
					memset(m_rgbCorruptMode, 0, m_cPacketsTotal*sizeof(BYTE));
				}
				*pcPackets = m_cPacketsTotal;

                Unlock () ;

                if(FAILED(hr))
                        Error(GetTVEError(hr), IID_IATVEFPackage);

        } EXIT_API_(hr);
}
#endif

#if 1


STDMETHODIMP CATVEFPackage::CorruptPacket(LONG nPacketID, INT bMode) 
		// if mode = 1, prevennt packet from being sent, if 2 then randomize a byte
{
        HRESULT hr = S_OK;

        ENTER_API 
		{

                Lock () ;

				if (nPacketID < m_cPacketsTotal)
				{
					if (m_rgbCorruptMode)
					{
						*(m_rgbCorruptMode+nPacketID) = (BYTE)bMode;
						return S_OK;    
					}
					else
						return E_POINTER;
				}
				else
				{
					return E_INVALIDARG;
				}

                Unlock () ;

                if(FAILED(hr))
                        Error(GetTVEError(hr), IID_IATVEFPackage);

        } EXIT_API_(hr);
}

#endif

#if 1
STDMETHODIMP CATVEFPackage::GetCorruptMode(LONG nPacket, INT *bMode)
{
    HRESULT hr = S_OK;

        ENTER_API {

                Lock () ;

				if (m_rgbCorruptMode)
				{
					*bMode = (INT) m_rgbCorruptMode[nPacket];
				}
				else
					*bMode = 0;

                Unlock () ;
                if(FAILED(hr))
                        Error(GetTVEError(hr), IID_IATVEFPackage);

        } LEAVE_API;            // leave, not exit.  Need to call the unlock() below


        return hr;
}

#endif


#ifdef SUPPORT_UHTTP_EXT  // a-clardi
STDMETHODIMP CATVEFPackage::AddExtensionHeader(
			IN BOOL		ExtHeaderFollows, 
			IN USHORT	ExtHeaderType,
			IN USHORT	ExtDataLength,
			IN BSTR		ExtHeaderData)
{
    HRESULT hr = S_OK;

        ENTER_API {

                Lock () ;

				if (m_pPackage)
				{
					hr = m_pPackage->AddExtensionHeader(
							ExtHeaderFollows, 
							ExtHeaderType,
							ExtDataLength,
							ExtHeaderData);
				}
				else 
					hr = E_POINTER;

                Unlock () ;
                if(FAILED(hr))
                        Error(GetTVEError(hr), IID_IATVEFPackage);

        } LEAVE_API;            // leave, not exit.  Need to call the unlock() below


        return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tverouter.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVERouter.cpp : Implementation of CATVEFRouterSession
#include "stdafx.h"

#pragma warning( disable: 4786 ) 

#include "ATVEFSend.h"
#include "TVERouter.h"

#include "DbgStuff.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CATVEFRouterSession

STDMETHODIMP CATVEFRouterSession::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATVEFRouterSession
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

// ----------------------------------------------------------------
HRESULT CATVEFRouterSession::FinalConstruct()
{		
	HRESULT hr = S_OK;

	CComObject<CATVEFAnnouncement> *pAnnc;
	hr = CComObject<CATVEFAnnouncement>::CreateInstance(&pAnnc);
	if(FAILED(hr))
		return hr;

	m_pcotveAnnc = pAnnc;
	m_pcotveAnnc->AddRef();			// strange we need this, doesn't createInstance do this?

				// would like to set the parent of m_pcotveAnnc back to *this here,
				//   but can't since ref-count of this is currently zero (inc'ed to 1)
				//   right after this call.  The QI to IUnknown does an AddRef, and
				//	 the release brings the ref count back to zero, causing *this to
				//	 be deleted...  Do it in the Initialize() call below.
	return hr;
}

HRESULT CATVEFRouterSession::FinalRelease()
{
	m_pcotveAnnc->SetParent(NULL);
	m_pcotveAnnc->Release();
	m_pcotveAnnc = NULL;
	return S_OK;
}
// ----------------------------------------------------------------
STDMETHODIMP CATVEFRouterSession::Initialize(BSTR bstrRouterHostname)
{

/*++

    Routine Description:

        The purpose of this routine is to initialize a tunnel session object.
        It instantiates and initializes 3 transmitters, which it then passes
        to the parent (CEnhancementSession), which performs its own 
        initialization.

        The call to the parent for initialization is performed last, so a 
        failure is easy to cleanup (just delete the transmitters and return
        an error code).

        This routine is called as a result of a COM interface call to
        ::Initialize.

        The class lock must be held during this call.

    Parameters:

        szRouterHostname    specifies the Broadcast Router Service host, or can
                            be NULL, in which case the service is assumed to be
                            running on the local host

    Return Values:

        S_OK            success

        error code      failure

--*/

    ENTERW_OBJ_0 (L"CATVEFRouterSession::Initialize ()") ;

 
	HRESULT hr ;
	CRouterTunnel * pAnnouncementTransmitter ;
	CRouterTunnel * pPackageTransmitter ;
	CRouterTunnel * pTriggerTransmitter ;
	bool fLocked = false;

	assert (LOCK_HELD (m_crt)) ;

/*	//  already initialized ??
	if (m_State >= STATE_INITIALIZED) {
		return ATVEFSEND_E_OBJECT_INITIALIZED ;
	}
*/
	//  start initialization

	//  initialize our transmitter object pointers
	pAnnouncementTransmitter = NULL ;
	pPackageTransmitter = NULL ;
	pTriggerTransmitter = NULL ;

	//  instantiate and initialize our transmission objects
	pAnnouncementTransmitter = new CRouterTunnel () ;
	GOTO_EQ_SET (pAnnouncementTransmitter, NULL, cleanup, hr, E_OUTOFMEMORY) ;

	pPackageTransmitter = new CRouterTunnel () ;
	GOTO_EQ_SET (pPackageTransmitter, NULL, cleanup, hr, E_OUTOFMEMORY) ;

	pTriggerTransmitter = new CRouterTunnel () ;
	GOTO_EQ_SET (pTriggerTransmitter, NULL, cleanup, hr, E_OUTOFMEMORY) ;

	hr = (pAnnouncementTransmitter -> Initialize (bstrRouterHostname)) ;
	GOTO_NE (hr, S_OK, cleanup) ;

	hr = (pPackageTransmitter -> Initialize (bstrRouterHostname)) ;
	GOTO_NE (hr, S_OK, cleanup) ;

	hr = (pTriggerTransmitter -> Initialize (bstrRouterHostname)) ;
	GOTO_NE (hr, S_OK, cleanup) ;

	//  now initialize our parent
	m_pcotveAnnc->Lock_ () ;
	fLocked = true;

	hr = m_pcotveAnnc->InitializeLocked_ (
			pAnnouncementTransmitter, 
			pPackageTransmitter, 
			pTriggerTransmitter
			) ;
	if(FAILED(hr)) 
		goto cleanup;
										// setup the parent pointer in the announcement
	IUnknown *punkThis;
	hr = this->QueryInterface(IID_IUnknown, (void**) &punkThis);		
	if(FAILED(hr)) 
		goto cleanup;

	m_pcotveAnnc->SetParent(punkThis);		// point it's parent back up to this
	punkThis->Release();					// parent pointer not ref'ed, so release it (shouldn't go away!)

cleanup:

	//  if we succeeded, set our state to initialized; otherwise, free up
	//  all resources which might have been allocated in the course of this
	//  method

	if(fLocked)
		m_pcotveAnnc->Unlock_() ;

	if (FAILED(hr))
	{			
		delete pAnnouncementTransmitter ;
		delete pPackageTransmitter ;
		delete pTriggerTransmitter ;

		Error(GetTVEError(hr), IID_IATVEFRouterSession);
	}

	return hr;
}

STDMETHODIMP CATVEFRouterSession::SetCurrentMedia( LONG lMedia)
{
	return  m_pcotveAnnc->SetCurrentMedia(lMedia);
}

STDMETHODIMP 
CATVEFRouterSession::DumpToBSTR(BSTR *pBstrBuff)
{
	CComBSTR bstrBuff;
	bstrBuff = L"CATVEFRouterSession\n";
	m_pcotveAnnc->Lock_ () ;

	bstrBuff.CopyTo(pBstrBuff);

    m_pcotveAnnc->Unlock_ () ;

	return S_OK;

}
// -----------------------------------------------------------

STDMETHODIMP CATVEFRouterSession::get_Announcement(IDispatch **pVal)
{
	HRESULT hr = m_pcotveAnnc->QueryInterface(pVal);
	return hr;
}

STDMETHODIMP CATVEFRouterSession::Connect()
{
    HRESULT hr = S_OK;
	ENTERW_OBJ_0 (L"CATVEFRouterSession::Connect") ;

    m_pcotveAnnc->Lock_ () ;

    hr = m_pcotveAnnc->ConnectLocked_ () ;

    m_pcotveAnnc->Unlock_ () ;

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFRouterSession);

	return hr;
}

STDMETHODIMP CATVEFRouterSession::Disconnect()
{
	// TODO: Add your implementation code here
    HRESULT hr ;

    ENTERW_OBJ_0 (L"CATVEFRouterSession::Disconnect") ;

    m_pcotveAnnc->Lock_ () ;
    hr = m_pcotveAnnc->DisconnectLocked_() ;
    m_pcotveAnnc->Unlock_ () ;


	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFRouterSession);

    return hr ;
} 

STDMETHODIMP CATVEFRouterSession::SendAnnouncement()
{
/*++

    Routine Description:

        The purpose of this routine is transmit an announcement.  The object
        must be connected for this call to succeed.

    Parameters:

        none

    Return Value:

        S_OK            success
        failure code    failure

--*/
    HRESULT hr ;

    ENTERW_OBJ_0 (L"CATVEFRouterSession::SendAnnouncement") ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendAnnouncementLocked_() ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFRouterSession::SendAnnouncement - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFRouterSession);

    return hr ;

}

STDMETHODIMP CATVEFRouterSession::SendPackage(IATVEFPackage *pPackage)
{
/*++

    Routine Description:
    Parameters:
    Return Value:

--*/
	HRESULT hr ;

    ENTERW_OBJ_0 (L"CATVEFRouterSession::SendPackage") ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendPackageLocked_(pPackage) ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFRouterSession::SendPackage - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFRouterSession);

    return hr ;

}

STDMETHODIMP CATVEFRouterSession::SendTrigger(BSTR bstrURL, BSTR bstrName, BSTR bstrScript, DATE dateExpires)
{
/*++

    Routine Description:

        Triggers, per the ATVEF specification must be as follows:

        <url>[name:name_str][expires:expire_tm][script:script_str][checksum]

        We do not append a checksum.

        The total length of the trigger cannot exceed 1472 bytes, including the
        null-terminator.  Transmitted as an ASCII string.

        Object must be connected for this call to succeed.

    Parameters:

        szURL			cannot be NULL;

        bstrName		can be NULL or 0 length

        bstrScript		can be NULL or 0 length

        Expires			can be 0'd out and will then be ignored 

    Return Values:

        S_OK            success
        error code      failure

--*/



    HRESULT hr ;

 	ENTERW_OBJ_3 (L"CATVEFRouterSession::SendTrigger (\n\t\"%s\", \n\t\"%s\", \n\t\"%s\")", 
		bstrURL, bstrName, bstrScript) ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendTriggerLocked_( bstrURL,  bstrName,  bstrScript,  dateExpires, /*level*/ 0.0, /*appendCRC*/ true) ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFRouterSession::SendTrigger - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFRouterSession);

    return hr ;
}

STDMETHODIMP CATVEFRouterSession::SendRawTrigger(BSTR bstrTrigger)
{
    HRESULT hr ;

 	ENTERW_OBJ_1 (L"CATVEFRouterSession::SendRawTrigger (\n\t\"%s\")", bstrTrigger) ;

	m_pcotveAnnc->Lock_ () ;
 	try 
	{
		hr = m_pcotveAnnc->SendRawTriggerLocked_( bstrTrigger, /*append CRC*/ false) ;
	} catch (...) {
		ENTERW_OBJ_0 (L"CATVEFRouterSession::SendRawTrigger - error!") ;
		hr = E_FAIL;
	}
    m_pcotveAnnc->Unlock_ () ;
 

	if(FAILED(hr))
		Error(GetTVEError(hr), IID_IATVEFRouterSession);

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvesupport.h ===
// -----------------------------------------------------------------
//  TVETrigger.cpp
//
//				generates a trigger...
//
//	if fShortForm is true, uses shorter keywords such as 'n:' vs. 'name:'
// -------------------------------------------------------------------

#ifndef __TVETRIGGER_H__
#define __TVETRIGGER_H__

// Encodes values out of the range 0x20 to 0x7e to standard Internet URL mechanism of the 
	//   percent character ("%") followed by the two-digit hexadecimal value of the character
	//   in standard ASCII (?? how different is this than ISO-8859-1 ??)
	//   Returns a static char...

char * W2EncodedA(BSTR bstrIn);	

HRESULT
GenTrigger(CHAR *pachBuffer, int cMaxLen,
		   BSTR bstrURL, BSTR bstrName, BSTR bstrScript, DATE dateExpires, 
		   BOOL fShortForm, float rTVELevel, BOOL fAppendCRC);


#endif __TVETRIGGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvesslist.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVESSList.cpp : Implementation of CATVEFStartStopList
#include "stdafx.h"
#include "ATVEFSend.h"
#include "TVESSList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CATVEFStartStopList

STDMETHODIMP CATVEFStartStopList::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATVEFStartStopList
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvesupport.cpp ===
// -----------------------------------------------------------------
//  TVESupport.cpp
//
//				generates a trigger...
// -------------------------------------------------------------------
#include "stdafx.h"
#include "stdlib.h"
#include "ATVEFSend.h"
#include "TVEAnnc.h"
#include "ATVEFMsg.h"		// error codes (generated from the .mc file)

#include "TVESupport.h"		// this

#include "..\common\address.h"		// trigger CRC code
#include "..\common\isotime.h"
#include "valid.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// -----------------------------------------------------------------------------------
//  W2EncodedA
//
//   Converts a BSTR (Unicode string) into a single char string suitable for HTML scripts 
//	 and triggers.
//
//	 Encodes values out of the range 0x20 to 0x7e to standard Internet URL mechanism of the 
//   percent character ("%") followed by the two-digit hexadecimal value of the character
//   in standard ASCII (?? how different is this than ISO-8859-1 ??)
//
//  Note possible Spec problems:
//		The characters '[', ']', and '%' are also escaped in the output string,
//		even though they are within the range of 0x20 to 0x7e to make parsing on the
//		receiver side far easier..
//
//		The name string is encoded - this lets it contain values outside the range 0x20
//		to 0x7e, and also lets it contain square brackets contrary to the spec.

char * W2EncodedA(BSTR bstrIn)		
{
	static char szOutBuff[ETHERNET_MTU_UDP_PAYLOAD_SIZE];
	char *pOut = szOutBuff;
	WCHAR *pIn = &bstrIn[0];
	char szDtoH[17] = "0123456789abcdef";
	while(0 != *pIn)
	{
		if(*pIn < 0x20 || *pIn > 0x7e || *pIn == ']' || *pIn == '[' || *pIn == '%')
		{
			*pOut++ = '%';
			*pOut++ = szDtoH[((*pIn & 0xF0) >> 4)];
			*pOut++ = szDtoH[((*pIn & 0x0F))];
		} else {
			*pOut++ = *pIn;
		}
		pIn++;
	}
	*pOut = 0;
	return szOutBuff;
}

// ------------------------------------------------------------------------------
// GenTrigger:
//	Constructs a trigger based on the given parts.
//	Encodes some characters in URL, Name, and script '%NN' characters 
//	If fShortForm is true, uses shorter keywords like 'n:' instead of 'name:'
//  If fAppendCRC is true, appends the CRC to the string.
//
//
//	returns:
//		ATVEFSEND_E_TRIGGER_TOO_LONG	if trigger length > 1472 bytes
//
//	notes:
//		very low-pri bug..  Doesn't utilize fShortForm when computing max length...
// --------------------------------------------------------------------------------

HRESULT
GenTrigger(CHAR *pachBuffer, int cMaxLen, 
		   BSTR bstrURL, BSTR bstrName, BSTR bstrScript, DATE dateExpires, 
		   BOOL fShortForm, float rTVELevel, BOOL fAppendCRC)
{
    CHAR *      pcLast, *pcT ;
    SYSTEMTIME  SystemTime ;
    CHAR        achExpires [64] ;

    pcLast = pachBuffer;

    //  make sure URL length is ok
    if (wcslen (bstrURL) + strlen ("<>") > cMaxLen - 1) {
        return ATVEFSEND_E_TRIGGER_TOO_LONG ;
    }

    //  opening caret for URL
    * pcLast ++ = '<' ;

    //  copy it in

	pcT = W2EncodedA(bstrURL);
    strcpy(pcLast, pcT) ;
	pcLast += strlen(pcT);


    //  closing bracket
    * pcLast ++ = '>' ;


    //  if there's a name we put it in here
    if (bstrName && wcslen (bstrName) > 0) {

        if (wcslen (bstrName) + strlen ("[name:]") > (DWORD) ((pachBuffer+cMaxLen-1) - pcLast)) {
            return ATVEFSEND_E_TRIGGER_TOO_LONG ;
        }

		if(fShortForm) {
			strcpy (pcLast, "[n:") ;
			pcLast += strlen ("[n:") ;
		} else {
			strcpy (pcLast, "[name:") ;
			pcLast += strlen ("[name:") ;
		}

 		pcT = W2EncodedA(bstrName);
		strcpy(pcLast, pcT) ;
		pcLast += strlen (pcT) ;

        *pcLast ++ = ']' ;
    }

    //  if there's a Level number put it in here as either [t:1] or 
    if (rTVELevel > 0.0f) 
	{
		char szNumBuffer[32];
		float rFrac = rTVELevel - int(rTVELevel);
		if(rFrac > 0.09) {
			sprintf(szNumBuffer,"%4.1f", rTVELevel);
		} else {
			sprintf(szNumBuffer, "%d", int(rTVELevel));
		}
        if (wcslen (bstrName) + strlen ("[tve:]") + strlen(szNumBuffer) > (DWORD) ((pachBuffer+cMaxLen-1) - pcLast)) {
            return ATVEFSEND_E_TRIGGER_TOO_LONG ;
        }

		if(fShortForm) {
			strcpy (pcLast, "[v:") ;
			pcLast += strlen ("[v:") ;
		} else {
			strcpy (pcLast, "[tve:") ;
			pcLast += strlen ("[tve:") ;
		}

		strcpy(pcLast, szNumBuffer);
		pcLast += strlen (szNumBuffer) ;

        *pcLast++ = ']' ;
    }

    //  same with the script
    if (bstrScript &&
        wcslen (bstrScript) > 0) {

        if (wcslen (bstrScript) + strlen ("[script:]") > (DWORD) ((pachBuffer+cMaxLen-1) - pcLast)) 
		{
            return ATVEFSEND_E_TRIGGER_TOO_LONG ;
        }

		if(fShortForm) {
			strcpy (pcLast, "[s:") ;
			pcLast += strlen ("[s:") ;
		} else {
			strcpy (pcLast, "[script:") ;
			pcLast += strlen ("[script:") ;
		}

        pcT = W2EncodedA(bstrScript);
		strcpy(pcLast, pcT) ;
		pcLast += strlen (pcT) ;

        *pcLast++ = ']' ;
    }

    //  expires tag
    if (dateExpires != 0.0) {
        //  convert to system time
        if (VariantTimeToSystemTime (dateExpires, & SystemTime) == FALSE) {
            return HRESULT_FROM_WIN32 (GetLastError ()) ;
        }

        //  make sure we have room
        if (strlen ("[expires:yyyymmddThhmmss]") > (WORD) ((pachBuffer+cMaxLen-1) - pcLast)) {
            return ATVEFSEND_E_TRIGGER_TOO_LONG ;
        }

        sprintf (
            achExpires, 
            fShortForm ? "[e:%04u%02u%02uT%02u%02u%02u]" : "[expires:%04u%02u%02uT%02u%02u%02u]", 
            SystemTime.wYear, 
            SystemTime.wMonth, 
            SystemTime.wDay, 
            SystemTime.wHour, 
            SystemTime.wMinute, 
            SystemTime.wSecond
            ) ;
        
        strcpy(pcLast, achExpires) ;
        pcLast += strlen (achExpires) ;
    }
	
	if(fAppendCRC)
	{
		*pcLast = '\0' ;		// cap of string, so ChkSumA doesn't go out of bounds
		CComBSTR spbsCRC = ChkSumA(pachBuffer);
		*(pcLast++) = '[';
		for(int i = 0; i < 4; i++)
			*(pcLast++) = spbsCRC[i]; 
		*(pcLast++) = ']';
	}

    //  cap it off
    * pcLast = '\0' ;

    assert (pcLast <= (pachBuffer+cMaxLen-1)) ;

 	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\tvesslist.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVESSList.h : Declaration of the CATVEFStartStopList
//
//		A DATE (key) to DATE (value) list modeled on a key/value attribute list.
//			This class contains a list of start/stop (key/value) pairs, where both start and stop are DATES.
//			The start times don't need to be unique. However, searching on the key will only
//			return the first value entered.
//	
//			Implemented as a list of DATE/DATE pairs.
//
//			This supports a threadsafe standard enumerator, which returns values in the map
//			in inserted order.  
//
//
//	Problem -  The NEXT method on the enumerator only returns the values of the (key/value) pair.  
//		This sort of makes the enumerator worthless.  Use the Key() and Item() methods yourself
//		with a numeric index to get both.
//
//	Was templated - supports types of:
//		TVal	- DATE
//		TKey	- DATE
//
//	This supports the interface members of:
//
//		get_Count(long *plCount)
//				Returns number of elements in this collection.
//		get__NewEnum(IUnknown **ppunk)
//				Returns a standard, threadsafe enumerator to this collecion.  (It copies the whole
//				map).
//		get_Item(VARIANT var, TVal *pT )
//				Supported input variant types are strings and numeric values.  If of string type, then
//				it returns the value associated with BSTR key.  If numeric, returns the n'th
//				item's value (in inserted order).   Access is not
//				fast, particularly for all elements in the collection.   
//				This method returns S_OK if success, and S_FALSE if the 
//				item with the specifed key (or index) isn't in the collection.
//		get_Key(VARIANT var, TKey *pT)
//				This does reverse lookup, returning the key associated with a given value.
//				Supported var variant types are strings and numeric values.  If of string type, then
//				it returns the *first* key whose value matches that passed in (it may not be a 1-1 mapping
//			    of values back to keys).  If numeric, returns the n'th keys's value (in 
//				inserted order).   This returns S_OK if success, 
//				and S_FALSE if the item with the specifed value (or index) isn't in the collection.
//				--> This method is intended for debugging only - it is not fast.  
//		Add(TKey rKey, TVal rVal)		
//				Appends a new <key,value> (start/stop) pair to the list.  
//
//		Remove(VARIANT varIn)
//				Removes both element in the list with the given key (start time) if varIn is a string form,
//				otherwise the n'th element (alphabetical order) if it's numeric.  It returns S_FALSE
//				if the item isn't there to remove.	Strange effects with Add1 key number here.
//		RemoveAll()
//				Removes all elements in the collection (just what did you expect?)
//
//	local methods
//
//		get_Item(BSTR bstr, TVal *pT )		
//				This returns the value associated with a given key.  This
//				is algorithmically fastest method to retreive values from this collection.
//				This returns S_FALSE if the item with the specified key isn't in the collection.
//
//		Item(VARIANT var, TVal *pT)
//		Key(VARIANT var, TKey *pK)
//			return the given value/first-key given the associated key/value or 
//			an index into the list
//
//		ItemIter(VARIANT varIn, ListT::iterator &iIter)
//		ItemKey(VARIANT varIn, ListT::iterator &iIter)
//			return iterator to the given value/first-key given the associated key/value 
//			or index into the list.
//		DumpToBSTR(BSTR *pBstr)
//			Returns a string containing all the elements in the list, suitable for debugging
//			of the form {key1:val1 | key2:val2 | ... keyN:valN}
//			This string must be free'ed by the caller.

#ifndef __ATVEFSTARTSTOPLIST_H_
#define __ATVEFSTARTSTOPLIST_H_

#include "resource.h"       // main symbols
#include "comdef.h"
#include "valid.h"			// ENTER_API, EXIT_API classes

#include <list>				// std List class

// --------------------------------------------------------------------
//  IEnumVARIANT implementation
// ---------------------------------------------------------------------
class CSafeEnumATVEFStartStopList :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_ATVEFSENDLib>
{

	typedef CSafeEnumATVEFStartStopList		ThisClassSSLTVE;
	typedef	IATVEFAttrList					BaseT;

	typedef DATE							TKey;
	typedef DATE							TVal;
	typedef	std::pair<TKey, TVal>			PairT;		
	typedef std::list<PairT>				ListT;				
		

public:
	CSafeEnumATVEFStartStopList()
	{
		m_punk		= NULL;
		m_iIterCur	= m_listT.begin();
		m_iCur		= 0;
	}

	~CSafeEnumATVEFStartStopList()  
	{
	}

	void FinalRelease()
	{
		m_listT.clear();

		if (m_punk != NULL)
			m_punk->Release();
	}

	void Init(IUnknown *punk, ListT *plistT)		// change to const ListT &rmapT???
	{
		if (m_punk != NULL)
		{
			m_punk->Release();
			m_punk = NULL;
		}

		if(NULL == plistT) return;		// bogus!!!

		if (punk != NULL)				// back pointer to containing class
		{
//			punk->AddRef();
//			m_punk = punk;
		}
		
								// copy the whole list (this is slow but safe!)
		EnterCriticalSection(&_Module.m_csTypeInfoHolder);
		{	
			ListT::iterator iIter;
			for(iIter = plistT->begin(); iIter != plistT->end(); iIter++)
			{
				TKey   key = (*iIter).first;  
				TVal   val = (*iIter).second;
				
				PairT	p(key,val);
				m_listT.push_back(p);		// append to the list		
			}
		}	
		LeaveCriticalSection(&_Module.m_csTypeInfoHolder);

		m_iCur = 0;
		m_iIterCur = m_listT.begin();
	}

BEGIN_COM_MAP(ThisClassSSLTVE)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

	// IEnumUnknown interface  -- get the next celt elements
	STDMETHOD(Next)(ULONG celt, VARIANT *pvar, ULONG *pceltFetched)
		{
		ENTER_API
			{
			ULONG celtFetched = 0;
			int iMax = m_listT.size();

			if ((pvar == NULL) || ((celt > 1) && (pceltFetched == NULL)))
				return E_POINTER;
			
			for (ULONG l=0; l < celt; l++)
				VariantInit( &pvar[l] ) ;

			while ((m_iCur < iMax) && (celtFetched < celt))
			{
				TKey tvK = (*m_iIterCur).first;
				TVal tvT = (*m_iIterCur).second;
														// slightly more formal way (if not slower)
														// since it does better error handling
				CComVariant *pcvvar = (CComVariant *) pvar;
				*pcvvar = tvT;							// problem - only returns 'value' here... How to do both?

				pvar++;
				celtFetched++;
				m_iIterCur++;	m_iCur++;
			}
			
			if (pceltFetched != NULL)
				*pceltFetched = celtFetched;
			
			return (celtFetched == celt) ? S_OK : S_FALSE;
			}
		EXIT_API
		}
	
	STDMETHOD(Skip)(ULONG celt)
		{
		ENTER_API
			{
				m_iCur += celt;
			
				if(m_iCur < m_listT.size())
				{
					for(int i = 0; i < celt; i++)
						m_iIterCur++;
					return S_OK;
				} else {
					m_iIterCur = m_listT.end();
					return S_FALSE;
				}
			}
		EXIT_API
		}
	
	STDMETHOD(Reset)(void)
		{
		ENTER_API
			{
				m_iCur = 0;
				m_iIterCur = m_listT.begin();
				return S_OK;
			}
		EXIT_API
		}
	
	STDMETHOD(Clone)(IEnumVARIANT **ppenum)
		{
		ENTER_API
			{
				static char THIS_FILE[] = __FILE__;	// for debug version of NewComObject
				ThisClassSSLTVE *penum = NewComObject(ThisClassSSLTVE);

				if (penum == NULL)
					return E_OUTOFMEMORY;

				penum->Init(m_punk, &m_listT);
				penum->m_iCur = m_iCur;
				for(int i = 0; i < m_iCur; i++)
					penum->m_iIterCur++;

				HRESULT hr = penum->QueryInterface(IID_IEnumVARIANT, (void **)ppenum);
				if(!FAILED(hr)) 
					penum->Release();
				return hr;
			}
		EXIT_API
		}

protected:
	IUnknown		*m_punk;			// back pointer to list class, to keep it alive
	ListT			m_listT;			// complete copy of the list, not pointer!
	ListT::iterator	m_iIterCur;			// actual iterator into m_listT  -- keep these 2 in sync --
	int				m_iCur;				// index of location into list   -- keep these 2 in sync --
};
/////////////////////////////////////////////////////////////////////////////
// CATVEFStartStopList
class ATL_NO_VTABLE CATVEFStartStopList : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATVEFStartStopList, &CLSID_ATVEFStartStopList>,
	public ISupportErrorInfo,
	public IDispatchImpl<IATVEFStartStopList, &IID_IATVEFStartStopList, &LIBID_ATVEFSENDLib>
{
	typedef	IATVEFStartStopList				BaseT;
	typedef CATVEFStartStopList				ThisClassTVEAM;

	typedef DATE							TKey;
	typedef DATE							TVal;

	typedef std::pair<TKey, TVal>			PairT;
	typedef std::list<PairT>				ListT;
//	typedef std::vector<PairT>				ListT;
	typedef CSafeEnumATVEFStartStopList		EnumTVESSListT;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_ATVEFSTARTSTOPLIST)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATVEFStartStopList)
	COM_INTERFACE_ENTRY(IATVEFStartStopList)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IATVEFStartStopList
public:
	CATVEFStartStopList()
	{
		m_cLast = 0;
	}

	~CATVEFStartStopList()
	{
		RemoveAll();
	}


	virtual BOOL FOkToRemove()
	{
		return TRUE;
	}
	

	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
	{
		ENTER_API
		{
			HRESULT hr;
			ValidateOutPtr<IUnknown *>(ppunk, NULL);

			static char THIS_FILE[] = __FILE__;	// for debug version of NewComObject
			EnumTVESSListT *penum = NewComObject(EnumTVESSListT);
			if (penum == NULL)
				return E_OUTOFMEMORY;
			
			penum->Init((IUnknown *)(BaseT *)this, &m_listT);

			hr =  penum->QueryInterface(IID_IEnumVARIANT, (void **)ppunk);
			penum->Release();			// need this...
			return hr;
		}
		EXIT_API
	}
	
	STDMETHOD(get_Count)(long *plCount)
	{
		ENTER_API
		{
			ValidateOutPtr<long>(plCount, NULL);

			if (plCount == NULL)
				return E_POINTER;
			
			*plCount = m_listT.size();
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(TKey key, TVal *pT )			// fast (but for string-compares) - uses map
	{
		ENTER_API
		{	
			ValidateOutPtr<TVal>(pT, NULL);

			ListT::iterator iterFind = Find(key); 
			if(iterFind != m_listT.end()) 
			{
				*pT = (*iterFind).second;			// copies data
			} else {
				return S_FALSE;
			}
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(VARIANT varKey, TVal *pT )
	{
		return Item(varKey, pT);		// all inline, error handling down lower...
	}

	STDMETHOD(get_Key)(VARIANT varValue, TVal *pT )
	{
		return Key(varValue, pT);
	}

	STDMETHOD(Add)(TKey rKey, TVal rVal)		// appends key/value pair to end of list
	{
		ENTER_API
		{
			ListT::value_type keyval(rKey, rVal);
			m_listT.push_back(keyval);
			return S_OK;
		}
		EXIT_API
	}
	
	
	STDMETHOD(Remove)(VARIANT varIn)
	{
		ENTER_API
		{
			CComVariant var(varIn);
			switch (var.vt)
			{
			case VT_BSTR:					// perhaps works for STRING type (UTC or local time zone from VB?)
				{
					var.ChangeType(VT_DATE);			// blow up perhaps if wrong casting
					
					ListT::iterator iIter = Find(var.date);
					if(m_listT.end() != iIter) {
						m_listT.erase(iIter);
						return S_OK;
					} else {
						return S_FALSE;
					}
				}
				break;
			case VT_DATE:					// dates are easier
				{
					var.ChangeType(VT_DATE);		
					
					ListT::iterator iIter = Find(var.date);
					if(m_listT.end() != iIter) {
						m_listT.erase(iIter);
						return S_OK;
					} else {
						return S_FALSE;
					}
				}
				break;

			default:				// slight different that above, since this only removes 1 object (by iter)
				{					//   and the above erase removes all keys with the same name
					ListT::iterator iIter;
					HRESULT hr = ItemIter(var, iIter);
					if(S_OK == hr) 
					{
						if(m_listT.end() != m_listT.erase(iIter))	// returns end() if item not there
							return S_OK;
						else
							return E_UNEXPECTED;				// this should never happen
					} else {
						return hr;
					}
				}
				break;
			}					// end switch
		return E_FAIL;		// should never get here...
			return E_NOTIMPL;
		}
		EXIT_API
	}
	
	STDMETHOD(RemoveAll)()
	{
		ENTER_API
		{
			//if(!m_listT.empty())
			//	m_listT.erase(m_listT.begin(),m_listT.end());
			m_listT.clear();
			m_cLast = 0;			// restart the Add1 count...
			return S_OK;
		}
		EXIT_API
	}

	STDMETHOD(Item)(VARIANT varKey, TVal *pT)
	{
		ENTER_API
		{
			ValidateOutPtr<TVal>(pT, NULL);

			ListT::iterator iIter;
			HRESULT hr = ItemIter(varKey, iIter);
			if(S_OK == hr) {
				*pT = (*iIter).second;						// copies pointer
			} 
			return hr;
		}
		EXIT_API
	}


	STDMETHOD(Key)(VARIANT varValue, TVal *pT)
	{
		ENTER_API
		{
			ValidateOutPtr<TVal>(pT, NULL);

			ListT::iterator iIter;
			HRESULT hr = KeyIter(varValue, iIter);
			if(S_OK == hr) {
				*pT = (*iIter).first;						// copies pointer
			} 
			return hr;
		}
		EXIT_API
	}
								// local routine to set iter to given item
	HRESULT ItemIter(VARIANT varIn, ListT::iterator &iIter)
	{
		CComVariant var(varIn);
		int index;

		switch (var.vt)
		{
		case VT_BSTR:		// only works for STRING type keys  (Possible bug for strings: UTC or local TZ?)
		case VT_DATE:	
			{
				var.ChangeType(VT_DATE);			// blow up perhaps if wrong casting
				
									// use iter to find matching key...
				ListT::iterator iterLoop;
				for(iIter = m_listT.begin(); iIter != m_listT.end(); iIter++)
				{
					TKey *pKey = &((*iIter).first);	
					if(*pKey == var.date)				// find first value matching input one
					{									//  (there may be more)  (perhaps change to < or something for dates?)
						return S_OK;
					}
				}
				iIter = m_listT.end();
				return S_FALSE;							// didn't find it..
			}
			break;

		default:
			{
				var.ChangeType(VT_I4);
				index = var.lVal;


				if(index < 0 || index >= m_listT.size())
					return S_FALSE;

				// use iterator here to get n'th value  
				for(iIter = m_listT.begin(); 
					 index > 0 /*&& iter != m_listT.end()*/; 
					--index, iIter++)
					{
						;
					}
				return S_OK;
			}
			break;
		}					// end switch
		return E_FAIL;		// should never get here...
	}						// end function

	
								// local routine to return iter to given item
	HRESULT KeyIter(VARIANT varIn, ListT::iterator &iIter)
	{
		CComVariant var(varIn);
		int index;

		switch (var.vt)
		{
		case VT_BSTR:		// only works for STRING type keys	(UTC vs Local TZ bug from VB?)
		case VT_DATE:	
			{
				var.ChangeType(VT_BSTR);			// blow up perhaps if wrong casting

				ListT::iterator iterLoop;
				for(iIter = m_listT.begin(); iIter != m_listT.end(); iIter++)
				{
					TVal *pValue = &((*iIter).second);	
					if(var.date == *pValue)			// find first value matching input one
					{									//  (there may be more)
						return S_OK;
					}
				}
				iIter = m_listT.end();
				return S_FALSE;				// didn't find it..
			}
			break;

		default:
			{
				var.ChangeType(VT_I4);
				index = var.lVal;


				if(index < 0 || index >= m_listT.size())
				{
					iIter = m_listT.end();
					return S_FALSE;
				}

				// use iterator here to get n'th value  (slow, but hey... better than nothing)
				for(iIter = m_listT.begin(); 
					 index > 0/*&& iter != m_listT.end()*/; 
					--index, iIter++)
						;
						
				return S_OK;
			}
			break;
		}					// end switch
		return E_FAIL;		// should never get here...
	}						// end function

								// local routine to set iter to given item
	ListT::iterator Find(TKey &rKey)
	{
									// use iter to find matching key...
		ListT::iterator iterLoop;
		const TKey crKey = rKey;
		for(iterLoop = m_listT.begin(); iterLoop != m_listT.end(); iterLoop++)
		{
			TKey *pKey = &((*iterLoop).first);	
			if(crKey == *pKey)				// find first value matching input one
			{									//  (there may be more)
				return iterLoop;
			}
		}
		iterLoop = m_listT.end();
		return iterLoop;					// didn't find it..
	}
	
	STDMETHOD(DumpToBSTR)(BSTR *pBstrBuff)			// should be in a _helper interface
	{
		const int kMaxChars=256;
		TCHAR tBuff[kMaxChars];
		CComBSTR bstrOut;
		bstrOut.Empty();

		ListT::iterator iIter;
		int i = 0;
		bstrOut.Append(L"{");
		for(iIter = m_listT.begin(); iIter != m_listT.end(); iIter++, i++)
		{
			if(i != 0) { _stprintf(tBuff,_T(" | ")); bstrOut.Append(tBuff); }
			_stprintf(tBuff,_T("%12.5g:%12.5g"),(*iIter).first,(*iIter).second);
			bstrOut.Append(tBuff);
		}
		bstrOut.Append(L"}");
		bstrOut.CopyTo(pBstrBuff);
		return S_OK;
	}

	ListT	m_listT;							// base collection object..
	int		m_cLast;						// last Add1() item (to handle deletes)
};

#endif //__ATVEFSTARTSTOPLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\xmit.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        xmit.cpp

    Abstract:

        This module 

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        02-Apr-1999     created

--*/

#include "stdafx.h"
#include "msbdnapi.h"
#include "xmit.h"

#include "stdio.h" //added by a-clardi

//#import "msbdnapi.idl"; // no_namespace named_guids

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static HRESULT
ToHRESULT (
    HRESULT hr
    ) 
{
    return (hr != S_OK ? (FAILED (hr) ? hr : HRESULT_FROM_WIN32 (hr)) : hr) ;
}

CMulticastTransmitter::CMulticastTransmitter () : m_ulIP (0),
                                                  m_usPort (0),
					                              m_TTL (DEFAULT_TTL),
                                                  m_State (STATE_UNINITIALIZED)
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    ;
}

CMulticastTransmitter::~CMulticastTransmitter ()
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    ;
}

BOOL
CMulticastTransmitter::IsConnected (
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    return m_State == STATE_CONNECTED ;
}

HRESULT
CMulticastTransmitter::SetMulticastIP (
    IN  ULONG   ulIP
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    assert (m_State != STATE_CONNECTED) ;

    if (VALID_MULTICAST_IP(ulIP) == FALSE) {
        return E_INVALIDARG ;
    }

    m_ulIP = ulIP ;

    return S_OK ;
}

HRESULT
CMulticastTransmitter::SetPort (
    IN  USHORT  usPort
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    assert (m_State != STATE_CONNECTED) ;

    m_usPort = usPort ;
    return S_OK ;
}


HRESULT
CMulticastTransmitter::GetMulticastIP (
    OUT ULONG * pulIP
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    assert (pulIP) ;

    * pulIP = m_ulIP ;
    return S_OK ;
}

HRESULT
CMulticastTransmitter::GetPort (
    OUT USHORT *    pusPort
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    assert (pusPort) ;
    * pusPort = m_usPort ;
    return S_OK ;
}

HRESULT
CMulticastTransmitter::SetMulticastScope (
    IN  INT     MulticastScope
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    m_TTL   = MulticastScope ;
    return S_OK ;
}

HRESULT
CMulticastTransmitter::GetMulticastScope (
    OUT INT *   pMulticastScope
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    assert (pMulticastScope) ;

    * pMulticastScope = m_TTL ;
    return S_OK ;
}

HRESULT
CMulticastTransmitter::SetBitRate (
    IN  DWORD   BitRate
    )
{
    assert (m_State != STATE_CONNECTED) ;

    m_Throttle.SetBitRate (BitRate) ;
    return S_OK ;
}

HRESULT
CMulticastTransmitter::SendThrottled (
			IN  LPBYTE  pbBuffer,
			IN  INT     iLength
			)
{
    m_Throttle.Throttle (iLength * 8) ;
    return Send (pbBuffer, iLength) ;
}
// ----------------------------------------------------------------------------
//   Throttling code
//
//			Was in throttle.h
//			move here to make it easier to debug ...
//
//	
// ----------------------------------------------------------------------------
void CThrottle::Throttle(
				IN  INT BitsToSend
				)
{
    DWORD   ticks ;
    DWORD   SleepMillis ;
    INT     bitsWeCanSend=0;

	_ASSERTE(m_BitsPerSecond > 0);			// error check!

    //  if (BitsToSend > 64k -> fail

    SetCurrTickCount(GetTickCount ()) ;
    while ((bitsWeCanSend = RemoveBitsFromBucket(BitsToSend)) < BitsToSend) 
	{
						// 1000 * bits / (bits/sec)  == MilliSecs
		BitsToSend -= bitsWeCanSend;
        SleepMillis = MulDiv (1000, BitsToSend, m_BitsPerSecond) ;
 		if(SleepMillis < 10) return;
//			SleepMillis+=10;
		Sleep (SleepMillis) ;
	//	ATLTRACE("Throttle - Sleeping %d msec\n", SleepMillis);
		ticks = GetTickCount();
        SetCurrTickCount(ticks) ;			// refill bucket with passage of time...
    }

    return ;
}

DWORD
CThrottle::SetCurrTickCount(				// fills bucket up based on passage of time..
				IN  DWORD   dwCurrentTicks
				)
{
    DWORD   quota, delta ;

    if (dwCurrentTicks < m_LastUpdateTicks) {
        m_LastUpdateTicks = dwCurrentTicks ;
        return NO_ERROR ;
    }

    //  how long since last
   delta = dwCurrentTicks - m_LastUpdateTicks ;
   m_LastUpdateTicks = dwCurrentTicks ;

    //  how many bits to add to our bucket..  (Bits/Sec * MSec /  (MSec/Sec) - how many we supposedly transmitted
    quota = MulDiv (m_BitsPerSecond, delta, 1000) ;
    m_Bucket += quota ;

    if (m_Bucket > MAX_BUCKET_DEPTH)		// don't let bucket get too big 
	{
        m_Bucket = MAX_BUCKET_DEPTH ;
    }

    return NO_ERROR ;
}

INT
CThrottle::RemoveBitsFromBucket(
				IN  INT nBitsToSend
				)
{
    if (m_Bucket >= nBitsToSend)	// bucket is bigger than number of bits we want to send
	{
        m_Bucket -= nBitsToSend;	//	  empty out the bucket a bit
   	} 
	else							// remaining size of bucket is too small....
	{						
		nBitsToSend = m_Bucket;		//    this is all we can send
		m_Bucket = 0;				//	  totally empty out the bucket
	}
     return nBitsToSend;			// return number of bits we can send (either nBitToSend of #Bits in bucket, whatever is smaller)
}
// ----------------------------------------------------------------------------
//      C R o u t e r T u n n e l
// ----------------------------------------------------------------------------

CRouterTunnel::CRouterTunnel () : m_pIUnknown (NULL),
                                  m_pITunnel (NULL),
                                  m_pIHost (NULL)
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    ;
}

CRouterTunnel::~CRouterTunnel ()
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    RELEASE_AND_CLEAR (m_pIUnknown) ;
    RELEASE_AND_CLEAR (m_pITunnel) ;
    RELEASE_AND_CLEAR (m_pIHost) ;
}

HRESULT
CRouterTunnel::Initialize (
    IN  LPCOLESTR       szRouterHostname
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    HRESULT     hr ;

    RELEASE_AND_CLEAR (m_pIUnknown) ;
    RELEASE_AND_CLEAR (m_pITunnel) ;
    RELEASE_AND_CLEAR (m_pIHost) ;

	hr = E_NOTIMPL;

    //  get our interfaces
    hr = CoCreateInstance (CLSID_BdnTunnel, NULL, CLSCTX_SERVER, IID_IUnknown, (void **) & m_pIUnknown) ;
    GOTO_NE (hr, S_OK, cleanup) ;
    assert (m_pIUnknown) ;

    hr = m_pIUnknown -> QueryInterface (IID_IBdnHostLocator, (void **) & m_pIHost) ;
    GOTO_NE (hr, S_OK, cleanup) ;
    assert (m_pIHost) ;

    hr = m_pIUnknown -> QueryInterface (IID_IBdnTunnel, (void **) & m_pITunnel) ;
    GOTO_NE (hr, S_OK, cleanup) ;
    assert (m_pITunnel) ;

    //  set the bridge hostname if it is specified; if it is not specified, the router
    //  service is assumed to be running on the local host
    if (szRouterHostname &&
        szRouterHostname [0] != '\0') {

        hr = ToHRESULT (m_pIHost -> SetServer (szRouterHostname)) ;
        GOTO_NE (hr, S_OK, cleanup) ;
    }

    cleanup :

    if (SUCCEEDED (hr)) {
        m_State = STATE_INITIALIZED ;
    }
    else {
        RELEASE_AND_CLEAR (m_pIUnknown) ;
        RELEASE_AND_CLEAR (m_pITunnel) ;
        RELEASE_AND_CLEAR (m_pIHost) ;

        assert (m_State == STATE_UNINITIALIZED) ;
        assert (IS_HRESULT (hr)) ;
    }

    return hr ;

}

HRESULT
CRouterTunnel::Connect (
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    HRESULT hr ;

    assert (m_State >= STATE_INITIALIZED) ;
    assert (VALID_MULTICAST_IP (m_ulIP)) ;
    assert (m_pITunnel) ;

    hr = ToHRESULT (m_pITunnel -> SetDestinationAddress (m_ulIP, m_usPort)) ;
    if (SUCCEEDED (hr)) {
        hr = ToHRESULT (m_pITunnel -> Connect ()) ;
        if (SUCCEEDED (hr)) {
            m_State = STATE_CONNECTED ;
        }
    }

    assert (IS_HRESULT (hr)) ;

    if (FAILED (hr)) {
        Disconnect () ;
    }

    return hr ;
}

HRESULT 
CRouterTunnel::Send (
    IN LPBYTE   pbBuffer,
    IN INT      iLength
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    HRESULT hr ;

    assert (m_pITunnel) ;

    assert (m_State == STATE_CONNECTED) ;

    hr = ToHRESULT (m_pITunnel -> Send (pbBuffer, iLength, BDN_TUNNEL_MESSAGE_UDP_PAYLOAD)) ;

    //
    //  if the send failed, we disconnect before sending back an error; the calling
    //  code handles this well, and stops all transmissions in case of an error.  We
    //  disconnect now before the TCP window collapses and prevents all future
    //  transmissions, including disconnects.
    if (FAILED (hr)) {
        Disconnect () ;
    }

    assert (IS_HRESULT (hr)) ;

    return hr ;
}

HRESULT
CRouterTunnel::Disconnect (
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    HRESULT  hr ;

    if (m_State != STATE_CONNECTED) {
        return S_OK ;
    }

    assert (m_pITunnel) ;

    hr = ToHRESULT (m_pITunnel -> Disconnect ()) ;
    if (SUCCEEDED (hr)) {
        m_State = STATE_INITIALIZED ;
    }

    assert (IS_HRESULT (hr)) ;

    return hr ;
}

// ----------------------------------------------------------------------------
//      C N a t i v e M u l t i c a s t
// ----------------------------------------------------------------------------

CNativeMulticast::CNativeMulticast () : m_Socket (INVALID_SOCKET),
                                        m_ulNIC (0)
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    ;
}

CNativeMulticast::~CNativeMulticast ()
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    RESET_SOCKET (m_Socket) ;

    if (m_State >= STATE_INITIALIZED) {
        WSACleanup () ;
    }
}

HRESULT
CNativeMulticast::Initialize (
    IN  ULONG   NetworkInterface
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    assert (m_State == STATE_UNINITIALIZED) ;

    if (WSAStartup(MAKEWORD(2, 0), &m_wsadata)) {
        return S_FALSE ;
    }

    m_ulNIC = NetworkInterface ;

    m_State = STATE_INITIALIZED ;

    return S_OK ;
}

HRESULT
CNativeMulticast::Connect (
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    BOOL        t ;
    int         retval ;
    SOCKADDR_IN tmp_addr ;
    DWORD       dwBytes ;

    if (m_State == STATE_CONNECTED) {
        return S_OK ;
    }

    RESET_SOCKET (m_Socket) ;

    //  get our socket
    m_Socket = WSASocket (AF_INET, SOCK_DGRAM, 0, NULL, 0, WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF) ;
    GOTO_EQ (m_Socket, INVALID_SOCKET, error) ;

    //  setsockopt
    t = TRUE ;
    retval = setsockopt (m_Socket, SOL_SOCKET, SO_REUSEADDR, (char *)&t, sizeof t) ;
    GOTO_EQ (retval, SOCKET_ERROR, error) ;

    ZeroMemory (& tmp_addr, sizeof tmp_addr) ;

    //  set the family and port
    tmp_addr.sin_family = AF_INET ;
    tmp_addr.sin_port = htons (m_usPort) ;

    //  set the NIC if specified, otherwise to INADDR_ANY
    if (m_ulNIC != 0) {
        tmp_addr.sin_addr.S_un.S_addr = htonl (m_ulNIC) ;
    }
    else {
        tmp_addr.sin_addr.S_un.S_addr = htonl (INADDR_ANY) ;
    }

    //  bind it up
    retval = bind (m_Socket, (LPSOCKADDR) & tmp_addr, sizeof tmp_addr) ;
    GOTO_EQ (retval, SOCKET_ERROR, error) ;

    //  now set the multicast scope
    retval = WSAIoctl (m_Socket, SIO_MULTICAST_SCOPE, & m_TTL, sizeof m_TTL, NULL, 0, & dwBytes, NULL, NULL) ;
    GOTO_EQ (retval, SOCKET_ERROR, error) ;

    //
    //  we're now set to multicast from this host; we set the multicast 
    //  destination
    //

    //  tmp_addr still holds the port and family, update the destination address
    //  and join the multicast as a sender
    tmp_addr.sin_addr.S_un.S_addr = htonl (m_ulIP) ;
    retval = (int) WSAJoinLeaf (m_Socket, (SOCKADDR *) & tmp_addr, sizeof tmp_addr, NULL, NULL, NULL, NULL, JL_SENDER_ONLY) ;
    GOTO_EQ ((SOCKET) retval, INVALID_SOCKET, error) ;

    //  connect our sender socket to the target multicast address
    retval = WSAConnect (m_Socket, (SOCKADDR *) & tmp_addr, sizeof tmp_addr, NULL, NULL, NULL, NULL) ;
    GOTO_EQ (retval, SOCKET_ERROR, error) ;

    //  update state and return success
    m_State = STATE_CONNECTED ;
    return S_OK ;

    error :

    retval = WSAGetLastError () ;

    RESET_SOCKET (m_Socket) ;

    return HRESULT_FROM_WIN32 (retval) ;
}

HRESULT 
CNativeMulticast::Send (
    IN LPBYTE   pbBuffer,
    IN INT      iLength
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    WSABUF  wsabuf ;
    ULONG   bytes ;
    int     retval ;

    assert (m_State == STATE_CONNECTED) ;
    assert (m_Socket != INVALID_SOCKET) ;

    wsabuf.len = iLength ;
    wsabuf.buf = reinterpret_cast <char *> (pbBuffer) ;

#if 0 // Use this to dump package contents to file
	DumpPackageBytes("c:\\AtvefSend.bin", pbBuffer, iLength);
#endif

    retval = WSASend (m_Socket, & wsabuf, 1, & bytes, NULL, NULL, NULL) ;

    if (retval != SOCKET_ERROR &&
        bytes == (ULONG) iLength) {
        retval = NO_ERROR ;
    }
    else {
        retval = WSAGetLastError () ;
        Disconnect () ;
    }

    return HRESULT_FROM_WIN32 (retval) ;
}

HRESULT
CNativeMulticast::DumpPackageBytes(
		char* pszFile,
	    IN LPBYTE   pbBuffer,
	    IN INT      iLength)
{
	static int nPktCnt = 0;
	FILE* pFile;

	if (nPktCnt == 0)
		pFile = fopen(pszFile, "wb");
	else
		pFile = fopen(pszFile, "ab");
	if (!pFile)
		return E_FAIL;

	{
		nPktCnt++;
		char szData[128];

		sprintf(szData, "\nPacket #%d\n", nPktCnt);
		fputs(szData, pFile);
	}

	size_t nWritten = fwrite(pbBuffer, 1, iLength, pFile);

	fclose(pFile);
	pFile = NULL;

	if (nWritten != iLength)
		return S_FALSE;

	return S_OK;
}

HRESULT
CNativeMulticast::Disconnect (
    )
/*++

    Routine Description:



    Parameters:



    Return Value:

        

--*/
{
    if (m_Socket != INVALID_SOCKET) {
        assert (m_State == STATE_CONNECTED) ;
        RESET_SOCKET (m_Socket) ;
        m_State = STATE_INITIALIZED ;
    }

    return S_OK ;
}

// ----------------------------------------------------------------------------
//      C I P V B I E n c o  d e r
// ----------------------------------------------------------------------------

CIPVBIEncoder::CIPVBIEncoder (
    ) : m_pInserter (NULL),
        m_pIpVbi (NULL),
        m_fCompressionEnabled (TRUE)
{
}

CIPVBIEncoder::~CIPVBIEncoder (
    )
{
}

HRESULT
CIPVBIEncoder::Initialize (
    IN  CTCPConnection *    pInserter,
    IN  CIPVBI *            pIpVbi,
    IN  BOOL                fCompressionEnabled
    )
{
    assert (pInserter) ;
    assert (pInserter -> IsConnected ()) ;

    m_pInserter = pInserter ;
    m_pIpVbi = pIpVbi ;
    m_fCompressionEnabled = fCompressionEnabled ;

    m_State = STATE_INITIALIZED ;

    return S_OK ;
}

HRESULT
CIPVBIEncoder::Connect (
    )
{
    m_State = STATE_CONNECTED ;
    return S_OK ;
}

HRESULT 
CIPVBIEncoder::Send (
    IN LPBYTE   pbBuffer,
    IN INT      iLength
    )
{
    HRESULT hr ;
    BYTE *  pSLIPFrame ;
    INT     SLIPFrameLength ;

    assert (m_State == STATE_CONNECTED) ;
    assert (m_pInserter) ;
    assert (m_pIpVbi) ;
    assert (pbBuffer) ;
    assert (iLength > 0) ;

#if 0 // Use this to dump package contents to file
	hr = DumpPackageBytes("c:\\AtvefSend.bin", pbBuffer, iLength);
#endif

    hr = m_pIpVbi -> Encode (
                        pbBuffer,
                        iLength,
                        m_ulIP,
                        m_usPort,
                        m_TTL,
                        m_fCompressionEnabled,
                        & pSLIPFrame,
                        & SLIPFrameLength
                        ) ;


    GOTO_NE (hr, S_OK, cleanup) ;

    assert (pSLIPFrame) ;
    assert (SLIPFrameLength > 0) ;

    hr = m_pInserter -> Send (	
                            pSLIPFrame,
                            SLIPFrameLength
                            ) ;
#if 0 // Use this to dump package contents to file
	hr = DumpPackageBytes("c:\\AtvefSendSlip.bin", pSLIPFrame, iLength);
#endif

    cleanup :
    
    return hr ;
}

HRESULT CIPVBIEncoder::DumpPackageBytes(
		char* pszFile,
	    IN LPBYTE   pbBuffer,
	    IN INT      iLength)
{
	static int nSlipPktCnt = 0;
	static int nPktCnt = 0;
	FILE* pFile;

	if (nPktCnt == 0 || nSlipPktCnt == 0)
		pFile = fopen(pszFile, "wb");
	else
		pFile = fopen(pszFile, "ab");
	if (!pFile)
		return E_FAIL;

	if (strcmp(pszFile, "c:\\AtvefSend.bin") == 0)
	{
		nPktCnt++;
		char szData[128];

		sprintf(szData, "\nPacket #%d\n", nPktCnt);
		fputs(szData, pFile);
	}
	else
		nSlipPktCnt++;

	size_t nWritten = fwrite(pbBuffer, 1, iLength, pFile);

	fclose(pFile);
	pFile = NULL;

	if (nWritten != iLength)
		return S_FALSE;

	return S_OK;
}

HRESULT
CIPVBIEncoder::Disconnect (
    )
{
    m_State = STATE_INITIALIZED ;
    return S_OK ;
}


// ----------------------------------------------------------------------------
//      C I P L i n e 2 1 E n c o d e r
// ----------------------------------------------------------------------------

CIPLine21Encoder::CIPLine21Encoder (
    ) : m_pInserter (NULL)
{
}

CIPLine21Encoder::~CIPLine21Encoder (
    )
{
}

HRESULT
CIPLine21Encoder::Initialize (
    IN  CTCPConnection *    pInserter
    )
{
    assert (pInserter) ;
    assert (pInserter -> IsConnected ()) ;

    m_pInserter = pInserter ;
    m_State = STATE_INITIALIZED ;

    return S_OK ;
}

HRESULT
CIPLine21Encoder::Connect (
    )
{
    m_State = STATE_CONNECTED ;
    return S_OK ;
}

HRESULT 
CIPLine21Encoder::Send (
    IN LPBYTE   pbBuffer,
    IN INT      iLength
    )
{
    HRESULT hr ;

    assert (m_State == STATE_CONNECTED) ;
    assert (m_pInserter) ;
    assert (pbBuffer) ;
    assert (iLength > 0) ;

    hr = m_pInserter -> Send (
                            pbBuffer,
                            iLength
                            ) ;
    
    return hr ;
}

HRESULT
CIPLine21Encoder::Disconnect (
    )
{
    m_State = STATE_INITIALIZED ;
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\xmit.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        xmit.h

    Abstract:

        This module 

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        02-Apr-1999     created

--*/

#ifndef _atvefsnd__xmit_h
#define _atvefsnd__xmit_h

#include "throttle.h"
#include "msbdnapi.h"
#include "tcpconn.h"
#include "ipvbi.h"

//  base class for our tunnel and
class CMulticastTransmitter
{
    enum {
        DEFAULT_TTL = 2
    } ;

    protected :

        enum CONNECT_STATE {
            STATE_UNINITIALIZED,
            STATE_INITIALIZED,
            STATE_CONNECTED
        } ;

        ULONG               m_ulIP ;
        USHORT              m_usPort ;
        CONNECT_STATE       m_State ;
        INT                 m_TTL ;
        CThrottle           m_Throttle ;

    public :
        
        CMulticastTransmitter () ;
        virtual ~CMulticastTransmitter () ;

        BOOL
        IsConnected (
            ) ;

        virtual 
        HRESULT
        Connect (
            ) = 0 ;

        virtual 
        HRESULT 
        Send (
            IN  LPBYTE  pbBuffer,
            IN  INT     iLength
            ) = 0 ;

        virtual
        HRESULT
        Disconnect (
            ) = 0 ;

        HRESULT
        SendThrottled (
            IN  LPBYTE  pbBuffer,
            IN  INT     iLength
            ) ;

        HRESULT
        SetMulticastIP (
            IN  ULONG   ulIP
            ) ;

        HRESULT
        SetPort (
            IN  USHORT  usPort
            ) ;

        HRESULT
        GetMulticastIP (
            OUT ULONG * pulIP
            ) ;

        HRESULT
        GetPort (
            OUT USHORT *    pusPort
            ) ;

        HRESULT
        SetMulticastScope (
            IN  INT MulticastScope
            ) ;

        HRESULT
        GetMulticastScope (
            OUT INT *   pMulticastScope
            ) ;

        HRESULT
        SetBitRate (
            IN  DWORD   BitRate
            ) ;
} ;

class CRouterTunnel :
    public CMulticastTransmitter
{
    IUnknown *          m_pIUnknown ;
    IBdnTunnel *        m_pITunnel ;
    IBdnHostLocator *   m_pIHost ;

    public :

        CRouterTunnel () ;
        ~CRouterTunnel () ;

        HRESULT
        Initialize (
            IN  LPCOLESTR       szRouterHostname
            ) ;

        virtual 
        HRESULT
        Connect (
            ) ;

        virtual 
        HRESULT 
        Send (
            IN LPBYTE   pbBuffer,
            IN INT      iLength
            ) ;

        virtual
        HRESULT
        Disconnect (
            ) ;
} ;

    
class CNativeMulticast :
    public CMulticastTransmitter
{
    SOCKET  m_Socket ;
    ULONG   m_ulNIC ;
    WSADATA m_wsadata ;

    public :

        CNativeMulticast () ;
        ~CNativeMulticast () ;

        HRESULT
        Initialize (    
            IN  ULONG   NetworkInterface
            ) ;

        virtual 
        HRESULT
        Connect (
            ) ;

        virtual 
        HRESULT 
        Send (
            IN LPBYTE   pbBuffer,
            IN INT      iLength
            ) ;

        virtual
        HRESULT
        Disconnect (
            ) ;

		HRESULT
		DumpPackageBytes(
			char* pszFile,
		    IN LPBYTE   pbBuffer,
		    IN INT      iLength);

} ;

/*++
    this class is a bit peculiar:

    The norpak inserter accepts 1 connection per port
--*/
class CIPVBIEncoder :
    public CMulticastTransmitter
{
    CTCPConnection *    m_pInserter ;
    CIPVBI *            m_pIpVbi ;
    BOOL                m_fCompressionEnabled ;

    public :

        CIPVBIEncoder () ;
        ~CIPVBIEncoder () ;

        HRESULT
        Initialize (
            IN  CTCPConnection *    pInserter,
            IN  CIPVBI *            pIpVbi,
            IN  BOOL                fCompressionEnabled
            ) ;

        virtual 
        HRESULT
        Connect (
            ) ;

        virtual 
        HRESULT 
        Send (
            IN LPBYTE   pbBuffer,
            IN INT      iLength
            ) ;

		virtual								// added by a-clardi
		HRESULT 
		DumpPackageBytes(
			char* pszFile,
			IN LPBYTE   pbBuffer,
			IN INT      iLength);

        virtual
        HRESULT
        Disconnect (
            ) ;
} ;
    
class CIPLine21Encoder :
    public CMulticastTransmitter
{
    CTCPConnection *    m_pInserter ;

    public :

        CIPLine21Encoder () ;
        ~CIPLine21Encoder () ;

		CONNECT_STATE GetState()	{return m_State;}

        HRESULT
        Initialize (
            IN  CTCPConnection *    pInserter
            ) ;

        virtual 
        HRESULT
        Connect (
            ) ;

        virtual 
        HRESULT 
        Send (
            IN LPBYTE   pbBuffer,
            IN INT      iLength
            ) ;

        virtual
        HRESULT
        Disconnect (
            ) ;
} ;
    

#endif  //  _atvefsnd__xmit_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\uhttpfrg.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        uhttpfrg.cpp

    Abstract:

        this module is the header for a class which fragments the contents of
        files per the ATVEF specification

        See http://www.atvef.com/atvef_spec/TVE-public.htm for a specification.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        05-Feb-1999     created 

--*/

#ifndef _uhttpfrg_h_
#define _uhttpfrg_h_

#include <math.h>

#include "mpegcrc.h"
#include <WinSock2.h>

template <class T>
T DivRoundUp (T Number, T Denominator)
{
    return (Number + Denominator - 1) / Denominator ;
}

template <class T>
T SetInBounds (T & Number, T Min, T Max)
{
    if (Number < Min) {
        Number = Min ;
    }
    else if (Number > Max) {
        Number = Max ;
    }

    return Number ;
}

class CUHTTPFragment
{
    public :

#ifdef SUPPORT_UHTTP_EXT  // a-clardi
		USHORT	m_nExtensionHeaderSize;
		LPBYTE	m_pbExtensionData;
		BOOL	m_fExtensionExists;


		HRESULT
		SetExtensionHeader(
						IN USHORT usLength,
						IN LPBYTE pbData);
#endif

        typedef enum {
            GET_BY_ROW,
            GET_BY_COL
        } GET_SCHEMA ;

    private :

        // UHTTP header
        //  bitfields are declared in reverse order to specification because
        //  specification assumes network order.  The x86 stores in little
        //  endian, so we need to specifically reverse the declaration here.
        typedef struct tagUHTTP_HEADER {
            BYTE    CRCFollows          : 1,
                    HTTPHeadersPrecede  : 1,
                    ExtensionHeader     : 1,
                    Version             : 5 ;
            BYTE    PacketsInXORBlock ;
            WORD    RetransmitExpiration ;
            GUID    TransferID ;
            DWORD   ResourceSize ;
            DWORD   SegStartByte ;                  // 0-based
        } UHTTP_HEADER, * LPUHTTP_HEADER ;

        enum {
            UHTTP_VERSION   = 0,
            CRC_SIZE        = sizeof ULONG,
        } ;

        //  defaults, all of which can be overridden, within
        //  the constraints of the hard stops enumerated below
        enum {
            //  UDP payload MTU on Ethernet; computed as follows:
            //      ethernet MTU    = 1500
            //      ip header size  = 20
            //      udp header size = 8
            //      
            //  1472 = 1500 - 20 - 8
            DEF_DATAGRAM_SIZE           = 1472,		// BUGBUG?  JB 11/9/99
	//		DEF_DATAGRAM_SIZE           = 1500,		// Bug fix? later calls subtract of 28 bytes

            //  min/max for XOR block size, includes XOR Datagram
            DEF_MIN_XOR_BLOCK_SIZE      = 2,
            DEF_MAX_XOR_BLOCK_SIZE      = 8,
        
            //  no CRC, by default
            DEF_CRC_FOLLOWS             = FALSE,

            //  retransmit expiration
            DEF_RETRANSMIT_EXPIRATION   = 30 * 60,
        } ;

        //  hard stops which cannot be exceeded
        enum {
            //  XOR datagram = payload datagram
            HARD_MIN_XOR_BLOCK_SIZE     = 2,

            //  datagram size cannot be 0, and must be a multiple of 
            //  sizeof DWORD
            HARD_MIN_DATAGRAM_SIZE      = sizeof DWORD,

            //  datagram size cannot exceed the max UDP payload (65507)
            //  and must be divisible by 4
            HARD_MAX_DATAGRAM_SIZE      = 65507 & 0xfffffffc,
        } ;

        //  last non-fill packet is the last datagram which contains relevant
        //  content that is needed by the reconstruction code on the client
        typedef struct tagLAST_NONFILL_PACKET {
            DWORD   Row ;
            BYTE    Col ;
        } LAST_NONFILL_PACKET, * LPLAST_NONFILL_PACKET ;

        //  get state - keeps track of last datagram retrieved
        typedef struct tagGET_STATE {
            GET_SCHEMA  GetSchema ;
            DWORD       CurRowIndex ;
            BYTE        CurColIndex ;
        } GET_STATE ;

        //  primary data structure; MATRIX_REF is our matrix reference; it
        //  contains all
        typedef struct tagMATRIX_REF {
            LPBYTE              pbUHTTPDatagrams ;
            DWORD               dwMaxRows ;
            DWORD               dwCurrentRows ;
            BYTE                Columns ;               //  XOR block size
            DWORD               dwUHTTPDatagramSize ;
            BOOL                fIncludeCRC ;           //  TRUE: append CRC after last read
            LAST_NONFILL_PACKET LastNonFillPacket ;
            GET_STATE           GetState ;

            DWORD   DatagramPayloadSize ()
            {
                return dwUHTTPDatagramSize - sizeof UHTTP_HEADER;
            }
        } MATRIX_REF, * LPMATRIX_REF ;

        //  all of the following assume being called with a 0-based row,
        //  col indeces
        LPBYTE 
        Datagram_ (
            DWORD   row, 
            BYTE    col
            )
        {
            return & m_Matrix.pbUHTTPDatagrams [(row * m_Matrix.Columns + col) * m_Matrix.dwUHTTPDatagramSize] ;
        }

#ifdef SUPPORT_UHTTP_EXT
        LPBYTE 
        DatagramUHTTPHeader_ (
            DWORD   row, 
            BYTE    col
            )
        {
            return (LPBYTE) Datagram_ (row, col) ;
        }

        LPBYTE 
        XORDatagramUHTTPHeader_ (
            DWORD row
            )
        {
            return DatagramUHTTPHeader_ (row, m_Matrix.Columns - 1) ;
        }

#else
        LPUHTTP_HEADER 
        DatagramUHTTPHeader_ (
            DWORD   row, 
            BYTE    col
            )
        {
            return (LPUHTTP_HEADER) Datagram_ (row, col) ;
        }

        LPUHTTP_HEADER 
        XORDatagramUHTTPHeader_ (
            DWORD row
            )
        {
            return DatagramUHTTPHeader_ (row, m_Matrix.Columns - 1) ;
        }
#endif


        LPBYTE 
        DatagramPayload_ (
            DWORD   row, 
            BYTE    col
            )
        {
#ifdef SUPPORT_UHTTP_EXT
            return Datagram_ (row, col) + sizeof UHTTP_HEADER + m_nExtensionHeaderSize;
#else
            return Datagram_ (row, col) + sizeof UHTTP_HEADER ;
#endif
        }

        LPBYTE 
        XORDatagramPayload_ (
            DWORD row
            )
        {
            return DatagramPayload_ (row, m_Matrix.Columns - 1) ;
        }

        BOOL 
        IsXORDatagram_ (
            DWORD   row, 
            BYTE    col)
        {
            return m_Matrix.Columns - 1 == col ;
        }

        BOOL 
        IsPaddingDatagram_ (
            DWORD   row, 
            BYTE    col)
        {
            return (row == m_Matrix.LastNonFillPacket.Row - 1) && 
                   (col > m_Matrix.LastNonFillPacket.Col - 1) && 
                   !IsXORDatagram_ (row,col) ;
        }

        void
        Lock_ (
            )
        {
            EnterCriticalSection (& m_crt) ;
        }

        void
        Unlock_ (
            )
        {
            LeaveCriticalSection (& m_crt) ;
        }

        DWORD
        AllocateAndInitializeDatagramMatrix_ (
            IN  DWORD           dwFileSize,
			IN	LONG			cPacketsPerXORSet
            ) ;

        DWORD
        ValidateHeapHandle_ (
            ) ;

        DWORD
        GenerateStaticUHTTPHeaderFields_ (
            IN  DWORD           dwPayloadSize,
			IN	GUID			*pPackageUUID
            ) ;

        DWORD
        CompleteXORBlock_ (
            IN  DWORD           dwRow
            ) ;

        DWORD
        StampNextHeader_ (
            IN  DWORD   Row,
            IN  BYTE    Col
            ) ;

        DWORD
        FillDatagramPayload_ (
            IN      HANDLE  hFileIn,
            IN      DWORD   Row,
            IN      BYTE    Col,
            IN OUT  DWORD * pdwBytesRead
            ) ;

        DWORD
        InitMatrix_ (
            IN  DWORD   dwFileSize,
			IN LONG		cPacketsPerXORSet,		// if zero, uses the default value
			IN GUID	 *	pguidPackageUUID		// if null, generates a unqie one
            ) ;

        void
        FreeMatrix_ (
            ) ;


        DWORD               m_dwMinXORBlockSize ;       //  minimum XOR block size; at least 2
        DWORD               m_dwMaxXORBlockSize ;       //  maximum XOR block size; arbitrary
        HANDLE              m_hHeap ;                   //  HANDLE to the heap to use for memory allocation
        BOOL                m_fCRCFollows ;             //  BOOL flag if CRC is to be included
        USHORT              m_usRetransmitExpiration ;  //  retransmit expiration value
        DWORD               m_dwUHTTPDatagramSize ;     //  datagram size
        MATRIX_REF          m_Matrix ;                  //  matrix referred to by this instance
        UHTTP_HEADER        m_UHTTPStaticHeader ;       //  static header fields which are stamped on each datagram
        MPEGCRC             m_MPEGCRC ;                 //  CRC computation class
        DWORD               m_CRCValue ;                //  CRC value
        CRITICAL_SECTION    m_crt ;

    public :

        CUHTTPFragment () ;
        ~CUHTTPFragment () ;

#if 1 // Added by a-clardi
		DWORD				m_dwTotalDatagramCount;
#endif

        DWORD
        Fragment (
            IN  char *  szDataFile,
			IN LONG  cPacketsPerXORSet,	
			IN GUID	 *	pguidPackageUUID	// if NULL, generates a unique one itself
            ) ;

        DWORD
        GetNextDatagram (
            OUT LPBYTE *    pBuffer,
            OUT int *       iLength,
            IN  GET_SCHEMA  GetSchema = GET_BY_COL
            ) ;

        DWORD
        Reset (
            ) ;

        DWORD
        SetXORBlockSizeRange (
            IN  BYTE    Min,
            IN  BYTE    Max
            ) ;

        DWORD
        SetCRCFollows (
            IN  BOOL    fCRCFollows
            ) ;

        DWORD
        SetUHTTPDatagramSize (
            IN  DWORD   dwUHTTPDatagramSize
            ) ;

        DWORD
        SetHeap (
            IN  HANDLE  hHeap
            ) ;

        static
        DWORD
        GetTransmitSize (
            IN  DWORD   FileSize,
            OUT DWORD * TransmitSize
            ) ;

} ;

#endif  //  _uhttpfrg_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\zconf.h ===
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-1996 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* $Id: zconf.h,v 1.20 1996/07/02 15:09:28 me Exp $ */

#ifndef _ZCONF_H
#define _ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if (defined(__STDC__) || defined(__cplusplus)) && !defined(STDC)
#  define STDC
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            1 << (windowBits+2)   +  1 << (memLevel+9)
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR __far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#    define SMALL_MEDIUM
#    define FAR __far
#  endif
#endif
#ifndef FAR
#   define FAR
#endif

typedef unsigned char  Byte;  /* 8 bits */
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#if defined(__BORLANDC__) && defined(SMALL_MEDIUM)
   /* Borland C/C++ ignores FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif


/* Compile with -DZLIB_DLL for Windows DLL support */
#if (defined(_WINDOWS) || defined(WINDOWS)) && defined(ZLIB_DLL)
#  include <windows.h>
#  define EXPORT  WINAPI
#else
#  define EXPORT
#endif

#endif /* _ZCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\zlib.h ===
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.0.4, Jul 24th, 1996.

  Copyright (C) 1995-1996 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  gzip@prep.ai.mit.edu    madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#ifdef __cplusplus
extern "C" {
#endif

#include "zconf.h"
#include <stdio.h>

#define ZLIB_VERSION "1.0.4"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms may be added later and will have the same
  stream interface.

     For compression the application must provide the output buffer and
  may optionally provide the input buffer for optimization. For decompression,
  the application must provide the input buffer and may optionally provide
  the output buffer for optimization.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library does not install any signal handler. It is recommended to
  add at least a handler for SIGSEGV when decompressing; the library checks
  the consistency of the input data whenever possible but may go nuts
  for some forms of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

extern const char * EXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
extern int EXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


extern int EXPORT deflate OF((z_streamp strm, int flush));
/*
  Performs one or both of the following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_PARTIAL_FLUSH, the current compression
  block is terminated and flushed to the output buffer so that the
  decompressor can get all input data available so far. For method 9, a future
  variant on method 8, the current block will be flushed but not terminated.
  Z_SYNC_FLUSH has the same effect as partial flush except that the compressed
  output is byte aligned (the compressor can clear its internal bit buffer)
  and the current block is always terminated; this can be useful if the
  compressor has to be restarted from scratch after an interruption (in which
  case the internal state of the compressor may be lost).
    If flush is set to Z_FULL_FLUSH, the compression block is terminated, a
  special marker is output and the compression dictionary is discarded; this
  is useful to allow the decompressor to synchronize if one compressed block
  has been damaged (see inflateSync below).  Flushing degrades compression and
  so should be used only when necessary.  Using Z_FULL_FLUSH too often can
  seriously degrade the compression. If deflate returns with avail_out == 0,
  this function must be called again with the same value of the flush
  parameter and more output space (updated avail_out), until the flush is
  complete (deflate returns with non-zero avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible.
*/


extern int EXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
extern int EXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.  If
   zalloc and zfree are set to Z_NULL, inflateInit updates them to use default
   allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_VERSION_ERROR if the zlib library version is incompatible
   with the version assumed by the caller.  msg is set to null if there is no
   error message. inflateInit does not perform any decompression: this will be
   done by inflate().
*/


extern int EXPORT inflate OF((z_streamp strm, int flush));
/*
  Performs one or both of the following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_PARTIAL_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_PARTIAL_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

    inflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if the end of the
  compressed data has been reached and all uncompressed output has been
  produced, Z_NEED_DICT if a preset dictionary is needed at this point (see
  inflateSetDictionary below), Z_DATA_ERROR if the input data was corrupted,
  Z_STREAM_ERROR if the stream structure was inconsistent (for example if
  next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
  Z_BUF_ERROR if no progress is possible or if there was not enough room in
  the output buffer when Z_FINISH is used. In the Z_DATA_ERROR case, the
  application may then call inflateSync to look for a good compression block.
  In the Z_NEED_DICT case, strm->adler is set to the Adler32 value of the
  dictionary chosen by the compressor.
*/


extern int EXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
extern int EXPORT deflateInit2 OF((z_streamp strm,
                                   int  level,
                                   int  method,
                                   int  windowBits,
                                   int  memLevel,
                                   int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library. (Method 9 will allow a 64K history buffer and
   partial block flushes.)

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library (the value 16 will be allowed for method 9). Larger
   values of this parameter result in better compression at the expense of
   memory usage. The default value is 15 if deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

     If next_in is not null, the library will use this buffer to hold also
   some history information; the buffer must either hold the entire input
   data, or have at least 1<<(windowBits+1) bytes and be writable. If next_in
   is null, the library will allocate its own history buffer (and leave next_in
   null). next_out need not be provided here but must be provided by the
   application for the next call of deflate().

     If the history buffer is provided by the application, next_in must
   must never be changed by the application since the compressor maintains
   information inside this buffer from call to call; the application
   must provide more input only by increasing avail_in. next_in is always
   reset by the library in this case.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
   an invalid method). msg is set to null if there is no error message.
   deflateInit2 does not perform any compression: this will be done by
   deflate(). 
*/
                            
extern int EXPORT deflateSetDictionary OF((z_streamp strm,
                                           const Bytef *dictionary,
				           uInt  dictLength));
/*
     Initializes the compression dictionary (history buffer) from the given
   byte sequence without producing any compressed output. This function must
   be called immediately after deflateInit or deflateInit2, before any call
   of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).
     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and
   can be predicted with good accuracy; the data can then be compressed better
   than with the default empty dictionary. In this version of the library,
   only the last 32K bytes of the dictionary are used.
     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state
   is inconsistent (for example if deflate has already been called for this
   stream). deflateSetDictionary does not perform any compression: this will
   be done by deflate(). 
*/

extern int EXPORT deflateCopy OF((z_streamp dest,
                                  z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.  If
   the source stream is using an application-supplied history buffer, a new
   buffer is allocated for the destination stream.  The compressed output
   buffer is always application-supplied. It's the responsibility of the
   application to provide the correct values of next_out and avail_out for the
   next call of deflate.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

extern int EXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

extern int EXPORT deflateParams OF((z_streamp strm, int level, int strategy));
/*
     Dynamically update the compression level and compression strategy.
   This can be used to switch between compression and straight copy of
   the input data, or to switch to a different kind of input data requiring
   a different strategy. If the compression level is changed, the input
   available so far is compressed with the old level (and may be flushed);
   the new level will take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
extern int EXPORT inflateInit2 OF((z_streamp strm,
                                   int  windowBits));

     This is another version of inflateInit with more compression options. The
   fields next_out, zalloc, zfree and opaque must be initialized before by
   the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library (the value 16 will be allowed soon). The
   default value is 15 if inflateInit is used instead. If a compressed stream
   with a larger window size is given as input, inflate() will return with
   the error code Z_DATA_ERROR instead of trying to allocate a larger window.

     If next_out is not null, the library will use this buffer for the history
   buffer; the buffer must either be large enough to hold the entire output
   data, or have at least 1<<windowBits bytes.  If next_out is null, the
   library will allocate its own buffer (and leave next_out null). next_in
   need not be provided here but must be provided by the application for the
   next call of inflate().

     If the history buffer is provided by the application, next_out must
   never be changed by the application since the decompressor maintains
   history information inside this buffer from call to call; the application
   can only reset next_out to the beginning of the history buffer when
   avail_out is zero and all output has been consumed.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
   windowBits < 8). msg is set to null if there is no error message.
   inflateInit2 does not perform any decompression: this will be done by
   inflate().
*/

extern int EXPORT inflateSetDictionary OF((z_streamp strm,
				           const Bytef *dictionary,
					   uInt  dictLength));
/*
     Initializes the decompression dictionary (history buffer) from the given
   uncompressed byte sequence. This function must be called immediately after
   a call of inflate if this call returned Z_NEED_DICT. The dictionary chosen
   by the compressor can be determined from the Adler32 value returned by this
   call of inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

extern int EXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until the special marker (see deflate()
  above) can be found, or until all available input is skipped. No output
  is provided.

    inflateSync returns Z_OK if the special marker has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no marker has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

extern int EXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level, window size,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

extern int EXPORT compress OF((Bytef *dest,   uLongf *destLen,
			       const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

extern int EXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
				 const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

extern gzFile EXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9").  gzopen can be used to read a file which is not in gzip format;
   in this case gzread will directly read from the file without decompression.
     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).
*/

extern gzFile EXPORT gzdopen  OF((int fd, const char *mode));
extern gzFile EXPORT gzoverlay  OF((FILE *fp, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

extern int EXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

extern int EXPORT    gzwrite OF((gzFile file, const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

extern int EXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

extern int EXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

extern const char * EXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

extern uLong EXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

extern uLong EXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
extern int EXPORT deflateInit_ OF((z_streamp strm, int level,
			           const char *version, int stream_size));
extern int EXPORT inflateInit_ OF((z_streamp strm,
				   const char *version, int stream_size));
extern int EXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
				    int windowBits, int memLevel, int strategy,
				    const char *version, int stream_size));
extern int EXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
				    const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
		      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))

#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

const uLongf *get_crc_table OF((void)); /* can be used by asm versions of crc32() */

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\uhttpfrg.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        uhttpfrg.cpp

    Abstract:

        This module implements a class which fragments the contents of a file
        into ATVEF-compliant UHTTP datagrams.

        See http://www.atvef.com/atvef_spec/TVE-public.htm for a specification.

        CUHTTPFragment fragments the contents of a file in memory.  At this
        point there is no type of caching attempted should the file be very
        large.  The primary users of this class will be transmitting data via
        the VBI, so very large files will most likely not be transmitted.  The
        hosting code could fragment 1 file at a time and write out the datagrams
        to a file.  GetNextDatagram () returns the length of each datagram, which
        could be stored as context with the written file..

        The primary data structure is a matrix.  We always transmit XOR blocks,
        so if the file is of size <= our minimum datagram size, two datagrams
        will be transmitted: (1) with the file contents, (2) XOR content.  In
        conjunction with the primary data structure, a MATRIX_REF data
        structure which is used as a reference into the matrix.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        05-Feb-1999     created 

--*/

#include "stdafx.h"				// new jb

#include "uhttpfrg.h"
#include "trace.h"
#include "DbgStuff.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// switches a GUID to network order
#define HTON_GUID(guid)    \
            (guid).Data1 = htonl ((guid).Data1) ;   \
            (guid).Data2 = htons ((guid).Data2) ;   \
            (guid).Data3 = htons ((guid).Data3) ;

#define NTOH_GUID(guid) HTON_GUID(guid)

CUHTTPFragment::CUHTTPFragment () : m_dwMinXORBlockSize (DEF_MIN_XOR_BLOCK_SIZE),
                                    m_dwMaxXORBlockSize (DEF_MAX_XOR_BLOCK_SIZE),
                                    m_fCRCFollows (DEF_CRC_FOLLOWS),
                                    m_usRetransmitExpiration (DEF_RETRANSMIT_EXPIRATION),
                                    m_dwUHTTPDatagramSize (DEF_DATAGRAM_SIZE),
                                    m_hHeap (NULL),
#ifdef SUPPORT_UHTTP_EXT
									m_nExtensionHeaderSize(0),
									m_pbExtensionData(NULL),
									m_fExtensionExists(FALSE)
#endif

/*++
    
    Routine Description:

        class constructor; initializes property values to the defaults; non-
        failable; zeroes the contents of the MATRIX_REF data structure

    Parameters:

        none

    Return Values:

        none

--*/
{
    ENTERW_OBJ_0 (L"CUHTTPFragment::CUHTTPFragment") ;

    ZeroMemory (& m_Matrix, sizeof m_Matrix) ;
    InitializeCriticalSection (& m_crt) ;
}

CUHTTPFragment::~CUHTTPFragment ()
/*++
    
    Routine Description:

        class destructor; frees the resources referenced by MATRIX_REF, if any

    Parameters:

        none

    Return Values:
    
        none

--*/
{
    ENTERW_OBJ_0 (L"CUHTTPFragment::~CUHTTPFragment") ;

#ifdef SUPPORT_UHTTP_EXT
	delete [] m_pbExtensionData;
#endif

    FreeMatrix_ () ;
    DeleteCriticalSection (& m_crt) ;
}

DWORD
CUHTTPFragment::Fragment (
    IN  char *  szDataFile,
	IN LONG  cPacketsPerXORSet,
	IN GUID	 *	pguidPackageUUID		// maybe NULL in which case auto-gen it
    )
/*++
    
    Routine Description:

        This is the main routine which is called to fragment the contents of a
        file.

        This rougine allocates sufficient memory to hold the entire fragmented
        file in memory.

        The size of the memory allocated varies proportionately to the size of
        the file and properties that are defined for the matrix (XOR block
        size, datagram size, etc...).

        Once the memory has been allocated, datagram payloads are read from the
        file by row, filling each up before going to the next.  The last
        datagram of each row is an XOR datagram which is used for FEC on the
        client side.  So the algorithm reads in col-1 datagrams, then completes
        the XOR datagram, and processes the next row, until the whole file has
        been read and fragmented.  Each datagram has a header prepended which
        is also used by the client-side code to reconstruct the original file.

        The dimensions of the matrix are computed such that the last row should
        have >= 1 datagram, in addition to the XOR datagram.

        If a failure occurs at any point, the routine closes the file, frees
        the memory, and exits.  The return value will be a Win32 error which
        is indicative of the type of failure.

    Parameters:

        szDataFile  null-terminated string which is the file to be fragmented.

    Return Values:

        NO_ERROR        success
        Win32 Error     failure
--*/
{
    HANDLE      hFileIn ;
    DWORD       dwFileSize ;
    DWORD       dwFileSizeHigh ;
    DWORD       retval ;
    DWORD       Row ;
    BYTE        Col ;
    DWORD       dwBytesRead ;

    ENTERA_OBJ_1 ("CUHTTPFragment::Fragment (\"%s\")", szDataFile) ;

    hFileIn = INVALID_HANDLE_VALUE ;

    hFileIn = CreateFileA (szDataFile,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL) ;
    if (hFileIn == INVALID_HANDLE_VALUE) {
        return GetLastError () ;
    }

    dwFileSize = GetFileSize (hFileIn, & dwFileSizeHigh) ;

    //
    //  the UHTTP field for data size is a DWORD, so if the file is larger
    //  than can be specified in a DWORD, we fail
    //

    if (dwFileSizeHigh) {
        retval = ERROR_GEN_FAILURE ;
        goto error ;
    }

    retval = InitMatrix_ (dwFileSize, cPacketsPerXORSet, pguidPackageUUID) ;
    GOTO_NE (retval, NO_ERROR, error) ;

    //  process each row of the matrix
    for (dwBytesRead = 0, Row = 0; Row < m_Matrix.dwMaxRows; Row++) {
        
        //  all the data columns, except for XOR block
        for (Col = 0; Col < m_Matrix.Columns - 1; Col++) {

            //  stamp in the new header
            StampNextHeader_ (Row, Col) ;

            //  read in datagram payload
            retval = FillDatagramPayload_ (hFileIn, Row, Col, & dwBytesRead) ;
            GOTO_NE (retval, NO_ERROR, error) ;
        }

        //  write out the XOR block
        retval = CompleteXORBlock_ (Row) ;
        GOTO_NE (retval, NO_ERROR, error) ;
    }

    assert (m_Matrix.dwCurrentRows == m_Matrix.dwMaxRows) ;
    assert (m_Matrix.LastNonFillPacket.Row == m_Matrix.dwMaxRows) ;     // last row not empty
    assert (m_Matrix.LastNonFillPacket.Col > 0) ;                       // at least 1 datagram

    CLOSE_IF_OPEN (hFileIn) ;

    return NO_ERROR ;

    error :

    CLOSE_IF_OPEN (hFileIn) ;
    FreeMatrix_ () ;

    return retval ;
}

DWORD
CUHTTPFragment::FillDatagramPayload_ (
    IN      HANDLE  hFileIn,
    IN      DWORD   Row,
    IN      BYTE    Col,
    IN OUT  DWORD * pdwBytesRead
    )
/*++
    
    Routine Description:

        this routine fills the UHTTP datagram payload with up-to the maximum
        payload size from the file;

        if we are computing a CRC as well, we update it and decide if we need
        to write it out; if we do need to write it out i.e. all the data from
        the file has been read, we must accomodate several corner cases which
        are documented in the code below.

    Parameters:

        hFileIn         the HANDLE to the file to read datagram payload from

        Row             the 0-based row index into the matrix of the current
                        datagram

        Col             the 0-based column index into the matrix of the current
                        datagram

        pdwBytesRead    pointer to the number of bytes read last; upon return
                        points to the number of bytes read this time; expected
                        to be initialized to 0

    Return Values:

        success     NO_ERROR
        failure     Win32 error code

--*/
{
    LPBYTE  pbCRC ;                             //  byte pointer to the CRC value
    LPBYTE  pbPayload ;                         //  byte pointer into the payload
    ULONG   CRC ;                               //  CRC value
    DWORD   cbCRCLeft ;                         //  bytes of the CRC value remaining
    BOOL    r ;                                 //  ReadFile return value
    DWORD   dwDatagramPayloadRemaining  ;       //  datagram payload remaining

    ENTERW_OBJ_4 (L"CUHTTPFragment::FillDatagramPayload_  (%08XH, row = %u, col = %u, %08XH)", hFileIn, Row, Col, pdwBytesRead) ;

    assert (hFileIn) ;
    assert (pdwBytesRead) ;
    assert (Row < m_Matrix.dwMaxRows) ;
    assert (Col < m_Matrix.Columns - 1) ;

    //  try to read data in only if we expect to read something in
    if (Row == 0 ||
        * pdwBytesRead) {

        //  and read in the content
#ifdef SUPPORT_UHTTP_EXT
		LPBYTE buffer = DatagramPayload_ (Row, Col);
		DWORD nBytesToRead = (m_Matrix.DatagramPayloadSize() - m_nExtensionHeaderSize);
		r = ReadFile (hFileIn, buffer, nBytesToRead, pdwBytesRead, NULL) ;
#else
        r = ReadFile (hFileIn, DatagramPayload_ (Row, Col), m_Matrix.DatagramPayloadSize (), pdwBytesRead, NULL) ;
#endif
        GOTO_EQ (r, FALSE, error) ;
    }

    //  if the CRC is still to be included
    if (m_Matrix.fIncludeCRC) {

        //  update the CRC if something was read in above
        if (* pdwBytesRead) {
            m_MPEGCRC.Update (DatagramPayload_ (Row, Col), * pdwBytesRead) ;
        }

        //  did we reach the end of the file contents ?
#ifdef SUPPORT_UHTT_EXT
        if (* pdwBytesRead < (m_Matrix.DatagramPayloadSize () - m_nExtensionHeaderSize) {
#else
        if (* pdwBytesRead < m_Matrix.DatagramPayloadSize ()) {
#endif
           
            //  compute the bytes remaining
#ifdef SUPPORT_UHTT_EXT
            dwDatagramPayloadRemaining = (m_Matrix.DatagramPayloadSize ()  - m_nExtensionHeaderSize) - * pdwBytesRead ;
#else
            dwDatagramPayloadRemaining = m_Matrix.DatagramPayloadSize () - * pdwBytesRead ;
#endif

            //  easy case: we can fit the CRC into the current datagram
            if (dwDatagramPayloadRemaining >= CRC_SIZE) {
                * reinterpret_cast <ULONG *> (DatagramPayload_ (Row, Col) + * pdwBytesRead) = htonl (m_MPEGCRC.CRC ()) ;
            }
            //  else, the CRC meets one of the following criteria:
            //  (1) does not fit at all in this datagram
            //  (2) spans to the next datagram in the same row
            //  (3) spans to the next datagram in the next row
            //  
            //  in any of the above cases, we will copy the CRC one byte
            //  at a time, check before each byte if we need to
            //  span to next datagram, and if so, decide what the
            //  next datagram is
            else {

                assert (CRC_SIZE == sizeof CRC) ;

                //  retrieve the CRC and set our byte pointer to it
                CRC = htonl (m_MPEGCRC.CRC ()) ;
                pbCRC = reinterpret_cast <LPBYTE> (& CRC) ;

                //  set our byte pointer to the expected payload
                pbPayload = DatagramPayload_ (Row, Col) + * pdwBytesRead ;
                
                //  loop through and copy the contents of the CRC
                //  one byte at a time, checking if we are at the
                //  datagram boundary each time
                for (cbCRCLeft = CRC_SIZE; cbCRCLeft > 0; cbCRCLeft--, 
                                                          dwDatagramPayloadRemaining--) {

                    //  are we into the next datagram ?
                    if (dwDatagramPayloadRemaining == 0) {

                        assert (m_Matrix.DatagramPayloadSize () > CRC_SIZE) ;

                        //  is the next datagram in the same row ?
                        if (Col < m_Matrix.Columns - 1 - 1) {
                            assert (Row == m_Matrix.dwMaxRows - 1) ;

                            //  set the byte pointer to next datagram in the
                            //  same row
                            pbPayload = DatagramPayload_ (Row, Col + 1) ;
                        }
                        //  span down to the next row
                        else {
                            assert (Row + 1 == m_Matrix.dwMaxRows - 1) ;

                            //  set the byte pointer to the first datagram
                            //  of the next row
                            pbPayload = DatagramPayload_ (Row + 1, 0) ;
                        }

                        //  update the payload remaining counter
#ifdef SUPPORT_UHTTP_EXT
                        dwDatagramPayloadRemaining = m_Matrix.DatagramPayloadSize () - m_nExtensionHeaderSize;
#else
                        dwDatagramPayloadRemaining = m_Matrix.DatagramPayloadSize () ;
#endif
                    }

                    //  set the value of the payload pointer to the CRC at the 
                    //  current byte and increment each pointer
                    * pbPayload++ = * pbCRC++ ;
                }
            }

            //  set this property to FALSE since we've now included the CRC
            //  and don't need to do so again as we process the remainder
            //  of the filler packets
            m_Matrix.fIncludeCRC = FALSE ;
        }
    }

    return NO_ERROR ;

    error :

    return GetLastError () ;
}

DWORD
CUHTTPFragment::GetNextDatagram (
    OUT LPBYTE *    pbBuffer,
    OUT int *       piLength,
    IN  GET_SCHEMA  GetSchema
    )
/*++
    
    Routine Description:

        This routine retrieves the next datagram.  State is kept between 
        consecutive GetNextDatagram () calls, so successive calls to this 
        method will retrieve successive datagrams, per the schema specified.

        There are currently two schemas: GET_BY_ROW and GET_BY_COL.  GET_BY_ROW
        retrieves datagrams in the same order as the content exists in the file
        which was fragmented, plus the XOR datagrams at the end of each row.  
        GET_BY_COL returns all the datagrams in col 1, then all in col 2, 
        etc...  The last column retrieved is all XOR datagrams.

        If the last datagram was retrieved in a previous call, the parameter
        return values will be NULL and 0.

    Parameters:

        pbBuffer    pointer to a buffer to receive the contents; will be
                    NULL if attempting to read from beyond the last datagram

        piLength    pointer to an integer which holds the length of the
                    retrieved buffer; it should be noted that this value
                    is the length of the datagram, should we wish to fragment
                    a file and then the datagrams to file.  Reading this
                    amount from the file, will then retrieve successive
                    datagrams.  This value is 0 if attempting to read
                    beyond the end of the datagrams.

        GetSchema   schema specifier; note that changing the schema after
                    several GetNextDatagram () calls resets the indeces to 
                    (0,0)

    Return Values:

        success     NO_ERROR
        failure     Win32 error code

--*/
{
    ENTERW_OBJ_3 (L"CUHTTPFragment::GetNextDatagram (%08XH, %08XH, %u)", pbBuffer, piLength, GetSchema) ;

    if (pbBuffer    == NULL ||
        piLength    == NULL ||
        (GetSchema != GET_BY_ROW && GetSchema != GET_BY_COL)) {

        return ERROR_INVALID_PARAMETER ;
    }

    * pbBuffer = NULL ;
    * piLength = 0 ;

    if (m_Matrix.pbUHTTPDatagrams == NULL) {
        return ERROR_GEN_FAILURE ;
    }

    //  if the get schema has changed, reset the state
    if (GetSchema != m_Matrix.GetState.GetSchema) {

        m_Matrix.GetState.CurRowIndex = 0 ;
        m_Matrix.GetState.CurColIndex = 0 ;
        m_Matrix.GetState.GetSchema = GetSchema ;
    }

    if (GetSchema == GET_BY_COL) {

        //  check if we need to wrap to next col
        if (m_Matrix.GetState.CurRowIndex >= m_Matrix.dwMaxRows ||
            IsPaddingDatagram_ (m_Matrix.GetState.CurRowIndex, m_Matrix.GetState.CurColIndex)) {

            m_Matrix.GetState.CurColIndex++ ;
            m_Matrix.GetState.CurRowIndex = 0 ;

        }

        // check if we're now beyond the matrix
        if (m_Matrix.GetState.CurColIndex >= m_Matrix.Columns) {
            return NO_ERROR ;
        }

        * pbBuffer = Datagram_ (m_Matrix.GetState.CurRowIndex++, m_Matrix.GetState.CurColIndex) ;
        assert (* pbBuffer) ;

        * piLength = m_Matrix.dwUHTTPDatagramSize ;
    }
    else if (GetSchema == GET_BY_ROW) {

        //  check if we need to wrap to next row
        //  first, the obvious case, we processed the XOR datagram last
        if (m_Matrix.GetState.CurColIndex >= m_Matrix.Columns) {

            //  enter here if the last datagram processed was an XOR datagram
            m_Matrix.GetState.CurRowIndex++ ;
            m_Matrix.GetState.CurColIndex = 0 ;

        //  second, we may have some padding datagrams before we get to the
        //  the XOR datagram - this will only occur if we are in the last
        //  row; we cannot move beyond the matrix boundaries in this situation;
        //  in fact, this will be the last pass through here - the next call
        //  will iterate the counters outside the boundaries of the matrix
        //  and we'll hit the if clause above.
        } else if (IsPaddingDatagram_ (m_Matrix.GetState.CurRowIndex, m_Matrix.GetState.CurColIndex)) {

            //  skip beyond pure padding datagrams
            do {
                m_Matrix.GetState.CurColIndex++ ;
            } 
            while (IsPaddingDatagram_ (m_Matrix.GetState.CurRowIndex, m_Matrix.GetState.CurColIndex)) ;

            assert (m_Matrix.GetState.CurColIndex == m_Matrix.Columns - 1) ;
            assert (m_Matrix.GetState.CurRowIndex == m_Matrix.dwMaxRows - 1) ;
        }

        // check if we're beyond the matrix
        if (m_Matrix.GetState.CurRowIndex >= m_Matrix.dwMaxRows) {
            return NO_ERROR ;
        }

        * pbBuffer = Datagram_ (m_Matrix.GetState.CurRowIndex, m_Matrix.GetState.CurColIndex++) ;
        assert (* pbBuffer) ;

        * piLength = m_Matrix.dwUHTTPDatagramSize ;
    }

    return NO_ERROR ;
}

DWORD
CUHTTPFragment::Reset (
    )
/*++
    
    Routine Description:

        resets the indeces for future GetNextDatagram () calls.

    Parameters:
        
        hFrag       HANDLE value retrieved via successful call to 
                    Fragment ()

    Return Values:

        NO_ERROR        success
        Win32 error     failure

--*/
{
    ENTERW_OBJ_0 (L"CUHTTPFragment::Reset") ;

    m_Matrix.GetState.CurRowIndex = 0 ;
    m_Matrix.GetState.CurColIndex = 0 ;

    return NO_ERROR ;
}

DWORD
CUHTTPFragment::InitMatrix_ (
    IN  DWORD           dwFileSize,
	IN	LONG			cPacketsPerXORSet,
	IN	GUID			*ppguidPackageUUID
    )
/*++
    
    Routine Description:

        allocates new memory which is based on the current class properties
        and the filesize specified.

        The schema is initialize to GET_BY_COL, and the CRC is initialized
        only if we care about it.

        also the m_UHTTPStaticHeader data structure is initialized to those
        field values which will not change from datagram - datagram.

    Parameters:

        dwFileSize			size of the file which is to be fragmented
		dwPacketsInXORSet	requested size of packets to xor packet in system.
							If(0), uses the default size (which may be too small
							for large files).

    Return Values:

        NO_ERROR        success
        Win32 Error     failure

--*/
{
    DWORD   retval ;

    ENTERW_OBJ_1 (L"CUHTTPFragment::InitMatrix_ (%u)", dwFileSize) ;

    FreeMatrix_ () ;

    retval = ValidateHeapHandle_ () ;
    if (retval != NO_ERROR) {
        return retval ;
    }

    assert (m_hHeap) ;

    Lock_ () ;

    retval = AllocateAndInitializeDatagramMatrix_ (dwFileSize, cPacketsPerXORSet) ;
    GOTO_NE (retval, NO_ERROR, cleanup) ;

    retval = GenerateStaticUHTTPHeaderFields_ (dwFileSize, ppguidPackageUUID) ;
    if (retval != NO_ERROR) {
        FreeMatrix_ () ;
        goto cleanup ;
    }

    m_Matrix.GetState.GetSchema = GET_BY_COL ;

    m_Matrix.fIncludeCRC = m_fCRCFollows ;
    if (m_Matrix.fIncludeCRC) {
        m_MPEGCRC.Reset () ;
    }

    retval = NO_ERROR ;

    cleanup :

    Unlock_ () ;

    return retval ;
}

void
CUHTTPFragment::FreeMatrix_ (
    )
/*++
    
    Routine Description:

        frees the resources which are referenced by m_Matrix, if any

    Parameters:

        none

    Return Values:

        none

--*/
{
    ENTERW_OBJ_0 (L"CUHTTPFragment::FreeMatrix_") ;

    if (m_Matrix.pbUHTTPDatagrams) {
        assert (m_hHeap) ;

        HeapFree (m_hHeap, NULL, m_Matrix.pbUHTTPDatagrams) ;
        ZeroMemory (& m_Matrix, sizeof m_Matrix) ;
    }
}

DWORD
CUHTTPFragment::StampNextHeader_ (
    IN  DWORD   Row,
    IN  BYTE    Col
    )
/*++
    
    Routine Description:

        this routine stamps the contents of our static UHTTP header
        to the (Row, Col) datagram referenced by m_Matrix.

        This routine must be called for SUCCESSIVE datagrams read 
        in from the file.

    Parameters:


    Return Values:

        NO_ERROR

--*/
{
    ENTERW_OBJ_2 (L"CUHTTPFragment::StampNextHeader_ (%u, %u)", Row, Col) ;

#ifdef SUPPORT_UHTTP_EXT  //a-clardi

	// Append extension headers to datagram
	if (m_fExtensionExists)
	{
		m_UHTTPStaticHeader.ExtensionHeader = 1;

		LPBYTE p = DatagramUHTTPHeader_ (Row, Col);
	    memcpy (p, & m_UHTTPStaticHeader, sizeof UHTTP_HEADER) ;

		if (m_pbExtensionData)
		{
		    memcpy (p + sizeof UHTTP_HEADER, m_pbExtensionData, m_nExtensionHeaderSize) ;
		}

		m_UHTTPStaticHeader.SegStartByte = htonl (ntohl (m_UHTTPStaticHeader.SegStartByte) + (m_Matrix.DatagramPayloadSize () - m_nExtensionHeaderSize)) ;
	}
	else
	{
	    memcpy (DatagramUHTTPHeader_ (Row, Col), & m_UHTTPStaticHeader, sizeof UHTTP_HEADER) ;
		m_UHTTPStaticHeader.SegStartByte = htonl (ntohl (m_UHTTPStaticHeader.SegStartByte) + m_Matrix.DatagramPayloadSize ()) ;
	}

#else

    memcpy (DatagramUHTTPHeader_ (Row, Col), & m_UHTTPStaticHeader, sizeof UHTTP_HEADER) ;
    m_UHTTPStaticHeader.SegStartByte = htonl (ntohl (m_UHTTPStaticHeader.SegStartByte) + m_Matrix.DatagramPayloadSize ()) ;

#endif

    return NO_ERROR ;
}

DWORD
CUHTTPFragment::CompleteXORBlock_ (
    IN  DWORD           Row
    )
/*++
    
    Routine Description:

        this routine completes an XOR block block by XORing the 1st byte of
        of the first datagram, second datagram, etc... and placing the
        the result in the first byte of the XOR datagram.  All the bytes
        are XORed in this manner.  
        
        Since this class enforced a datagram size which is alighed on the
        size of a DWORD, we XOR 1 DWORD at a time vs. 1 BYTE at a time.

    Parameters:

        Row         the row in the matrix for which the XOR datagram is
                    to be computed.

    Return Values:

        NO_ERROR

--*/
{
    BYTE    Col ;
    DWORD * pdwXOR ;
    DWORD   DWORD_Index ;
    DWORD   DatagramPayloadSize_DWORD ;

    ENTERW_OBJ_1 (L"CUHTTPFragment::CompleteXORBlock_ (%u)", Row) ;
    
#ifdef SUPPORT_UHTTP_EXT
    assert (((m_Matrix.DatagramPayloadSize () - m_nExtensionHeaderSize) & 0x03) == 0) ;
#else
    assert ((m_Matrix.DatagramPayloadSize () & 0x03) == 0) ;
#endif

    StampNextHeader_ (Row, m_Matrix.Columns - 1) ;

#ifdef SUPPORT_UHTTP_EXT
    DatagramPayloadSize_DWORD = (m_Matrix.DatagramPayloadSize () - m_nExtensionHeaderSize) / sizeof DWORD ;
#else
    DatagramPayloadSize_DWORD = m_Matrix.DatagramPayloadSize () / sizeof DWORD ;
#endif

    pdwXOR = reinterpret_cast <DWORD *> (XORDatagramPayload_ (Row)) ;

    for (DWORD_Index = 0; DWORD_Index < DatagramPayloadSize_DWORD; DWORD_Index++) {
        assert (pdwXOR [DWORD_Index] == 0) ;

        for (Col = 0; Col < m_Matrix.Columns - 1; Col++) {
            pdwXOR [DWORD_Index] ^= (reinterpret_cast <DWORD *> (DatagramPayload_ (Row, Col))) [DWORD_Index] ;
        }
    }

    m_Matrix.dwCurrentRows++ ;

    return NO_ERROR ;
}

DWORD
CUHTTPFragment::AllocateAndInitializeDatagramMatrix_ (
    IN  DWORD           dwFileSize,
	IN	LONG			cPacketsPerXORSet			// if zero, uses default auto-gen valued
    )
/*++
    
    Routine Description:

        Allocates and initializes the datagram matrix which holds the contents
        of the fragmented file.

        The dimensions of the matrix are computed as follows:

            1. the file size is incremented by CRC_SIZE bytes if we are to 
                be included a CRC

            2.  next we divide the datagram size into the number of bytes to
                be fragmented, rounding up; this figure is the number of
                datagrams which are necessary just to hold the fragmented
                file contents

            3.  we next bound the number of columns (XOR block size) within
                a min/max property, setting to min if it is too small, or to
                max if it is too large; when bounding we take into account
                the XOR datagram which will go on the end of each row

            4.  we now have the column count, and we compute the row count,
                rounding up again; 
                
            The values we now have are within bounds column wise, and we
            have sufficient rows to hold the entire fragmented file; note
            that we may very likely have some extra datagrams padded on the
            end to fill out the matrix.
        
        The amount of memory allocated is then row * col * datagram_size.

        Locks held:     m_crt

    Parameters:

        dwFileSize			filesize, not including CRC
		cPacketsPerXORSet	number of packets per xor packets - if zero, uses a default
							size appox to sqrt(total packets) or m_dwMaxXORBlockSize(8), whatever is smaller

    Return Values:

        NO_ERROR        success
        Win32 error     failure

--*/
{
    DWORD   dwDatagramCount ;
    DWORD   dwRowCount ;
    DWORD   dwColCount ;
    DWORD   dwExtraBytes ;

    ENTERW_OBJ_1 (L"CUHTTPFragment::AllocateAndInitializeDatagramMatrix_ (%u)", dwFileSize) ;

    assert ((m_dwUHTTPDatagramSize & 0x03) == 0) ;

    m_Matrix.dwUHTTPDatagramSize = m_dwUHTTPDatagramSize ;

    //  all subsequent computations assume that dwFileSize is the size of the UHTTP datagram
    //  payload that must be transmitted; if we have CRC, it must be included in the payload
    //  size.
    dwFileSize += m_fCRCFollows ? CRC_SIZE : 0 ;

#ifdef SUPPORT_UHTTP_EXT
	// Add extension header size
    dwFileSize += m_nExtensionHeaderSize;
#endif

    //  compute the number of data Datagrams
#ifdef SUPPORT_UHTTP_EXT
    dwDatagramCount = DivRoundUp (dwFileSize, (m_Matrix.DatagramPayloadSize () - m_nExtensionHeaderSize)) ;
#else
    dwDatagramCount = DivRoundUp (dwFileSize, m_Matrix.DatagramPayloadSize ()) ;
#endif

    //  now compute the dimensions of our matrix for the data Datagrams only

    dwColCount = (DWORD) sqrt (dwDatagramCount) ;		// initial guess (make the block square)

	if(cPacketsPerXORSet <= 0)
		SetInBounds (dwColCount, m_dwMinXORBlockSize - 1, m_dwMaxXORBlockSize - 1) ;
	else
		dwColCount = (DWORD) cPacketsPerXORSet;

    dwRowCount = DivRoundUp (dwDatagramCount, dwColCount) ;

    //  we now have the data dimensions of our matrix; compute the 
    //  total Datagrams, including XOR Datagrams

    dwDatagramCount = dwRowCount * dwColCount + dwRowCount ;

#if 1 // Added by a-clardi
	m_dwTotalDatagramCount = dwDatagramCount;
#endif
    //  dwDatagramCount now contains the total number of Datagrams in our
    //  matrix

    m_Matrix.dwMaxRows = dwRowCount ;
    m_Matrix.Columns = (BYTE) (dwColCount + 1) ;         // include XOR column

    assert (m_hHeap) ;

    m_Matrix.pbUHTTPDatagrams = static_cast <LPBYTE> (HeapAlloc (m_hHeap, 
                                                                 HEAP_ZERO_MEMORY, 
                                                                 m_Matrix.dwMaxRows * m_Matrix.Columns * m_Matrix.dwUHTTPDatagramSize)) ;
    if (m_Matrix.pbUHTTPDatagrams == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY ;
    }

    //  the last computation we make is to figure out the last, non-padding
    //  datagram in the matrix

    //  rows: we expect to fill into the bottom row
    m_Matrix.LastNonFillPacket.Row = m_Matrix.dwMaxRows ;

    //  columns: compute the total payload capacity of the matrix, subtract the filesize
#ifdef SUPPORT_UHTTP_EXT
    dwExtraBytes = ((m_Matrix.DatagramPayloadSize () - m_nExtensionHeaderSize) * (m_Matrix.Columns - 1) * m_Matrix.dwMaxRows) - dwFileSize ;
#else
    dwExtraBytes = (m_Matrix.DatagramPayloadSize () * (m_Matrix.Columns - 1) * m_Matrix.dwMaxRows) - dwFileSize ;
#endif

    //  then divide the datagram payload into this to get the number of pure padding
    //  datagrams (division of integers will round down); don't include the XOR column
    //  in this computation
#ifdef SUPPORT_UHTTP_EXT
    m_Matrix.LastNonFillPacket.Col = (m_Matrix.Columns - 1) - (BYTE) (dwExtraBytes / (m_Matrix.DatagramPayloadSize () - m_nExtensionHeaderSize)) ;
#else
    m_Matrix.LastNonFillPacket.Col = (m_Matrix.Columns - 1) - (BYTE) (dwExtraBytes / m_Matrix.DatagramPayloadSize ()) ;
#endif

    return NO_ERROR ;
}

DWORD
CUHTTPFragment::GenerateStaticUHTTPHeaderFields_ (
    IN  DWORD           dwPayloadSize,
	IN	GUID			*ppguidPackageUUID
    )
/*++
    
    Routine Description:

        generates the entries in the UHTTP header which remain static
        for all the datagrams.

        locks held:     m_crt

    Parameters:

        dwPayloadSize   payload size; includes the CRC_SIZE byte CRC, as 
                        applicable

        pMatrix         MATRIX_REF pointer

    Return Values:

        NO_ERROR        success
        Win32 Error     failure

--*/
{
    ENTERW_OBJ_1 (L"CUHTTPFragment::GenerateStaticUHTTPHeaderFields_ (%u)", dwPayloadSize) ;

    ZeroMemory (& m_UHTTPStaticHeader, sizeof UHTTP_HEADER) ;

    //  stamp all fields which we won't be changing during the course 
    //  of this transmission

    m_UHTTPStaticHeader.Version                = UHTTP_VERSION ;
    m_UHTTPStaticHeader.CRCFollows             = m_fCRCFollows ? 1 : 0 ;
    m_UHTTPStaticHeader.HTTPHeadersPrecede     = 1 ;               // our input file is always MIME
    m_UHTTPStaticHeader.PacketsInXORBlock      = m_Matrix.Columns ;
    m_UHTTPStaticHeader.RetransmitExpiration   = htons (m_usRetransmitExpiration) ;        // this should really be computed on the fly ..

	m_UHTTPStaticHeader.TransferID = *ppguidPackageUUID;

    //  switch TransferID to network order
    HTON_GUID (m_UHTTPStaticHeader.TransferID) ;

    m_UHTTPStaticHeader.ResourceSize = htonl (dwPayloadSize + (m_fCRCFollows ? CRC_SIZE : 0)) ;

    return NO_ERROR ;
}

DWORD
CUHTTPFragment::ValidateHeapHandle_ (
    )
/*++
    
    Routine Description:

        validates or obtains a heap handle.

        The m_hHeap property is settable, so a hosting process could give us a handle from
        which to allocate memory.  By default, m_hHeap is set to NULL in the constructor.
        If it is still NULL when this routine is called, it is set to the process heap.

        m_hHeap is settable only once.

    Parameters:

        none

    Return Values:

        NO_ERROR        m_hHeap is valid and can be used
        Win32 Error     failure; m_hHeap is not valid and could not be obtained

--*/
{
    ENTERW_OBJ_0 (L"CUHTTPFragment::ValidateHeapHandle_") ;

    if (m_hHeap == NULL) {
        m_hHeap = GetProcessHeap () ;
        if (m_hHeap == NULL) {
            return GetLastError () ;
        }
    }

    return NO_ERROR ;
}

DWORD
CUHTTPFragment::SetXORBlockSizeRange (
    IN  BYTE    Min,
    IN  BYTE    Max
    )
/*++
    
    Routine Description:

    Parameters:

    Return Values:

--*/
{
    DWORD   retval ;

    ENTERW_OBJ_2 (L"CUHTTPFragment::SetXORBlockSizeRange (%u, %u)", Min, Max) ;

    retval = NO_ERROR ;

    Lock_ () ;

    if (Min >= HARD_MIN_XOR_BLOCK_SIZE) {
        m_dwMinXORBlockSize = Min ;
        m_dwMaxXORBlockSize = Max ;
    }
    else {
        retval = ERROR_INVALID_PARAMETER ;
    }

    Unlock_ () ;

    return retval ;
}

DWORD
CUHTTPFragment::SetCRCFollows (
    IN  BOOL    fCRCFollows
    )
/*++
    
    Routine Description:

    Parameters:

    Return Values:

--*/
{
    DWORD   retval ;

    ENTERW_OBJ_1 (L"CUHTTPFragment::SetCRCFollows (%08XH)", fCRCFollows) ;

    retval = NO_ERROR ;

    Lock_ () ;

    m_fCRCFollows = fCRCFollows ;

    Unlock_ () ;

    return retval ;
}

DWORD
CUHTTPFragment::SetUHTTPDatagramSize (
    IN  DWORD   dwUHTTPDatagramSize
    )
/*++
    
    Routine Description:

    Parameters:

    Return Values:

--*/
{
    DWORD   retval ;

    ENTERW_OBJ_1 (L"CUHTTPFragment::SetUHTTPDatagramSize (%u)", dwUHTTPDatagramSize) ;

    retval = NO_ERROR ;

    Lock_ () ;

    assert ((m_dwUHTTPDatagramSize & 0x03) == 0) ;

    if ((dwUHTTPDatagramSize & 0x03) == 0               &&
         dwUHTTPDatagramSize >= HARD_MIN_DATAGRAM_SIZE  &&
         dwUHTTPDatagramSize <= HARD_MAX_DATAGRAM_SIZE) {

        m_dwUHTTPDatagramSize = dwUHTTPDatagramSize ;
    }
    else {
        retval = ERROR_INVALID_PARAMETER ;       
    }


    Unlock_ () ;

    return retval ;
}

DWORD
CUHTTPFragment::SetHeap (
    IN  HANDLE  hHeap
    )
/*++
    
    Routine Description:

    Parameters:

    Return Values:

--*/
{
    DWORD   retval ;

    ENTERW_OBJ_1 (L"CUHTTPFragment::SetHeap (%08XH)", hHeap) ;

    retval = NO_ERROR ;

    Lock_ () ;

    //  can't change it after it's been used
    if (m_hHeap == NULL) {
        m_hHeap = hHeap ;
    }
    else {
        retval = ERROR_GEN_FAILURE ;
    }

    Unlock_ () ;

    return retval ;
}

DWORD
CUHTTPFragment::GetTransmitSize (
    IN  DWORD   FileSize,
    OUT DWORD * TransmitSize
    )
/*++
    
    Routine Description:

        works only with default values; returns a rough estimate i.e. actual
        may be a bit faster because we don't compute for padding datagrams,
        etc...

    Parameters:

    Return Values:

--*/
{
    DWORD   DatagramCount ;
    DWORD   Col, Row ;

    assert (TransmitSize) ;
    assert (FileSize > 0) ;

    DatagramCount = DivRoundUp (FileSize, (DWORD) (DEF_DATAGRAM_SIZE - sizeof UHTTP_HEADER)) ;

    Col = (DWORD) sqrt (DatagramCount) ;
    SetInBounds (Col, (DWORD) DEF_MIN_XOR_BLOCK_SIZE - 1, (DWORD) DEF_MAX_XOR_BLOCK_SIZE - 1) ;

    Row = DivRoundUp (DatagramCount, Col) ;

    DatagramCount = Row * Col + Row ;

    * TransmitSize = DatagramCount * DEF_DATAGRAM_SIZE ;

    return NO_ERROR ;
}

#ifdef SUPPORT_UHTTP_EXT  // a-clardi

HRESULT
CUHTTPFragment::SetExtensionHeader(
				IN USHORT usLength,
				IN LPBYTE pbData)
{
	m_fExtensionExists = TRUE;

	if (pbData)
	{
		m_pbExtensionData = new BYTE[usLength];
		if (m_pbExtensionData)
		{
			memcpy(m_pbExtensionData, pbData, usLength);
			m_nExtensionHeaderSize = usLength;
		}
	}

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\zutil.h ===
/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-1996 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* $Id: zutil.h,v 1.16 1996/07/24 13:41:13 me Exp $ */

#ifndef _Z_UTIL_H
#define _Z_UTIL_H

#include "zlib.h"

#if defined(MSDOS)||defined(VMS)||defined(CRAY)||defined(WIN32)||defined(RISCOS)
#   include <stddef.h>
#   include <errno.h>
#else
    extern int errno;
#endif
#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = (char*)ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#ifdef MSDOS
#  define OS_CODE  0x00
#  ifdef __TURBOC__
#    include <alloc.h>
#  else /* MSC or DJGPP */
#    include <malloc.h>
#  endif
#endif

#ifdef OS2
#  define OS_CODE  0x06
#endif

#ifdef WIN32 /* Window 95 & Windows NT */
#  define OS_CODE  0x0b
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define FOPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#ifdef AMIGA
#  define OS_CODE  0x01
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif

#ifdef MACOS
#  define OS_CODE  0x07
#endif

#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0F
#endif

#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

        /* Common defaults */

#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef FOPEN
#  define FOPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#ifdef HAVE_STRERROR
   extern char *strerror OF((int));
#  define zstrerror(errnum) strerror(errnum)
#else
#  define zstrerror(errnum) ""
#endif

#if defined(pyr)
#  define NO_MEMCPY
#endif
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(_MSC_VER)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   extern void zmemcpy  OF((Bytef* dest, Bytef* source, uInt len));
   extern int  zmemcmp  OF((Bytef* s1,   Bytef* s2, uInt len));
   extern void zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef DEBUG
#  include <stdio.h>
#  ifndef verbose
#    define verbose 0
#  endif
   extern void z_error    OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) fprintf x
#  define Tracev(x) {if (verbose) fprintf x ;}
#  define Tracevv(x) {if (verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif


typedef uLong (*check_func) OF((uLong check, const Bytef *buf, uInt len));

voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
void   zcfree  OF((voidpf opaque, voidpf ptr));

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

#endif /* _Z_UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\address.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// Address.cpp : Implementation of Address and Data creator and parser

#include "stdafx.h"

#include <atlbase.h>
#include <stdio.h>

#include "address.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Macros
#include "tstmacro.h"

/////////////////////////////////////////////////////////////////////////////
// Checksum code
// //////////////////////////////////////////////////////////////////////////
#define LITTLE_ENDIAN

static unsigned long
lcsum(unsigned short *buf, unsigned long nbytes) 
{
    unsigned long    sum;
    unsigned long     nwords;

    nwords = nbytes >> 1;
    sum = 0;
    while (nwords-- > 0)
		sum += *buf++;
#ifdef LITTLE_ENDIAN
    if (nbytes & 1)
		sum += *((unsigned char*)buf);
#else
    if (nbytes & 1)
		sum += *buf & 0xff00;
#endif
    return sum;
}

static unsigned short
eac(unsigned long sum)
{
    unsigned short csum;

    while((csum = ((unsigned short) (sum >> 16))) !=0 )
		sum = csum + (sum & 0xffff);
    return (unsigned short)(sum & 0xffff);
}

static unsigned short
cksum(unsigned short *buf, unsigned long nbytes) 
{
    unsigned short result = ~eac(lcsum(buf, nbytes));
    return result;
}

unsigned short
checksum(unsigned short *buf, unsigned long len) 
{
    unsigned short result = eac(lcsum(buf, len));
    return result;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Data Field
CComBSTR 
CreateData (TCHAR* pcNetCard,
			TCHAR* pcAddress,
			short sPort,
			TCHAR* pcConnectionData)
{
    USES_CONVERSION;

    CComBSTR bstrData;
//    TCHAR pcNumber[16];
    TCHAR pcPort[5];
    _stprintf(pcPort, _T("%hd"), sPort);

    if ((NULL == pcNetCard) ||
		(0 == sPort))
		return bstrData;

    bstrData = pcNetCard;
    bstrData.Append(" ");
    if (NULL != pcAddress)
		bstrData.Append(pcAddress);
    bstrData.Append(":");
    bstrData.Append(pcPort);
    if (NULL != pcConnectionData)
    {
		bstrData.Append(" ");
		bstrData.Append(pcConnectionData);
    }

    return bstrData;
}

BOOL 
ParseData (CComBSTR bstrData,
		TCHAR** ppcNetCard,
		TCHAR** ppcAddress,
		short* psPort,
		TCHAR** ppcConnectionData)
{
    try{

        USES_CONVERSION;

        if ((FALSE == TEST_OUT_PTR(ppcNetCard, TCHAR*))	||
            (FALSE == TEST_OUT_PTR(ppcAddress, TCHAR*))	||
            (FALSE == TEST_OUT_PTR(psPort, short)) ||
            (FALSE == TEST_OUT_PTR(ppcConnectionData, TCHAR*)))
        {
            _ASSERTE(TEST_OUT_PTR(ppcNetCard, TCHAR*));
            _ASSERTE(TEST_OUT_PTR(ppcAddress, TCHAR*));
            _ASSERTE(TEST_OUT_PTR(psPort, short));
            _ASSERTE(TEST_OUT_PTR(ppcConnectionData, TCHAR*));
            return FALSE;
        }

        *ppcNetCard	= NULL;
        *ppcAddress	= NULL;
        *psPort	= 0;
        *ppcConnectionData = NULL;

        // Data	format <NETCARD> [<ADDRESS>]:<PORT>[ <CONNECTION DATA>]

        int	iLen = wcslen(bstrData);

        TCHAR* pcNetCard = (TCHAR*)	_alloca(iLen * sizeof(TCHAR));
        TCHAR* pcAddress = (TCHAR*)	_alloca(iLen * sizeof(TCHAR));
        short sPort;
        TCHAR* pcConnectionData	= (TCHAR*) _alloca(iLen	* sizeof(TCHAR));
        *pcConnectionData =	0;

        if (3 <= _stscanf(W2T(bstrData), _T("%[0-9.] %[0-9.]:%hu %[^\0]"),
            pcNetCard, 
            pcAddress,
            &sPort,
            pcConnectionData))
        {
            *ppcNetCard	= _tcsdup(pcNetCard);
            *ppcAddress	= _tcsdup(pcAddress);
            *psPort	= sPort;
            if (0 != *pcConnectionData)
                *ppcConnectionData = _tcsdup(pcConnectionData);

            return TRUE;
        }

        if (3 == _stscanf(W2T(bstrData), _T("%[0-9.] :%hu %[^\0]"),
            pcNetCard,
            &sPort,
            pcConnectionData))
        {
            *ppcNetCard	= _tcsdup(pcNetCard);
            *psPort	= sPort;
            *ppcConnectionData = _tcsdup(pcConnectionData);

            return TRUE;
        }

        if (2 == _stscanf(W2T(bstrData), _T("%[0-9.] :%hu"),
            pcNetCard,
            &sPort))
        {
            *ppcNetCard	= _tcsdup(pcNetCard);
            *psPort	= sPort;

            return TRUE;
        }

        return FALSE;
    }
    catch(...){
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
// Address Field
CComBSTR 
CreateAddress (TCHAR* pcID,
			TCHAR* pcTransportProtocol,
			BSTR bstrData)
{
    USES_CONVERSION;

    _ASSERTE(NULL != pcTransportProtocol);
    _ASSERTE(NULL != bstrData);

    CComBSTR bstrReturn = pcTransportProtocol;
    bstrReturn.Append("(");
    bstrReturn.AppendBSTR(bstrData);
    bstrReturn.Append(")");

    if (NULL != pcID)
    {
        bstrReturn.Append("; ");
        bstrReturn.Append(pcID);
    }

    return bstrReturn;
}

BOOL ParseAddress (CComBSTR bstrData,
                   TCHAR** ppcID,
                   TCHAR** ppcTransportProtocol,
                   TCHAR** ppcData)
{
    try{
        USES_CONVERSION;

        if ((FALSE == TEST_OUT_PTR(ppcID, TCHAR*)) ||
            (FALSE == TEST_OUT_PTR(ppcTransportProtocol, TCHAR*)) ||
            (FALSE == TEST_OUT_PTR(ppcData, TCHAR*)))
        {
            _ASSERTE(TEST_OUT_PTR(ppcID, TCHAR*));
            _ASSERTE(TEST_OUT_PTR(ppcTransportProtocol, TCHAR*));
            _ASSERTE(TEST_OUT_PTR(ppcData, TCHAR*));
            return FALSE;
        }

        *ppcID = NULL;
        *ppcTransportProtocol = NULL;
        *ppcData = NULL;

        int iLen = wcslen(bstrData);

        TCHAR* pcID = (TCHAR*) _alloca(iLen * sizeof(TCHAR));
        TCHAR* pcTransport = (TCHAR*) _alloca(iLen * sizeof(TCHAR));
        TCHAR* pcData = (TCHAR*) _alloca(iLen * sizeof(TCHAR));

        int iParse = _stscanf(W2T(bstrData),
            _T("%[^(](%[^)]); %[^\0]"),
            pcTransport,
            pcData,
            pcID);
        if (3 == iParse)
        {
            *ppcID = _tcsdup(pcID);
            *ppcTransportProtocol = _tcsdup(pcTransport);
            *ppcData = _tcsdup(pcData);
            return TRUE;
        }

        if (2 == iParse)
        {
            *ppcTransportProtocol = _tcsdup(pcTransport);
            *ppcData = _tcsdup(pcData);
            return TRUE;
        }

        if (1 == iParse)
        {
            *ppcTransportProtocol = _tcsdup(pcTransport);
            return TRUE;
        }

        return FALSE;
    }
    catch(...){
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CHKSUM Field

		// Computes checksum of input string, returing it in 4 character hex string

CComBSTR ChkSumA(char * pcAData)
{
    USES_CONVERSION;

    ULONG ulSum = lcsum((unsigned short*) pcAData, strlen(pcAData));

    USHORT usChkSum = ~eac(ulSum);
    short sLow = LOBYTE(usChkSum);
    short sHigh = HIBYTE(usChkSum);
    DWORD dwCalcSum = MAKEWORD(sHigh, sLow);

    TCHAR pcChkSum[7];
    _stprintf(pcChkSum, 
	    _T("%04X"),
	    dwCalcSum);

    CComBSTR bstrChkSum = pcChkSum;
    return bstrChkSum;
}

CComBSTR ChkSum(TCHAR* pcData)
{
    try{
    USES_CONVERSION;

    ULONG ulSum = lcsum((unsigned short*) T2A(pcData), _tcslen(pcData));

    USHORT usChkSum = ~eac(ulSum);
    short sLow = LOBYTE(usChkSum);
    short sHigh = HIBYTE(usChkSum);
    DWORD dwCalcSum = MAKEWORD(sHigh, sLow);

    TCHAR pcChkSum[7];
    _stprintf(pcChkSum, 
	    _T("%04X"),
	    dwCalcSum);

    CComBSTR bstrChkSum = pcChkSum;
    return bstrChkSum;
    }catch(...){
        return CComBSTR(NULL);
    }
}

CComBSTR CreateAndAppendChkSum(BSTR bstrData)
{
    USES_CONVERSION;

    CComBSTR bstrRet = bstrData;
    bstrRet.Append("[");
    bstrRet.AppendBSTR(ChkSum(W2T(bstrData)));
    bstrRet.Append("]");

    return bstrRet;
}

// ------------------------------------------------------------------------
// DiscoverValidateAndRemoveChkSum
//		This looks for trailing [] block of data that doesn't contain a ':'.
//		  this is checksum.
//		This then compares that value to checksum computed from data before it.
//		If they are equal, returns true - else false, and sets but also sets *pfHasChecksum to true.
//		If checksum didn't exist, the returns false, but also sets *pfHasChecksum to false.
// 
//		This modifies the input string to remove the checksum
//
//		Ff checksum is 'XXXX', then always treated as valid
// -------------------------------------------------------------------------
BOOL 
DiscoverValidateAndRemoveChkSum(TCHAR* pcData, BOOL *pfHasChecksum, BSTR *pBstrChksum)
{
    USES_CONVERSION;
	
		// Trigger of form <URL>[attir:value][attr:value][chksum]
		//   where chksum is optional

				// locate trailing '[' of last [] block
	TCHAR* pcStartChkSum = _tcsrchr(pcData, '[');
	
				// if trailing block contains a ':', then its not a checksum
	if((NULL != pcStartChkSum) && NULL != _tcschr(pcStartChkSum,':'))
	{
		*pfHasChecksum = false;
		if(pBstrChksum)	*pBstrChksum = ChkSum(pcData);
		return false;
	}

	if (NULL == pcStartChkSum) {		// pretty bogus case if you ask me (no '[' anywhere)
		*pfHasChecksum = false;
		if(pBstrChksum)	*pBstrChksum = ChkSum(pcData);
		return false;
	}
	
	*pfHasChecksum = true;
    *pcStartChkSum = NULL;					// kill tailing part of string containing checksum
    pcStartChkSum++;


    CComBSTR bstrChkSum = ChkSum(pcData);	// do checksum of data
	if(pBstrChksum)
		*pBstrChksum = bstrChkSum;			// return correct checksum if asked for it

	TCHAR* pcEndChkSum = _tcsrchr(pcStartChkSum, ']');	// terminate the checksum field
	if(pcEndChkSum) *pcEndChkSum=NULL;

//#ifdef _DEBUG
	if(0 == _tcsicmp(pcStartChkSum,_T("XXXX"))) return TRUE;			// magic 'XXXX' debug test
//#endif


    return (0 == _tcsicmp(W2T(bstrChkSum), pcStartChkSum));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\enhfile.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef STRICT
#define STRICT 1
#endif

#include <windows.h>

#include <io.h>
#include <errno.h>
#include <tchar.h>

#include "enhfile.h"

/////////////////////////////////////////////////////////////////////////////
// CComFileLow
CComFileLow::CComFileLow()
{
    m_hFile = -1;
}

CComFileLow::CComFileLow(const TCHAR* pcFileName, int iFlags, int iMode)
{
    m_hFile = _topen(pcFileName, iFlags, iMode);
}

CComFileLow::~CComFileLow()
{
    close();
}

////////////////////////
// File Handling methods
int CComFileLow::open(const TCHAR* pcFileName, int iFlags, int iMode)
{
    close();
    return m_hFile = _topen(pcFileName, iFlags, iMode);
}

int CComFileLow::close()
{
    int iRet = 0;

    if (-1 != m_hFile)
    {
	iRet = _close(m_hFile);
	m_hFile = -1;
    }

    return iRet;
}

int CComFileLow::read(void* pvBuffer, unsigned int uiBytes)
{
    if (-1 == m_hFile)
    {
	SetLastError(EBADF);
	return -1;
    }

    return _read(m_hFile, pvBuffer, uiBytes);
}

long CComFileLow::filelength()
{
    if (-1 == m_hFile)
    {
	SetLastError(EBADF);
	return -1;
    }

    return _filelength(m_hFile);
}

//////////////////////////////////////
// Methods to make it work like an int
BOOL CComFileLow::operator==(int i)
{
    return (m_hFile == i);
}

CComFileLow::operator int()
{
    return m_hFile;
}

int CComFileLow::operator=(int i)
{
    if (-1 != m_hFile)
    {
	close();
    }

    // BUG: Assure that the int passed in is really a file handle...
    return (m_hFile = i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\chksum.c ===
/* Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved. */
// --------------------------
// chksum.c
// 
//   this C file actually included into address.cpp ... WIERD!
// ---------------------------------------------------------


static unsigned long
lcsum(unsigned short *buf, unsigned long nbytes) 
{
    unsigned long    sum;
    unsigned long     nwords;

    nwords = nbytes >> 1;
    sum = 0;
    while (nwords-- > 0)
	sum += *buf++;
#ifdef LITTLE_ENDIAN
    if (nbytes & 1)
	sum += *((unsigned char*)buf);
#else
    if (nbytes & 1)
	sum += *buf & 0xff00;
#endif
    return sum;
}

static unsigned short
eac(unsigned long sum)
{
    unsigned short csum;

    while((csum = ((unsigned short) (sum >> 16))) !=0 )
		sum = csum + (sum & 0xffff);
    return (unsigned short)(sum & 0xffff);
}

static unsigned short
cksum(unsigned short *buf, unsigned long nbytes) 
{
    unsigned short result = ~eac(lcsum(buf, nbytes));
    return result;
}

unsigned short
checksum(unsigned short *buf, unsigned long len) 
{
    unsigned short result = eac(lcsum(buf, len));
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\address.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// address.h : Data creator and parser

CComBSTR CreateData (TCHAR* pcNetCard,
			TCHAR* pcAddress,
			short sPort,
			TCHAR* pcConnectionData = NULL);

BOOL ParseData (CComBSTR bstrData,
		TCHAR** ppcNetCard,
		TCHAR** ppcAddress,
		short* psPort,
		TCHAR** ppcConnectionData);

CComBSTR CreateAddress (TCHAR* pcID,
			TCHAR* pcTransportProtocol,
			BSTR bstrData);

BOOL ParseAddress (CComBSTR bstrData,
		    TCHAR** ppcID,
		    TCHAR** ppcTransportProtocol,
		    TCHAR** ppcData);

CComBSTR ChkSumA(char * pcAData);
CComBSTR ChkSum(TCHAR* pcData);

CComBSTR 
CreateAndAppendChkSum(BSTR bstrData);

			// returns TRUE if checksum of string is OK, also if it exists
BOOL 
DiscoverValidateAndRemoveChkSum(TCHAR* pcData, BOOL *pfHasChecksum, BSTR *pbstrChecksum=NULL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\atvefsend\zutil.c ===
/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-1996 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* $Id: zutil.c,v 1.17 1996/07/24 13:41:12 me Exp $ */

#include <stdio.h>

#include "zutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

struct internal_state      {int dummy;}; /* for buggy compilers */

#ifndef STDC
extern void exit OF((int));
#endif

const char *z_errmsg[10] = {
"need dictionary",     /* Z_NEED_DICT       2  */
"stream end",          /* Z_STREAM_END      1  */
"",                    /* Z_OK              0  */
"file error",          /* Z_ERRNO         (-1) */
"stream error",        /* Z_STREAM_ERROR  (-2) */
"data error",          /* Z_DATA_ERROR    (-3) */
"insufficient memory", /* Z_MEM_ERROR     (-4) */
"buffer error",        /* Z_BUF_ERROR     (-5) */
"incompatible version",/* Z_VERSION_ERROR (-6) */
""};


const char *zlibVersion()
{
    return ZLIB_VERSION;
}

#ifdef DEBUG
void z_error (m)
    char *m;
{
    fprintf(stderr, "%s\n", m);
    exit(1);
}
#endif

#ifndef HAVE_MEMCPY

void zmemcpy(dest, source, len)
    Bytef* dest;
    Bytef* source;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = *source++; /* ??? to be unrolled */
    } while (--len != 0);
}

int zmemcmp(s1, s2, len)
    Bytef* s1;
    Bytef* s2;
    uInt  len;
{
    uInt j;

    for (j = 0; j < len; j++) {
        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
    }
    return 0;
}

void zmemzero(dest, len)
    Bytef* dest;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = 0;  /* ??? to be unrolled */
    } while (--len != 0);
}
#endif

#ifdef __TURBOC__
#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)
/* Small and medium model in Turbo C are for now limited to near allocation
 * with reduced MAX_WBITS and MAX_MEM_LEVEL
 */
#  define MY_ZCALLOC

/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */

#define MAX_PTR 10
/* 10*64K = 640K */

local int next_ptr = 0;

typedef struct ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    voidpf buf = opaque; /* just to make some compilers happy */
    ulg bsize = (ulg)items*size;

    /* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */
    if (bsize < 65520L) {
        buf = farmalloc(bsize);
        if (*(ush*)&buf != 0) return buf;
    } else {
        buf = farmalloc(bsize + 16L);
    }
    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
    table[next_ptr].org_ptr = buf;

    /* Normalize the pointer to seg:0 */
    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
    *(ush*)&buf = 0;
    table[next_ptr++].new_ptr = buf;
    return buf;
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    int n;
    if (*(ush*)&ptr != 0) { /* object < 64K */
        farfree(ptr);
        return;
    }
    /* Find the original pointer */
    for (n = 0; n < next_ptr; n++) {
        if (ptr != table[n].new_ptr) continue;

        farfree(table[n].org_ptr);
        while (++n < next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        return;
    }
    ptr = opaque; /* just to make some compilers happy */
    Assert(0, "zcfree: ptr not found");
}
#endif
#endif /* __TURBOC__ */


#if defined(M_I86) && !defined(__32BIT__)
/* Microsoft C in 16-bit mode */

#  define MY_ZCALLOC

#if (!defined(_MSC_VER) || (_MSC_VER < 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    return _halloc((long)items, size);
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    _hfree(ptr);
}

#endif /* MSC */


#ifndef MY_ZCALLOC /* Any system without a special alloc function */

#ifndef STDC
extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));
#endif

voidpf zcalloc (opaque, items, size)
    voidpf opaque;
    unsigned items;
    unsigned size;
{
    if (opaque) items += size - size; /* make compiler happy */
    return (voidpf)calloc(items, size);
}

void  zcfree (opaque, ptr)
    voidpf opaque;
    voidpf ptr;
{
    free(ptr);
    if (opaque) return; /* make compiler happy */
}

#endif /* MY_ZCALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\enhurl.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// EnhURL.h : Implementation of URL routines
int ReplaceCharacter(TCHAR* pcReplace);
CComBSTR ReplaceEscapeSequences(CComBSTR bstrURL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\enhws.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// WSUtil Functions
#ifndef __WSUTIL_H_
#define __WSUTIL_H_

extern BOOL IsValidIPAddress(TCHAR* strAddress);
extern BOOL IsUnicast(TCHAR* strAddress);

#endif // __WSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\enhflags.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// EnhFlags.h

#define ENH_FUTURE	0x1
#define ENH_AUTOUPDATE	0x2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\enhurl.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// EnhURL.cpp : Implementation of URL routines
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

/*#ifndef STRICT
#define STRICT 1
#endif*/

#include "stdafx.h"

//#include <windows.h>
#include <stdio.h>
#include <atlbase.h>

#include "EnhURL.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ---------------------------------------------------------


/////////////////////////////////////////////////////////////////////////////
// URL escape sequence routines
int ReplaceCharacter(TCHAR* pcReplace)
{
    TCHAR pcVal[3];

    pcReplace++;
    if ((NULL != *pcReplace) && (NULL != _tcschr(_T("0123456789ABCDEFabcdef"), *pcReplace)))
    {
		pcVal[0] = *pcReplace;
		pcReplace++; 
		if ((NULL != *pcReplace) && (NULL != _tcschr(_T("0123456789ABCDEFabcdef"), *pcReplace)))
		{
			pcVal[1] = *pcReplace;
			pcVal[2] = NULL;

			TCHAR usChar;
			_stscanf(pcVal, _T("%x"), &usChar);

			*pcReplace = usChar;

			pcVal[0] = usChar;
			pcVal[1] = usChar;

			return (int) usChar;
		}
    }

    return 0;
}

CComBSTR ReplaceEscapeSequences(CComBSTR bstrURL)
{
    USES_CONVERSION;

    WCHAR* pcURL = bstrURL.m_str;
    if (NULL == pcURL)
		return bstrURL;

    TCHAR* pcSearch = pcURL;
    TCHAR* pcCurrent = pcURL;
    while (NULL != *pcSearch)
    {
		if (_T('%') == *pcSearch)
		{
			if (NULL != ReplaceCharacter(pcSearch))
			{
				pcSearch += 2;
			}
		}
		
		*pcCurrent = *pcSearch;
		pcSearch++;
		pcCurrent++;
	}
    *pcCurrent = NULL;

    return CComBSTR(pcURL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\enhfile.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __FILES_H_
#define __FILES_H_

/////////////////////////////////////////////////////////////////////////////
// CComFileLow
class CComFileLow
{
private:
    int m_hFile;

public:
    CComFileLow();
    CComFileLow(const TCHAR* pcFileName, int iFlags, int iMode = 0);
    ~CComFileLow();

    // File Handling methods
    int open(const TCHAR* pcFileName, int iFlags, int iMode = 0);
    int close();

    int read(void* pvBuffer, UINT uiBytes);

    long filelength();

    // Methods to make it work like an file handle
    BOOL operator==(int i);
    operator int();
    int operator=(int i);
};

#endif // __FILES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\fileutil.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef STRICT
#define STRICT 1
#endif


#include <windows.h>
#include <tchar.h>

#include <malloc.h>
#include <crtdbg.h>
#include <stdio.h>
#include <errno.h>
#include <direct.h>

#include "fileutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ---------------------------------------------------------

TCHAR* FixPath(TCHAR* strPath)
{
    // This Function replaces all / characters with \ characters

    if (NULL == strPath)
    {
	return strPath;
    }

    TCHAR* pcSlash = _tcschr(strPath, '/');
    while (NULL != pcSlash)
    {
	*pcSlash = '\\';
	pcSlash = _tcschr(pcSlash, '/');
    }

    return strPath;
}

BOOL CreatePath(TCHAR* pcPath)
{
    if (NULL == pcPath)
    {
	_ASSERTE(NULL != pcPath);
	return FALSE;
    }

    if (-1 == _tmkdir(pcPath))
    {
		DWORD err = GetLastError(); 
		if (ERROR_PATH_NOT_FOUND == err ||			// create subpath ...
			ERROR_FILE_NOT_FOUND == err)
		{
			TCHAR* pcLastSlash = _tcsrchr(pcPath, '\\');
			if (NULL == pcLastSlash)
			{
				_ASSERTE(NULL != pcLastSlash);
				return FALSE;
			}

			*pcLastSlash = 0;
			BOOL bRet = CreatePath(pcPath);
			*pcLastSlash = '\\';

			if ((FALSE == bRet) || (-1 == _tmkdir(pcPath)))
				return FALSE;
		}
	// PATH EXISTS
    }

    return TRUE;
}

void DelTreeOne(LPWIN32_FIND_DATA lpFindFileData, TCHAR* pcBase)
{
    try{
        if ((0 == _tcscmp(lpFindFileData->cFileName, _T("."))) ||
            (0 == _tcscmp(lpFindFileData->cFileName, _T(".."))))
        {
            // Ignore . and ..
            return;
        }

        TCHAR* pcFullName = NULL;
        pcFullName = (TCHAR*) _alloca((_tcslen(pcBase) + _tcslen(lpFindFileData->cFileName) + 2) * sizeof(TCHAR));
        _stprintf(pcFullName, _T("%s\\%s"), pcBase, lpFindFileData->cFileName);
        if (FILE_ATTRIBUTE_DIRECTORY & lpFindFileData->dwFileAttributes)
        {
            // File is a directory
            DelTree(pcFullName);
        }
        else
        {
            _tremove(pcFullName);
        }
    }
    catch(...){
        return;
    }
}

void DelTree(TCHAR* pcTree)
{
    try{
        int iPathLen = _tcslen(pcTree);

        TCHAR* pcFileList = NULL;
        pcFileList = (TCHAR*) _alloca((iPathLen + 4) * sizeof(TCHAR));
        if (NULL == pcFileList)
        {
            return;
        }
        _stprintf(pcFileList, _T("%s\\*.*"), pcTree);

        if (MAX_PATH < _tcslen(pcFileList))
        {
            return;
        }

        WIN32_FIND_DATA FileData;
        HANDLE hFileList = FindFirstFile(pcFileList, &FileData);
        if (INVALID_HANDLE_VALUE != hFileList)
        {
            DelTreeOne(&FileData, pcTree);

            while (TRUE == FindNextFile(hFileList, &FileData))
            {
                DelTreeOne(&FileData, pcTree);
            }

            FindClose(hFileList);
        }

        _trmdir(pcTree);
    }
    catch(...){
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\isotime.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// ----------------------------------------------------------------------
//  isotime.cpp
//
//		Convert ISO-8601 standard time to DATE format, except that it is assumed to
//		be UTC (Z) unless the time zone is specified.
//		
//                            012345678901234             
//
//		This will return 0 if error in parsing
//
//
//		In this system, 'DATES' are passed out of interfaces in local time zone
//		(not in UTC 'Z' time).
//		
//
//		see http://www.cl.cam.ac.uk/~mgkt25/iso-time.html		// overview
//			http://wwww.iso.ch.markete/8601.pdf					// full spec
//
//
//	Remarks:
//		J.B  08/28/2000
// -------------------------------------------------------------------------
//

#include "stdafx.h"
//#include <atlbase.h>
#include <time.h>
#include <stdio.h>
#include <math.h>

#include "isotime.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

				// converts a time_t format time into a variant time 
DATE 
VariantTimeFromTime(time_t theTime)
{
				// yecko - this is really nasty code - should be a way to make it nicer..
				//   (CTime or COleDateTime would make this easy, but they are in MFC).
		// m_cSecExpires is UNIX-style time and display as number and string. */
		//    Time in seconds since UTC 1/1/70 (or 
		SYSTEMTIME stimeNow;			// big structure
		time_t cSecNow;					// time now...
		GetSystemTime(&stimeNow);
		time(&cSecNow);

		DATE dateNow;					// 8-byte real value (double), days from January 1, 1753 and December 31, 2078, inclusive. 
		SystemTimeToVariantTime(&stimeNow, &dateNow);
		int cSecTheTimeFromNow;
		if(theTime > cSecNow)
			cSecTheTimeFromNow = (int) (theTime - cSecNow);
		else 
			cSecTheTimeFromNow = -((int) (cSecNow - theTime));

		DATE dateTheTime = dateNow + cSecTheTimeFromNow / (24.0 * 60 * 60);
		return dateTheTime;
}


							// local routine that tries to find out
							// local offset from UTC.   (needed 'cause _daylite, _tm don't work in dynamic dll's) 
							//   BUG - because caches value, will be an hour off on nights timezone changes
							//         on the other hand, only used in debug print code, so who really cares?

static DATE DateLocalToGM()
{
	const DATE kBadValue = -7734;			// a very unlikely value
	static DATE gDateLocalToGM = kBadValue;
	static DATE gDateLocalToGM2 = kBadValue;

	if(gDateLocalToGM == kBadValue)		// just do calc's once and never change afterwards
	{
	
				// Set time zone from TZ environment variable. If TZ is not set,
				// the operating system is queried to obtain the default value 
				// for the _daylight and _timezone. 
		_tzset();

		time_t lNow, lNowGM, lNowLocal;

		time(&lNow);				// start with any random time (like now)
		struct tm *tmNow;

		tmNow = gmtime(&lNow);		// get value in GMT
		lNowGM = mktime(tmNow);		// convert back to long values... (secs)

		tmNow = localtime(&lNow);	// get value in local timezone
		lNowLocal = mktime(tmNow);

		long lSecsGMToLocal = (long) (lNowGM - lNowLocal);	// find difference
		gDateLocalToGM = lSecsGMToLocal / (60.0 * 60.0 * 24.0);

		TIME_ZONE_INFORMATION timeZoneInfo;
		DWORD dwTz = GetTimeZoneInformation(&timeZoneInfo);
		long bias = timeZoneInfo.Bias;
		if(TIME_ZONE_ID_STANDARD == dwTz) {
			bias += timeZoneInfo.StandardBias;
		} else if(TIME_ZONE_ID_DAYLIGHT == dwTz) {
			bias += timeZoneInfo.DaylightBias;
		}

				// UTC = local + bias
		gDateLocalToGM2 = bias / (60.0  * 24.0);			// bias time is in minutes...
		_ASSERT(gDateLocalToGM2 == gDateLocalToGM);

	}
	return gDateLocalToGM;				// returns positive values such as 7/24 for seattle summer...
}


// ---------------------------------------------------------------------------
//	SystemTimeToLocalVariantTime()
//	LocalVariantTimeToSystemTime()
//	
//		These routines return variant times (DATES) in local time zone units
//		adjusted for daylight savings time.
//
//		Avoid using these - try to adopt convention that Variant times are
//		  in UTC.  VB probably screws this up...
// ---------------------------------------------------------------------------



HRESULT 
SystemTimeToLocalVariantTime(const SYSTEMTIME *psysTime, DATE *pDate)
{
		
		HRESULT hr = SystemTimeToVariantTime(const_cast<SYSTEMTIME*>(psysTime), pDate);
		if(FAILED(hr)) return hr;		// note - it seems to be returning S_FALSE for OK times
				//   
//		*pDate -= DateLocalToGM();
/*
		*pDate -= _timezone / (24.0 * 60 * 60);			// adjust for time zone
		if(_daylight)
			*pDate += 1.0 / (24.0);						// add 1 hour if in daylight savings time
*/
		return S_OK;
}

HRESULT 
LocalVariantTimeToSystemTime(DATE date, SYSTEMTIME *pSysTime)
{
		_tzset();
//		date += DateLocalToGM();

/*		date += _timezone / (24.0 * 60 * 60);			// adjust for time zone
		if(_daylight)
			date -= 1.0 / (24.0);						// add 1 hour if in daylight savings time
*/
		return VariantTimeToSystemTime(date, pSysTime);	// this is UTC time
}


// -------------------------------------------------------------
// LocalSystemTimeToVariantTime()
// VariantTimeToLocalSystemTime()
//
//  These assume variant time is in UTC, and System time is in LTZ (local time zone).
//
HRESULT 
LocalSystemTimeToVariantTime(const SYSTEMTIME *psysTime, DATE *pDate)
{
		
		HRESULT hr = SystemTimeToVariantTime(const_cast<SYSTEMTIME*>(psysTime), pDate);
		if(FAILED(hr)) return hr;		// note - it seems to be returning S_FALSE for OK times

				// Set time zone from TZ environment variable. If TZ is not set,
				// the operating system is queried to obtain the default value 
				// for the _daylight and _timezone. 
	
/*		_tzset();

		*pDate += _timezone / (24.0 * 60 * 60);			// adjust for time zone
		if(_daylight)
			*pDate -= 1.0 / (24.0);						// add 1 hour if in daylight savings time
*/

				// Here, variant time in UTC, Local system time in LTZ (local time zone).
				//  Converting from LTZ to UTC
				// 8 pm in england is 12 noon here in winter, 1 pm in summer.
				//   so in summer, need to add 7 hours ...
		*pDate += DateLocalToGM();
		return S_OK;
}

HRESULT 
VariantTimeToLocalSystemTime(DATE date, SYSTEMTIME *pSysTime)
{
		_tzset();

/*		date -= _timezone / (24.0 * 60 * 60);			// adjust for time zone
		if(_daylight)
			date += 1.0 / (24.0);	*/					// add 1 hour if in daylight savings time

						// 8 pm england back to noon or 1 pm here in.  So subtract 7 hours.

		date -= DateLocalToGM();	
		return VariantTimeToSystemTime(date, pSysTime);	// this is UTC time
}



// --------------------------------------------------
// ISOTimeZToDate
//		Converts ISO-8601 time to a DATE in local time zone.
//
//		It time zone is not passed in, the ISO times are assumed to be in 
//		UTC zero time zone (Z) if fZuluTimeZone is true, local time zone if false.
//		
//                            012345678901234   
//		Recommended ussage is yyyymmddThhmmssZzzzzz, where the captial letter "T" separates
//		the date from the time.  The time zone fields are optional. If missing the 
//		time zone is assumed to be in 'Z' time if fZuluTimeZone is true, else it's
//		assumed be be in local time zone.  
//		Z is either '+' or '-', and zzzzz is hh:mm, hhmm, or hh
//
//
//		If fZuluTimeZone is true
//			if did not enter a timezone offset	- assumes time is in Zulu coordiantes
//			if entered a timezone offset	- assumes time is in Zulu, offset by time zone
//		If fZuluTimeZone is false
//			If did not enter a timezone offset - assumes time in local timezone
//			if entered a timezone offset	   - assumes time in in Zulu, offset by the time zone
//
//		All 'dates' are returned in UTC time zone.
//
//
//	Possible Bug - problem with TimeZone
//	  I'm assuming that
//		19990901T110102-08:00		- is 11:01:02 local seattle time regardless of daylite savings time.
//									   Does the -8:00 change to -7:00 during the summer?
//
//		Returns a date of 0 if there is a parse error
// -----------------------------------------------------------------------

DATE
ISOTimeToDate(char *pcTime, BOOL fZuluTimeZone /*=false*/)
{ 
  // Get Received Time
 	DATE date = 0;						// 0 return value also indicates error

	SYSTEMTIME sysTime, sysTimeNow;
    GetSystemTime(&sysTimeNow);			// initialize with currrent time.

	BOOL fParseError = false;
	BOOL fEnteredTZ  = false;
					
	if(NULL == *pcTime) {				// parse the time
		fParseError = true;	
	} else {
		char strValue[5]; 
		int iValue;
		unsigned short usValue;

		// timezone parsing
		int itzSign = 1;
		int tzMinutes = 0;
		int cTZ = 0;
		char *pcTZ = strchr(pcTime,'+');
		if(!pcTZ) 
		{
			pcTZ = strchr(pcTime,'-'); 
			itzSign = -1;
		}
		if(pcTZ) {
			cTZ = *pcTZ;			// remember values so we can restore it...
			*pcTZ = NULL;
			pcTZ += 1;				// (bump up by one to skip '+/-')

			fEnteredTZ = true;

			int iLen = strlen(pcTZ);
			switch(iLen)
			{
			default:
				fParseError = true;
				break;
			case 2:		// 'hh' form
				if(1 != sscanf(pcTZ, "%d", &iValue))
					fParseError = true;
				else
					tzMinutes = iValue * 60 * itzSign;
				break;
			case 4:		// 'hhmm' form
				strValue[0] = pcTZ[0];
				strValue[1] = pcTZ[1];
				strValue[2] = 0;
				if(1 != sscanf(strValue, "%d", &iValue))
					fParseError = true;
				else {
					tzMinutes = iValue * 60;
					strValue[0] = pcTZ[2];
					strValue[1] = pcTZ[3];
					strValue[2] = 0;
					if(1 != sscanf(strValue, "%d", &iValue))
						fParseError = true;
					else {
						tzMinutes += iValue;
						tzMinutes *= itzSign;
					}
				}
				break;
			case 5:		// 'hh:mm' form
				strValue[0] = pcTZ[0];
				strValue[1] = pcTZ[1];
				strValue[2] = 0;
				if(1 != sscanf(strValue, "%d", &iValue) || pcTZ[2] != ':')
					fParseError = true;
				else {
					tzMinutes = iValue * 60;
					strValue[0] = pcTZ[3];
					strValue[1] = pcTZ[4];
					strValue[2] = 0;
					if(1 != sscanf(strValue, "%d", &iValue))
						fParseError = true;
					else {
						tzMinutes += iValue;
						tzMinutes *= itzSign;
					}
				}
				break;
			}
		}

		memset(&sysTime, 0, sizeof(SYSTEMTIME));		// initalize time to '00:00:00 hours/minutes/seconds ('beginning of current day)

		int iLen = strlen(pcTime);
		switch(iLen)
		{
		case 15:
			// Seconds
			strValue[0] = pcTime[13];
			strValue[1] = pcTime[14];
			strValue[2] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wSecond = usValue;
		case 13:
			// Minutes
			strValue[0] = pcTime[11];
			strValue[1] = pcTime[12];
			strValue[2] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wMinute = usValue;
		case 11:
			// Hours
			strValue[0] = pcTime[9];
			strValue[1] = pcTime[10];
			strValue[2] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wHour = usValue;

			if(pcTime[8] != 'T')			// object if not 'T' in the middle according to spec.
				fParseError = true;
	
		case 8:
			// Year
			strValue[0] = pcTime[0];
			strValue[1] = pcTime[1];
			strValue[2] = pcTime[2];
			strValue[3] = pcTime[3];
			strValue[4] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wYear = usValue;
			
			// Month
			strValue[0] = pcTime[4];
			strValue[1] = pcTime[5];
			strValue[2] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wMonth = usValue;

			// Day
			strValue[0] = pcTime[6];
			strValue[1] = pcTime[7];
			strValue[2] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wDay = usValue;
			break;

		default:
			fParseError = true;
		}

				// Set time zone from TZ environment variable. If TZ is not set,
				// the operating system is queried to obtain the default value 
				// for the variable. 
		_tzset();

		
		if(!fParseError) {
/*			if(fEnteredTZ) {
				SystemTimeToLocalVariantTime(&sysTime, &date);
				date -= tzMinutes / (60.0 * 24.0);
			} else {
				if(!fZuluTimeZone) 
					SystemTimeToVariantTime(&sysTime, &date);
				else {
					SystemTimeToLocalVariantTime(&sysTime, &date);
				}
			} 
			if(_daylight) date -= 1.0 / (24.0);			// is this right???
			*/

			if(fEnteredTZ) {
				SystemTimeToVariantTime(&sysTime, &date);
				date -= tzMinutes / (60.0 * 24.0);
			} else {
				if(fZuluTimeZone) 
					SystemTimeToVariantTime(&sysTime, &date);
				else {
					LocalSystemTimeToVariantTime(&sysTime, &date);		// 
				}
			}

		}
										// reset string if we mucked with it.
		if(pcTZ) pcTZ[-1] = (char) cTZ;
    }
	return date;
}

// -----------------------------------------------------------------------
//   converts date to a string in local time zone 
//		date must be in UTC.

CComBSTR 
DateToBSTR(DATE date)
{
	USES_CONVERSION;

	static WCHAR *RgDay[] = {L"Sun",L"Mon",L"Tue",L"Wed",L"Thu",L"Fri",L"Sat"};

    /* Set time zone from TZ environment variable. If TZ is not set,
     * the operating system is queried to obtain the default value 
     * for the variable. 
     */
    _tzset();

 
//	time_t aclock;
//	time( &aclock );					// current time
//	struct tm *nowTime = localtime( &aclock );
	
				// this whole sections is bad since ComOleDate doesn't work
	const int kMaxSize = 256;
	CComBSTR spBstr(kMaxSize);

	if(0.0 == date) 
	{
		swprintf(spBstr,L"<Not Set>");
	} else {
/*
		date -= _timezone / (24.0 * 60 * 60);			// adjust for time zone
		if(_daylight)
			date += 1.0 / (24.0);						// add 1 hour if in daylight savings time
*/
		SYSTEMTIME sysTime;
//		BOOL fOk = VariantTimeToSystemTime(date, &sysTime);				// this is UDC time
				// toDo - VariantTimeToLocalSystemTime actually returns a BOOL, but is marked as returning an HRESULT
		BOOL fOk = (BOOL) VariantTimeToLocalSystemTime(date, &sysTime);		// this is local time
//		if(FAILED(hr))
		if(fOk)
		{
			swprintf(spBstr,L"<Invalid>");
		} else {

			TIME_ZONE_INFORMATION timeZoneInfo;							// get timezone name
			DWORD dwTz = GetTimeZoneInformation(&timeZoneInfo);
			

			WCHAR *pwszZone = 0;
            CComBSTR spbsZoneUnknown="Unknown Time Zone";    //-> UTZ

			if(TIME_ZONE_ID_STANDARD == dwTz) {
				pwszZone = timeZoneInfo.StandardName;
			} else if(TIME_ZONE_ID_DAYLIGHT == dwTz) {
				pwszZone = timeZoneInfo.DaylightName;
            } else {
                pwszZone = timeZoneInfo.StandardName;
            }
            if(NULL == pwszZone)
            {
                pwszZone = spbsZoneUnknown.m_str;
            }

			WCHAR wszTZoneShort[16]; 

			if(wcslen(pwszZone) < 9) {									// if it's long, abbreviate it.
				wcscpy(wszTZoneShort, pwszZone);
			} else {
				WCHAR *ptz = wszTZoneShort; ptz++;
				wszTZoneShort[0] = *pwszZone;
				while(*(++pwszZone))				// abbreviate name name
				{
					if(*pwszZone == ' ') {
						*pwszZone++;
						if(*pwszZone) *ptz++ = *pwszZone;
					}
				}
				*ptz = NULL;
			}

			swprintf(spBstr,L"%s %02d/%02d/%d %02d:%02d:%02d %s %s (LTZ)",
				RgDay[sysTime.wDayOfWeek],
				sysTime.wMonth, sysTime.wDay, sysTime.wYear, 
				sysTime.wHour % 12, sysTime.wMinute, sysTime.wSecond,
				((sysTime.wHour/12)==0 ? L"AM":L"PM"), wszTZoneShort);
		}
	}
	return spBstr;
//	char *cs = time.Format(_T("%a %b %d %I:%m:%S %p"));
}

CComBSTR 
DateToDiffBSTR(DATE date)				// Date is in UTC (Variant Time), not local time
{
	const int kMaxSize = 256;
	CComBSTR spBstr(kMaxSize);

	if(0.0 == date) 
	{
		swprintf(spBstr,L"<Undefined>");
	} else {
		SYSTEMTIME SysTimeNow;
		GetSystemTime(&SysTimeNow);									// initialize with currrent time.
		DATE dateNow;
		SystemTimeToVariantTime(&SysTimeNow, &dateNow);

		SYSTEMTIME sysTime;
		BOOL fOk = VariantTimeToSystemTime(date, &sysTime);			// this is UTC time
		if(!fOk)
		{
			swprintf(spBstr,L"<Invalid>");
		} else {
			DATE dateDel = dateNow - date;
			WCHAR *pszDiff;
			if(dateDel < 0) {
				pszDiff = L"From Now";
				dateDel = -dateDel;
			} else
				pszDiff = L"Before Now";

			if(dateDel > 365/4.0)
				swprintf(spBstr,L"%6.2f Years %s",dateDel/365.25, pszDiff);
			else if(dateDel > 1.0)
				swprintf(spBstr,L"%5.1f Days %s",int(10*dateDel + 0.5)/10.0, pszDiff);
			else if (dateDel > 1.0 / 24)
				swprintf(spBstr,L"%5.1f Hours %s", int(10*dateDel * 24 + 0.5)/10.0, pszDiff);
			else if (dateDel > 1.0 / (24*60))
				swprintf(spBstr,L"%5.1f Minutes %s",int(10*dateDel * 24 * 60 + 0.5)/10.0, pszDiff);
			else if (dateDel > 2.0 / (24*60*60))
				swprintf(spBstr,L"%5.1f Seconds %s", int(dateDel * 24 * 60 * 60 + 0.5)/10.0, pszDiff);
			else
				swprintf(spBstr,L"Now");
		}	
	}

//	COleDateTimeSpan spanElapsed = timeThen - timeStart;
	return spBstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\enhws.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef STRICT
#define STRICT 1
#endif

#include <windows.h>
#include <winsock2.h>
#include <stdlib.h>
#include <atlbase.h>
#include <stdio.h>

#include "enhws.h"

/////////////////////////////////////////////////////////////////////////////
// WSUtil Functions
BOOL IsValidIPAddress(TCHAR* strAddress)
{
    USES_CONVERSION;
    try{
        return (INADDR_NONE != inet_addr(T2A(strAddress)));
    }
    catch(...){
        return FALSE;
    }
}

BOOL IsUnicast(TCHAR* strAddress)
{
    if ((NULL == strAddress) || (FALSE == IsValidIPAddress(strAddress)))
    {
	return FALSE;
    }

    short sValue;
    _stscanf(strAddress, _T("%hu."), &sValue);

    return (sValue <= 223);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\tstmacro.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/////////////////////////////////////////////////////////////////////////////
// Validation Macros
#define TEST_OUT_PTR(p,t) ((p != NULL) && (!IsBadWritePtr(p, sizeof(t))))
#define TEST_OUT_BUF(p,s) ((p != NULL) && (!IsBadWritePtr(p, s)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\strmacro.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/////////////////////////////////////////////////////////////////////////////
// String Macros
#define CLEAR_STR(str) if (NULL != str) \
			{\
			    free(str);\
			    str = NULL;\
			}

#define DUPLICATE_STR(dst, src) \
    dst = _tcsdup(src); \
    if (NULL == dst) \
    { \
        return E_OUTOFMEMORY; \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A7CFEDB5_0B5C_4d7a_A965_8D73886E4216__INCLUDED_)
#define AFX_STDAFX_H__A7CFEDB5_0B5C_4d7a_A965_8D73886E4216__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>  
//#include "MyAtlBase.h"

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <comdef.h>
#include "valid.h"

#include <assert.h>
#include "MGatesDefs.h"		// some of MGates macros...  try to remove if possible

WCHAR * GetTVEError(HRESULT hr, ...);			//  Extended Error Message Handler

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A7CFEDB5_0B5C_4d7a_A965_8D73886E4216__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\include\mgatesdefs.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//---------------------------------------------------------
//  MGatesDefs.h
//
//			Debug definitions - used to be in precomp.h
// --------------------------------------------------------

#ifndef __MGATESDEFS_H__
#define __MGATESDEFS_H__

#define ATVEFSEND_DESCRIPTION           L"ATVEF-compliant transmitter (v2)"

//  ethernet MTU - sizeof IP_header - sizeof UDP_header
//  1500         - 20               - 8                 = 1472
#define ETHERNET_MTU_UDP_PAYLOAD_SIZE             1472

//  these three required because MSBDNAPI does not always convert a WIN32 
//  error to an HRESULT before returning the error; we know that NO_ERROR ==
//  S_OK
#define FAILED_CODE_TO_HRESULT(hr)              (FAILED(hr) ? (hr) : ((hr) = HRESULT_FROM_WIN32(hr)))
#define FAILED_HR(hr)                           ((hr) != S_OK ? FAILED(FAILED_CODE_TO_HRESULT(hr)) : FALSE)
#define SUCCEEDED_HR(hr)                        (!FAILED_HR(hr))

#define DELETE_RESET(p)                         if (p) { delete (p) ; (p) = NULL ; }
#define RESET_SOCKET(s)                         if ((s) != INVALID_SOCKET) { closesocket (s) ; (s) = INVALID_SOCKET ; }
#define RELEASE_AND_CLEAR(p)                    if (p) { (p) -> Release () ; (p) = NULL ; }
#define GOTO_NE(val,comp,label)                 if (val != comp) goto label
#define GOTO_EQ(val,comp,label)                 if (val == comp) goto label
#define GOTO_EQ_SET(val,comp,label,hr,error)    if (val == comp) { hr = error; goto label ; }
#define FAILED_HR_GOTO(val,comp,label)          if (FAILED_HR(hr)) goto label
#define VALID_MULTICAST_IP(ip)                  (((ip) >> 24) >= 0xE0)
#define CLOSE_IF_OPEN(h)                        if ((h) != INVALID_HANDLE_VALUE) { CloseHandle(h);h = INVALID_HANDLE_VALUE;}
#define SETLASTERROR_GOTO_EQ(val,cmp,label)     if ((val) == (cmp)) { SetLastError (val); goto label ; }
#define SETLASTERROR_GOTO_NE(val,cmp,label)     if ((val) != (cmp)) { SetLastError (val); goto label ; }
#define IN_BOUNDS(v,min,max)                    ((min) <= (v) && (v) <= (max))

//#define LOCK_HELD(l)                            ((l).RecursionCount > 0)
#define LOCK_HELD(l)                            TRUE

#define IS_HRESULT(hr)                          ((hr) != S_OK ? FAILED(hr) : TRUE)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\isotime.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// isotime.h

#ifndef __ISOTIME_H__
#define __ISOTIME_H__

#include "wtypes.h"
#include "limits.h"
#include "time.h"

// converst a time_ type time into 
DATE VariantTimeFromTime(time_t theTime);

// converts system times to/from local time in date format  (AVOID USING - Assume Variant Times in UTC)
HRESULT SystemTimeToLocalVariantTime(const SYSTEMTIME *psysTime, DATE *pDate);
HRESULT LocalVariantTimeToSystemTime(DATE date, SYSTEMTIME *pSysTime);

// converts UTC Variant times to local (in current time zone) system times
HRESULT LocalSystemTimeToVariantTime(const SYSTEMTIME *psysTime, DATE *pDate);
HRESULT VariantTimeToLocalSystemTime(DATE date, SYSTEMTIME *pSysTime);

// converts ISO-8601 time to date, if fZuluTimeZone is false, assumes in local time
DATE ISOTimeToDate(char *pcTime, BOOL fZuluTimeZone=false);

// converts date to string, or to difference string from 'now'.
CComBSTR DateToBSTR(DATE date);
CComBSTR DateToDiffBSTR(DATE date);

// Offset in seconds from NTP time representation 
// to seconds since 1 Jan 1970 (UNIX Time)
typedef unsigned __int64 ULONG64;
const unsigned __int64   g_ul64NTPOffset = 2208988800UL;

inline DATE NtpToDate(ULONG64 Ntp)
{
	LONG64 NtpS = Ntp;
	NtpS +=  ((__int64) 25569 * 24 * 60 * 60) - g_ul64NTPOffset;			// COleDateTime(1970,1,1,0,0,0) - seconds since 1 Jan 1970 (UNIX Time)
											
	__int64 timeC = (__int64) NtpS;
	if(NtpS > ULONG_MAX) timeC = ULONG_MAX;
	if(NtpS < LONG_MIN)  timeC = LONG_MIN;

	DATE date = timeC / (24.0 * 60.0 * 60.0);		// days since 1 Jan 1970

//	date = date + 25569.000000000;					// COleDateTime(1970,1,1,0,0,0);

//	date = date + 365.25 * (1970 - 1900);			// days since 1 Jan 1900
//	date += 1.5;									// days since 30 December 1899
	return date;
}

inline ULONG64 DateToNtp(DATE date)
{
	date -= 25569.000000000;
	time_t time = (time_t) (0.5 + date * (24.0 * 60.0 * 60.0));
	
	ULONG64 Ntp = time;
	Ntp += g_ul64NTPOffset;
	return Ntp; 
}

#endif //#define __ISOTIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\include\dbgstuff.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/* DbgStuff.h
/* Defines global operator new to allocate from
/* client blocks
*/

#ifndef __DBGSTUFF_H__
#define __DBGSTUFF_H__
#include "crtdbg.h"

#ifdef _DEBUG
   #define DEBUG_NEW   new( _CLIENT_BLOCK, __FILE__, __LINE__)
#else
   #define DEBUG_NEW
#endif // _DEBUG

						// dumps a multi-line string to the output window...
#ifndef DEBUG
static inline void ATLTRACE_LONG(BSTR bstr) {}		
#else
static inline void ATLTRACE_LONG(BSTR bstr)			
{
	CComBSTR bstrCpy = bstr;
	WCHAR *wch = bstrCpy.m_str;
	while(NULL != *wch) {
		WCHAR *wch1 = wch;
		while(NULL != *wch1 && *wch1 != '\n') {
			wch1++;
		}
		if(*wch1 == '\n') *wch1 = 0;
		ATLTRACE("%S\n",wch);
		wch = wch1+1;
	}
}
#endif

#endif	// __DBGSTUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\tvedbg.cpp ===
// Copyright (c) 1999,2000  Microsoft Corporation.  All Rights Reserved.
//-------------------------------------------------------------
// TVEDbg.cpp : Status and error Logging
//
//  To use:
//		m_dwLogFlags		
//	    m_dwLogLevel
//	
//	Either call:
//		SetLogFlags(const TCHAR* pcLogFileName, DWORD dwLogFlags, dwLogLevel);
//		DBG_SET_LOGFLAGS(pcLogFileName, dwLogFlags1, dwLogFlags2, dwLogFlags3, dwLogFlags4, dwLogLevel);
//
//	where 
//		pcLogFileName	- is name of log file		("LogTve.log");
//		dwLogFlags[1-4]	- OR'd values in correct bank of CDebugLog  (TveDbg.h)
//		dwLogLevel		- controls printout level   (0 always off, 1 terse, 3 normal, 5 verbose, 8 very verbose)
//	 
//	Or call
//		CDebugLog(const TCHAR* pcLogRegLocation);
//		DBG_INIT(pcLogRegLocation)
//
//	where
//		pcLogFileName		- is the name of the log file
//		pcLogRegLocation	- is location to look up dwLogFlags/dwLogLevel (see above) in the registry.
//		Set registry value at:
//			 HKEY_LOCAL_MACHINE\SOFTWARE\Debug\MSTvE\(pcLogFileName)\key
//
//			DEF_REG_LOCATION = Interactive Content
//			key			     = 'Level' or 'Flags'
//
//		if Level key is 0, debugging always turned off
//--------------------------------------------------------------

#include "stdafx.h"
#include <stdio.h>

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef STRICT
#define STRICT 1
#endif

#include "TVEDbg.h"
#include "TVEReg.h"

/*
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
*/
// ----------------------------------------------------------
// ----------------------------------------------------------


//extern CComModule _Module;


// AfxIsValidAddress() returns TRUE if the passed parameter points
// to at least nBytes of accessible memory. If bReadWrite is TRUE,
// the memory must be writeable; if bReadWrite is FALSE, the memory
// may be const.
			// was AFXIsValidAddress, from ValidAdd.cpp in MFC source
BOOL TVEIsValidAddress(const void* lp, UINT nBytes,	BOOL bReadWrite /* = TRUE */)
{
	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

// AfxIsValidString() returns TRUE if the passed pointer
// references a string of at least the given length in characters.
// A length of -1 (the default parameter) means that the string
// buffer's minimum length isn't known, and the function will
// return TRUE no matter how long the string is. The memory
// used by the string can be read-only.

BOOL TVEIsValidString(LPCWSTR lpsz, int nLength /*= -1*/ )
{
	if (lpsz == NULL)
		return FALSE;
	return /*afxData.bWin95 ||*/ ::IsBadStringPtrW(lpsz, nLength) == 0;
}

// As above, but for ANSI strings.

BOOL TVEIsValidString(LPCSTR lpsz, int nLength/* = -1*/ )
{
	if (lpsz == NULL)
		return FALSE;
	return ::IsBadStringPtrA(lpsz, nLength) == 0;
}




/////////////////////////////////////////////////////////////////////////////
//
//	Initializes the logging system
//	
//	Uses keys in the registry location
//		HKEY_LOCAL_MACHINE\\SOFTWARE\\Debug\\MSTvE\\TvELog\\vvv
//	
//		vvv is Level or Flags
//
//		If not set, creates these with values of 0 {off, allow user override}
//		
//		In call to SetLogFlags,
//			Flags -  if registry value is 0, will override with value in SetLogFlags
//				     if registry value is not 0, use registry value instead of value in SetLogFlags
//		    Level -  if registry Level value is 0, will turn logging off
//					 if registry value is = 1, override with value in SetLogFlags
//					 if registry value > 1, use registry value instead of value in SetLogFlags
//						(2 = reasonably terse,  3,4 = medium, 5 = verbose, 8 = very verbose)  
//				
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Debug Logging
#if _TVEDEBUG_ACTIVE

void WINAPI
TVEDebugLogInfo1(
    DWORD dwFlags1,
    DWORD dwLevel,
    const TCHAR *pFormat,
    ...
    )
{
							// quick level and flag test before the sprintf
    if (g_Log.Level() < dwLevel || (0 == (dwFlags1 | g_Log.Flags1()) )) 
		return;

    TCHAR szInfo[1024];
	 
	 /* Format the variable length parameter list */


    va_list va;
    va_start(va, pFormat);

    wvsprintf(szInfo, pFormat, va);

	g_Log.Log1(dwFlags1, dwLevel, szInfo, S_OK);;

    va_end(va);
}

void WINAPI
TVEDebugLogInfo2(
    DWORD dwFlags2,
    DWORD dwLevel,
    const TCHAR *pFormat,
    ...
    )
{
							// quick level and flag test before the sprintf
    if (g_Log.Level() < dwLevel || (0 == (dwFlags2 | g_Log.Flags2()) )) 
		return;

    TCHAR szInfo[1024];
	 
	 /* Format the variable length parameter list */


    va_list va;
    va_start(va, pFormat);

    wvsprintf(szInfo, pFormat, va);

	g_Log.Log2(dwFlags2, dwLevel, szInfo, S_OK);;

    va_end(va);
}

void WINAPI
TVEDebugLogInfo3(
    DWORD dwFlags3,
    DWORD dwLevel,
    const TCHAR *pFormat,
    ...
    )
{
							// quick level and flag test before the sprintf
    if (g_Log.Level() < dwLevel || (0 == (dwFlags3 | g_Log.Flags3()) )) 
		return;

    TCHAR szInfo[1024];
	 
	 /* Format the variable length parameter list */


    va_list va;
    va_start(va, pFormat);

    wvsprintf(szInfo, pFormat, va);

	g_Log.Log3(dwFlags3, dwLevel, szInfo, S_OK);;

    va_end(va);
}

void WINAPI
TVEDebugLogInfo4(
    DWORD dwFlags4,
    DWORD dwLevel,
    const TCHAR *pFormat,
    ...
    )
{
							// quick level and flag test before the sprintf
    if (g_Log.Level() < dwLevel || (0 == (dwFlags4 | g_Log.Flags4()) )) 
		return;

    TCHAR szInfo[1024];
	 
	 /* Format the variable length parameter list */


    va_list va;
    va_start(va, pFormat);

    wvsprintf(szInfo, pFormat, va);

	g_Log.Log4(dwFlags4, dwLevel, szInfo, S_OK);;

    va_end(va);
}
// ------------------------------------------------------------

CDebugLog::CDebugLog(const TCHAR* pcLogRegLocation)
{
    USES_CONVERSION;

    m_fileLog = NULL;

    // Read LogFlags1 from Registry
    if (ERROR_SUCCESS != GetRegValue(DEF_DBG_BASE,			// key	--> "Software/Debug"
									 DEF_REG_LOCATION,		// key1 --> "MSTvTVE"
									 pcLogRegLocation,
									 DEF_REG_FLAGS1,
									 &m_dwLogFlags1))
    {
		m_dwLogFlags1 = 0;						// do nothing, or let SetLogFlags1 override

		SetRegValue(DEF_DBG_BASE, DEF_REG_LOCATION, 			// set it just so users can find it...
					pcLogRegLocation, 
					DEF_REG_FLAGS1,
					m_dwLogFlags1
					);
                    
    }

 // Read LogFlags2 from Registry
    if (ERROR_SUCCESS != GetRegValue(DEF_DBG_BASE,			// key	--> "Software/Debug"
									 DEF_REG_LOCATION,		// key1 --> "MSTvTVE"
									 pcLogRegLocation,
									 DEF_REG_FLAGS2,
									 &m_dwLogFlags2))
    {
		m_dwLogFlags2 = 0;						// do nothing, or let SetLogFlags2 override

		SetRegValue(DEF_DBG_BASE, DEF_REG_LOCATION, 			// set it just so users can find it...
					pcLogRegLocation, 
					DEF_REG_FLAGS2,
					m_dwLogFlags2
					);
                    
    }

 // Read LogFlags3 from Registry
    if (ERROR_SUCCESS != GetRegValue(DEF_DBG_BASE,			// key	--> "Software/Debug"
									 DEF_REG_LOCATION,		// key1 --> "MSTvTVE"
									 pcLogRegLocation,
									 DEF_REG_FLAGS3,
									 &m_dwLogFlags3))
    {
		m_dwLogFlags3 = 0;						// do nothing, or let SetLogFlags3 override

		SetRegValue(DEF_DBG_BASE, DEF_REG_LOCATION, 			// set it just so users can find it...
					pcLogRegLocation, 
					DEF_REG_FLAGS3,
					m_dwLogFlags3
					);
                    
    }

 // Read LogFlags4 from Registry
    if (ERROR_SUCCESS != GetRegValue(DEF_DBG_BASE,			// key	--> "Software/Debug"
									 DEF_REG_LOCATION,		// key1 --> "MSTvTVE"
									 pcLogRegLocation,
									 DEF_REG_FLAGS4,
									 &m_dwLogFlags4))
    {
		m_dwLogFlags4 = 0;						// do nothing, or let SetLogFlags4 override

		SetRegValue(DEF_DBG_BASE, DEF_REG_LOCATION, 			// set it just so users can find it...
					pcLogRegLocation, 
					DEF_REG_FLAGS4,
					m_dwLogFlags4
					);
                    
    }

// Read LogLevel from Registry
    if (ERROR_SUCCESS != GetRegValue(DEF_DBG_BASE, DEF_REG_LOCATION, 
									 pcLogRegLocation, 
									 DEF_REG_LEVEL,
									 &m_dwLogLevel))
    {
		m_dwLogLevel = 0;						// If can't find it, default to 0 (always turned off)

		SetRegValue(DEF_DBG_BASE, DEF_REG_LOCATION, 
					pcLogRegLocation,
					DEF_REG_LEVEL,
					m_dwLogLevel
					);
    }

 
	m_szLogFileName[0]=0;
												// Read LogValue from Registry
	DWORD cBytesName = sizeof(m_szLogFileName);
	if (ERROR_SUCCESS != GetRegValueSZ(DEF_DBG_BASE, DEF_REG_LOCATION, 
									 pcLogRegLocation, 
									 DEF_REG_LOGFILE,
									 m_szLogFileName,
									 &cBytesName))
	{
		_tcscpy(m_szLogFileName, DEF_DF_TVE_LOGFILE);			// if can't find it, create with default name...

		SetRegValueSZ(DEF_DBG_BASE, DEF_REG_LOCATION, 		
					pcLogRegLocation,
					DEF_REG_LOGFILE,
					(const TCHAR *) m_szLogFileName
					);
	} 

   // Must call SetFlags to open...

}

CDebugLog::~CDebugLog()
{
    if (NULL != m_fileLog)
		fclose(m_fileLog);
}


void
CDebugLog::SetLogFlags(const TCHAR* pcLogFileName, 
					   DWORD dwLogFlags1,   DWORD dwLogFlags2,  DWORD dwLogFlags3,  DWORD dwLogFlags4,  
 
					   DWORD dwLogLevel)
{
	if(m_dwLogFlags1 == 0) 					// initial values are from registry - override here if 0/NULL
		m_dwLogFlags1 = dwLogFlags1;
	if(m_dwLogFlags2 == 0) 					
		m_dwLogFlags2 = dwLogFlags2;
	if(m_dwLogFlags3 == 0) 					
		m_dwLogFlags3 = dwLogFlags3;
	if(m_dwLogFlags4 == 0) 					
		m_dwLogFlags4 = dwLogFlags4;

	BOOL fDefaulting = false;
	if(m_dwLogLevel == 1)					// override level if 1
	{
		m_dwLogLevel = dwLogLevel;
		fDefaulting = true;
	}
		
	if(m_szLogFileName[0] == 0 && pcLogFileName && pcLogFileName[0])
	{	
		_tcscpy(m_szLogFileName, pcLogFileName);
	}

	if(m_fileLog == NULL &&				    // Open LogFileName if logging enabled
		CDebugLog::DBG_NONE != m_dwLogFlags2 &&		// file logging stuff on Flags2
		m_szLogFileName[0] != 0 &&
		m_dwLogLevel > 0)
    {
		if (CDebugLog::DBG4_WRITELOG & m_dwLogFlags2)
		{
			m_fileLog = _tfopen(m_szLogFileName, _T("w+tc"));
		} 
		else if(CDebugLog::DBG4_APPENDLOG & m_dwLogFlags2)
		{
			m_fileLog = _tfopen(m_szLogFileName, _T("a+tc"));
		} 
    }
	
	if(m_fileLog) 
	{
		if(m_dwLogLevel > 1)
		{
			SYSTEMTIME sysTime;
			GetLocalTime(&sysTime);

			TCHAR pcTime[1024];
			_stprintf(pcTime,
				_T("\n---------------------------------------------\nMSTvE Debugging: %d/%d/%d - %d:%02d:%02d"),
				sysTime.wMonth, sysTime.wDay, sysTime.wYear,
				sysTime.wHour,
				sysTime.wMinute,
				sysTime.wSecond);

			LogOut(pcTime, S_OK);
		}
	}
}

/*
#undef ATLTRACE

#ifndef _TRACE_ON
#define ATLTRACE            1 ? (void)0 : XAtlTrace
#else
#define ATLTRACE            XAtlTrace
#endif
*/

void XAtlTrace(LPCSTR lpszFormat, ...)
{
        va_list args;
        va_start(args, lpszFormat);

        int nBuf;
        char szBuffer[512];

        nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
 //       ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

        OutputDebugStringA(szBuffer);
        va_end(args);
}
#ifndef OLE2ANSI
void XAtlTrace(LPCWSTR lpszFormat, ...)
{
        va_list args;
        va_start(args, lpszFormat);

        int nBuf;
        WCHAR szBuffer[512];

        nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
      //  ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

        OutputDebugStringW(szBuffer);
        va_end(args);
}
#endif //!OLE2ANSI


void CDebugLog::LogOut(const TCHAR* pcString, HRESULT hr)
{
	TCHAR pHeadNull[8];
	if(NULL == m_pszHeader)				// create header in case no DBG_HEADER() call
	{
		_tcscpy(pHeadNull,_T("*"));
		m_pszHeader = pHeadNull;
	}

    if (S_OK == hr)
    {
		if (_tcslen(pcString) < 200) {
			ATLTRACE(_T("tid:%04x %s : %s\n"), GetCurrentThreadId(), m_pszHeader, pcString);
		}
		if (NULL != m_fileLog)
		{
			_ftprintf(m_fileLog, _T("tid:%04x %s : %s\n"), GetCurrentThreadId(), m_pszHeader, pcString);
			fflush(m_fileLog);
		}
    }
    else
    {
		if (_tcslen(pcString) < 200)
			ATLTRACE(_T("tid:%04x %s : %s -- hr=0x%08x\n"), GetCurrentThreadId(), m_pszHeader, pcString, hr);
		if (NULL != m_fileLog)
		{
			_ftprintf(m_fileLog, _T("tid:%04x %s : %s -- hr=0x%08x\n"), GetCurrentThreadId(), m_pszHeader, pcString, hr);
			fflush(m_fileLog);
		}
    }
}

void CDebugLog::Log(DWORD dwFlags1,  const TCHAR* pcString, HRESULT hr)
{
    if ((dwFlags1 & m_dwLogFlags1) != 0)
		{
		if (NULL == pcString)
		{
			LogOut(_T("<null>"), hr);
		}
		else
		{
			LogOut(pcString, hr);
		}
	}
}


void CDebugLog::Log1(DWORD dwFlags1, DWORD dwLevel, const TCHAR* pcString, HRESULT hr)
{
	if(m_dwLogLevel < dwLevel) return;

    if((dwFlags1 & m_dwLogFlags1) != 0)
		{
		if (NULL == pcString)
		{
			LogOut(_T("<null>"), hr);
		}
		else
		{
			LogOut(pcString, hr);
		}
	}
}


void CDebugLog::Log2(DWORD dwFlags2, DWORD dwLevel, const TCHAR* pcString, HRESULT hr)
{
	if(m_dwLogLevel < dwLevel) return;

    if((dwFlags2 & m_dwLogFlags2) != 0)
		{
		if (NULL == pcString)
		{
			LogOut(_T("<null>"), hr);
		}
		else
		{
			LogOut(pcString, hr);
		}
	}
}


void CDebugLog::Log3(DWORD dwFlags3, DWORD dwLevel, const TCHAR* pcString, HRESULT hr)
{
	if(m_dwLogLevel < dwLevel) return;

    if((dwFlags3 & m_dwLogFlags3) != 0)
		{
		if (NULL == pcString)
		{
			LogOut(_T("<null>"), hr);
		}
		else
		{
			LogOut(pcString, hr);
		}
	}
}


void CDebugLog::Log4(DWORD dwFlags4, DWORD dwLevel, const TCHAR* pcString, HRESULT hr)
{
	if(m_dwLogLevel < dwLevel) return;

    if((dwFlags4 & m_dwLogFlags4) != 0)
		{
		if (NULL == pcString)
		{
			LogOut(_T("<null>"), hr);
		}
		else
		{
			LogOut(pcString, hr);
		}
	}
}
void CDebugLog::Log(DWORD dwFlags1, UINT iResource, HRESULT hr)
{
    USES_CONVERSION;

    if ((dwFlags1 & m_dwLogFlags1) != 0)
    {
		TCHAR szTemp[_MAX_PATH];

		if (LoadString(_Module.GetResourceInstance(), iResource, szTemp, _MAX_PATH))
		{
			LogOut(szTemp, hr);
		}
	}
}

void CDebugLog::LogEvaluate(const TCHAR* pcString, HRESULT hr)
{
    if (DBG4_EVALUATE & m_dwLogFlags4)
    {
		SYSTEMTIME sysTime;
		GetLocalTime(&sysTime);

		TCHAR pcTime[1024];
		_stprintf(pcTime,
			_T("%d:%02d:%02d - %s"),
			sysTime.wHour,
			sysTime.wMinute,
			sysTime.wSecond, pcString);

		LogOut(pcTime, hr);
    }
}

void CDebugLog::LogEvaluate(UINT iResource, HRESULT hr)
{
    USES_CONVERSION;

    if (DBG4_EVALUATE & m_dwLogFlags4)
    {
		TCHAR szTemp[_MAX_PATH];

		if (LoadString(_Module.GetResourceInstance(), iResource, szTemp, _MAX_PATH))
		{
			LogEvaluate(szTemp, hr);
		}
    }
}

void CDebugLog::LogHeader(DWORD dwFlags1, const TCHAR* pcHeader, int cLevel)
{
    if ((NULL != pcHeader) && 
		(dwFlags1 & m_dwLogFlags1) && 
		(DBG4_TRACE & m_dwLogFlags4))	
    {
		int kMax = 10;
		int cMax = cLevel; if(cMax >= kMax) cMax = kMax-1;
		TCHAR tspace1[] = _T("              ");
		TCHAR tspace2[] = _T("              ");
		tspace1[cMax] = 0;
		tspace2[kMax-cMax] = 0;
		if(1==cLevel) {tspace1[0]='\n';tspace1[1]=' ';tspace1[2]=0;} 

		if (_tcslen(pcHeader) < (size_t) (256-kMax-20))
			ATLTRACE(_T("%svv%2d%s %04x %s\n"),tspace1, cLevel, tspace2, GetCurrentThreadId(), pcHeader);
		if (NULL != m_fileLog)
		{
			_ftprintf(m_fileLog, _T("%svv%2d%s %04x %s\n"), tspace1, cLevel, tspace2, GetCurrentThreadId(), pcHeader);
			fflush(m_fileLog);
		}
    }
}

void CDebugLog::LogTrailer(DWORD dwFlags1, const TCHAR* pcHeader, int cLevel)
{
    if ((NULL != pcHeader) && 
		(dwFlags1 & m_dwLogFlags1) && 
		(DBG4_TRACE & m_dwLogFlags4))		
    {
		int kMax = 10;
		int cMax = cLevel; if(cMax >= kMax) cMax = kMax-1;
		TCHAR tspace1[] = _T("              ");
		TCHAR tspace2[] = _T("              ");
		tspace1[cMax] = 0;
		tspace2[kMax-cMax] = 0;
		if (_tcslen(pcHeader) < (size_t) (256-kMax-20))
			ATLTRACE(_T("%s^^%2d%s ---- %s\n"),tspace1, cLevel, tspace2, pcHeader);
		if (NULL != m_fileLog)
		{
			_ftprintf(m_fileLog, _T("%s^^%2d%s ---- %s\n"),tspace1, cLevel, tspace2, pcHeader);
			fflush(m_fileLog);
		}
    }
}

#endif _TVEDEBUG_ACTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\include\defreg.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// -------------------------------------------------------
// defreg.h
//
// -------------------------------------------------------

								// where IE Cache directory's name is stored in the registry (HKEY-Current User)
#define DEF_IECACHEDIR_KEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define DEF_IECACHEDIR_VAR _T("Cache")


								// where TVE's cache dirctory is stored - also HKEY-current-user
								// (see Initialize_LID_SpoolDir_RegEntry() method which does IE's dir name to here)
								// These must match same variables in vidctl\msvidctl\vidprot.h or LID: won't work
#define DEF_LIDCACHEDIR_KEY _T("SOFTWARE\\Microsoft\\TV Services\\TVE Content\\")
#define DEF_LIDCACHEDIR_VAR _T("TVE Cache Dir")

								// ---------

#define DEF_REG_BASE		_T("SOFTWARE\\Microsoft\\TV Services\\")
#define DEF_REG_LOCATION	_T("MSTvE")

							// key values
#define DEF_LIDCACHEDIR_NAME			_T("TVE Cache")
#define DEF_LASTCHOICE_LIDCACHEDIR		_T("c:\\TveTemp")

							// debug key locations
#define DEF_DBG_BASE _T("SOFTWARE\\Debug\\")    // base key (folled by DEF_REG_LOCATION)

#define DEF_REG_LOGFILE		_T("LogFile")		// String - Name of log file, NULL let program override
#define DEF_REG_LEVEL		_T("Level")			// DWORD 0-8 logging verbosity level, 0 off, 1 let program override 
#define DEF_REG_FLAGS1		_T("Flags1")		// DWORD bits to control what subsystems to log, 0 let program override  
#define DEF_REG_FLAGS2		_T("Flags2")
#define DEF_REG_FLAGS3		_T("Flags3") 
#define DEF_REG_FLAGS4		_T("Flags4")

#define DEF_LOG_TVE			_T("LogTve")
#define DEF_LOG_TVEFILT		_T("LogTveFilt")
#define DEF_LOG_TVEGSEG		_T("LogTveGSeg")

#define DEF_DF_TVE_LOGFILE		_T("c:\\MSTvE.log")          // name of the logfile
#define DEF_DF_TVEFILT_LOGFILE	_T("c:\\MSTvEFilt.log")      // name of the logfile
#define DEF_DF_TVEGSEG_LOGFILE	_T("c:\\MSTvEGSeg.log")      // name of the logfile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\include\mpegcrc.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __MPEGCRC_H__
#define __MPEGCRC_H__

// generator polynomial: 0000 0100 1100 0001 0001 1101 1011 0111
const ULONG kCRCPolynomial = 0x04c11db7;

class MPEGCRC
{
public:
    MPEGCRC()
        {
        m_crc = 0xFFFFFFFF;
        }
    
    ULONG CRC()
        {
        return m_crc;
        }

    void Reset()
        {
        m_crc = 0xFFFFFFFF;
        }

    ULONG Update(BYTE *pb, int cb)
        {

        while (cb--)
            m_crc = crc_32(m_crc, *pb++);

        return m_crc;
        }

    ULONG crc_32(ULONG crc, BYTE b)
        {
        ULONG mask = 0x80;

        while (mask)
            {
            if (!(crc & 0x80000000) ^ !(b & mask))
                {
                crc = crc << 1;
                crc = crc ^ kCRCPolynomial;
                }
            else
                crc = crc << 1;
            
            mask = mask >> 1;
            }
        
        return crc;
        }

protected:
    ULONG m_crc;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\common\tvereg.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// --------------------------------------------------------------------
// TVEReg.cpp
// --------------------------------------------------------------------
#include "stdafx.h"

#include "TveReg.h"
#include "DbgStuff.h"
/*
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
*/

#ifndef _AFX
#define TRACE(x, y)
#define TRACE2(x, y1, y2)
#define TRACE3(x, y1, y2, y3)
#define ASSERT(x)
#endif


// ---------------------------------------------------------------------------
// Initialize_LID_SpoolDir_RegEntry
//
//		This looks in HKEY-Current-User\SOFTWARE\Microsoft\TV Services\TVE Content\TVE Cache Dir
//			for location of TVE Cache Directory.
//	
//		If not set, it sets it to the 'IE Cache Directory'/TVE Cache
//		    where the IE Cache directory is located at:
//			   HKEY-Current-User\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\Cache
//
//		If this not set, it sets it to:		<-- bug, should we change it to something else
//			c:\TVETemp
//
//		Finally, once it gets the name, it sets it into the initially tested location so it can find it again.
//
// ---------------------------------------------------------------------------


HRESULT 
Initialize_LID_SpoolDir_RegEntry()
{
	HRESULT hr = S_OK;

	TCHAR sztSpoolDir[MAX_PATH];
    DWORD  dwSpoolDir = MAX_PATH;

	hr = GetUserRegValueSZ(DEF_LIDCACHEDIR_KEY,		// try to get name
										 NULL,
										 NULL,
										 DEF_LIDCACHEDIR_VAR, 
                                         sztSpoolDir, 
                                         &dwSpoolDir);

	if (ERROR_SUCCESS != hr || dwSpoolDir < 1)
	{

					// TODO - create with a real name..
	    dwSpoolDir = MAX_PATH;
		hr = GetUserRegValueSZ(DEF_IECACHEDIR_KEY, 
											  NULL, 
											  NULL,
											  DEF_IECACHEDIR_VAR, 
											  sztSpoolDir,
											  &dwSpoolDir);
		if (ERROR_SUCCESS != hr)
		{
			_ASSERT(false);  // IE not loaded???
			_tcscpy(sztSpoolDir, DEF_LASTCHOICE_LIDCACHEDIR);					// if can't find it, create with default name...
		} else {
							// tack on a TVE Cache Dir to the end...	
			if(_tcslen(sztSpoolDir) + _tcslen(DEF_LIDCACHEDIR_NAME) > MAX_PATH - 64)
			{
				_tcscpy(sztSpoolDir, DEF_LASTCHOICE_LIDCACHEDIR);				// path way too long - set to a smaller one..
			} else {
				_tcsncat(sztSpoolDir, _T("\\"), MAX_PATH - _tcslen(sztSpoolDir));
				_tcsncat(sztSpoolDir, DEF_LIDCACHEDIR_NAME, MAX_PATH - _tcslen(sztSpoolDir));
			}
		}
		
		hr = SetUserRegValueSZ(DEF_LIDCACHEDIR_KEY,					// write it...
						       NULL,
							   NULL,
							   DEF_LIDCACHEDIR_VAR,
						       sztSpoolDir);
	}
	return hr;
}

			// null it out...
HRESULT 
Unregister_LID_SpoolDir_RegEntry()
{
	
	HKEY hkey;
	long r = OpenUserRegKey(DEF_LIDCACHEDIR_KEY,				// is key there?
						   NULL,
						   NULL,
						   &hkey);

	long r2 = -1;												// default to no-zero
	if(ERROR_SUCCESS == r) {
		r2 = RegDeleteValue(hkey,DEF_LIDCACHEDIR_VAR);			// delete the value
		r = RegCloseKey(hkey);
	}
	return (ERROR_SUCCESS == r && ERROR_SUCCESS == r2) ? S_OK : HRESULT_FROM_WIN32((r != ERROR_SUCCESS ? r : r2));
}
//-----------------------------------------------------------------------------
// See  TveReg.h for documentation for all functions.
//-----------------------------------------------------------------------------

long OpenRegKey(HKEY hkeyRoot, LPCTSTR szKey, LPCTSTR szSubKey1,
        LPCTSTR szSubKey2, HKEY *phkey,
        REGSAM sam /* = BPC_KEY_STD_ACCESS */, BOOL fCreate /* = FALSE */)
{
    LONG r;
    TCHAR *szFullKey = NULL;

    if (szKey == NULL)
        {
        if (szSubKey1 != NULL)
            {
            szKey = szSubKey1;
            szSubKey1 = NULL;
            }
        }
    else
        {
        if (szSubKey1 == NULL && szSubKey2 != NULL)
            {
            szSubKey1 = szSubKey2;
            szSubKey2 = NULL;
            }

        if (szSubKey1 != NULL)
            {
            int cb = _tcsclen(szKey) + _tcsclen(szSubKey1) + 2;
            if (szSubKey2 != NULL)
                cb += _tcsclen(szSubKey2) + 1;
#ifdef _AFX
            try
                {
                szFullKey = new TCHAR[cb];
                }
            catch (CMemoryException *pe)
                {
                pe->Delete();
                return ERROR_NOT_ENOUGH_MEMORY;
                }
#else
            szFullKey = new TCHAR[cb];
            if (szFullKey == NULL)
                return ERROR_NOT_ENOUGH_MEMORY;
#endif

            _tcscpy(szFullKey, szKey);

            TCHAR *szT = szFullKey + _tcsclen(szFullKey);
            if (szT[-1] != _T('\\') && szSubKey1[0] != _T('\\'))
                {
                szT[0] = _T('\\');
                szT++;
                }
            _tcscpy(szT, szSubKey1);

            if (szSubKey2 != NULL)
                {
                szT += _tcsclen(szT);
                if (szT[-1] != _T('\\') && szSubKey2[0] != _T('\\'))
                    {
                    szT[0] = _T('\\');
                    szT++;
                    }
                _tcscpy(szT, szSubKey2);
                }
            szKey = szFullKey;
            }
        }

    if (fCreate && szKey != NULL)
        {
        DWORD dwDisposition;

        r = RegCreateKeyEx(hkeyRoot, szKey, 0, _T(""), 0, sam, NULL,
                phkey, &dwDisposition);
        }
    else
        {
        r = RegOpenKeyEx(hkeyRoot, szKey, 0, sam, phkey);
        }

    if (r != ERROR_SUCCESS)
        {
        if (szKey != NULL)
            TRACE2("OpenRegKey(): can't open key '%s' %ld\n", szKey, r);
        else
            TRACE2("OpenRegKey(): can't duplicate key '%x'  %ld\n", hkeyRoot, r);
        }

    if (szFullKey != NULL)
        delete [] szFullKey;

    return r;
}

long GetRegValue(HKEY hkeyRoot, LPCTSTR szKey, LPCTSTR szSubKey1,
        LPCTSTR szSubKey2, LPCTSTR szValueName,
        DWORD dwType, BYTE *pb, DWORD *pcb)
{
    DWORD dwTypeGot;
    HKEY hkey;
    LONG r = ERROR_SUCCESS;

    if (pb != NULL)
        {
        ASSERT(AfxIsValidAddress(pb, *pcb, TRUE));
        memset(pb, 0, *pcb);
        }

    r = OpenRegKey(hkeyRoot, szKey, szSubKey1, szSubKey2, &hkey, KEY_READ);

    if (r == ERROR_SUCCESS)
        {
        r = RegQueryValueEx(hkey, szValueName, NULL, &dwTypeGot, pb, pcb);
        RegCloseKey(hkey);

#ifdef _DEBUG
        if (szValueName == NULL)
            szValueName = _T("<default>");
#endif

        if (r != ERROR_SUCCESS)
            {
            TRACE2("GetRegValue(): can't read value '%s'  %ld\n", szValueName, r);
            }
        else if (dwTypeGot != dwType)
            {
            if ((dwTypeGot == REG_BINARY) && (dwType == REG_DWORD) && (*pcb == sizeof(DWORD)))
                {
                // REG_DWORD is the same as 4 bytes of REG_BINARY
                }
            else
                {
//                TRACE3(_T("GetRegValue(): '%s' is wrong type (%x != %x)\n"),
//                        szValueName, dwTypeGot, dwType);
                r = ERROR_INVALID_DATATYPE;
                }
            }
        }

    return r;
}

long SetRegValue(HKEY hkeyRoot, LPCTSTR szKey, LPCTSTR szSubKey1,
        LPCTSTR szSubKey2, LPCTSTR szValueName,
        DWORD dwType, const BYTE *pb, DWORD cb)
{
    HKEY hkey;
    LONG r;

    r = OpenRegKey(hkeyRoot, szKey, szSubKey1, szSubKey2, &hkey, KEY_WRITE, TRUE);

    ASSERT(pb != NULL);

    if (r == ERROR_SUCCESS)
        {
        r = RegSetValueEx(hkey, szValueName, NULL, dwType, pb, cb);
        RegCloseKey(hkey);

#ifdef _DEBUG
        if (r != ERROR_SUCCESS)
            {
            if (szValueName == NULL)
                szValueName = _T("<default>");
            TRACE2("SetRegValue(): can't write value '%s'  %ld\n", szValueName, r);
            }
#endif
        }

    return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\include\fileutil.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// FileUtil.h : File Utilities

// Methods
extern TCHAR* FixPath(TCHAR* strPath);
extern BOOL CreatePath(TCHAR *pcPath);
extern void DelTree(TCHAR *pcTree);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\crc32.c ===
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

// new
#define ZEXPORT
//////

#include "zlib.h"


#define local static

#ifdef DYNAMIC_CRC_TABLE

local int crc_table_empty = 1;
local uLongf crc_table[256];
local void make_crc_table OF((void));

/*
  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The table is simply the CRC of all possible eight bit values.  This is all
  the information needed to generate CRC's on data a byte at a time for all
  combinations of CRC register values and incoming bytes.
*/
local void make_crc_table()
{
  uLong c;
  int n, k;
  uLong poly;            /* polynomial exclusive-or pattern */
  /* terms of polynomial defining this crc (except x^32): */
  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

  /* make exclusive-or pattern from polynomial (0xedb88320L) */
  poly = 0L;
  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
    poly |= 1L << (31 - p[n]);
 
  for (n = 0; n < 256; n++)
  {
    c = (uLong)n;
    for (k = 0; k < 8; k++)
      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    crc_table[n] = c;
  }
  crc_table_empty = 0;
}
#else
/* ========================================================================
 * Table of CRC-32's of all single-byte values (made by make_crc_table)
 */
local const uLongf crc_table[256] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
  0x2d02ef8dL
};
#endif

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const uLongf * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
  if (crc_table_empty) make_crc_table();
#endif
  return (const uLongf *)crc_table;
}

/* ========================================================================= */
#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

/* ========================================================================= */
uLong ZEXPORT crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
    if (buf == Z_NULL) return 0L;
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
    } while (--len);
    return crc ^ 0xffffffffL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\include\myatlbase.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4505) // unreferenced local function has been removed
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514) // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
#pragma warning(disable: 4097) // typedef name used as synonym for class-name
#pragma warning(disable: 4786) // identifier was truncated in the debug information
#pragma warning(disable: 4268) // const static/global data initialized to zeros
#pragma warning(disable: 4291) // allow placement new
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <atldef.h>

#include <windows.h>
#include <winnls.h>
#include <ole2.h>

#include <comcat.h>
#include <stddef.h>

#include "tvedbg.h"     // used to turn ATL traceing on/off

#ifdef new
#pragma push_macro("new")
#define _ATL_REDEF_NEW
#undef new
#endif

#include <tchar.h>
#include <malloc.h>

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
        #include <crtdbg.h>
#endif

#include <olectl.h>
#include <winreg.h>
#include <atliface.h>

#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>
#endif

#include <atlconv.h>

#include <shlwapi.h>

#pragma pack(push, _ATL_PACKING)

#if defined(_ATL_DLL)
        #pragma comment(lib, "atl.lib")
#endif

extern "C" const __declspec(selectany) GUID LIBID_ATLLib = {0x44EC0535,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) CLSID CLSID_Registrar = {0x44EC053A,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IRegistrar = {0x44EC053B,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IAxWinHostWindow = {0xb6ea2050,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IAxWinAmbientDispatch = {0xb6ea2051,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IInternalConnection = {0x72AD0770,0x6A9F,0x11d1,{0xBC,0xEC,0x00,0x60,0x08,0x8F,0x44,0x4E}};
extern "C" const __declspec(selectany) IID IID_IDocHostUIHandlerDispatch = {0x425B5AF0,0x65F1,0x11d1,{0x96,0x11,0x00,0x00,0xF8,0x1E,0x0D,0x0D}};

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

struct _ATL_CATMAP_ENTRY
{
   int iType;
   const CATID* pcatid;
};

#define _ATL_CATMAP_ENTRY_END 0
#define _ATL_CATMAP_ENTRY_IMPLEMENTED 1
#define _ATL_CATMAP_ENTRY_REQUIRED 2

typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw);
typedef HRESULT (WINAPI _ATL_MODULEFUNC)(DWORD_PTR dw);
typedef LPCTSTR (WINAPI _ATL_DESCRIPTIONFUNC)();
typedef const struct _ATL_CATMAP_ENTRY* (_ATL_CATMAPFUNC)();
typedef void (__stdcall _ATL_TERMFUNC)(DWORD_PTR dw);

struct _ATL_TERMFUNC_ELEM
{
        _ATL_TERMFUNC* pFunc;
        DWORD_PTR dw;
        _ATL_TERMFUNC_ELEM* pNext;
};

struct _ATL_OBJMAP_ENTRY
{
        const CLSID* pclsid;
        HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
        _ATL_CREATORFUNC* pfnGetClassObject;
        _ATL_CREATORFUNC* pfnCreateInstance;
        IUnknown* pCF;
        DWORD dwRegister;
        _ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
        _ATL_CATMAPFUNC* pfnGetCategoryMap;
        HRESULT WINAPI RevokeClassObject()
        {
                return CoRevokeClassObject(dwRegister);
        }
        HRESULT WINAPI RegisterClassObject(DWORD dwClsContext, DWORD dwFlags)
        {
                IUnknown* p = NULL;
                if (pfnGetClassObject == NULL)
                        return S_OK;
                HRESULT hRes = pfnGetClassObject(pfnCreateInstance, IID_IUnknown, (LPVOID*) &p);
                if (SUCCEEDED(hRes))
                        hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
                if (p != NULL)
                        p->Release();
                return hRes;
        }
// Added in ATL 3.0
        void (WINAPI *pfnObjectMain)(bool bStarting);
};

struct _ATL_REGMAP_ENTRY
{
        LPCOLESTR     szKey;
        LPCOLESTR     szData;
};

struct _AtlCreateWndData
{
        void* m_pThis;
        DWORD m_dwThreadID;
        _AtlCreateWndData* m_pNext;
};

struct _ATL_MODULE_21
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        union
        {
                CRITICAL_SECTION m_csTypeInfoHolder;
                CRITICAL_SECTION m_csStaticDataInit;
        };
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
};

struct _ATL_MODULE_30
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        union
        {
                CRITICAL_SECTION m_csTypeInfoHolder;
                CRITICAL_SECTION m_csStaticDataInit;
        };
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
// Original Size = 100
// Stuff added in ATL 3.0
        DWORD dwAtlBuildVer;
        _AtlCreateWndData* m_pCreateWndList;
        bool m_bDestroyHeap;
        GUID* pguidVer;
        DWORD m_dwHeaps;    // Number of heaps we have (-1)
        HANDLE* m_phHeaps;
        int m_nHeap;        // Which heap to choose from
        _ATL_TERMFUNC_ELEM* m_pTermFuncs;
};

#if _ATL_VER == 0x0300
typedef _ATL_MODULE_30 _ATL_MODULE;
#else
struct _ATL_MODULE
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        union
        {
                CRITICAL_SECTION m_csTypeInfoHolder;
                CRITICAL_SECTION m_csStaticDataInit;
        };
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
// Original Size = 100
// Stuff added in ATL 3.0
        DWORD dwAtlBuildVer;
        _AtlCreateWndData* m_pCreateWndList;
        bool m_bDestroyHeap;
        GUID* pguidVer;
        DWORD m_dwHeaps;    // Number of heaps we have (-1)
        HANDLE* m_phHeaps;
        int m_nHeap;        // Which heap to choose from
        _ATL_TERMFUNC_ELEM* m_pTermFuncs;
// Stuff added in ATL 6.1
        LONG m_nNextWindowID;
};
#endif

const int _nAtlModuleVer21Size = sizeof( _ATL_MODULE_21 );
const int _nAtlModuleVer30Size = sizeof( _ATL_MODULE_30 );

//This define makes debugging asserts easier.
#define _ATL_SIMPLEMAPENTRY ((_ATL_CREATORARGFUNC*)1)

struct _ATL_INTMAP_ENTRY
{
        const IID* piid;       // the interface id (IID)
        DWORD_PTR dw;
        _ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};

/////////////////////////////////////////////////////////////////////////////
// Thunks for __stdcall member functions


#if defined(_M_IX86)
#pragma pack(push,1)
struct _stdcallthunk
{
        DWORD   m_mov;          // mov dword ptr [esp+0x4], pThis (esp+0x4 is hWnd)
        DWORD   m_this;         //
        BYTE    m_jmp;          // jmp WndProc
        DWORD   m_relproc;      // relative jmp
        void Init(DWORD_PTR proc, void* pThis)
        {
                m_mov = 0x042444C7;  //C7 44 24 0C
                m_this = PtrToUlong(pThis);
                m_jmp = 0xe9;
                m_relproc = DWORD((INT_PTR)proc - ((INT_PTR)this+sizeof(_stdcallthunk)));
                // write block from data cache and
                //  flush from instruction cache
                FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
        }
};
#pragma pack(pop)
#elif defined (_M_AMD64)
#pragma pack(push,2)
struct _stdcallthunk
{
    USHORT  RcxMov;         // mov rcx, pThis
    ULONG64 RcxImm;         // 
    USHORT  RaxMov;         // mov rax, target
    ULONG64 RaxImm;         //
    USHORT  RaxJmp;         // jmp target
    void Init(DWORD_PTR proc, void *pThis)
    {
        RcxMov = 0xb948;          // mov rcx, pThis
        RcxImm = (ULONG64)pThis;  // 
        RaxMov = 0xb848;          // mov rax, target
        RaxImm = (ULONG64)proc;   //
        RaxJmp = 0xe0ff;          // jmp rax
        FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
    }
};
#pragma pack(pop)
#elif defined(_M_IA64)
#pragma pack(push,8)
extern "C" LRESULT CALLBACK _WndProcThunkProc( HWND, UINT, WPARAM, LPARAM );
struct _FuncDesc
{
        void* pfn;
        void* gp;
};
struct _stdcallthunk
{
        _FuncDesc m_funcdesc;
        void* m_pFunc;
        void* m_pThis;
        void Init(DWORD_PTR proc, void* pThis)
        {
                const _FuncDesc* pThunkProc;

                pThunkProc = reinterpret_cast< const _FuncDesc* >( _WndProcThunkProc );
                m_funcdesc.pfn = pThunkProc->pfn;
                m_funcdesc.gp = &m_pFunc;
                m_pFunc = reinterpret_cast< void* >( proc );
                m_pThis = pThis;
                ::FlushInstructionCache( GetCurrentProcess(), this, sizeof( _stdcallthunk ) );
        }
};
#pragma pack(pop)
#else
#error Only AMD64, IA64, and X86 supported
#endif

class CDynamicStdCallThunk
{
public:
        _stdcallthunk *pThunk;

        CDynamicStdCallThunk()
        {
                pThunk = NULL;
        }

        ~CDynamicStdCallThunk()
        {
                if (pThunk)
                        HeapFree(GetProcessHeap(), 0, pThunk);
        }

        void Init(DWORD_PTR proc, void *pThis)
        {
                if (!pThunk) {
                    pThunk = static_cast<_stdcallthunk *>(HeapAlloc(GetProcessHeap(), 
                            HEAP_GENERATE_EXCEPTIONS, sizeof(_stdcallthunk)));
                }
                ATLASSERT(pThunk);
                pThunk->Init(proc, pThis);
        }
};
typedef CDynamicStdCallThunk CStdCallThunk;

/////////////////////////////////////////////////////////////////////////////
// QI Support

ATLAPI AtlInternalQueryInterface(void* pThis,
        const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject);

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp);
ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid);

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

ATLAPI AtlFreeMarshalStream(IStream* pStream);
ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream);
ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk);

ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent);

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc,
        DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes,
        HINSTANCE hInst);

/////////////////////////////////////////////////////////////////////////////
// Module

ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags);
ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM);
ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv);
ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE*pM, LPCOLESTR lpszRes,
        BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg = NULL);
ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib);

ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h);
ATLAPI AtlModuleTerm(_ATL_MODULE* pM);
ATLAPI_(DWORD) AtlGetVersion(void* pReserved);
ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject);
ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM);
ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD_PTR dw);

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

namespace ATL
{

enum atlTraceFlags
{
        // Application defined categories
        atlTraceUser        = 0x00000001,
        atlTraceUser2       = 0x00000002,
        atlTraceUser3       = 0x00000004,
        atlTraceUser4       = 0x00000008,
        // ATL defined categories
        atlTraceGeneral     = 0x00000020,
        atlTraceCOM         = 0x00000040,
        atlTraceQI      = 0x00000080,
        atlTraceRegistrar   = 0x00000100,
        atlTraceRefcount    = 0x00000200,
        atlTraceWindowing   = 0x00000400,
        atlTraceControls    = 0x00000800,
        atlTraceHosting     = 0x00001000,
        atlTraceDBClient    = 0x00002000,
        atlTraceDBProvider  = 0x00004000,
        atlTraceSnapin      = 0x00008000,
        atlTraceNotImpl     = 0x00010000,
};

#ifndef ATL_TRACE_CATEGORY
#define ATL_TRACE_CATEGORY 0xFFFFFFFF
#endif

#ifdef _DEBUG

#ifndef ATL_TRACE_LEVEL
#define ATL_TRACE_LEVEL 0
#endif

inline void _cdecl AtlTrace(LPCSTR lpszFormat, ...)
{
        va_list args;
        va_start(args, lpszFormat);

        int nBuf;
        char szBuffer[512];

        nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
        ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

        OutputDebugStringA(szBuffer);
        va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCSTR lpszFormat, ...)
{
        if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
        {
                va_list args;
                va_start(args, lpszFormat);

                int nBuf;
                char szBuffer[512];

                nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
                ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

                OutputDebugStringA("ATL: ");
                OutputDebugStringA(szBuffer);
                va_end(args);
        }
}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR lpszFormat, ...)
{
        va_list args;
        va_start(args, lpszFormat);

        int nBuf;
        WCHAR szBuffer[512];

        nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
        ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

        OutputDebugStringW(szBuffer);
        va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCWSTR lpszFormat, ...)
{
        if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
        {
                va_list args;
                va_start(args, lpszFormat);

                int nBuf;
                WCHAR szBuffer[512];

                nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
                ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

                OutputDebugStringW(L"ATL: ");
                OutputDebugStringW(szBuffer);
                va_end(args);
        }
}
#endif //!OLE2ANSI


#ifndef ATLTRACE
#define ATLTRACE            AtlTrace
#define ATLTRACE2           AtlTrace2
#endif
#define ATLTRACENOTIMPL(funcname)   ATLTRACE2(atlTraceNotImpl, 2, _T("ATL: %s not implemented.\n"), funcname); return E_NOTIMPL
#else // !DEBUG
inline void _cdecl AtlTrace(LPCSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCSTR , ...){}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCWSTR , ...){}
#endif //OLE2ANSI
#ifndef ATLTRACE
#define ATLTRACE            1 ? (void)0 : AtlTrace
#define ATLTRACE2           1 ? (void)0 : AtlTrace2
#endif //ATLTRACE
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG





/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#ifndef _WIN64
#pragma comment(lib, "olepro32.lib")
#endif
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "uuid.lib")

static HRESULT AtlSetChildSite(IUnknown* punkChild, IUnknown* punkParent)
{
        if (punkChild == NULL)
                return E_POINTER;

        HRESULT hr;
        IObjectWithSite* pChildSite = NULL;
        hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&pChildSite);
        if (SUCCEEDED(hr) && pChildSite != NULL)
        {
                hr = pChildSite->SetSite(punkParent);
                pChildSite->Release();
        }
        return hr;
}

template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
        private:
                STDMETHOD_(ULONG, AddRef)()=0;
                STDMETHOD_(ULONG, Release)()=0;
};

template <class T>
class CComPtr
{
public:
        typedef T _PtrClass;
        CComPtr()
        {
                p=NULL;
        }
        CComPtr(T* lp)
        {
                if ((p = lp) != NULL)
                        p->AddRef();
        }
        CComPtr(const CComPtr<T>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        ~CComPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator T*() const
        {
                return (T*)p;
        }
        T& operator*() const
        {
                ATLASSERT(p!=NULL);
                return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.
        T** operator&()
        {
                ATLASSERT(p==NULL);
                return &p;
        }
        _NoAddRefReleaseOnCComPtr<T>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<T>*)p;
        }
        T* operator=(T* lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
        }
        T* operator=(const CComPtr<T>& lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(T* pT) const
        {
                return p < pT;
        }
        bool operator==(T* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        void Attach(T* p2)
        {
                if (p)
                        p->Release();
                p = p2;
        }
        T* Detach()
        {
                T* pt = p;
                p = NULL;
                return pt;
        }
        HRESULT CopyTo(T** ppT)
        {
                ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp) const
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
        T* p;
};


template <class T, const IID* piid = &__uuidof(T)>
class CComQIPtr
{
public:
        typedef T _PtrClass;
        CComQIPtr()
        {
                p=NULL;
        }
        CComQIPtr(T* lp)
        {
                if ((p = lp) != NULL)
                        p->AddRef();
        }
        CComQIPtr(const CComQIPtr<T,piid>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        CComQIPtr(IUnknown* lp)
        {
                p=NULL;
                if (lp != NULL)
                        lp->QueryInterface(*piid, (void **)&p);
        }
        ~CComQIPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator T*() const
        {
                return p;
        }
        T& operator*() const
        {
                ATLASSERT(p!=NULL); return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.
        T** operator&()
        {
                ATLASSERT(p==NULL);
                return &p;
        }
        _NoAddRefReleaseOnCComPtr<T>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<T>*)p;
        }
        T* operator=(T* lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
        }
        T* operator=(const CComQIPtr<T,piid>& lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        T* operator=(IUnknown* lp)
        {
                return (T*)AtlComQIPtrAssign((IUnknown**)&p, lp, *piid);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(T* pT) const
        {
                return p < pT;
        }
        bool operator==(T* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        void Attach(T* p2)
        {
                if (p)
                        p->Release();
                p = p2;
        }
        T* Detach()
        {
                T* pt = p;
                p = NULL;
                return pt;
        }
        HRESULT CopyTo(T** ppT)
        {
                ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp)
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
        T* p;
};

//Specialization to make it work
template<>
class CComQIPtr<IUnknown, &IID_IUnknown>
{
public:
        typedef IUnknown _PtrClass;
        CComQIPtr()
        {
                p=NULL;
        }
        CComQIPtr(IUnknown* lp)
        {
                //Actually do a QI to get identity
                p=NULL;
                if (lp != NULL)
                        lp->QueryInterface(IID_IUnknown, (void **)&p);
        }
        CComQIPtr(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        ~CComQIPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator IUnknown*() const
        {
                return p;
        }
        IUnknown& operator*() const
        {
                ATLASSERT(p!=NULL);
                return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.
        IUnknown** operator&()
        {
                ATLASSERT(p==NULL);
                return &p;
        }
        _NoAddRefReleaseOnCComPtr<T>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<T>*)p;
        }
        IUnknown* operator=(IUnknown* lp)
        {
                //Actually do a QI to get identity
                return (IUnknown*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IUnknown);
        }
        IUnknown* operator=(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
        {
                return (IUnknown*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(IUnknown* pT) const
        {
                return p < pT;
        }
        bool operator==(IUnknown* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        IUnknown* Detach()
        {
                IUnknown* pt = p;
                p = NULL;
                return pt;
        }
        HRESULT CopyTo(T** ppT)
        {
                ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp)
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
        IUnknown* p;
};

#define com_cast CComQIPtr

/////////////////////////////////////////////////////////////
// Class to Adapt CComBSTR and CComPtr for use with STL containers
// the syntax to use it is
// std::vector< CAdapt <CComBSTR> > vect;

template <class T>
class CAdapt
{
public:
        CAdapt()
        {
        }
        CAdapt(const T& rSrc)
        {
                m_T = rSrc;
        }

        CAdapt(const CAdapt& rSrCA)
        {
                m_T = rSrCA.m_T;
        }

        CAdapt& operator=(const T& rSrc)
        {
                m_T = rSrc;
                return *this;
        }
        bool operator<(const T& rSrc) const
        {
                return m_T < rSrc;
        }
        bool operator==(const T& rSrc) const
        {
                return m_T == rSrc;
        }
        operator T&()
        {
                return m_T;
        }

        operator const T&() const
        {
                return m_T;
        }

        T m_T;
};

/////////////////////////////////////////////////////////////////////////////
// GUID comparison

#if 0
inline BOOL InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
          ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
          ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
          ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
          ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}
#endif

inline BOOL InlineIsEqualUnknown(REFGUID rguid1)
{
   return (
          ((PLONG) &rguid1)[0] == 0 &&
          ((PLONG) &rguid1)[1] == 0 &&
#ifdef _ATL_BYTESWAP
          ((PLONG) &rguid1)[2] == 0xC0000000 &&
          ((PLONG) &rguid1)[3] == 0x00000046);
#else
          ((PLONG) &rguid1)[2] == 0x000000C0 &&
          ((PLONG) &rguid1)[3] == 0x46000000);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support

class CComCriticalSection
{
public:
        void Lock() {EnterCriticalSection(&m_sec);}
        void Unlock() {LeaveCriticalSection(&m_sec);}
        void Init() {InitializeCriticalSection(&m_sec);}
        void Term() {DeleteCriticalSection(&m_sec);}
        CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection
{
public:
        void Lock() {EnterCriticalSection(&m_sec);}
        void Unlock() {LeaveCriticalSection(&m_sec);}
        CComAutoCriticalSection() {InitializeCriticalSection(&m_sec);}
        ~CComAutoCriticalSection() {DeleteCriticalSection(&m_sec);}
        CRITICAL_SECTION m_sec;
};

class CComFakeCriticalSection
{
public:
        void Lock() {}
        void Unlock() {}
        void Init() {}
        void Term() {}
};

class CComMultiThreadModelNoCS
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
        static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
        typedef CComFakeCriticalSection AutoCriticalSection;
        typedef CComFakeCriticalSection CriticalSection;
        typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComMultiThreadModel
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
        static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
        typedef CComAutoCriticalSection AutoCriticalSection;
        typedef CComCriticalSection CriticalSection;
        typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComSingleThreadModel
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return ++(*p);}
        static ULONG WINAPI Decrement(LPLONG p) {return --(*p);}
        typedef CComFakeCriticalSection AutoCriticalSection;
        typedef CComFakeCriticalSection CriticalSection;
        typedef CComSingleThreadModel ThreadModelNoCS;
};

#if defined(_ATL_SINGLE_THREADED)
        typedef CComSingleThreadModel CComObjectThreadModel;
        typedef CComSingleThreadModel CComGlobalsThreadModel;
#elif defined(_ATL_APARTMENT_THREADED)
        typedef CComSingleThreadModel CComObjectThreadModel;
        typedef CComMultiThreadModel CComGlobalsThreadModel;
#else
        typedef CComMultiThreadModel CComObjectThreadModel;
        typedef CComMultiThreadModel CComGlobalsThreadModel;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComModule

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4

HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);

#ifdef _ATL_DEBUG_INTERFACES
struct _QIThunk
{
        STDMETHOD(QueryInterface)(REFIID iid, void** pp)
        {
                ATLASSERT(m_dwRef >= 0);
                return pUnk->QueryInterface(iid, pp);
        }
        STDMETHOD_(ULONG, AddRef)()
        {
                if (bBreak)
                        DebugBreak();
                pUnk->AddRef();
                return InternalAddRef();
        }
        ULONG InternalAddRef()
        {
                if (bBreak)
                        DebugBreak();
                ATLASSERT(m_dwRef >= 0);
                long l = InterlockedIncrement(&m_dwRef);

	        //------------------------------------------------------
		        if(DBG_FSET4(CDebugLog::DBG4_ATLTRACE))
		        {
			        ATLTRACE(_T("            %d> "), m_dwRef);										// jbcode
			        pUnk->AddRef();
			        int _cRefs = pUnk->Release();
			        ATLTRACE(_T("%04x %3d/%3d 0x%08x t%3d id %4d +  "), GetCurrentThreadId() , m_dwRef, m_dwMaxRef, pUnk, _cRefs, nIndex);		// jb 6/32
			        ATLTRACE(_cRefs==1 ? _T("---") : _T("   "));
			        AtlDumpIID(iid, lpszClassName, S_OK);
		        }
	        //-------------------------------------------------------

                if (l > m_dwMaxRef)
                        m_dwMaxRef = l;
                return l;
        }
        STDMETHOD_(ULONG, Release)();

        STDMETHOD(f3)();
        STDMETHOD(f4)();
        STDMETHOD(f5)();
        STDMETHOD(f6)();
        STDMETHOD(f7)();
        STDMETHOD(f8)();
        STDMETHOD(f9)();
        STDMETHOD(f10)();
        STDMETHOD(f11)();
        STDMETHOD(f12)();
        STDMETHOD(f13)();
        STDMETHOD(f14)();
        STDMETHOD(f15)();
        STDMETHOD(f16)();
        STDMETHOD(f17)();
        STDMETHOD(f18)();
        STDMETHOD(f19)();
        STDMETHOD(f20)();
        STDMETHOD(f21)();
        STDMETHOD(f22)();
        STDMETHOD(f23)();
        STDMETHOD(f24)();
        STDMETHOD(f25)();
        STDMETHOD(f26)();
        STDMETHOD(f27)();
        STDMETHOD(f28)();
        STDMETHOD(f29)();
        STDMETHOD(f30)();
        STDMETHOD(f31)();
        STDMETHOD(f32)();
        STDMETHOD(f33)();
        STDMETHOD(f34)();
        STDMETHOD(f35)();
        STDMETHOD(f36)();
        STDMETHOD(f37)();
        STDMETHOD(f38)();
        STDMETHOD(f39)();
        STDMETHOD(f40)();
        STDMETHOD(f41)();
        STDMETHOD(f42)();
        STDMETHOD(f43)();
        STDMETHOD(f44)();
        STDMETHOD(f45)();
        STDMETHOD(f46)();
        STDMETHOD(f47)();
        STDMETHOD(f48)();
        STDMETHOD(f49)();
        STDMETHOD(f50)();
        STDMETHOD(f51)();
        STDMETHOD(f52)();
        STDMETHOD(f53)();
        STDMETHOD(f54)();
        STDMETHOD(f55)();
        STDMETHOD(f56)();
        STDMETHOD(f57)();
        STDMETHOD(f58)();
        STDMETHOD(f59)();
        STDMETHOD(f60)();
        STDMETHOD(f61)();
        STDMETHOD(f62)();
        STDMETHOD(f63)();
        STDMETHOD(f64)();
        STDMETHOD(f65)();
        STDMETHOD(f66)();
        STDMETHOD(f67)();
        STDMETHOD(f68)();
        STDMETHOD(f69)();
        STDMETHOD(f70)();
        STDMETHOD(f71)();
        STDMETHOD(f72)();
        STDMETHOD(f73)();
        STDMETHOD(f74)();
        STDMETHOD(f75)();
        STDMETHOD(f76)();
        STDMETHOD(f77)();
        STDMETHOD(f78)();
        STDMETHOD(f79)();
        STDMETHOD(f80)();
        STDMETHOD(f81)();
        STDMETHOD(f82)();
        STDMETHOD(f83)();
        STDMETHOD(f84)();
        STDMETHOD(f85)();
        STDMETHOD(f86)();
        STDMETHOD(f87)();
        STDMETHOD(f88)();
        STDMETHOD(f89)();
        STDMETHOD(f90)();
        STDMETHOD(f91)();
        STDMETHOD(f92)();
        STDMETHOD(f93)();
        STDMETHOD(f94)();
        STDMETHOD(f95)();
        STDMETHOD(f96)();
        STDMETHOD(f97)();
        STDMETHOD(f98)();
        STDMETHOD(f99)();
        STDMETHOD(f100)();
        STDMETHOD(f101)();
        STDMETHOD(f102)();
        STDMETHOD(f103)();
        STDMETHOD(f104)();
        STDMETHOD(f105)();
        STDMETHOD(f106)();
        STDMETHOD(f107)();
        STDMETHOD(f108)();
        STDMETHOD(f109)();
        STDMETHOD(f110)();
        STDMETHOD(f111)();
        STDMETHOD(f112)();
        STDMETHOD(f113)();
        STDMETHOD(f114)();
        STDMETHOD(f115)();
        STDMETHOD(f116)();
        STDMETHOD(f117)();
        STDMETHOD(f118)();
        STDMETHOD(f119)();
        STDMETHOD(f120)();
        STDMETHOD(f121)();
        STDMETHOD(f122)();
        STDMETHOD(f123)();
        STDMETHOD(f124)();
        STDMETHOD(f125)();
        STDMETHOD(f126)();
        STDMETHOD(f127)();
        STDMETHOD(f128)();
        STDMETHOD(f129)();
        STDMETHOD(f130)();
        STDMETHOD(f131)();
        STDMETHOD(f132)();
        STDMETHOD(f133)();
        STDMETHOD(f134)();
        STDMETHOD(f135)();
        STDMETHOD(f136)();
        STDMETHOD(f137)();
        STDMETHOD(f138)();
        STDMETHOD(f139)();
        STDMETHOD(f140)();
        STDMETHOD(f141)();
        STDMETHOD(f142)();
        STDMETHOD(f143)();
        STDMETHOD(f144)();
        STDMETHOD(f145)();
        STDMETHOD(f146)();
        STDMETHOD(f147)();
        STDMETHOD(f148)();
        STDMETHOD(f149)();
        STDMETHOD(f150)();
        STDMETHOD(f151)();
        STDMETHOD(f152)();
        STDMETHOD(f153)();
        STDMETHOD(f154)();
        STDMETHOD(f155)();
        STDMETHOD(f156)();
        STDMETHOD(f157)();
        STDMETHOD(f158)();
        STDMETHOD(f159)();
        STDMETHOD(f160)();
        STDMETHOD(f161)();
        STDMETHOD(f162)();
        STDMETHOD(f163)();
        STDMETHOD(f164)();
        STDMETHOD(f165)();
        STDMETHOD(f166)();
        STDMETHOD(f167)();
        STDMETHOD(f168)();
        STDMETHOD(f169)();
        STDMETHOD(f170)();
        STDMETHOD(f171)();
        STDMETHOD(f172)();
        STDMETHOD(f173)();
        STDMETHOD(f174)();
        STDMETHOD(f175)();
        STDMETHOD(f176)();
        STDMETHOD(f177)();
        STDMETHOD(f178)();
        STDMETHOD(f179)();
        STDMETHOD(f180)();
        STDMETHOD(f181)();
        STDMETHOD(f182)();
        STDMETHOD(f183)();
        STDMETHOD(f184)();
        STDMETHOD(f185)();
        STDMETHOD(f186)();
        STDMETHOD(f187)();
        STDMETHOD(f188)();
        STDMETHOD(f189)();
        STDMETHOD(f190)();
        STDMETHOD(f191)();
        STDMETHOD(f192)();
        STDMETHOD(f193)();
        STDMETHOD(f194)();
        STDMETHOD(f195)();
        STDMETHOD(f196)();
        STDMETHOD(f197)();
        STDMETHOD(f198)();
        STDMETHOD(f199)();
        STDMETHOD(f200)();
        STDMETHOD(f201)();
        STDMETHOD(f202)();
        STDMETHOD(f203)();
        STDMETHOD(f204)();
        STDMETHOD(f205)();
        STDMETHOD(f206)();
        STDMETHOD(f207)();
        STDMETHOD(f208)();
        STDMETHOD(f209)();
        STDMETHOD(f210)();
        STDMETHOD(f211)();
        STDMETHOD(f212)();
        STDMETHOD(f213)();
        STDMETHOD(f214)();
        STDMETHOD(f215)();
        STDMETHOD(f216)();
        STDMETHOD(f217)();
        STDMETHOD(f218)();
        STDMETHOD(f219)();
        STDMETHOD(f220)();
        STDMETHOD(f221)();
        STDMETHOD(f222)();
        STDMETHOD(f223)();
        STDMETHOD(f224)();
        STDMETHOD(f225)();
        STDMETHOD(f226)();
        STDMETHOD(f227)();
        STDMETHOD(f228)();
        STDMETHOD(f229)();
        STDMETHOD(f230)();
        STDMETHOD(f231)();
        STDMETHOD(f232)();
        STDMETHOD(f233)();
        STDMETHOD(f234)();
        STDMETHOD(f235)();
        STDMETHOD(f236)();
        STDMETHOD(f237)();
        STDMETHOD(f238)();
        STDMETHOD(f239)();
        STDMETHOD(f240)();
        STDMETHOD(f241)();
        STDMETHOD(f242)();
        STDMETHOD(f243)();
        STDMETHOD(f244)();
        STDMETHOD(f245)();
        STDMETHOD(f246)();
        STDMETHOD(f247)();
        STDMETHOD(f248)();
        STDMETHOD(f249)();
        STDMETHOD(f250)();
        STDMETHOD(f251)();
        STDMETHOD(f252)();
        STDMETHOD(f253)();
        STDMETHOD(f254)();
        STDMETHOD(f255)();
        STDMETHOD(f256)();
        STDMETHOD(f257)();
        STDMETHOD(f258)();
        STDMETHOD(f259)();
        STDMETHOD(f260)();
        STDMETHOD(f261)();
        STDMETHOD(f262)();
        STDMETHOD(f263)();
        STDMETHOD(f264)();
        STDMETHOD(f265)();
        STDMETHOD(f266)();
        STDMETHOD(f267)();
        STDMETHOD(f268)();
        STDMETHOD(f269)();
        STDMETHOD(f270)();
        STDMETHOD(f271)();
        STDMETHOD(f272)();
        STDMETHOD(f273)();
        STDMETHOD(f274)();
        STDMETHOD(f275)();
        STDMETHOD(f276)();
        STDMETHOD(f277)();
        STDMETHOD(f278)();
        STDMETHOD(f279)();
        STDMETHOD(f280)();
        STDMETHOD(f281)();
        STDMETHOD(f282)();
        STDMETHOD(f283)();
        STDMETHOD(f284)();
        STDMETHOD(f285)();
        STDMETHOD(f286)();
        STDMETHOD(f287)();
        STDMETHOD(f288)();
        STDMETHOD(f289)();
        STDMETHOD(f290)();
        STDMETHOD(f291)();
        STDMETHOD(f292)();
        STDMETHOD(f293)();
        STDMETHOD(f294)();
        STDMETHOD(f295)();
        STDMETHOD(f296)();
        STDMETHOD(f297)();
        STDMETHOD(f298)();
        STDMETHOD(f299)();
        STDMETHOD(f300)();
        STDMETHOD(f301)();
        STDMETHOD(f302)();
        STDMETHOD(f303)();
        STDMETHOD(f304)();
        STDMETHOD(f305)();
        STDMETHOD(f306)();
        STDMETHOD(f307)();
        STDMETHOD(f308)();
        STDMETHOD(f309)();
        STDMETHOD(f310)();
        STDMETHOD(f311)();
        STDMETHOD(f312)();
        STDMETHOD(f313)();
        STDMETHOD(f314)();
        STDMETHOD(f315)();
        STDMETHOD(f316)();
        STDMETHOD(f317)();
        STDMETHOD(f318)();
        STDMETHOD(f319)();
        STDMETHOD(f320)();
        STDMETHOD(f321)();
        STDMETHOD(f322)();
        STDMETHOD(f323)();
        STDMETHOD(f324)();
        STDMETHOD(f325)();
        STDMETHOD(f326)();
        STDMETHOD(f327)();
        STDMETHOD(f328)();
        STDMETHOD(f329)();
        STDMETHOD(f330)();
        STDMETHOD(f331)();
        STDMETHOD(f332)();
        STDMETHOD(f333)();
        STDMETHOD(f334)();
        STDMETHOD(f335)();
        STDMETHOD(f336)();
        STDMETHOD(f337)();
        STDMETHOD(f338)();
        STDMETHOD(f339)();
        STDMETHOD(f340)();
        STDMETHOD(f341)();
        STDMETHOD(f342)();
        STDMETHOD(f343)();
        STDMETHOD(f344)();
        STDMETHOD(f345)();
        STDMETHOD(f346)();
        STDMETHOD(f347)();
        STDMETHOD(f348)();
        STDMETHOD(f349)();
        STDMETHOD(f350)();
        STDMETHOD(f351)();
        STDMETHOD(f352)();
        STDMETHOD(f353)();
        STDMETHOD(f354)();
        STDMETHOD(f355)();
        STDMETHOD(f356)();
        STDMETHOD(f357)();
        STDMETHOD(f358)();
        STDMETHOD(f359)();
        STDMETHOD(f360)();
        STDMETHOD(f361)();
        STDMETHOD(f362)();
        STDMETHOD(f363)();
        STDMETHOD(f364)();
        STDMETHOD(f365)();
        STDMETHOD(f366)();
        STDMETHOD(f367)();
        STDMETHOD(f368)();
        STDMETHOD(f369)();
        STDMETHOD(f370)();
        STDMETHOD(f371)();
        STDMETHOD(f372)();
        STDMETHOD(f373)();
        STDMETHOD(f374)();
        STDMETHOD(f375)();
        STDMETHOD(f376)();
        STDMETHOD(f377)();
        STDMETHOD(f378)();
        STDMETHOD(f379)();
        STDMETHOD(f380)();
        STDMETHOD(f381)();
        STDMETHOD(f382)();
        STDMETHOD(f383)();
        STDMETHOD(f384)();
        STDMETHOD(f385)();
        STDMETHOD(f386)();
        STDMETHOD(f387)();
        STDMETHOD(f388)();
        STDMETHOD(f389)();
        STDMETHOD(f390)();
        STDMETHOD(f391)();
        STDMETHOD(f392)();
        STDMETHOD(f393)();
        STDMETHOD(f394)();
        STDMETHOD(f395)();
        STDMETHOD(f396)();
        STDMETHOD(f397)();
        STDMETHOD(f398)();
        STDMETHOD(f399)();
        STDMETHOD(f400)();
        STDMETHOD(f401)();
        STDMETHOD(f402)();
        STDMETHOD(f403)();
        STDMETHOD(f404)();
        STDMETHOD(f405)();
        STDMETHOD(f406)();
        STDMETHOD(f407)();
        STDMETHOD(f408)();
        STDMETHOD(f409)();
        STDMETHOD(f410)();
        STDMETHOD(f411)();
        STDMETHOD(f412)();
        STDMETHOD(f413)();
        STDMETHOD(f414)();
        STDMETHOD(f415)();
        STDMETHOD(f416)();
        STDMETHOD(f417)();
        STDMETHOD(f418)();
        STDMETHOD(f419)();
        STDMETHOD(f420)();
        STDMETHOD(f421)();
        STDMETHOD(f422)();
        STDMETHOD(f423)();
        STDMETHOD(f424)();
        STDMETHOD(f425)();
        STDMETHOD(f426)();
        STDMETHOD(f427)();
        STDMETHOD(f428)();
        STDMETHOD(f429)();
        STDMETHOD(f430)();
        STDMETHOD(f431)();
        STDMETHOD(f432)();
        STDMETHOD(f433)();
        STDMETHOD(f434)();
        STDMETHOD(f435)();
        STDMETHOD(f436)();
        STDMETHOD(f437)();
        STDMETHOD(f438)();
        STDMETHOD(f439)();
        STDMETHOD(f440)();
        STDMETHOD(f441)();
        STDMETHOD(f442)();
        STDMETHOD(f443)();
        STDMETHOD(f444)();
        STDMETHOD(f445)();
        STDMETHOD(f446)();
        STDMETHOD(f447)();
        STDMETHOD(f448)();
        STDMETHOD(f449)();
        STDMETHOD(f450)();
        STDMETHOD(f451)();
        STDMETHOD(f452)();
        STDMETHOD(f453)();
        STDMETHOD(f454)();
        STDMETHOD(f455)();
        STDMETHOD(f456)();
        STDMETHOD(f457)();
        STDMETHOD(f458)();
        STDMETHOD(f459)();
        STDMETHOD(f460)();
        STDMETHOD(f461)();
        STDMETHOD(f462)();
        STDMETHOD(f463)();
        STDMETHOD(f464)();
        STDMETHOD(f465)();
        STDMETHOD(f466)();
        STDMETHOD(f467)();
        STDMETHOD(f468)();
        STDMETHOD(f469)();
        STDMETHOD(f470)();
        STDMETHOD(f471)();
        STDMETHOD(f472)();
        STDMETHOD(f473)();
        STDMETHOD(f474)();
        STDMETHOD(f475)();
        STDMETHOD(f476)();
        STDMETHOD(f477)();
        STDMETHOD(f478)();
        STDMETHOD(f479)();
        STDMETHOD(f480)();
        STDMETHOD(f481)();
        STDMETHOD(f482)();
        STDMETHOD(f483)();
        STDMETHOD(f484)();
        STDMETHOD(f485)();
        STDMETHOD(f486)();
        STDMETHOD(f487)();
        STDMETHOD(f488)();
        STDMETHOD(f489)();
        STDMETHOD(f490)();
        STDMETHOD(f491)();
        STDMETHOD(f492)();
        STDMETHOD(f493)();
        STDMETHOD(f494)();
        STDMETHOD(f495)();
        STDMETHOD(f496)();
        STDMETHOD(f497)();
        STDMETHOD(f498)();
        STDMETHOD(f499)();
        STDMETHOD(f500)();
        STDMETHOD(f501)();
        STDMETHOD(f502)();
        STDMETHOD(f503)();
        STDMETHOD(f504)();
        STDMETHOD(f505)();
        STDMETHOD(f506)();
        STDMETHOD(f507)();
        STDMETHOD(f508)();
        STDMETHOD(f509)();
        STDMETHOD(f510)();
        STDMETHOD(f511)();
        STDMETHOD(f512)();
        STDMETHOD(f513)();
        STDMETHOD(f514)();
        STDMETHOD(f515)();
        STDMETHOD(f516)();
        STDMETHOD(f517)();
        STDMETHOD(f518)();
        STDMETHOD(f519)();
        STDMETHOD(f520)();
        STDMETHOD(f521)();
        STDMETHOD(f522)();
        STDMETHOD(f523)();
        STDMETHOD(f524)();
        STDMETHOD(f525)();
        STDMETHOD(f526)();
        STDMETHOD(f527)();
        STDMETHOD(f528)();
        STDMETHOD(f529)();
        STDMETHOD(f530)();
        STDMETHOD(f531)();
        STDMETHOD(f532)();
        STDMETHOD(f533)();
        STDMETHOD(f534)();
        STDMETHOD(f535)();
        STDMETHOD(f536)();
        STDMETHOD(f537)();
        STDMETHOD(f538)();
        STDMETHOD(f539)();
        STDMETHOD(f540)();
        STDMETHOD(f541)();
        STDMETHOD(f542)();
        STDMETHOD(f543)();
        STDMETHOD(f544)();
        STDMETHOD(f545)();
        STDMETHOD(f546)();
        STDMETHOD(f547)();
        STDMETHOD(f548)();
        STDMETHOD(f549)();
        STDMETHOD(f550)();
        STDMETHOD(f551)();
        STDMETHOD(f552)();
        STDMETHOD(f553)();
        STDMETHOD(f554)();
        STDMETHOD(f555)();
        STDMETHOD(f556)();
        STDMETHOD(f557)();
        STDMETHOD(f558)();
        STDMETHOD(f559)();
        STDMETHOD(f560)();
        STDMETHOD(f561)();
        STDMETHOD(f562)();
        STDMETHOD(f563)();
        STDMETHOD(f564)();
        STDMETHOD(f565)();
        STDMETHOD(f566)();
        STDMETHOD(f567)();
        STDMETHOD(f568)();
        STDMETHOD(f569)();
        STDMETHOD(f570)();
        STDMETHOD(f571)();
        STDMETHOD(f572)();
        STDMETHOD(f573)();
        STDMETHOD(f574)();
        STDMETHOD(f575)();
        STDMETHOD(f576)();
        STDMETHOD(f577)();
        STDMETHOD(f578)();
        STDMETHOD(f579)();
        STDMETHOD(f580)();
        STDMETHOD(f581)();
        STDMETHOD(f582)();
        STDMETHOD(f583)();
        STDMETHOD(f584)();
        STDMETHOD(f585)();
        STDMETHOD(f586)();
        STDMETHOD(f587)();
        STDMETHOD(f588)();
        STDMETHOD(f589)();
        STDMETHOD(f590)();
        STDMETHOD(f591)();
        STDMETHOD(f592)();
        STDMETHOD(f593)();
        STDMETHOD(f594)();
        STDMETHOD(f595)();
        STDMETHOD(f596)();
        STDMETHOD(f597)();
        STDMETHOD(f598)();
        STDMETHOD(f599)();
        STDMETHOD(f600)();
        STDMETHOD(f601)();
        STDMETHOD(f602)();
        STDMETHOD(f603)();
        STDMETHOD(f604)();
        STDMETHOD(f605)();
        STDMETHOD(f606)();
        STDMETHOD(f607)();
        STDMETHOD(f608)();
        STDMETHOD(f609)();
        STDMETHOD(f610)();
        STDMETHOD(f611)();
        STDMETHOD(f612)();
        STDMETHOD(f613)();
        STDMETHOD(f614)();
        STDMETHOD(f615)();
        STDMETHOD(f616)();
        STDMETHOD(f617)();
        STDMETHOD(f618)();
        STDMETHOD(f619)();
        STDMETHOD(f620)();
        STDMETHOD(f621)();
        STDMETHOD(f622)();
        STDMETHOD(f623)();
        STDMETHOD(f624)();
        STDMETHOD(f625)();
        STDMETHOD(f626)();
        STDMETHOD(f627)();
        STDMETHOD(f628)();
        STDMETHOD(f629)();
        STDMETHOD(f630)();
        STDMETHOD(f631)();
        STDMETHOD(f632)();
        STDMETHOD(f633)();
        STDMETHOD(f634)();
        STDMETHOD(f635)();
        STDMETHOD(f636)();
        STDMETHOD(f637)();
        STDMETHOD(f638)();
        STDMETHOD(f639)();
        STDMETHOD(f640)();
        STDMETHOD(f641)();
        STDMETHOD(f642)();
        STDMETHOD(f643)();
        STDMETHOD(f644)();
        STDMETHOD(f645)();
        STDMETHOD(f646)();
        STDMETHOD(f647)();
        STDMETHOD(f648)();
        STDMETHOD(f649)();
        STDMETHOD(f650)();
        STDMETHOD(f651)();
        STDMETHOD(f652)();
        STDMETHOD(f653)();
        STDMETHOD(f654)();
        STDMETHOD(f655)();
        STDMETHOD(f656)();
        STDMETHOD(f657)();
        STDMETHOD(f658)();
        STDMETHOD(f659)();
        STDMETHOD(f660)();
        STDMETHOD(f661)();
        STDMETHOD(f662)();
        STDMETHOD(f663)();
        STDMETHOD(f664)();
        STDMETHOD(f665)();
        STDMETHOD(f666)();
        STDMETHOD(f667)();
        STDMETHOD(f668)();
        STDMETHOD(f669)();
        STDMETHOD(f670)();
        STDMETHOD(f671)();
        STDMETHOD(f672)();
        STDMETHOD(f673)();
        STDMETHOD(f674)();
        STDMETHOD(f675)();
        STDMETHOD(f676)();
        STDMETHOD(f677)();
        STDMETHOD(f678)();
        STDMETHOD(f679)();
        STDMETHOD(f680)();
        STDMETHOD(f681)();
        STDMETHOD(f682)();
        STDMETHOD(f683)();
        STDMETHOD(f684)();
        STDMETHOD(f685)();
        STDMETHOD(f686)();
        STDMETHOD(f687)();
        STDMETHOD(f688)();
        STDMETHOD(f689)();
        STDMETHOD(f690)();
        STDMETHOD(f691)();
        STDMETHOD(f692)();
        STDMETHOD(f693)();
        STDMETHOD(f694)();
        STDMETHOD(f695)();
        STDMETHOD(f696)();
        STDMETHOD(f697)();
        STDMETHOD(f698)();
        STDMETHOD(f699)();
        STDMETHOD(f700)();
        STDMETHOD(f701)();
        STDMETHOD(f702)();
        STDMETHOD(f703)();
        STDMETHOD(f704)();
        STDMETHOD(f705)();
        STDMETHOD(f706)();
        STDMETHOD(f707)();
        STDMETHOD(f708)();
        STDMETHOD(f709)();
        STDMETHOD(f710)();
        STDMETHOD(f711)();
        STDMETHOD(f712)();
        STDMETHOD(f713)();
        STDMETHOD(f714)();
        STDMETHOD(f715)();
        STDMETHOD(f716)();
        STDMETHOD(f717)();
        STDMETHOD(f718)();
        STDMETHOD(f719)();
        STDMETHOD(f720)();
        STDMETHOD(f721)();
        STDMETHOD(f722)();
        STDMETHOD(f723)();
        STDMETHOD(f724)();
        STDMETHOD(f725)();
        STDMETHOD(f726)();
        STDMETHOD(f727)();
        STDMETHOD(f728)();
        STDMETHOD(f729)();
        STDMETHOD(f730)();
        STDMETHOD(f731)();
        STDMETHOD(f732)();
        STDMETHOD(f733)();
        STDMETHOD(f734)();
        STDMETHOD(f735)();
        STDMETHOD(f736)();
        STDMETHOD(f737)();
        STDMETHOD(f738)();
        STDMETHOD(f739)();
        STDMETHOD(f740)();
        STDMETHOD(f741)();
        STDMETHOD(f742)();
        STDMETHOD(f743)();
        STDMETHOD(f744)();
        STDMETHOD(f745)();
        STDMETHOD(f746)();
        STDMETHOD(f747)();
        STDMETHOD(f748)();
        STDMETHOD(f749)();
        STDMETHOD(f750)();
        STDMETHOD(f751)();
        STDMETHOD(f752)();
        STDMETHOD(f753)();
        STDMETHOD(f754)();
        STDMETHOD(f755)();
        STDMETHOD(f756)();
        STDMETHOD(f757)();
        STDMETHOD(f758)();
        STDMETHOD(f759)();
        STDMETHOD(f760)();
        STDMETHOD(f761)();
        STDMETHOD(f762)();
        STDMETHOD(f763)();
        STDMETHOD(f764)();
        STDMETHOD(f765)();
        STDMETHOD(f766)();
        STDMETHOD(f767)();
        STDMETHOD(f768)();
        STDMETHOD(f769)();
        STDMETHOD(f770)();
        STDMETHOD(f771)();
        STDMETHOD(f772)();
        STDMETHOD(f773)();
        STDMETHOD(f774)();
        STDMETHOD(f775)();
        STDMETHOD(f776)();
        STDMETHOD(f777)();
        STDMETHOD(f778)();
        STDMETHOD(f779)();
        STDMETHOD(f780)();
        STDMETHOD(f781)();
        STDMETHOD(f782)();
        STDMETHOD(f783)();
        STDMETHOD(f784)();
        STDMETHOD(f785)();
        STDMETHOD(f786)();
        STDMETHOD(f787)();
        STDMETHOD(f788)();
        STDMETHOD(f789)();
        STDMETHOD(f790)();
        STDMETHOD(f791)();
        STDMETHOD(f792)();
        STDMETHOD(f793)();
        STDMETHOD(f794)();
        STDMETHOD(f795)();
        STDMETHOD(f796)();
        STDMETHOD(f797)();
        STDMETHOD(f798)();
        STDMETHOD(f799)();
        STDMETHOD(f800)();
        STDMETHOD(f801)();
        STDMETHOD(f802)();
        STDMETHOD(f803)();
        STDMETHOD(f804)();
        STDMETHOD(f805)();
        STDMETHOD(f806)();
        STDMETHOD(f807)();
        STDMETHOD(f808)();
        STDMETHOD(f809)();
        STDMETHOD(f810)();
        STDMETHOD(f811)();
        STDMETHOD(f812)();
        STDMETHOD(f813)();
        STDMETHOD(f814)();
        STDMETHOD(f815)();
        STDMETHOD(f816)();
        STDMETHOD(f817)();
        STDMETHOD(f818)();
        STDMETHOD(f819)();
        STDMETHOD(f820)();
        STDMETHOD(f821)();
        STDMETHOD(f822)();
        STDMETHOD(f823)();
        STDMETHOD(f824)();
        STDMETHOD(f825)();
        STDMETHOD(f826)();
        STDMETHOD(f827)();
        STDMETHOD(f828)();
        STDMETHOD(f829)();
        STDMETHOD(f830)();
        STDMETHOD(f831)();
        STDMETHOD(f832)();
        STDMETHOD(f833)();
        STDMETHOD(f834)();
        STDMETHOD(f835)();
        STDMETHOD(f836)();
        STDMETHOD(f837)();
        STDMETHOD(f838)();
        STDMETHOD(f839)();
        STDMETHOD(f840)();
        STDMETHOD(f841)();
        STDMETHOD(f842)();
        STDMETHOD(f843)();
        STDMETHOD(f844)();
        STDMETHOD(f845)();
        STDMETHOD(f846)();
        STDMETHOD(f847)();
        STDMETHOD(f848)();
        STDMETHOD(f849)();
        STDMETHOD(f850)();
        STDMETHOD(f851)();
        STDMETHOD(f852)();
        STDMETHOD(f853)();
        STDMETHOD(f854)();
        STDMETHOD(f855)();
        STDMETHOD(f856)();
        STDMETHOD(f857)();
        STDMETHOD(f858)();
        STDMETHOD(f859)();
        STDMETHOD(f860)();
        STDMETHOD(f861)();
        STDMETHOD(f862)();
        STDMETHOD(f863)();
        STDMETHOD(f864)();
        STDMETHOD(f865)();
        STDMETHOD(f866)();
        STDMETHOD(f867)();
        STDMETHOD(f868)();
        STDMETHOD(f869)();
        STDMETHOD(f870)();
        STDMETHOD(f871)();
        STDMETHOD(f872)();
        STDMETHOD(f873)();
        STDMETHOD(f874)();
        STDMETHOD(f875)();
        STDMETHOD(f876)();
        STDMETHOD(f877)();
        STDMETHOD(f878)();
        STDMETHOD(f879)();
        STDMETHOD(f880)();
        STDMETHOD(f881)();
        STDMETHOD(f882)();
        STDMETHOD(f883)();
        STDMETHOD(f884)();
        STDMETHOD(f885)();
        STDMETHOD(f886)();
        STDMETHOD(f887)();
        STDMETHOD(f888)();
        STDMETHOD(f889)();
        STDMETHOD(f890)();
        STDMETHOD(f891)();
        STDMETHOD(f892)();
        STDMETHOD(f893)();
        STDMETHOD(f894)();
        STDMETHOD(f895)();
        STDMETHOD(f896)();
        STDMETHOD(f897)();
        STDMETHOD(f898)();
        STDMETHOD(f899)();
        STDMETHOD(f900)();
        STDMETHOD(f901)();
        STDMETHOD(f902)();
        STDMETHOD(f903)();
        STDMETHOD(f904)();
        STDMETHOD(f905)();
        STDMETHOD(f906)();
        STDMETHOD(f907)();
        STDMETHOD(f908)();
        STDMETHOD(f909)();
        STDMETHOD(f910)();
        STDMETHOD(f911)();
        STDMETHOD(f912)();
        STDMETHOD(f913)();
        STDMETHOD(f914)();
        STDMETHOD(f915)();
        STDMETHOD(f916)();
        STDMETHOD(f917)();
        STDMETHOD(f918)();
        STDMETHOD(f919)();
        STDMETHOD(f920)();
        STDMETHOD(f921)();
        STDMETHOD(f922)();
        STDMETHOD(f923)();
        STDMETHOD(f924)();
        STDMETHOD(f925)();
        STDMETHOD(f926)();
        STDMETHOD(f927)();
        STDMETHOD(f928)();
        STDMETHOD(f929)();
        STDMETHOD(f930)();
        STDMETHOD(f931)();
        STDMETHOD(f932)();
        STDMETHOD(f933)();
        STDMETHOD(f934)();
        STDMETHOD(f935)();
        STDMETHOD(f936)();
        STDMETHOD(f937)();
        STDMETHOD(f938)();
        STDMETHOD(f939)();
        STDMETHOD(f940)();
        STDMETHOD(f941)();
        STDMETHOD(f942)();
        STDMETHOD(f943)();
        STDMETHOD(f944)();
        STDMETHOD(f945)();
        STDMETHOD(f946)();
        STDMETHOD(f947)();
        STDMETHOD(f948)();
        STDMETHOD(f949)();
        STDMETHOD(f950)();
        STDMETHOD(f951)();
        STDMETHOD(f952)();
        STDMETHOD(f953)();
        STDMETHOD(f954)();
        STDMETHOD(f955)();
        STDMETHOD(f956)();
        STDMETHOD(f957)();
        STDMETHOD(f958)();
        STDMETHOD(f959)();
        STDMETHOD(f960)();
        STDMETHOD(f961)();
        STDMETHOD(f962)();
        STDMETHOD(f963)();
        STDMETHOD(f964)();
        STDMETHOD(f965)();
        STDMETHOD(f966)();
        STDMETHOD(f967)();
        STDMETHOD(f968)();
        STDMETHOD(f969)();
        STDMETHOD(f970)();
        STDMETHOD(f971)();
        STDMETHOD(f972)();
        STDMETHOD(f973)();
        STDMETHOD(f974)();
        STDMETHOD(f975)();
        STDMETHOD(f976)();
        STDMETHOD(f977)();
        STDMETHOD(f978)();
        STDMETHOD(f979)();
        STDMETHOD(f980)();
        STDMETHOD(f981)();
        STDMETHOD(f982)();
        STDMETHOD(f983)();
        STDMETHOD(f984)();
        STDMETHOD(f985)();
        STDMETHOD(f986)();
        STDMETHOD(f987)();
        STDMETHOD(f988)();
        STDMETHOD(f989)();
        STDMETHOD(f990)();
        STDMETHOD(f991)();
        STDMETHOD(f992)();
        STDMETHOD(f993)();
        STDMETHOD(f994)();
        STDMETHOD(f995)();
        STDMETHOD(f996)();
        STDMETHOD(f997)();
        STDMETHOD(f998)();
        STDMETHOD(f999)();
        STDMETHOD(f1000)();
        STDMETHOD(f1001)();
        STDMETHOD(f1002)();
        STDMETHOD(f1003)();
        STDMETHOD(f1004)();
        STDMETHOD(f1005)();
        STDMETHOD(f1006)();
        STDMETHOD(f1007)();
        STDMETHOD(f1008)();
        STDMETHOD(f1009)();
        STDMETHOD(f1010)();
        STDMETHOD(f1011)();
        STDMETHOD(f1012)();
        STDMETHOD(f1013)();
        STDMETHOD(f1014)();
        STDMETHOD(f1015)();
        STDMETHOD(f1016)();
        STDMETHOD(f1017)();
        STDMETHOD(f1018)();
        STDMETHOD(f1019)();
        STDMETHOD(f1020)();
        STDMETHOD(f1021)();
        STDMETHOD(f1022)();
        STDMETHOD(f1023)();
#ifndef _WIN64
        STDMETHOD(f1024)();
#endif
        _QIThunk(IUnknown* pOrig, LPCTSTR p, const IID& i, UINT n, bool b)
        {
                lpszClassName = p;
                iid = i;
                nIndex = n;
                m_dwRef = 0;
                m_dwMaxRef = 0;
                pUnk = pOrig;
                bBreak = b;
                bNonAddRefThunk = false;
        }
        IUnknown* pUnk;
        long m_dwRef;
        long m_dwMaxRef;
        LPCTSTR lpszClassName;
        IID iid;
        UINT nIndex;
        bool bBreak;
        bool bNonAddRefThunk;
        void Dump()
        {
                TCHAR buf[256];
                if (m_dwRef != 0)
                {
                        wsprintf(buf, _T("INTERFACE LEAK: RefCount = %d, MaxRefCount = %d, {Allocation = %d} "), m_dwRef, m_dwMaxRef, nIndex);
                        OutputDebugString(buf);
                        AtlDumpIID(iid, lpszClassName, S_OK);
                }
                else
                {
                        wsprintf(buf, _T("NonAddRef Thunk LEAK: {Allocation = %d}\n"), nIndex);
                        OutputDebugString(buf);
                }
        }
};
#endif


/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

template <class T>
class CSimpleArray
{
public:
        T* m_aT;
        int m_nSize;
        int m_nAllocSize;

// Construction/destruction
        CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
        { }

        ~CSimpleArray()
        {
                RemoveAll();
        }

// Operations
        int GetSize() const
        {
                return m_nSize;
        }
        BOOL Add(T& t)
        {
                if(m_nSize == m_nAllocSize)
                {
                        T* aT;
                        int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
                        aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
                        if(aT == NULL)
                                return FALSE;
                        m_nAllocSize = nNewAllocSize;
                        m_aT = aT;
                }
                m_nSize++;
                SetAtIndex(m_nSize - 1, t);
                return TRUE;
        }
        BOOL Remove(T& t)
        {
                int nIndex = Find(t);
                if(nIndex == -1)
                        return FALSE;
                return RemoveAt(nIndex);
        }
        BOOL RemoveAt(int nIndex)
        {

                //---- always call the dtr ----
#if _MSC_VER >= 1200
                m_aT[nIndex].~T();
#else
                T* MyT;
                MyT = &m_aT[nIndex];
                MyT->~T();
#endif

                //---- if target entry is not at end, compact the array ----
                if(nIndex != (m_nSize - 1))
                {
                        
                        memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
                }

                m_nSize--;
                return TRUE;
        }
        void RemoveAll()
        {
                if(m_aT != NULL)
                {
                        for(int i = 0; i < m_nSize; i++) {
#if _MSC_VER >= 1200
                                m_aT[i].~T();
#else
                T* MyT;
                MyT = &m_aT[i];
                MyT->~T();
#endif
            }
                        free(m_aT);
                        m_aT = NULL;
                }
                m_nSize = 0;
                m_nAllocSize = 0;
        }
        T& operator[] (int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_aT[nIndex];
        }
        T* GetData() const
        {
                return m_aT;
        }

// Implementation
        class Wrapper
        {
        public:
                Wrapper(T& _t) : t(_t)
                {
                }
                template <class _Ty>
                void *operator new(size_t, _Ty* p)
                {
                        return p;
                }
                T t;
        };
        void SetAtIndex(int nIndex, T& t)
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                new(m_aT + nIndex) Wrapper(t);
        }
        int Find(T& t) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aT[i] == t)
                                return i;
                }
                return -1;  // not found
        }
};

// for arrays of simple types
template <class T>
class CSimpleValArray : public CSimpleArray< T >
{
public:
        BOOL Add(T t)
        {
                return CSimpleArray< T >::Add(t);
        }
        BOOL Remove(T t)
        {
                return CSimpleArray< T >::Remove(t);
        }
        T operator[] (int nIndex) const
        {
                return CSimpleArray< T >::operator[](nIndex);
        }
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
        TKey* m_aKey;
        TVal* m_aVal;
        int m_nSize;

// Construction/destruction
        CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
        { }

        ~CSimpleMap()
        {
                RemoveAll();
        }

// Operations
        int GetSize() const
        {
                return m_nSize;
        }
        BOOL Add(TKey key, TVal val)
        {
                TKey* pKey;
                pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
                if(pKey == NULL)
                        return FALSE;
                m_aKey = pKey;
                TVal* pVal;
                pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
                if(pVal == NULL)
                        return FALSE;
                m_aVal = pVal;
                m_nSize++;
                SetAtIndex(m_nSize - 1, key, val);
                return TRUE;
        }
        BOOL Remove(TKey key)
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return FALSE;
                if(nIndex != (m_nSize - 1))
                {
                        m_aKey[nIndex].~TKey();
#if _MSC_VER >= 1200
            m_aVal[nIndex].~TVal();
#else
            TVal * t1;
            t1 = &m_aVal[nIndex];
            t1->~TVal();
#endif
                        memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
                        memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
                }
                TKey* pKey;
                pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
                if(pKey != NULL || m_nSize == 1)
                        m_aKey = pKey;
                TVal* pVal;
                pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
                if(pVal != NULL || m_nSize == 1)
                        m_aVal = pVal;
                m_nSize--;
                return TRUE;
        }
        void RemoveAll()
        {
                if(m_aKey != NULL)
                {
                        for(int i = 0; i < m_nSize; i++)
                        {
                                m_aKey[i].~TKey();
#if _MSC_VER >= 1200
                                m_aVal[i].~TVal();
#else
                TVal * t1;
                t1 = &m_aVal[i];
                t1->~TVal();
#endif
                        }
                        free(m_aKey);
                        m_aKey = NULL;
                }
                if(m_aVal != NULL)
                {
                        free(m_aVal);
                        m_aVal = NULL;
                }

                m_nSize = 0;
        }
        BOOL SetAt(TKey key, TVal val)
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return FALSE;
                SetAtIndex(nIndex, key, val);
                return TRUE;
        }
        TVal Lookup(TKey key) const
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return NULL;    // must be able to convert
                return GetValueAt(nIndex);
        }
        TKey ReverseLookup(TVal val) const
        {
                int nIndex = FindVal(val);
                if(nIndex == -1)
                        return NULL;    // must be able to convert
                return GetKeyAt(nIndex);
        }
        TKey& GetKeyAt(int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_aKey[nIndex];
        }
        TVal& GetValueAt(int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_aVal[nIndex];
        }

// Implementation

        template <typename T>
        class Wrapper
        {
        public:
                Wrapper(T& _t) : t(_t)
                {
                }
                template <typename _Ty>
                void *operator new(size_t, _Ty* p)
                {
                        return p;
                }
                T t;
        };
        void SetAtIndex(int nIndex, TKey& key, TVal& val)
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                new(m_aKey + nIndex) Wrapper<TKey>(key);
                new(m_aVal + nIndex) Wrapper<TVal>(val);
        }
        int FindKey(TKey& key) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aKey[i] == key)
                                return i;
                }
                return -1;  // not found
        }
        int FindVal(TVal& val) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aVal[i] == val)
                                return i;
                }
                return -1;  // not found
        }
};


class CComModule;
__declspec(selectany) CComModule* _pModule=NULL;

// {B62F5910-6528-11d1-9611-0000F81E0D0D}
_declspec(selectany) GUID GUID_ATLVer30 = { 0xb62f5910, 0x6528, 0x11d1, { 0x96, 0x11, 0x0, 0x0, 0xf8, 0x1e, 0xd, 0xd } };

class CComModule : public _ATL_MODULE
{
// Operations
public:
        static GUID m_libid;
#ifdef _ATL_DEBUG_INTERFACES
        UINT m_nIndexQI;
        UINT m_nIndexBreakAt;
        CSimpleArray<_QIThunk*>* m_paThunks;
#endif // _ATL_DEBUG_INTERFACES

        void AddCreateWndData(_AtlCreateWndData* pData, void* pObject)
        {
                AtlModuleAddCreateWndData(this, pData, pObject);
        }
        void* ExtractCreateWndData()
        {
                return AtlModuleExtractCreateWndData(this);
        }

#if _ATL_VER > 0x0300
        LONG GetNextWindowID()
        {
                LONG nID;

                nID = InterlockedIncrement(&m_nNextWindowID);

                return nID;
        }
#endif

        HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL)
        {
                pguidVer = &GUID_ATLVer30;
                _pModule = this;
                cbSize = sizeof(_ATL_MODULE);
                dwAtlBuildVer = _ATL_VER;
                AtlModuleInit(this, p, h);
                if (plibid != NULL)
                        memcpy((void*)&m_libid, plibid, sizeof(GUID));
#if _ATL_VER > 0x0300
                m_nNextWindowID = 1;
#endif
#ifdef _ATL_MIN_CRT
                // Create a base heap
                m_hHeap = HeapCreate(0, 0, 0);

#ifndef _ATL_NO_MP_HEAP
                SYSTEM_INFO si;
                GetSystemInfo(&si);
                if (si.dwNumberOfProcessors > 1)
                {
                        DWORD dwHeaps = si.dwNumberOfProcessors * 2;
                        m_dwHeaps = 0xFFFFFFFF;
                        for (int bits = 0; bits < 32; bits++)
                        {
                                if (dwHeaps & 0x80000000)
                                        break;
                                dwHeaps <<= 1;
                                m_dwHeaps >>= 1;
                        }
                        m_dwHeaps >>= 1;

                        // Allocate more heaps for each processor
                        m_phHeaps = (HANDLE*) HeapAlloc(m_hHeap, _ATL_HEAPFLAGS, sizeof(HANDLE) * (m_dwHeaps + 1));
                        for (DWORD i = 0; i <= m_dwHeaps; i++)
                                m_phHeaps[i] = HeapCreate(0, 0, 0);
                }
                else
#endif
                {
                        m_phHeaps = NULL;
                        m_dwHeaps = 0;
                }
#endif
#ifdef _ATL_DEBUG_INTERFACES
                m_nIndexQI = 0;
                m_nIndexBreakAt = 0;
                m_paThunks = NULL;
                ATLTRY(m_paThunks = new CSimpleArray<_QIThunk*>);
                if (m_paThunks == NULL)
                        return E_OUTOFMEMORY;
#endif // _ATL_DEBUG_INTERFACES
                return S_OK;
        }
#ifdef _ATL_DEBUG_INTERFACES
        HRESULT AddThunk(IUnknown** pp, LPCTSTR lpsz, REFIID iid)
        {
                if ((pp == NULL) || (*pp == NULL))
                        return E_POINTER;
                IUnknown* p = *pp;
                _QIThunk* pThunk = NULL;
                EnterCriticalSection(&m_csObjMap);
                // Check if exists already for identity
                if (InlineIsEqualUnknown(iid))
                {
                        for (int i = 0; i < m_paThunks->GetSize(); i++)
                        {
                                if (m_paThunks->operator[](i)->pUnk == p)
                                {
                                        m_paThunks->operator[](i)->InternalAddRef();
                                        pThunk = m_paThunks->operator[](i);
                                        break;
                                }
                        }
                }
                if (pThunk == NULL)
                {
                        ++m_nIndexQI;
                        if (m_nIndexBreakAt == m_nIndexQI)
                                DebugBreak();
                        ATLTRY(pThunk = new _QIThunk(p, lpsz, iid, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
                        if (pThunk == NULL)
                                return E_OUTOFMEMORY;
                        pThunk->InternalAddRef();
                        m_paThunks->Add(pThunk);
                }
                LeaveCriticalSection(&m_csObjMap);
                *pp = (IUnknown*)pThunk;
                return S_OK;
        }
        HRESULT AddNonAddRefThunk(IUnknown* p, LPCTSTR lpsz, IUnknown** ppThunkRet)
        {
                _QIThunk* pThunk = NULL;
                EnterCriticalSection(&m_csObjMap);
                // Check if exists already for identity
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        if (m_paThunks->operator[](i)->pUnk == p)
                        {
                                m_paThunks->operator[](i)->bNonAddRefThunk = true;
                                pThunk = m_paThunks->operator[](i);
                                break;
                        }
                }
                if (pThunk == NULL)
                {
                        ++m_nIndexQI;
                        if (m_nIndexBreakAt == m_nIndexQI)
                                DebugBreak();
                        ATLTRY(pThunk = new _QIThunk(p, lpsz, IID_IUnknown, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
                        if (pThunk == NULL)
                        {
                                *ppThunkRet = NULL;
                                return E_OUTOFMEMORY;
                        }
                        pThunk->bNonAddRefThunk = true;
                        m_paThunks->Add(pThunk);
                }
                LeaveCriticalSection(&m_csObjMap);
                *ppThunkRet = (IUnknown*)pThunk;
                return S_OK;;
        }
        void DeleteNonAddRefThunk(IUnknown* pUnk)
        {
                EnterCriticalSection(&m_csObjMap);
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        if (m_paThunks->operator[](i)->pUnk == pUnk)
                        {
                                delete m_paThunks->operator[](i);
                                m_paThunks->RemoveAt(i);
                                break;
                        }
                }
                LeaveCriticalSection(&m_csObjMap);
        }
        void DeleteThunk(_QIThunk* p)
        {
                EnterCriticalSection(&m_csObjMap);
                int nIndex = m_paThunks->Find(p);
                if (nIndex != -1)
                {
                        delete m_paThunks->operator[](nIndex);
                        m_paThunks->RemoveAt(nIndex);
                }
                LeaveCriticalSection(&m_csObjMap);
        }
        bool DumpLeakedThunks()
        {
                bool b = false;
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        b = true;
                        m_paThunks->operator[](i)->Dump();
                        delete m_paThunks->operator[](i);
                }
                m_paThunks->RemoveAll();
                return b;
        }
#endif // _ATL_DEBUG_INTERFACES
        void Term()
        {
#ifdef _ATL_DEBUG_INTERFACES
                m_bDestroyHeap = false; // prevent heap from going away
                AtlModuleTerm(this);
                DumpLeakedThunks();
                delete m_paThunks;
#ifndef _ATL_NO_MP_HEAP
                if (m_phHeaps != NULL)
                {
                        for (DWORD i = 0; i <= m_dwHeaps; i++)
                                HeapDestroy(m_phHeaps[i]);
                }
#endif
                if (m_hHeap != NULL)
                        HeapDestroy(m_hHeap);
#else
                AtlModuleTerm(this);
#endif // _ATL_DEBUG_INTERFACES
        }

        HRESULT AddTermFunc(_ATL_TERMFUNC* pFunc, DWORD_PTR dw)
        {
                return AtlModuleAddTermFunc(this, pFunc, dw);
        }

        LONG Lock()
        {
                return CComGlobalsThreadModel::Increment(&m_nLockCnt);
        }
        LONG Unlock()
        {
                return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
        }
        LONG GetLockCount()
        {
                return m_nLockCnt;
        }

        HINSTANCE GetModuleInstance() {return m_hInst;}
        HINSTANCE GetResourceInstance() {return m_hInstResource;}
        HINSTANCE GetTypeLibInstance() {return m_hInstTypeLib;}

        // Registry support (helpers)
        HRESULT RegisterTypeLib()
        {
                return AtlModuleRegisterTypeLib(this, NULL);
        }
        HRESULT RegisterTypeLib(LPCTSTR lpszIndex)
        {
                USES_CONVERSION;
                return AtlModuleRegisterTypeLib(this, T2COLE(lpszIndex));
        }
        HRESULT UnRegisterTypeLib()
        {
                return AtlModuleUnRegisterTypeLib(this, NULL);
        }
        HRESULT UnRegisterTypeLib(LPCTSTR lpszIndex)
        {
                USES_CONVERSION;
                return AtlModuleUnRegisterTypeLib(this, T2COLE(lpszIndex));
        }
        HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL)
        {
                return AtlModuleRegisterServer(this, bRegTypeLib, pCLSID);
        }

        HRESULT UnregisterServer(const CLSID* pCLSID = NULL)
        {
                return AtlModuleUnregisterServer(this, pCLSID);
        }
        HRESULT UnregisterServer(BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL)
        {
                return AtlModuleUnregisterServerEx(this, bUnRegTypeLib, pCLSID);
        }

        // Resource-based Registration
        HRESULT WINAPI UpdateRegistryFromResourceD(LPCTSTR lpszRes, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
        {
                USES_CONVERSION;
                return AtlModuleUpdateRegistryFromResourceD(this, T2COLE(lpszRes), bRegister,
                        pMapEntries);
        }
        HRESULT WINAPI UpdateRegistryFromResourceD(UINT nResID, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
        {
                return AtlModuleUpdateRegistryFromResourceD(this,
                        (LPCOLESTR)MAKEINTRESOURCE(nResID), bRegister, pMapEntries);
        }

#ifdef _ATL_STATIC_REGISTRY
        // Statically linking to Registry Ponent
        HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
        HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
#endif

        // Standard Registration
        HRESULT WINAPI UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister);
        HRESULT WINAPI RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags);
        HRESULT WINAPI UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID);

        // Register/Revoke All Class Factories with the OS (EXE only)
        HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags)
        {
                return AtlModuleRegisterClassObjects(this, dwClsContext, dwFlags);
        }
        HRESULT RevokeClassObjects()
        {
                return AtlModuleRevokeClassObjects(this);
        }

        // Obtain a Class Factory (DLL only)
        HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
        {
                return AtlModuleGetClassObject(this, rclsid, riid, ppv);
        }

        // Only used in CComAutoThreadModule
        HRESULT CreateInstance(void* /*pfnCreateInstance*/, REFIID /*riid*/, void** /*ppvObj*/)
        {
                ATLASSERT(FALSE);
                return E_NOTIMPL;
        }
        static HRESULT RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc);

        static void ReplaceSingleQuote(LPOLESTR lpDest, LPCOLESTR lp)
        {
                while (*lp)
                {
                        *lpDest++ = *lp;
                        if (*lp == OLESTR('\''))
                                *lpDest++ = *lp;
                        lp++;
                }
                *lpDest = NULL;
        }
};

#ifdef _ATL_DEBUG_INTERFACES
inline ULONG _QIThunk::Release()
{
        if (bBreak)
                DebugBreak();
        ATLASSERT(m_dwRef > 0);
        ULONG l = InterlockedDecrement(&m_dwRef);

	    // --------------------------------------------------------
        if(DBG_FSET4(CDebugLog::DBG4_ATLTRACE))
	    {

		    ATLTRACE(_T("            %d< "), m_dwRef);					// jbcode

		    pUnk->AddRef();
		    int _cRefs = pUnk->Release();
		    ATLTRACE(_T("%04x %3d/%3d 0x%08x t%3d id %4d -  "), GetCurrentThreadId(), m_dwRef, m_dwMaxRef, pUnk, _cRefs-1, nIndex);		// jb 6/32
		    if(_cRefs==1)
			    ATLTRACE(_T("***"));
		    else
			    ATLTRACE(_T("   "));

		    AtlDumpIID(iid, lpszClassName, S_OK);
	    }
 	    // --------------------------------------------------------
       

        pUnk->Release();
        if (l == 0 && !bNonAddRefThunk)
                _pModule->DeleteThunk(this);
        return l;
}

inline static void atlBadThunkCall()
{
        ATLASSERT(FALSE && "Call through deleted thunk");
}

#ifdef _M_IX86
#define IMPL_THUNK(n)\
__declspec(naked) inline HRESULT _QIThunk::f##n()\
{\
        __asm mov eax, [esp+4]\
        __asm cmp dword ptr [eax+8], 0\
        __asm jg goodref\
        __asm call atlBadThunkCall\
        __asm goodref:\
        __asm mov eax, [esp+4]\
        __asm mov eax, dword ptr [eax+4]\
        __asm mov [esp+4], eax\
        __asm mov eax, dword ptr [eax]\
        __asm mov eax, dword ptr [eax+4*n]\
        __asm jmp eax\
}

#else
#define IMPL_THUNK(x)
#endif

IMPL_THUNK(3)
IMPL_THUNK(4)
IMPL_THUNK(5)
IMPL_THUNK(6)
IMPL_THUNK(7)
IMPL_THUNK(8)
IMPL_THUNK(9)
IMPL_THUNK(10)
IMPL_THUNK(11)
IMPL_THUNK(12)
IMPL_THUNK(13)
IMPL_THUNK(14)
IMPL_THUNK(15)
IMPL_THUNK(16)
IMPL_THUNK(17)
IMPL_THUNK(18)
IMPL_THUNK(19)
IMPL_THUNK(20)
IMPL_THUNK(21)
IMPL_THUNK(22)
IMPL_THUNK(23)
IMPL_THUNK(24)
IMPL_THUNK(25)
IMPL_THUNK(26)
IMPL_THUNK(27)
IMPL_THUNK(28)
IMPL_THUNK(29)
IMPL_THUNK(30)
IMPL_THUNK(31)
IMPL_THUNK(32)
IMPL_THUNK(33)
IMPL_THUNK(34)
IMPL_THUNK(35)
IMPL_THUNK(36)
IMPL_THUNK(37)
IMPL_THUNK(38)
IMPL_THUNK(39)
IMPL_THUNK(40)
IMPL_THUNK(41)
IMPL_THUNK(42)
IMPL_THUNK(43)
IMPL_THUNK(44)
IMPL_THUNK(45)
IMPL_THUNK(46)
IMPL_THUNK(47)
IMPL_THUNK(48)
IMPL_THUNK(49)
IMPL_THUNK(50)
IMPL_THUNK(51)
IMPL_THUNK(52)
IMPL_THUNK(53)
IMPL_THUNK(54)
IMPL_THUNK(55)
IMPL_THUNK(56)
IMPL_THUNK(57)
IMPL_THUNK(58)
IMPL_THUNK(59)
IMPL_THUNK(60)
IMPL_THUNK(61)
IMPL_THUNK(62)
IMPL_THUNK(63)
IMPL_THUNK(64)
IMPL_THUNK(65)
IMPL_THUNK(66)
IMPL_THUNK(67)
IMPL_THUNK(68)
IMPL_THUNK(69)
IMPL_THUNK(70)
IMPL_THUNK(71)
IMPL_THUNK(72)
IMPL_THUNK(73)
IMPL_THUNK(74)
IMPL_THUNK(75)
IMPL_THUNK(76)
IMPL_THUNK(77)
IMPL_THUNK(78)
IMPL_THUNK(79)
IMPL_THUNK(80)
IMPL_THUNK(81)
IMPL_THUNK(82)
IMPL_THUNK(83)
IMPL_THUNK(84)
IMPL_THUNK(85)
IMPL_THUNK(86)
IMPL_THUNK(87)
IMPL_THUNK(88)
IMPL_THUNK(89)
IMPL_THUNK(90)
IMPL_THUNK(91)
IMPL_THUNK(92)
IMPL_THUNK(93)
IMPL_THUNK(94)
IMPL_THUNK(95)
IMPL_THUNK(96)
IMPL_THUNK(97)
IMPL_THUNK(98)
IMPL_THUNK(99)
IMPL_THUNK(100)
IMPL_THUNK(101)
IMPL_THUNK(102)
IMPL_THUNK(103)
IMPL_THUNK(104)
IMPL_THUNK(105)
IMPL_THUNK(106)
IMPL_THUNK(107)
IMPL_THUNK(108)
IMPL_THUNK(109)
IMPL_THUNK(110)
IMPL_THUNK(111)
IMPL_THUNK(112)
IMPL_THUNK(113)
IMPL_THUNK(114)
IMPL_THUNK(115)
IMPL_THUNK(116)
IMPL_THUNK(117)
IMPL_THUNK(118)
IMPL_THUNK(119)
IMPL_THUNK(120)
IMPL_THUNK(121)
IMPL_THUNK(122)
IMPL_THUNK(123)
IMPL_THUNK(124)
IMPL_THUNK(125)
IMPL_THUNK(126)
IMPL_THUNK(127)
IMPL_THUNK(128)
IMPL_THUNK(129)
IMPL_THUNK(130)
IMPL_THUNK(131)
IMPL_THUNK(132)
IMPL_THUNK(133)
IMPL_THUNK(134)
IMPL_THUNK(135)
IMPL_THUNK(136)
IMPL_THUNK(137)
IMPL_THUNK(138)
IMPL_THUNK(139)
IMPL_THUNK(140)
IMPL_THUNK(141)
IMPL_THUNK(142)
IMPL_THUNK(143)
IMPL_THUNK(144)
IMPL_THUNK(145)
IMPL_THUNK(146)
IMPL_THUNK(147)
IMPL_THUNK(148)
IMPL_THUNK(149)
IMPL_THUNK(150)
IMPL_THUNK(151)
IMPL_THUNK(152)
IMPL_THUNK(153)
IMPL_THUNK(154)
IMPL_THUNK(155)
IMPL_THUNK(156)
IMPL_THUNK(157)
IMPL_THUNK(158)
IMPL_THUNK(159)
IMPL_THUNK(160)
IMPL_THUNK(161)
IMPL_THUNK(162)
IMPL_THUNK(163)
IMPL_THUNK(164)
IMPL_THUNK(165)
IMPL_THUNK(166)
IMPL_THUNK(167)
IMPL_THUNK(168)
IMPL_THUNK(169)
IMPL_THUNK(170)
IMPL_THUNK(171)
IMPL_THUNK(172)
IMPL_THUNK(173)
IMPL_THUNK(174)
IMPL_THUNK(175)
IMPL_THUNK(176)
IMPL_THUNK(177)
IMPL_THUNK(178)
IMPL_THUNK(179)
IMPL_THUNK(180)
IMPL_THUNK(181)
IMPL_THUNK(182)
IMPL_THUNK(183)
IMPL_THUNK(184)
IMPL_THUNK(185)
IMPL_THUNK(186)
IMPL_THUNK(187)
IMPL_THUNK(188)
IMPL_THUNK(189)
IMPL_THUNK(190)
IMPL_THUNK(191)
IMPL_THUNK(192)
IMPL_THUNK(193)
IMPL_THUNK(194)
IMPL_THUNK(195)
IMPL_THUNK(196)
IMPL_THUNK(197)
IMPL_THUNK(198)
IMPL_THUNK(199)
IMPL_THUNK(200)
IMPL_THUNK(201)
IMPL_THUNK(202)
IMPL_THUNK(203)
IMPL_THUNK(204)
IMPL_THUNK(205)
IMPL_THUNK(206)
IMPL_THUNK(207)
IMPL_THUNK(208)
IMPL_THUNK(209)
IMPL_THUNK(210)
IMPL_THUNK(211)
IMPL_THUNK(212)
IMPL_THUNK(213)
IMPL_THUNK(214)
IMPL_THUNK(215)
IMPL_THUNK(216)
IMPL_THUNK(217)
IMPL_THUNK(218)
IMPL_THUNK(219)
IMPL_THUNK(220)
IMPL_THUNK(221)
IMPL_THUNK(222)
IMPL_THUNK(223)
IMPL_THUNK(224)
IMPL_THUNK(225)
IMPL_THUNK(226)
IMPL_THUNK(227)
IMPL_THUNK(228)
IMPL_THUNK(229)
IMPL_THUNK(230)
IMPL_THUNK(231)
IMPL_THUNK(232)
IMPL_THUNK(233)
IMPL_THUNK(234)
IMPL_THUNK(235)
IMPL_THUNK(236)
IMPL_THUNK(237)
IMPL_THUNK(238)
IMPL_THUNK(239)
IMPL_THUNK(240)
IMPL_THUNK(241)
IMPL_THUNK(242)
IMPL_THUNK(243)
IMPL_THUNK(244)
IMPL_THUNK(245)
IMPL_THUNK(246)
IMPL_THUNK(247)
IMPL_THUNK(248)
IMPL_THUNK(249)
IMPL_THUNK(250)
IMPL_THUNK(251)
IMPL_THUNK(252)
IMPL_THUNK(253)
IMPL_THUNK(254)
IMPL_THUNK(255)
IMPL_THUNK(256)
IMPL_THUNK(257)
IMPL_THUNK(258)
IMPL_THUNK(259)
IMPL_THUNK(260)
IMPL_THUNK(261)
IMPL_THUNK(262)
IMPL_THUNK(263)
IMPL_THUNK(264)
IMPL_THUNK(265)
IMPL_THUNK(266)
IMPL_THUNK(267)
IMPL_THUNK(268)
IMPL_THUNK(269)
IMPL_THUNK(270)
IMPL_THUNK(271)
IMPL_THUNK(272)
IMPL_THUNK(273)
IMPL_THUNK(274)
IMPL_THUNK(275)
IMPL_THUNK(276)
IMPL_THUNK(277)
IMPL_THUNK(278)
IMPL_THUNK(279)
IMPL_THUNK(280)
IMPL_THUNK(281)
IMPL_THUNK(282)
IMPL_THUNK(283)
IMPL_THUNK(284)
IMPL_THUNK(285)
IMPL_THUNK(286)
IMPL_THUNK(287)
IMPL_THUNK(288)
IMPL_THUNK(289)
IMPL_THUNK(290)
IMPL_THUNK(291)
IMPL_THUNK(292)
IMPL_THUNK(293)
IMPL_THUNK(294)
IMPL_THUNK(295)
IMPL_THUNK(296)
IMPL_THUNK(297)
IMPL_THUNK(298)
IMPL_THUNK(299)
IMPL_THUNK(300)
IMPL_THUNK(301)
IMPL_THUNK(302)
IMPL_THUNK(303)
IMPL_THUNK(304)
IMPL_THUNK(305)
IMPL_THUNK(306)
IMPL_THUNK(307)
IMPL_THUNK(308)
IMPL_THUNK(309)
IMPL_THUNK(310)
IMPL_THUNK(311)
IMPL_THUNK(312)
IMPL_THUNK(313)
IMPL_THUNK(314)
IMPL_THUNK(315)
IMPL_THUNK(316)
IMPL_THUNK(317)
IMPL_THUNK(318)
IMPL_THUNK(319)
IMPL_THUNK(320)
IMPL_THUNK(321)
IMPL_THUNK(322)
IMPL_THUNK(323)
IMPL_THUNK(324)
IMPL_THUNK(325)
IMPL_THUNK(326)
IMPL_THUNK(327)
IMPL_THUNK(328)
IMPL_THUNK(329)
IMPL_THUNK(330)
IMPL_THUNK(331)
IMPL_THUNK(332)
IMPL_THUNK(333)
IMPL_THUNK(334)
IMPL_THUNK(335)
IMPL_THUNK(336)
IMPL_THUNK(337)
IMPL_THUNK(338)
IMPL_THUNK(339)
IMPL_THUNK(340)
IMPL_THUNK(341)
IMPL_THUNK(342)
IMPL_THUNK(343)
IMPL_THUNK(344)
IMPL_THUNK(345)
IMPL_THUNK(346)
IMPL_THUNK(347)
IMPL_THUNK(348)
IMPL_THUNK(349)
IMPL_THUNK(350)
IMPL_THUNK(351)
IMPL_THUNK(352)
IMPL_THUNK(353)
IMPL_THUNK(354)
IMPL_THUNK(355)
IMPL_THUNK(356)
IMPL_THUNK(357)
IMPL_THUNK(358)
IMPL_THUNK(359)
IMPL_THUNK(360)
IMPL_THUNK(361)
IMPL_THUNK(362)
IMPL_THUNK(363)
IMPL_THUNK(364)
IMPL_THUNK(365)
IMPL_THUNK(366)
IMPL_THUNK(367)
IMPL_THUNK(368)
IMPL_THUNK(369)
IMPL_THUNK(370)
IMPL_THUNK(371)
IMPL_THUNK(372)
IMPL_THUNK(373)
IMPL_THUNK(374)
IMPL_THUNK(375)
IMPL_THUNK(376)
IMPL_THUNK(377)
IMPL_THUNK(378)
IMPL_THUNK(379)
IMPL_THUNK(380)
IMPL_THUNK(381)
IMPL_THUNK(382)
IMPL_THUNK(383)
IMPL_THUNK(384)
IMPL_THUNK(385)
IMPL_THUNK(386)
IMPL_THUNK(387)
IMPL_THUNK(388)
IMPL_THUNK(389)
IMPL_THUNK(390)
IMPL_THUNK(391)
IMPL_THUNK(392)
IMPL_THUNK(393)
IMPL_THUNK(394)
IMPL_THUNK(395)
IMPL_THUNK(396)
IMPL_THUNK(397)
IMPL_THUNK(398)
IMPL_THUNK(399)
IMPL_THUNK(400)
IMPL_THUNK(401)
IMPL_THUNK(402)
IMPL_THUNK(403)
IMPL_THUNK(404)
IMPL_THUNK(405)
IMPL_THUNK(406)
IMPL_THUNK(407)
IMPL_THUNK(408)
IMPL_THUNK(409)
IMPL_THUNK(410)
IMPL_THUNK(411)
IMPL_THUNK(412)
IMPL_THUNK(413)
IMPL_THUNK(414)
IMPL_THUNK(415)
IMPL_THUNK(416)
IMPL_THUNK(417)
IMPL_THUNK(418)
IMPL_THUNK(419)
IMPL_THUNK(420)
IMPL_THUNK(421)
IMPL_THUNK(422)
IMPL_THUNK(423)
IMPL_THUNK(424)
IMPL_THUNK(425)
IMPL_THUNK(426)
IMPL_THUNK(427)
IMPL_THUNK(428)
IMPL_THUNK(429)
IMPL_THUNK(430)
IMPL_THUNK(431)
IMPL_THUNK(432)
IMPL_THUNK(433)
IMPL_THUNK(434)
IMPL_THUNK(435)
IMPL_THUNK(436)
IMPL_THUNK(437)
IMPL_THUNK(438)
IMPL_THUNK(439)
IMPL_THUNK(440)
IMPL_THUNK(441)
IMPL_THUNK(442)
IMPL_THUNK(443)
IMPL_THUNK(444)
IMPL_THUNK(445)
IMPL_THUNK(446)
IMPL_THUNK(447)
IMPL_THUNK(448)
IMPL_THUNK(449)
IMPL_THUNK(450)
IMPL_THUNK(451)
IMPL_THUNK(452)
IMPL_THUNK(453)
IMPL_THUNK(454)
IMPL_THUNK(455)
IMPL_THUNK(456)
IMPL_THUNK(457)
IMPL_THUNK(458)
IMPL_THUNK(459)
IMPL_THUNK(460)
IMPL_THUNK(461)
IMPL_THUNK(462)
IMPL_THUNK(463)
IMPL_THUNK(464)
IMPL_THUNK(465)
IMPL_THUNK(466)
IMPL_THUNK(467)
IMPL_THUNK(468)
IMPL_THUNK(469)
IMPL_THUNK(470)
IMPL_THUNK(471)
IMPL_THUNK(472)
IMPL_THUNK(473)
IMPL_THUNK(474)
IMPL_THUNK(475)
IMPL_THUNK(476)
IMPL_THUNK(477)
IMPL_THUNK(478)
IMPL_THUNK(479)
IMPL_THUNK(480)
IMPL_THUNK(481)
IMPL_THUNK(482)
IMPL_THUNK(483)
IMPL_THUNK(484)
IMPL_THUNK(485)
IMPL_THUNK(486)
IMPL_THUNK(487)
IMPL_THUNK(488)
IMPL_THUNK(489)
IMPL_THUNK(490)
IMPL_THUNK(491)
IMPL_THUNK(492)
IMPL_THUNK(493)
IMPL_THUNK(494)
IMPL_THUNK(495)
IMPL_THUNK(496)
IMPL_THUNK(497)
IMPL_THUNK(498)
IMPL_THUNK(499)
IMPL_THUNK(500)
IMPL_THUNK(501)
IMPL_THUNK(502)
IMPL_THUNK(503)
IMPL_THUNK(504)
IMPL_THUNK(505)
IMPL_THUNK(506)
IMPL_THUNK(507)
IMPL_THUNK(508)
IMPL_THUNK(509)
IMPL_THUNK(510)
IMPL_THUNK(511)
IMPL_THUNK(512)
IMPL_THUNK(513)
IMPL_THUNK(514)
IMPL_THUNK(515)
IMPL_THUNK(516)
IMPL_THUNK(517)
IMPL_THUNK(518)
IMPL_THUNK(519)
IMPL_THUNK(520)
IMPL_THUNK(521)
IMPL_THUNK(522)
IMPL_THUNK(523)
IMPL_THUNK(524)
IMPL_THUNK(525)
IMPL_THUNK(526)
IMPL_THUNK(527)
IMPL_THUNK(528)
IMPL_THUNK(529)
IMPL_THUNK(530)
IMPL_THUNK(531)
IMPL_THUNK(532)
IMPL_THUNK(533)
IMPL_THUNK(534)
IMPL_THUNK(535)
IMPL_THUNK(536)
IMPL_THUNK(537)
IMPL_THUNK(538)
IMPL_THUNK(539)
IMPL_THUNK(540)
IMPL_THUNK(541)
IMPL_THUNK(542)
IMPL_THUNK(543)
IMPL_THUNK(544)
IMPL_THUNK(545)
IMPL_THUNK(546)
IMPL_THUNK(547)
IMPL_THUNK(548)
IMPL_THUNK(549)
IMPL_THUNK(550)
IMPL_THUNK(551)
IMPL_THUNK(552)
IMPL_THUNK(553)
IMPL_THUNK(554)
IMPL_THUNK(555)
IMPL_THUNK(556)
IMPL_THUNK(557)
IMPL_THUNK(558)
IMPL_THUNK(559)
IMPL_THUNK(560)
IMPL_THUNK(561)
IMPL_THUNK(562)
IMPL_THUNK(563)
IMPL_THUNK(564)
IMPL_THUNK(565)
IMPL_THUNK(566)
IMPL_THUNK(567)
IMPL_THUNK(568)
IMPL_THUNK(569)
IMPL_THUNK(570)
IMPL_THUNK(571)
IMPL_THUNK(572)
IMPL_THUNK(573)
IMPL_THUNK(574)
IMPL_THUNK(575)
IMPL_THUNK(576)
IMPL_THUNK(577)
IMPL_THUNK(578)
IMPL_THUNK(579)
IMPL_THUNK(580)
IMPL_THUNK(581)
IMPL_THUNK(582)
IMPL_THUNK(583)
IMPL_THUNK(584)
IMPL_THUNK(585)
IMPL_THUNK(586)
IMPL_THUNK(587)
IMPL_THUNK(588)
IMPL_THUNK(589)
IMPL_THUNK(590)
IMPL_THUNK(591)
IMPL_THUNK(592)
IMPL_THUNK(593)
IMPL_THUNK(594)
IMPL_THUNK(595)
IMPL_THUNK(596)
IMPL_THUNK(597)
IMPL_THUNK(598)
IMPL_THUNK(599)
IMPL_THUNK(600)
IMPL_THUNK(601)
IMPL_THUNK(602)
IMPL_THUNK(603)
IMPL_THUNK(604)
IMPL_THUNK(605)
IMPL_THUNK(606)
IMPL_THUNK(607)
IMPL_THUNK(608)
IMPL_THUNK(609)
IMPL_THUNK(610)
IMPL_THUNK(611)
IMPL_THUNK(612)
IMPL_THUNK(613)
IMPL_THUNK(614)
IMPL_THUNK(615)
IMPL_THUNK(616)
IMPL_THUNK(617)
IMPL_THUNK(618)
IMPL_THUNK(619)
IMPL_THUNK(620)
IMPL_THUNK(621)
IMPL_THUNK(622)
IMPL_THUNK(623)
IMPL_THUNK(624)
IMPL_THUNK(625)
IMPL_THUNK(626)
IMPL_THUNK(627)
IMPL_THUNK(628)
IMPL_THUNK(629)
IMPL_THUNK(630)
IMPL_THUNK(631)
IMPL_THUNK(632)
IMPL_THUNK(633)
IMPL_THUNK(634)
IMPL_THUNK(635)
IMPL_THUNK(636)
IMPL_THUNK(637)
IMPL_THUNK(638)
IMPL_THUNK(639)
IMPL_THUNK(640)
IMPL_THUNK(641)
IMPL_THUNK(642)
IMPL_THUNK(643)
IMPL_THUNK(644)
IMPL_THUNK(645)
IMPL_THUNK(646)
IMPL_THUNK(647)
IMPL_THUNK(648)
IMPL_THUNK(649)
IMPL_THUNK(650)
IMPL_THUNK(651)
IMPL_THUNK(652)
IMPL_THUNK(653)
IMPL_THUNK(654)
IMPL_THUNK(655)
IMPL_THUNK(656)
IMPL_THUNK(657)
IMPL_THUNK(658)
IMPL_THUNK(659)
IMPL_THUNK(660)
IMPL_THUNK(661)
IMPL_THUNK(662)
IMPL_THUNK(663)
IMPL_THUNK(664)
IMPL_THUNK(665)
IMPL_THUNK(666)
IMPL_THUNK(667)
IMPL_THUNK(668)
IMPL_THUNK(669)
IMPL_THUNK(670)
IMPL_THUNK(671)
IMPL_THUNK(672)
IMPL_THUNK(673)
IMPL_THUNK(674)
IMPL_THUNK(675)
IMPL_THUNK(676)
IMPL_THUNK(677)
IMPL_THUNK(678)
IMPL_THUNK(679)
IMPL_THUNK(680)
IMPL_THUNK(681)
IMPL_THUNK(682)
IMPL_THUNK(683)
IMPL_THUNK(684)
IMPL_THUNK(685)
IMPL_THUNK(686)
IMPL_THUNK(687)
IMPL_THUNK(688)
IMPL_THUNK(689)
IMPL_THUNK(690)
IMPL_THUNK(691)
IMPL_THUNK(692)
IMPL_THUNK(693)
IMPL_THUNK(694)
IMPL_THUNK(695)
IMPL_THUNK(696)
IMPL_THUNK(697)
IMPL_THUNK(698)
IMPL_THUNK(699)
IMPL_THUNK(700)
IMPL_THUNK(701)
IMPL_THUNK(702)
IMPL_THUNK(703)
IMPL_THUNK(704)
IMPL_THUNK(705)
IMPL_THUNK(706)
IMPL_THUNK(707)
IMPL_THUNK(708)
IMPL_THUNK(709)
IMPL_THUNK(710)
IMPL_THUNK(711)
IMPL_THUNK(712)
IMPL_THUNK(713)
IMPL_THUNK(714)
IMPL_THUNK(715)
IMPL_THUNK(716)
IMPL_THUNK(717)
IMPL_THUNK(718)
IMPL_THUNK(719)
IMPL_THUNK(720)
IMPL_THUNK(721)
IMPL_THUNK(722)
IMPL_THUNK(723)
IMPL_THUNK(724)
IMPL_THUNK(725)
IMPL_THUNK(726)
IMPL_THUNK(727)
IMPL_THUNK(728)
IMPL_THUNK(729)
IMPL_THUNK(730)
IMPL_THUNK(731)
IMPL_THUNK(732)
IMPL_THUNK(733)
IMPL_THUNK(734)
IMPL_THUNK(735)
IMPL_THUNK(736)
IMPL_THUNK(737)
IMPL_THUNK(738)
IMPL_THUNK(739)
IMPL_THUNK(740)
IMPL_THUNK(741)
IMPL_THUNK(742)
IMPL_THUNK(743)
IMPL_THUNK(744)
IMPL_THUNK(745)
IMPL_THUNK(746)
IMPL_THUNK(747)
IMPL_THUNK(748)
IMPL_THUNK(749)
IMPL_THUNK(750)
IMPL_THUNK(751)
IMPL_THUNK(752)
IMPL_THUNK(753)
IMPL_THUNK(754)
IMPL_THUNK(755)
IMPL_THUNK(756)
IMPL_THUNK(757)
IMPL_THUNK(758)
IMPL_THUNK(759)
IMPL_THUNK(760)
IMPL_THUNK(761)
IMPL_THUNK(762)
IMPL_THUNK(763)
IMPL_THUNK(764)
IMPL_THUNK(765)
IMPL_THUNK(766)
IMPL_THUNK(767)
IMPL_THUNK(768)
IMPL_THUNK(769)
IMPL_THUNK(770)
IMPL_THUNK(771)
IMPL_THUNK(772)
IMPL_THUNK(773)
IMPL_THUNK(774)
IMPL_THUNK(775)
IMPL_THUNK(776)
IMPL_THUNK(777)
IMPL_THUNK(778)
IMPL_THUNK(779)
IMPL_THUNK(780)
IMPL_THUNK(781)
IMPL_THUNK(782)
IMPL_THUNK(783)
IMPL_THUNK(784)
IMPL_THUNK(785)
IMPL_THUNK(786)
IMPL_THUNK(787)
IMPL_THUNK(788)
IMPL_THUNK(789)
IMPL_THUNK(790)
IMPL_THUNK(791)
IMPL_THUNK(792)
IMPL_THUNK(793)
IMPL_THUNK(794)
IMPL_THUNK(795)
IMPL_THUNK(796)
IMPL_THUNK(797)
IMPL_THUNK(798)
IMPL_THUNK(799)
IMPL_THUNK(800)
IMPL_THUNK(801)
IMPL_THUNK(802)
IMPL_THUNK(803)
IMPL_THUNK(804)
IMPL_THUNK(805)
IMPL_THUNK(806)
IMPL_THUNK(807)
IMPL_THUNK(808)
IMPL_THUNK(809)
IMPL_THUNK(810)
IMPL_THUNK(811)
IMPL_THUNK(812)
IMPL_THUNK(813)
IMPL_THUNK(814)
IMPL_THUNK(815)
IMPL_THUNK(816)
IMPL_THUNK(817)
IMPL_THUNK(818)
IMPL_THUNK(819)
IMPL_THUNK(820)
IMPL_THUNK(821)
IMPL_THUNK(822)
IMPL_THUNK(823)
IMPL_THUNK(824)
IMPL_THUNK(825)
IMPL_THUNK(826)
IMPL_THUNK(827)
IMPL_THUNK(828)
IMPL_THUNK(829)
IMPL_THUNK(830)
IMPL_THUNK(831)
IMPL_THUNK(832)
IMPL_THUNK(833)
IMPL_THUNK(834)
IMPL_THUNK(835)
IMPL_THUNK(836)
IMPL_THUNK(837)
IMPL_THUNK(838)
IMPL_THUNK(839)
IMPL_THUNK(840)
IMPL_THUNK(841)
IMPL_THUNK(842)
IMPL_THUNK(843)
IMPL_THUNK(844)
IMPL_THUNK(845)
IMPL_THUNK(846)
IMPL_THUNK(847)
IMPL_THUNK(848)
IMPL_THUNK(849)
IMPL_THUNK(850)
IMPL_THUNK(851)
IMPL_THUNK(852)
IMPL_THUNK(853)
IMPL_THUNK(854)
IMPL_THUNK(855)
IMPL_THUNK(856)
IMPL_THUNK(857)
IMPL_THUNK(858)
IMPL_THUNK(859)
IMPL_THUNK(860)
IMPL_THUNK(861)
IMPL_THUNK(862)
IMPL_THUNK(863)
IMPL_THUNK(864)
IMPL_THUNK(865)
IMPL_THUNK(866)
IMPL_THUNK(867)
IMPL_THUNK(868)
IMPL_THUNK(869)
IMPL_THUNK(870)
IMPL_THUNK(871)
IMPL_THUNK(872)
IMPL_THUNK(873)
IMPL_THUNK(874)
IMPL_THUNK(875)
IMPL_THUNK(876)
IMPL_THUNK(877)
IMPL_THUNK(878)
IMPL_THUNK(879)
IMPL_THUNK(880)
IMPL_THUNK(881)
IMPL_THUNK(882)
IMPL_THUNK(883)
IMPL_THUNK(884)
IMPL_THUNK(885)
IMPL_THUNK(886)
IMPL_THUNK(887)
IMPL_THUNK(888)
IMPL_THUNK(889)
IMPL_THUNK(890)
IMPL_THUNK(891)
IMPL_THUNK(892)
IMPL_THUNK(893)
IMPL_THUNK(894)
IMPL_THUNK(895)
IMPL_THUNK(896)
IMPL_THUNK(897)
IMPL_THUNK(898)
IMPL_THUNK(899)
IMPL_THUNK(900)
IMPL_THUNK(901)
IMPL_THUNK(902)
IMPL_THUNK(903)
IMPL_THUNK(904)
IMPL_THUNK(905)
IMPL_THUNK(906)
IMPL_THUNK(907)
IMPL_THUNK(908)
IMPL_THUNK(909)
IMPL_THUNK(910)
IMPL_THUNK(911)
IMPL_THUNK(912)
IMPL_THUNK(913)
IMPL_THUNK(914)
IMPL_THUNK(915)
IMPL_THUNK(916)
IMPL_THUNK(917)
IMPL_THUNK(918)
IMPL_THUNK(919)
IMPL_THUNK(920)
IMPL_THUNK(921)
IMPL_THUNK(922)
IMPL_THUNK(923)
IMPL_THUNK(924)
IMPL_THUNK(925)
IMPL_THUNK(926)
IMPL_THUNK(927)
IMPL_THUNK(928)
IMPL_THUNK(929)
IMPL_THUNK(930)
IMPL_THUNK(931)
IMPL_THUNK(932)
IMPL_THUNK(933)
IMPL_THUNK(934)
IMPL_THUNK(935)
IMPL_THUNK(936)
IMPL_THUNK(937)
IMPL_THUNK(938)
IMPL_THUNK(939)
IMPL_THUNK(940)
IMPL_THUNK(941)
IMPL_THUNK(942)
IMPL_THUNK(943)
IMPL_THUNK(944)
IMPL_THUNK(945)
IMPL_THUNK(946)
IMPL_THUNK(947)
IMPL_THUNK(948)
IMPL_THUNK(949)
IMPL_THUNK(950)
IMPL_THUNK(951)
IMPL_THUNK(952)
IMPL_THUNK(953)
IMPL_THUNK(954)
IMPL_THUNK(955)
IMPL_THUNK(956)
IMPL_THUNK(957)
IMPL_THUNK(958)
IMPL_THUNK(959)
IMPL_THUNK(960)
IMPL_THUNK(961)
IMPL_THUNK(962)
IMPL_THUNK(963)
IMPL_THUNK(964)
IMPL_THUNK(965)
IMPL_THUNK(966)
IMPL_THUNK(967)
IMPL_THUNK(968)
IMPL_THUNK(969)
IMPL_THUNK(970)
IMPL_THUNK(971)
IMPL_THUNK(972)
IMPL_THUNK(973)
IMPL_THUNK(974)
IMPL_THUNK(975)
IMPL_THUNK(976)
IMPL_THUNK(977)
IMPL_THUNK(978)
IMPL_THUNK(979)
IMPL_THUNK(980)
IMPL_THUNK(981)
IMPL_THUNK(982)
IMPL_THUNK(983)
IMPL_THUNK(984)
IMPL_THUNK(985)
IMPL_THUNK(986)
IMPL_THUNK(987)
IMPL_THUNK(988)
IMPL_THUNK(989)
IMPL_THUNK(990)
IMPL_THUNK(991)
IMPL_THUNK(992)
IMPL_THUNK(993)
IMPL_THUNK(994)
IMPL_THUNK(995)
IMPL_THUNK(996)
IMPL_THUNK(997)
IMPL_THUNK(998)
IMPL_THUNK(999)
IMPL_THUNK(1000)
IMPL_THUNK(1001)
IMPL_THUNK(1002)
IMPL_THUNK(1003)
IMPL_THUNK(1004)
IMPL_THUNK(1005)
IMPL_THUNK(1006)
IMPL_THUNK(1007)
IMPL_THUNK(1008)
IMPL_THUNK(1009)
IMPL_THUNK(1010)
IMPL_THUNK(1011)
IMPL_THUNK(1012)
IMPL_THUNK(1013)
IMPL_THUNK(1014)
IMPL_THUNK(1015)
IMPL_THUNK(1016)
IMPL_THUNK(1017)
IMPL_THUNK(1018)
IMPL_THUNK(1019)
IMPL_THUNK(1020)
IMPL_THUNK(1021)
IMPL_THUNK(1022)
IMPL_THUNK(1023)
IMPL_THUNK(1024)

#endif

__declspec(selectany) GUID CComModule::m_libid = {0x0,0x0,0x0,{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0}};

#ifdef _ATL_STATIC_REGISTRY
#define UpdateRegistryFromResource UpdateRegistryFromResourceS
#else
#define UpdateRegistryFromResource UpdateRegistryFromResourceD
#endif

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling classes

class _AtlAptCreateObjData
{
public:
        _ATL_CREATORFUNC* pfnCreateInstance;
        const IID* piid;
        HANDLE hEvent;
        LPSTREAM pStream;
        HRESULT hRes;
};

class CComApartment
{
public:
        CComApartment()
        {
                m_nLockCnt = 0;
        }
        static UINT ATL_CREATE_OBJECT;
        static DWORD WINAPI _Apartment(void* pv)
        {
                return ((CComApartment*)pv)->Apartment();
        }
        DWORD Apartment()
        {
                CoInitialize(NULL);
                MSG msg;
                while(GetMessage(&msg, 0, 0, 0))
                {
                        if (msg.message == ATL_CREATE_OBJECT)
                        {
                                _AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam;
                                IUnknown* pUnk = NULL;
                                pdata->hRes = pdata->pfnCreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
                                if (SUCCEEDED(pdata->hRes))
                                        pdata->hRes = CoMarshalInterThreadInterfaceInStream(*pdata->piid, pUnk, &pdata->pStream);
                                if (SUCCEEDED(pdata->hRes))
                                {
                                        pUnk->Release();
                                        ATLTRACE2(atlTraceCOM, 2, _T("Object created on thread = %d\n"), GetCurrentThreadId());
                                }
                                SetEvent(pdata->hEvent);
                        }
                        DispatchMessage(&msg);
                }
                CoUninitialize();
                return 0;
        }
        LONG Lock() {return CComGlobalsThreadModel::Increment(&m_nLockCnt);}
        LONG Unlock(){return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
        }
        LONG GetLockCount() {return m_nLockCnt;}

        DWORD m_dwThreadID;
        HANDLE m_hThread;
        LONG m_nLockCnt;
};

__declspec(selectany) UINT CComApartment::ATL_CREATE_OBJECT = 0;

class CComSimpleThreadAllocator
{
public:
        CComSimpleThreadAllocator()
        {
                m_nThread = 0;
        }
        int GetThread(CComApartment* /*pApt*/, int nThreads)
        {
                if (++m_nThread == nThreads)
                        m_nThread = 0;
                return m_nThread;
        }
        int m_nThread;
};

template <class ThreadAllocator = CComSimpleThreadAllocator>
class CComAutoThreadModule : public CComModule
{
public:
        HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL, int nThreads = GetDefaultThreads());
        ~CComAutoThreadModule();
        HRESULT CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj);
        LONG Lock();
        LONG Unlock();
        DWORD dwThreadID;
        int m_nThreads;
        CComApartment* m_pApartments;
        ThreadAllocator m_Allocator;
        static int GetDefaultThreads()
        {
                SYSTEM_INFO si;
                GetSystemInfo(&si);
                return si.dwNumberOfProcessors * 4;
        }
};

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
        BSTR m_str;
        CComBSTR()
        {
                m_str = NULL;
        }
        /*explicit*/ CComBSTR(int nSize)
        {
                m_str = ::SysAllocStringLen(NULL, nSize);
        }
        /*explicit*/ CComBSTR(int nSize, LPCOLESTR sz)
        {
                m_str = ::SysAllocStringLen(sz, nSize);
        }
        /*explicit*/ CComBSTR(LPCOLESTR pSrc)
        {
                m_str = ::SysAllocString(pSrc);
        }
        /*explicit*/ CComBSTR(const CComBSTR& src)
        {
                m_str = src.Copy();
        }
        /*explicit*/ CComBSTR(REFGUID src)
        {
                LPOLESTR szGuid;
                StringFromCLSID(src, &szGuid);
                m_str = ::SysAllocString(szGuid);
                CoTaskMemFree(szGuid);
        }
        CComBSTR& operator=(const CComBSTR& src)
        {
                if (m_str != src.m_str)
                {
                        if (m_str)
                                ::SysFreeString(m_str);
                        m_str = src.Copy();
                }
                return *this;
        }

        CComBSTR& operator=(LPCOLESTR pSrc)
        {
                ::SysFreeString(m_str);
                m_str = ::SysAllocString(pSrc);
                return *this;
        }

        ~CComBSTR()
        {
                ::SysFreeString(m_str);
        }
        unsigned int Length() const
        {
                return (m_str == NULL)? 0 : SysStringLen(m_str);
        }
        operator BSTR() const
        {
                return m_str;
        }
        BSTR* operator&()
        {
                return &m_str;
        }
        BSTR Copy() const
        {
                return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
        }
        HRESULT CopyTo(BSTR* pbstr)
        {
                ATLASSERT(pbstr != NULL);
                if (pbstr == NULL)
                        return E_POINTER;
                *pbstr = ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
                if (*pbstr == NULL)
                        return E_OUTOFMEMORY;
                return S_OK;
        }
        void Attach(BSTR src)
        {
                ATLASSERT(m_str == NULL);
                m_str = src;
        }
        BSTR Detach()
        {
                BSTR s = m_str;
                m_str = NULL;
                return s;
        }
        void Empty()
        {
                ::SysFreeString(m_str);
                m_str = NULL;
        }
        bool operator!() const
        {
                return (m_str == NULL);
        }
        HRESULT Append(const CComBSTR& bstrSrc)
        {
                return Append(bstrSrc.m_str, SysStringLen(bstrSrc.m_str));
        }
        HRESULT Append(LPCOLESTR lpsz)
        {
                return Append(lpsz, ocslen(lpsz));
        }
        // a BSTR is just a LPCOLESTR so we need a special version to signify
        // that we are appending a BSTR
        HRESULT AppendBSTR(BSTR p)
        {
                return Append(p, SysStringLen(p));
        }
        HRESULT Append(LPCOLESTR lpsz, int nLen)
        {
                int n1 = Length();
                BSTR b;
                b = ::SysAllocStringLen(NULL, n1+nLen);
                if (b == NULL)
                        return E_OUTOFMEMORY;
                memcpy(b, m_str, n1*sizeof(OLECHAR));
                memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
                b[n1+nLen] = NULL;
                SysFreeString(m_str);
                m_str = b;
                return S_OK;
        }
        HRESULT ToLower()
        {
                USES_CONVERSION;
                if (m_str != NULL)
                {
                        LPTSTR psz = CharLower(OLE2T(m_str));
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        BSTR b = T2BSTR(psz);
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        SysFreeString(m_str);
                        m_str = b;
                }
                return S_OK;
        }
        HRESULT ToUpper()
        {
                USES_CONVERSION;
                if (m_str != NULL)
                {
                        LPTSTR psz = CharUpper(OLE2T(m_str));
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        BSTR b = T2BSTR(psz);
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        SysFreeString(m_str);
                        m_str = b;
                }
                return S_OK;
        }
        bool LoadString(HINSTANCE hInst, UINT nID)
        {
                USES_CONVERSION;
                TCHAR sz[512];
                UINT nLen = ::LoadString(hInst, nID, sz, 512);
                ATLASSERT(nLen < 511);
                SysFreeString(m_str);
                m_str = (nLen != 0) ? SysAllocString(T2OLE(sz)) : NULL;
                return (nLen != 0);
        }
        bool LoadString(UINT nID)
        {
                return LoadString(_pModule->m_hInstResource, nID);
        }

        CComBSTR& operator+=(const CComBSTR& bstrSrc)
        {
                AppendBSTR(bstrSrc.m_str);
                return *this;
        }
        bool operator<(BSTR bstrSrc) const
        {
                if (bstrSrc == NULL && m_str == NULL)
                        return false;
                if (bstrSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, bstrSrc) < 0;
                return m_str == NULL;
        }
        bool operator==(BSTR bstrSrc) const
        {
                if (bstrSrc == NULL && m_str == NULL)
                        return true;
                if (bstrSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, bstrSrc) == 0;
                return false;
        }
        bool operator<(LPCSTR pszSrc) const
        {
                if (pszSrc == NULL && m_str == NULL)
                        return false;
                USES_CONVERSION;
                if (pszSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, A2W(pszSrc)) < 0;
                return m_str == NULL;
        }
        bool operator==(LPCSTR pszSrc) const
        {
                if (pszSrc == NULL && m_str == NULL)
                        return true;
                USES_CONVERSION;
                if (pszSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, A2W(pszSrc)) == 0;
                return false;
        }
#ifndef OLE2ANSI
        CComBSTR(LPCSTR pSrc)
        {
                m_str = A2WBSTR(pSrc);
        }

        CComBSTR(int nSize, LPCSTR sz)
        {
                m_str = A2WBSTR(sz, nSize);
        }

        void Append(LPCSTR lpsz)
        {
                USES_CONVERSION;
                LPCOLESTR lpo = A2COLE(lpsz);
                Append(lpo, ocslen(lpo));
        }

        CComBSTR& operator=(LPCSTR pSrc)
        {
                ::SysFreeString(m_str);
                m_str = A2WBSTR(pSrc);
                return *this;
        }
#endif
        HRESULT WriteToStream(IStream* pStream)
        {
                ATLASSERT(pStream != NULL);
                ULONG cb;
                ULONG cbStrLen = m_str ? SysStringByteLen(m_str)+(ULONG)sizeof(OLECHAR) : 0;
                HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
                if (FAILED(hr))
                        return hr;
                return cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
        }
        HRESULT ReadFromStream(IStream* pStream)
        {
                ATLASSERT(pStream != NULL);
                ATLASSERT(m_str == NULL); // should be empty
                ULONG cbStrLen = 0;
                HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), NULL);
                if ((hr == S_OK) && (cbStrLen != 0))
                {
                        //subtract size for terminating NULL which we wrote out
                        //since SysAllocStringByteLen overallocates for the NULL
                        m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
                        if (m_str == NULL)
                                hr = E_OUTOFMEMORY;
                        else
                                hr = pStream->Read((void*) m_str, cbStrLen, NULL);
                }
                if (hr == S_FALSE)
                        hr = E_FAIL;
                return hr;
        }
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
// Constructors
public:
        CComVariant()
        {
                vt = VT_EMPTY;
        }
        ~CComVariant()
        {
                Clear();
        }

        CComVariant(const VARIANT& varSrc)
        {
                vt = VT_EMPTY;
                InternalCopy(&varSrc);
        }

        CComVariant(const CComVariant& varSrc)
        {
                vt = VT_EMPTY;
                InternalCopy(&varSrc);
        }

        CComVariant(BSTR bstrSrc)
        {
                vt = VT_EMPTY;
                *this = bstrSrc;
        }
        CComVariant(LPCOLESTR lpszSrc)
        {
                vt = VT_EMPTY;
                *this = lpszSrc;
        }

#ifndef OLE2ANSI
        CComVariant(LPCSTR lpszSrc)
        {
                vt = VT_EMPTY;
                *this = lpszSrc;
        }
#endif

        CComVariant(bool bSrc)
        {
                vt = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
                boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
        }

        CComVariant(int nSrc)
        {
                vt = VT_I4;
                lVal = nSrc;
        }
        CComVariant(BYTE nSrc)
        {
                vt = VT_UI1;
                bVal = nSrc;
        }
        CComVariant(short nSrc)
        {
                vt = VT_I2;
                iVal = nSrc;
        }
        CComVariant(long nSrc, VARTYPE vtSrc = VT_I4)
        {
                ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
                vt = vtSrc;
                lVal = nSrc;
        }
        CComVariant(float fltSrc)
        {
                vt = VT_R4;
                fltVal = fltSrc;
        }
        CComVariant(double dblSrc)
        {
                vt = VT_R8;
                dblVal = dblSrc;
        }
        CComVariant(CY cySrc)
        {
                vt = VT_CY;
                cyVal.Hi = cySrc.Hi;
                cyVal.Lo = cySrc.Lo;
        }
        CComVariant(IDispatch* pSrc)
        {
                vt = VT_DISPATCH;
                pdispVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (pdispVal != NULL)
                        pdispVal->AddRef();
        }
        CComVariant(IUnknown* pSrc)
        {
                vt = VT_UNKNOWN;
                punkVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (punkVal != NULL)
                        punkVal->AddRef();
        }

// Assignment Operators
public:
        CComVariant& operator=(const CComVariant& varSrc)
        {
                InternalCopy(&varSrc);
                return *this;
        }
        CComVariant& operator=(const VARIANT& varSrc)
        {
                InternalCopy(&varSrc);
                return *this;
        }

        CComVariant& operator=(BSTR bstrSrc)
        {
                InternalClear();
                vt = VT_BSTR;
                bstrVal = ::SysAllocString(bstrSrc);
                if (bstrVal == NULL && bstrSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }

        CComVariant& operator=(LPCOLESTR lpszSrc)
        {
                InternalClear();
                vt = VT_BSTR;
                bstrVal = ::SysAllocString(lpszSrc);

                if (bstrVal == NULL && lpszSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }

        #ifndef OLE2ANSI
        CComVariant& operator=(LPCSTR lpszSrc)
        {
                USES_CONVERSION;
                InternalClear();
                vt = VT_BSTR;
                bstrVal = ::SysAllocString(A2COLE(lpszSrc));

                if (bstrVal == NULL && lpszSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }
        #endif

        CComVariant& operator=(bool bSrc)
        {
                if (vt != VT_BOOL)
                {
                        InternalClear();
                        vt = VT_BOOL;
                }
        #pragma warning(disable: 4310) // cast truncates constant value
                boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
        #pragma warning(default: 4310) // cast truncates constant value
                return *this;
        }

        CComVariant& operator=(int nSrc)
        {
                if (vt != VT_I4)
                {
                        InternalClear();
                        vt = VT_I4;
                }
                lVal = nSrc;

                return *this;
        }

        CComVariant& operator=(BYTE nSrc)
        {
                if (vt != VT_UI1)
                {
                        InternalClear();
                        vt = VT_UI1;
                }
                bVal = nSrc;
                return *this;
        }

        CComVariant& operator=(short nSrc)
        {
                if (vt != VT_I2)
                {
                        InternalClear();
                        vt = VT_I2;
                }
                iVal = nSrc;
                return *this;
        }

        CComVariant& operator=(long nSrc)
        {
                if (vt != VT_I4)
                {
                        InternalClear();
                        vt = VT_I4;
                }
                lVal = nSrc;
                return *this;
        }

        CComVariant& operator=(float fltSrc)
        {
                if (vt != VT_R4)
                {
                        InternalClear();
                        vt = VT_R4;
                }
                fltVal = fltSrc;
                return *this;
        }

        CComVariant& operator=(double dblSrc)
        {
                if (vt != VT_R8)
                {
                        InternalClear();
                        vt = VT_R8;
                }
                dblVal = dblSrc;
                return *this;
        }

        CComVariant& operator=(CY cySrc)
        {
                if (vt != VT_CY)
                {
                        InternalClear();
                        vt = VT_CY;
                }
                cyVal.Hi = cySrc.Hi;
                cyVal.Lo = cySrc.Lo;
                return *this;
        }

        CComVariant& operator=(IDispatch* pSrc)
        {
                InternalClear();
                vt = VT_DISPATCH;
                pdispVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (pdispVal != NULL)
                        pdispVal->AddRef();
                return *this;
        }

        CComVariant& operator=(IUnknown* pSrc)
        {
                InternalClear();
                vt = VT_UNKNOWN;
                punkVal = pSrc;

                // Need to AddRef as VariantClear will Release
                if (punkVal != NULL)
                        punkVal->AddRef();
                return *this;
        }


// Comparison Operators
public:
        bool operator==(const VARIANT& varSrc) const
        {
                if (this == &varSrc)
                        return true;

                // Variants not equal if types don't match
                if (vt != varSrc.vt)
                        return false;

                // Check type specific values
                switch (vt)
                {
                        case VT_EMPTY:
                        case VT_NULL:
                                return true;

                        case VT_BOOL:
                                return boolVal == varSrc.boolVal;

                        case VT_UI1:
                                return bVal == varSrc.bVal;

                        case VT_I2:
                                return iVal == varSrc.iVal;

                        case VT_I4:
                                return lVal == varSrc.lVal;

                        case VT_R4:
                                return fltVal == varSrc.fltVal;

                        case VT_R8:
                                return dblVal == varSrc.dblVal;

                        case VT_BSTR:
                                return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
                                                (::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

                        case VT_ERROR:
                                return scode == varSrc.scode;

                        case VT_DISPATCH:
                                return pdispVal == varSrc.pdispVal;

                        case VT_UNKNOWN:
                                return punkVal == varSrc.punkVal;

                        default:
                                ATLASSERT(false);
                                // fall through
                }

                return false;
        }
        bool operator!=(const VARIANT& varSrc) const {return !operator==(varSrc);}
        bool operator<(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)==VARCMP_LT;}
        bool operator>(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)==VARCMP_GT;}

// Operations
public:
        HRESULT Clear() { return ::VariantClear(this); }
        HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }
        HRESULT Attach(VARIANT* pSrc)
        {
                // Clear out the variant
                HRESULT hr = Clear();
                if (!FAILED(hr))
                {
                        // Copy the contents and give control to CComVariant
                        memcpy(this, pSrc, sizeof(VARIANT));
                        pSrc->vt = VT_EMPTY;
                        hr = S_OK;
                }
                return hr;
        }

        HRESULT Detach(VARIANT* pDest)
        {
                // Clear out the variant
                HRESULT hr = ::VariantClear(pDest);
                if (!FAILED(hr))
                {
                        // Copy the contents and remove control from CComVariant
                        memcpy(pDest, this, sizeof(VARIANT));
                        vt = VT_EMPTY;
                        hr = S_OK;
                }
                return hr;
        }

        HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL)
        {
                VARIANT* pVar = const_cast<VARIANT*>(pSrc);
                // Convert in place if pSrc is NULL
                if (pVar == NULL)
                        pVar = this;
                // Do nothing if doing in place convert and vts not different
                return ::VariantChangeType(this, pVar, 0, vtNew);
        }

        HRESULT WriteToStream(IStream* pStream);
        HRESULT ReadFromStream(IStream* pStream);

// Implementation
public:
        HRESULT InternalClear()
        {
                HRESULT hr = Clear();
                ATLASSERT(SUCCEEDED(hr));
                if (FAILED(hr))
                {
                        vt = VT_ERROR;
                        scode = hr;
                }
                return hr;
        }

        void InternalCopy(const VARIANT* pSrc)
        {
                HRESULT hr = Copy(pSrc);
                if (FAILED(hr))
                {
                        vt = VT_ERROR;
                        scode = hr;
                }
        }
};

inline HRESULT CComVariant::WriteToStream(IStream* pStream)
{
        HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
        if (FAILED(hr))
                return hr;

        int cbWrite = 0;
        switch (vt)
        {
        case VT_UNKNOWN:
        case VT_DISPATCH:
                {
                        CComPtr<IPersistStream> spStream;
                        if (punkVal != NULL)
                        {
                                hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
                                if (FAILED(hr))
                                        return hr;
                        }
                        if (spStream != NULL)
                                return OleSaveToStream(spStream, pStream);
                        else
                                return WriteClassStm(pStream, CLSID_NULL);
                }
        case VT_UI1:
        case VT_I1:
                cbWrite = sizeof(BYTE);
                break;
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
                cbWrite = sizeof(short);
                break;
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_INT:
        case VT_UINT:
        case VT_ERROR:
                cbWrite = sizeof(long);
                break;
        case VT_R8:
        case VT_CY:
        case VT_DATE:
                cbWrite = sizeof(double);
                break;
        default:
                break;
        }
        if (cbWrite != 0)
                return pStream->Write((void*) &bVal, cbWrite, NULL);

        CComBSTR bstrWrite;
        CComVariant varBSTR;
        if (vt != VT_BSTR)
        {
                hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
                if (FAILED(hr))
                        return hr;
                bstrWrite = varBSTR.bstrVal;
        }
        else
                bstrWrite = bstrVal;

        return bstrWrite.WriteToStream(pStream);
}

inline HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
        ATLASSERT(pStream != NULL);
        HRESULT hr;
        hr = VariantClear(this);
        if (FAILED(hr))
                return hr;
        VARTYPE vtRead;
        hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
        if (hr == S_FALSE)
                hr = E_FAIL;
        if (FAILED(hr))
                return hr;

        vt = vtRead;
        int cbRead = 0;
        switch (vtRead)
        {
        case VT_UNKNOWN:
        case VT_DISPATCH:
                {
                        punkVal = NULL;
                        hr = OleLoadFromStream(pStream,
                                (vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
                                (void**)&punkVal);
                        if (hr == REGDB_E_CLASSNOTREG)
                                hr = S_OK;
                        return S_OK;
                }
        case VT_UI1:
        case VT_I1:
                cbRead = sizeof(BYTE);
                break;
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
                cbRead = sizeof(short);
                break;
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_INT:
        case VT_UINT:
        case VT_ERROR:
                cbRead = sizeof(long);
                break;
        case VT_R8:
        case VT_CY:
        case VT_DATE:
                cbRead = sizeof(double);
                break;
        default:
                break;
        }
        if (cbRead != 0)
        {
                hr = pStream->Read((void*) &bVal, cbRead, NULL);
                if (hr == S_FALSE)
                        hr = E_FAIL;
                return hr;
        }
        CComBSTR bstrRead;

        hr = bstrRead.ReadFromStream(pStream);
        if (FAILED(hr))
                return hr;
        vt = VT_BSTR;
        bstrVal = bstrRead.Detach();
        if (vtRead != VT_BSTR)
                hr = ChangeType(vtRead);
        return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
        CRegKey();
        ~CRegKey();

// Attributes
public:
        operator HKEY() const;
        HKEY m_hKey;

// Operations
public:
        LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
        LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
        LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
        LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

        LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
        static LONG WINAPI SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName,
                LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

        LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
                LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
                REGSAM samDesired = KEY_ALL_ACCESS,
                LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
                LPDWORD lpdwDisposition = NULL);
        LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
                REGSAM samDesired = KEY_ALL_ACCESS);
        LONG Close();
        HKEY Detach();
        void Attach(HKEY hKey);
        LONG DeleteSubKey(LPCTSTR lpszSubKey);
        LONG RecurseDeleteKey(LPCTSTR lpszKey);
        LONG DeleteValue(LPCTSTR lpszValue);
};

inline CRegKey::CRegKey()
{m_hKey = NULL;}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HKEY() const
{return m_hKey;}

inline HKEY CRegKey::Detach()
{
        HKEY hKey = m_hKey;
        m_hKey = NULL;
        return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
        ATLASSERT(m_hKey == NULL);
        m_hKey = hKey;
}

inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
        ATLASSERT(m_hKey != NULL);
        return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
        ATLASSERT(m_hKey != NULL);
        return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

inline LONG CRegKey::Close()
{
        LONG lRes = ERROR_SUCCESS;
        if (m_hKey != NULL)
        {
                lRes = RegCloseKey(m_hKey);
                m_hKey = NULL;
        }
        return lRes;
}

inline LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
        LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
        ATLASSERT(hKeyParent != NULL);
        DWORD dw;
        HKEY hKey = NULL;
        LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
                lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
        if (lpdwDisposition != NULL)
                *lpdwDisposition = dw;
        if (lRes == ERROR_SUCCESS)
        {
                lRes = Close();
                m_hKey = hKey;
        }
        return lRes;
}

inline LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
        ATLASSERT(hKeyParent != NULL);
        HKEY hKey = NULL;
        LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
        if (lRes == ERROR_SUCCESS)
        {
                lRes = Close();
                ATLASSERT(lRes == ERROR_SUCCESS);
                m_hKey = hKey;
        }
        return lRes;
}

inline LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
        DWORD dwType = NULL;
        DWORD dwCount = sizeof(DWORD);
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
                (LPBYTE)&dwValue, &dwCount);
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
        return lRes;
}

inline LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
        ATLASSERT(pdwCount != NULL);
        DWORD dwType = NULL;
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
                (LPBYTE)szValue, pdwCount);
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
                         (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
        return lRes;
}

inline LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        CRegKey key;
        LONG lRes = key.Create(hKeyParent, lpszKeyName);
        if (lRes == ERROR_SUCCESS)
                lRes = key.SetValue(lpszValue, lpszValueName);
        return lRes;
}

inline LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        CRegKey key;
        LONG lRes = key.Create(m_hKey, lpszKeyName);
        if (lRes == ERROR_SUCCESS)
                lRes = key.SetValue(lpszValue, lpszValueName);
        return lRes;
}

inline LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
        ATLASSERT(m_hKey != NULL);
        return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
                (BYTE * const)&dwValue, sizeof(DWORD));
}

inline LONG CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        ATLASSERT(m_hKey != NULL);
        return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
                (BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

inline LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
        CRegKey key;
        LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
        if (lRes != ERROR_SUCCESS)
                return lRes;
        FILETIME time;
        DWORD dwSize = 256;
        TCHAR szBuffer[256];
        while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
                &time)==ERROR_SUCCESS)
        {
                lRes = key.RecurseDeleteKey(szBuffer);
                if (lRes != ERROR_SUCCESS)
                        return lRes;
                dwSize = 256;
        }
        key.Close();
        return DeleteSubKey(lpszKey);
}

inline HRESULT CComModule::RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
        CRegKey keyProgID;
        LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE);
        if (lRes == ERROR_SUCCESS)
        {
                keyProgID.SetValue(lpszUserDesc);
                keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
                return S_OK;
        }
        return HRESULT_FROM_WIN32(lRes);
}

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>

// Statically linking to Registry Ponent
inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
        struct _ATL_REGMAP_ENTRY* pMapEntries)
{
        USES_CONVERSION;
        ATL::CRegObject ro;
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

   // Convert to short path to work around bug in NT4's CreateProcess
   TCHAR szModuleShort[_MAX_PATH];
   GetShortPathName(szModule, szModuleShort, _MAX_PATH);
   LPOLESTR pszModule = T2OLE(szModuleShort);

        int nLen = ocslen(pszModule);
        LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
        ReplaceSingleQuote(pszModuleQuote, pszModule);
        ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
        if (NULL != pMapEntries)
        {
                while (NULL != pMapEntries->szKey)
                {
                        ATLASSERT(NULL != pMapEntries->szData);
                        ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
                        pMapEntries++;
                }
        }

        LPCOLESTR szType = OLESTR("REGISTRY");
        return (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
                        ro.ResourceUnregister(pszModule, nResID, szType);
}

inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
        struct _ATL_REGMAP_ENTRY* pMapEntries)
{
        USES_CONVERSION;
        ATL::CRegObject ro;
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

   // Convert to short path to work around bug in NT4's CreateProcess
   TCHAR szModuleShort[_MAX_PATH];
   GetShortPathName(szModule, szModuleShort, _MAX_PATH);
   LPOLESTR pszModule = T2OLE(szModuleShort);

        int nLen = ocslen(pszModule);
        LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
        ReplaceSingleQuote(pszModuleQuote, pszModule);
        ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
        if (NULL != pMapEntries)
        {
                while (NULL != pMapEntries->szKey)
                {
                        ATLASSERT(NULL != pMapEntries->szData);
                        ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
                        pMapEntries++;
                }
        }

        LPCOLESTR szType = OLESTR("REGISTRY");
        LPCOLESTR pszRes = T2COLE(lpszRes);
        return (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
                        ro.ResourceUnregisterSz(pszModule, pszRes, szType);
}
#endif //_ATL_STATIC_REGISTRY

inline HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
        if (bRegister)
        {
                return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
                        dwFlags);
        }
        else
                return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

inline HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
        static const TCHAR szProgID[] = _T("ProgID");
        static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
        static const TCHAR szLS32[] = _T("LocalServer32");
        static const TCHAR szIPS32[] = _T("InprocServer32");
        static const TCHAR szThreadingModel[] = _T("ThreadingModel");
        static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
        static const TCHAR szApartment[] = _T("Apartment");
        static const TCHAR szBoth[] = _T("both");
        USES_CONVERSION;
        HRESULT hRes = S_OK;
        TCHAR szDesc[256];
        LoadString(m_hInst, nDescID, szDesc, 256);
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(m_hInst, szModule, _MAX_PATH);

        LPOLESTR lpOleStr;
        StringFromCLSID(clsid, &lpOleStr);
        LPTSTR lpsz = OLE2T(lpOleStr);

        hRes = RegisterProgID(lpsz, lpszProgID, szDesc);
        if (hRes == S_OK)
                hRes = RegisterProgID(lpsz, lpszVerIndProgID, szDesc);
        LONG lRes = ERROR_SUCCESS;
        if (hRes == S_OK)
        {
                CRegKey key;
                lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ);
                if (lRes == ERROR_SUCCESS)
                {
                        lRes = key.Create(key, lpsz, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE);
                        if (lRes == ERROR_SUCCESS)
                        {
                                key.SetValue(szDesc);
                                key.SetKeyValue(szProgID, lpszProgID);
                                key.SetKeyValue(szVIProgID, lpszVerIndProgID);

                                if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
                                {
                                        // Convert to short path to work around bug in NT4's CreateProcess
                                        TCHAR szModuleShort[_MAX_PATH];
                                        GetShortPathName(szModule, szModuleShort, _MAX_PATH);
                                        key.SetKeyValue(szLS32, szModuleShort);
                                }
                                else
                                {
                                        key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule);
                                        LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
                                                (dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
                                        if (lpszModel != NULL)
                                                key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
                                }
                        }
                }
        }
        CoTaskMemFree(lpOleStr);
        if (lRes != ERROR_SUCCESS)
                hRes = HRESULT_FROM_WIN32(lRes);
        return hRes;
}

inline HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID)
{
        USES_CONVERSION;
        CRegKey key;

        key.Attach(HKEY_CLASSES_ROOT);
        if (lpszProgID != NULL && lstrcmpi(lpszProgID, _T("")))
                key.RecurseDeleteKey(lpszProgID);
        if (lpszVerIndProgID != NULL && lstrcmpi(lpszVerIndProgID, _T("")))
                key.RecurseDeleteKey(lpszVerIndProgID);
        LPOLESTR lpOleStr;
        StringFromCLSID(clsid, &lpOleStr);
        LPTSTR lpsz = OLE2T(lpOleStr);
        if (key.Open(key, _T("CLSID"), KEY_READ) == ERROR_SUCCESS)
                key.RecurseDeleteKey(lpsz);
        CoTaskMemFree(lpOleStr);
        return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Large Block Allocation Helper - CVBufHelper & CVirtualBuffer


template <class T>
class CVBufHelper
{
public:
        virtual T* operator()(T* pCurrent) {return pCurrent;}
};

template <class T>
class CVirtualBuffer
{
protected:
        CVirtualBuffer() {}
        T* m_pBase;
        T* m_pCurrent;
        T* m_pTop;
        int m_nMaxElements;
public:
        CVirtualBuffer(int nMaxElements)
        {
                m_nMaxElements = nMaxElements;
                m_pBase = (T*) VirtualAlloc(NULL, sizeof(T) * nMaxElements,
                        MEM_RESERVE, PAGE_READWRITE);
                m_pTop = m_pCurrent = m_pBase;
                // Commit first page - chances are this is all that will be used
                VirtualAlloc(m_pBase, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
        }
        ~CVirtualBuffer()
        {
                VirtualFree(m_pBase, 0, MEM_RELEASE);
        }
        int Except(LPEXCEPTION_POINTERS lpEP)
        {
                EXCEPTION_RECORD* pExcept = lpEP->ExceptionRecord;
                if (pExcept->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
                        return EXCEPTION_CONTINUE_SEARCH;
                BYTE* pAddress = (LPBYTE) pExcept->ExceptionInformation[1];
                VirtualAlloc(pAddress, ((BYTE*)m_pTop - (BYTE*)m_pBase), MEM_COMMIT, PAGE_READWRITE);
                return EXCEPTION_CONTINUE_EXECUTION;
        }
        void Seek(int nElement)
        {
                m_pCurrent = &m_pBase[nElement];
        }
        void SetAt(int nElement, const T& Element)
        {
                __try
                {
                        T* p = &m_pBase[nElement]
                        *p = Element;
                        m_pTop = p > m_pTop ? p : m_pTop;
                }
                __except(Except(GetExceptionInformation()))
                {
                }

        }
        template <class Q>
        void WriteBulk(Q& helper)
        {
                __try
                {
                        m_pCurrent = helper(m_pBase);
                        m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
                }
                __except(Except(GetExceptionInformation()))
                {
                }
        }
        void Write(const T& Element)
        {
                __try
                {
                        *m_pCurrent = Element;
                        m_pCurrent++;
                        m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
                }
                __except(Except(GetExceptionInformation()))
                {
                }
        }
        T& Read()
        {
                return *m_pCurrent;
        }
        operator BSTR()
        {
                BSTR bstrTemp;
                __try
                {
                        bstrTemp = SysAllocStringByteLen((char*) m_pBase,
                                (UINT) ((BYTE*)m_pTop - (BYTE*)m_pBase));
                }
                __except(Except(GetExceptionInformation()))
                {
                }
                return bstrTemp;
        }
        const T& operator[](int nElement) const
        {
                return m_pBase[nElement];
        }
        operator T*()
        {
                return m_pBase;
        }
};

typedef CVirtualBuffer<BYTE> CVirtualBytes;


inline HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
        if (atlTraceQI & ATL_TRACE_CATEGORY)
        {
                USES_CONVERSION;
                CRegKey key;
                TCHAR szName[100];
                DWORD dwType,dw = sizeof(szName);

                LPOLESTR pszGUID = NULL;
                StringFromCLSID(iid, &pszGUID);
                OutputDebugString(pszClassName);
                OutputDebugString(_T(" - "));

                // Attempt to find it in the interfaces section
                key.Open(HKEY_CLASSES_ROOT, _T("Interface"), KEY_READ);
                if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
                {
                        *szName = 0;
                        RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
                        OutputDebugString(szName);
                        goto cleanup;
                }
                // Attempt to find it in the clsid section
                key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ);
                if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
                {
                        *szName = 0;
                        RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
                        OutputDebugString(_T("(CLSID\?\?\?) "));
                        OutputDebugString(szName);
                        goto cleanup;
                }
                OutputDebugString(OLE2T(pszGUID));
        cleanup:
                if (hr != S_OK)
                        OutputDebugString(_T(" - failed"));
                OutputDebugString(_T("\n"));
                CoTaskMemFree(pszGUID);
        }
        return hr;
}

#pragma pack(pop)

// WM_FORWARDMSG - used to forward a message to another window for processing
// WPARAM - DWORD dwUserData - defined by user
// LPARAM - LPMSG pMsg - a pointer to the MSG structure
// return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG       0x037F

}; //namespace ATL
using namespace ATL;

//only pull in definition if static linking
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLBASE_IMPL
#endif
#endif

#ifdef _ATL_REDEF_NEW
#pragma pop_macro("new")
#undef _ATL_REDEF_NEW
#endif

#endif // __ATLBASE_H__

//All exports go here
#ifdef _ATLBASE_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
        ATLASSERT(lpszPathName != NULL);

        // always capture the complete file name including extension (if present)
        LPCOLESTR lpszTemp = lpszPathName;
        for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
        {
                LPCOLESTR lp = CharNextO(lpsz);
                // remember last directory/drive separator
                if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
                        lpszTemp = lp;
                lpsz = lp;
        }

        return UINT(lpszTemp-lpszPathName);
}

/////////////////////////////////////////////////////////////////////////////
// QI support

ATLINLINE ATLAPI AtlInternalQueryInterface(void* pThis,
        const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
        ATLASSERT(pThis != NULL);
        // First entry in the com map should be a simple map entry
        ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
        if (ppvObject == NULL)
                return E_POINTER;
        *ppvObject = NULL;
        if (InlineIsEqualUnknown(iid)) // use first interface
        {
                        IUnknown* pUnk = (IUnknown*)((DWORD_PTR)pThis+pEntries->dw);
                        pUnk->AddRef();
                        *ppvObject = pUnk;
                        return S_OK;
        }
        while (pEntries->pFunc != NULL)
        {
                BOOL bBlind = (pEntries->piid == NULL);
                if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
                {
                        if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
                        {
                                ATLASSERT(!bBlind);
                                IUnknown* pUnk = (IUnknown*)((DWORD_PTR)pThis+pEntries->dw);
                                pUnk->AddRef();
                                *ppvObject = pUnk;
                                return S_OK;
                        }
                        else //actual function call
                        {
                                HRESULT hRes = pEntries->pFunc(pThis,
                                        iid, ppvObject, pEntries->dw);
                                if (hRes == S_OK || (!bBlind && FAILED(hRes)))
                                        return hRes;
                        }
                }
                pEntries++;
        }
        return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLINLINE ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
        if (lp != NULL)
                lp->AddRef();
        if (*pp)
                (*pp)->Release();
        *pp = lp;
        return lp;
}

ATLINLINE ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
        IUnknown* pTemp = *pp;
        *pp = NULL;
        if (lp != NULL)
                lp->QueryInterface(riid, (void**)pp);
        if (pTemp)
                pTemp->Release();
        return *pp;
}

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

//This API should be called from the same thread that called
//AtlMarshalPtrInProc
ATLINLINE ATLAPI AtlFreeMarshalStream(IStream* pStream)
{
        if (pStream != NULL)
        {
                LARGE_INTEGER l;
                l.QuadPart = 0;
                pStream->Seek(l, STREAM_SEEK_SET, NULL);
                CoReleaseMarshalData(pStream);
                pStream->Release();
        }
        return S_OK;
}

ATLINLINE ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
        HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
        if (SUCCEEDED(hRes))
        {
                hRes = CoMarshalInterface(*ppStream, iid,
                        pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
                if (FAILED(hRes))
                {
                        (*ppStream)->Release();
                        *ppStream = NULL;
                }
        }
        return hRes;
}

ATLINLINE ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
        *ppUnk = NULL;
        HRESULT hRes = E_INVALIDARG;
        if (pStream != NULL)
        {
                LARGE_INTEGER l;
                l.QuadPart = 0;
                pStream->Seek(l, STREAM_SEEK_SET, NULL);
                hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
        }
        return hRes;
}

ATLINLINE ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent)
{
        DWORD dwRet;
        MSG msg;

        while(1)
        {
                dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT);

                if (dwRet == WAIT_OBJECT_0)
                        return TRUE;    // The event was signaled

                if (dwRet != WAIT_OBJECT_0 + 1)
                        break;          // Something else happened

                // There is one or more window message available. Dispatch them
                while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
                {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                        if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
                                return TRUE; // Event is now signaled.
                }
        }
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLINLINE ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
        CComPtr<IConnectionPointContainer> pCPC;
        CComPtr<IConnectionPoint> pCP;
        HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
        if (SUCCEEDED(hRes))
                hRes = pCPC->FindConnectionPoint(iid, &pCP);
        if (SUCCEEDED(hRes))
                hRes = pCP->Advise(pUnk, pdw);
        return hRes;
}

ATLINLINE ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
        CComPtr<IConnectionPointContainer> pCPC;
        CComPtr<IConnectionPoint> pCP;
        HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
        if (SUCCEEDED(hRes))
                hRes = pCPC->FindConnectionPoint(iid, &pCP);
        if (SUCCEEDED(hRes))
                hRes = pCP->Unadvise(dw);
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLINLINE ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
        LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
        USES_CONVERSION;
        TCHAR szDesc[1024];
        szDesc[0] = NULL;
        // For a valid HRESULT the id should be in the range [0x0200, 0xffff]
        if (IS_INTRESOURCE(lpszDesc)) //id
        {
                UINT nID = LOWORD((DWORD_PTR)lpszDesc);
                ATLASSERT((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
                if (LoadString(hInst, nID, szDesc, 1024) == 0)
                {
                        ATLASSERT(FALSE);
                        lstrcpy(szDesc, _T("Unknown Error"));
                }
                lpszDesc = T2OLE(szDesc);
                if (hRes == 0)
                        hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
        }

        CComPtr<ICreateErrorInfo> pICEI;
        if (SUCCEEDED(CreateErrorInfo(&pICEI)))
        {
                CComPtr<IErrorInfo> pErrorInfo;
                pICEI->SetGUID(iid);
                LPOLESTR lpsz;
                ProgIDFromCLSID(clsid, &lpsz);
                if (lpsz != NULL)
                        pICEI->SetSource(lpsz);
                if (dwHelpID != 0 && lpszHelpFile != NULL)
                {
                        pICEI->SetHelpContext(dwHelpID);
                        pICEI->SetHelpFile(const_cast<LPOLESTR>(lpszHelpFile));
                }
                CoTaskMemFree(lpsz);
                pICEI->SetDescription((LPOLESTR)lpszDesc);
                if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
                        SetErrorInfo(0, pErrorInfo);
        }
        return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Module

struct _ATL_MODULE20
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        CRITICAL_SECTION m_csTypeInfoHolder;
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
};

typedef _ATL_MODULE _ATL_MODULE30;

struct _ATL_OBJMAP_ENTRY20
{
        const CLSID* pclsid;
        HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
        _ATL_CREATORFUNC* pfnGetClassObject;
        _ATL_CREATORFUNC* pfnCreateInstance;
        IUnknown* pCF;
        DWORD dwRegister;
        _ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
};

typedef _ATL_OBJMAP_ENTRY _ATL_OBJMAP_ENTRY30;

inline _ATL_OBJMAP_ENTRY* _NextObjectMapEntry(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* pEntry)
{
        if (pM->cbSize == sizeof(_ATL_MODULE20))
                return (_ATL_OBJMAP_ENTRY*)(((BYTE*)pEntry) + sizeof(_ATL_OBJMAP_ENTRY20));
        return pEntry+1;
}

//Although these functions are big, they are only used once in a module
//so we should make them inline.

ATLINLINE ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
#ifdef _ATL_DLL_IMPL
        if ((pM->cbSize != _nAtlModuleVer21Size) && (pM->cbSize != _nAtlModuleVer30Size) &&
                (pM->cbSize != sizeof(_ATL_MODULE)))
                return E_INVALIDARG;
#else
        ATLASSERT(pM->cbSize == sizeof(_ATL_MODULE));
#endif
        pM->m_pObjMap = p;
        pM->m_hInst = pM->m_hInstTypeLib = pM->m_hInstResource = h;
        pM->m_nLockCnt=0L;
        pM->m_hHeap = NULL;
        InitializeCriticalSection(&pM->m_csTypeInfoHolder);
        InitializeCriticalSection(&pM->m_csWindowCreate);
        InitializeCriticalSection(&pM->m_csObjMap);
#ifdef _ATL_DLL_IMPL
        if (pM->cbSize > _nAtlModuleVer21Size)
#endif
        {
                pM->m_pCreateWndList = NULL;
                pM->m_bDestroyHeap = true;
                pM->m_dwHeaps = 0;
                pM->m_nHeap = 0;
                pM->m_phHeaps = NULL;
                pM->m_pTermFuncs = NULL;
                if (pM->m_pObjMap != NULL)
                {
                        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
                        while (pEntry->pclsid != NULL)
                        {
                                pEntry->pfnObjectMain(true); //initialize class resources
                                pEntry = _NextObjectMapEntry(pM, pEntry);
                        }
                }
        }
#ifdef _ATL_DLL_IMPL
        if (pM->cbSize > _nAtlModuleVer30Size)
#endif
        {
#if _ATL_VER > 0x0300
                pM->m_nNextWindowID = 1;
#endif
        }

        return S_OK;
}

ATLINLINE ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        while (pEntry->pclsid != NULL && hRes == S_OK)
        {
                hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }
        return hRes;
}

ATLINLINE ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        while (pEntry->pclsid != NULL && hRes == S_OK)
        {
                hRes = pEntry->RevokeClassObject();
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }
        return hRes;
}

ATLINLINE ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        if (ppv == NULL)
                return E_POINTER;
        *ppv = NULL;
        while (pEntry->pclsid != NULL)
        {
                if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
                {
                        if (pEntry->pCF == NULL)
                        {
                                EnterCriticalSection(&pM->m_csObjMap);
                                if (pEntry->pCF == NULL)
                                        hRes = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
                                LeaveCriticalSection(&pM->m_csObjMap);
                        }
                        if (pEntry->pCF != NULL)
                                hRes = pEntry->pCF->QueryInterface(riid, ppv);
                        break;
                }
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }
        if (*ppv == NULL && hRes == S_OK)
                hRes = CLASS_E_CLASSNOTAVAILABLE;
        return hRes;
}

ATLINLINE ATLAPI AtlModuleTerm(_ATL_MODULE* pM)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_hInst != NULL);
        if (pM->m_pObjMap != NULL)
        {
                _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
                while (pEntry->pclsid != NULL)
                {
                        if (pEntry->pCF != NULL)
                                pEntry->pCF->Release();
                        pEntry->pCF = NULL;
#ifdef _ATL_DLL_IMPL
                        if (pM->cbSize > _nAtlModuleVer21Size)
#endif
                                pEntry->pfnObjectMain(false); //cleanup class resources
                        pEntry = _NextObjectMapEntry(pM, pEntry);
                }
        }
        DeleteCriticalSection(&pM->m_csTypeInfoHolder);
        DeleteCriticalSection(&pM->m_csWindowCreate);
        DeleteCriticalSection(&pM->m_csObjMap);

#ifdef _ATL_DLL_IMPL
        if (pM->cbSize > _nAtlModuleVer21Size)
#endif
        {
                _ATL_TERMFUNC_ELEM* pElem = pM->m_pTermFuncs;
                _ATL_TERMFUNC_ELEM* pNext = NULL;
                while (pElem != NULL)
                {
                        pElem->pFunc(pElem->dw);
                        pNext = pElem->pNext;
                        delete pElem;
                        pElem = pNext;
                }
                if (pM->m_hHeap != NULL && pM->m_bDestroyHeap)
                {
#ifndef _ATL_NO_MP_HEAP
                        if (pM->m_phHeaps != NULL)
                        {
                                for (DWORD i = 0; i <= pM->m_dwHeaps; i++)
                                        HeapDestroy(pM->m_phHeaps[i]);
                        }
#endif
                        HeapDestroy(pM->m_hHeap);
                }
        }
        return S_OK;
}

ATLINLINE ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD_PTR dw)
{
        HRESULT hr = S_OK;
        _ATL_TERMFUNC_ELEM* pNew = NULL;
        ATLTRY(pNew = new _ATL_TERMFUNC_ELEM);
        if (pNew == NULL)
                hr = E_OUTOFMEMORY;
        else
        {
                pNew->pFunc = pFunc;
                pNew->dw = dw;
                EnterCriticalSection(&pM->m_csStaticDataInit);
                pNew->pNext = pM->m_pTermFuncs;
                pM->m_pTermFuncs = pNew;
                LeaveCriticalSection(&pM->m_csStaticDataInit);
        }
        return hr;
}

ATLINLINE ATLAPI AtlRegisterClassCategoriesHelper( REFCLSID clsid,
   const struct _ATL_CATMAP_ENTRY* pCatMap, BOOL bRegister )
{
   CComPtr< ICatRegister > pCatRegister;
   HRESULT hResult;
   const struct _ATL_CATMAP_ENTRY* pEntry;
   CATID catid;

   if( pCatMap == NULL )
   {
          return( S_OK );
   }

   hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL,
          CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pCatRegister );
   if( FAILED( hResult ) )
   {
          // Since not all systems have the category manager installed, we'll allow
          // the registration to succeed even though we didn't register our
          // categories.  If you really want to register categories on a system
          // without the category manager, you can either manually add the
          // appropriate entries to your registry script (.rgs), or you can
          // redistribute comcat.dll.
          return( S_OK );
   }

   hResult = S_OK;
   pEntry = pCatMap;
   while( pEntry->iType != _ATL_CATMAP_ENTRY_END )
   {
          catid = *pEntry->pcatid;
          if( bRegister )
          {
                 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
                 {
                        hResult = pCatRegister->RegisterClassImplCategories( clsid, 1,
                           &catid );
                 }
                 else
                 {
                        ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
                        hResult = pCatRegister->RegisterClassReqCategories( clsid, 1,
                           &catid );
                 }
                 if( FAILED( hResult ) )
                 {
                        return( hResult );
                 }
          }
          else
          {
                 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
                 {
                        pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );
                 }
                 else
                 {
                        ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
                        pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );
                 }
          }
          pEntry++;
   }

   return( S_OK );
}

ATLINLINE ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_hInst != NULL);
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
        {
                if (pCLSID == NULL)
                {
                        if (pEntry->pfnGetObjectDescription != NULL &&
                                pEntry->pfnGetObjectDescription() != NULL)
                                        continue;
                }
                else
                {
                        if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
                                continue;
                }
                hRes = pEntry->pfnUpdateRegistry(TRUE);
                if (FAILED(hRes))
                        break;
                if (pM->cbSize == sizeof(_ATL_MODULE))
                {
                        hRes = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
                                pEntry->pfnGetCategoryMap(), TRUE );
                        if (FAILED(hRes))
                                break;
                }
        }
        if (SUCCEEDED(hRes) && bRegTypeLib)
                hRes = AtlModuleRegisterTypeLib(pM, 0);
        return hRes;
}

ATLINLINE ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_hInst != NULL);
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
        {
                if (pCLSID == NULL)
                {
                        if (pEntry->pfnGetObjectDescription != NULL
                                && pEntry->pfnGetObjectDescription() != NULL)
                                continue;
                }
                else
                {
                        if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
                                continue;
                }
                pEntry->pfnUpdateRegistry(FALSE); //unregister
        if (pM->cbSize == sizeof(_ATL_MODULE) && pEntry->pfnGetCategoryMap != NULL)
                AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
                        pEntry->pfnGetCategoryMap(), FALSE );
        }
        if (bUnRegTypeLib)
                AtlModuleUnRegisterTypeLib(pM, 0);
        return S_OK;
}

ATLINLINE ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID)
{
        return AtlModuleUnregisterServerEx(pM, FALSE, pCLSID);
}

ATLINLINE ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE* pM, LPCOLESTR lpszRes,
        BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg)
{
        USES_CONVERSION;
        ATLASSERT(pM != NULL);
        HRESULT hRes = S_OK;
        CComPtr<IRegistrar> p;
        if (pReg != NULL)
                p = pReg;
        else
        {
                hRes = CoCreateInstance(CLSID_Registrar, NULL,
                        CLSCTX_INPROC_SERVER, IID_IRegistrar, (void**)&p);
        }
        if (SUCCEEDED(hRes))
        {
                TCHAR szModule[_MAX_PATH];
                GetModuleFileName(pM->m_hInst, szModule, _MAX_PATH);

          // Convert to short path to work around bug in NT4's CreateProcess
          TCHAR szModuleShort[_MAX_PATH];
          GetShortPathName(szModule, szModuleShort, _MAX_PATH);
          LPOLESTR pszModule = T2OLE(szModuleShort);

                int nLen = ocslen(pszModule);
                LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
                CComModule::ReplaceSingleQuote(pszModuleQuote, pszModule);
                p->AddReplacement(OLESTR("Module"), pszModuleQuote);

                if (NULL != pMapEntries)
                {
                        while (NULL != pMapEntries->szKey)
                        {
                                ATLASSERT(NULL != pMapEntries->szData);
                                p->AddReplacement((LPOLESTR)pMapEntries->szKey, (LPOLESTR)pMapEntries->szData);
                                pMapEntries++;
                        }
                }
                LPCOLESTR szType = OLESTR("REGISTRY");
                if (DWORD_PTR(lpszRes)<=0xffff)
                {
                        if (bRegister)
                                hRes = p->ResourceRegister(pszModule, ((UINT)LOWORD((DWORD_PTR)lpszRes)), szType);
                        else
                                hRes = p->ResourceUnregister(pszModule, ((UINT)LOWORD((DWORD_PTR)lpszRes)), szType);
                }
                else
                {
                        if (bRegister)
                                hRes = p->ResourceRegisterSz(pszModule, lpszRes, szType);
                        else
                                hRes = p->ResourceUnregisterSz(pszModule, lpszRes, szType);
                }

        }
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

ATLINLINE ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib)
{
        *pbstrPath = NULL;
        *ppTypeLib = NULL;
        ATLASSERT(pM != NULL);
        USES_CONVERSION;
        ATLASSERT(pM->m_hInstTypeLib != NULL);
        TCHAR szModule[_MAX_PATH+10];
        GetModuleFileName(pM->m_hInstTypeLib, szModule, _MAX_PATH);
        if (lpszIndex != NULL)
                lstrcat(szModule, OLE2CT(lpszIndex));
        LPOLESTR lpszModule = T2OLE(szModule);
        HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);
        if (!SUCCEEDED(hr))
        {
                // typelib not in module, try <module>.tlb instead
                LPTSTR lpszExt = NULL;
                LPTSTR lpsz;
                for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
                {
                        if (*lpsz == _T('.'))
                                lpszExt = lpsz;
                }
                if (lpszExt == NULL)
                        lpszExt = lpsz;
                lstrcpy(lpszExt, _T(".tlb"));
                lpszModule = T2OLE(szModule);
                hr = LoadTypeLib(lpszModule, ppTypeLib);
        }
        if (SUCCEEDED(hr))
                *pbstrPath = OLE2BSTR(lpszModule);
        return hr;
}

ATLINLINE ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
        typedef HRESULT (WINAPI *PFNRTL)(REFGUID, WORD, WORD, LCID, SYSKIND);
        CComBSTR bstrPath;
        CComPtr<ITypeLib> pTypeLib;
        HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
        if (SUCCEEDED(hr))
        {
                TLIBATTR* ptla;
                HRESULT hr = pTypeLib->GetLibAttr(&ptla);
                if (SUCCEEDED(hr))
                {
                        HINSTANCE h = LoadLibrary(_T("oleaut32.dll"));
                        if (h != NULL)
                        {
                                PFNRTL pfn = (PFNRTL) GetProcAddress(h, "UnRegisterTypeLib");
                                if (pfn != NULL)
                                        hr = pfn(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);
                                FreeLibrary(h);
                        }
                        pTypeLib->ReleaseTLibAttr(ptla);
                }
        }
        return hr;
}

ATLINLINE ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
        CComBSTR bstrPath;
        CComPtr<ITypeLib> pTypeLib;
        HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
        if (SUCCEEDED(hr))
        {
                OLECHAR szDir[_MAX_PATH];
                ocscpy(szDir, bstrPath);
                szDir[AtlGetDirLen(szDir)] = 0;
                hr = ::RegisterTypeLib(pTypeLib, bstrPath, szDir);
        }
        return hr;
}

ATLINLINE ATLAPI_(DWORD) AtlGetVersion(void* /* pReserved */)
{
        return _ATL_VER;
}

ATLINLINE ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject)
{
        pData->m_pThis = pObject;
        pData->m_dwThreadID = ::GetCurrentThreadId();
        ::EnterCriticalSection(&pM->m_csWindowCreate);
        pData->m_pNext = pM->m_pCreateWndList;
        pM->m_pCreateWndList = pData;
        ::LeaveCriticalSection(&pM->m_csWindowCreate);
}

ATLINLINE ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM)
{
        void* pv = NULL;
        ::EnterCriticalSection(&pM->m_csWindowCreate);
        _AtlCreateWndData* pEntry = pM->m_pCreateWndList;
        if(pEntry != NULL)
        {
                DWORD dwThreadID = ::GetCurrentThreadId();
                _AtlCreateWndData* pPrev = NULL;
                while(pEntry != NULL)
                {
                        if(pEntry->m_dwThreadID == dwThreadID)
                        {
                                if(pPrev == NULL)
                                        pM->m_pCreateWndList = pEntry->m_pNext;
                                else
                                        pPrev->m_pNext = pEntry->m_pNext;
                                pv = pEntry->m_pThis;
                                break;
                        }
                        pPrev = pEntry;
                        pEntry = pEntry->m_pNext;
                }
        }
        ::LeaveCriticalSection(&pM->m_csWindowCreate);
        return pv;
}

/////////////////////////////////////////////////////////////////////////////
// General DLL Version Helpers

inline HRESULT AtlGetDllVersion(HINSTANCE hInstDLL, DLLVERSIONINFO* pDllVersionInfo)
{
        ATLASSERT(pDllVersionInfo != NULL);
        if(::IsBadWritePtr(pDllVersionInfo, sizeof(DWORD)))
                return E_INVALIDARG;

        // We must get this function explicitly because some DLLs don't implement it.
        DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)::GetProcAddress(hInstDLL, "DllGetVersion");
        if(pfnDllGetVersion == NULL)
                return E_NOTIMPL;

        return (*pfnDllGetVersion)(pDllVersionInfo);
}

inline HRESULT AtlGetDllVersion(LPCTSTR lpstrDllName, DLLVERSIONINFO* pDllVersionInfo)
{
        HINSTANCE hInstDLL = ::LoadLibrary(lpstrDllName);
        if(hInstDLL == NULL)
                return E_FAIL;
        HRESULT hRet = AtlGetDllVersion(hInstDLL, pDllVersionInfo);
        ::FreeLibrary(hInstDLL);
        return hRet;
}

// Common Control Versions:
//   Win95/WinNT 4.0    maj=4 min=00
//   IE 3.x     maj=4 min=70
//   IE 4.0     maj=4 min=71
inline HRESULT AtlGetCommCtrlVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
        ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
        if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
                return E_INVALIDARG;

        DLLVERSIONINFO dvi;
        ::ZeroMemory(&dvi, sizeof(dvi));
        dvi.cbSize = sizeof(dvi);
        HRESULT hRet = AtlGetDllVersion(_T("comctl32.dll"), &dvi);

        if(SUCCEEDED(hRet))
        {
                *pdwMajor = dvi.dwMajorVersion;
                *pdwMinor = dvi.dwMinorVersion;
        }
        else if(hRet == E_NOTIMPL)
        {
                // If DllGetVersion is not there, then the DLL is a version
                // previous to the one shipped with IE 3.x
                *pdwMajor = 4;
                *pdwMinor = 0;
                hRet = S_OK;
        }

        return hRet;
}

// Shell Versions:
//   Win95/WinNT 4.0                    maj=4 min=00
//   IE 3.x, IE 4.0 without Web Integrated Desktop  maj=4 min=00
//   IE 4.0 with Web Integrated Desktop         maj=4 min=71
//   IE 4.01 with Web Integrated Desktop        maj=4 min=72
inline HRESULT AtlGetShellVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
        ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
        if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
                return E_INVALIDARG;

        DLLVERSIONINFO dvi;
        ::ZeroMemory(&dvi, sizeof(dvi));
        dvi.cbSize = sizeof(dvi);
        HRESULT hRet = AtlGetDllVersion(_T("shell32.dll"), &dvi);

        if(SUCCEEDED(hRet))
        {
                *pdwMajor = dvi.dwMajorVersion;
                *pdwMinor = dvi.dwMinorVersion;
        }
        else if(hRet == E_NOTIMPL)
        {
                // If DllGetVersion is not there, then the DLL is a version
                // previous to the one shipped with IE 4.x
                *pdwMajor = 4;
                *pdwMinor = 0;
                hRet = S_OK;
        }

        return hRet;
}

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time
#undef _ATLBASE_IMPL

#endif // _ATLBASE_IMPL

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\include\tvestats.h ===
// --------------------------------------------------------------------------------
// TveStats.h
//
//		Private little data structure for passing simple stats data out of TveSuper
//		into TveFilt...
//
// ---------------------------------------------------------------------------------

#ifndef __TVESTATS_H__
#define __TVESTATS_H__

class  CTVEStats
{
public:
	CTVEStats()				{Init();}

	void Init()				{memset((void*) this, 0, sizeof(CTVEStats)); }
	long					m_cTunes;
	long					m_cFiles;
	long					m_cPackages;
	long					m_cTriggers;
	long					m_cXOverLinks;
	long					m_cEnhancements;
	long					m_cAuxInfos;			// errors..
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\include\tvedbg.h ===
// Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.


#ifndef __TVEDBG_H__
#define __TVEDBG_H__

#include <stdio.h>
#include "defreg.h"				// registry locations 

#define CHECK_OUT_PARAM(p) \
	if(NULL == p) return E_POINTER;

template <typename T>
inline void CheckOutPtr(T *pVal)
{
    if (IsBadWritePtr(pVal, sizeof(T)))
		 _com_issue_error((HRESULT) E_POINTER);
}

template <typename T>
inline void CheckInPtr(T *pT)
{
    if (IsBadReadPtr(pT, sizeof(T)))
		_com_issue_error((HRESULT) E_POINTER);
}

//////////////////////////////////////////////////////////////////////////////
//   Debug Code...
//
//
//		This code creates a tracing system.
//
//		In each method or function, 
//			add a header
//				DBG_HEADER(flags,  header_string)
//
//			and zero or more:
//			  TVEDebugLog( (DWORD flags1, DWORD level, TCHAR*  formatString, ...))		// note double parens
//			  TVEDebugLog2((DWORD flags2, DWORD level, TCHAR*  formatString, ...))		// note double parens
//			  TVEDebugLog3((DWORD flags3, DWORD level, TCHAR*  formatString, ...))		// note double parens
//			  TVEDebugLog4((DWORD flags4, DWORD level, TCHAR*  formatString, ...))		// note double parens
//
//			The header is printed out when the method is entered, and before the log messages
//
//
//		In the main file, add the line:  
//
//				DBG_INIT(TCHAR registryLoc);
//
//				This creates the global entry g_log used for logging, and initializes it.  It must
//				be called once.
//
//				registryLoc is the subkey in the registy used for this project  (Something like "TveLog")
//
//		In some main routine (constructor of the main object), optionally add a line:
//
//		   DBG_SET_LOGFLAGS(str, grfFlags, level)
//				str      - name of the log file.  If NULL, don't trace to a file
//				grfFlags - or'ed collection of flags to trace.  
//				level    - trace level (1 terse, 3 normal, 5 verbose, 8 very verbose) 
//
//			Non-zero registry values will override the level and flags.  These are (currently)
//			located at:
//
//
//				 HKEY_LOCAL_MACHINE\SOFTWARE\Debug\MSTvE\{X}\(pcLogRegLocation)
//
//					{X}						: is either LogTve or LogTveFilt
//					{pcLogRegLocation}		: is either "Level" or "Flags"
//
//					Registry location can be changed by altering defreg.h
//						DEF_DBG_BASE		- SOFTWARE\\Debug\\
//						DEF_REG_LOCATION	- MSTvE
//
//
//			Non debug keys are located at...
//
//				 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\TV Services\MSTvE\{X}\(pcLogRegLocation)
//
//						DEF_REG_BASE		- SOFTWARE\\Microsoft\\TV Services\\
//						DEF_REG_LOCATION	- MSTvE
//
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Cool Debug Macro
//
//		TVEDebugLog((flags, level, "xxx %d, %d", a, b))		-- double paren thingy
//
//		
//			Flags is an OR of one or more of the enums defined in CDebugLog
//			Level is 0-8, 0 being all the time, 3 being standard trace, 5 being verbose
//			
/////////////////////////////////////////////////////////////////////////////
#ifndef _TVEDEBUG	// inactive debugging

#define _TVEDEBUG_ACTIVE		0			// used to turn .cpp compling on and off						
#define DBG_INIT(reg) 
#define DBG_WARN(flags, str) 
#define DBG_SET_LOGFLAGS(str, grfFlags1, grfFlags2, grfFlags3, grfFlags4, level) 
#define DBG_APPEND_LOGFLAGS(grfFlags1, grfFlags2, grfFlags3, grfFlags4, level)
#define DBG_HEADER(flags, headerString) 
#define DBG_FSET(grfFlags) false		// return 'false', used to remove coee
#define DBG_FSET1(grfFlags) false		// return 'false', used to remove coee
#define DBG_FSET2(grfFlags) false		// return 'false', used to remove coee
#define DBG_FSET3(grfFlags) false		// return 'false', used to remove coee
#define DBG_FSET4(grfFlags) false		// return 'false', used to remove coee
#define TVEDebugLog(_x_) 
#define TVEDebugLog1(_x_) 
#define TVEDebugLog2(_x_) 
#define TVEDebugLog3(_x_) 
#define TVEDebugLog4(_x_) 
#define DBG_StartingANewThread() 

#else	// active debugging

#define _TVEDEBUG_ACTIVE		1		
extern void WINAPI TVEDebugLogInfo1(DWORD flags1, DWORD Level, const TCHAR *pFormat,...);
extern void WINAPI TVEDebugLogInfo2(DWORD flags2, DWORD Level, const TCHAR *pFormat,...);
extern void WINAPI TVEDebugLogInfo3(DWORD flags3, DWORD Level, const TCHAR *pFormat,...);
extern void WINAPI TVEDebugLogInfo4(DWORD flags4, DWORD Level, const TCHAR *pFormat,...);

/////////////////////////////////////////////////////////////////////////////
// Debug Logging
class CDebugLog
{
public:
    FILE* m_fileLog;
	TCHAR m_szLogFileName[256];
    DWORD m_dwLogFlags1;
	DWORD m_dwLogFlags2;			// for second set of log flags
	DWORD m_dwLogFlags3;			// for second set of log flags
	DWORD m_dwLogFlags4;			// for second set of log flags
	DWORD m_dwLogLevel;
	TCHAR *m_pszHeader;
    
public:	// Construction, Destruction
    CDebugLog(const TCHAR* pcLogRegLocation);
    ~CDebugLog();

private:
    void LogOut(const TCHAR* pcString, HRESULT hr);

public:	// Logging		(use TVEDebugLog instead of these...
	void Log1(DWORD dwFlags1, DWORD dwLevel, const TCHAR* pcString, HRESULT hr);
  	void Log2(DWORD dwFlags2, DWORD dwLevel, const TCHAR* pcString, HRESULT hr);
 	void Log3(DWORD dwFlags3, DWORD dwLevel, const TCHAR* pcString, HRESULT hr);
 	void Log4(DWORD dwFlags4, DWORD dwLevel, const TCHAR* pcString, HRESULT hr);
  
	void Log(DWORD dwFlags1, const TCHAR* pcString = NULL, HRESULT hr = S_OK);
    void Log(DWORD dwFlags1, UINT iResource, HRESULT hr = S_OK);

    void LogEvaluate(const TCHAR* pcString, HRESULT hr);
    void LogEvaluate(UINT iResource, HRESULT hr);
    void LogHeader(DWORD dwFlags1, const TCHAR* pcHeader, int cLevel=0);
	void LogTrailer(DWORD dwFlags1, const TCHAR* pcHeader, int cLevel=0);

    void SetLogFlags(const TCHAR* pcLogFileName, 
					 DWORD dwLogFlags1, DWORD dwLogFlags2, DWORD dwLogFlags3, DWORD dwLogFlags4,  
					 DWORD dwLogLevel);		// to override Registry usage

	BOOL FSet(DWORD dwLogFlags1)	{return 0 != (dwLogFlags1 & m_dwLogFlags1);}		// for compat, get rid of it
	BOOL FSet1(DWORD dwLogFlags1)	{return 0 != (dwLogFlags1 & m_dwLogFlags1);}
	BOOL FSet2(DWORD dwLogFlags2)	{return 0 != (dwLogFlags2 & m_dwLogFlags2);}
	BOOL FSet3(DWORD dwLogFlags3)	{return 0 != (dwLogFlags3 & m_dwLogFlags3);}
	BOOL FSet4(DWORD dwLogFlags4)	{return 0 != (dwLogFlags4 & m_dwLogFlags4);}

	DWORD Level()					{return m_dwLogLevel;}
	DWORD Flags1()					{return m_dwLogFlags1;}
	DWORD Flags2()					{return m_dwLogFlags2;}
	DWORD Flags3()					{return m_dwLogFlags3;}
	DWORD Flags4()					{return m_dwLogFlags4;}
	TCHAR *LogFileName()			{return m_szLogFileName;}

	void SetHeader(TCHAR *pcHeader)		{m_pszHeader = pcHeader;}

public: // Flags
    enum 
    {
	DBG_NONE			= 0x00000000,

	DBG_SEV1			= 0x00000001,	    // Basic Structure
	DBG_SEV2			= 0x00000002,	    // Error Conditions
	DBG_SEV3			= 0x00000004,	    // Warning Conditions
	DBG_SEV4			= 0x00000008,	    // Generic Info

								//  TveContr flags 

	DBG_EVENT			= 0x00000010,		// any upward event
	DBG_PACKET_RCV		= 0x00000020,		// each packet received..
	DBG_MCASTMNGR		= 0x00000040,		// multicast manager
	DBG_MCAST			= 0x00000080,		// multicast object (multiple ones)

	DBG_SUPERVISOR		= 0x00000100,		// TVE Supervisor
	DBG_SERVICE			= 0x00000200,		// Services
	DBG_ENHANCEMENT		= 0x00000400,		// Enhancements
	DBG_VARIATION		= 0x00000800,		// Variations
	DBG_TRACK			= 0x00001000,		// Tracks
	DBG_TRIGGER			= 0x00002000,		// triggers
	DBG_EXPIREQ			= 0x00004000,		// Property page messages and events

	DBG_MIME			= 0x00008000,

	DBG_UHTTP			= 0x00010000,
	DBG_UHTTPPACKET		= 0x00020000,
	DBG_FCACHE			= 0x00040000,

	DBG_other			= 0x00080000,		// used in DBG2-DBG4 headers, since don't have DUMP_HEADER2 yet

					// TVEFilt events
										// keep >= 0x0000 0010  and < 0x1000 0000
											
	DBG_FLT				= 0x00100000,		// General TVE Filter stuff
	DBG_FLT_DSHOW		= 0x00200000,		// DShow events for TveFilter stuff
	DBG_FLT_PIN_TUNE	= 0x00400000,		// Tune pin events
	DBG_FLT_PIN_CC		= 0x00800000,		// CC pin events
	DBG_FLT_CC_DECODER  = 0x01000000,		// CC Decoder state
	DBG_FLT_CC_PARSER   = 0x02000000,		// Internal CC Decoder state
	DBG_FLT_CC_PARSER2  = 0x04000000,		// Internal stuff about CC Decoder state
	DBG_FLT_PROPS		= 0x08000000,		// Property page messages and events

					// TVEGSeg and other external parts 

	DBG_GSEG			= 0x10000000,		// General TVE Graph Segment stuff
	DBG_FEATURE			= 0x20000000,		// General ITVEFeature
	DBG_TRIGGERCTRL     = 0x40000000,		// TriggerCtrl
	DBG_NAVAID			= 0x80000000,		// ITVENavAid

	DBG_FEAT_EVENTS		= 0x00000010,		// ITVEFeature Events		(ran out of bits...)


				// --------------------------------------------------------
				//  Bank 2
	DBG2_NONE					= 0x00000000,		// 
	DBG2_TEMP1					= 0x00000001,	
	DBG2_TEMP2					= 0x00000002,	
	DBG2_TEMP3					= 0x00000004,	
	DBG2_TEMP4					= 0x00000008,	

	DBG2_DUMP_PACKAGES			= 0x00000010,		// Dump packages as we receive them
	DBG2_DUMP_MISSPACKET		= 0x00000020,		// dump missing packets occasionally...

					// --------------------------------------------------------
				//  Bank 3
	DBG3_NONE					= 0x00000000,		// Placeholder
	DBG3_TEMP1					= 0x00000001,	
	DBG3_TEMP2					= 0x00000002,	
	DBG3_TEMP3					= 0x00000004,	
	DBG3_TEMP4					= 0x00000008,	

			// --------------------------------------------------------
				//  Bank 4
	DBG4_NONE					= 0x00000000,	
	
	DBG4_WRITELOG				= 0x00000001,		// write to a fresh log file, 	
	DBG4_APPENDLOG				= 0x00000002,		// append to existing to log file, 
	DBG4_ATLTRACE				= 0x00000004,		// turn on atl interface tracing 
	DBG4_TRACE					= 0x00000008,		// trace methods as enter/exit them

	DBG4_EVALUATE				= 0x00000010,		// some sort of time tracing guy..

	DBG4_BOGUS					= 0					// just to get that last non comman
    };

};


//
/////////////////////////////////////////////////////////////////////////////
// Debug Globals					// defaults for DBG_WARN macro - change to use TVEDebugLog program
extern CDebugLog g_Log;
extern TCHAR	*g_pcDbgHeader;

									// Create a g_Log.  'reg' is name of registry key
#define DBG_INIT(reg) \
    CDebugLog g_Log(reg);

/////////////////////////////////////////////////////////////////////////////
// Debug Macros
				
#define DBG_WARN(flags1, str) {g_Log.SetHeader(l_TraceFunc.l_pcDbgHeader); \
                              g_Log.Log1(flags1, 3, str, S_OK); }						// warn at Level 3

#define DBG_SET_LOGFLAGS(str, grfFlags1, grfFlags2, grfFlags3, grfFlags4, level) \
    g_Log.SetLogFlags(str, grfFlags1, grfFlags2, grfFlags3, grfFlags4, level);

#define DBG_APPEND_LOGFLAGS(grfFlags1, grfFlags2, grfFlags3, grfFlags4,  level) \
    g_Log.SetLogFlags(g_Log.LogFileName(), \
		grfFlags1 | g_Log.Flags1(), \
		grfFlags2 | g_Log.Flags2(), \
		grfFlags3 | g_Log.Flags3(), \
		grfFlags4 | g_Log.Flags4(), \
	level);

static int g_cLevel = 0;
												
class TraceFunc
{
public:
	DWORD l_dwDbgFlags;
    TCHAR* l_pcDbgHeader;

	TraceFunc(DWORD flags1, TCHAR* headerString)
	{
		l_pcDbgHeader = headerString;
		l_dwDbgFlags = flags1; 
		g_cLevel++;
		g_Log.LogHeader(l_dwDbgFlags, l_pcDbgHeader, g_cLevel); 
	}
	~TraceFunc()	
	{
		g_Log.LogTrailer(l_dwDbgFlags, l_pcDbgHeader, g_cLevel);
		g_cLevel--;
	}
};
										// save flags, header in local variables
#define DBG_HEADER(flags1, headerString) \
 	TraceFunc l_TraceFunc(flags1,headerString);

										// when startup a tread, never 'exit' a method.  So bop the count here...  really need counter per thread.
#define DBG_StartingANewThread() \
    { g_cLevel--; }                 

		// could change this to return 0 in Release build to remove large sections of code..
#define DBG_FSET(grfFlags1) \
    (0 != g_Log.FSet1(grfFlags1))		// for compat , remove when get around to it...

#define DBG_FSET1(grfFlags1) \
    (0 != g_Log.FSet1(grfFlags1))
#define DBG_FSET2(grfFlags2) \
    (0 != g_Log.FSet2(grfFlags2))
#define DBG_FSET3(grfFlags3) \
    (0 != g_Log.FSet3(grfFlags3))
#define DBG_FSET4(grfFlags4) \
    (0 != g_Log.FSet4(grfFlags4))

//		 TVEDebugLogN((DWORD flags1, DWORD level, TCHAR*  formatString, ...))		// note double parens

					// for compat
#define TVEDebugLog(_x_) {g_Log.SetHeader(l_TraceFunc.l_pcDbgHeader); \
                          TVEDebugLogInfo1 _x_ ; }

#define TVEDebugLog1(_x_) {g_Log.SetHeader(l_TraceFunc.l_pcDbgHeader); \
                          TVEDebugLogInfo1 _x_ ; }
#define TVEDebugLog2(_x_) {g_Log.SetHeader(l_TraceFunc.l_pcDbgHeader); \
                          TVEDebugLogInfo2 _x_ ; }
#define TVEDebugLog3(_x_) {g_Log.SetHeader(l_TraceFunc.l_pcDbgHeader); \
                          TVEDebugLogInfo3 _x_ ; }
#define TVEDebugLog4(_x_) {g_Log.SetHeader(l_TraceFunc.l_pcDbgHeader); \
                          TVEDebugLogInfo4 _x_ ; }

#endif		// active debugging

#endif		// __TVEDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\include\tveenum.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// ----------------------------------------------------------
//  TVEEnum.h
//
//		an attempt at writing my own ATL enumerator / collection class).
//		This is based on STL, but allows for snapshop copies and locking.
///
//		It solves these problems:
//			(Mentioned in Professional ATL Com Programming - 671).  
//		"<ICollectionOnSTLImpl> provides dynamic access to the m_coll 
//		 container, so once the enumerator has been given out, you should not
//		 add or remove any items from the container."
//		".. It also doesn't include a locking mechanism..."

#include <atlcom.h>

#if 0 //--------------------------------------------------
template<class T>
class ATL_NO_VTABLE CComIEnum : public IUnknown
{
public:
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched) = 0;
	STDMETHOD(Skip)(ULONG celt) = 0;
	STDMETHOD(Reset)(void) = 0;
	STDMETHOD(Clone)(CComIEnum<T>** ppEnum) = 0;
};


enum CComEnumFlags
{
	//see FlagBits in CComEnumImpl
	AtlFlagNoCopy = 0,
	AtlFlagTakeOwnership = 2,
	AtlFlagCopy = 3 // copy implies ownership
};

template <class Base, const IID* piid, class T, class Copy>
class ATL_NO_VTABLE CComEnumImpl : public Base
{
public:
	CComEnumImpl() {m_begin = m_end = m_iter = NULL; m_dwFlags = 0;}
	~CComEnumImpl();
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)(void){m_iter = m_begin;return S_OK;}
	STDMETHOD(Clone)(Base** ppEnum);
	HRESULT Init(T* begin, T* end, IUnknown* pUnk,
		CComEnumFlags flags = AtlFlagNoCopy);
	CComPtr<IUnknown> m_spUnk;
	T* m_begin;
	T* m_end;
	T* m_iter;
	DWORD m_dwFlags;
protected:
	enum FlagBits
	{
		BitCopy=1,
		BitOwn=2
	};
};

template <class Base, const IID* piid, class T, class Copy>
CComEnumImpl<Base, piid, T, Copy>::~CComEnumImpl()
{
	if (m_dwFlags & BitOwn)
	{
		for (T* p = m_begin; p != m_end; p++)
			Copy::destroy(p);
		delete [] m_begin;
	}
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Next(ULONG celt, T* rgelt,
	ULONG* pceltFetched)
{
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
		return E_POINTER;
	if (m_begin == NULL || m_end == NULL || m_iter == NULL)
		return E_FAIL;
	ULONG nRem = (ULONG)(m_end - m_iter);
	HRESULT hRes = S_OK;
	if (nRem < celt)
		hRes = S_FALSE;
	ULONG nMin = min(celt, nRem);
	if (pceltFetched != NULL)
		*pceltFetched = nMin;
	T* pelt = rgelt;
	while(nMin--)
	{
		HRESULT hr = Copy::copy(pelt, m_iter);
		if (FAILED(hr))
		{
			while (rgelt < pelt)
				Copy::destroy(rgelt++);
			if (pceltFetched != NULL)
				*pceltFetched = 0;
			return hr;
		}
		pelt++;
		m_iter++;
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Skip(ULONG celt)
{
	m_iter += celt;
	if (m_iter <= m_end)
		return S_OK;
	m_iter = m_end;
	return S_FALSE;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Clone(Base** ppEnum)
{
	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		*ppEnum = NULL;
		_class* p;
		hRes = _class::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			// If the data is a copy then we need to keep "this" object around
			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitCopy) ? this : m_spUnk);
			if (SUCCEEDED(hRes))
			{
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
			}
			if (FAILED(hRes))
				delete p;
		}
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
HRESULT CComEnumImpl<Base, piid, T, Copy>::Init(T* begin, T* end, IUnknown* pUnk,
	CComEnumFlags flags)
{
	if (flags == AtlFlagCopy)
	{
		ATLASSERT(m_begin == NULL); //Init called twice?
		ATLTRY(m_begin = new T[end-begin])
		m_iter = m_begin;
		if (m_begin == NULL)
			return E_OUTOFMEMORY;
		for (T* i=begin; i != end; i++)
		{
			Copy::init(m_iter);
			HRESULT hr = Copy::copy(m_iter, i);
			if (FAILED(hr))
			{
				T* p = m_begin;
				while (p < m_iter)
					Copy::destroy(p++);
				delete [] m_begin;
				m_begin = m_end = m_iter = NULL;
				return hr;
			}
			m_iter++;
		}
		m_end = m_begin + (end-begin);
	}
	else
	{
		m_begin = begin;
		m_end = end;
	}
	m_spUnk = pUnk;
	m_iter = m_begin;
	m_dwFlags = flags;
	return S_OK;
}

template <class Base, const IID* piid, class T, class Copy, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnum :
	public CComEnumImpl<Base, piid, T, Copy>,
	public CComObjectRootEx< ThreadModel >
{
public:
	typedef CComEnum<Base, piid, T, Copy > _CComEnum;
	typedef CComEnumImpl<Base, piid, T, Copy > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
}

#if 0 //--------------------------------------------------

template <class T, class CollType, class ItemType, class CopyItem, class EnumType>
class ICollectionOnSTLImpl : public T
{
public:
	STDMETHOD(get_Count)(long* pcount)
	{
		if (pcount == NULL)
			return E_POINTER;
		*pcount = m_coll.size();
		return S_OK;
	}
	STDMETHOD(get_Item)(long Index, ItemType* pvar)
	{
		//Index is 1-based
		if (pvar == NULL)
			return E_POINTER;
		HRESULT hr = E_FAIL;
		Index--;
		CollType::iterator iter = m_coll.begin();
		while (iter != m_coll.end() && Index > 0)
		{
			iter++;
			Index--;
		}
		if (iter != m_coll.end())
			hr = CopyItem::copy(pvar, &*iter);
		return hr;
	}
	STDMETHOD(get__NewEnum)(IUnknown** ppUnk)
	{
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;
		HRESULT hRes = S_OK;
		CComObject<EnumType>* p;
		hRes = CComObject<EnumType>::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			hRes = p->Init(this, m_coll);
			if (hRes == S_OK)
				hRes = p->QueryInterface(IID_IUnknown, (void**)ppUnk);
		}
		if (hRes != S_OK)
			delete p;
		return hRes;
	}
	CollType m_coll;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\include\tvereg.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef TVEREG_H
#define TVEREG_H

#include <tchar.h>
#include "defreg.h"

extern HRESULT Initialize_LID_SpoolDir_RegEntry();
extern HRESULT Unregister_LID_SpoolDir_RegEntry();
//-----------------------------------------------------------------------------
//
// Registry usage:
//
// HKLM = HKEY_LOCAL_MACHINE
// HKCU = HKEY_CURRENT_USER
//
// HKLM\Software\Microsoft\TV Services\MSTvE							
//
//
//-----------------------------------------------------------------------------


#ifdef _DEBUG
extern const LPCTSTR g_strDEBUG;
extern const LPCTSTR g_strTrace;
#endif


//-----------------------------------------------------------------------------
// OpenRegKey
//
// Opens a registry HKEY.  There are several overloads of this function
// that basically just provide defaults for the arguments to this function.
//
// Please use the overload that defaults as much as possible.
//
// The registry key is a combination of the following four parts.
//
//   HKEY hkeyRoot       = Optional root hkey.
//                         Default: HKEY_LOCAL_MACHINE
//
//   LPCTSTR szKey       = Optional key to be set.
//                         Default: DEF_REG_BASE
//
//   LPCTSTR szSubKey1
//   LPCTSTR szSubKey2   = Optional sub keys that are concatenated after
//                         szKey to form the full key.
//                         Backward slashes are added as necessary.
//
//                         Default: NULL
//
//   Note: if only one or two strings are specified they are assumed to be
//         szSubKey1 and szSubKey2.
//         i.e. szKey defaults to DEF_REG_BASE before szSubKey1 and
//         szSubKey2 default to NULL.
//
//         If szKey, szSubKey1, and szSubKey2 are NULL then this will open
//         a duplicate of hkeyRoot.
//
// The only required argument is the destination for the returned HKEY.
//
//   HKEY *pkey  = The returned HKEY.
//                 Remember to use RegCloseKey(*pkey) when you are finished
//                 with this registry key.
//
// The last two arguments are optional.
//
//   REGSAM sam  = Desired access mask.
//                 Default: KEY_ALL_ACCESS
//
//   BOOL fCreate = TRUE if the key should be created.
//                  Default: FALSE
//
// Returns:
//     ERROR_SUCCESS or an error code.
//-----------------------------------------------------------------------------
long OpenRegKey(HKEY hkeyRoot, LPCTSTR szKey, LPCTSTR szSubKey1,
        LPCTSTR szSubKey2, HKEY *pkey,
        REGSAM sam = KEY_ALL_ACCESS, BOOL fCreate = FALSE);

inline long OpenRegKey(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        HKEY *pkey, REGSAM sam = KEY_ALL_ACCESS, BOOL fCreate = FALSE)
{
     return OpenRegKey(HKEY_LOCAL_MACHINE, szKey, szSubKey1, szSubKey2, pkey,
             sam, fCreate);
}

inline long OpenRegKey(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        HKEY *pkey, REGSAM sam = KEY_ALL_ACCESS, BOOL fCreate = FALSE)
{
     return OpenRegKey(HKEY_LOCAL_MACHINE, DEF_REG_BASE, szSubKey1,
             szSubKey2, pkey, sam, fCreate);
}

inline long OpenRegKey(LPCTSTR szSubKey, HKEY *pkey,
        REGSAM sam = KEY_ALL_ACCESS, BOOL fCreate = FALSE)
{
     return OpenRegKey(HKEY_LOCAL_MACHINE, DEF_REG_BASE, szSubKey, NULL,
             pkey, sam, fCreate);
}

inline long OpenRegKey(HKEY *pkey, REGSAM sam = KEY_ALL_ACCESS,
        BOOL fCreate = FALSE)
{
     return OpenRegKey(HKEY_LOCAL_MACHINE, DEF_REG_BASE, NULL, NULL,
             pkey, sam, fCreate);
}

//-----------------------------------------------------------------------------
// OpenUserRegKey
//
// Same as OpenRegKey except hkeyRoot defaults to HKEY_CURRENT_USER.
//-----------------------------------------------------------------------------
inline long OpenUserRegKey(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        HKEY *pkey, REGSAM sam = KEY_ALL_ACCESS, BOOL fCreate = FALSE)
{
     return OpenRegKey(HKEY_CURRENT_USER, szKey, szSubKey1, szSubKey2, pkey,
             sam, fCreate);
}

inline long OpenUserRegKey(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        HKEY *pkey, REGSAM sam = KEY_ALL_ACCESS, BOOL fCreate = FALSE)
{
     return OpenRegKey(HKEY_CURRENT_USER, DEF_REG_BASE, szSubKey1,
             szSubKey2, pkey, sam, fCreate);
}

inline long OpenUserRegKey(LPCTSTR szSubKey, HKEY *pkey,
        REGSAM sam = KEY_ALL_ACCESS, BOOL fCreate = FALSE)
{
     return OpenRegKey(HKEY_CURRENT_USER, DEF_REG_BASE, szSubKey, NULL,
             pkey, sam, fCreate);
}

inline long OpenUserRegKey(HKEY *pkey, REGSAM sam = KEY_ALL_ACCESS,
        BOOL fCreate = FALSE)
{
     return OpenRegKey(HKEY_CURRENT_USER, DEF_REG_BASE, NULL, NULL,
             pkey, sam, fCreate);
}

//-----------------------------------------------------------------------------
// GetRegValue,		SetRegValue
// GetRegValueSZ,	SetRegValueSZ
//
// Gets data from the registry.  There are numerous overloads of this function
// that basically just provide defaults for the arguments to this function.
//
// Please use the overload that defaults as much as possible.
//
// The registry key/value is a combination of the following five parts.
// The first four are the same as in OpenRegKey().
//
//   HKEY hkeyRoot
//   LPCTSTR szKey
//   LPCTSTR szSubKey1
//   LPCTSTR szSubKey2
//
//   LPCTSTR szValueName = The name of the value to be set.
//                         If it is NULL then the default value for the key
//                         will be set.
//
//                         Default: none
//
// There are four ways to specify where the data to be returned
// depending on the type of data in the registry.
//
// REG_BINARY
//
//   BYTE *pb      = Out: The data is copied to this location.
//   DWORD *pcb    = In:  Maximum size of the returned data (in bytes).
//                   Out: Actual size of the data (in bytes).
//
// REG_SZ
//
//   TCHAR *psz    = Out: The string is copied to this location.
//   DWORD *pcb    = In:  Maximum size of the returned data (in bytes).
//                   Out: Actual size of the data (in bytes).
//                   Includes the null terminator.
//
// REG_DWORD
//
//   DWORD *pdw    = Out: The data is copied to this location.
//                   The length is assumed to be sizeof(DWORD).
//
// All other types
//
//   DWORD dwType  = The data type.
//   BYTE *pb      = Pointer to the data.
//   DWORD *pcb    = In:  Maximum size of the returned data (in bytes).
//                   Out: Actual size of the data (in bytes).
//                   Includes the null terminator if the data is a string type.
//
// Returns:
//     ERROR_SUCCESS or an error code.
//-----------------------------------------------------------------------------
long GetRegValue(HKEY hkeyRoot, LPCTSTR szKey, LPCTSTR szSubKey1,
        LPCTSTR szSubKey2, LPCTSTR szValueName,
        DWORD dwType, BYTE *pb, DWORD *pcb);

//-----------------------------------------------------------------------------
// REG_BINARY variants
//-----------------------------------------------------------------------------
inline long GetRegValue(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, BYTE *pb, DWORD *pcb)
{
    return GetRegValue(HKEY_LOCAL_MACHINE, szKey, szSubKey1, szSubKey2,
            szValueName,
            REG_BINARY, pb, pcb);
}

inline long GetRegValue(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, BYTE *pb, DWORD *pcb)
{
    return GetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, szSubKey1,
            szSubKey2, szValueName, REG_BINARY, pb, pcb);
}

inline long GetRegValue(LPCTSTR szSubKey, LPCTSTR szValueName,
        BYTE *pb, DWORD *pcb)
{
    return GetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, szSubKey, NULL,
            szValueName, REG_BINARY, pb, pcb);
}

inline long GetRegValue(LPCTSTR szValueName, BYTE *pb, DWORD *pcb)
{
    return GetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, NULL, NULL,
            szValueName, REG_BINARY, pb, pcb);
}

//-----------------------------------------------------------------------------
// REG_SZ variants
//-----------------------------------------------------------------------------
inline long GetRegValueSZ(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, TCHAR *psz, DWORD *pcb)
{
    return GetRegValue(HKEY_LOCAL_MACHINE, szKey, szSubKey1, szSubKey2,
            szValueName, REG_SZ, (BYTE *) psz, pcb);
}
inline long GetRegValueSZ(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, TCHAR *psz, DWORD *pcb)
{
    return GetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, szSubKey1,
            szSubKey2, szValueName, REG_SZ, (BYTE *) psz, pcb);
}

inline long GetRegValueSZ(LPCTSTR szSubKey, LPCTSTR szValueName,
        TCHAR *psz, DWORD *pcb)
{
    return GetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, szSubKey, NULL,
            szValueName, REG_SZ, (BYTE *)psz, pcb);
}

#if 0
inline long GetRegValue(HKEY hk, LPCTSTR szValueName,
        TCHAR *psz, DWORD *pcb)
{
    return GetRegValue(hk, NULL, NULLy, NULL,
            szValueName, REG_SZ, (BYTE *)psz, pcb);
}
#endif

inline long GetRegValueSZ(LPCTSTR szValueName, TCHAR *psz, DWORD *pcb)
{
    return GetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, NULL, NULL,
            szValueName, REG_SZ, (BYTE *) psz, pcb);
}

//-----------------------------------------------------------------------------
// REG_DWORD variants
//-----------------------------------------------------------------------------
inline long GetRegValue(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, DWORD *pdw)
{
    DWORD cb = sizeof(DWORD);

    return GetRegValue(HKEY_LOCAL_MACHINE, szKey, szSubKey1, szSubKey2,
            szValueName, REG_DWORD, (BYTE *) pdw, &cb);
}

inline long GetRegValue(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, DWORD *pdw)
{
    DWORD cb = sizeof(DWORD);

    return GetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, szSubKey1,
            szSubKey2, szValueName, REG_DWORD, (BYTE *) pdw, &cb);
}


inline long GetRegValue(LPCTSTR szSubKey, LPCTSTR szValueName, DWORD *pdw)
{
    DWORD cb = sizeof(DWORD);

    return GetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, szSubKey, NULL,
            szValueName, REG_DWORD, (BYTE *) pdw, &cb);
}

inline long GetRegValue(LPCTSTR szValueName, DWORD *pdw)
{
    DWORD cb = sizeof(DWORD);

    return GetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, NULL, NULL,
            szValueName, REG_DWORD, (BYTE *) pdw, &cb);
}

//-----------------------------------------------------------------------------
// The following variants are for getting values from an already open key.
//-----------------------------------------------------------------------------
inline long GetRegValueSZ(HKEY hkey, LPCTSTR szKey, LPCTSTR szSubKey,
        LPCTSTR szValueName, TCHAR *psz, DWORD *pcb)
{
    return GetRegValue(hkey, szKey, szSubKey, NULL, szValueName,
            REG_SZ, (BYTE *) psz, pcb);
}

inline long GetRegValue(HKEY hkey, LPCTSTR szValueName, BYTE *pb, DWORD *pcb)
{
    return GetRegValue(hkey, NULL, NULL, NULL, szValueName,
            REG_BINARY, pb, pcb);
}

inline long GetRegValueSZ(HKEY hkey, LPCTSTR szValueName, TCHAR *psz, DWORD *pcb)
{
    return GetRegValue(hkey, NULL, NULL, NULL, szValueName,
            REG_SZ, (BYTE *) psz, pcb);
}

inline long GetRegValue(HKEY hkey, LPCTSTR szValueName, DWORD *pdw)
{
    DWORD cb = sizeof(DWORD);

    return GetRegValue(hkey, NULL, NULL, NULL, szValueName,
            REG_DWORD, (BYTE *) pdw, &cb);
}

//-----------------------------------------------------------------------------
// GetUserRegValue
//
// Same as GetRegValue except hkeyRoot defaults to HKEY_CURRENT_USER.
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// REG_BINARY variants
//-----------------------------------------------------------------------------
inline long GetUserRegValue(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, BYTE *pb, DWORD *pcb)
{
    return GetRegValue(HKEY_CURRENT_USER, szKey, szSubKey1, szSubKey2,
            szValueName,
            REG_BINARY, pb, pcb);
}

inline long GetUserRegValue(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, BYTE *pb, DWORD *pcb)
{
    return GetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, szSubKey1,
            szSubKey2, szValueName, REG_BINARY, pb, pcb);
}

inline long GetUserRegValue(LPCTSTR szSubKey, LPCTSTR szValueName,
        BYTE *pb, DWORD *pcb)
{
    return GetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, szSubKey, NULL,
            szValueName, REG_BINARY, pb, pcb);
}

inline long GetUserRegValue(LPCTSTR szValueName, BYTE *pb, DWORD *pcb)
{
    return GetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, NULL, NULL,
            szValueName, REG_BINARY, pb, pcb);
}

//-----------------------------------------------------------------------------
// REG_SZ variants
//-----------------------------------------------------------------------------
inline long GetUserRegValueSZ(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, TCHAR *psz, DWORD *pcb)
{
    return GetRegValue(HKEY_CURRENT_USER, szKey, szSubKey1, szSubKey2,
            szValueName, REG_SZ, (BYTE *) psz, pcb);
}
inline long GetUserRegValueSZ(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, TCHAR *psz, DWORD *pcb)
{
    return GetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, szSubKey1,
            szSubKey2, szValueName, REG_SZ, (BYTE *) psz, pcb);
}

inline long GetUserRegValueSZ(LPCTSTR szSubKey, LPCTSTR szValueName,
        TCHAR *psz, DWORD *pcb)
{
    return GetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, szSubKey, NULL,
            szValueName, REG_SZ, (BYTE *)psz, pcb);
}

inline long GetUserRegValueSZ(LPCTSTR szValueName, TCHAR *psz, DWORD *pcb)
{
    return GetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, NULL, NULL,
            szValueName, REG_SZ, (BYTE *) psz, pcb);
}

//-----------------------------------------------------------------------------
// REG_DWORD variants
//-----------------------------------------------------------------------------
inline long GetUserRegValue(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, DWORD *pdw)
{
    DWORD cb = sizeof(DWORD);

    return GetRegValue(HKEY_CURRENT_USER, szKey, szSubKey1, szSubKey2,
            szValueName, REG_DWORD, (BYTE *) pdw, &cb);
}

inline long GetUserRegValue(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, DWORD *pdw)
{
    DWORD cb = sizeof(DWORD);

    return GetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, szSubKey1,
            szSubKey2, szValueName, REG_DWORD, (BYTE *) pdw, &cb);
}


inline long GetUserRegValue(LPCTSTR szSubKey, LPCTSTR szValueName, DWORD *pdw)
{
    DWORD cb = sizeof(DWORD);

    return GetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, szSubKey, NULL,
            szValueName, REG_DWORD, (BYTE *) pdw, &cb);
}

inline long GetUserRegValue(LPCTSTR szValueName, DWORD *pdw)
{
    DWORD cb = sizeof(DWORD);

    return GetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, NULL, NULL,
            szValueName, REG_DWORD, (BYTE *) pdw, &cb);
}

inline long GetUserRegValue(LPCTSTR szSubKey, LPCTSTR szValueName, DWORD &dw)
{
    DWORD cb = sizeof(DWORD);

    return GetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, szSubKey, NULL,
            szValueName, REG_DWORD, (BYTE *) &dw, &cb);
}

inline long GetUserRegValue(LPCTSTR szValueName, DWORD &dw)
{
    DWORD cb = sizeof(DWORD);

    return GetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, NULL, NULL,
            szValueName, REG_DWORD, (BYTE *) &dw, &cb);
}

//-----------------------------------------------------------------------------
// SetRegValue
// SetRegValueSZ
//
// Sets data into the registry.  There are numerous overloads of this function
// that basically just provide defaults for the arguments to this function.
//
// Please use the overload that defaults as much as possible.
//
// The registry key/value is a combination of the following five parts.
// The first four are the same as in OpenRegKey().
//
//   HKEY hkeyRoot
//   LPCTSTR szKey
//   LPCTSTR szSubKey1
//   LPCTSTR szSubKey2
//
//   LPCTSTR szValueName = The name of the value to be set.
//                         If it is NULL then the default value for the key
//                         will be set.
//
//                         Default: none
//
// There are four ways to specify the data to be set into the registry
// depending on the type of data being stored.
//
// REG_BINARY
//
//   BYTE *pb      = Pointer to the data.
//   DWORD cb      = Actual size of the data (in bytes).
//
// REG_SZ		(SetRegValueSZ)
//
//   TCHAR *psz    = The data is written as type REG_SZ.
//                   The length is calculated as (_tcsclen(psz) +1) * sizeof(TCHAR).
//
// REG_DWORD
//
//   DWORD dw      = The data is written as type DWORD.
//                   The length is calculated as sizeof(DWORD).
//
// All other types
//
//   DWORD dwType  = The data type.
//   BYTE *pb      = Pointer to the data.
//   DWORD cb      = Actual size of the data in bytes.
//
// Returns:
//     ERROR_SUCCESS or an error code.
//-----------------------------------------------------------------------------
long SetRegValue(HKEY hkeyRoot, LPCTSTR szKey, LPCTSTR szSubKey1,
        LPCTSTR szSubKey2, LPCTSTR szValueName,
        DWORD dwType, const BYTE *pb, DWORD cb);

//-----------------------------------------------------------------------------
// REG_BINARY variants
//-----------------------------------------------------------------------------
inline long SetRegValue(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, const BYTE *pb, DWORD cb)
{
    return SetRegValue(HKEY_LOCAL_MACHINE, szKey, szSubKey1, szSubKey2,
            szValueName, REG_BINARY, pb, cb);
}

inline long SetRegValue(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, const BYTE *pb, DWORD cb)
{
    return SetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, szSubKey1,
            szSubKey2, szValueName, REG_BINARY, pb, cb);
}

inline long SetRegValue(LPCTSTR szSubKey, LPCTSTR szValueName,
        const BYTE *pb, DWORD cb)
{
    return SetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, szSubKey, NULL,
            szValueName, REG_BINARY, pb, cb);
}

inline long SetRegValue(LPCTSTR szValueName, const BYTE *pb, DWORD cb)
{
    return SetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE, NULL, NULL,
            szValueName, REG_BINARY, pb, cb);
}

//-----------------------------------------------------------------------------
// REG_SZ variants
//-----------------------------------------------------------------------------
inline long SetRegValueSZ(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, const TCHAR *psz)
{
    return SetRegValue(HKEY_LOCAL_MACHINE,
            szKey, szSubKey1, szSubKey2, szValueName,
            REG_SZ, (const BYTE *) psz, (_tcsclen(psz) + 1) * sizeof(TCHAR));
}
inline long SetRegValueSZ(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, const TCHAR *psz)
{
    return SetRegValue(HKEY_LOCAL_MACHINE, DEF_REG_BASE,
            szSubKey1, szSubKey2, szValueName,
            REG_SZ, (const BYTE *) psz, (_tcsclen(psz) + 1) * sizeof(TCHAR));
}

inline long SetRegValueSZ(LPCTSTR szSubKey, LPCTSTR szValueName, const TCHAR *psz)
{
    return SetRegValue(HKEY_LOCAL_MACHINE,
            DEF_REG_BASE, szSubKey, NULL, szValueName,
            REG_SZ, (const BYTE *)psz, (_tcsclen(psz) + 1) * sizeof(TCHAR));
}

inline long SetRegValueSZ(LPCTSTR szValueName, const TCHAR *psz)
{
    return SetRegValue(HKEY_LOCAL_MACHINE,
            DEF_REG_BASE, NULL, NULL, szValueName,
            REG_SZ, (const BYTE *) psz, (_tcsclen(psz) + 1) * sizeof(TCHAR));
}

//-----------------------------------------------------------------------------
// REG_DWORD variants
//-----------------------------------------------------------------------------
inline long SetRegValue(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, DWORD dw)
{
    return SetRegValue(HKEY_LOCAL_MACHINE,
            szKey, szSubKey1, szSubKey2, szValueName,
            REG_DWORD, (BYTE *) &dw, sizeof(DWORD));
}

inline long SetRegValue(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, DWORD dw)
{
    return SetRegValue(HKEY_LOCAL_MACHINE,
            DEF_REG_BASE, szSubKey1, szSubKey2, szValueName,
            REG_DWORD, (BYTE *) &dw, sizeof(DWORD));
}

inline long SetRegValue(LPCTSTR szSubKey, LPCTSTR szValueName, DWORD dw)
{
    return SetRegValue(HKEY_LOCAL_MACHINE,
            DEF_REG_BASE, szSubKey, NULL, szValueName,
            REG_DWORD, (const BYTE *) &dw, sizeof(DWORD));
}

inline long SetRegValue(LPCTSTR szValueName, DWORD dw)
{
    return SetRegValue(HKEY_LOCAL_MACHINE,
            DEF_REG_BASE, NULL, NULL, szValueName,
            REG_DWORD, (const BYTE *) &dw, sizeof(DWORD));
}

//-----------------------------------------------------------------------------
// The following variants are for setting values in an already open key.
//-----------------------------------------------------------------------------
inline long SetRegValue(HKEY hkey, LPCTSTR szValueName, const BYTE *pb, DWORD cb)
{
    return SetRegValue(hkey, NULL, NULL, NULL, szValueName,
            REG_BINARY, pb, cb);
}

inline long SetRegValueSZ(HKEY hkey, LPCTSTR szValueName, const TCHAR *psz)
{
    return SetRegValue(hkey, NULL, NULL, NULL, szValueName,
            REG_SZ, (const BYTE *) psz, (_tcsclen(psz) + 1) * sizeof(TCHAR));
}

inline long SetRegValue(HKEY hkey, LPCTSTR szValueName, DWORD dw)
{
    return SetRegValue(hkey, NULL, NULL, NULL, szValueName,
            REG_DWORD, (const BYTE *) &dw, sizeof(DWORD));
}

//-----------------------------------------------------------------------------
// SetUserRegValue
//
// Same as SetRegValue except hkeyRoot defaults to HKEY_CURRENT_USER.
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// REG_BINARY variants
//-----------------------------------------------------------------------------
inline long SetUserRegValue(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, const BYTE *pb, DWORD cb)
{
    return SetRegValue(HKEY_CURRENT_USER, szKey, szSubKey1, szSubKey2,
            szValueName, REG_BINARY, pb, cb);
}

inline long SetUserRegValue(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, const BYTE *pb, DWORD cb)
{
    return SetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, szSubKey1,
            szSubKey2, szValueName, REG_BINARY, pb, cb);
}

inline long SetUserRegValue(LPCTSTR szSubKey, LPCTSTR szValueName,
        const BYTE *pb, DWORD cb)
{
    return SetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, szSubKey, NULL,
            szValueName, REG_BINARY, pb, cb);
}

inline long SetUserRegValue(LPCTSTR szValueName, const BYTE *pb, DWORD cb)
{
    return SetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE, NULL, NULL,
            szValueName, REG_BINARY, pb, cb);
}

//-----------------------------------------------------------------------------
// REG_SZ variants
//-----------------------------------------------------------------------------
inline long SetUserRegValueSZ(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, const TCHAR *psz)
{
    return SetRegValue(HKEY_CURRENT_USER,
            szKey, szSubKey1, szSubKey2, szValueName,
            REG_SZ, (const BYTE *) psz, (_tcsclen(psz) + 1) * sizeof(TCHAR));
}
inline long SetUserRegValueSZ(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, const TCHAR *psz)
{
    return SetRegValue(HKEY_CURRENT_USER, DEF_REG_BASE,
            szSubKey1, szSubKey2, szValueName,
            REG_SZ, (const BYTE *) psz, (_tcsclen(psz) + 1) * sizeof(TCHAR));
}

inline long SetUserRegValueSZ(LPCTSTR szSubKey, LPCTSTR szValueName, const TCHAR *psz)
{
    return SetRegValue(HKEY_CURRENT_USER,
            DEF_REG_BASE, szSubKey, NULL, szValueName,
            REG_SZ, (const BYTE *)psz, (_tcsclen(psz) + 1) * sizeof(TCHAR));
}

inline long SetUserRegValueSZ(LPCTSTR szValueName, const TCHAR *psz)
{
    return SetRegValue(HKEY_CURRENT_USER,
            DEF_REG_BASE, NULL, NULL, szValueName,
            REG_SZ, (const BYTE *) psz, (_tcsclen(psz) + 1) *  sizeof(TCHAR));
}

//-----------------------------------------------------------------------------
// REG_DWORD variants
//-----------------------------------------------------------------------------
inline long SetUserRegValue(LPCTSTR szKey, LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, DWORD dw)
{
    return SetRegValue(HKEY_CURRENT_USER,
            szKey, szSubKey1, szSubKey2, szValueName,
            REG_DWORD, (BYTE *) &dw, sizeof(DWORD));
}

inline long SetUserRegValue(LPCTSTR szSubKey1, LPCTSTR szSubKey2,
        LPCTSTR szValueName, DWORD dw)
{
    return SetRegValue(HKEY_CURRENT_USER,
            DEF_REG_BASE, szSubKey1, szSubKey2, szValueName,
            REG_DWORD, (BYTE *) &dw, sizeof(DWORD));
}

inline long SetUserRegValue(LPCTSTR szSubKey, LPCTSTR szValueName, DWORD dw)
{
    return SetRegValue(HKEY_CURRENT_USER,
            DEF_REG_BASE, szSubKey, NULL, szValueName,
            REG_DWORD, (const BYTE *) &dw, sizeof(DWORD));
}

inline long SetUserRegValue(LPCTSTR szValueName, DWORD dw)
{
    return SetRegValue(HKEY_CURRENT_USER,
            DEF_REG_BASE, NULL, NULL, szValueName,
            REG_DWORD, (const BYTE *) &dw, sizeof(DWORD));
}

#endif // REG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\adler32.c ===
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* $Id: adler32.c,v 1.10 1996/05/22 11:52:18 me Exp $ */

#include "zlib.h"

#define BASE 65521L /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* ========================================================================= */
uLong adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
    unsigned long s1 = adler & 0xffff;
    unsigned long s2 = (adler >> 16) & 0xffff;
    int k;

    if (buf == Z_NULL) return 1L;

    while (len > 0) {
        k = len < NMAX ? len : NMAX;
        len -= k;
        while (k >= 16) {
            DO16(buf);
	    buf += 16;
            k -= 16;
        }
        if (k != 0) do {
            s1 += *buf++;
	    s2 += s1;
        } while (--k);
        s1 %= BASE;
        s2 %= BASE;
    }
    return (s2 << 16) | s1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__D2BECF7A_D0E8_46A5_8917_90F65B435441__INCLUDED_)
#define AFX_DLLDATAX_H__D2BECF7A_D0E8_46A5_8917_90F65B435441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__D2BECF7A_D0E8_46A5_8917_90F65B435441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\dlldatax.c ===
/*********************************************************
   DllData file -- partially generated by MIDL compiler 

  We are building the .idls over in multimedia\Published\DXMDev\dshowdev\idl but we want the actual 
  proxy stub to live in MSTvE.dll *not* quartz.dll 
  This is because registering the typelibs wipes out the proxy stub registration and
  we want to avoid any registration order dependencies.  so , we must register the proxy/stubs in 
  the MSTvE.dl after the typelib registration and it wouldn't be good to do it in both places and
  make quartz.dll unecessarily larger.

  consequently, we are manually maintaining this file.  if you add a new .idl to the MSTvE you
  must update these entries

  for simplicity sake since we know we're always merging the proxy stub we're combining dlldata.c and
  dlldatax.c as well.  -- Also, dlldata.c  over in Published\DXMDev\dshowdev\idl\objd\i386 is totally
  the wrong one...

*********************************************************/

// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

//#define _WIN32_WINNT 0x0400     //for WinNT 4.0 or Win95 with DCOM (not for NT)
#define USE_STUBLESS_PROXY        //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

// -------------------------------
//  it was this
//#include "dlldata.c"
// -------------------------------
//  it's now this...
#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( mstve )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( mstve ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

// ----------------------------
#include "MSTvE_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\include\valid.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.

// Enter and Leave macros for all externally called functions.  Debug version does not
// have try/catch block to make gp faults easier to track down.
//
// Examples:
//
// // This is the standard way to wrap APIs.
// HRESULT API1(...)
// {
// ENTER_API
//     {
//
//     // API code here.
//
//     }
// EXIT_API				( or EXIT_API_(hr) to return a particular non-thrown hr);
// }
//
//		can also use LEAVE_API to simply exit the try-catch block without returning.
//
// // This is how you would do it if you need more control.
// HRESULT API2(...)
// {
//     STD_MANAGE_STATE
//
//     try
//         {
//
//         // Your code here.
//
//         }
//     catch (CSpecialException *pexcept)
//         {
//         // This is how you would catch an exception that required
//         // special processing (beyond just returning an hresult).
//         }
//
//     // This is the default way to return E_OutOfMemory for CMemoryException
//     DefCatchMemory
//
//     // This is required to catch all other exceptions and return E_FAIL
//     DefCatchAll
// }

// Note that we must manage MFC .dll state around each of our public
// entry points via this call to AFX_MANAGE_STATE(AfxGetStaticModuleState())
//
//
//		Further note -- this file was originally designed for MFC, which we
//		are not using.  It has been modified to remove MFC dependencies (CException
//		classes for example), and some AFX code has bee added to make it compile.

#ifndef __VALID_H__
#define	__VALID_H__


//  MFC routines 

// TVEIsValidAddress() returns TRUE if the passed parameter points
// to at least nBytes of accessible memory. If bReadWrite is TRUE,
// the memory must be writeable; if bReadWrite is FALSE, the memory
// may be const. (WasAFXIsValidAddress);

BOOL TVEIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE );		


// AfxIsValidString() returns TRUE if the passed pointer
// references a string of at least the given length in characters.
// A length of -1 (the default parameter) means that the string
// buffer's minimum length isn't known, and the function will
// return TRUE no matter how long the string is. The memory
// used by the string can be read-only.

BOOL TVEIsValidString(LPCWSTR lpsz, int nLength = -1);
BOOL TVEIsValidString(LPCSTR lpsz, int nLength = -1);


//#define STD_MANAGE_STATE AFX_MANAGE_STATE(AfxGetStaticModuleState());
#define STD_MANAGE_STATE				// non MFC version...


/* 
#define DefCatchMemory \
   catch (CMemoryException *pe) \
		{ \
        pe->Delete(); \
        return E_OUTOFMEMORY; \
		}


#define DefCatchOleException \
    catch (COleException *pe) \
		{ \
		HRESULT hr = pe->m_sc; \
        pe->Delete(); \
        return hr; \
		}

#define DefCatchOleDispatchException \
    catch (COleDispatchException *pe) \
		{ \
		HRESULT hr = pe->m_scError; \
        pe->Delete(); \
        return hr; \
		}
*/
#define DefCatchMemory					// non MFC version...
#define DefCatchOleException
#define DefCatchOleDispatchException

#define DefCatchHRESULT \
	catch (HRESULT hr) \
		{ \
		return hr; \
		}

#define DefCatchComError \
	catch (_com_error ce) \
		{ \
		return ce.Error(); \
		}

#define DefCatchAll \
    catch (...) \
		{ \
        return E_FAIL; \
		}


#define StdCatchMost \
	DefCatchHRESULT \
	DefCatchComError \
	DefCatchMemory \
	DefCatchOleException \
	DefCatchOleDispatchException

// Don't do DefCatchAll in _DEBUG so unexpected exceptions will fault.
#ifdef _DEBUG
#define StdCatchAll StdCatchMost
#else
#define StdCatchAll \
	StdCatchMost \
	DefCatchAll
#endif

#define ENTER_API \
        STD_MANAGE_STATE \
        try

#define EXIT_API \
		StdCatchAll \
		return ERROR_SUCCESS;

#define EXIT_API_(_hr) \
		StdCatchAll \
		return _hr;

#define LEAVE_API \
		StdCatchAll

template <typename T>
inline void ValidateOutPtr(T *pVal, T val)
{
	if (!TVEIsValidAddress(pVal, sizeof(T)))
	{
	//	_ASSERT(false);
	_com_issue_error(E_POINTER);
	}
	
	*pVal = val;
}

template <typename T>
inline void ValidateInPtr(T *pT)
{
	if (!TVEIsValidAddress(pT, sizeof(T), FALSE))
	{
	//	_ASSERT(false);
		_com_issue_error(E_POINTER);
	}
}


inline void Validate(BSTR sData)
{
	if (!TVEIsValidString(sData))
	{
//		_ASSERT(false);
		_com_issue_error(E_POINTER);
	}
}


template <class T>
class CComObjectTracked : public CComObject<T>
{
public:
	CComObjectTracked()
		{
		m_ppobj = NULL;
		}

	~CComObjectTracked()
		{
		if (m_ppobj != NULL)
			{
			ASSERT(*m_ppobj == this);
			*m_ppobj = NULL;
			}
		}
	
	void SetTrackedPointer(CComObjectTracked<T> **ppobj)
		{
		m_ppobj = ppobj;
		}

protected:
	CComObjectTracked<T> **m_ppobj;
};

#if defined(_DEBUG)
#define NewComObject(T) _NewComObject<T>(THIS_FILE, __LINE__)
template<class T>
T * _NewComObject(LPCSTR lpszFileName, int nLine)
	{
	T* pT = NULL;
//	try
		{
//		pT = new(lpszFileName, nLine) CComObject<T>;
		pT = new(_CLIENT_BLOCK, lpszFileName, nLine) CComObject<T>;
		}
//	catch (CMemoryException *pe)
		{
//		pe->Delete();
		}
	
	if (pT != NULL)
		pT->AddRef();
	
	return pT;
	}
#define NewComObjectTracked(T, ppobj) _NewComObjectTracked<T>(THIS_FILE, __LINE__, ppobj)
template<class T>
T * _NewComObjectTracked(LPCSTR lpszFileName, int nLine, CComObjectTracked<T> **ppobj)
	{
	T* pT = NULL;
//	try
		{
//		pT = new(lpszFileName, nLine) CComObjectTracked<T>;
		pT = new(_CLIENT_BLOCK, lpszFileName, nLine) CComObjectTracked<T>;
		}
//	catch (CMemoryException *pe)
		{
//		pe->Delete();
		}
	
	if (pT != NULL)
		{
		pT->AddRef();
		pT->SetTrackedPointer(ppobj);
		}
	
	return pT;
	}
#else
#define NewComObject(T) _NewComObject<T>()
template<class T>
T * _NewComObject()
	{
	T* pT = NULL;
//	try
		{
		pT = new CComObject<T>;
//		pT = new(_CLIENT_BLOCK, lpszFileName, nLine) CComObject<T>;
		}
//	catch (CMemoryException *pe)
		{
//		pe->Delete();
		}
	
	if (pT != NULL)
		pT->AddRef();
	
	return pT;
	}
#define NewComObjectTracked(T, ppobj) _NewComObjectTracked<T>(ppobj)
template<class T>
T * _NewComObjectTracked(CComObjectTracked<T> **ppobj)
	{
	T* pT = NULL;
//	try
		{
		pT = new CComObjectTracked<T>;
		}
//	catch (CMemoryException *pe)
		{
//		pe->Delete();
		}
	
	if (pT != NULL)
		{
		pT->AddRef();
		pT->SetTrackedPointer(ppobj);
		}
	
	return pT;
	}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\fcache.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  Module: fcache.cpp
//
//  Author: Dan Elliott
//
//  Abstract:
//
//  Environment:
//      Win98, Win2000
//
//  Revision History:
//      990201  dane    Created and added the following classes:
//                      * CCachedFile
//                      * CCachedIEFile
//                      * CCachedTveFile
//                      * CCacheManager
//                      * CCacheTrivia
//                      * CTveCacheTrivia
//      990203  dane    Update the expire time in the registry.
//      990210  dane    CCachedTveFile::Open now returns handle to temporary
//                      file. Temporary file is closed and moved to destination
//                      in CCachedTveFile::Close.  Added Commit and MoveFile
//                      member functions to CCachedTveFile
//
//////////////////////////////////////////////////////////////////////////////

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)


//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include "StdAfx.h"
#include "MSTvE.h"
#include "TVEDbg.h"
#include "TVEReg.h"
#include "TveSuper.h"

#include <WinINet.h>
#include "FileUtil.h"
#include "FCache.h"

#include "DbgStuff.h"

_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
//////////////////////////////////////////////////////////////////////////////
//
//  Constants
//
const TCHAR* SZ_SCHEME_HTTP		= _T("http");
const TCHAR* SZ_SCHEME_LID		= _T("lid");
const TCHAR* SZ_SCHEME_LIDCOLON = _T("lid:");
const TCHAR* SZ_DEFAULT_HEADER  = _T("HTTP/1.0 200 OK\r\n\r\n");
const int    MAX_CACHE_ENTRY_INFO_SIZE = 4096;
///////////////////////////////////////////////////////////////////////////
//
//  Static member initialization
//
TCHAR           CCachedTveFile::m_rgchSpoolDir[] = {0};
double          CCachedTveFile::m_dExpireIncrement = 
                    static_cast<double>(MINS_EXPIRE_INCREMENT) / MINS_PER_DAY;



// ///////////////////////////////////////////////////////////////////////////
//	Initialize_LID_SpoolDir_RegEntry
//
//		This initializes the spool directory registry entry
//		used to contain LID: files if it's not currently set.
//		This needs to be set once on a machine.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  Open
//
//  Create a new cache entry and open the associated disk file.
//
//  parameters:
//      szUrl       name of the url for which to create a cache entry
//      dwExpectedFileSize expected size of the file
//      ftExpires       expiration date of the file
//      ftLastModified  last modification time of the file
//      szLanguage      language
//      szContentType   content type of file
//
//  returns:
//      NOERROR         if the file is opened successfully
//      E_POINTER       if a required pointer parameter is NULL
//      E_INVALIDARG    if a parameter is invalid
//      E_HANDLE        if the file cannot be opened for any reason
//      E_OUTOFMEMORY   if memory cannot be allocated
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCachedIEFile::GetName(LPCTSTR			*ppszName)
{
	if(ppszName != 0)
		*ppszName = m_szFileName;
	return S_OK;
}

HRESULT
CCachedIEFile::Open(
    LPCTSTR             szUrl,
    DWORD               dwExpectedFileSize,
    FILETIME            ftExpires,
    FILETIME            ftLastModified,
    LPCTSTR             szLanguage,
    LPCTSTR             szContentType
    )
{
	USES_CONVERSION;

    DBG_HEADER(CDebugLog::DBG_FCACHE, _T("CCachedIEFile::Open"));
    
    // Does this object already correspond to a file?
    //
    _ASSERT(INVALID_HANDLE_VALUE == m_hFile);
    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        TVEDebugLog((CDebugLog::DBG_SEV3, 3, _T("Handle should be invalid"))); 
        return E_HANDLE;
    }

    // Do the required pointer parameters actually point to something?
    // Is the buffer a valid length?
    //
    _ASSERT(NULL != szUrl);
    if (NULL == szUrl)
    {
        TVEDebugLog((CDebugLog::DBG_SEV3, 3, _T("Invalid parameter"))); 
        return E_POINTER;
    }

    _ASSERT(0 < _tcslen(szUrl) && 
            _tcslen(szUrl) <= INTERNET_MAX_URL_LENGTH
            );
    if (0 == _tcslen(szUrl) || 
        _tcslen(szUrl) > INTERNET_MAX_URL_LENGTH
        )
    {
        TVEDebugLog((CDebugLog::DBG_SEV3, 3, _T("Invalid parameter"))); 
        return E_INVALIDARG;
    }

    // Does the file have a size?
    // REVIEW: Is zero a valid file size??
    //
    _ASSERT(0 < dwExpectedFileSize);

    // Cache the information that will be needed to commit the file prior to
    // closing it.
    //
    m_szUrl = _tcsdup(szUrl);
    if (NULL == m_szUrl)
    {
        TVEDebugLog((CDebugLog::DBG_SEV3, 3, _T("Can't dupe URL"))); 
        return E_OUTOFMEMORY;
    }

    m_ftExpires = ftExpires;
    m_ftLastModified = ftLastModified;

    // Get File Extension
    TCHAR* szFileExtension = NULL;
    TCHAR* pch = _tcsrchr(szUrl, '.');
    if (NULL != pch)
    {
	_tcscpy(m_szFileExtension, ++pch);
	szFileExtension = m_szFileExtension;
    }


    // Create a cache entry and get the name of its file
    //
  if (! CreateUrlCacheEntry(szUrl,
                              dwExpectedFileSize,
                              szFileExtension,
                              m_szFileName,
                              0                 // Reserved
                              )
        || NULL == m_szFileName
        )
    {
        TVEDebugLog((CDebugLog::DBG_SEV3, 3, _T("Failed to create IE cache entry : %s"),szUrl));
        return E_HANDLE;
    }
    _ASSERT(NULL != m_szFileName);

    // Open the file for writing.  If the file exists, overwrite it.
    //
    m_hFile = CreateFile(m_szFileName,  // file path & name
                         GENERIC_WRITE, // access priviledges
                         0,             // share mode -- no sharing
                         NULL,          // security attributes
                         CREATE_ALWAYS, // creation attributes
                         0,             // misc flags
                         NULL           // template file
                         );
    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        TVEDebugLog((CDebugLog::DBG_SEV3, 3, _T("Failed to create IE cache file : %s"),m_szFileName));
        return E_HANDLE;
    }

    _VALIDATE_THIS( );

    TVEDebugLog((CDebugLog::DBG_FCACHE, 3, _T("Opened IE cache file:"), m_szFileName));
    return NOERROR;

}   //  CCachedIEFile::Open


//////////////////////////////////////////////////////////////////////////////
//
//  Close
//
//  Commits and closes the cache file.
//
//  parameters:
//      None.
//
//  returns:
//      NOERROR         if the operation is successful
//      E_UNEXPECTED    if one of the cached parameters is invalid
//      E_FAIL          if the file cannot be closed
//      ERROR_DISK_FULL if the file cannot be committed because the disk is
//                      full
//      ERROR_FILE_NOT_FOUND if the file that is being committed cannot be
//                      found
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCachedIEFile::Close( )
{
	USES_CONVERSION;

    DBG_HEADER(CDebugLog::DBG_FCACHE, _T("CCachedIEFile::Close"));

    BOOL                fResult;
    FILETIME nullTime;
    ZeroMemory(&nullTime, sizeof(FILETIME));
    DWORD ceType = NORMAL_CACHE_ENTRY;
	/* vars for cache entry info header
		TCHAR bufHeaderInfo[MAX_CACHE_ENTRY_INFO_SIZE/2];
		ZeroMemory(&bufHeaderInfo, (MAX_CACHE_ENTRY_INFO_SIZE/2)*sizeof(TCHAR));
	*/
    // Both URL and file name should have been cached by Open( )
    //
    _ASSERT(NULL != m_szUrl);
    _ASSERT(NULL != m_szFileName[0]);
    if (NULL == m_szUrl || NULL == m_szFileName[0])
    {
        DBG_WARN(CDebugLog::DBG_SEV3, _T("Invalid parameter"));
        return E_UNEXPECTED;
    }

    // Close File Handle
    _VERIFY(fResult = CloseHandle(m_hFile));
    if (! fResult)
    {
        DBG_WARN(CDebugLog::DBG_SEV3, _T("Failed to close IE cache file handle"));
        return E_FAIL;
    }
    DBG_WARN(CDebugLog::DBG_SEV4, _T("IE cache file closed"));

    TCHAR* szFileExtension = NULL;
    if (NULL != *m_szFileExtension)
	szFileExtension = m_szFileExtension;

    // Commit the data to disk
    //
    DBG_WARN(CDebugLog::DBG_SEV4, m_szUrl);
    DBG_WARN(CDebugLog::DBG_SEV4, m_szFileName);
    DBG_WARN(CDebugLog::DBG_SEV4, m_szFileExtension);

	/*  Code to construct the Cache entry info,

	typedef struct _INTERNET_CACHE_ENTRY_INFOW {
	DWORD dwStructSize;         // version of cache system.
	LPWSTR  lpszSourceUrlName;    // embedded pointer to the URL name string.
	LPWSTR  lpszLocalFileName;  // embedded pointer to the local file name.
	DWORD CacheEntryType;       // cache type bit mask.
	DWORD dwUseCount;           // current users count of the cache entry.
	DWORD dwHitRate;            // num of times the cache entry was retrieved.
	DWORD dwSizeLow;            // low DWORD of the file size.
	DWORD dwSizeHigh;           // high DWORD of the file size.
	FILETIME LastModifiedTime;  // last modified time of the file in GMT format
	FILETIME ExpireTime;        // expire time of the file in GMT format
	FILETIME LastAccessTime;    // last accessed time in GMT format
	FILETIME LastSyncTime;      // last time the URL was synchronized
	// with the source
	LPWSTR  lpHeaderInfo;        // embedded pointer to the header info.
	DWORD dwHeaderInfoSize;     // size of the above header.
	LPWSTR  lpszFileExtension;  // File extension used to retrive the urldata a
	union {                     // Exemption delta from last access time.
	DWORD dwReserved;
	DWORD dwExemptDelta;
	};                          // Exemption delta from last access
	} INTERNET_CACHE_ENTRY_INFOW, * LPINTERNET_CACHE_ENTRY_INFOW;

	INTERNET_CACHE_ENTRY_INFO *pICEinfo;
	pICEinfo = reinterpret_cast<INTERNET_CACHE_ENTRY_INFO*>(bufHeaderInfo);
	pICEinfo->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);
	pICEinfo->lpszSourceUrlName = (LPWSTR)((BYTE*)pICEinfo + pICEinfo->dwStructSize);
	TCHAR *curStr = pICEinfo->lpszSourceUrlName;
	if(_tcslen(m_szUrl) <= MAX_CACHE_ENTRY_INFO_SIZE/2 - pICEinfo->dwStructSize/2)
	_tcsncpy(curStr, m_szUrl, _tcslen(m_szUrl));
	pICEinfo->lpszLocalFileName = pICEinfo->lpszSourceUrlName + _tcslen(m_szUrl) + 1;
	curStr = pICEinfo->lpszLocalFileName;
	if(_tcslen(m_szFileName) <= MAX_CACHE_ENTRY_INFO_SIZE/2 - pICEinfo->dwStructSize/2 - _tcslen(pICEinfo->lpszSourceUrlName) - 1)
	_tcsncpy(curStr, m_szFileName, _tcslen(m_szFileName));
	pICEinfo->CacheEntryType = ceType;
	pICEinfo->LastModifiedTime = m_ftLastModified;
	pICEinfo->ExpireTime = m_ftExpires;
	if(FAILED(CoFileTimeNow(&pICEinfo->LastSyncTime))){
	return E_UNEXPECTED;
	}
	pICEinfo->lpHeaderInfo = pICEinfo->lpszLocalFileName + _tcslen(pICEinfo->lpszLocalFileName) + 1;
	curStr = pICEinfo->lpHeaderInfo;
	if(_tcslen(SZ_DEFAULT_HEADER) <= MAX_CACHE_ENTRY_INFO_SIZE/2 - pICEinfo->dwStructSize/2 - _tcslen(pICEinfo->lpszSourceUrlName) - _tcslen(pICEinfo->lpszLocalFileName) - 2)
	_tcsncpy(curStr, SZ_DEFAULT_HEADER, _tcslen(SZ_DEFAULT_HEADER));
	pICEinfo->dwHeaderInfoSize = _tcslen(SZ_DEFAULT_HEADER);
	pICEinfo->lpszFileExtension = pICEinfo->lpHeaderInfo + _tcslen(pICEinfo->lpHeaderInfo) + 1;
	curStr = pICEinfo->lpszFileExtension;
	if(_tcslen(szFileExtension) <= MAX_CACHE_ENTRY_INFO_SIZE/2 - pICEinfo->dwStructSize/2 - _tcslen(pICEinfo->lpszSourceUrlName) - _tcslen(pICEinfo->lpszLocalFileName) - 2)
	_tcsncpy(curStr, szFileExtension, _tcslen(szFileExtension));
	*/

	if (! CommitUrlCacheEntry(m_szUrl,
                              m_szFileName,
                              m_ftExpires,
                              m_ftLastModified,
                              ceType,                // cache entry type
                              NULL,                  // pointer to header info //bufHeaderInfo,
                              0,                     // size of header info in dwords //(pICEinfo->dwStructSize/2 + _tcslen(pICEinfo->lpszSourceUrlName) + _tcslen(pICEinfo->lpszLocalFileName) +  _tcslen(pICEinfo->lpszFileExtension) + 3),                // bytes of header info
                              NULL,                  // file extension, docs conflict on this some say must be NULL others don't works correctly this way // szFileExtension
                              0                      // reserved
                              )
        ) 
   {
		DBG_WARN(CDebugLog::DBG_SEV3, _T("Failed to commit IE cache entry"));

		DWORD dwError = GetLastError();
		if (ERROR_FILE_NOT_FOUND == dwError)
		{
			DBG_WARN(CDebugLog::DBG_SEV4, _T("ERROR_FILE_NOT_FOUND"));
		}
		else if (ERROR_DISK_FULL == dwError)
		{
			DBG_WARN(CDebugLog::DBG_SEV4, _T("ERROR_DISK_FULL"));
		}
		else
		{
			DBG_WARN(CDebugLog::DBG_SEV4, _T("Unspecified Error"));
		}

		return HRESULT_FROM_WIN32(dwError);
    }
    TVEDebugLog((CDebugLog::DBG_FCACHE, 3, _T("Committed IE cache file : "), m_szUrl));
    _VALIDATE_THIS( );

    return NOERROR;

}   //  CCachedIEFile::Close

//////////////////////////////////////////////////////////////////////////////
//
//  Open
//
//  Opens a file in the TVE spool directory and returns the file handle.
//
//  parameters:
//      szFileName      name of the file to open
//      dwExpectedFileSize expected size of the file
//      ftExpires       expiration date of the file
//      ftLastModified  last modification time of the file
//      szLanguage      language
//      szContentType   content type of file
//
//  returns:
//      NOERROR         if operation is successful
//      E_HANDLE        if the file is already open or can't be opened
//      E_POINTER       if a required pointer parameter is NULL
//      E_INVALIDARG    if a parameter contains an invalid value
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCachedTveFile::GetName(LPCTSTR		*ppszName)
{
	const int kChars = 256;
	static TCHAR tszBuff[kChars];
	_sntprintf(tszBuff,kChars, _T("%s\\%s"),m_rgchDestDir,m_rgchDestFile);
	tszBuff[kChars-1] = 0;		// just in case of an overflow...
	if(ppszName != 0)
		*ppszName =  (LPCTSTR) tszBuff;
	return S_OK;
}

HRESULT
CCachedTveFile::Open(
    LPCTSTR             szUrl,
    DWORD               dwExpectedFileSize,
    FILETIME            ftExpires,
    FILETIME            ftLastModified,
    LPCTSTR             szLanguage,
    LPCTSTR             szContentType
    )
{
	USES_CONVERSION;

    DBG_HEADER(CDebugLog::DBG_FCACHE, _T("CCachedTveFile::Open"));

    // Does this object already correspond to a file?
    //
    _ASSERT(INVALID_HANDLE_VALUE == m_hFile);
    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        DBG_WARN(CDebugLog::DBG_SEV3, _T("TVE cache file already open")); 
        return E_HANDLE;
    }

    // Do the required pointer parameters actually point to something?
    //
    _ASSERT(NULL != szUrl);
    if (NULL == szUrl)
    {
        DBG_WARN(CDebugLog::DBG_SEV3, _T("Invalid parameter: szUrl")); 
        return E_POINTER;
    }

    HRESULT             hr = E_NOTIMPL;
    TCHAR*              pch = NULL;

    // m_rgchSpoolDir is static so only need to do this the first time
    //
    if ('\0' == m_rgchSpoolDir[0])
    {
		// Default the Environment variable if it's not already there...
		Initialize_LID_SpoolDir_RegEntry();

        // Get the spool directory 
        //
        DWORD  dwSpoolDir = _MAX_PATH;
        if (ERROR_SUCCESS != GetUserRegValueSZ(DEF_LIDCACHEDIR_KEY,
											   NULL,
											   NULL,
											   DEF_LIDCACHEDIR_VAR, 
										 	   m_rgchSpoolDir, 
											   &dwSpoolDir
											   )
            )
        {
            TVEDebugLog((CDebugLog::DBG_FCACHE, 5,  _T("Failed to retrieve spool dir from registry  - defaulting to %s"),DEF_LASTCHOICE_LIDCACHEDIR));
			{
				_tcscpy(m_rgchSpoolDir, DEF_LASTCHOICE_LIDCACHEDIR);
			}
        } else {
            TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("Lid Cache Dir: %s"),m_rgchSpoolDir));
		}

        // Is there room for the backslash and null terminator??
        //
        if ((_MAX_PATH - 2) < _tcslen(m_rgchSpoolDir))
        {
	    _ASSERT((_MAX_PATH - 2) >= _tcslen(m_rgchSpoolDir));

            DBG_WARN(CDebugLog::DBG_FCACHE, _T("Spool directory path is too long"));
            return E_UNEXPECTED;
        }
    }
    TVEDebugLog((CDebugLog::DBG_FCACHE, 6, _T("Package Spool directory retrieved: %s"), m_rgchSpoolDir));
    DBG_WARN(CDebugLog::DBG_SEV4, m_rgchSpoolDir);
    if (FALSE == CreatePath(m_rgchSpoolDir))
    {
		DBG_WARN(CDebugLog::DBG_SEV3, _T("Couldn't create spool directory"));
		return E_FAIL;
    }

    // Create the spool file name
    //
    if (! GetTempFileName(m_rgchSpoolDir, _T("tve"), 0, m_rgchSpoolFile))
    {
        DBG_WARN(CDebugLog::DBG_SEV3, _T("Unable to retrieve temp file name"));
        return E_UNEXPECTED;
    }
    DBG_WARN(CDebugLog::DBG_SEV4, _T("Spool file name retrieved"));
    DBG_WARN(CDebugLog::DBG_SEV4, m_rgchSpoolFile);

    // Create the destination file path and name
    //
    if ((0 != _tcsnicmp(szUrl, SZ_SCHEME_LIDCOLON, 4)) || (8 > _tcslen(szUrl)))
	return E_INVALIDARG;

    TCHAR rgchDestUrl[_MAX_PATH];
    TCHAR* rgchDestDir;
    _tcscpy(rgchDestUrl, szUrl);
    rgchDestDir = rgchDestUrl + 6;
    if ((_MAX_PATH - 1) < _tcslen(rgchDestDir))
    {
        DBG_WARN(CDebugLog::DBG_SEV3, _T("Destination path is too long"));
        return E_UNEXPECTED;
    }

    // Replace all front slashes '/' with back slashes '\\'
    //
    pch = rgchDestDir;
    while ((NULL != pch) && (NULL != *pch))
    {
		if ('/' == *pch)
			*pch = '\\';
		pch++;
    }

    // Path precedes last backslash, file name follows it.  If no backslash,
    // assume buffer contains only filename.
    //
    pch = _tcsrchr(rgchDestDir, '\\');
    _ASSERTE(NULL != pch);
    if (NULL == pch)
    {
		return E_INVALIDARG;
    }
    else
    {
        _ASSERT((_MAX_FNAME - 1) > _tcslen(pch + 1));

        // Buffer contains both path and file name.  Replace the last backslash
        // in the path with a null char and copy the file name to the file name
        // buffer.
        //
        *pch = '\0';
        _tcscpy(m_rgchDestFile, ++pch);
		_stprintf(m_rgchDestDir, _T("%s\\%s"), m_rgchSpoolDir, rgchDestDir);

		// Retreive Domain
		//
		pch = rgchDestDir;
		while ((NULL != *pch) && ('\\' != *pch))
			pch++;
		if (NULL != *pch)
			*pch = NULL;
		_tcscpy(m_rgchDestDomain, rgchDestDir);
    }

    // Append backslash to dest dir
    //
    DBG_WARN(CDebugLog::DBG_SEV4, _T("Destination directory retrieved:"));
    DBG_WARN(CDebugLog::DBG_SEV4, m_rgchDestDir);
    DBG_WARN(CDebugLog::DBG_SEV4, _T("Destination file name retrieved:"));
    DBG_WARN(CDebugLog::DBG_SEV4, m_rgchDestFile);

    // Create Temporary File
    //
    m_hFile = CreateFile(m_rgchSpoolFile,       // file path & name
                         GENERIC_WRITE,			// access priviledges
                         0,						// share mode -- no sharing
                         NULL,					// security attributes
                         CREATE_ALWAYS,			// creation attributes
                         0,						// misc flags
                         NULL					// template file
                         );
    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        DBG_WARN(CDebugLog::DBG_SEV3, _T("Failed to create spool file"));
        DBG_WARN(CDebugLog::DBG_SEV3, m_rgchSpoolFile);
        return E_HANDLE;
    }
    TVEDebugLog((CDebugLog::DBG_FCACHE, 3, _T("Created Spool File : %s"), m_rgchSpoolFile));

    _VALIDATE_THIS( );

    return NOERROR;

}   //  CCachedTveFile::Open


//////////////////////////////////////////////////////////////////////////////
//
//  Close
//
//  Close the cache file.
//
//  parameters:
//      None.
//
//  returns:
//      NOERROR         if the file is closed successfully
//      E_FAIL          if it is not
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCachedTveFile::Close( )
{
    DBG_HEADER(CDebugLog::DBG_FCACHE, _T("CCachedTveFile::Close"));

    _VALIDATE_THIS( );


    HRESULT             hr = NOERROR;
    SYSTEMTIME          stNow;
    double              dExpireTime;

    // Set the expiration time on the spool directory to now + 30 minutes
    //
    ::GetSystemTime(&stNow);
    SystemTimeToVariantTime(&stNow, &dExpireTime);

    // Calculate the percentage of a day to the current time to get the
   //  expiration time.
    dExpireTime += m_dExpireIncrement;

    /*   SetRegValue(DEF_TEMP_SUBDIRS,
    m_rgchDestDomain,
    reinterpret_cast<BYTE*>(&dExpireTime),
    sizeof(double)
    );
    */                  

    return Commit( );


}   //  CCachedTveFile::Close


//////////////////////////////////////////////////////////////////////////////
//
//  Commit
//
//  Close the temporary file, move the temporary file to the destination file,
//  and set the destination file's attributes.
//
//  parameters:
//      None.
//
//  returns:
//      NOERROR         if the operation is successful
//      E_FAIL          otherwise
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCachedTveFile::Commit( )
{
    try{
        USES_CONVERSION;

        DBG_HEADER(CDebugLog::DBG_FCACHE, _T("CCachedTveFile::Commit"));

        HRESULT             hr = NOERROR;
        TCHAR               rgchDestPath[_MAX_PATH];

        // close temporary file 
        //
        if (! CloseHandle(m_hFile))
        {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Failed to close TVE cache file handle"));
            _ASSERT(FALSE);
            return E_FAIL;
        }
        m_hFile = INVALID_HANDLE_VALUE;
        DBG_WARN(CDebugLog::DBG_SEV4, _T("TVE cache file closed"));

        // move the temp file to the dest file
        //
        if (FALSE == CreatePath(m_rgchDestDir))
        {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Couldn't create destination path"));
            return E_FAIL;
        }

        _stprintf(rgchDestPath, _T("%s\\%s"), m_rgchDestDir, m_rgchDestFile);
        DBG_WARN(CDebugLog::DBG_SEV4, rgchDestPath);
        hr = MoveFile(m_rgchSpoolFile, rgchDestPath);
        if (FAILED(hr))
        {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Failed to move spool file to destination file"));
            remove(T2A(m_rgchSpoolFile));
            return E_FAIL;
        }
        SetFileAttributes(rgchDestPath, FILE_ATTRIBUTE_NORMAL);
        TVEDebugLog((CDebugLog::DBG_FCACHE, 3, _T("Move Spool file %s to %s"), m_rgchSpoolFile, rgchDestPath));

        return NOERROR;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}   //  CCachedTveFile::Commit

//////////////////////////////////////////////////////////////////////////////
//
//  MoveFile
//
//  Move a file to another file and/or directory.
//
//  parameters:
//      szOldFile       name (and path) of file to be moved
//      szNewFile       new name (and path) of file
//
//  returns:
//      NOERROR         if the operation completes successfully
//      E_FAIL          otherwise
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCachedTveFile::MoveFile(
                         LPCTSTR             szOldFile,
                         LPCTSTR             szNewFile
                         )
{
    try{
        USES_CONVERSION;

        DBG_HEADER(CDebugLog::DBG_FCACHE, _T("CCachedTveFile::MoveFile"));

        if (0 != rename(T2CA(szOldFile), T2CA(szNewFile)))
        {
            if (0 != remove(T2CA(szNewFile)) || 0 != rename(T2CA(szOldFile), T2CA(szNewFile)))
            {
                return E_FAIL;
            }
        }

        return NOERROR;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}   //  CCachedTveFile::MoveFile


//////////////////////////////////////////////////////////////////////////////
//
//  OpenCacheFile
//
//  Determines which type of cached file object to instantiate based on the URL
//  scheme.  Any scheme other than lid: is forwarded to the IE cache.  Returns
//  a handle to the file.
//
//  parameters:
//      szUrl           URL of the file to be written
//      dwExpectedFileSize expected size of the file
//      ftExpires       expiration date of the file
//      ftLastModified  last modification time of the file
//      szLanguage      language
//      szContentType   content type of file
//      phFile          pointer to the buffer that will receive the handle of
//                      the newly opened file
//
//  returns:
//      NOERROR         if the operation is successful
//      E_POINTER       if a required pointer parameter is NULL
//      E_OUTOFMEMORY   if the cached file object cannot be allocated
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCacheManager::OpenCacheFile(
    LPCTSTR             szUrl,
    DWORD               dwExpectedFileSize,
    FILETIME            ftExpires,
    FILETIME            ftLastModified,
    LPCTSTR             szLanguage,
    LPCTSTR             szContentType,
    CCachedFile*&       rpCachedFile
    )
{
	USES_CONVERSION;

    DBG_HEADER(CDebugLog::DBG_FCACHE, _T("CCacheManager::OpenCacheFile"));

    _ASSERT(NULL != szUrl);
    if (NULL == szUrl)
    {
        DBG_WARN(CDebugLog::DBG_SEV3, _T("Invalid parameter")); 
        return E_POINTER;
    }

    _ASSERT(NULL == _tcsstr(szUrl, _T("..")));
    if (NULL != _tcsstr(szUrl, _T("..")))
    {
	DBG_WARN(CDebugLog::DBG_SEV3, _T("Relative path"));
	return E_INVALIDARG;
    }

    HRESULT             hr = NOERROR;
    CCachedFile*        pCachedFile = NULL;
    TCHAR*              pch;

    // Compare the scheme of the URL (chars up to the colon) with the
    // LID scheme.  Compare is case-insensitive to the length of the
    // longer of the two strings.  If they match, store in the TVE
    // cache; otherwise, let IE cache it.
    // 
    pch = _tcschr(szUrl, ':');
    if (NULL != pch &&
        0 == _tcsncicmp(szUrl, SZ_SCHEME_LID, 
                        max((int) _tcslen(SZ_SCHEME_LID), pch - szUrl)
                        )
        )
    {
		// LID: case dont worry about case and '\'s to '/'s since we do all of the processing here
        pCachedFile = new CCachedTveFile;
        if (NULL == pCachedFile)
        {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Failed to create CCachedTveFile object"));
            return E_OUTOFMEMORY;
        }
    }
    else
    {
		// convert all '\' to '/' and make sure the ip address (string after the protocol type and before the 1st '/'
		//	i.e. http://xxx/ make sure all of 'xxx' is lower case and covert it if not (also lower case the protocol)
        pCachedFile = new CCachedIEFile;
        if (NULL == pCachedFile)
        {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Failed to create CCachedIEFile object"));
            return E_OUTOFMEMORY;
        }
		TCHAR *pcSlash = (TCHAR *)szUrl;
		int numSlash = 0;
		while (0 != *pcSlash) {
			// Convert '\' to '/'
            if (L'\\' == *pcSlash) {
		        *pcSlash = L'/';
				++numSlash;
            }
			// make sure everything before the 3rd '/' is lower case
			if(numSlash <= 2){
				if(_istupper(*pcSlash) != 0){
					*pcSlash = _tolower(*pcSlash);
				}
			}
		    ++pcSlash;
	    }
    }
    hr = pCachedFile->Open(szUrl,
                           dwExpectedFileSize,
                           ftExpires,
                           ftLastModified,
                           szLanguage,
                           szContentType
                           );

    if (FAILED(hr))
    {
        delete pCachedFile;
        pCachedFile = NULL;
        return hr;
    } 

    rpCachedFile = pCachedFile;

    _VALIDATE_THIS( );

    return hr;

}   //  CCacheManager::OpenCacheFile








//
///// End of file: fcache.cpp ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\infblock.h ===
/* infblock.h -- header to use infblock.c
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

struct inflate_blocks_state;
typedef struct inflate_blocks_state FAR inflate_blocks_statef;

extern inflate_blocks_statef * inflate_blocks_new OF((
    z_streamp z,
    check_func c,               /* check function */
    uInt w));                   /* window size */

extern int inflate_blocks OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));                      /* initial return code */

extern void inflate_blocks_reset OF((
    inflate_blocks_statef *,
    z_streamp ,
    uLongf *));                  /* check value on output */

extern int inflate_blocks_free OF((
    inflate_blocks_statef *,
    z_streamp ,
    uLongf *));                  /* check value on output */

extern void inflate_set_dictionary OF((
    inflate_blocks_statef *s,
    const Bytef *d,  /* dictionary */
    uInt  n));       /* dictionary length */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\infcodes.h ===
/* infcodes.h -- header to use infcodes.c
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

struct inflate_codes_state;
typedef struct inflate_codes_state FAR inflate_codes_statef;

extern inflate_codes_statef *inflate_codes_new OF((
    uInt, uInt,
    inflate_huft *, inflate_huft *,
    z_streamp ));

extern int inflate_codes OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

extern void inflate_codes_free OF((
    inflate_codes_statef *,
    z_streamp ));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\fcache.h ===
#ifndef     _FCACHE_H_
#define _FCACHE_H_

//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  Module: fcache.h
//
//  Author: Dan Elliott
//
//  Abstract:
//
//  Environment:
//      Win98, Win2000
//
//  Revision History:
//      990201  dane    Created and added the following classes:
//                      * CCachedFile
//                      * CCachedIEFile
//                      * CCachedTveFile
//                      * CCacheManager
//                      * CCacheTrivia
//                      * CTveCacheTrivia
//      990203  dane    Moved code that could fail in constructor to Init( )
//                      in the following classes
//                      * CTveCacheTrivia
//                      * CCacheManager
//      990207  dane    Move m_dExpireIncrement and m_szSpoolDir to
//                      CCachedTveFile and removed CCacheTrivia and
//                      CTveCacheTrivia classes.
//      990207  dane    Moved URL cracking into CCachedTveFile::Open.
//                      CCacheManager::OpenCacheFile now only determines
//                      which cache the file goes into and creates the
//                      appropriate object.
//      990210  dane    CCacheManager::OpenCacheFile now returns a CCachedFile
//                      pointer instead of a file handle
//                      Removed CCacheManager::CloseCacheFile.
//		991014	jb		Added the TVESupervisor back pointer
//						Added TVEEvents on file reception
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  Macros
//
#ifdef      _DEBUG
    #define _VERIFY(expr)       _ASSERT(expr)
    #define _VALIDATE(obj)      _ASSERT((obj).IsValid( ))
    #define _VALIDATE_THIS( )   _VALIDATE(*this)
    #define _VALIDATE_CONNECTION_MAPS( ) _ASSERT(ValidateConnectionMaps( ))
#else   //  ! _DEBUG
    #define _VERIFY(expr)       ((void)(expr))
    #define _VALIDATE(obj)      ((void)(obj))
    #define _VALIDATE_THIS( )
    #define _VALIDATE_CONNECTION_MAPS( )
#endif  //  _DEBUG

//////////////////////////////////////////////////////////////////////////////
//
// CTveObject  -- low level object used in low level decoder only - not in
//		TVESupervisor Tree objects 
//
// Base object from which all others derive.  Detects memory overwrites, use
// of unallocated/deallocated objects by comparing its this pointer to a
// cached this pointer.
//
class CTveObject 
{
// Public member functions
//
public:
    CTveObject( )
    :   m_this(this)
    {
    }   //  CTveObject

    //  Verify that rhs is valid.  rhs member data must not be copied.
    //
    CTveObject(const CTveObject& rhs)
    {
        _ASSERT(rhs.IsValid( ));
    }   //  CTveObject

    // Verify that both objects are valid.  rhs member data must not be
    // copied.
    //
    CTveObject& operator=(const CTveObject& rhs)
    {
        _ASSERT(IsValid( ));
        _ASSERT(rhs.IsValid( ));

        return *this;
    }   //  operator=

    // Verify that this object is valid.  Set m_this to invalid value.
    //
    ~CTveObject( )
    {
        _ASSERT(IsValid( ));
        m_this = NULL;
    }   //  ~CTveObject

    // Determine whether this object is valid by comparing its this pointer
    // to the one that was cached when the object was created.
    //
    BOOL 
    IsValid( ) const
    {
        return (this == m_this);
    }   //  IsValid

// Private member data
//
private:
    // Cached this pointer.  Set at object creation.  Compared against to
    // determine whether object has been overwritten, was never allocated, or
    // has been deallocated.
    //
    const CTveObject*      m_this;

};  //  CTveObject


//////////////////////////////////////////////////////////////////////////////
//
// CCachedFile
//
// Virtual base class for cached files.  Provides file handle and basic object
// validation.
//
class CCachedFile 
:   public CTveObject
{
// Public member functions
//
public:
    CCachedFile(HANDLE hFile = INVALID_HANDLE_VALUE)
    {
	m_hFile = hFile;
    }   //  CCachedFile

    virtual 
    ~CCachedFile( )
    {
	_VALIDATE_THIS();
    };

    virtual HRESULT
    Open(LPCTSTR             szName,
	    DWORD               dwExpectedFileSize,
	    FILETIME            ftExpires,
	    FILETIME            ftLastModified,
	    LPCTSTR             szLanguage,
	    LPCTSTR             szContentType) = 0;

    virtual HRESULT
    Close( ) = 0;

    const HANDLE&
    Handle( )
    {
        return m_hFile;
    }   //  hFile

    BOOL
    IsValid( )  const
    {
        return CTveObject::IsValid( );
    }   //  IsValid

	virtual HRESULT 
		GetName(LPCTSTR			*ppszName)	= 0;
// Protected member functions
//
protected:

// Protected member data
//
protected:
    HANDLE                      m_hFile;

// Private member functions
//
private:
    // Explicitly prohibit use of copy constructor and assignment operator.
    //
    CCachedFile(const CCachedFile& rhs);

    CCachedFile&
    operator=(const CCachedFile& rhs);

};  //  CCachedFile

//////////////////////////////////////////////////////////////////////////////
//
// CCachedIEFile
//
// Concrete class for writing files to the IE cache.  Provides ability to
// retrieve handle to a file from the IE cache based on a URL and commit
// changes to that file when done with it.
//
class CCachedIEFile 
:   public CCachedFile
{
// Public member functions
//
public:
    CCachedIEFile( )
    :   m_szUrl(NULL)
    {
	m_szFileName[0] = NULL;
	m_szFileExtension[0] = NULL;
        _VALIDATE_THIS( );
    }   //  CCachedIEFile

    virtual 
    ~CCachedIEFile( )
    {
        _VALIDATE_THIS( );
        if (NULL != m_szUrl)
        {
            // Use free to release memory allocated with _tcsdup (_strdup)
            //
            free(m_szUrl);
            m_szUrl = NULL;
        }
    }   //  ~CCachedIEFile

    virtual HRESULT
    Open(LPCTSTR             szUrl,
	    DWORD               dwExpectedFileSize,
	    FILETIME            ftExpires,
	    FILETIME            ftLastModified,
	    LPCTSTR             szLanguage,
	    LPCTSTR             szContentType);

    virtual HRESULT
    Close( );

	virtual HRESULT GetName(LPCTSTR			*ppszName);

// Private member functions
//
private:
    // Explicitly prohibit use of copy constructor and assignment operator.
    //
    CCachedIEFile(const CCachedIEFile& rhs);

    CCachedIEFile&
    operator=(const CCachedIEFile& rhs);

    BOOL
    IsValid( ) const
    {
        if (! CCachedFile::IsValid( ))
        {
            return FALSE;
        }

        if (INVALID_HANDLE_VALUE == m_hFile)
        {
            if (NULL != m_szUrl ||
                NULL != m_szFileName[0])
            {
                return FALSE;
            }
        }
        else
        {
            if (NULL == m_szUrl ||
                NULL == m_szFileName[0])
            {
                return FALSE;
            }
        }

        return TRUE;

    }   //  IsValid

// Private member data
//
private:

    // Name of URL from which the file came
    //
    TCHAR*              m_szUrl;

    // File name returned by CreateUrlCacheEntry
    //
    TCHAR               m_szFileName[_MAX_PATH];

    // File extension
    TCHAR		m_szFileExtension[_MAX_PATH];	// This is overkill

    // Expiration date for the file
    //
    FILETIME            m_ftExpires;

    // Last modification time for the file
    //
    FILETIME            m_ftLastModified;

};  //  CCachedIEFile


//////////////////////////////////////////////////////////////////////////////
//
// CCachedTveFile
//
// Concrete class for writing files to the TVE cache.  Provides ability to
// create a namespace for the file, open, write, close the file.
//
class CCachedTveFile 
:   public CCachedFile
{
// Public member functions
//
public:
    CCachedTveFile( )
    { 
        ZeroMemory(m_rgchSpoolFile, sizeof(m_rgchSpoolFile));
        ZeroMemory(m_rgchDestFile, sizeof(m_rgchDestFile));
        _VALIDATE_THIS( );
    }   //  CCachedTveFile

    virtual 
    ~CCachedTveFile( )
    { 
        _VALIDATE_THIS( );
    }   //  ~CCachedTveFile

    virtual HRESULT
    Open(LPCTSTR             szFileName,
	    DWORD               dwExpectedFileSize,
	    FILETIME            ftExpires,
	    FILETIME            ftLastModified,
	    LPCTSTR             szLanguage,
	    LPCTSTR             szContentType);

    virtual HRESULT
    Close( );

    BOOL
    IsValid( ) const
    {
       return CCachedFile::IsValid( ); 
    }   //  IsValid

	virtual HRESULT GetName(LPCTSTR			*ppszName);

// Private member functions
//
private:
    // Explicitly prohibit use of copy constructor and assignment operator.
    //
    CCachedTveFile(const CCachedTveFile& rhs);

    CCachedTveFile& operator=(const CCachedTveFile& rhs);

    HRESULT
    Commit( );

    HRESULT
    MoveFile(LPCTSTR szOldFile, LPCTSTR szNewFile);

// Private member data
//
private:
    enum
    {
        MINS_EXPIRE_INCREMENT = 30,
        MINS_PER_DAY   = 60 * 24
    };

    static TCHAR        m_rgchSpoolDir[_MAX_PATH];
    TCHAR               m_rgchSpoolFile[_MAX_FNAME];
    TCHAR               m_rgchDestDir[_MAX_PATH];
    TCHAR               m_rgchDestFile[_MAX_FNAME];
    TCHAR				m_rgchDestDomain[_MAX_PATH];
    static double       m_dExpireIncrement;

};  //  CCachedTveFile

//////////////////////////////////////////////////////////////////////////////
//
// CCacheManager
//
// Concrete class for managing files being written to the IE and TVE caches.
// Determines which cache the file should be written to by examining the URL
// scheme.  Creates the appropriate object.
//
class CCacheManager 
:   public CTveObject
{
// Public member functions
//
public:
    CCacheManager( )
    {
        _VALIDATE_THIS( );
		m_pTVESuper = NULL;
    }   //  CCacheManager

    ~CCacheManager( )
    {
        _VALIDATE_THIS( );
    }   //  ~CCacheManager

    HRESULT
    OpenCacheFile(
        LPCTSTR             szUrl,
        DWORD               dwExpectedFileSize,
        FILETIME            ftExpires,
        FILETIME            ftLastModified,
        LPCTSTR             szLanguage,
        LPCTSTR             szContentType,
        CCachedFile*&       ppCachedFile
        );

    BOOL
    IsValid( )
    {
        return CTveObject::IsValid( );

    }   //  IsValid

	HRESULT
	SetTVESupervisor(IUnknown *pTVESuper)		// should be ITVESupervisor *
	{
		m_pTVESuper = pTVESuper;				// should be called in ITVESupervisor::FinalRelease()
		return S_OK;
	}

//
	IUnknown			*m_pTVESuper;
// Protected member functions
//
protected:


protected:

// Private member functions
//
private:
    // Explicitly prohibit use of copy constructor and assignment operator.
    //
    CCacheManager(
        const CCacheManager&      rhs
        );

    CCacheManager&
    operator=(
        const CCacheManager&      rhs
        );

// Private member data
//
private:


};  //  CCacheManager

#endif  //  _FCACHE_H_

//
///// End of file: fcache.h   /////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\infblock.c ===
/* infblock.c -- interpret and process block types to last block
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"
#include "inftrees.h"
#include "infcodes.h"
#include "infutil.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* Table for deflate from PKZIP's appnote.txt. */
local uInt border[] = { /* Order of the bit length code lengths */
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

/*
   Notes beyond the 1.93a appnote.txt:

   1. Distance pointers never point before the beginning of the output
      stream.
   2. Distance pointers can point back across blocks, up to 32k away.
   3. There is an implied maximum of 7 bits for the bit length table and
      15 bits for the actual data.
   4. If only one code exists, then it is encoded using one bit.  (Zero
      would be more efficient, but perhaps a little confusing.)  If two
      codes exist, they are coded using one bit each (0 and 1).
   5. There is no way of sending zero distance codes--a dummy must be
      sent if there are none.  (History: a pre 2.0 version of PKZIP would
      store blocks with no distance codes, but this was discovered to be
      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
      zero distance codes, which is sent as one code of zero bits in
      length.
   6. There are up to 286 literal/length codes.  Code 256 represents the
      end-of-block.  Note however that the static length tree defines
      288 codes just to fill out the Huffman codes.  Codes 286 and 287
      cannot be used though, since there is no length base or extra bits
      defined for them.  Similarily, there are up to 30 distance codes.
      However, static trees define 32 codes (all 5 bits) to fill out the
      Huffman codes, but the last two had better not show up in the data.
   7. Unzip can check dynamic Huffman blocks for complete code sets.
      The exception is that a single code would not be complete (see #4).
   8. The five bits following the block type is really the number of
      literal codes sent minus 257.
   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
      (1+6+6).  Therefore, to output three times the length, you output
      three codes (1+1+1), whereas to output four times the same length,
      you only need two codes (1+3).  Hmm.
  10. In the tree reconstruction algorithm, Code = Code + Increment
      only if BitLength(i) is not zero.  (Pretty obvious.)
  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
  12. Note: length code 284 can represent 227-258, but length code 285
      really is 258.  The last length deserves its own, short code
      since it gets used a lot in very redundant files.  The length
      258 is special since 258 - 3 (the min match length) is 255.
  13. The literal/length and distance code bit lengths are read as a
      single stream of lengths.  It is possible (and advantageous) for
      a repeat code (16, 17, or 18) to go across the boundary between
      the two sets of lengths.
 */


void inflate_blocks_reset(s, z, c)
inflate_blocks_statef *s;
z_streamp z;
uLongf *c;
{
  if (s->checkfn != Z_NULL)
    *c = s->check;
  if (s->mode == BTREE || s->mode == DTREE)
    ZFREE(z, s->sub.trees.blens);
  if (s->mode == CODES)
  {
    inflate_codes_free(s->sub.decode.codes, z);
    inflate_trees_free(s->sub.decode.td, z);
    inflate_trees_free(s->sub.decode.tl, z);
  }
  s->mode = TYPE;
  s->bitk = 0;
  s->bitb = 0;
  s->read = s->write = s->window;
  if (s->checkfn != Z_NULL)
    z->adler = s->check = (*s->checkfn)(0L, Z_NULL, 0);
  Trace((stderr, "inflate:   blocks reset\n"));
}


inflate_blocks_statef *inflate_blocks_new(z, c, w)
z_streamp z;
check_func c;
uInt w;
{
  inflate_blocks_statef *s;

  if ((s = (inflate_blocks_statef *)ZALLOC
       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
    return s;
  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
  {
    ZFREE(z, s);
    return Z_NULL;
  }
  s->end = s->window + w;
  s->checkfn = c;
  s->mode = TYPE;
  Trace((stderr, "inflate:   blocks allocated\n"));
  inflate_blocks_reset(s, z, &s->check);
  return s;
}


#ifdef DEBUG
  extern uInt inflate_hufts;
#endif
int inflate_blocks(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt t;               /* temporary storage */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD

  /* process input based on current state */
  while (1) switch (s->mode)
  {
    case TYPE:
      NEEDBITS(3)
      t = (uInt)b & 7;
      s->last = t & 1;
      switch (t >> 1)
      {
        case 0:                         /* stored */
          Trace((stderr, "inflate:     stored block%s\n",
                 s->last ? " (last)" : ""));
          DUMPBITS(3)
          t = k & 7;                    /* go to byte boundary */
          DUMPBITS(t)
          s->mode = LENS;               /* get length of stored block */
          break;
        case 1:                         /* fixed */
          Trace((stderr, "inflate:     fixed codes block%s\n",
                 s->last ? " (last)" : ""));
          {
            uInt bl, bd;
            inflate_huft *tl, *td;

            inflate_trees_fixed(&bl, &bd, &tl, &td);
            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
            if (s->sub.decode.codes == Z_NULL)
            {
              r = Z_MEM_ERROR;
              LEAVE
            }
            s->sub.decode.tl = Z_NULL;  /* don't try to free these */
            s->sub.decode.td = Z_NULL;
          }
          DUMPBITS(3)
          s->mode = CODES;
          break;
        case 2:                         /* dynamic */
          Trace((stderr, "inflate:     dynamic codes block%s\n",
                 s->last ? " (last)" : ""));
          DUMPBITS(3)
          s->mode = TABLE;
          break;
        case 3:                         /* illegal */
          DUMPBITS(3)
          s->mode = BAD;
          z->msg = (char*)"invalid block type";
          r = Z_DATA_ERROR;
          LEAVE
      }
      break;
    case LENS:
      NEEDBITS(32)
      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
      {
        s->mode = BAD;
        z->msg = (char*)"invalid stored block lengths";
        r = Z_DATA_ERROR;
        LEAVE
      }
      s->sub.left = (uInt)b & 0xffff;
      b = k = 0;                      /* dump bits */
      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
      break;
    case STORED:
      if (n == 0)
        LEAVE
      NEEDOUT
      t = s->sub.left;
      if (t > n) t = n;
      if (t > m) t = m;
      zmemcpy(q, p, t);
      p += t;  n -= t;
      q += t;  m -= t;
      if ((s->sub.left -= t) != 0)
        break;
      Tracev((stderr, "inflate:       stored end, %lu total out\n",
              z->total_out + (q >= s->read ? q - s->read :
              (s->end - s->read) + (q - s->window))));
      s->mode = s->last ? DRY : TYPE;
      break;
    case TABLE:
      NEEDBITS(14)
      s->sub.trees.table = t = (uInt)b & 0x3fff;
#ifndef PKZIP_BUG_WORKAROUND
      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
      {
        s->mode = BAD;
        z->msg = (char*)"too many length or distance symbols";
        r = Z_DATA_ERROR;
        LEAVE
      }
#endif
      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
      if (t < 19)
        t = 19;
      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
      {
        r = Z_MEM_ERROR;
        LEAVE
      }
      DUMPBITS(14)
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       table sizes ok\n"));
      s->mode = BTREE;
    case BTREE:
      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
      {
        NEEDBITS(3)
        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
        DUMPBITS(3)
      }
      while (s->sub.trees.index < 19)
        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
      s->sub.trees.bb = 7;
      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
                             &s->sub.trees.tb, z);
      if (t != Z_OK)
      {
        r = t;
        if (r == Z_DATA_ERROR)
          s->mode = BAD;
        LEAVE
      }
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       bits tree ok\n"));
      s->mode = DTREE;
    case DTREE:
      while (t = s->sub.trees.table,
             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
      {
        inflate_huft *h;
        uInt i, j, c;

        t = s->sub.trees.bb;
        NEEDBITS(t)
        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
        t = h->word.what.Bits;
        c = h->more.Base;
        if (c < 16)
        {
          DUMPBITS(t)
          s->sub.trees.blens[s->sub.trees.index++] = c;
        }
        else /* c == 16..18 */
        {
          i = c == 18 ? 7 : c - 14;
          j = c == 18 ? 11 : 3;
          NEEDBITS(t + i)
          DUMPBITS(t)
          j += (uInt)b & inflate_mask[i];
          DUMPBITS(i)
          i = s->sub.trees.index;
          t = s->sub.trees.table;
          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
              (c == 16 && i < 1))
          {
            s->mode = BAD;
            z->msg = (char*)"invalid bit length repeat";
            r = Z_DATA_ERROR;
            LEAVE
          }
          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
          do {
            s->sub.trees.blens[i++] = c;
          } while (--j);
          s->sub.trees.index = i;
        }
      }
      inflate_trees_free(s->sub.trees.tb, z);
      s->sub.trees.tb = Z_NULL;
      {
        uInt bl, bd;
        inflate_huft *tl, *td;
        inflate_codes_statef *c;

        bl = 9;         /* must be <= 9 for lookahead assumptions */
        bd = 6;         /* must be <= 9 for lookahead assumptions */
        t = s->sub.trees.table;
#ifdef DEBUG
      inflate_hufts = 0;
#endif
        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
                                  s->sub.trees.blens, &bl, &bd, &tl, &td, z);
        if (t != Z_OK)
        {
          if (t == (uInt)Z_DATA_ERROR)
            s->mode = BAD;
          r = t;
          LEAVE
        }
        Tracev((stderr, "inflate:       trees ok, %d * %d bytes used\n",
              inflate_hufts, sizeof(inflate_huft)));
        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
        {
          inflate_trees_free(td, z);
          inflate_trees_free(tl, z);
          r = Z_MEM_ERROR;
          LEAVE
        }
        ZFREE(z, s->sub.trees.blens);
        s->sub.decode.codes = c;
        s->sub.decode.tl = tl;
        s->sub.decode.td = td;
      }
      s->mode = CODES;
    case CODES:
      UPDATE
      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
        return inflate_flush(s, z, r);
      r = Z_OK;
      inflate_codes_free(s->sub.decode.codes, z);
      inflate_trees_free(s->sub.decode.td, z);
      inflate_trees_free(s->sub.decode.tl, z);
      LOAD
      Tracev((stderr, "inflate:       codes end, %lu total out\n",
              z->total_out + (q >= s->read ? q - s->read :
              (s->end - s->read) + (q - s->window))));
      if (!s->last)
      {
        s->mode = TYPE;
        break;
      }
      if (k > 7)              /* return unused byte, if any */
      {
        Assert(k < 16, "inflate_codes grabbed too many bytes")
        k -= 8;
        n++;
        p--;                    /* can always return one */
      }
      s->mode = DRY;
    case DRY:
      FLUSH
      if (s->read != s->write)
        LEAVE
      s->mode = DONE;
    case DONE:
      r = Z_STREAM_END;
      LEAVE
    case BAD:
      r = Z_DATA_ERROR;
      LEAVE
    default:
      r = Z_STREAM_ERROR;
      LEAVE
  }
}


int inflate_blocks_free(s, z, c)
inflate_blocks_statef *s;
z_streamp z;
uLongf *c;
{
  inflate_blocks_reset(s, z, c);
  ZFREE(z, s->window);
  ZFREE(z, s);
  Trace((stderr, "inflate:   blocks freed\n"));
  return Z_OK;
}


void inflate_set_dictionary(s, d, n)
inflate_blocks_statef *s;
const Bytef *d;
uInt  n;
{
  zmemcpy((charf *)s->window, d, n);
  s->read = s->write = s->window + n;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\inffast.h ===
/* inffast.h -- header to use inffast.c
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

extern int inflate_fast OF((
    uInt,
    uInt,
    inflate_huft *,
    inflate_huft *,
    inflate_blocks_statef *,
    z_streamp ));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\infcodes.c ===
/* infcodes.c -- process literals and length/distance pairs
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

/* simplify the use of the inflate_huft type with some defines */
#define base more.Base
#define next more.Next
#define exop word.what.Exop
#define bits word.what.Bits

/* inflate codes private state */
struct inflate_codes_state {

  /* mode */
  enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
      START,    /* x: set up for LEN */
      LEN,      /* i: get length/literal/eob next */
      LENEXT,   /* i: getting length extra (have base) */
      DIST,     /* i: get distance next */
      DISTEXT,  /* i: getting distance extra */
      COPY,     /* o: copying bytes in window, waiting for space */
      LIT,      /* o: got literal, waiting for output space */
      WASH,     /* o: got eob, possibly still output waiting */
      END,      /* x: got eob and all data flushed */
      BADCODE}  /* x: got error */
    mode;               /* current inflate_codes mode */

  /* mode dependent information */
  uInt len;
  union {
    struct {
      inflate_huft *tree;       /* pointer into tree */
      uInt need;                /* bits needed */
    } code;             /* if LEN or DIST, where in tree */
    uInt lit;           /* if LIT, literal */
    struct {
      uInt get;                 /* bits to get for extra */
      uInt dist;                /* distance back to copy from */
    } copy;             /* if EXT or COPY, where and how much */
  } sub;                /* submode */

  /* mode independent information */
  Byte lbits;           /* ltree bits decoded per branch */
  Byte dbits;           /* dtree bits decoder per branch */
  inflate_huft *ltree;          /* literal/length/eob tree */
  inflate_huft *dtree;          /* distance tree */

};


inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
uInt bl, bd;
inflate_huft *tl;
inflate_huft *td; /* need separate declaration for Borland C++ */
z_streamp z;
{
  inflate_codes_statef *c;

  if ((c = (inflate_codes_statef *)
       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
  {
    c->mode = START;
    c->lbits = (Byte)bl;
    c->dbits = (Byte)bd;
    c->ltree = tl;
    c->dtree = td;
    Tracev((stderr, "inflate:       codes new\n"));
  }
  return c;
}


int inflate_codes(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt j;               /* temporary storage */
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  Bytef *f;             /* pointer to copy strings from */
  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD

  /* process input and output based on current state */
  while (1) switch (c->mode)
  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
    case START:         /* x: set up for LEN */
#ifndef SLOW
      if (m >= 258 && n >= 10)
      {
        UPDATE
        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
        LOAD
        if (r != Z_OK)
        {
          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
          break;
        }
      }
#endif /* !SLOW */
      c->sub.code.need = c->lbits;
      c->sub.code.tree = c->ltree;
      c->mode = LEN;
    case LEN:           /* i: get length/literal/eob next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e == 0)               /* literal */
      {
        c->sub.lit = t->base;
        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                 "inflate:         literal '%c'\n" :
                 "inflate:         literal 0x%02x\n", t->base));
        c->mode = LIT;
        break;
      }
      if (e & 16)               /* length */
      {
        c->sub.copy.get = e & 15;
        c->len = t->base;
        c->mode = LENEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t->next;
        break;
      }
      if (e & 32)               /* end of block */
      {
        Tracevv((stderr, "inflate:         end of block\n"));
        c->mode = WASH;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid literal/length code";
      r = Z_DATA_ERROR;
      LEAVE
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->len += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      c->sub.code.need = c->dbits;
      c->sub.code.tree = c->dtree;
      Tracevv((stderr, "inflate:         length %u\n", c->len));
      c->mode = DIST;
    case DIST:          /* i: get distance next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e & 16)               /* distance */
      {
        c->sub.copy.get = e & 15;
        c->sub.copy.dist = t->base;
        c->mode = DISTEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t->next;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid distance code";
      r = Z_DATA_ERROR;
      LEAVE
    case DISTEXT:       /* i: getting distance extra */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->sub.copy.dist += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
      c->mode = COPY;
    case COPY:          /* o: copying bytes in window, waiting for space */
#ifndef __TURBOC__ /* Turbo C bug for following expression */
      f = (uInt)(q - s->window) < c->sub.copy.dist ?
          s->end - (c->sub.copy.dist - (q - s->window)) :
          q - c->sub.copy.dist;
#else
      f = q - c->sub.copy.dist;
      if ((uInt)(q - s->window) < c->sub.copy.dist)
        f = s->end - (c->sub.copy.dist - (uInt)(q - s->window));
#endif
      while (c->len)
      {
        NEEDOUT
        OUTBYTE(*f++)
        if (f == s->end)
          f = s->window;
        c->len--;
      }
      c->mode = START;
      break;
    case LIT:           /* o: got literal, waiting for output space */
      NEEDOUT
      OUTBYTE(c->sub.lit)
      c->mode = START;
      break;
    case WASH:          /* o: got eob, possibly more output */
      FLUSH
      if (s->read != s->write)
        LEAVE
      c->mode = END;
    case END:
      r = Z_STREAM_END;
      LEAVE
    case BADCODE:       /* x: got error */
      r = Z_DATA_ERROR;
      LEAVE
    default:
      r = Z_STREAM_ERROR;
      LEAVE
  }
}


void inflate_codes_free(c, z)
inflate_codes_statef *c;
z_streamp z;
{
  ZFREE(z, c);
  Tracev((stderr, "inflate:       codes free\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\inffast.c ===
/* inffast.c -- process literals and length/distance pairs fast
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define base more.Base
#define next more.Next
#define exop word.what.Exop
#define bits word.what.Bits

/* macros for bit input with no checking and for returning unused bytes */
#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define UNGRAB {n+=(c=k>>3);p-=c;k&=7;}

/* Called with number of bytes left to write in window at least 258
   (the maximum string length) and number of input bytes available
   at least ten.  The ten bytes are six bytes for the longest length/
   distance pair plus four bytes for overloading the bit buffer. */

int inflate_fast(bl, bd, tl, td, s, z)
uInt bl, bd;
inflate_huft *tl;
inflate_huft *td; /* need separate declaration for Borland C++ */
inflate_blocks_statef *s;
z_streamp z;
{
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  uInt ml;              /* mask for literal/length tree */
  uInt md;              /* mask for distance tree */
  uInt c;               /* bytes to copy */
  uInt d;               /* distance back to copy from */
  Bytef *r;             /* copy source pointer */

  /* load input, output, bit values */
  LOAD

  /* initialize masks */
  ml = inflate_mask[bl];
  md = inflate_mask[bd];

  /* do until not enough input or output space for fast loop */
  do {                          /* assume called with m >= 258 && n >= 10 */
    /* get literal/length code */
    GRABBITS(20)                /* max bits for literal/length code */
    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
    {
      DUMPBITS(t->bits)
      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                "inflate:         * literal '%c'\n" :
                "inflate:         * literal 0x%02x\n", t->base));
      *q++ = (Byte)t->base;
      m--;
      continue;
    }
    do {
      DUMPBITS(t->bits)
      if (e & 16)
      {
        /* get extra bits for length */
        e &= 15;
        c = t->base + ((uInt)b & inflate_mask[e]);
        DUMPBITS(e)
        Tracevv((stderr, "inflate:         * length %u\n", c));

        /* decode distance base of block to copy */
        GRABBITS(15);           /* max bits for distance code */
        e = (t = td + ((uInt)b & md))->exop;
        do {
          DUMPBITS(t->bits)
          if (e & 16)
          {
            /* get extra bits to add to distance base */
            e &= 15;
            GRABBITS(e)         /* get extra bits (up to 13) */
            d = t->base + ((uInt)b & inflate_mask[e]);
            DUMPBITS(e)
            Tracevv((stderr, "inflate:         * distance %u\n", d));

            /* do the copy */
            m -= c;
            if ((uInt)(q - s->window) >= d)     /* offset before dest */
            {                                   /*  just copy */
              r = q - d;
              *q++ = *r++;  c--;        /* minimum count is three, */
              *q++ = *r++;  c--;        /*  so unroll loop a little */
            }
            else                        /* else offset after destination */
            {
              e = d - (uInt)(q - s->window); /* bytes from offset to end */
              r = s->end - e;           /* pointer to offset */
              if (c > e)                /* if source crosses, */
              {
                c -= e;                 /* copy to end of window */
                do {
                  *q++ = *r++;
                } while (--e);
                r = s->window;          /* copy rest from start of window */
              }
            }
            do {                        /* copy all or what's left */
              *q++ = *r++;
            } while (--c);
            break;
          }
          else if ((e & 64) == 0)
            e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop;
          else
          {
            z->msg = (char*)"invalid distance code";
            UNGRAB
            UPDATE
            return Z_DATA_ERROR;
          }
        } while (1);
        break;
      }
      if ((e & 64) == 0)
      {
        if ((e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop) == 0)
        {
          DUMPBITS(t->bits)
          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                    "inflate:         * literal '%c'\n" :
                    "inflate:         * literal 0x%02x\n", t->base));
          *q++ = (Byte)t->base;
          m--;
          break;
        }
      }
      else if (e & 32)
      {
        Tracevv((stderr, "inflate:         * end of block\n"));
        UNGRAB
        UPDATE
        return Z_STREAM_END;
      }
      else
      {
        z->msg = (char*)"invalid literal/length code";
        UNGRAB
        UPDATE
        return Z_DATA_ERROR;
      }
    } while (1);
  } while (m >= 258 && n >= 10);

  /* not enough input or output--restore pointers and return */
  UNGRAB
  UPDATE
  return Z_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\inftrees.c ===
/* inftrees.c -- generate Huffman trees for efficient decoding
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"

char inflate_copyright[] = " inflate 1.0.4 Copyright 1995-1996 Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */
struct internal_state  {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define base more.Base
#define next more.Next
#define exop word.what.Exop
#define bits word.what.Bits


local int huft_build OF((
    uIntf *,            /* code lengths in bits */
    uInt,               /* number of codes */
    uInt,               /* number of "simple" codes */
    uIntf *,            /* list of base values for non-simple codes */
    uIntf *,            /* list of extra bits for non-simple codes */
    inflate_huft * FAR*,/* result: starting table */
    uIntf *,            /* maximum lookup bits (returns actual) */
    z_streamp ));       /* for zalloc function */

local voidpf falloc OF((
    voidpf,             /* opaque pointer (not used) */
    uInt,               /* number of items */
    uInt));             /* size of item */

/* Tables for deflate from PKZIP's appnote.txt. */
local uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
        /* actually lengths - 2; also see note #13 above about 258 */
local uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 192, 192}; /* 192==invalid */
local uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577};
local uInt cpdext[30] = { /* Extra bits for distance codes */
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13};

/*
   Huffman code decoding is performed using a multi-level table lookup.
   The fastest way to decode is to simply build a lookup table whose
   size is determined by the longest code.  However, the time it takes
   to build this table can also be a factor if the data being decoded
   is not very long.  The most common codes are necessarily the
   shortest codes, so those codes dominate the decoding time, and hence
   the speed.  The idea is you can have a shorter table that decodes the
   shorter, more probable codes, and then point to subsidiary tables for
   the longer codes.  The time it costs to decode the longer codes is
   then traded against the time it takes to make longer tables.

   This results of this trade are in the variables lbits and dbits
   below.  lbits is the number of bits the first level table for literal/
   length codes can decode in one step, and dbits is the same thing for
   the distance codes.  Subsequent tables are also less than or equal to
   those sizes.  These values may be adjusted either when all of the
   codes are shorter than that, in which case the longest code length in
   bits is used, or when the shortest code is *longer* than the requested
   table size, in which case the length of the shortest code in bits is
   used.

   There are two different values for the two tables, since they code a
   different number of possibilities each.  The literal/length table
   codes 286 possible values, or in a flat code, a little over eight
   bits.  The distance table codes 30 possible values, or a little less
   than five bits, flat.  The optimum values for speed end up being
   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
   The optimum values may differ though from machine to machine, and
   possibly even between compilers.  Your mileage may vary.
 */


/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
#define BMAX 15         /* maximum bit length of any code */
#define N_MAX 288       /* maximum number of codes in any set */

#ifdef DEBUG
  uInt inflate_hufts;
#endif

local int huft_build(b, n, s, d, e, t, m, zs)
uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
uInt n;                 /* number of codes (assumed <= N_MAX) */
uInt s;                 /* number of simple-valued codes (0..s-1) */
uIntf *d;               /* list of base values for non-simple codes */
uIntf *e;               /* list of extra bits for non-simple codes */  
inflate_huft * FAR *t;  /* result: starting table */
uIntf *m;               /* maximum lookup bits, returns actual */
z_streamp zs;           /* for zalloc function */
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
   if the given code set is incomplete (the tables are still built in this
   case), Z_DATA_ERROR if the input is invalid (all zero length codes or an
   over-subscribed set of lengths), or Z_MEM_ERROR if not enough memory. */
{

  uInt a;                       /* counter for codes of length k */
  uInt c[BMAX+1];               /* bit length count table */
  uInt f;                       /* i repeats in table every f entries */
  int g;                        /* maximum code length */
  int h;                        /* table level */
  register uInt i;              /* counter, current code */
  register uInt j;              /* counter */
  register int k;               /* number of bits in current code */
  int l;                        /* bits per table (returned in m) */
  register uIntf *p;            /* pointer into c[], b[], or v[] */
  inflate_huft *q;              /* points to current table */
  struct inflate_huft_s r;      /* table entry for structure assignment */
  inflate_huft *u[BMAX];        /* table stack */
  uInt v[N_MAX];                /* values in order of bit length */
  register int w;               /* bits before this table == (l * h) */
  uInt x[BMAX+1];               /* bit offsets, then code stack */
  uIntf *xp;                    /* pointer into x */
  int y;                        /* number of dummy codes added */
  uInt z;                       /* number of entries in current table */


  /* Generate counts for each bit length */
  p = c;
#define C0 *p++ = 0;
#define C2 C0 C0 C0 C0
#define C4 C2 C2 C2 C2
  C4                            /* clear c[]--assume BMAX+1 is 16 */
  p = b;  i = n;
  do {
    c[*p++]++;                  /* assume all entries <= BMAX */
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
  {
    *t = (inflate_huft *)Z_NULL;
    *m = 0;
    return Z_OK;
  }


  /* Find minimum and maximum length, bound *m by those */
  l = *m;
  for (j = 1; j <= BMAX; j++)
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if ((uInt)l < j)
    l = j;
  for (i = BMAX; i; i--)
    if (c[i])
      break;
  g = i;                        /* maximum code length */
  if ((uInt)l > i)
    l = i;
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return Z_DATA_ERROR;
  if ((y -= c[i]) < 0)
    return Z_DATA_ERROR;
  c[i] += y;


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
    *xp++ = (j += *p++);
  }


  /* Make a table of values in order of bit lengths */
  p = b;  i = 0;
  do {
    if ((j = *p++) != 0)
      v[x[j]++] = i;
  } while (++i < n);


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
  w = -l;                       /* bits decoded == (l * h) */
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
  q = (inflate_huft *)Z_NULL;   /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
  {
    a = c[k];
    while (a--)
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l)
      {
        h++;
        w += l;                 /* previous table always l bits */

        /* compute minimum size table less than or equal to l bits */
        z = g - w;
        z = z > (uInt)l ? l : z;        /* table size upper limit */
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          if (j < z)
            while (++j < z)     /* try smaller tables up to z bits */
            {
              if ((f <<= 1) <= *++xp)
                break;          /* enough codes to use up j bits */
              f -= *xp;         /* else deduct codes from patterns */
            }
        }
        z = 1 << j;             /* table entries for j-bit table */

        /* allocate and link in new table */
        if ((q = (inflate_huft *)ZALLOC
             (zs,z + 1,sizeof(inflate_huft))) == Z_NULL)
        {
          if (h)
            inflate_trees_free(u[0], zs);
          return Z_MEM_ERROR;   /* not enough memory */
        }
#ifdef DEBUG
        inflate_hufts += z + 1;
#endif
        *t = q + 1;             /* link to list for huft_free() */
        *(t = &(q->next)) = Z_NULL;
        u[h] = ++q;             /* table starts after link */

        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.bits = (Byte)l;     /* bits to dump before this table */
          r.exop = (Byte)j;     /* bits in this table */
          r.next = q;           /* pointer to this table */
          j = i >> (w - l);     /* (get around Turbo C bug) */
          u[h-1][j] = r;        /* connect to last table */
        }
      }

      /* set up table entry in r */
      r.bits = (Byte)(k - w);
      if (p >= v + n)
        r.exop = 128 + 64;      /* out of values--invalid code */
      else if (*p < s)
      {
        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
        r.base = *p++;          /* simple code is just the value */
      }
      else
      {
        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
        r.base = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
        i ^= j;
      i ^= j;

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
      {
        h--;                    /* don't need to update q */
        w -= l;
      }
    }
  }


  /* Return Z_BUF_ERROR if we were given an incomplete table */
  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
}


int inflate_trees_bits(c, bb, tb, z)
uIntf *c;               /* 19 code lengths */
uIntf *bb;              /* bits tree desired/actual depth */
inflate_huft * FAR *tb; /* bits tree result */
z_streamp z;            /* for zfree function */
{
  int r;

  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL, tb, bb, z);
  if (r == Z_DATA_ERROR)
    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
  else if (r == Z_BUF_ERROR)
  {
    inflate_trees_free(*tb, z);
    z->msg = (char*)"incomplete dynamic bit lengths tree";
    r = Z_DATA_ERROR;
  }
  return r;
}


int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, z)
uInt nl;                /* number of literal/length codes */
uInt nd;                /* number of distance codes */
uIntf *c;               /* that many (total) code lengths */
uIntf *bl;              /* literal desired/actual bit depth */
uIntf *bd;              /* distance desired/actual bit depth */
inflate_huft * FAR *tl; /* literal/length tree result */
inflate_huft * FAR *td; /* distance tree result */
z_streamp z;            /* for zfree function */
{
  int r;

  /* build literal/length tree */
  if ((r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z)) != Z_OK)
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed literal/length tree";
    else if (r == Z_BUF_ERROR)
    {
      inflate_trees_free(*tl, z);
      z->msg = (char*)"incomplete literal/length tree";
      r = Z_DATA_ERROR;
    }
    return r;
  }

  /* build distance tree */
  if ((r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, z)) != Z_OK)
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed literal/length tree";
    else if (r == Z_BUF_ERROR) {
#ifdef PKZIP_BUG_WORKAROUND
      r = Z_OK;
    }
#else
      inflate_trees_free(*td, z);
      z->msg = (char*)"incomplete literal/length tree";
      r = Z_DATA_ERROR;
    }
    inflate_trees_free(*tl, z);
    return r;
#endif
  }

  /* done */
  return Z_OK;
}


/* build fixed tables only once--keep them here */
local int fixed_built = 0;
#define FIXEDH 530      /* number of hufts used by fixed tables */
local inflate_huft fixed_mem[FIXEDH];
local uInt fixed_bl;
local uInt fixed_bd;
local inflate_huft *fixed_tl;
local inflate_huft *fixed_td;


local voidpf falloc(q, n, s)
voidpf q;       /* opaque pointer */
uInt n;         /* number of items */
uInt s;         /* size of item */
{
  Assert(s == sizeof(inflate_huft) && n <= (uInt) *(intf *)q,
         "inflate_trees falloc overflow");
  *(intf *)q -= n+s-s; /* s-s to avoid warning */
  return (voidpf)(fixed_mem + *(intf *)q);
}


int inflate_trees_fixed(bl, bd, tl, td)
uIntf *bl;               /* literal desired/actual bit depth */
uIntf *bd;               /* distance desired/actual bit depth */
inflate_huft * FAR *tl;  /* literal/length tree result */
inflate_huft * FAR *td;  /* distance tree result */
{
  /* build fixed tables if not already (multiple overlapped executions ok) */
  if (!fixed_built)
  {
    int k;              /* temporary variable */
    unsigned c[288];    /* length list for huft_build */
    z_stream z;         /* for falloc function */
    int f = FIXEDH;     /* number of hufts left in fixed_mem */

    /* set up fake z_stream for memory routines */
    z.zalloc = falloc;
    z.zfree = Z_NULL;
    z.opaque = (voidpf)&f;

    /* literal table */
    for (k = 0; k < 144; k++)
      c[k] = 8;
    for (; k < 256; k++)
      c[k] = 9;
    for (; k < 280; k++)
      c[k] = 7;
    for (; k < 288; k++)
      c[k] = 8;
    fixed_bl = 7;
    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl, &z);

    /* distance table */
    for (k = 0; k < 30; k++)
      c[k] = 5;
    fixed_bd = 5;
    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd, &z);

    /* done */
    Assert(f == 0, "invalid build of fixed tables");
    fixed_built = 1;
  }
  *bl = fixed_bl;
  *bd = fixed_bd;
  *tl = fixed_tl;
  *td = fixed_td;
  return Z_OK;
}


int inflate_trees_free(t, z)
inflate_huft *t;        /* table to free */
z_streamp z;            /* for zfree function */
/* Free the malloc'ed tables built by huft_build(), which makes a linked
   list of the tables it made, with the links in a dummy first entry of
   each table. */
{
  register inflate_huft *p, *q, *r;

  /* Reverse linked list */
  p = Z_NULL;
  q = t;
  while (q != Z_NULL)
  {
    r = (q - 1)->next;
    (q - 1)->next = p;
    p = q;
    q = r;
  }
  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  while (p != Z_NULL)
  {
    q = (--p)->next;
    ZFREE(z,p);
    p = q;
  } 
  return Z_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\inflate.c ===
/* inflate.c -- zlib interface to inflate modules
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"

struct inflate_blocks_state {int dummy;}; /* for buggy compilers */

/* inflate private state */
struct internal_state {

  /* mode */
  enum {
      METHOD,   /* waiting for method byte */
      FLAG,     /* waiting for flag byte */
      DICT4,    /* four dictionary check bytes to go */
      DICT3,    /* three dictionary check bytes to go */
      DICT2,    /* two dictionary check bytes to go */
      DICT1,    /* one dictionary check byte to go */
      DICT0,    /* waiting for inflateSetDictionary */
      BLOCKS,   /* decompressing blocks */
      CHECK4,   /* four check bytes to go */
      CHECK3,   /* three check bytes to go */
      CHECK2,   /* two check bytes to go */
      CHECK1,   /* one check byte to go */
      DONE,     /* finished check, done */
      BAD}      /* got an error--stay here */
    mode;               /* current inflate mode */

  /* mode dependent information */
  union {
    uInt method;        /* if FLAGS, method byte */
    struct {
      uLong was;                /* computed check value */
      uLong need;               /* stream check value */
    } check;            /* if CHECK, check values to compare */
    uInt marker;        /* if BAD, inflateSync's marker bytes count */
  } sub;        /* submode */

  /* mode independent information */
  int  nowrap;          /* flag for no wrapper */
  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
  inflate_blocks_statef 
    *blocks;            /* current inflate_blocks state */

};


int inflateReset(z)
z_streamp z;
{
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  z->total_in = z->total_out = 0;
  z->msg = Z_NULL;
  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
  inflate_blocks_reset(z->state->blocks, z, &c);
  Trace((stderr, "inflate: reset\n"));
  return Z_OK;
}


int inflateEnd(z)
z_streamp z;
{
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->blocks != Z_NULL)
    inflate_blocks_free(z->state->blocks, z, &c);
  ZFREE(z, z->state);
  z->state = Z_NULL;
  Trace((stderr, "inflate: end\n"));
  return Z_OK;
}


int inflateInit2_(z, w, version, stream_size)
z_streamp z;
int w;
const char *version;
int stream_size;
{
  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
      stream_size != sizeof(z_stream))
      return Z_VERSION_ERROR;

  /* initialize state */
  if (z == Z_NULL)
    return Z_STREAM_ERROR;
  z->msg = Z_NULL;
  if (z->zalloc == Z_NULL)
  {
    z->zalloc = zcalloc;
    z->opaque = (voidpf)0;
  }
  if (z->zfree == Z_NULL) z->zfree = zcfree;
  if ((z->state = (struct internal_state FAR *)
       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
    return Z_MEM_ERROR;
  z->state->blocks = Z_NULL;

  /* handle undocumented nowrap option (no zlib header or check) */
  z->state->nowrap = 0;
  if (w < 0)
  {
    w = - w;
    z->state->nowrap = 1;
  }

  /* set window size */
  if (w < 8 || w > 15)
  {
    inflateEnd(z);
    return Z_STREAM_ERROR;
  }
  z->state->wbits = (uInt)w;

  /* create inflate_blocks state */
  if ((z->state->blocks =
      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
      == Z_NULL)
  {
    inflateEnd(z);
    return Z_MEM_ERROR;
  }
  Trace((stderr, "inflate: allocated\n"));

  /* reset state */
  inflateReset(z);
  return Z_OK;
}


int inflateInit_(z, version, stream_size)
z_streamp z;
const char *version;
int stream_size;
{
  return inflateInit2_(z, DEF_WBITS, version, stream_size);
}


#define NEEDBYTE {if(z->avail_in==0)return r;r=Z_OK;}
#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)

int inflate(z, f)
z_streamp z;
int f;
{
  int r;
  uInt b;

  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL || f < 0)
    return Z_STREAM_ERROR;
  r = Z_BUF_ERROR;
  while (1) switch (z->state->mode)
  {
    case METHOD:
      NEEDBYTE
      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
      {
        z->state->mode = BAD;
        z->msg = (char*)"unknown compression method";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
      {
        z->state->mode = BAD;
        z->msg = (char*)"invalid window size";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      z->state->mode = FLAG;
    case FLAG:
      NEEDBYTE
      b = NEXTBYTE;
      if (((z->state->sub.method << 8) + b) % 31)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect header check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Trace((stderr, "inflate: zlib header ok\n"));
      if (!(b & PRESET_DICT))
      {
        z->state->mode = BLOCKS;
	break;
      }
      z->state->mode = DICT4;
    case DICT4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = DICT3;
    case DICT3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = DICT2;
    case DICT2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = DICT1;
    case DICT1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;
      z->adler = z->state->sub.check.need;
      z->state->mode = DICT0;
      return Z_NEED_DICT;
    case DICT0:
      z->state->mode = BAD;
      z->msg = (char*)"need dictionary";
      z->state->sub.marker = 0;       /* can try inflateSync */
      return Z_STREAM_ERROR;
    case BLOCKS:
      r = inflate_blocks(z->state->blocks, z, r);
      if (r == Z_DATA_ERROR)
      {
        z->state->mode = BAD;
        z->state->sub.marker = 0;       /* can try inflateSync */
        break;
      }
      if (r != Z_STREAM_END)
        return r;
      r = Z_OK;
      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
      if (z->state->nowrap)
      {
        z->state->mode = DONE;
        break;
      }
      z->state->mode = CHECK4;
    case CHECK4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = CHECK3;
    case CHECK3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = CHECK2;
    case CHECK2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = CHECK1;
    case CHECK1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;

      if (z->state->sub.check.was != z->state->sub.check.need)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect data check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Trace((stderr, "inflate: zlib check ok\n"));
      z->state->mode = DONE;
    case DONE:
      return Z_STREAM_END;
    case BAD:
      return Z_DATA_ERROR;
    default:
      return Z_STREAM_ERROR;
  }
}


int inflateSetDictionary(z, dictionary, dictLength)
z_streamp z;
const Bytef *dictionary;
uInt  dictLength;
{
  uInt length = dictLength;

  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
    return Z_STREAM_ERROR;

  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
  z->adler = 1L;

  if (length >= ((uInt)1<<z->state->wbits))
  {
    length = (1<<z->state->wbits)-1;
    dictionary += dictLength - length;
  }
  inflate_set_dictionary(z->state->blocks, dictionary, length);
  z->state->mode = BLOCKS;
  return Z_OK;
}


int inflateSync(z)
z_streamp z;
{
  uInt n;       /* number of bytes to look at */
  Bytef *p;     /* pointer to bytes */
  uInt m;       /* number of marker bytes found in a row */
  uLong r, w;   /* temporaries to save total_in and total_out */

  /* set up */
  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->mode != BAD)
  {
    z->state->mode = BAD;
    z->state->sub.marker = 0;
  }
  if ((n = z->avail_in) == 0)
    return Z_BUF_ERROR;
  p = z->next_in;
  m = z->state->sub.marker;

  /* search */
  while (n && m < 4)
  {
    if (*p == (Byte)(m < 2 ? 0 : 0xff))
      m++;
    else if (*p)
      m = 0;
    else
      m = 4 - m;
    p++, n--;
  }

  /* restore */
  z->total_in += (unsigned long) (p - z->next_in);		// Win64 cast (JB 2/15/00)
  z->next_in = p;
  z->avail_in = n;
  z->state->sub.marker = m;

  /* return no joy or set up to restart on a new block */
  if (m != 4)
    return Z_DATA_ERROR;
  r = z->total_in;  w = z->total_out;
  inflateReset(z);
  z->total_in = r;  z->total_out = w;
  z->state->mode = BLOCKS;
  return Z_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\inftrees.h ===
/* inftrees.h -- header to use inftrees.c
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* Huffman code lookup table entry--this entry is four bytes for machines
   that have 16-bit pointers (e.g. PC's in the small or medium model). */

typedef struct inflate_huft_s FAR inflate_huft;

struct inflate_huft_s {
  union {
    struct {
      Byte Exop;        /* number of extra bits or operation */
      Byte Bits;        /* number of bits in this code or subcode */
    } what;
    Bytef *pad;         /* pad structure to a power of 2 (4 bytes for */
  } word;               /*  16-bit, 8 bytes for 32-bit machines) */
  union {
    uInt Base;          /* literal, length base, or distance base */
    inflate_huft *Next; /* pointer to next level of table */
  } more;
};

#ifdef DEBUG
  extern uInt inflate_hufts;
#endif

extern int inflate_trees_bits OF((
    uIntf *,                    /* 19 code lengths */
    uIntf *,                    /* bits tree desired/actual depth */
    inflate_huft * FAR *,       /* bits tree result */
    z_streamp ));               /* for zalloc, zfree functions */

extern int inflate_trees_dynamic OF((
    uInt,                       /* number of literal/length codes */
    uInt,                       /* number of distance codes */
    uIntf *,                    /* that many (total) code lengths */
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    inflate_huft * FAR *,       /* literal/length tree result */
    inflate_huft * FAR *,       /* distance tree result */
    z_streamp ));               /* for zalloc, zfree functions */

extern int inflate_trees_fixed OF((
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    inflate_huft * FAR *,       /* literal/length tree result */
    inflate_huft * FAR *));     /* distance tree result */

extern int inflate_trees_free OF((
    inflate_huft *,             /* tables to free */
    z_streamp ));               /* for zfree function */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\infutil.c ===
/* inflate_util.c -- data and routines common to blocks and codes
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"
#include "inftrees.h"
#include "infcodes.h"
#include "infutil.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* And'ing with mask[n] masks the lower n bits */
uInt inflate_mask[17] = {
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};


/* copy as much as possible from the sliding window to the output area */
int inflate_flush(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt n;
  Bytef *p;
  Bytef *q;

  /* local copies of source and destination pointers */
  p = z->next_out;
  q = s->read;

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
  if (n > z->avail_out) n = z->avail_out;
  if (n && r == Z_BUF_ERROR) r = Z_OK;

  /* update counters */
  z->avail_out -= n;
  z->total_out += n;

  /* update check information */
  if (s->checkfn != Z_NULL)
    z->adler = s->check = (*s->checkfn)(s->check, q, n);

  /* copy as far as end of window */
  zmemcpy(p, q, n);
  p += n;
  q += n;

  /* see if more to copy at beginning of window */
  if (q == s->end)
  {
    /* wrap pointers */
    q = s->window;
    if (s->write == s->end)
      s->write = s->window;

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
    if (n > z->avail_out) n = z->avail_out;
    if (n && r == Z_BUF_ERROR) r = Z_OK;

    /* update counters */
    z->avail_out -= n;
    z->total_out += n;

    /* update check information */
    if (s->checkfn != Z_NULL)
      z->adler = s->check = (*s->checkfn)(s->check, q, n);

    /* copy */
    zmemcpy(p, q, n);
    p += n;
    q += n;
  }

  /* update pointers */
  z->next_out = p;
  s->read = q;

  /* done */
  return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\infutil.h ===
/* infutil.h -- types and macros common to blocks and codes
 * Copyright (C) 1995-1996 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

#ifndef _INFUTIL_H
#define _INFUTIL_H

typedef enum {
      TYPE,     /* get type bits (3, including end bit) */
      LENS,     /* get lengths for stored */
      STORED,   /* processing stored block */
      TABLE,    /* get table lengths */
      BTREE,    /* get bit lengths tree for a dynamic block */
      DTREE,    /* get length, distance trees for a dynamic block */
      CODES,    /* processing fixed or dynamic block */
      DRY,      /* output remaining window bytes */
      DONE,     /* finished last block, done */
      BAD}      /* got a data error--stuck here */
inflate_block_mode;

/* inflate blocks semi-private state */
struct inflate_blocks_state {

  /* mode */
  inflate_block_mode  mode;     /* current inflate_block mode */

  /* mode dependent information */
  union {
    uInt left;          /* if STORED, bytes left to copy */
    struct {
      uInt table;               /* table lengths (14 bits) */
      uInt index;               /* index into blens (or border) */
      uIntf *blens;             /* bit lengths of codes */
      uInt bb;                  /* bit length tree depth */
      inflate_huft *tb;         /* bit length decoding tree */
    } trees;            /* if DTREE, decoding info for trees */
    struct {
      inflate_huft *tl;
      inflate_huft *td;         /* trees to free */
      inflate_codes_statef 
         *codes;
    } decode;           /* if CODES, current state */
  } sub;                /* submode */
  uInt last;            /* true if this block is the last block */

  /* mode independent information */
  uInt bitk;            /* bits in bit buffer */
  uLong bitb;           /* bit buffer */
  Bytef *window;        /* sliding window */
  Bytef *end;           /* one byte after sliding window */
  Bytef *read;          /* window read pointer */
  Bytef *write;         /* window write pointer */
  check_func checkfn;   /* check function */
  uLong check;          /* check on output */

};


/* defines for inflate input/output */
/*   update pointers and return */
#define UPDBITS {s->bitb=b;s->bitk=k;}
#define UPDIN {z->avail_in=n;z->total_in+=(unsigned long)(p-z->next_in);z->next_in=p;}	// Win64 cast (JB 2/15/00)
#define UPDOUT {s->write=q;}
#define UPDATE {UPDBITS UPDIN UPDOUT}
#define LEAVE {UPDATE return inflate_flush(s,z,r);}
/*   get bytes and bits */
#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
#define NEXTBYTE (n--,*p++)
#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define DUMPBITS(j) {b>>=(j);k-=(j);}
/*   output bytes */
#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
/*   load local pointers */
#define LOAD {LOADIN LOADOUT}

/* masks for lower bits (size given to avoid warnings with Visual C++) */
extern uInt inflate_mask[17];

/* copy as much as possible from the sliding window to the output area */
extern int inflate_flush OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

struct internal_state      {int dummy;}; /* for buggy compilers */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mstve.rc
//
#define VER_OLESELFREGISTER             1
#define IDR_TVETRIGGER                  102
#define IDR_TVEVARIATION                103
#define IDR_TVEENHANCEMENT              104
#define IDR_TVESERVICE                  105
#define IDR_TVESUPERVISOR               106
#define IDR_TVEEVENT                    107
#define IDR_TVETRACKS                   108
#define IDR_TVEVARIATIONS               109
#define IDR_TVEENHANCEMENTS             110
#define IDR_TVESERVICES                 111
#define IDR_TVETRACK                    112
#define IDR_CTVETRACK                   113
#define IDR_TVEATTRMAP                  116
#define IDR_TVEATTRTIMEQ                117
#define IDR_TVEMCAST                    121
#define IDR_TVEMCASTMANAGER             122
#define IDR_TVEMCASTLIST                123
#define IDR_TVEMCASTS                   124
#define IDR_TVEMCASTSESSIONS            125
#define IDR_TVEMCASTSESSION             126
#define IDR_TVEMCASTCALLBACK            127
#define IDR_TVECBANNC                   128
#define IDR_TVECBTRIG                   129
#define IDR_TVECBFILE                   130
#define IDR_TVECBDUMMY                  131
#define IDR_TVEFILTER                   132
#define IDR_TVEFILE                     133
#define IDR_TVETRIGGERCTRL              134
#define IDR_TVENAVAID                   135
#define IDR_TVEFEATURE                  136
#define IDR_TVESUPERVISORGITPROXY       137
#define IDD_TVEFILTER_TUNEPROPPAGE      200
#define IDD_TVEFILTER_CCPROPPAGE        201
#define IDD_TVEFILTER_STATSPROPPAGE     202
#define IDC_EDIT_IPADDRESS              300
#define IDC_EDIT_STATION                301
#define IDC_TVESTATS_SERVICES           303
#define IDC_TVESTATS_ENHANCEMENTS       304
#define IDC_TVESTATS_PACKAGES           305
#define IDC_TVESTATS_XOVERLINKS         306
#define IDC_TVESTATS_TRIGGERS           307
#define IDC_TVESTATS_FILES              308
#define IDC_TVESTATS_AUXINFO            309
#define IDC_TVESTATS_RESET              310
#define IDC_TVESTATS_TUNES              311
#define IDC_TVESTATS_XOVERLINKSx        312
#define IDC_TVECC_STOPXOVER             313
#define IDC_TVECC_STOP_XOVER            313
#define IDC_TVECC_ANNC_LISTEN           313
#define IDC_TVECC_STOPLISTEN            314
#define IDC_TVECC_STOP_BLISTEN          314
#define IDC_TVECC_XOVER_LISTEN          314
#define IDC_TVECC_STOPDECODE            315
#define IDC_TVECC_STOP_BDECODE          315
#define IDC_TVECC_TRIG_LISTEN           315
#define IDC_LIST_ADDRESSES              316
#define IDC_TVECC_STOP_BPARSE           316
#define IDC_TVECC_DATA_LISTEN           316
#define IDC_TVECC_ANNC_DECODE           317
#define IDC_TVECC_XOVER_DECODE          318
#define IDC_COMBO_IPADDRESS             318
#define IDC_TVECC_TRIG_DECODE           319
#define IDC_TVECC_DATA_DECODE           320
#define IDC_TVECC_ANNC_PARSE            321
#define IDC_TVECC_XOVER_PARSE           322
#define IDC_TVECC_TRIG_PARSE            323
#define IDC_TVECC_DATA_PARSE            324
#define IDC_TVECC_EXPIREQ               325
#define IDC_TVECC_EXTRA                 326
#define IDS_PROJNAME                    1000
#define IDS_TVEFILTERNAME               1001
#define IDS_TVEFILTERPROPNAME           1002
#define IDS_TVEFILTER_TUNEPROPNAME      1002
#define IDS_TVEFILTER_CCPROPNAME        1003
#define IDS_TVEFILTER_STATSPROPNAME     1004
#define IDS_TVETRACK_DESC               1005
#define IDS_AuxInfo_MessageQueueJammed  1005
#define IDS_REG_TVERECEIVER_PROGID      1006
#define IDS_AuxInfo_MessageQueueUnjammed 1006
#define IDS_REG_TVERECEIVER_DESC        1007
#define IDS_AuxInfo_ServiceRemoved      1007
#define IDS_AuxInfo_NoData              1008
#define IDS_AuxInfo_MissingPackets      1009
#define IDS_INVALID_STATE               1010
#define IDS_AuxInfoD_NewPackage         1010
#define IDS_INVALIDCHKSUM               1011
#define IDS_AuxInfoD_GotPacket          1011
#define IDS_INVALIDTrigger              1012
#define IDS_AuxInfo_ReceivedExpiredPackage 1012
#define IDS_INVALIDExpireDate           1013
#define IDS_AuxInfo_CRCInvaild_Dropping 1013
#define IDS_INVALIDURL                  1014
#define IDS_AuxInfo_CRCInvaild_NotDropping 1014
#define IDS_INVALIDName                 1015
#define IDS_AuxInfo_ErrorDecodingMIMEFile 1015
#define IDS_INVALIDExpires              1016
#define IDS_AuxInfo_DeletingVariation   1016
#define IDS_INVALIDScript               1017
#define IDS_INVALIDVersion              1018
#define IDS_INVALIDParsedAlready        1020
#define IDS_INVALIDTVELevel             1021

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        138
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         319
#define _APS_NEXT_SYMED_VALUE           1022
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\mstve.cpp ===
// Copyright (c) 1999,2000,2001  Microsoft Corporation.  All Rights Reserved.
// MSTvE.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for MergePSTest.idl by adding the following
//      files to the Outputs.
//          MSTvE_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f MSTvEps.mk in the project directory.

#include "stdafx.h"

#include "resource.h"
#include <initguid.h>
#include "MSTvE.h"
#include "dlldatax.h"

//#include "MSTvE_i.c"	// GUID definitions now in strmiids.lib

#include "TVEAttrM.h"
#include "TVEAttrQ.h"
#include "TVETrigg.h"
#include "TVETrack.h"
#include "TVEVaria.h"
#include "TVEEnhan.h"
#include "TVEServi.h"
#include "TVESuper.h"
#include "TVEFile.h"

#include "TVETracks.h"
#include "TVEVarias.h"
#include "TVEEnhans.h"
#include "TVEServis.h"

#include "TVEMCast.h"
#include "TVEMCasts.h"
#include "TVEMCMng.h"
#include "TVEMCCback.h"
#include "TVECBAnnc.h"
#include "TVECBTrig.h"
#include "TVECBFile.h"
#include "TVECBDummy.h"

#include "TVEFilt.h"
#include "TVETrigCtrl.h"
#include "TVENavAid.h"
#include "TVEFeature.h"

#include "TVEReg.h"
// ----------------------------------
#include <bdaiface.h>
#include <streams.h>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDLL;
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
// --------------------------------------------------------------------
;;;
// --------------------------------------------------------------------
//   Filter  Setup data  (see tvefilt.cpp)


extern CFactoryTemplate g_Templates[];
extern int g_cTemplates;
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TVETrigger,		CTVETrigger)
OBJECT_ENTRY(CLSID_TVETrack,		CTVETrack)
OBJECT_ENTRY(CLSID_TVEVariation,	CTVEVariation)
OBJECT_ENTRY(CLSID_TVEEnhancement,	CTVEEnhancement)
OBJECT_ENTRY(CLSID_TVEService,		CTVEService)
OBJECT_ENTRY(CLSID_TVESupervisor,	CTVESupervisor)
//OBJECT_ENTRY(CLSID_TVETracks,		CTVETracks)			// iterators and other non-createable classes
//OBJECT_ENTRY_NON_CREATEABLE(CTVETracks)
//OBJECT_ENTRY(CLSID_TVEVariations,	CTVEVariations)
//OBJECT_ENTRY(CLSID_TVEEnhancements, CTVEEnhancements)
//OBJECT_ENTRY(CLSID_TVEServices,	CTVEServices)
OBJECT_ENTRY(CLSID_TVEAttrMap,		CTVEAttrMap)
OBJECT_ENTRY(CLSID_TVEAttrTimeQ,	CTVEAttrTimeQ)

OBJECT_ENTRY(CLSID_TVEMCast,		CTVEMCast)
OBJECT_ENTRY(CLSID_TVEMCastManager, CTVEMCastManager)
//OBJECT_ENTRY(CLSID_TVEMCastCallback, CTVEMCastCallback)
OBJECT_ENTRY(CLSID_TVECBAnnc,		CTVECBAnnc)
OBJECT_ENTRY(CLSID_TVECBTrig,		CTVECBTrig)
OBJECT_ENTRY(CLSID_TVECBFile,		CTVECBFile)
OBJECT_ENTRY(CLSID_TVECBDummy,		CTVECBDummy)

OBJECT_ENTRY(CLSID_TVEFile,			CTVEFile)
//OBJECT_ENTRY(CLSID_TVEFilter,		CTVEFilter)		// this won't work - DShow registration used

OBJECT_ENTRY(CLSID_TVETriggerCtrl,	CTVETriggerCtrl)
OBJECT_ENTRY(CLSID_TVENavAid,		CTVENavAid)
OBJECT_ENTRY(CLSID_TVEFeature,		CTVEFeature)

//OBJECT_ENTRY(CLSID_TVESupervisorGITProxy,	CTVESupervisorGITProxy)

END_OBJECT_MAP()


// ----------------------------------------------------------
//  Rich Error Handling Object
// ----------------------------------------------------------
WCHAR * 
GetTVEError(HRESULT hr, ...)		// returns static string containing error message
{
	va_list arglist;
	va_start(arglist, hr);

	static WCHAR wbuff[1024];
	 HMODULE hMod = GetModuleHandleA("MSTvE.dll");
//	 HMODULE hMod1 = GetModuleHandleA(NULL);

//	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD)hr, 
//				 0L, szFormat, MAX_PATH, NULL);

	if(0 == FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM 
					     | FORMAT_MESSAGE_FROM_HMODULE,
					 hMod, //NULL, //g_hTVESendModule,
					 hr,
					 0, //LANG_NEUTRAL,
					 wbuff,
					 sizeof(wbuff) / sizeof(wbuff[0]) -1,
					 &arglist))
	{
		int err = GetLastError();
		swprintf(wbuff,L"Unknown MSTvE Error 0x%08x (%d)",hr,hr);
	}

	return wbuff;
};
/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);


extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
//BOOL WINAPI _DllMainXXX(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {
         g_hInst = hInstance;
		_Module.Init(ObjectMap, hInstance, &LIBID_MSTvELib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    
	return TRUE;    // was this in TVEContr, was below if TVEFilt
//	return DllEntryPoint(hInstance, dwReason, lpReserved);
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
//  (version already in strmbase.lib)

STDAPI MSTvE_DllCanUnloadNow(void)
{
	HRESULT hr = DllCanUnloadNow();

#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
     if (hr == S_OK) {
        if (_Module.GetLockCount() != 0) {
            hr = S_FALSE;
        }
    }
    return hr;;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
//  (version already in strmbase.lib)


STDAPI MSTvE_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	HRESULT hr;
	hr = DllGetClassObject(rclsid, riid, ppv);
	if(hr == S_OK)
		return hr;

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;
#ifdef _MERGE_PROXYSTUB
	hr = PrxDllRegisterServer();
#endif
	
	if(!FAILED(hr))
		hr = AMovieDllRegisterServer2( TRUE );

    // registers object, typelib and all interfaces in typelib
 	if(!FAILED(hr))
		hr = _Module.RegisterServer(TRUE);		// TRUE meands to do Type Library Marshalling...

	if(!FAILED(hr))
		hr = Initialize_LID_SpoolDir_RegEntry();		// LID cache directory location

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	HRESULT hr;
	HRESULT hrTotal = S_OK;
#ifdef _MERGE_PROXYSTUB
    hr = PrxDllUnregisterServer();
	if(FAILED(hr)) hrTotal = hr;
#endif
    hr = _Module.UnregisterServer(TRUE);
	if(FAILED(hr)) hrTotal = hr;

	hr = AMovieDllRegisterServer2( FALSE );
	if(FAILED(hr)) hrTotal = hr;

	hr = Unregister_LID_SpoolDir_RegEntry();
	if(FAILED(hr)) hrTotal = hr;

	return S_OK;			// return ok no matter what happened...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\mstvecp.h ===
#ifndef _TVECONTRCP_H_
#define _TVECONTRCP_H_

// don't want this #import line defined..
//#import "F:\nt\multimedia\dshow\filters\tve\tvecontr\objd\i386\tvecontr.tlb" raw_interfaces_only, raw_native_types, no_namespace, named_guids	//"Import typelib"



template <class T>
class CProxy_ITVETriggerCtrlEvents : public IConnectionPointImpl<T, &DIID__ITVETriggerCtrlEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
};

template <class T>
class CProxy_ITVEEvents : public IConnectionPointImpl<T, &DIID__ITVEEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_NotifyTVETune(NTUN_Mode tuneMode, ITVEService * pService, BSTR bstrDescription, BSTR bstrIPAdapter)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[3] = tuneMode;
				pvars[2] = pService;
				pvars[1] = bstrDescription;
				pvars[0] = bstrIPAdapter;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(0x835, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVEEnhancementNew(ITVEEnhancement * pEnh)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pEnh;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x836, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVEEnhancementUpdated(ITVEEnhancement * pEnh, LONG lChangedFlags)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pEnh;
				pvars[0] = lChangedFlags;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x837, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVEEnhancementStarting(ITVEEnhancement * pEnh)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pEnh;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x838, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVEEnhancementExpired(ITVEEnhancement * pEnh)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pEnh;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x839, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVETriggerNew(ITVETrigger * pTrigger, LONG fActive)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pTrigger;
				pvars[0] = fActive;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x83a, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVETriggerUpdated(ITVETrigger * pTrigger, LONG fActive, LONG lChangedFlags)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[2] = pTrigger;
				pvars[1] = fActive;
				pvars[0] = lChangedFlags;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x83b, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVETriggerExpired(ITVETrigger * pTrigger, LONG fActive)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pTrigger;
				pvars[0] = fActive;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x83c, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVEPackage(NPKG_Mode engPkgMode, ITVEVariation * pVariation, BSTR bstrUUID, LONG cBytesTotal, LONG cBytesReceived)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[5];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[4] = engPkgMode;
				pvars[3] = pVariation;
				pvars[2] = bstrUUID;
				pvars[1] = cBytesTotal;
				pvars[0] = cBytesReceived;
				DISPPARAMS disp = { pvars, NULL, 5, 0 };
				pDispatch->Invoke(0x83d, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVEFile(NFLE_Mode engFileMode, ITVEVariation * pVariation, BSTR bstrUrlName, BSTR bstrFileName)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[3] = engFileMode;
				pvars[2] = pVariation;
				pvars[1] = bstrUrlName;
				pvars[0] = bstrFileName;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(0x83e, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVEAuxInfo(NWHAT_Mode engAuxInfoMode, BSTR bstrAuxInfoString, LONG lChangedFlags, LONG lErrorLine)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[3] = engAuxInfoMode;
				pvars[2] = bstrAuxInfoString;
				pvars[1] = lChangedFlags;
				pvars[0] = lErrorLine;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(0x83f, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveattrm.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEAttrM.cpp : Implementation of CTVEAttrMap

#include "stdafx.h"
#include "MSTvE.h"

#include "TVEAttrM.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTVEAttrMap

STDMETHODIMP CTVEAttrMap::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEAttrMap
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveattrmap.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEAttrMap.cpp : Implementation of CTVEAttrMap
#include "stdafx.h"
#include "MSTvE.h"

#include "TVEAttrM.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTVEAttrMap

STDMETHODIMP CTVEAttrMap::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEAttrMap
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveattrq.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEAttrQ.cpp : Implementation of CTVEAttrTimeQ

#include "stdafx.h"
#include "MSTvE.h"


//#include "TVEExpireQ.h"

#include "TveAttrQ.h"
#include "TveFile.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CTVEAttrQueue

STDMETHODIMP CTVEAttrTimeQ::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEAttrTimeQ
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

				// calls the TVE class verison of RemoveYourself() by figuring out the class via QI.
				//   Would of been cleaner if based all TVE classes on the same sub-class..  Oh well.

HRESULT CTVEAttrTimeQ::TVERemoveYourself(IUnknown *pUnk)
{
	HRESULT hr;
	if(NULL == pUnk)
		return E_POINTER;

	ITVEService_HelperPtr spServiHelper(pUnk);
	if(spServiHelper) {
		hr = spServiHelper->RemoveYourself();
		return hr;
	}

	ITVEEnhancement_HelperPtr spEnhancementHelper(pUnk);
	if(spEnhancementHelper) {
		hr = spEnhancementHelper->RemoveYourself();
		return hr;
	}

	ITVEVariation_HelperPtr spVariHelper(pUnk);
	if(spVariHelper) {
		hr = spVariHelper->RemoveYourself();
		return hr;
	}

	ITVETrack_HelperPtr spTrackHelper(pUnk);
	if(spTrackHelper) {
		hr = spTrackHelper->RemoveYourself();
		return hr;
	}

	ITVETrigger_HelperPtr spTriggerHelper(pUnk);
	if(spTriggerHelper) {
		hr = spTriggerHelper->RemoveYourself();
		return hr;
	}

	ITVEFilePtr spFile(pUnk);			// Packages are also ITVEFiles with a special bit set.
	if(spFile) {
		hr = spFile->RemoveYourself();
		return hr;
	}

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E2796205_2377_11D3_BF62_00C04F8EC1B5__INCLUDED_)
#define AFX_STDAFX_H__E2796205_2377_11D3_BF62_00C04F8EC1B5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
//#define _ATL_APARTMENT_THREADED
#define _ATL_FREE_THREADED			// 3/20 : pg 365

#ifdef _DEBUG
#ifdef _M_IX86					// must be defined (else fails to link in Win64 debug build)
//#define _ATL_DEBUG_INTERFACES
//#define  ATL_TRACE_LEVEL 5
//#define  ATL_TRACE_CATEGORY 
#endif
#endif


#include <winsock2.h>				// seems to be needed when compiling under bogus NTC environment
#include <atlbase.h>
//#include "MyAtlBase.h"			// caution - JB code only.. Use atlbase.h for real code

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

#include "valid.h"
		
const int WM_TVEPACKET_EVENT        = (WM_USER + 0x69 + 0);	// event used for packets from reader threads to queue thread
const int WM_TVETIMER_EVENT         = (WM_USER + 0x69 + 1);	// event used for timer events to the queue thread (to expire stuff)
const int WM_TVEKILLMCAST_EVENT     = (WM_USER + 0x69 + 3);	// event used for kill a MCast object via the queue thread
const int WM_TVEKILLQTHREAD_EVENT   = (WM_USER + 0x69 + 4);	// event used for kill the queue thread
const int WM_TVELAST_EVENT          = (WM_USER + 0x69 + 4);


const DATE kDateMax = ((9999-1900)*365.25);		// a really huge date...

#include "MSTveMsg.h"							// error message strings (gen'ed from MSTvEmsg.mc)
WCHAR * GetTVEError(HRESULT hr, ...);			//  Extended Error Message Handler

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E2796205_2377_11D3_BF62_00C04F8EC1B5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveattrq.h ===
// Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.
// TVEAttrQ.h : Declaration of the CTVEAttrTimeQ
//
//		A Date (key) to IUnknown (value) Queue
//			This class contains a List of <date, IUnknown> pairs, sorted
//			in increasing date.  Used to implement an expire queue.
//
//			This supports a threadsafe standard enumerator, which returns values in the list
//			in order of increasing dates.
//
//	Was templated - supports types of:
//		TVal	- DATE
//		TKey	- IUnknown *
//
//	This supports the interface members of:
//
//		get_Count(long *plCount)
//				Returns number of elements in this collection.
//
//		get__NewEnum(IUnknown **ppunk)
//				Returns a standard, threadsafe enumerator to this collecion.  (It copies the whole
//				list).
//
//		get_Item(VARIANT var, TVal *pT )
//				Supported input variant types are dates (R8's) and integer values.  If of DATE type, 
//				then it returns the value (IUNknown*) of the >first< element with an earlier date,
//				or NULL/E_INVALIDARG if no such dates exist. 
//				If integer, returns the n'th item's value (in increasing date order). 
//				This method returns S_OK if success, and E_INVALIDARG if no item is of an earlier 
//				date exists, or some index isn't in the collection.   
//				(To get rid of all items earlier than the one specified (in var), call get_Item repeatedly 
//				until it returns false.)
//				Returns an AddRef'ed item, it is the responsibility of the user to free it.
//
//		get_Key(VARIANT var, TKey *pT) VT_R8
//				This does reverse lookup, returning the key (DATE) assoicated with a given IUnknown.
//				Supported var variant types are IUnknown Ptr's (VT_UNKNOWN) and integer values.  
//				If of IUnknown type, then it returns the key (date) whose IUnknown matches
//				that passed in. If numeric, returns the n'th item's key (DATE) (in 
//				increasing date order).   This returns S_OK if success, 
//				and E_INVALIDARG if the item with the specifed IUnknown (or index) 
//				isn't in the collection. 
//  
//		Add(TKey rKey, TVal rVal)		
//				Adds a new <key,value> (<DATE,IUnknown*>) pair to the queue.  
//				It is inserted in to the list in order of increasing date.
//				The item is Addref'ed when it is added...
//
//		Remove(VARIANT varIn)
//				If varIn is of type DATE (or VT_R8) removes all items up to and equal that
//				date.  (If nothing to remove, it returns ).
//				If it's an IUnknown, removes (the first) item with that value.   
//				Finally, if varIn is a number
//				Otherwise removes the n'th element (date order) if it's numeric. 
//				Releases the item as it's being removed.
//				It returns E_INVALIDARG if the item isn't there to remove.
//
//		RemoveAll()
//				Removes (and releases) all elements in the collection (just what did you expect?)
//
//		DumpToBSTR(BSTR *)
//				PrettyPrints queue to a BSTR, which can be displayed someplace.  Useful for
//				debbuging.
//
//	local methods
//
//
//		Item(VARIANT var, TVal *pT)
//		Key(VARIANT var, TKey *pK)
//			return the given value/first-key given the associated key/value or 
//			an index into the queue
//
//		ItemIterDateGT(DATE dateTest, QueueT::iterator &iIter)
//			Returns Iter to the first element with a date greater than the given one (or end() and
//		    S_FALSE if there are none).  Used in inserting into date-sorted order (Add method)
//
//		ItemIterDateLE(DATE dateTest, QueueT::iterator &iIter)
//			Returns Iter to the first element with a date less than or equal to the given one 
//		    (or begin() and E_INVALIDARG if there are none).  Used when removing items (Item method).
//
//		ItemIter(VARIANT varIn, QueueT::iterator &iIter)
//			If date, act's like ItemIterDateLE (use for removes).
//			If IUnknown, returns item with given Key.
//			If numeric, returns the n'th item.
//
//		CheckSortOrder(BOOL fResort)
//			Testing routine.  Returns S_TRUE if the queue is sorted in the correct order.
//			Retuns S_FALSE if not.  In this later case, if fResort is true, it resorts
//			the list into order of increasing date.
//
//
//	  Implementation notes.
//	
//			This queue is implemented as a simple STL list.  Add Querys are done with a 
//			linear search. Hence insertion (Add) is O(N).  
//			On the other hand, the query for removal (Item) only checks the first element
//			in the list.  Hence most tests and removal is O(1).
// -------------------------------------------------------------------------------------------
#ifndef __TVEATTRQ_H_
#define __TVEATTRQ_H_

#include "resource.h"       // main symbols
#include "..\Common\isotime.h"
#include "TveSmartLock.h"

#include <list>					// std List class
#include <vector>
#include <map>



_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,		__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,	__uuidof(ITVEEnhancement_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEVariation_Helper,		__uuidof(ITVEVariation_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrack,				__uuidof(ITVETrack));
_COM_SMARTPTR_TYPEDEF(ITVETrack_Helper,			__uuidof(ITVETrack_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,				__uuidof(ITVETrigger));
_COM_SMARTPTR_TYPEDEF(ITVETrigger_Helper,		__uuidof(ITVETrigger_Helper));

_COM_SMARTPTR_TYPEDEF(ITVEFile,					__uuidof(ITVEFile));


// --------------------------------------------------------------------
//  IEnumVARIANT version
// ---------------------------------------------------------------------
class CSafeEnumTVETimeQ :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_MSTvELib>
{

	typedef DATE							TKey;
	typedef IUnknown*						TVal;
	typedef	ITVEAttrTimeQ					BaseT;

	typedef std::pair<TKey, TVal>			PairT;				
	typedef std::list<PairT>				TimeQT;				
		
	typedef CSafeEnumTVETimeQ				ThisClassSETQTVE;

public:
	CSafeEnumTVETimeQ()
	{
		m_punk		= NULL;
		m_iIterCur	= m_TimeQT.begin();
		m_iCur		= 0;
	}

	~CSafeEnumTVETimeQ()  
	{
	}

	void FinalRelease()
	{
		m_TimeQT.clear();

		if (m_punk != NULL)
			m_punk->Release();
	}

	void Init(IUnknown *punk, TimeQT *pmapT)		// change to const TimeQT &rmapT???
	{
		if (m_punk != NULL)
		{
			m_punk->Release();
			m_punk = NULL;
		}

		if(NULL == pmapT) return;		// bogus!!!

		if (punk != NULL)				// back pointer to containing class
		{
//			punk->AddRef();
//			m_punk = punk;
		}
		
								// copy the whole map (this is slow but safe!)
		EnterCriticalSection(&_Module.m_csTypeInfoHolder);
		{	
//			m_TimeQT = *pmapT;					// wonder if this will work?
			TimeQT::iterator iIter;
			for(iIter = pmapT->begin(); iIter != pmapT->end(); iIter++)
			{
				TKey   key = (*iIter).first;  
				TVal   val = (*iIter).second;
				
				PairT	p(key,val);			
			//	ListT::value_type keyval(key, val);
				m_TimeQT.push_back(p);
				
			}
		}	
		LeaveCriticalSection(&_Module.m_csTypeInfoHolder);

		m_iCur = 0;
		m_iIterCur = m_TimeQT.begin();
	}

BEGIN_COM_MAP(ThisClassSETQTVE)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

	// IEnumUnknown interface  -- get the next celt elements
	STDMETHOD(Next)(ULONG celt, VARIANT *pvar, ULONG *pceltFetched)
		{
		ENTER_API
			{
			ULONG celtFetched = 0;
			int iMax = m_TimeQT.size();

			if ((pvar == NULL) || ((celt > 1) && (pceltFetched == NULL)))
				return E_POINTER;
			
			for (ULONG l=0; l < celt; l++)
				VariantInit( &pvar[l] ) ;

			while ((m_iCur < iMax) && (celtFetched < celt))
			{
				TKey tvK = (*m_iIterCur).first;
				TVal tvT = (*m_iIterCur).second;		

							// stuff into a variant...
				CComVariant *pcvvar = (CComVariant *) pvar;
				*pcvvar = tvT;

				pvar++;
				celtFetched++;
				m_iIterCur++;	m_iCur++;
			}
			
			if (pceltFetched != NULL)
				*pceltFetched = celtFetched;
			
			return (celtFetched == celt) ? S_OK : S_FALSE;
			}
		EXIT_API
		}
	
	STDMETHOD(Skip)(ULONG celt)
		{
		ENTER_API
			{
				m_iCur += celt;
			
				if(m_iCur < m_TimeQT.size())
				{
					for(int i = 0; i < celt; i++)
						m_iIterCur++;
					return S_OK;
				} else {
					m_iIterCur = m_TimeQT.end();
					return S_FALSE;
				}
			}
		EXIT_API
		}
	
	STDMETHOD(Reset)(void)
		{
		ENTER_API
			{
				m_iCur = 0;
				m_iIterCur = m_TimeQT.begin();
				return S_OK;
			}
		EXIT_API
		}
	
	STDMETHOD(Clone)(IEnumVARIANT **ppenum)
		{
		ENTER_API
			{
				static char THIS_FILE[] = __FILE__;	// for debug version of NewComObject
				ThisClassSETQTVE *penum = NewComObject(ThisClassSETQTVE);

				if (penum == NULL)
					return E_OUTOFMEMORY;

				penum->Init(m_punk, &m_TimeQT);
				penum->m_iCur = m_iCur;
				for(int i = 0; i < m_iCur; i++)
					penum->m_iIterCur++;

				HRESULT hr = penum->QueryInterface(IID_IEnumVARIANT, (void **)ppenum);
				if(!FAILED(hr)) 
					penum->Release();
				return hr;
			}
		EXIT_API
		}

protected:
	IUnknown		*m_punk;			// back pointer to map class, to keep it alive
	TimeQT			m_TimeQT;				// complete copy of the map, not pointer!
	TimeQT::iterator	m_iIterCur;			// actual iterator into m_TimeQT  -- keep these 2 in sync --
	int				m_iCur;				// index of location into map   -- keep these 2 in sync --
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTVEAttrTimeQ
class ATL_NO_VTABLE CTVEAttrTimeQ :  
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTVEAttrTimeQ, &CLSID_TVEAttrTimeQ>,
//	public TVETimeQ<DATE, IUnknown *, ITVEAttrTimeQ>,
	public ISupportErrorInfo,
	public IDispatchImpl<ITVEAttrTimeQ, &IID_ITVEAttrTimeQ, &LIBID_MSTvELib>
{
	typedef DATE							TKey;
	typedef IUnknown *						TVal;

	typedef	ITVEAttrTimeQ					BaseT;
	typedef CTVEAttrTimeQ					ThisClassTVEATQ; 

	typedef	std::pair<TKey, TVal>			PairT;		
	typedef std::list<PairT>				TimeQT;
	typedef CSafeEnumTVETimeQ				EnumTVETimeQT;
				

	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
	DECLARE_REGISTRY_RESOURCEID(IDR_TVEATTRTIMEQ)
	DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVEAttrTimeQ)
	COM_INTERFACE_ENTRY(ITVEAttrTimeQ)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

public:
	CTVEAttrTimeQ()
	{
	}
	
	~CTVEAttrTimeQ()
	{
		RemoveAll();
	}
	
	
	virtual BOOL FOkToRemove()
	{
		return TRUE;
	}
	

	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
	{
		ENTER_API
		{
			HRESULT hr;
			ValidateOutPtr<IUnknown *>(ppunk, NULL);

			static char THIS_FILE[] = __FILE__;	// for debug version of NewComObject
			EnumTVETimeQT *penum = NewComObject(EnumTVETimeQT);
			if (penum == NULL)
				return E_OUTOFMEMORY;
			
			penum->Init((IUnknown *)(BaseT *)this, &m_TimeQT);

//			hr =  penum->QueryInterface(IID_IEnumString, (void **)ppunk);
			hr =  penum->QueryInterface(IID_IEnumVARIANT, (void **)ppunk);
			penum->Release();			// need this...
			return hr;
		}
		EXIT_API
	}
	
	STDMETHOD(get_Count)(long *plCount)
	{
		ENTER_API
		{
			CSmartLock spLock(&m_sLk, ReadLock);

			ValidateOutPtr<long>(plCount, NULL);
			
			*plCount = m_TimeQT.size();
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(DATE dateExpires, TVal *pT )			// returns <first> element in queue < dateExpires
	{
		ENTER_API
		{	
			ValidateOutPtr<TVal>(pT, NULL);
			CSmartLock spLock(&m_sLk, ReadLock);

			TimeQT::iterator iterFind = m_TimeQT.begin(); 
			if(iterFind != m_TimeQT.end()) 
			{
				DATE dateItem  = (*iterFind).first;
				IUnknown *pUnk = (*iterFind).second;
				if(dateItem < dateExpires) {			// found one...
					*pT = pUnk;
					(*pT)->AddRef();
					return S_OK;
				}

			} else {
				return E_INVALIDARG;
			}
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(VARIANT varKey, TVal *pT )
	{
		CSmartLock spLock(&m_sLk, ReadLock);
		return Item(varKey, pT);				// all inline, error handling down lower...
	}

	STDMETHOD(get_Key)(VARIANT varValue, TKey *pK )
	{
		ENTER_API
		{
			ValidateOutPtr<TKey>(pK, NULL);

			TimeQT::iterator iIter;					// could really mess up if wrong input type
			CSmartLock spLock(&m_sLk, ReadLock);

			HRESULT hr = ItemIter(varValue, iIter);	// (but oh well!)
			if(S_OK != hr) 
				return hr;
			*pK = (*iIter).first;
			return S_OK;
		}
		EXIT_API
	}

	STDMETHOD(Add)(TKey rKey, TVal rVal)		// can have multiple keys of same value...
	{
		ENTER_API
		{
			HRESULT hr;
			TimeQT::iterator iIter;	
			CSmartLock spLock(&m_sLk, ReadLock);

			TimeQT::value_type keyval(rKey, rVal);

			hr = ItemIterDateGT(rKey, iIter);
			
			spLock.ConvertToWrite();

			if(S_FALSE == hr)					// greater than all dates, add at end
				m_TimeQT.push_back(keyval);
			else 
			{
				//iIter--;						// back up to right before this one
				m_TimeQT.insert(iIter, keyval);
			}
			if(rVal)
				rVal->AddRef();					// NEW - not using Smart pointers here, but we want ref-counts in collection

			return S_OK;
		}
		EXIT_API
	}
							// update IUnknown (rVal) with new Date...
	STDMETHOD(Update)(TKey rKey, TVal rVal)		
	{
		ENTER_API
		{
			HRESULT hr;
			TimeQT::iterator iIter;
		
			CSmartLock spLock(&m_sLk, ReadLock);
			
			for(iIter = m_TimeQT.begin(); iIter != m_TimeQT.end(); iIter++)
			{
				if(rVal == (*iIter).second)
					break;
			}
			if(rVal)
				rVal->AddRef();						// wether new or not, addref it. (If dupped, we release it below.)
													//  we're going to push it into the list in the next step

			spLock.ConvertToWrite();

			if(iIter != m_TimeQT.end())				// temporally remove the item from the queue.
			{
				if((*iIter).second)					// release this item... (maybe transfer as optimization?
					((*iIter).second)->Release();
				(*iIter).second = NULL;			
				m_TimeQT.erase(iIter);				// not don't have smart objects in class, so this doesn't do release
			}

													// now insert it back into it's new location
			TimeQT::value_type keyval(rKey, rVal);		// (this code stolen from Add above, but no AddRef()

			hr = ItemIterDateGT(rKey, iIter);		// find the location...	
			if(S_FALSE == hr)						// greater than all dates, add at end
				m_TimeQT.push_back(keyval);
			else 
			{
				m_TimeQT.insert(iIter, keyval);		// add it here...
			}

		}
		EXIT_API
	}

	STDMETHOD(LockRead)()
	{
		m_sLk.lockR_();
		return S_OK;
	}

	STDMETHOD(LockWrite)()
	{
		m_sLk.lockW_();
		return S_OK;
	}

	STDMETHOD(Unlock)()
	{
		if(0 == m_sLk.lockCount_())
			return S_FALSE;

		m_sLk.unlock_();
		return S_OK;
	}

	HRESULT TVERemoveYourself(IUnknown *pUnk);		// determines what kind of TVE Class it is, and removes it

	typedef IUnknown*	LPUNK;

	STDMETHOD(Remove)(VARIANT varIn)
	{
		ENTER_API
		{

			CComVariant var(varIn);
			switch (var.vt)
			{
			case VT_EMPTY:
				return E_INVALIDARG;

			case VT_DATE:		// removes all items up to and including this date
			case VT_R8:
				{
					var.ChangeType(VT_DATE);			// blow up perhaps if wrong casting
					DATE dateTest = varIn.date;
					int iRemove = 0;
					LPUNK *rgUnks = NULL;

					{									// scope just for locking...
						CSmartLock spLock(&m_sLk, ReadLock);

						TimeQT::iterator iIter;				// count number of items to remove
						for(iIter = m_TimeQT.begin(); iIter != m_TimeQT.end(); iIter++)
						{
							DATE dateItem = (*iIter).first;		// items sorted, just count how many
							if(dateItem > dateTest) 
								break;
							iRemove++;
						}

						if(iRemove == 0)
							return E_INVALIDARG;

						if(iRemove > 0)						// if any items to remove, copy them into a new list
						{									//    and delete refernces from current list
							int i = 0;
							rgUnks = new LPUNK[iRemove];	// temp space to hold these guys (should do a heap alloc instead for speed)
							if(NULL == rgUnks)
								return E_OUTOFMEMORY;

															// copy into the new list
							for(iIter = m_TimeQT.begin(); iIter != m_TimeQT.end(); iIter++)
							{
								rgUnks[i++] = (*iIter).second;
								if(i >= iRemove) 
									break;
							}						

							spLock.ConvertToWrite();			// convert lock to write lock

							for(i = 0; i < iRemove; i++) {	// delete out of the internal list
								m_TimeQT.pop_front();
							}
						}
					}			// end of Lock scope - release the write lock

					for(int i = 0; i < iRemove; i++) {				// now clear the objects
						TVERemoveYourself(rgUnks[i]);			//  -- this fires events (don't do in a lock!)
						rgUnks[i]->Release();
					}

					if(rgUnks)
						delete [] rgUnks;
				} 
				return S_OK;
				break;

			default:				// slight different that above, since this only removes 1 object (by iter)
				{					//   and the above erase removes all keys with the same name
					TimeQT::iterator iIter;
					HRESULT hr = S_OK;
			//		IUnknown	*pUnk = NULL;		bug 322453 fix (also changed pUnk's to spUnks below)
					IUnknownPtr spUnk;

					{
						CSmartLock spLock(&m_sLk, ReadLock);
						hr = ItemIter(var, iIter);					// locate the item
						if(S_OK == hr) 
						{

							spUnk = (*iIter).second;					// new Addref'ed pointer to item
							if((*iIter).second)							// release this item... (maybe transfer as optimization?
								((*iIter).second)->Release();
							(*iIter).second = NULL;	

							m_TimeQT.erase(iIter);						// erase out of the elist...
						} else {
							return E_INVALIDARG;						// if didn't find it return E_INVAIDARG
						}
					}

					if(spUnk) {
						TVERemoveYourself(spUnk);				// This fires an event off.... Do after modifying the list
						spUnk = NULL;							//     -- don't do it inside a lock!
					}
				}
				return S_OK;				// things deleted OK
				break;
			}					// end switch
			return E_FAIL;		// should never get here...
		}
		EXIT_API
	}
	
				// Exact same code as above, but TVERemoveYourself code commented out
				//    Used when fake a Start item in the expire queue...
	STDMETHOD(RemoveSimple)(VARIANT varIn)
	{
		ENTER_API
		{

			CComVariant var(varIn);
			switch (var.vt)
			{
			case VT_EMPTY:
				return E_INVALIDARG;

			case VT_DATE:		// removes all items up to and including this date
			case VT_R8:
				{
					var.ChangeType(VT_DATE);			// blow up perhaps if wrong casting
					DATE dateTest = varIn.date;
					int iRemove = 0;
					LPUNK *rgUnks = NULL;

					{									// scope just for locking...
						CSmartLock spLock(&m_sLk, ReadLock);

						TimeQT::iterator iIter;				// count number of items to remove
						for(iIter = m_TimeQT.begin(); iIter != m_TimeQT.end(); iIter++)
						{
							DATE dateItem = (*iIter).first;		// items sorted, just count how many
							if(dateItem > dateTest) 
								break;
							iRemove++;
						}

						if(iRemove == 0)
							return E_INVALIDARG;

						if(iRemove > 0)						// if any items to remove, copy them into a new list
						{									//    and delete refernces from current list
							int i = 0;
							rgUnks = new LPUNK[iRemove];	// temp space to hold these guys (should do a heap alloc instead for speed)
							if(NULL == rgUnks)
								return E_OUTOFMEMORY;

															// copy into the new list
							for(iIter = m_TimeQT.begin(); iIter != m_TimeQT.end(); iIter++)
							{
								rgUnks[i++] = (*iIter).second;
								if(i >= iRemove)
									break;
							}						

							spLock.ConvertToWrite();			// convert lock to write lock

							for(i = 0; i < iRemove; i++) {	// delete out of the internal list
								m_TimeQT.pop_front();
							}
						}
					}			// end of Lock scope - release the write lock

					for(int i = 0; i < iRemove; i++) {				// now clear the objects
				//		TVERemoveYourself(rgUnks[i]);			//  -- this fires events (don't do in a lock!)
						rgUnks[i]->Release();
					}

					if(rgUnks)
						delete [] rgUnks;
				} 
				return S_OK;
				break;

			default:				// slight different that above, since this only removes 1 object (by iter)
				{					//   and the above erase removes all keys with the same name
					TimeQT::iterator iIter;
					HRESULT hr = S_OK;
					IUnknown *pUnk = NULL;

					{
						CSmartLock spLock(&m_sLk, ReadLock);
						hr = ItemIter(var, iIter);					// locate the item
						if(S_OK == hr) 
						{

							pUnk = (*iIter).second;
							if((*iIter).second)							// release this item...
								((*iIter).second)->Release();
							(*iIter).second = NULL;	


							m_TimeQT.erase(iIter);						// erase out of the elist...
						} else {
							return E_INVALIDARG;
						}
					}

					if(pUnk) {
				//		TVERemoveYourself(pUnk);				// This fires an event off.... Do after modifying the list
						pUnk->Release();						//     -- don't do it inside a lock!
					}
				}
				return S_OK;
				break;
			}					// end switch
		return E_FAIL;			// should never get here...
		}
		EXIT_API
	}

	STDMETHOD(RemoveAll)()
	{
								// semi-nasty case.  Need to empty out the collection
		ENTER_API				//   before we go releasing each object, since some of the object's
		{						//   release code will again try to remove themselves from the ExpireQueue.
								//   
			LPUNK *rgUnks = NULL;

			int cRemove = 0;

			{
				CSmartLock spLock(&m_sLk, ReadLock);

				TimeQT::iterator iIter;
	
									// first thing we want to do is copy the queue over
				cRemove = m_TimeQT.size();
				if(cRemove > 0)
				{
					rgUnks = new LPUNK[cRemove];		// temp space to hold these guys (should do a heap alloc instead for speed)
					if(NULL == rgUnks)
						return E_OUTOFMEMORY;

					TimeQT::iterator iIter;			
					int iRemove = 0;
					for(iIter = m_TimeQT.begin(); iIter != m_TimeQT.end(); iIter++)
					{
						rgUnks[iRemove++] = (*iIter).second;		// copy them over
						(*iIter).second = NULL;
					}

					spLock.ConvertToWrite();			// convert lock to write lock

					m_TimeQT.clear();					// delete items offthe internal list
				}
			}											// lock now gone

								// now go and release the internal objects
			for(int i = 0; i < cRemove; i++)
			{
				IUnknown *pUnk = rgUnks[i];
				pUnk->Release();						// remember, this may recurse back to this method	
			}
			
			if(rgUnks)										// womp our temp array
				delete [] rgUnks;

			return S_OK;
		}
		EXIT_API

	}

	STDMETHOD(Item)(VARIANT varKey, TVal *pT)				// given date or index, return IUnknown*
	{
		ENTER_API
		{
			ValidateOutPtr<TVal>(pT, NULL);
			CSmartLock spLock(&m_sLk, ReadLock);

			TimeQT::iterator iIter;
			HRESULT hr = ItemIter(varKey, iIter);
			if(S_OK == hr) {
				TKey key	  = (*iIter).first;
				TVal punkItem = (*iIter).second;			// creates new copy of the value
				if(punkItem)
					(punkItem)->AddRef();					// watch this?
				*pT = punkItem;
			} else {
				return E_INVALIDARG;						// counln't find it
			}
			return S_OK;
		}
		EXIT_API
	}

								// Local routine to set iter to 
								//   first item to first date less than
								//   specified.   
								//   Usually returns iter to begining of queue.
								//   If no items earlier, returns S_FALSE and iter.begin()
	HRESULT ItemIterDateLE(DATE dateTest, TimeQT::iterator &iIter)
	{
		TimeQT::iterator iter;
		for(iIter = m_TimeQT.begin(); iIter != m_TimeQT.end(); iIter++)
		{
			DATE dateItem = ((*iIter).first);

			if(dateItem <= dateTest )			// found it
				return S_OK;
			else 
			{
				iIter = m_TimeQT.end();		// nothing newer than date (SORT TEST)
				return S_FALSE;
			}
		
		}
		iIter = m_TimeQT.begin();
		return S_OK;
	}

								// local routine to set iter to
								//  first item with date greater than 
								//  the test date.  Usually
								//  returns iter in middle of queue, or S_FALSE
								//  if 
	HRESULT ItemIterDateGT(DATE dateTest, TimeQT::iterator &iIter)
	{
		TimeQT::iterator iter;
		for(iIter = m_TimeQT.begin(); iIter != m_TimeQT.end(); iIter++)
		{
			DATE dateItem = ((*iIter).first);

			if(dateItem > dateTest)		// found it
				return S_OK;
		
		}
		iIter = m_TimeQT.end();
		return S_FALSE;
	}
	
							// local routine to set iter to given item
	HRESULT ItemIter(VARIANT varIn, TimeQT::iterator &iIter)
	{
		CComVariant var(varIn);
		int index;

		switch (varIn.vt)
		{
		case VT_EMPTY:
			return E_INVALIDARG;

		case VT_DATE:			// only works for DATE type keys
		case VT_R8:
			{
				var.ChangeType(VT_DATE);			// blow up perhaps if wrong casting
			
				DATE dateTest = var.date;
				return ItemIterDateLE(dateTest, iIter);		
			}
			break;

		case VT_UNKNOWN:
		case VT_DISPATCH:
			{
				IUnknown *pUnkTest = var.punkVal;
				IUnknownPtr spUnkTest(pUnkTest);	

				for(iIter = m_TimeQT.begin(); iIter != m_TimeQT.end(); iIter++) 
				{
					IUnknown *pUnkItem = (*iIter).second;
					if(pUnkItem == pUnkTest)
						return S_OK;
					IUnknownPtr spUnkItem(pUnkItem);		// QI to IUnknown just to be safe		
					if(spUnkTest == spUnkItem)
						return S_OK;
				}
			}
			return E_INVALIDARG;
			break;
		default:
			{
				var.ChangeType(VT_I4);
				index = var.lVal;


				if(index < 0 || index >= m_TimeQT.size())
					return E_INVALIDARG;

				// use iterator here to get n'th value  (slow, but hey... better than nothing)
				for(iIter = m_TimeQT.begin(); 
					 index > 0 /*&& iter != m_TimeQT.end()*/; 
					--index, iIter++)
					{
						;
					}
				return S_OK;
			}
			break;
		}					// end switch
		return E_FAIL;		// should never get here...
	}						// end function

	


	STDMETHOD(DumpToBSTR)(BSTR *pBstrBuff)			// should be in a _helper interface
	{
		const int kMaxChars=256;
		TCHAR tBuff[kMaxChars];
		CComBSTR bstrOut;
		bstrOut.Empty();

		CSmartLock spLock(&m_sLk, ReadLock);

		if(S_FALSE == CheckSortOrder(false))
		{
			bstrOut.Append(_T("*** Error : Bad Sort Order ***\n"));
		}
		
		TimeQT::iterator iIter;
		int i = 0;
//		bstrOut.Append("{");
		for(iIter = m_TimeQT.begin(); iIter != m_TimeQT.end(); iIter++, i++)
		{
			if(i != 0) { _stprintf(tBuff,_T(",\n")); bstrOut.Append(tBuff); }
			DATE dateItem = (*iIter).first;
			IUnknown *punkItem = (*iIter).second;

			_stprintf(tBuff,_T("%3d  %s : 0x%08x "),i, DateToBSTR(dateItem),punkItem);
			bstrOut.Append(tBuff);
		}
		bstrOut.Append(_T("\n"));
//		bstrOut.Append("}");
		bstrOut.CopyTo(pBstrBuff);


		return S_OK;
	}

	STDMETHOD(CheckSortOrder)(BOOL fReSort)
	{
		HRESULT hr = S_OK;
		TimeQT::iterator iIter;
		CSmartLock spLock(&m_sLk, ReadLock);
		
		int iFirstFail=0;										// check to see if out of order
		DATE dateTest = -1e8;
		int i=0;
		for(iIter = m_TimeQT.begin();  iIter != m_TimeQT.end(); iIter++, i++)
		{
			DATE dateItem = (*iIter).first;
			if(dateItem < dateTest) {
				iFirstFail = i;
				hr = S_FALSE;
			}
			dateTest = dateItem;
		}
		if(S_FALSE == hr && fReSort) {				// slow bubble sort	- is there an STL sort I can use?
			spLock.ConvertToWrite();
			for(iIter = m_TimeQT.begin();  iIter != m_TimeQT.end(); iIter++)
			{
				TimeQT::iterator iIter2 = iIter;
				iIter2++;
				for(; iIter2 != m_TimeQT.end(); iIter2++)
				{
					DATE dateItem1 = (*iIter).first;
					DATE dateItem2 = (*iIter2).first;
					if(dateItem2 < dateItem1) {
						IUnknown *punkT = (*iIter).second;
						(*iIter).second = (*iIter2).second;
						(*iIter2).second = punkT;

						(*iIter).first = dateItem2;
						(*iIter2).first = dateItem1;
					}
				}
			}											
		}
		return hr;
	}

	TimeQT	m_TimeQT;							// base collection object..

private:
	CTVESmartLock		m_sLk;
};



#endif __TVEATTRQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveattrm.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEAttrM.h : Declaration of the CTVEAttrMap
//
//		A BSTR (key) to BSTR (value) map
//			This class maps keys to values, where both keys and values are BSTRs.
//			The keys must be unique, (adding duplicate keys either returns S_FALSE
//			or overwrites the old key).  
//
//			This supports a threadsafe standard enumerator, which returns values in the map
//			in alphabetical order.  
//
//	Was templated - supports types of:
//		TVal	- CComBSTR
//		TKey	- CComBSTR
//
//	This supports the interface members of:
//
//		get_Count(long *plCount)
//				Returns number of elements in this collection.
//		get__NewEnum(IUnknown **ppunk)
//				Returns a standard, threadsafe enumerator to this collecion.  (It copies the whole
//				map).
//		get_Item(VARIANT var, TVal *pT )
//				Supported input variant types are strings and numeric values.  If of string type, then
//				it returns the value associated with BSTR key.  If numeric, returns the n'th
//				item's value (in alphabetical, rather than inserted order).   Numeric access is not
//				fast, particularly for all elements in the collection.   
//				This method returns S_OK if success, and E_INVALIDARG if the 
//				item with the specifed key (or index) isn't in the collection.
//		get_Key(VARIANT var, TKey *pT)
//				This does reverse lookup, returning the key assoicated with a given value.
//				Supported var variant types are strings and numeric values.  If of string type, then
//				it returns the *first* key whose value matches that passed in (it may not be a 1-1 mapping
//			    of values back to keys).  If numeric, returns the n'th keys's value (in 
//				alphabetical, rather than inserted order).   This returns S_OK if success, 
//				and E_INVALIDARG if the item with the specifed value (or index) isn't in the collection.
//				--> This method is intended for debugging only - it is not fast.  
//		Add(TKey rKey, TVal rVal)		
//				Adds a new <key,value> pair to the map.  If the key already in use, it
//				doesn't overwrite the old value.  Instead it returns S_FALSE.
//		Add1(TVal rVal)		
//				Adds a new <value> to the map, creating a unique key for it.
//				(Key is ID number in "NNN" format, such as "007").  This allows the
//				map to be used to contain simple arrays of TVals, accessed with the 
//				number variant version of get_Item().  It's possible to mix two forms 
//				in the same collection, but avoid keys of 'NNN'.  (Assumes less than 1000 elements
//				in the map, sort will fail if larger. - change %03d to something larger.)
//
//		Replace(TKey rKey, TVal rVal)
//				Replaces the value at the given key in the map, and if successful, returns S_OK.
//			    If the key can not be found in the map, it adds a new key/value and returns S_FALSE.  
//				(E.g. this is like Add(), but it overwrites the old value.)
//		Remove(VARIANT varIn)
//				Removes either element in the map with the given key if varIn is a string form,
//				otherwise the n'th element (alphabetical order) if it's numeric.  It returns E_INVALIDARG
//				if the item isn't there to remove.	Strange effects with Add1 key number here.
//		RemoveAll()
//				Removes all elements in the collection (just what did you expect?)
//
//	local methods
//
//		get_Item(BSTR bstr, TVal *pT )		
//				This returns the value associated with a given key.  This
//				is algorithmically fastest method to retreive values from this collection.
//				This returns E_INVALIDARG if the item with the specified key isn't in the collection.
//
//		Item(VARIANT var, TVal *pT)
//		Key(VARIANT var, TKey *pK)
//			return the given value/first-key given the associated key/value or 
//			an index into the map
//
//		ItemIter(VARIANT varIn, MapT::iterator &iIter)
//		ItemKey(VARIANT varIn, MapT::iterator &iIter)
//			return iterator to the given value/first-key given the associated key/value 
//			or index into the map
// -------------------------------------------------------------------------------------------
#ifndef __TVEATTRM_H_
#define __TVEATTRM_H_

#include "resource.h"       // main symbols

#include <map>

//#include "TveMap.h"
/////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
		// This is a thread safe enumerator.  It copies the collections internal
		//    data structure used to hold objects over so the collection can
		//	  change without affecting the enumerator list.  

// --------------------------------------------------------------------
//  IEnumString version
// ---------------------------------------------------------------------
/*
class CSafeEnumTVEMap :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<IEnumString, &IID_IEnumString, &LIBID_MSTvELib>
{

	typedef BSTR							TKey;
	typedef BSTR							TVal;
	typedef	ITVEAttrMap						BaseT;

	typedef std::map<CComBSTR, CComBSTR>	MapT;				
		
	typedef CSafeEnumTVEMap					ThisClassSEAMTVE;

public:
	CSafeEnumTVEMap()
	{
		m_punk		= NULL;
		m_iIterCur	= m_mapT.begin();
		m_iCur		= 0;
	}

	~CSafeEnumTVEMap()  
	{
	}

	void FinalRelease()
	{
		m_mapT.clear();

		if (m_punk != NULL)
			m_punk->Release();
	}

	void Init(IUnknown *punk, MapT *pmapT)		// change to const MapT &rmapT???
	{
		if (m_punk != NULL)
		{
			m_punk->Release();
			m_punk = NULL;
		}

		if(NULL == pmapT) return;		// bogus!!!

		if (punk != NULL)				// back pointer to containing class
		{
//			punk->AddRef();
//			m_punk = punk;
		}
		
								// copy the whole map (this is slow but safe!)
		EnterCriticalSection(&_Module.m_csTypeInfoHolder);
		{	
			m_mapT = *pmapT;					// wonder if this will work?
//			int cN = pmapT->size();
//			for(int j = 0; j < cN; j++)
//				m_mapT.Add(pmapT->GetKeyAt(j), pmapT->GetValueAt(j));		// must be faster way to do this...
		}	
		LeaveCriticalSection(&_Module.m_csTypeInfoHolder);

		m_iCur = 0;
		m_iIterCur = m_mapT.begin();
	}

BEGIN_COM_MAP(ThisClassSEAMTVE)
	COM_INTERFACE_ENTRY(IEnumString)
END_COM_MAP()

	// IEnumUnknown interface  -- get the next celt elements
	STDMETHOD(Next)(ULONG celt, BSTR *pvar, ULONG *pceltFetched)
		{
		ENTER_API
			{
			ULONG celtFetched = 0;
			int iMax = m_mapT.size();

			if ((pvar == NULL) || ((celt > 1) && (pceltFetched == NULL)))
				return E_POINTER;
			
			while ((m_iCur < iMax) && (celtFetched < celt))
			{
				TKey vK = (*m_iIterCur).first;
				TVal vT = (*m_iIterCur).second;

				*pvar++ = vT;
		//		IDispatch *pdispatch;
		//		pT->QueryInterface(IID_IDispatch, (void **) &pdispatch);
	//			CComVariant var(vT);
	//			*pvar++ = var;
				celtFetched++;
				m_iIterCur++;	m_iCur++;
			}
			
			if (pceltFetched != NULL)
				*pceltFetched = celtFetched;
			
			return (celtFetched == celt) ? S_OK : S_FALSE;
			}
		EXIT_API
		}
	
	STDMETHOD(Skip)(ULONG celt)
		{
		ENTER_API
			{
				m_iCur += celt;
			
				if(m_iCur < m_mapT.size())
				{
					for(int i = 0; i < celt; i++)
						m_iIterCur++;
					return S_OK;
				} else {
					m_iIterCur = m_mapT.end();
					return S_FALSE;
				}
			}
		EXIT_API
		}
	
	STDMETHOD(Reset)(void)
		{
		ENTER_API
			{
				m_iCur = 0;
				m_iIterCur = m_mapT.begin();
				return S_OK;
			}
		EXIT_API
		}
	
	STDMETHOD(Clone)(IEnumString **ppenum)
		{
		ENTER_API
			{
				static char THIS_FILE[] = __FILE__;	// for debug version of NewComObject
				ThisClassSEAMTVE *penum = NewComObject(ThisClassSEAMTVE);

				if (penum == NULL)
					return E_OUTOFMEMORY;

				penum->Init(m_punk, &m_mapT);
				penum->m_iCur = m_iCur;
				for(int i = 0; i < m_iCur; i++)		// bump up the iter
					penum->m_iIterCur++;

				HRESULT hr = penum->QueryInterface(IID_IEnumString, (void **)ppenum);
				if(!FAILED(hr)) 
					penum->Release();
				return hr;
			}
		EXIT_API
		}

protected:
	IUnknown		*m_punk;			// back pointer to map class, to keep it alive
	MapT			m_mapT;				// complete copy of the map, not pointer!
	MapT::iterator	m_iIterCur;			// actual iterator into m_mapT  -- keep these 2 in sync --
	int				m_iCur;				// index of location into map   -- keep these 2 in sync --
};

*/
// --------------------------------------------------------------------
//  IEnumVARIANT version
// ---------------------------------------------------------------------
class CSafeEnumTVEMap :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_MSTvELib>
{

	typedef BSTR							TKey;
	typedef BSTR							TVal;
	typedef	ITVEAttrMap						BaseT;

	typedef std::map<CComBSTR, CComBSTR>	MapT;				
		
	typedef CSafeEnumTVEMap					ThisClassSEAMTVE;

public:
	CSafeEnumTVEMap()
	{
		m_punk		= NULL;
		m_iIterCur	= m_mapT.begin();
		m_iCur		= 0;
	}

	~CSafeEnumTVEMap()  
	{
	}

	void FinalRelease()
	{
		m_mapT.clear();

		if (m_punk != NULL)
			m_punk->Release();
	}

	void Init(IUnknown *punk, MapT *pmapT)		// change to const MapT &rmapT???
	{
		if (m_punk != NULL)
		{
			m_punk->Release();
			m_punk = NULL;
		}

		if(NULL == pmapT) return;		// bogus!!!

		if (punk != NULL)				// back pointer to containing class
		{
//			punk->AddRef();
//			m_punk = punk;
		}
		
								// copy the whole map (this is slow but safe!)
		EnterCriticalSection(&_Module.m_csTypeInfoHolder);
		{	
//			m_mapT = *pmapT;					// wonder if this will work?
			MapT::iterator iIter;
			for(iIter = pmapT->begin(); iIter != pmapT->end(); iIter++)
			{
	//			MapT::value_type keyval(rKey, rVal);
				m_mapT.insert((*iIter));
			}
		}	
		LeaveCriticalSection(&_Module.m_csTypeInfoHolder);

		m_iCur = 0;
		m_iIterCur = m_mapT.begin();
	}

BEGIN_COM_MAP(ThisClassSEAMTVE)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

	// IEnumUnknown interface  -- get the next celt elements
	STDMETHOD(Next)(ULONG celt, VARIANT *pvar, ULONG *pceltFetched)
		{
		ENTER_API
			{
			ULONG celtFetched = 0;
			int iMax = m_mapT.size();

			if ((pvar == NULL) || ((celt > 1) && (pceltFetched == NULL)))
				return E_POINTER;
			
			for (ULONG l=0; l < celt; l++)
				::VariantClear( &pvar[l] ) ;

			while ((m_iCur < iMax) && (celtFetched < celt))
			{
				TKey tvK = (*m_iIterCur).first;
				TVal tvT = (*m_iIterCur).second;
				BSTR bstrVal(tvT);

			//	pvar = new CComVariant(tvT);		// doesn't work
				
			//	pvar->vt	  = VT_BSTR;					// major pain in the butt here
			//	pvar->bstrVal = ::SysAllocString(tvT);		//  the CComVariant above didn't work
															//  and no 'transfer' like function	

													// slightly more formal way (if not slower)
													// since it does better error handling
				CComVariant *pcvvar = (CComVariant *) pvar;
				*pcvvar = tvT;

				pvar++;
				celtFetched++;
				m_iIterCur++;	m_iCur++;
			}
			
			if (pceltFetched != NULL)
				*pceltFetched = celtFetched;
			
			return (celtFetched == celt) ? S_OK : S_FALSE;
			}
		EXIT_API
		}
	
	STDMETHOD(Skip)(ULONG celt)
		{
		ENTER_API
			{
				m_iCur += celt;
			
				if(m_iCur < m_mapT.size())
				{
					for(int i = 0; i < celt; i++)
						m_iIterCur++;
					return S_OK;
				} else {
					m_iIterCur = m_mapT.end();
					return S_FALSE;
				}
			}
		EXIT_API
		}
	
	STDMETHOD(Reset)(void)
		{
		ENTER_API
			{
				m_iCur = 0;
				m_iIterCur = m_mapT.begin();
				return S_OK;
			}
		EXIT_API
		}
	
	STDMETHOD(Clone)(IEnumVARIANT **ppenum)
		{
		ENTER_API
			{
				static char THIS_FILE[] = __FILE__;	// for debug version of NewComObject
				ThisClassSEAMTVE *penum = NewComObject(ThisClassSEAMTVE);

				if (penum == NULL)
					return E_OUTOFMEMORY;

				penum->Init(m_punk, &m_mapT);
				penum->m_iCur = m_iCur;
				for(int i = 0; i < m_iCur; i++)
					penum->m_iIterCur++;

				HRESULT hr = penum->QueryInterface(IID_IEnumVARIANT, (void **)ppenum);
				if(!FAILED(hr)) 
					penum->Release();
				return hr;
			}
		EXIT_API
		}

protected:
	IUnknown		*m_punk;			// back pointer to map class, to keep it alive
	MapT			m_mapT;				// complete copy of the map, not pointer!
	MapT::iterator	m_iIterCur;			// actual iterator into m_mapT  -- keep these 2 in sync --
	int				m_iCur;				// index of location into map   -- keep these 2 in sync --
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTVEAttrMap
class ATL_NO_VTABLE CTVEAttrMap :  
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTVEAttrMap, &CLSID_TVEAttrMap>,
//	public TVEMap<CComBSTR, CComBSTR, ITVEAttrMap>,
	public ISupportErrorInfo,
	public IDispatchImpl<ITVEAttrMap, &IID_ITVEAttrMap, &LIBID_MSTvELib>
{
	typedef BSTR							TKey;
	typedef BSTR							TVal;
	typedef	ITVEAttrMap						BaseT;

	typedef CTVEAttrMap						ThisClassTVEAM;
	typedef std::map<CComBSTR, CComBSTR>	MapT;
	typedef CSafeEnumTVEMap					EnumTVEMapT;
				
//	typedef std::map<TKey, TVal>			MapT;				
//	typedef SafeEnumTVEMap<TKey, TVal>		EnumTVEMapT;

	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
	DECLARE_REGISTRY_RESOURCEID(IDR_TVEATTRMAP)
	DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVEAttrMap)
	COM_INTERFACE_ENTRY(ITVEAttrMap)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

public:
	CTVEAttrMap()
	{
		m_cLast = 0;
	}
	
	~CTVEAttrMap()
	{
		RemoveAll();
	}
	
	
	virtual BOOL FOkToRemove()
	{
		return TRUE;
	}
	

	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
	{
		ENTER_API
		{
			HRESULT hr;
			ValidateOutPtr<IUnknown *>(ppunk, NULL);

			static char THIS_FILE[] = __FILE__;	// for debug version of NewComObject
			EnumTVEMapT *penum = NewComObject(EnumTVEMapT);
			if (penum == NULL)
				return E_OUTOFMEMORY;
			
			penum->Init((IUnknown *)(BaseT *)this, &m_mapT);

//			hr =  penum->QueryInterface(IID_IEnumString, (void **)ppunk);
			hr =  penum->QueryInterface(IID_IEnumVARIANT, (void **)ppunk);
			penum->Release();			// need this...
			return hr;
		}
		EXIT_API
	}
	
	STDMETHOD(get_Count)(long *plCount)
	{
		ENTER_API
		{
			ValidateOutPtr<long>(plCount, NULL);

			if (plCount == NULL)
				return E_POINTER;
			
			*plCount = m_mapT.size();
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(BSTR bstr, TVal *pT )			// fast (but for string-compares) - uses map
	{
		ENTER_API
		{	
			ValidateOutPtr<TVal>(pT, NULL);

			MapT::iterator iterFind = m_mapT.find(bstr); 
			if(iterFind != m_mapT.end()) 
			{
				CComBSTR spB = (*iterFind).second;
//				*pT = spB.Detach();				// copies pointer
				return spB.CopyTo(pT);
			} else {
				return E_INVALIDARG;			// not found...
			}
		}
		EXIT_API
	}

	STDMETHOD(get_Item)(VARIANT varKey, TVal *pT )
	{
		return Item(varKey, pT);		// all inline, error handling down lower...
	}

	STDMETHOD(get_Key)(VARIANT varValue, TVal *pT )
	{
		return Key(varValue, pT);
	}

	STDMETHOD(Add)(TKey rKey, TVal rVal)		// returns S_FALSE if key already in use, but doesn't overwrite old one
	{
		ENTER_API
		{
			MapT::iterator mit = m_mapT.find(rKey);
			if(mit != m_mapT.end())
				return S_FALSE;
			std::pair<MapT::iterator, bool> pi;
			MapT::value_type keyval(rKey, rVal);
			pi = m_mapT.insert(keyval);
//			if(pi.second == false) return E_UNEXPECTED;
			return S_OK;
		}
		EXIT_API
	}
	
	STDMETHOD(Add1)(TVal rVal)		// returns S_FALSE if key already in use, but doesn't overwrite old one
	{
		ENTER_API
		{
			TKey rKey;
			wchar_t wcsbuff[10];
			if(m_cLast >= 1000)				// too many items...
				return E_UNEXPECTED;

			swprintf(wcsbuff,L"%03d",m_cLast++);
			rKey = wcsbuff;

			MapT::iterator mit = m_mapT.find(rKey);		// paranoia...
			if(mit != m_mapT.end())
				return E_UNEXPECTED;

			std::pair<MapT::iterator, bool> pi;
			MapT::value_type keyval(rKey, rVal);
			pi = m_mapT.insert(keyval);
			return S_OK;
		}
		EXIT_API
	}

	STDMETHOD(Replace)(TKey rKey, TVal rVal)		// returns S_FALSE if key not there yet.
	{
		ENTER_API
		{
			BOOL fAlreadyThere = (m_mapT.end() != m_mapT.find(rKey));
			m_mapT[rKey] = rVal;					// cool overloaded operator
			return fAlreadyThere ? S_OK : S_FALSE ;	// if not already there, (and we added it), return S_FALSE instead 
		}
		EXIT_API
	}
	
	STDMETHOD(Remove)(VARIANT varIn)
	{
		ENTER_API
		{
			CComVariant var(varIn);
			switch (var.vt)
			{
			case VT_EMPTY:
				return E_INVALIDARG;

			case VT_BSTR:		// only works for STRING type keys
				{
					var.ChangeType(VT_BSTR);			// blow up perhaps if wrong casting
					
					int iRemove = m_mapT.erase(var.bstrVal);
					if(iRemove > 0) {
						return S_OK;
					} else {
						return E_INVALIDARG;
					}
				}
				break;

			default:				// slight different that above, since this only removes 1 object (by iter)
				{					//   and the above erase removes all keys with the same name
					MapT::iterator iIter;
					HRESULT hr = ItemIter(var, iIter);
					if(S_OK == hr) 
					{
						if(m_mapT.end() != m_mapT.erase(iIter))	// returns end() if item not there
							return S_OK;
						else
							return E_UNEXPECTED;				// this should never happen
					} else {
						return hr;
					}
				}
				break;
			}					// end switch
		return E_FAIL;		// should never get here...
		}
		EXIT_API
	}
	
	STDMETHOD(RemoveAll)()
	{
		ENTER_API
		{
			//if(!m_mapT.empty())
			//	m_mapT.erase(m_mapT.begin(),m_mapT.end());
			m_mapT.clear();
			m_cLast = 0;			// restart the Add1 count...
			return S_OK;
		}
		EXIT_API
	}

	STDMETHOD(Item)(VARIANT varKey, TVal *pT)
	{
		ENTER_API
		{
			ValidateOutPtr<TVal>(pT, NULL);

			MapT::iterator iIter;
			HRESULT hr = ItemIter(varKey, iIter);
			if(S_OK == hr) {
				CComBSTR spB = (*iIter).second;			// creates new copy of the value
//				*pT = spB.Detach();						// copies pointer
				return spB.CopyTo(pT);
			} else {
				return E_INVALIDARG;
			}
			return S_OK;
		}
		EXIT_API
	}


	STDMETHOD(Key)(VARIANT varValue, TVal *pT)
	{
		ENTER_API
		{
			ValidateOutPtr<TVal>(pT, NULL);

			MapT::iterator iIter;
			HRESULT hr = KeyIter(varValue, iIter);
			if(S_OK == hr) {
				CComBSTR spB = (*iIter).first;			// creates new copy of the key
//				*pT = spB.Detach();						// copies pointer
				return spB.CopyTo(pT);
			} else {
				return E_INVALIDARG;
			} 
			return S_OK;
		}
		EXIT_API
	}
								// local routine to set iter to given item
	HRESULT ItemIter(VARIANT varIn, MapT::iterator &iIter)
	{
		CComVariant var(varIn);
		int index;

		switch (var.vt)
		{
		case VT_EMPTY:
			return E_INVALIDARG;

		case VT_BSTR:		// only works for STRING type keys
			{
				var.ChangeType(VT_BSTR);			// blow up perhaps if wrong casting
				
				iIter = m_mapT.find(var.bstrVal);
				if(iIter != m_mapT.end()) {
					return S_OK;
				} else {
					return E_INVALIDARG;
				}
			}
			break;

		default:
			{
				var.ChangeType(VT_I4);
				index = var.lVal;


				if(index < 0 || index >= m_mapT.size())
					return E_INVALIDARG;

				// use iterator here to get n'th value  (slow, but hey... better than nothing)
				for(iIter = m_mapT.begin(); 
					 index > 0 /*&& iter != m_mapT.end()*/; 
					--index, iIter++)
					{
						;
					}
				return S_OK;
			}
			break;
		}					// end switch
		return E_FAIL;		// should never get here...
	}						// end function

	
								// local routine to return iter to given item
	HRESULT KeyIter(VARIANT varIn, MapT::iterator &iIter)
	{
		CComVariant var(varIn);
		int index;

		switch (var.vt)
		{
		case VT_EMPTY:
			return E_INVALIDARG;

		case VT_BSTR:		// only works for STRING type keys
			{
				var.ChangeType(VT_BSTR);			// blow up perhaps if wrong casting

				MapT::iterator iterLoop;
				for(iIter = m_mapT.begin(); iIter != m_mapT.end(); iIter++)
				{
					BSTR *pValue = &((*iIter).second);	
					if(0 == wcscmp(var.bstrVal, *pValue))	// find first value matching input one
					{										//  (there may be more)
						return S_OK;
					}
				}
				iIter = m_mapT.end();
				return E_INVALIDARG;				// didn't find it..
			}
			break;

		default:
			{
				var.ChangeType(VT_I4);
				index = var.lVal;


				if(index < 0 || index >= m_mapT.size())
				{
					iIter = m_mapT.end();
					return E_INVALIDARG;
				}

				// use iterator here to get n'th value  (slow, but hey... better than nothing)
				for(iIter = m_mapT.begin(); 
					 index > 0/*&& iter != m_mapT.end()*/; 
					--index, iIter++)
						;
						
				return S_OK;
			}
			break;
		}					// end switch
		return E_FAIL;		// should never get here...
	}						// end function

	STDMETHOD(DumpToBSTR)(BSTR *pBstrBuff)			// should be in a _helper interface
	{
		ENTER_API
		{
			ValidateOutPtr<BSTR>(pBstrBuff, NULL);
		
			const int kMaxChars=256;
			TCHAR tBuff[kMaxChars];
			CComBSTR bstrOut;
			bstrOut.Empty();

			MapT::iterator iIter;
			int i = 0;
			bstrOut.Append("{");
			for(iIter = m_mapT.begin(); iIter != m_mapT.end(); iIter++, i++)
			{
				if(i != 0) { _sntprintf(tBuff, kMaxChars-1, _T(" | ")); bstrOut.Append(tBuff); }
				_sntprintf(tBuff, kMaxChars-1, _T("%s:%s"),(*iIter).first,(*iIter).second);
				tBuff[kMaxChars-1]=0;		// terminate in case too large.
				bstrOut.Append(tBuff);
			}
			bstrOut.Append("}");
			return bstrOut.CopyTo(pBstrBuff);
		}
		EXIT_API
	}

	MapT	m_mapT;							// base collection object..
	int		m_cLast;						// last Add1() item (to handle deletes)
};



#endif __TVEATTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvecbannc.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVECBAnnc.cpp : Implementation of CTVECBAnnc
#include "stdafx.h"
#include "MSTvE.h"
#include "TVECBAnnc.h"
#include "TVEMCast.h"

_COM_SMARTPTR_TYPEDEF(ITVEMCast,			__uuidof(ITVEMCast));
_COM_SMARTPTR_TYPEDEF(ITVEMCasts,			__uuidof(ITVEMCasts));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,		__uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCastCallback,	__uuidof(ITVEMCastCallback));


_COM_SMARTPTR_TYPEDEF(ITVEService,			__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,	__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,		__uuidof(ITVEEnhancement));

/////////////////////////////////////////////////////////////////////////////
// CTVECBAnnc

STDMETHODIMP CTVECBAnnc::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVECBAnnc
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CTVECBAnnc::ProcessPacket(unsigned char *pchBuffer, long cBytes, long lPacketId)
{
	DBG_HEADER(CDebugLog::DBG_PACKET_RCV, _T("CTVECBAnnc::ProcessPacket"));

    try{
        HRESULT hr;
        USES_CONVERSION;


        _ASSERTE(NULL != m_spTVEService);			// forgot to bind to the enhancement node		

        IUnknownPtr spUnk;
        _ASSERTE(NULL != m_pcMCast);			// forgot to bind to the multicast listener manager
        hr = m_pcMCast->get_Manager(&spUnk);
        if(FAILED(hr))
            return hr;

        ITVEMCastManagerPtr spMCM(spUnk);		
        if(NULL == spMCM)
            return E_NOINTERFACE;


        WCHAR *wasAnc = (WCHAR*) alloca(cBytes*2 + 2);
        for(int i = 0; i < cBytes; i++)
        {
            wasAnc[i] = pchBuffer[i];		// NULL binary data prevents use of A2W here...
        }
        wasAnc[cBytes] = 0;					// extra special null terminator for paranoid programmers

        // add enhancement, or update existing one

        ITVEService_HelperPtr spServiceHelper(m_spTVEService);
        //	spMCM->Lock();
        hr = spServiceHelper->ParseCBAnnouncement(m_spbstrFileTrigAdapter, &wasAnc);

        if(FAILED(hr))
        {
            TVEDebugLog((CDebugLog::DBG_SEV2, 2,_T("*** Error *** Invalid Announcement - hr = 0x%08x\n"),hr));
        }

        //	spMCM->DumpString(wBuff);
        //	spMCM->Unlock();

        return hr;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CTVECBAnnc::Init(BSTR bstrFileTrigAdapter, ITVEService *pIService)
{
	if(NULL == pIService) return E_NOINTERFACE;

	m_spbstrFileTrigAdapter = bstrFileTrigAdapter;
	m_spTVEService = pIService;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvecbfile.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVECBFile.h : Declaration of the CTVECBFile

#ifndef __TVECBFILE_H_
#define __TVECBFILE_H_

#include "resource.h"       // main symbols
#include "TVEMCCback.h"
#include "TVECBAnnc.h"
#include "TVEMCast.h"

#include "UHTTP.h"

_COM_SMARTPTR_TYPEDEF(ITVEMCast,			__uuidof(ITVEMCast));
_COM_SMARTPTR_TYPEDEF(ITVEMCasts,			__uuidof(ITVEMCasts));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,		__uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCastCallback,	__uuidof(ITVEMCastCallback));

_COM_SMARTPTR_TYPEDEF(ITVESupervisor,		__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,		__uuidof(ITVEVariation));
/////////////////////////////////////////////////////////////////////////////
// CTVECBFile
class ATL_NO_VTABLE CTVECBFile : public CTVEMCastCallback, 
	public CComCoClass<CTVECBFile, &CLSID_TVECBFile>,
	public IDispatchImpl<ITVECBFile, &IID_ITVECBFile, &LIBID_MSTvELib>
{
public:
	CTVECBFile()
	{
	}

	~CTVECBFile()
	{
	}
DECLARE_REGISTRY_RESOURCEID(IDR_TVECBFILE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVECBFile)
	COM_INTERFACE_ENTRY(ITVECBFile)
	COM_INTERFACE_ENTRY(ITVEMCastCallback)
//	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY2(IDispatch, ITVEMCastCallback)		// note the '2'
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ITVEMCastCallback
public:
	STDMETHOD(ProcessPacket)(unsigned char *pchBuffer, long cBytes, long lPacketId);

// ITVECBFile
public:
	STDMETHOD(Init)(ITVEVariation *pVariation,  ITVEService *pIService);

private:
	ITVEServicePtr		m_spTVEService;
	ITVEVariationPtr	m_spTVEVariation;
	UHTTP_Receiver		m_uhttpReceiver;
};

#endif //__TVECBFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvecbdummy.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVECBDummy.h : Declaration of the CTVECBDummy

#ifndef __TVECBDUMMY_H_
#define __TVECBDUMMY_H_

#include "resource.h"       // main symbols
#include "TVEMCCback.h"
#include "TVEMCast.h"

_COM_SMARTPTR_TYPEDEF(ITVEMCast, __uuidof(ITVEMCast));
_COM_SMARTPTR_TYPEDEF(ITVEMCasts, __uuidof(ITVEMCasts));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager, __uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCastCallback, __uuidof(ITVEMCastCallback));
/////////////////////////////////////////////////////////////////////////////
// CTVECBDummy
class ATL_NO_VTABLE CTVECBDummy : public CTVEMCastCallback, 
	public CComCoClass<CTVECBDummy, &CLSID_TVECBDummy>,
	public IDispatchImpl<ITVECBDummy, &IID_ITVECBDummy, &LIBID_MSTvELib>
{
public:
	CTVECBDummy()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVECBDUMMY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVECBDummy)
	COM_INTERFACE_ENTRY(ITVECBDummy)
	COM_INTERFACE_ENTRY(ITVEMCastCallback)
	//	COM_INTERFACE_ENTRY(IDispatch)			
	COM_INTERFACE_ENTRY2(IDispatch, ITVEMCastCallback)		// note the '2'
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ITVEMCastCallback
public:
	STDMETHOD(ProcessPacket)(unsigned char *pchBuffer, long cBytes, long lPacketId);

// ITVECBDummy
public:
	STDMETHOD(Init)(int i);

private:
	int m_i;
};

#endif //__TVECBDUMMY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvecbfile.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVECBFile.cpp : Implementation of CTVECBFile
// -------------------------------------------------
//     Caution  
//			unlike other callbacks, this one uses a simple pointer instead of a
//			smart pointer references to the supervisor.  Otherwise, we get a circular
//			reference problem, and the supervisor ref-count can't go to zero.
//
// --------------------------------------------------
#include "stdafx.h"
#include "MSTvE.h"
#include "TVECBFile.h"

_COM_SMARTPTR_TYPEDEF(ITVEMCast,					__uuidof(ITVEMCast));
_COM_SMARTPTR_TYPEDEF(ITVEMCasts,					__uuidof(ITVEMCasts));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,				__uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCastCallback,			__uuidof(ITVEMCastCallback));

_COM_SMARTPTR_TYPEDEF(ITVEService,					__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,			__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,				__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,		__uuidof(ITVEEnhancement_Helper));

_COM_SMARTPTR_TYPEDEF(ITVEVariation,				__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEVariation_Helper,			__uuidof(ITVEVariation_Helper));

/////////////////////////////////////////////////////////////////////////////
// CTVECBFile

STDMETHODIMP CTVECBFile::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVECBFile
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CTVECBFile::ProcessPacket(unsigned char *pchBuffer, long cBytes, long lPacketId)
{
    HRESULT hr = S_OK;

	IUnknownPtr spUnk;
	_ASSERTE(NULL != m_pcMCast);			// forgot to bind it.
	hr = m_pcMCast->get_Manager(&spUnk);
	if(FAILED(hr))
		return hr;

	ITVEMCastManagerPtr spMCM(spUnk);
	if(NULL == spMCM)
		return E_NOINTERFACE;

//	spMCM->Lock();

	if(m_spTVEService) 
	{
		hr =  m_uhttpReceiver.NewPacket(cBytes, (UHTTP_Packet *) pchBuffer,	m_spTVEVariation);
	} else {
		ATLTRACE("*** Error *** NULL Service pointer\n");
		hr = E_POINTER;
	}


//	spMCM->DumpString(wBuff);
//	spMCM->UnLock();

	return hr;
}

STDMETHODIMP CTVECBFile::Init(ITVEVariation *pIVariation, ITVEService *pIService)
{
	if(NULL == pIVariation) return E_NOINTERFACE;
	if(NULL == pIService) return E_NOINTERFACE;

	m_spTVEVariation = pIVariation;
	m_spTVEService    = pIService;	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvecbannc.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVECBAnnc.h : Declaration of the CTVECBAnnc

#ifndef __TVECBANNC_H_
#define __TVECBANNC_H_

#include "resource.h"       // main symbols
#include "TVEMCCback.h"

_COM_SMARTPTR_TYPEDEF(ITVEEnhancement, __uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEService,     __uuidof(ITVEService));

/////////////////////////////////////////////////////////////////////////////
// CTVECBAnnc
class ATL_NO_VTABLE CTVECBAnnc : public CTVEMCastCallback, 
	public CComCoClass<CTVECBAnnc, &CLSID_TVECBAnnc>,
	public IDispatchImpl<ITVECBAnnc,        &IID_ITVECBAnnc,        &LIBID_MSTvELib>
{
public:
	CTVECBAnnc()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVECBANNC)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVECBAnnc)
	COM_INTERFACE_ENTRY(ITVECBAnnc)
	COM_INTERFACE_ENTRY(ITVEMCastCallback)
//	COM_INTERFACE_ENTRY(IDispatch)			
	COM_INTERFACE_ENTRY2(IDispatch, ITVEMCastCallback)		// note the '2'
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	HRESULT FinalRelease()
	{
		HRESULT hr = S_OK;			// place for a callback...
		return hr;
	}

// ITVEMCastCallback
public:
	STDMETHOD(ProcessPacket)(unsigned char *pchBuffer, long cBytes, long lPacketId);

// ITVECBAnnc
public:
	STDMETHOD(Init)(BSTR bstrFileTrigAdapter, ITVEService *pUnk);			

private:
	ITVEServicePtr	m_spTVEService;
	CComBSTR		m_spbstrFileTrigAdapter;

//	IUnknownPtr		   m_spUnk;
};

#endif //__TVECBANNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvecbdummy.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVECBDummy.cpp : Implementation of CTVECBDummy
#include "stdafx.h"
#include "MSTvE.h"
#include "TVECBDummy.h"
#include "TVEDbg.h"
#include <stdio.h>

/////////////////////////////////////////////////////////////////////////////
// CTVECBDummy

STDMETHODIMP CTVECBDummy::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVECBDummy
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CTVECBDummy::ProcessPacket(unsigned char *pchBuffer, long cBytes, long lPacketId)
{
 	DBG_HEADER(CDebugLog::DBG_PACKET_RCV, _T("CTVECBDummy::ProcessPacket"));

	HRESULT hr;
	USES_CONVERSION;


	IUnknownPtr spUnk;
	_ASSERTE(NULL != m_pcMCast);			// forgot to bind it.
	hr = m_pcMCast->get_Manager(&spUnk);
	if(FAILED(hr))
		return hr;

	ITVEMCastManagerPtr spMCM(spUnk);
	if(NULL == spMCM)
		return E_NOINTERFACE;

//	spMCM->Lock();

	if(1) //DBG_FSET(CDebugLog::DBG_UHTTPPACKET))	// always trace out dummy packets
	{
		spMCM->Lock_();
		TVEDebugLog((CDebugLog::DBG_SEV2, 2, 
					 _T("CTVECBDummy::ProcessPacket - %s:%d - Packet(%d) %d Bytes"),
					 m_pcMCast->m_spbsIP, m_pcMCast->m_Port, 
					 m_pcMCast->m_cPackets, cBytes))

		spMCM->Unlock_();
	}

//	spMCM->DumpString(wBuff);
//	spMCM->UnLock();

	return S_OK;
}

STDMETHODIMP CTVECBDummy::Init(int i)
{
	// TODO: Add your implementation code here
	m_i = 1;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvecbtrig.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVECBTrig.h : Declaration of the CTVECBTrig

#ifndef __TVECBTRIG_H_
#define __TVECBTRIG_H_

#include "resource.h"       // main symbols
#include "TVEMCCback.h"
#include "TVECBAnnc.h"
#include "TVEMCast.h"

_COM_SMARTPTR_TYPEDEF(ITVEMCast, __uuidof(ITVEMCast));
_COM_SMARTPTR_TYPEDEF(ITVEMCasts, __uuidof(ITVEMCasts));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager, __uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCastCallback, __uuidof(ITVEMCastCallback));

_COM_SMARTPTR_TYPEDEF(ITVEVariation, __uuidof(ITVEVariation));
/////////////////////////////////////////////////////////////////////////////
// CTVECBTrig
class ATL_NO_VTABLE CTVECBTrig : public CTVEMCastCallback, 
	public CComCoClass<CTVECBTrig, &CLSID_TVECBTrig>,
	public IDispatchImpl<ITVECBTrig, &IID_ITVECBTrig, &LIBID_MSTvELib>
{
public:
	CTVECBTrig()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVECBTRIG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVECBTrig)
	COM_INTERFACE_ENTRY(ITVECBTrig)
	COM_INTERFACE_ENTRY(ITVEMCastCallback)
//	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY2(IDispatch, ITVEMCastCallback)		// note the '2'
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ITVEMCastCallback
public:
	STDMETHOD(ProcessPacket)(unsigned char *pchBuffer, long cBytes, long lPacketId);

public:
// ITVECBTrig
	STDMETHOD(Init)(ITVEVariation *pVariation);

private:
	ITVEVariationPtr	m_spTVEVariation;
};

#endif //__TVECBTRIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvecbtrig.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVECBTrig.cpp : Implementation of CTVECBTrig
#include "stdafx.h"
#include "MSTvE.h"
#include "TVECBTrig.h"

_COM_SMARTPTR_TYPEDEF(ITVEMCast,					__uuidof(ITVEMCast));
_COM_SMARTPTR_TYPEDEF(ITVEMCasts,					__uuidof(ITVEMCasts));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,				__uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCastCallback,			__uuidof(ITVEMCastCallback));

_COM_SMARTPTR_TYPEDEF(ITVEService,					__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,			__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,				__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,		__uuidof(ITVEEnhancement_Helper));

_COM_SMARTPTR_TYPEDEF(ITVEVariation,				__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEVariation_Helper,			__uuidof(ITVEVariation_Helper));

/////////////////////////////////////////////////////////////////////////////
// CTVECBTrig

STDMETHODIMP CTVECBTrig::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_ITVECBTrig
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CTVECBTrig::ProcessPacket(unsigned char *pchBuffer, long cBytes, long lPacketId)
{
    try{
        HRESULT hr;
        USES_CONVERSION;


        IUnknownPtr spUnk;
        _ASSERTE(NULL != m_pcMCast);			// forgot to bind it.
        hr = m_pcMCast->get_Manager(&spUnk);
        if(FAILED(hr))
            return hr;

        ITVEMCastManagerPtr spMCM(spUnk);
        if(NULL == spMCM)
            return E_NOINTERFACE;

        //	spMCM->Lock();

        WCHAR *wasTrig = (WCHAR*) alloca(cBytes*2 + 2);
        for(int i = 0; i < cBytes; i++)
        {
            wasTrig[i] = pchBuffer[i];		// NULL binary data prevents use of A2W here...
        }
        wasTrig[cBytes] = 0;	

        // add enhancement, or update existing one
        if(m_spTVEVariation) 
        {
            ITVEVariation_HelperPtr spVariationHelper(m_spTVEVariation);
            //	spMCM->Lock();
            hr = spVariationHelper->ParseCBTrigger(wasTrig);
#ifdef _DEBUG
            USES_CONVERSION;
            if(FAILED(hr))
                ATLTRACE("*** Error *** Invalid Trigger %s\n",W2A(wasTrig));
#endif
        } else {
            ATLTRACE("*** Error *** NULL Variation Pointer\n");
        }
        //	spMCM->DumpString(wBuff);
        //	spMCM->UnLock();

        return S_OK;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CTVECBTrig::Init(ITVEVariation *pIVariation)
{
	if(NULL == pIVariation) return E_NOINTERFACE;

	m_spTVEVariation = pIVariation;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvecollect.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//  TVECollection.h
//   From Lee's (bpc\ca\caman\templ.h) :
//
//
//
//	These templates create a collection class and a threadsafe enumerator
//	on that class.  <note - can make faster, non-threadsafe enumerator too
//	by changing enumerator type in class TVECollection>
//
//
//	To create a collection object CXXs (e.g. CTVETracks) with Interface
//	of ICXXs (e.g. ITVETracks), containing a set of objects with interfaces 
//	of IXX (e.g. ITVETrack)	declare something like this:
//
// class CXXs : public TVECollection<ICXX, ICXXs>
// {
//    public:
//		.. additional functions and methods.
//
// }
//
//
//
// STDMETHODS to support ITVECollection
//
//		HRESULT get__NewEnum(IUnknown **ppunk);
//			returns a new enumerator of type IEnumVARIANT.
//			User must release this item.
//
//		HRESULT get_Count(long *plCount);
//			returns number of items in collection in *plCount;
//
//		HRESULT Item(long index, T **ppT);
//		HRESULT get_Item(long index, T **ppT)
//		HRESULT get_Item(VARIANT var, T **ppT )
//			returns the index'th(0 based) item from the collection.  Returns
//			E_INVALIDARG if index out of range (<0 or >= count).
//			User must release this item.
//
//		HRESULT Add(T *pT);
//		HRESULT Add(IUnknown *punk);
//			Adds a new object to the end of the collection.  Returns S_FALSE
//			if that item already in the collection.  IUnknown version may return
//			E_INTERFACE if wrong object type passed.
//
//		HRESULT Insert(int iLoc, T *pT);
//			Adds a new object somewhere in a collection.  Returns S_FALSE if that
//			item is already in the collection.  iLoc of 0 will go to the begining.
//			iLoc of the Count will place it at the end.
//
//		HRESULT Remove(VARIANT var);
//			Removes an item. Variant may be a number, or a IUnknown or IDispatch
//			interface to an object in the collection.  Returns E_FAIL if can't
//			find the object.  May return E_INTERFACE is variant is the wrong type.
//			
//		internal class methods
//

//		HRESULT ItemIndex(VARIANT varIn, int *piItem)
//			Returns the index for the given object buried in the variant.  Variant
//			must be of either VT_UNKNOWN or VT_DISPATCH type to query by objects,
//			or else of a numeric type that can be converted to VT_I4 type.
//			Will return E_FAIL if can't find object (and set *piItem to -1).
//			Will return E_INTERFACE if passed object doesn't support interface of 
//			type T.
//			
//
//		int Find(T *pT)
//			Returns the index for the given object.  Returnsv value of -1 if not found.
//
//		HRESULT Remove(T *pT)
//			Removes the given item if possible (see below).  If item is not in
//			the collection, returns E_FAIL.
//	
//		HRESULT Remove(int iItem)
//			Removes the item at the given index if possible. if index is out of range,
//			(< 0 or >= Count), returns E_INVALIDARG.  If not ok to remove (currently
//			always OK), returns E_FAIL.  
//
//
// The enumerator supports IEnumVARIANT, which has the following methods
//
//		HRESULT Next(ULONG cElt, 
//		             VARIANT *rgvar, 
//                   unsigned long * pceltFetched);
//			Get the next CElt elements (usually 1), returning them in the
//			given array.   The number actually returned is passed back in pCeltFetched.
//			This returns S_FALSE if *pCeltFetched is not equal to cElt.
//
//		HRESULT Skip(ULONG cElt);
//			Skip over cElt elements.  Returns S_FALSE if skipped over the end of
//			the list.
//
//		HRESULT Reset();
//			Sets the internal counter back to beginning.
//
//		HRESULT Clone(IEnumVARIANT **ppenum);
//			Clone the enumerator, including current position.  May return E_OUTOFMEMORY,
//			or any of the erros from QueryInterface.
// 
//
//
// ------------------------------------------------------------------------------
//  To use an enumerator in C++, try this:
//
//
//	Given object spXXs in class built on TVECollection<IXX, IXXs>
//
//					// create an enumerator
//		CComPtr<IXXs> spXXs;
//		spXXs = ???
//
//		CComQIPtr<IEnumVARIANT> speEnum; 
//		hr = spXXs->get__NewEnum((IUnknown **) &speEnum);
//		if(!FAILED(hr)) 
//		{
//			while(S_OK == speEnum->Next(1, &v, &cReturned))
//			{
//				if(1 != cReturned) break;		// did we get the object?
//				IUnknown *pUnk = v.punkVal;		// convert out of variant form
//
//				CComQIPtr<IXX> spXX = pUnk;		// convert over to desired form
//				if(!spXX) break;				// did it work?
//
//				spXX->DoSomething();
//
//				pUnk->Release();				// !!! remember to release it
//			}
//		}
 // 
// ------------------------------------------------------------------------------

#ifndef __TVECOLLECTION_H__
#define __TVECOLLECTION_H__

#include <vector>		// STL Vector class (for storing list of tracks)

#include "valid.h"		// ENTER_API, EXIT_API classes
#include "TveSmartLock.h"

typedef std::vector<CComVariant> VarVector;				// fundamental collection storage class
template<class T> class EnumTVECollection;				// templates defined in this file
template<class T> class SafeEnumTVECollection;
template<class T, class BaseT> class TVECollection;

// -------------------------------------------------------------
//							



template<class T>					// non threadsafe version 
class EnumTVECollection :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_MSTvELib>
{
	typedef std::vector<T *>	 VectorPT;
	typedef EnumTVECollection<T> ThisClassETVEC;

public:
    EnumTVECollection()
    {
        m_punk = NULL;
        m_iCur = 0;
        HRESULT hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_spUnkMarshaler.p);
    }
    
    ~EnumTVECollection()
    {
        if (m_punk != NULL)
            m_punk->Release();
        m_punk = NULL;
        m_spUnkMarshaler = NULL;
    }
    
    void Init(IUnknown *punk, VectorPT *pvecpT)
    {
        if (m_punk != NULL)
        {
            m_punk->Release();
            m_punk = NULL;
        }
        
        if (punk != NULL)
        {
            punk->AddRef();
            m_punk = punk;
        }
        
        m_pvecpT = pvecpT;
        m_iCur = 0;
    }

DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(ThisClassETVEC)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
END_COM_MAP()

	CComPtr<IUnknown> m_spUnkMarshaler;

	// IEnumUnknown interface
    STDMETHOD(Next)(ULONG celt, VARIANT *pvar, ULONG *pceltFetched)
    {
        ENTER_API
        {
            CSmartLock spLock(&m_sLk, ReadLock);
        
            ULONG celtFetched = 0;
            int iMax = m_pvecpT->size();
        
            if (pvar == NULL) 
                return E_POINTER;
        
            if((celt > 1) && (pceltFetched == NULL))
                return E_POINTER;
        
            for (ULONG l=0; l < celt; l++)		// need to do this...
                ::VariantClear( &pvar[l] ) ;
        
            while ((m_iCur < iMax) && (celtFetched < celt))
            {
                T * pT = m_pvecpT->at(m_iCur++);
                IDispatch *pdispatch;
                pT->QueryInterface(IID_IDispatch, (void **) &pdispatch);
                CComVariant var(pdispatch);
                *pvar++ = var;
                celtFetched++;
            }
        
            if (pceltFetched != NULL)
                *pceltFetched = celtFetched;
        
            return (celtFetched == celt) ? S_OK : S_FALSE;
        }
        EXIT_API
    }

    STDMETHOD(Skip)(ULONG celt)
    {
        ENTER_API
        {
            CSmartLock spLock(&m_sLk, ReadLock);
            m_iCur += celt;
        
            return (m_iCur < m_pvecpT->size()) ? S_OK : S_FALSE;
        }
        EXIT_API
    }

    STDMETHOD(Reset)(void)
    {
        ENTER_API
        {
            CSmartLock spLock(&m_sLk, WriteLock);
            m_iCur = 0;
        
            return S_OK;
        }
        EXIT_API
		}
	
    STDMETHOD(Clone)(IEnumVARIANT **ppenum)
    {
        ENTER_API
        {
            CSmartLock spLock(&m_sLk, ReadLock);
            
            ThisClassETVEC *penum = NewComObject(ThisClassETVEC);
            
            if (penum == NULL)
                return E_OUTOFMEMORY;
            
            penum->Init(m_punk, m_pvecpT);
            penum->m_iCur = m_iCur;
            
            return QueryInterface(IID_IEnumVARIANT, (void **)ppenum);
        }
        EXIT_API
    }

protected:
	CTVESmartLock		m_sLk;

	IUnknown *m_punk;
	VectorPT *m_pvecpT;			// TODO - change this to a copy of the vector, not pointer!
	int m_iCur;
};

// -----------------------------------------------------------------

		// This is a thread safe enumerator.  It copies the collections internal
		//    data structure used to hold objects over so the collection can
		//	  change without affecting the enumerator list.  

template<class T>
class SafeEnumTVECollection :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<IEnumVARIANT, &IID_IEnumVARIANT, &LIBID_MSTvELib>
{
	typedef std::vector<T *>		 VectorPT;
	typedef SafeEnumTVECollection<T> ThisClassSETVE;

public:
    SafeEnumTVECollection()
    {
        m_punk = NULL;
        m_iCur = 0;
    }
    
    ~SafeEnumTVECollection()
    {
        
    }
    
    void FinalRelease()
    {
        
        int iMax = m_vecpT.size();
        for(int i = 0; i < iMax; i++)
        {
            T * pt = m_vecpT.at(i);
            pt->Release();
        }
        if (m_punk != NULL)
            m_punk->Release();
    }
    
    void Init(IUnknown *punk, VectorPT *pvecpT)
    {
        if (m_punk != NULL)
        {
            m_punk->Release();
            m_punk = NULL;
        }
        
        if(NULL == pvecpT) return;
        if (punk != NULL)		// back pointer to containing class
        {
            punk->AddRef();
            m_punk = punk;
        }
        
        //		EnterCriticalSection(&_Module.m_csTypeInfoHolder);		// threadsafe clause...
        {						
            CSmartLock spLock(&m_sLk);
            m_vecpT = *pvecpT;				// Overridden equal operator - copies vector.
            int iMax = m_vecpT.size();
            
            for(int i = 0; i < iMax; i++)	// Now AddRef each of the contained items.
            {
                T * pt = m_vecpT.at(i);
                pt->AddRef();
            }
        }
        //		LeaveCriticalSection(&_Module.m_csTypeInfoHolder);       
        m_iCur = 0;
    }

BEGIN_COM_MAP(ThisClassSETVE)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

	// IEnumUnknown interface
    STDMETHOD(Next)(ULONG celt, VARIANT *pvar, ULONG *pceltFetched)
    {
        ENTER_API
        {
            CSmartLock spLock(&m_sLk);
        
            ULONG celtFetched = 0;
            int iMax = m_vecpT.size();
        
            if(pvar == NULL)
                return E_POINTER;
        
            if((celt > 1) && (pceltFetched == NULL))
                return E_POINTER;
        
            for (ULONG l=0; l < celt; l++)				// needed, else may leak 
                ::VariantClear( &pvar[l] ) ;
        
            while ((m_iCur < iMax) && (celtFetched < celt))
            {
                T * pT = m_vecpT.at(m_iCur++);
                IDispatch *pdispatch;
                pT->QueryInterface(IID_IDispatch, (void **) &pdispatch);
                if(pdispatch) {
                    CComVariant var(pdispatch);
                    *pvar++ = var;
                    celtFetched++;
                } else {				// shouldn't of happened...
                    _ASSERT(false);
                }
            
            }
        
            if (pceltFetched != NULL) 
                *pceltFetched = celtFetched;
        
            return (celtFetched == celt) ? S_OK : S_FALSE;
        }
        EXIT_API
    }
	
	STDMETHOD(Skip)(ULONG celt)
    {
        ENTER_API
        {
            int iCur, iSize;
            
            CSmartLock spLock(&m_sLk);		// be extra threadsafe (Init OK, but m_iCur could change)
            m_iCur += celt;
            iCur = m_iCur;
            iSize = m_vecpT.size();
            
            return (iCur < iSize) ? S_OK : S_FALSE;
        }
        EXIT_API
    }
	
	STDMETHOD(Reset)(void)
    {
        ENTER_API
        {
            CSmartLock spLock(&m_sLk);		// be extra threadsafe (Init OK, but m_iCur could change)
            m_iCur = 0;
            return S_OK;
        }
        EXIT_API
    }
	
	STDMETHOD(Clone)(IEnumVARIANT **ppenum)
    {
        ENTER_API
        {
            ThisClassSETVE *penum = NewComObject(ThisClassSETVE);
            
            if (penum == NULL)
                return E_OUTOFMEMORY;
            
            {
                CSmartLock spLock(&m_sLk);		// be extra threadsafe (Init OK, but m_iCur could change)
                penum->Init(m_punk, &m_vecpT);          
                penum->m_iCur = m_iCur;
            }
            
            // was	//	return QueryInterface(IID_IEnumVARIANT, (void **)ppenum);
            HRESULT hr = penum->QueryInterface(IID_IEnumVARIANT, (void **)ppenum);
            if(!FAILED(hr)) penum->Release();
            return hr;
        }
        EXIT_API
    }

protected:
	IUnknown *m_punk;			// back pointer...
	VectorPT m_vecpT;			// copy of the vector, not pointer!
	int m_iCur;
	CTVESmartLock		m_sLk;
 
};

// ----------------------------------------------------------------
//		TVECollection class
//
//			
//		
// ----------------------------------------------------------------

template<class T, class BaseT>
class TVECollection :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<BaseT, &__uuidof(BaseT), &LIBID_MSTvELib>
{
	typedef std::vector<T *>	 VectorPT;
	typedef TVECollection<T,BaseT> ThisClassTVEC;
//	typedef EnumTVECollection<T> EnumTVECollectionT;		// notso threadsafe version
	typedef SafeEnumTVECollection<T> EnumTVECollectionT;	// threadsafe version

public:
    TVECollection()
    {
        HRESULT hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_spUnkMarshaler.p);
    }
    
    ~TVECollection()
    {
        RemoveAll();
        m_spUnkMarshaler = NULL;
    }
    
    virtual BOOL FOkToRemove(T *pT)
    {
        return TRUE;
    }
	
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(ThisClassTVEC)
	COM_INTERFACE_ENTRY_IID(__uuidof(BaseT), BaseT)
	COM_INTERFACE_ENTRY(IDispatch)
//	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
END_COM_MAP()

	CComPtr<IUnknown> m_spUnkMarshaler;

    STDMETHOD(get__NewEnum)(IUnknown **ppunk)
    {
        ENTER_API
        {
            HRESULT hr;
            ValidateOutPtr<IUnknown *>(ppunk, NULL);
        
            EnumTVECollectionT *penum = NewComObject(EnumTVECollectionT);
            if (penum == NULL)
                return E_OUTOFMEMORY;
        
            penum->Init((IUnknown *)(BaseT *)this, &m_vecpT);               // this copy is internally treadsafe
        
            hr =  penum->QueryInterface(IID_IEnumVARIANT, (void **)ppunk);
            penum->Release();
            return hr;
        }
        EXIT_API
    }
	
    STDMETHOD(get_Count)(long *plCount)
    {
        ENTER_API
        {
            ValidateOutPtr<long>(plCount, 0);
            CSmartLock spLock(&m_sLk, ReadLock);
            
            *plCount = m_vecpT.size();
        }
        EXIT_API
    }

    STDMETHOD(get_Item)(long index, T **ppT )
    {
        ENTER_API
        {	
            ValidateOutPtr<T*>(ppT, NULL);
            CSmartLock spLock(&m_sLk, ReadLock);
            
            if(index < 0 || index >= m_vecpT.size())
                return E_INVALIDARG;
            
            *ppT = m_vecpT[index];
            (*ppT)->AddRef();
        }
        EXIT_API
    }
    
    STDMETHOD(get_Item)(VARIANT var, T **ppT )
    {
        ENTER_API
        {	
            ValidateOutPtr<T *>(ppT, NULL);
            
            *ppT = NULL;
            
            CSmartLock spLock(&m_sLk, ReadLock);
            int iItem;
            HRESULT hr = ItemIndex(var, &iItem);
            if (FAILED(hr))	
                return E_INVALIDARG;
            
            *ppT = m_vecpT[iItem];
            (*ppT)->AddRef();
        }
        EXIT_API
    }

	STDMETHOD(Add)(T *pT)
	{
		ENTER_API
		{
			if(NULL == pT)
				return E_INVALIDARG;

			{					// is it really what we expect it to be?
				T *pT2;
				HRESULT hr = pT->QueryInterface(__uuidof(T), (void **) &pT2);
				if(FAILED(hr)) 
					return hr;
				else
					pT2->Release();
			}
				
			CSmartLock spLock(&m_sLk, ReadLock);
			if (Find(pT) >= 0)
				return S_FALSE;

			spLock.ConvertToWrite();

			m_vecpT.push_back(pT);
			pT->AddRef();
		}
		EXIT_API
	}

    STDMETHOD(Insert)(int iLoc, T *pT)				// inserts before particular location (0 is the front)
    {
        ENTER_API
        {
            if(NULL == pT)							// don't allow null objects to be inserted
                return E_INVALIDARG;
            
            {					// is it really what we expect it to be?
                T *pT2;
                HRESULT hr = pT->QueryInterface(__uuidof(T), (void **) &pT2);
                if(FAILED(hr)) 
                    return hr;
                else
                    pT2->Release();
            }
            
            CSmartLock spLock(&m_sLk, ReadLock);
            
            if (Find(pT) >= 0)
                return S_FALSE;						// already have it... (hope this change doesn't break anything jb 0320)
            if(iLoc < 0 || iLoc > m_vecpT.size()) 
                return E_INVALIDARG;
            VectorPT::iterator iterLoc;
            if(iLoc == 0)
                iterLoc = m_vecpT.begin();
            if(iLoc >= m_vecpT.size())				// insert at end
                iterLoc = m_vecpT.end();
            else {
                for(iterLoc = m_vecpT.begin(); iLoc > 0; iterLoc++)
                    --iLoc;
            }
            
            spLock.ConvertToWrite();
            
            m_vecpT.insert(iterLoc, pT);
            pT->AddRef();
        }
        EXIT_API
    }
    
    STDMETHOD(Add)(IUnknown *punk)
    {
        ENTER_API
        {
            HRESULT hr;
            T *pT;
            
            hr = punk->QueryInterface(__uuidof(T), (void **) &pT);
            if(FAILED(hr)) return hr;
            
            {
                CSmartLock spLock(&m_sLk, WriteLock);
                hr = Add(pT);
            }
            pT->Release();
            return hr;
        }
        EXIT_API
    }
    
    STDMETHOD(Remove)(VARIANT var)
    {
        ENTER_API
        {
            int iRemove;
            CSmartLock spLock(&m_sLk, WriteLock);       // wrap ItemIndex with WriteLock, cause use value to modify struct
            HRESULT hr = ItemIndex(var, &iRemove);
            if (FAILED(hr))
                return E_INVALIDARG;
            
            return Remove(iRemove);
        }
        EXIT_API
    }
	
    STDMETHOD(Item)(VARIANT var, T **ppT)
    {
        ENTER_API
        {
            ValidateOutPtr<T *>(ppT, NULL);
            
            CSmartLock spLock(&m_sLk, ReadLock);
            
            int iItem;
            HRESULT hr = ItemIndex(var, &iItem);
            if (FAILED(hr))	
                return E_INVALIDARG;
            
            *ppT = m_vecpT[iItem];
            (*ppT)->AddRef();
        }
        EXIT_API
    }
    
    HRESULT ItemIndex(VARIANT varIn, int *piItem)
    {
        HRESULT hr;
        CComVariant var(varIn);
        int iItem = -1;
        
        CSmartLock spLock(&m_sLk, ReadLock);
        
        switch (var.vt)
        {
        case VT_EMPTY:
            return E_INVALIDARG;
            
        case VT_UNKNOWN:
        case VT_DISPATCH:
            T *pT;
            
            hr = var.punkVal->QueryInterface(__uuidof(T), (void **)&pT);
            if (FAILED(hr))
                return hr;
            
            iItem = Find(pT);
            pT->Release();
            break;
            
        default:
            var.ChangeType(VT_I4);
            
            iItem = var.lVal;
            break;
        }
        
        
        if ((iItem < 0) || (iItem >= m_vecpT.size()))
            return E_INVALIDARG;
        
        *piItem = iItem;
        return S_OK;
    }
	
    int Find(T *pT)
    {	
        _ASSERT(NULL != pT);
        if(NULL == pT)			// invalid value
            return -1;
        
        int iMax = m_vecpT.size();
        if(0 == iMax)
            return -1;
        
        CComQIPtr<IUnknown, &IID_IUnknown> spUnkT(pT);
        IUnknownPtr spUnkT2(pT);							// DONOW - remove
        _ASSERT(spUnkT2 == spUnkT);
        
        for(int i = 0; i < iMax; i++)
        {	
            T* pTi = m_vecpT[i];
            if(pTi == pT)
                return i;
            
            CComQIPtr<IUnknown, &IID_IUnknown> spUnkTi(pTi);
            IUnknownPtr spUnkT2i(pTi);
            
            _ASSERT(spUnkT2i == spUnkTi);					// DONOW - remove
            if (spUnkTi == spUnkT)
                return i;
            
            if (spUnkT2i == spUnkT2)						// DONOW - remove
                return i;
        }
        
        return -1;
    }
    
    HRESULT Remove(T *pT)
    {
        int iItem = Find(pT);
        if (iItem < 0)
            return E_INVALIDARG;
        
        return Remove(iItem);
    }
    
    HRESULT Remove(int iItem)
    {
        
        if(iItem < 0 || iItem >= m_vecpT.size())
            return E_INVALIDARG;
        
        T *pT = m_vecpT[iItem];
        
        if (!FOkToRemove(pT))
            return E_FAIL;
        
        m_vecpT.erase(m_vecpT.begin() + iItem);
        pT->Release();
        
        return S_OK;
    }

    STDMETHOD(RemoveAll)()
    {
        // Need to be carefull.  If the elements hold IUnknown pointers back to
        // the container. Releasing the element count cause the container's ref
        // count to drop to zero.  The container would then delete this Collection,
        // causing RemoveAll to be called again.
        // To handle this, we must clone the collection.
        CSmartLock spLock(&m_sLk, WriteLock);
        
        int iMax = m_vecpT.size();
        
        if (iMax > 0)
        {
            VectorPT vecpT;
            
            //			vecpT.Copy(m_vecpT);			<CArray version>
            //			m_vecpT.RemoveAll();
            
            vecpT = m_vecpT;
            m_vecpT.erase(m_vecpT.begin(), m_vecpT.end());
            
            for (int iItem = 0; iItem < iMax; iItem++)
            {
                T *&pT = vecpT[iItem];
                
                pT->Release();
                pT = NULL;
            }
            
        }
        return S_OK;
    }

	VectorPT m_vecpT;						// base collection object..

private:
	CTVESmartLock		m_sLk;
 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveenhans.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEEnhancements.h : Declaration of the CTVEEnhancements

#ifndef __TVEENHANCEMENTS_H_
#define __TVEENHANCEMENTS_H_

#include "resource.h"       // main symbols
#include "TVECollect.h"


/////////////////////////////////////////////////////////////////////////////
// CTVEEnhancements
class CTVEEnhancements : public TVECollection<ITVEEnhancement, ITVEEnhancements>,
	public ISupportErrorInfo
{
public:
	DECLARE_REGISTRY_RESOURCEID(IDR_TVEENHANCEMENTS);
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

#endif //__TVEENHANCEMENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveevent.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEEvent.cpp : Implementation of CTVEEvent
#include "stdafx.h"
#include "MSTvE.h"
#include "TVEEvent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CTVEEvent

STDMETHODIMP CTVEEvent::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEEvent
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveevent.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEEvent.h : Declaration of the CTVEEvent

#ifndef __TVEEVENT_H_
#define __TVEEVENT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CTVEEvent
class ATL_NO_VTABLE CTVEEvent : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTVEEvent, &CLSID_TVEEvent>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CTVEEvent>,
	public IDispatchImpl<ITVEEvent, &IID_ITVEEvent, &LIBID_MSTvELib>
{
public:
	CTVEEvent()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVEEVENT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVEEvent)
	COM_INTERFACE_ENTRY(ITVEEvent)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CTVEEvent)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ITVEEvent
public:
};

#endif //__TVEEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvecontr.cpp ===
\\ this is a totally bogus file..  It should be removed
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveenhan.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEEnhancement.cpp : Implementation of CTVEEnhancement
#include "stdafx.h"
#include "MSTvE.h"
#include "TVEEnhan.h"
#include "TVETrack.h"
#include "TVETrigg.h"

#include "TVECBFile.h"		// callback objects
#include "TVECBTrig.h"
#include "TVECBDummy.h"

#include "TveDbg.h"
#include "..\Common\isotime.h"		// time printing code

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ABS(x)  (((x)<0)?-(x):(x))
#define MAX(a,b) (((a) < (b)) ? (b) : (a))

_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,			__uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(ITVECBFile,				__uuidof(ITVECBFile));
_COM_SMARTPTR_TYPEDEF(ITVECBTrig,				__uuidof(ITVECBTrig));
_COM_SMARTPTR_TYPEDEF(ITVECBDummy,				__uuidof(ITVECBDummy));

_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancements,			__uuidof(ITVEEnhancements));
_COM_SMARTPTR_TYPEDEF(ITVEVariations,			__uuidof(ITVEVariations));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEVariation_Helper,		__uuidof(ITVEVariation_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrack,				__uuidof(ITVETrack));
_COM_SMARTPTR_TYPEDEF(ITVETrack_Helper,			__uuidof(ITVETrack_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,				__uuidof(ITVETrigger));
_COM_SMARTPTR_TYPEDEF(ITVETrigger_Helper,		__uuidof(ITVETrigger_Helper));

static DATE 
DateNow()
{		SYSTEMTIME SysTimeNow;
		GetSystemTime(&SysTimeNow);									// initialize with currrent time.
		DATE dateNow;
		SystemTimeToVariantTime(&SysTimeNow, &dateNow);
		return dateNow;
}

/////////////////////////////////////////////////////////////////////////////
// CTVEEnhancement_Helper

HRESULT	
CTVEEnhancement::FinalRelease()
{
	HRESULT hr;
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::FinalRelease"));
	m_pService = NULL;								// null out the up pointer
	m_spVariationBase = NULL;						// release the base variation

	if(m_spVariations) {							// kill all childrens up pointers that ref this
		long cVariations;
		hr = m_spVariations->get_Count(&cVariations);
		if(S_OK == hr)
		{
			for(long i = 0; i < cVariations; i++)
			{
				CComVariant var(i);
				ITVEVariationPtr spVariation;
				hr = m_spVariations->get_Item(var, &spVariation);			// does AddRef!  - 1 base?

				if(S_OK == hr)
				{
					CComQIPtr<ITVEVariation_Helper> spVariationHelper = spVariation;
					spVariationHelper->ConnectParent(NULL);
				}
			}
		}
	}
	m_spVariations = NULL;							// release all variations in the enhancement
	m_spamAttributes = NULL;
	m_spamEmailAddresses = NULL;
	m_spamPhoneNumbers = NULL;

	m_spUnkMarshaler = NULL;
	return S_OK;
}


STDMETHODIMP CTVEEnhancement::ConnectParent(ITVEService *pService)
{
	if(!pService) return E_POINTER;
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::ConnectParent"));
	CSmartLock spLock(&m_sLk);

	m_pService = pService;			// not smart pointer add ref here, I hope.
	return S_OK;
}


					// this method expects caller to be holding on to a reference to this object... 
STDMETHODIMP CTVEEnhancement::RemoveYourself()
{

	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::RemoveYourself"));

    try {
	    CSmartLock spLock(&m_sLk);

	    if(NULL == m_pService) {	// not connected, can't do anything 
		    return S_OK;
	    }

	    ITVEEnhancementPtr		spEnhancementThis(this);
	    IUnknownPtr				spUnkSuper;

	    hr = m_pService->get_Parent(&spUnkSuper);
	    if(FAILED(hr) || NULL == spUnkSuper)
		    return E_FAIL;		// bad state

	    ITVESupervisor_HelperPtr	spSuperHelper(spUnkSuper);

								    // remove any files in the expire queue that reference this enhancement
								    //   remove any triggers that ref this enhancement too...
	    {
		    ITVEService_HelperPtr	spServiHelper(m_pService);
		    spServiHelper->RemoveEnhFilesFromExpireQueue(spEnhancementThis);
	    }

	    hr = Deactivate();			// remove all the variations that talk to this enhancement
	    _ASSERT(!FAILED(hr));
								    
								    // remove the ref counted link to this enhancement down from parent service
	    ITVEEnhancementsPtr				spEnhancements;
	    hr = m_pService->get_Enhancements(&spEnhancements);	
	    if(S_OK == hr && NULL != spEnhancements)
	    {
    //		CComVariant			        cvThis(spEnhancementThis);		// not working, made it a BOOL type???
		    IUnknownPtr					spPunkThis(spEnhancementThis);
		    CComVariant			        cvThis((IUnknown *) spPunkThis);

		    if(spEnhancements)
			    hr = spEnhancements->Remove(cvThis);	
	    }
	    
								    // tell client this enhancement went away  (do after the Remove above, so U/I won't see it.)

	    if(NULL != spSuperHelper) {
		    spSuperHelper->NotifyEnhancement(NENH_Expired, spEnhancementThis, 0);
	    }


	    m_pService = NULL;			// Finally, NULL out the non ref-counted up pointer
	} catch (_com_error e) {
        hr = e.Error();
 	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}


STDMETHODIMP CTVEEnhancement::DumpToBSTR(BSTR *pBstrBuff)
{
	HRESULT hr = S_OK;
	try 
	{
		CheckOutPtr<BSTR>(pBstrBuff);

		const int kMaxChars = 1024;
		TCHAR tBuff[kMaxChars];
		CComBSTR bstrOut;
		CComBSTR spbstrTmp;
		bstrOut.Empty();

		bstrOut.Append(_T("Enhancement:\n"));
		_stprintf(tBuff,_T("Description      : %s\n"),m_spbsDescription);		bstrOut.Append(tBuff);
		_stprintf(tBuff,_T("IsPrimary        : %s\n"),m_fIsPrimary ? L"TRUE" : L"false"); bstrOut.Append(tBuff);
		_stprintf(tBuff,_T("Protocol Version : %s\n"),m_spbsProtocolVersion);   bstrOut.Append(tBuff);
		_stprintf(tBuff,_T("Session UserName : %u\n"),m_spbsSessionUserName);	bstrOut.Append(tBuff);
		_stprintf(tBuff,_T("Session ID       : %u\n"),m_ulSessionId);			bstrOut.Append(tBuff);
		_stprintf(tBuff,_T("Session Version  : %u\n"),m_ulSessionVersion);		bstrOut.Append(tBuff);
		_stprintf(tBuff,_T("Session IP Addr  : %s\n"),m_spbsSessionIPAddress);	bstrOut.Append(tBuff);
		_stprintf(tBuff,_T("Session Name     : %s\n"),m_spbsSessionName);		bstrOut.Append(tBuff);

		spbstrTmp.Empty();
		m_spamEmailAddresses->DumpToBSTR(&spbstrTmp);
		_stprintf(tBuff,_T("EMail Addresses  : %s\n"),spbstrTmp);				bstrOut.Append(tBuff); 
		spbstrTmp.Empty();
		m_spamPhoneNumbers->DumpToBSTR(&spbstrTmp);
		_stprintf(tBuff,_T("Phone Numbers    : %s\n"),spbstrTmp);				bstrOut.Append(tBuff);
	//
		_stprintf(tBuff,_T("UUID             : %s\n"),m_spbsUUID);				bstrOut.Append(tBuff);
 		_stprintf(tBuff,_T("Start Time       : %s (%s)\n"),
				DateToBSTR(m_dateStart), DateToDiffBSTR(m_dateStart));		bstrOut.Append(tBuff);
		_stprintf(tBuff,_T("Stop Time        : %s (%s)\n"),
				DateToBSTR(m_dateStop), DateToDiffBSTR(m_dateStop));		bstrOut.Append(tBuff);
	// tve-typeAttributes
		_stprintf(tBuff,_T("Type             : %s\n"),m_spbsType);				bstrOut.Append(tBuff);
		_stprintf(tBuff,_T("tve-type         : %s\n"),m_spbsTveType);			bstrOut.Append(tBuff);
		_stprintf(tBuff,_T("tve-Size         : %d\n"),m_ulTveSize);				bstrOut.Append(tBuff);
		_stprintf(tBuff,_T("tve-Level        : %-5.1f\n"),m_rTveLevel);			bstrOut.Append(tBuff);
		long cAttr;
		m_spamAttributes->get_Count(&cAttr);
		spbstrTmp.Empty();
		m_spamAttributes->DumpToBSTR(&spbstrTmp);
		_stprintf(tBuff,_T("(%3d) Attributes : %s\n"),cAttr,spbstrTmp);         bstrOut.Append(tBuff);

		spbstrTmp.Empty();
		m_spamRest->DumpToBSTR(&spbstrTmp);
		_stprintf(tBuff,_T("** Rest **       : %s\n ---------------\n"),spbstrTmp);	     		bstrOut.Append(tBuff);

		{
			bstrOut.Append(_T("--- Base Variation --- \n"));
			CComQIPtr<ITVEVariation_Helper> spVariationBaseHelper = m_spVariationBase;
			if(!spVariationBaseHelper) {
				bstrOut.Append(_T("*** Error in Base Variation\n"));
			} else {
				CComBSTR bstrVariationBase;
				spVariationBaseHelper->DumpToBSTR(&bstrVariationBase);
				bstrOut.Append(bstrVariationBase);
			}
		}

		if(NULL == m_spVariations) {
			_stprintf(tBuff,_T("<<< Uninitialized Variations >>>\n"));
			bstrOut.Append(tBuff);
		} else {
			long cVariations;
			m_spVariations->get_Count(&cVariations);	
			_stprintf(tBuff,_T("--- %d Variations ---\n"), cVariations);
			bstrOut.Append(tBuff);

			for(long i = 0; i < cVariations; i++)
			{
				_stprintf(tBuff,_T("Variation %d\n"), i);
				bstrOut.Append(tBuff);

				CComVariant var(i);
				ITVEVariationPtr spVariation;
				hr = m_spVariations->get_Item(var, &spVariation);			// does AddRef!  - 1 base?

				if(S_OK == hr)
				{
					CComQIPtr<ITVEVariation_Helper> spVariationHelper = spVariation;
					if(!spVariationHelper) {bstrOut.Append(_T("*** Error in Variation\n")); break;}

					CComBSTR bstrVariation;
					spVariationHelper->DumpToBSTR(&bstrVariation);
					bstrOut.Append(bstrVariation);
				} else {
					bstrOut.Append(_T("*** Invalid, wasn't able to get_Item on it\n"));
				}
			}
		}

		bstrOut.CopyTo(pBstrBuff);
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CTVEEnhancement

STDMETHODIMP CTVEEnhancement::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_ITVEEnhancement,
		&IID_ITVEEnhancement_Helper

	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CTVEEnhancement::FinalConstruct()
{												// create variation list
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::FinalConstruct"));
	hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_spUnkMarshaler.p);
	if(FAILED(hr)) {
		_ASSERT(!FAILED(hr));
		return hr;
	}

	CComObject<CTVEVariations> *pVariations;
	hr = CComObject<CTVEVariations>::CreateInstance(&pVariations);
	if(FAILED(hr))
		return hr;
	hr = pVariations->QueryInterface(&m_spVariations);			// typesafe QI
	if(FAILED(hr)) {
		delete pVariations;
		return hr;
	}

	CComObject<CTVEAttrMap> *pMap;
	hr = CComObject<CTVEAttrMap>::CreateInstance(&pMap);
	if(FAILED(hr))
		return hr;
	hr = pMap->QueryInterface(&m_spamAttributes);			// typesafe QI
	if(FAILED(hr)) {
		delete pMap;
		return hr;
	}

	CComObject<CTVEAttrMap> *pMap1;
	hr = CComObject<CTVEAttrMap>::CreateInstance(&pMap1);
	if(FAILED(hr))
		return hr;
	hr = pMap1->QueryInterface(&m_spamRest);					// typesafe QI
	if(FAILED(hr)) {
		delete pMap1;
		return hr;
	}

	CComObject<CTVEAttrMap> *pMap2;
	hr = CComObject<CTVEAttrMap>::CreateInstance(&pMap2);
	if(FAILED(hr))
		return hr;
	hr = pMap2->QueryInterface(&m_spamEmailAddresses);			// typesafe QI
	if(FAILED(hr)) {
		delete pMap2;
		return hr;
	}

	CComObject<CTVEAttrMap> *pMap3;
	hr = CComObject<CTVEAttrMap>::CreateInstance(&pMap3);
	if(FAILED(hr))
		return hr;
	hr = pMap3->QueryInterface(&m_spamPhoneNumbers);			// typesafe QI
	if(FAILED(hr)) {
		delete pMap3;
		return hr;
	}
						// can't do it this way.  Doesn't work in multi-threaded creation
						//   (Calls CoCreateInstance, which uses OLE, which needs OleInitialize on each thread)
/*
	ITVEAttrMapPtr spAttrMap = ITVEAttrMapPtr(CLSID_TVEAttrMap);
	if(NULL == spAttrMap) {
		m_spamAttributes = NULL;	
		return E_OUTOFMEMORY;
	} else {		
		m_spamAttributes = spAttrMap;
	}

	ITVEAttrMapPtr spAttrMap2 = ITVEAttrMapPtr(CLSID_TVEAttrMap);
	if(NULL == spAttrMap) {
		m_spamEmailAddresses = NULL;	
		return E_OUTOFMEMORY;
	} else {		
		m_spamEmailAddresses = spAttrMap2;
	}

	ITVEAttrMapPtr spAttrMap3 = ITVEAttrMapPtr(CLSID_TVEAttrMap);
	if(NULL == spAttrMap) {
		m_spamPhoneNumbers = NULL;	
		return E_OUTOFMEMORY;
	} else {		
		m_spamPhoneNumbers = spAttrMap3;
	}
*/
					// create base variation (holds the default media parameters)
/*		ITVEVariationPtr spVariation = ITVEVariationPtr(CLSID_TVEVariation);
	if(NULL == spVariation)
	{
		m_spVariations = NULL;	
		return E_OUTOFMEMORY;
	} */
	CComObject<CTVEVariation> *pVariation;
	hr = CComObject<CTVEVariation>::CreateInstance(&pVariation);
	if(FAILED(hr)) {
		m_spVariations = NULL;
		return hr;
	}
	hr = pVariation->QueryInterface(&m_spVariationBase);			// typesafe QI
	if(FAILED(hr)) {
		delete pVariation;
		m_spVariations = NULL;
		return hr;
	}

	m_spVariationBase->put_Description(L"Default Variation");

//		spVariation->put_Description(L"Default Variation");
//		m_spVariationBase = spVariation;											
//		spVariation->Release();
	
	return hr;
}



			// return Addref'ed pointer to parent.  (Note m_pService is not add Refed.)
			//		there is a small possibility that this object is bogus if 
			//		tree is deleted in wrong order.

STDMETHODIMP CTVEEnhancement::get_Parent(IUnknown **ppVal)
{
	HRESULT hr = S_OK;

    try {
		CheckOutPtr<IUnknown *>(ppVal);
		if(m_pService) {
			IUnknownPtr spPunk(m_pService);
			spPunk->AddRef();
			*ppVal = spPunk;	
		}
		else 
			*ppVal = NULL;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
		hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP CTVEEnhancement::get_Service(ITVEService **ppVal)		// service is parent
{
    HRESULT hr = S_OK;
    
    try {
        CheckOutPtr<ITVEService *>(ppVal);
        if(m_pService) {
            m_pService->AddRef();
            *ppVal = m_pService;	
        }
        else 
            *ppVal = NULL;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_Variations(ITVEVariations **ppVal)
{

	HRESULT hr;
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::get_Variations"));

	try 
	{
		CheckOutPtr<ITVEVariations *>(ppVal);
		CSmartLock spLock(&m_sLk);
		if(NULL == m_spVariations)					// bad thing happened...
			return E_UNEXPECTED;
		hr = m_spVariations->QueryInterface(ppVal);
    } catch(_com_error e) {
        hr = e.Error();
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
    } catch (...) 	{
		return E_UNEXPECTED;
	}
	return hr;
}


void CTVEEnhancement::Initialize(BSTR strDesc)
{
//	m_spbsDescription = strDesc;
	m_dateStart = 0;
	m_dateStop = 0;
	m_fDataMedia = false;
	m_fIsPrimary = false;
	m_fIsValid = false;
	m_fTriggerMedia = false;
	m_pService = NULL;				// up pointer!
	m_rTveLevel = 0;

	m_spamAttributes->RemoveAll();
	m_spamRest->RemoveAll();
	m_spamEmailAddresses->RemoveAll();
	m_spamPhoneNumbers->RemoveAll();

	m_spbsSessionUserName.Empty();
	m_spbsSessionIPAddress.Empty();
	m_spbsProtocolVersion.Empty();

	m_spbsSAPSendingIP.Empty();
	m_spbsSessionName.Empty();
	m_spbsTveType.Empty();
	m_spbsType.Empty();
	m_spbsUUID.Empty();
	m_spVariationBase->Initialize(L"");
	m_spVariations->RemoveAll();
	m_ucSAPAuthLength = 0;
	m_ucSAPHeaderBits = 0;
	m_ulSessionId = 0;
	m_ulSessionVersion = 0;
	m_ulTveSize = 0;
	m_usSAPMsgIDHash = 0;


}

// --------------------------------------------------------------------------

STDMETHODIMP CTVEEnhancement::get_IsValid(VARIANT_BOOL *pVal)
{
    HRESULT hr = S_OK;
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    
    try {
        CheckOutPtr<VARIANT_BOOL>(pVal);
        *pVal = m_fIsValid ? VARIANT_TRUE : VARIANT_FALSE;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

// from the SAP header

STDMETHODIMP CTVEEnhancement::get_SAPHeaderBits(short *pVal)
{
    HRESULT hr = S_OK;
    
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    
    try {
        CheckOutPtr<short>(pVal);
        *pVal = (short) m_ucSAPHeaderBits;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_SAPAuthLength(short *pVal)
{
    HRESULT hr = S_OK;
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    
    try {
        CheckOutPtr<short>(pVal);
        *pVal = (short) m_ucSAPAuthLength;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}	

STDMETHODIMP CTVEEnhancement::get_SAPAuthData(BSTR *pVal)
{
    HRESULT hr = S_OK;
    
    try {
        CheckOutPtr<BSTR>(pVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsSAPAuthData.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}
STDMETHODIMP CTVEEnhancement::get_SAPMsgIDHash(LONG *pVal)
{
    HRESULT hr = S_OK;
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    
    try {
        CheckOutPtr<long>(pVal);
        *pVal = (long) m_usSAPMsgIDHash;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_SAPSendingIP(BSTR *pVal)
{
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsSAPSendingIP.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}




STDMETHODIMP CTVEEnhancement::get_ProtocolVersion(BSTR *pVal)
{
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsProtocolVersion.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED; ;
    }
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_SessionUserName(BSTR *pVal)			// o=userName SID version <IN IP4> ipaddress
{
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsSessionUserName.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED; ;
    }
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_SessionId(LONG *plVal)
{
    HRESULT hr = S_OK;
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    
    try {
        CheckOutPtr<LONG>(plVal);
        *plVal = (LONG) m_ulSessionId;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_SessionVersion(LONG *plVal)
{
    HRESULT hr = S_OK;
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    try {
        CheckOutPtr<LONG>(plVal);
        *plVal = (LONG) m_ulSessionVersion;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_SessionIPAddress(BSTR *pVal)
{
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsSessionIPAddress.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_SessionName(BSTR *pVal)
{
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsSessionName.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_EmailAddresses(ITVEAttrMap **ppVal)
{
    HRESULT hr = S_OK;
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    
    try {
        CheckOutPtr<ITVEAttrMap *>(ppVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spamEmailAddresses->QueryInterface(ppVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_PhoneNumbers(ITVEAttrMap **ppVal)
{
    HRESULT hr = S_OK;
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    
    try {
        CheckOutPtr<ITVEAttrMap *>(ppVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spamPhoneNumbers->QueryInterface(ppVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_Description(BSTR *pVal)
{
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsDescription.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEEnhancement::put_Description(BSTR newVal)
{
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::put_Description"));
    m_spbsDescription = newVal;
    return S_OK;
}

STDMETHODIMP CTVEEnhancement::get_DescriptionURI(BSTR *pVal)
{
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsDescriptionURI.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}
STDMETHODIMP CTVEEnhancement::get_UUID(BSTR *pVal)
{
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsUUID.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_StartTime(DATE *pVal)
{
    HRESULT hr = S_OK;
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    
    try {
        CheckOutPtr<DATE>(pVal);
        *pVal = m_dateStart;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}
STDMETHODIMP CTVEEnhancement::get_StopTime(DATE *pVal)
{
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
    
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<DATE>(pVal);
        *pVal = m_dateStop;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_Type(BSTR *pVal)
{
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsType.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEEnhancement::get_TveType(BSTR *pVal)
{
    HRESULT hr = S_OK;
    
    try {
        CheckOutPtr<BSTR>(pVal);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsTveType.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}


STDMETHODIMP CTVEEnhancement::get_IsPrimary(VARIANT_BOOL *pVal)
{
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
	HRESULT hr = S_OK;
    try {
		CheckOutPtr<VARIANT_BOOL>(pVal);
         *pVal = m_fIsPrimary ? VARIANT_TRUE : VARIANT_FALSE;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
	return hr;
}

// tveTypeAttributes (list of BSTR pairs)
STDMETHODIMP CTVEEnhancement::get_TveSize(LONG *plVal)
{
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
	HRESULT hr = S_OK;
    try {
		CheckOutPtr<LONG>(plVal);
        *plVal = m_ulTveSize;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP CTVEEnhancement::get_TveLevel(double *pVal)
{
	HRESULT hr = S_OK;
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }

    try {
		CheckOutPtr<double>(pVal);
         *pVal = m_rTveLevel;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
	return hr;
}


STDMETHODIMP CTVEEnhancement::get_Attributes(ITVEAttrMap **ppVal)
{
	HRESULT hr = S_OK;
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
	try {
		CheckOutPtr<ITVEAttrMap *>(ppVal);
		hr = m_spamAttributes->QueryInterface(ppVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
	return hr;
}


STDMETHODIMP CTVEEnhancement::get_Rest(ITVEAttrMap **ppVal)
{
	HRESULT hr = S_OK;

    try {
		CheckOutPtr<ITVEAttrMap *>(ppVal);
		hr = m_spamRest->QueryInterface(ppVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
	return hr;
}

// ---------------------------------------------------------------------------

#define VERIFY_EMPTY(bstr) //{ if(!(NULL == bstr)) return E_INVALIDARG; }


// todo -
//		allow SAP delete messages
//		allow non-zero auth lengths 


HRESULT
CTVEEnhancement::ParseSAPHeader(const BSTR *pbstrSDP, DWORD *pcWordsSAP, long *plgrfParseError)
{
	*pcWordsSAP = 0;			// note - data expanded to WCHAR's before this, hence don't use BYTES here

	WCHAR *pwRead = (WCHAR *) *pbstrSDP;

	m_ucSAPHeaderBits = (BYTE) *pwRead; pwRead++;
	m_ucSAPAuthLength = (BYTE) *pwRead; pwRead++;		// number of 32bit words that contain Auth data
	m_usSAPMsgIDHash = (USHORT) (*pwRead | ((*(pwRead+1))<<8));  pwRead+=2;
	ULONG ulSAPSendingIP = *(pwRead+0) | ((*(pwRead+1))<<8) | ((*(pwRead+2))<<16)| ((*(pwRead+3))<<24);
	WCHAR wszBuff[64];
	swprintf(wszBuff,L"%d.%d.%d.%d",*(pwRead+0),*(pwRead+1),*(pwRead+2),*(pwRead+3)); pwRead+=4;
	m_spbsSAPSendingIP = wszBuff;

	SAPHeaderBits SAPHead;
	SAPHead.uc = m_ucSAPHeaderBits;

	if(SAPHead.s.Version	    != 1) *plgrfParseError |= NENH_grfSAPVersion;					// must be 1.
	if(SAPHead.s.AddressType	!= 0) *plgrfParseError |= NENH_grfSAPAddressType;				// IPv4 (not IPv6)
	if(SAPHead.s.Reserved		!= 0) *plgrfParseError |= NENH_grfSAPOther;						// must be zero for senders
	if(SAPHead.s.MessageType	!= 0) *plgrfParseError |= NENH_grfSAPOther;						// session announcement packet (not delete packet)
	if(SAPHead.s.Encrypted		!= 0) *plgrfParseError |= NENH_grfSAPEncryptComp;				// not  encrypted
	if(SAPHead.s.Compressed 	!= 0) *plgrfParseError |= NENH_grfSAPEncryptComp;				// not ZLIB compressed

	if(*plgrfParseError	!= 0)		
		return E_INVALIDARG;

	m_spbsSAPAuthData.Empty();
	if(m_ucSAPAuthLength != 0)					// can't handle this yet (encryted or compressed)
	{
		CComBSTR bstrTmp(m_ucSAPAuthLength/2+2);		// byte data expanded into WCHAR's, need to coompress it here.
		WCHAR *pTmp = &bstrTmp[0];
		BYTE *pszTmp = (BYTE *) pTmp;
		for(int i = 0; i < m_ucSAPAuthLength; i++)
		{
			*pszTmp++ = (BYTE) *pwRead++;
		}
		*pszTmp++ = 0;			// null terminate for the shear thrill of it...
		*pszTmp = 0;			// do it again in case of odd length string


		m_spbsSAPAuthData.Append(bstrTmp, m_ucSAPAuthLength/2+1);					// SAP authorization data
 
		*plgrfParseError |= NENH_grfSAPOther;
//		return E_INVALIDARG;	
	} 

//	if(m_usSAPMsgIDHash == 0)					// according to the SAP-v2-02 spec, this is ok
//		return E_INVALIDARG;

	/*TCHAR tBuff[512];

	_stprintf(tBuff,_T("SAP Header (%02x %02x %02x %02x %08x)\n"),
		*(pcRead), *(pcRead+1),*(pcRead+2), *(pcRead+3), *(((int*) pcRead)+1) );
	spbsOut.Append(tBuff);
	_stprintf(tBuff,_T("   SAP Version      : %d\n"),(*pcRead)>>4); 	spbsOut.Append(tBuff);
	_stprintf(tBuff,_T("   ???        (bit3): %d\n"),((*pcRead)>>3) & 0x1); 	spbsOut.Append(tBuff);
	_stprintf(tBuff,_T("   Delete     (bit2): %d\n"),((*pcRead)>>2) & 0x1); 	spbsOut.Append(tBuff);
	_stprintf(tBuff,_T("   Encrypted  (bit1): %d\n"),((*pcRead)>>1) & 0x1); 	spbsOut.Append(tBuff);
	_stprintf(tBuff,_T("   Compressed (bit0): %d\n"),((*pcRead)>>0) & 0x1); 	spbsOut.Append(tBuff);
	pcRead++;
	_stprintf(tBuff,_T("   Auth Header      : %d\n"),*pcRead);					spbsOut.Append(tBuff);
	pcRead++;
	_stprintf(tBuff,_T("   MsgIDHash        : 0x%04x\n"),*pcRead | ((*(pcRead+1))<<8)); spbsOut.Append(tBuff);
	pcRead += 2;

	_stprintf(tBuff,_T("   Sending IP       : %u.%u.%u.%u  (0x%8x)\n"),
		*(pcRead+0),*(pcRead+1),*(pcRead+2),*(pcRead+3), *((int*) pcRead));
	spbsOut.Append(tBuff);
*/
	*pcWordsSAP = 8 + m_ucSAPAuthLength;
	return S_OK;
}

// -------------------------------------------------------------------------------
// CTVEEnhancement::ParseAnnouncement
// parses announcement - creating enhancement and set of variations this is the biggie..
//
//		bstrIPAdapter is the IP adapter to read the trigger and file data on for all medias (variations)
//		Currently, this assumes both trigger and file data are coming over the same adapter
//				   this could be changed if later if need to...
//		pbstrSDP is the announcement string to parse...
//

STDMETHODIMP
CTVEEnhancement::ParseAnnouncement(BSTR bstrIPAdapter, const BSTR *pbstrSDP, long *plgrfParseError, long *plLineError)		// pbstrSDP not really const here, modifies strings, but does restore them
{
	HRESULT hrTotal = S_OK;
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::ParseAnnouncement"));

	try 
	{
		CheckOutPtr<long>(plgrfParseError);
		CheckOutPtr<long>(plLineError);

		CComBSTR spbsErrorBuff;							// error buffer

		HRESULT hr;
		int  iLineNumber = 1;							// line number being parsed - for error messages
		BOOL fInMediaSection = false;					// set to true on first 'm=' field
		long lgrfParseError = 0;

		*plLineError = 0;
		*plgrfParseError = 0;

		m_fIsValid = false;

		CComBSTR spbsDes = m_spbsDescription;
		Initialize(spbsDes.m_str);						//	clean out all the existing values					

		DWORD cWordsSAP;		// number of bytes in SAP header (usually 8 for ATVEF)
		hr = ParseSAPHeader(pbstrSDP, &cWordsSAP, &lgrfParseError);
		if(FAILED(hr)) {
			ATLTRACE("*** Error *** Invalid SAP Header\n");
			return hr;
		}


		wchar_t *wszSDP = *pbstrSDP;
		wszSDP += cWordsSAP;							// skip this junk...

			// announcement must start with 'v=0' field
		if ((0 != wcsncmp(wszSDP, kbstrSDPVersion,  wcslen(kbstrSDPVersion) )) &&	// "v=0\n"
			(0 != wcsncmp(wszSDP, kbstrSDPVersionCR, wcslen(kbstrSDPVersionCR)) )) 	// "v=0\r"
		{
			lgrfParseError |= NENH_grfProtocolVersion;
			return E_INVALIDARG;
		}

			// must be of atvef type			(??? do this here or later ???)
		if (NULL == wcsstr(wszSDP, kbstrATVEFTypeTVE))			// "a=type:tve"  - search for anywhere in string
		{
 			lgrfParseError |= NENH_grfTveType;
			return E_INVALIDARG;
		}

		ITVEVariationPtr spVariation;						// changes to non-base on first m= field
		spVariation = m_spVariationBase;
		BOOL fMissingMedia = false;

			// parse substrings...
		while (*wszSDP)
		{
			hr = S_OK;
			while(wszSDP && iswspace(*wszSDP)) wszSDP++;	// skip spaces before keyword. caution - standard may not want this fix

			wchar_t *wszArgStart = wszSDP;					// get the 'x=' part too.
			wchar_t wchCmd = *wszSDP++;						// keyword
			wchar_t *wszArg = wszSDP;						// "=<value>' ...

			wchar_t *wszNL = wcschr(wszSDP, '\n');			// find the <CR> that terminates each field
			BOOL fCRLF = false;

			if (wszNL != NULL)								// if found <CR>, null it out..
			{
				*wszNL = '\0';					
				if ((wszNL > wszSDP) && (wszNL[-1] == '\r'))	// Ignore CR immediately before LF
				{
					fCRLF = true;
					wszNL[-1] = '\0';
				}
				wszSDP = wszNL + 1;							// bounce wszSDP to end of this field
				if (*wszSDP == '\r')						// Ignore CR immediately after LF
					wszSDP++;
			}

			if (*wszArg++ == '=')							
			{
				switch (wchCmd)
				{
					default:
						*(wszArg-1) = 0;					// kill '=' so we can get the key.
						if(!fInMediaSection)
						{
							hr = m_spamRest->Replace(wszArgStart, wszArg);	// gets key:'xzy', value'121231'  
						} else {
							ITVEAttrMapPtr spamVarRest;
							spVariation->get_Rest(&spamVarRest);
							hr = spamVarRest->Replace(wszArgStart, wszArg);	
						}
						*(wszArg-1) = '=';							// put our '=' back incase anyone uses string again.
						break;

					case 'v':
						if(0 != m_spbsProtocolVersion.Length())
						{
							hr = E_INVALIDARG;
							lgrfParseError |= NENH_grfProtocolVersion;
							break;
						}
						m_spbsProtocolVersion = wszArg;	
						break;

					case 's':
						if(0 != m_spbsSessionName.Length())
						{
							hr = E_INVALIDARG;
							lgrfParseError |= NENH_grfSessionName;
							break;
						}
						m_spbsSessionName = wszArg;
						break;

					case 'o':
						hr = ParseOwner(wszArg, &lgrfParseError);
						break;

					case 'i':
						if(!fInMediaSection)
						{
							if(0 != m_spbsDescription.Length())
							{
								hr = E_INVALIDARG;
								lgrfParseError |= NENH_grfDescription;
								break;
							}
							m_spbsDescription = wszArg;
						} else {
							CComQIPtr<ITVEVariation_Helper> spVariationHelper = spVariation;
							hr = spVariationHelper->SubParseSDP((const BSTR*) &wszArgStart, NULL);
						}
						break;

					case 'u':
						if(0 != m_spbsDescriptionURI.Length())
						{
							hr = E_INVALIDARG;
							lgrfParseError |= NENH_grfDescriptionURI;
							break;
						}
						m_spbsDescriptionURI = wszArg;
						break;

					case 't':
						if(0 != m_dateStart)							// don't allow multiple t= fields.
						{
							hr = E_INVALIDARG;
							lgrfParseError |= NENH_grfStartTime;
							break;
						}
						hr = ParseStartStopTime(wszArg);
						if(m_dateStop < m_dateStart)
						{
							hr = E_INVALIDARG;
							lgrfParseError |= NENH_grfStopTime;
							break;
						}
						break;

					case 'e':
						hr = m_spamEmailAddresses->Add1(wszArg);		// Add1 autogenerate a key
						break;

					case 'p':
						hr = m_spamPhoneNumbers->Add1(wszArg);			// Add1 autogenerates a unique key
						break;

					case 'm':					// media type - create a new variation here
						{
							USES_CONVERSION;
												// finish default variation if first time through...
							if(!fInMediaSection)
							{
								fInMediaSection = true;
								hr = ParseAttributes();		// pull known 'a:' attributes out of input ones
								if(FAILED(hr)) {			//   and place into known fields
									TCHAR tzBuff[512];
									CComBSTR spbsError;
									m_spamAttributes->DumpToBSTR(&spbsError);
									wsprintf(tzBuff,_T("ParseAnnouncement: Error in session attributes\n    '%S'\n"),spbsError);
									spbsErrorBuff += tzBuff;
									lgrfParseError |= NENH_grfSomeVarAttribute;
								}
															// move default media attributes too
								CComQIPtr<ITVEVariation_Helper> spVariationBaseHelper = m_spVariationBase;
								if(!spVariationBaseHelper) return E_NOINTERFACE;
								hr = spVariationBaseHelper->FinalParseSDP();

							//	CComBSTR spBstrDump;
							//	spVariationBaseHelper->DumpToBSTR(&spBstrDump);
							//	DumpToBSTR(&spBstrDump);		// dump the enhancement..
							}
												// create a new variation if not in a 1-element m= parse
							if(!fMissingMedia) {
              					CComObject<CTVEVariation> *pVariation;
								hr = CComObject<CTVEVariation>::CreateInstance(&pVariation);
								if(FAILED(hr))
									return hr;
													// point to it with our current 'spVariation' variable
								hr = pVariation->QueryInterface(&spVariation);			// typesafe QI
								if(FAILED(hr)) {
									delete pVariation;
									break;
								}
							}
							if(NULL == spVariation)  {
								lgrfParseError |= NENH_grfSomeVarIP;
								hr = E_FAIL;				// bad two-part media (missing second part)
								break;
							}

												// QI for it's helper interface so we can modify it.
							CComQIPtr<ITVEVariation_Helper> spVariationHelper = spVariation;

												// Fill it with session general parameters in the base variation
												//  (initially fMissingMedia is false, only set to true if following Parse
												//   doesn't get both trigger/file data)
							if(!fMissingMedia) {
								spVariationHelper->DefaultTo(m_spVariationBase);
								TCHAR tbuff[256];
								long cVariations;
								m_spVariations->get_Count(&cVariations);
								_stprintf(tbuff,_T("<<<Variation %d>>>"),cVariations+1);
								spVariation->put_Description(T2W(tbuff));
							}
												// Parse the 'm' field to get port numbers
							hr = spVariationHelper->SubParseSDP((const BSTR*) &wszArgStart, &fMissingMedia);	// I don't like this cast
							if(FAILED(hr)) {
								lgrfParseError |= NENH_grfSomeVarIP;
								break;
							}
												// If we're done, add this new variation into our list of variations
							if(!fMissingMedia) {
								CComPtr<ITVEEnhancement>	spEnhancementThis(this);				// interface pointer to stuff into parent-pointers
								spVariationHelper->ConnectParent(spEnhancementThis);		// Don't use SmartPTR's (CComPtr<ITVEEnhancement>) for ConnectParent calls (ATLDebug Blow's it)
								m_spVariations->Add(spVariation);
							}
						}
 						break;

					case 'b':						// variation (media) specific parameters
					case 'c':
						{
							if(!fInMediaSection)
							{
								lgrfParseError |= NENH_grfSomeVarIP;
								hr = E_INVALIDARG;
								break;
							}
							CComQIPtr<ITVEVariation_Helper> spVariationHelper = spVariation;
							hr = spVariationHelper->SubParseSDP((const BSTR*) &wszArgStart, NULL);
						}
						break;

					case 'a':						// general attribute - could be enhancement (session) or variation (media) level
						if(!fInMediaSection)
						{
							wchar_t *wszCo = wcschr(wszArg, ':');			// find the <:> that divides each field
							if(wszCo != NULL) {
								CComBSTR bsKey, bsValue;					// parse into <key> ':' <value>
								int cLenKey = wszCo - wszArg;
								bsKey.Append(wszArg, cLenKey);
								bsValue.Append(wszCo+1, wcslen(wszArg) - cLenKey - 1);

																			// languages can appear on may lines.. 
																			//  Instead of creating an AttrList, if reading in second one,
																			//    simply append new languages to existing one with list with ','
								if(0 == wcscmp(bsKey,L"lang") ||
								   0 == wcscmp(bsKey,L"sdplang"))
								{
									CComBSTR bsValCurr;
									CComVariant cvKey(bsKey);
									m_spamAttributes->get_Item(cvKey, &bsValCurr);
									if(bsValCurr.Length() > 0)
									{
										bsValCurr.Append(",");
										bsValCurr.Append(bsValue);
										m_spamAttributes->Replace(bsKey, bsValCurr);
										break;
									}
								}

								m_spamAttributes->Replace(bsKey, bsValue);
							} else {
								m_spamAttributes->Replace(wszArg,L"");			// no parameters
							}
						} else {
							CComQIPtr<ITVEVariation_Helper> spVariationHelper = spVariation;
							hr = spVariationHelper->SubParseSDP((const BSTR*) &wszArgStart, NULL);
						}
					   break;
				}						// end switch
			}							// end '=' test


			if(FAILED(hr))				// catch the error
			{
				const kChars=512;
				WCHAR wszBuff[kChars+1];
				_snwprintf(wszBuff,kChars,L"ParseSAP: line (%4d): '%s'\n",iLineNumber, wszArgStart);
				if(*plLineError == 0)		// only keep track of line with first error...
					*plLineError = iLineNumber;

				spbsErrorBuff += wszBuff;
				hrTotal = E_FAIL; //hr;
			}

			if (NULL == wszNL)
				break;

			// Restore the newline.
			*wszNL = '\n';

			// Restore the CR (if any)
			if (fCRLF)
				wszNL[-1] = '\r';
			iLineNumber++;

	//		if(FAILED(hrTotal))					// uncomment out line to catch new parse erros
	//			break;
		}										// bottom of while(*wzSDP) loop
 			
		if(!FAILED(hrTotal)) {
							// final clean up of each variation (e.g. move attributes into specific fields)
			long cVars;
			hr = m_spVariations->get_Count(&cVars);
			if(S_OK == hr && cVars > 0)
			{
				TCHAR tzBuff[512];
				tzBuff[0] = 0;
		
				for(int i = 0; i < cVars; i++) {
					tzBuff[0] = NULL;
					CComVariant id(i);
					ITVEVariationPtr spVar;
					hr = m_spVariations->get_Item(id,&spVar);
					if(!FAILED(hr)) {
						ITVEVariation_HelperPtr spVar_Helper = spVar;
						if(NULL == spVar_Helper)
							hr = E_NOINTERFACE;
						else {
							hr = spVar_Helper->FinalParseSDP();
							if(!FAILED(hr)) hr = spVar_Helper->SetFileIPAdapter(bstrIPAdapter);
							if(!FAILED(hr)) hr = spVar_Helper->SetTriggerIPAdapter(bstrIPAdapter);
							if(FAILED(hr))
								lgrfParseError |= NENH_grfSomeVarIP;

							if(!FAILED(hr)) {
								ITVEAttrMapPtr spAttrs;
								hr = spVar->get_Attributes(&spAttrs);
								if(FAILED(hr)) {
									USES_CONVERSION;
									CComBSTR spbsError;
									spAttrs->DumpToBSTR(&spbsError);
									wsprintf(tzBuff,_T("ParseAnnouncement: Attribute Error in Variation %d. Attributes\n    '%s'\n"),
										i,W2T(spbsError));
									lgrfParseError |= NENH_grfAttributes;
								} 
							}
							if(!FAILED(hr)) {							// mark as valid....
								spVar_Helper->put_IsValid(VARIANT_TRUE);
							}
						}
					} else {
						if(tzBuff[0] == 'NULL')
							wsprintf(tzBuff,_T("ParseAnnouncement: get_Item Error 0x%8x in Variation %d"),hr,i);
						spbsErrorBuff += tzBuff;
					}
				}
				hrTotal = hr;
			}

		}

                    // note - moved Expire time processing up into CTVEServicer::ParseCBAnnouncement()
                    //        since at this point we don't have access to the enhancements parent
                    //        service and hence can't do *pService->get_ExpireOffset()
                    //      - This is actually sort of bad, since now that I think of it, each
                    //        enhancement should have a different offset, not the service.
                    //      - Oh well, more than likely, this is only for VideoTape delays, which
                    //        are all going to occur on a particular 'Aux' or Channel-3 service.
        
		if(FAILED(hrTotal)) {
			Error(spbsErrorBuff, IID_ITVEEnhancement);
		} else {
			m_fInit = true;
			m_fIsValid = true;				// it succeeded...
		}

		*plgrfParseError = lgrfParseError;

    } catch(_com_error e) {
        hrTotal = e.Error();
    } catch (HRESULT hrCatch) {
		hrTotal = hrCatch;
	} catch (...) {
		hrTotal = E_UNEXPECTED;
	}

    return hrTotal;
}

// -------------------------------------------------------------------------
//	ParseOwner	- handles the o= flag
//
//		Format	o=username sid version IN IP4 ipaddress
//
//			username is nomrally "-", with possibly no space after it.
//
//			
HRESULT
CTVEEnhancement::ParseOwner(const wchar_t *wszArg, long *plgrfParseError)
{
	int cb;
	wchar_t *wsz;

//	if(*wszSDP++ != '-')						// username of '-'
//		return E_INVALIDARG;

//	if(0 != wcsncmp(wszArg,L"-",wcslen(L"-"))) {
//		return E_INVALIDARG;
//	}

//	wszArg += wcslen(L"-");				// seems to be ok to forget the ' ' after the -

	while(wszArg && iswspace(*wszArg))	// paranoia, skip this first white space if any
		wszArg++;

										// Session UserName
	wsz = wcschr(wszArg, ' ');
	if(!wsz) {
		*plgrfParseError |= NENH_grfSessionUserName;
		return E_INVALIDARG;
	}
	*wsz = NULL;
	m_spbsSessionUserName = wszArg;
	*wsz = ' ';
	wszArg = wsz+1;
	

										// session ID
	wsz = wcschr(wszArg, ' ');
	if(!wsz) {
		*plgrfParseError |= NENH_grfSessionId;
		return E_INVALIDARG;
	}
	*wsz = NULL;

	m_ulSessionId = _wtol(wszArg);		
	cb = wcsspn(wszArg, L"0123456789");
	*wsz = ' ';
	if (cb == 0 || (wszArg[cb] != ' ') || (wsz != cb + wszArg))
	{	
		*plgrfParseError |= NENH_grfSessionId;
		return E_INVALIDARG;
	}

	wszArg = wsz+1;

										// Session Version
	wsz = wcschr(wszArg, ' ');
	if(!wsz)
	{
		*plgrfParseError |= NENH_grfSessionVersion;
		return E_INVALIDARG;
	}
	*wsz = NULL;

	m_ulSessionVersion = _wtol(wszArg);
	cb = wcsspn(wszArg, L"0123456789");
	*wsz = ' ';
	if (cb == 0 || wszArg[cb] != ' ' || (wsz != cb + wszArg))
	{
		*plgrfParseError |= NENH_grfSessionVersion;
		return E_INVALIDARG;
	}

	wszArg = wsz+1;
											// skip the "IN IP4 " part
	if(0 != wcsncmp(wszArg, kbstrConnection, wcslen(kbstrConnection)))
	{
		*plgrfParseError |= NENH_grfSessionIPAddress;
		return E_INVALIDARG;
	}

	wszArg += wcslen(kbstrConnection);

	wchar_t wszT = NULL;					// final ipaddress
	wsz = wcschr(wszArg, ' ');				// terminate it at the first space
	if(wsz) {
		wszT = *wsz;
		*wsz = NULL;
	}

	m_spbsSessionIPAddress = wszArg;
	if(wszT)
		*wsz = wszT;

	return S_OK;
}

// ------------------------------------------------------------------------------------------------
// ParseStartStopTime
//		expects time to be in 'start stop' order, where times are in NTP format,
//		and stop time may be optional
//		See RFC 2327 for assumptions about stop time
HRESULT
CTVEEnhancement::ParseStartStopTime(const wchar_t *wszArg)
{
	ULONG ldateStart = _wtol(wszArg);
	ULONG64 ul64dateStart = ldateStart;
	m_dateStart = NtpToDate(ul64dateStart);
    wchar_t *wsz = wcschr(wszArg, ' ');
     if (wsz == NULL) {
		m_dateStop = 0;		                                // never expires...			
	} else {
		wszArg = wsz+1;
 		ULONG ldateStop = _wtol(wszArg);
 		if(ldateStop != 0) {
			ULONG64 ul64dateStop = ldateStop;
			m_dateStop = NtpToDate(ul64dateStop);
        } else {
            m_dateStop = 0;
        }
                                                               
               // if announcement expired in the past or in the next 15 seconds .... probably tape delayed..
                //    this is not nice, so bump it to expire 1/2 hour into the future..
        if(m_dateStop < DateNow() + 15.0 / (24.0 * 60.0 * 60.0))     // questionable code
        {
             m_dateStop = 0;                                // (offset occurs in next line)
        }

        if(m_dateStop == 0)
		{
			m_dateStop = MAX(m_dateStart,DateNow()) + 30.0 / (24.0 * 60.0);	// if no stop time, assume show last 1/2 hour
		}																		// (see SDP spec 2327, page 15, t= section, 
    }

	if(m_dateStop == 0.0)
        m_dateStop = NtpToDate(ULONG_MAX);			        // if zero, treat as maxiumum date allowed...
    return S_OK;
}

// ------------------------------------------------------------------------------------------------
// ParseAttributes
//
//	Parses the well known a: attributes.  Removes them from the attribute list
//	and places them into specific parameters.
//
//		a=UUID:<uuid>
//		a=type:tve
//		a=tve-type:<types>		'primary'
//		a=tve-level:<x>
//		a=tve-ends:<seconds>
//		a=tve-size:Kbytes		
//		a=lang:<languages>		(in variation)
//		a=sdplang:<languages>	(in variation)
//		a=<lang>,				(in variations)
//

HRESULT
CTVEEnhancement::ParseAttributes()
{
    try{
        USES_CONVERSION;

        HRESULT hr = S_OK;
        // pull out special 'a:' attribute fields
        long cAttrs;
        hr = m_spamAttributes->get_Count(&cAttrs);

#ifdef DEBUG
        CComBSTR bstrAttrs;
        m_spamAttributes->DumpToBSTR(&bstrAttrs);
#endif

        if(S_OK == hr && 0 < cAttrs) {
            CComBSTR bstrValue;

            CComVariant cvUUID(L"UUID");
            if(S_OK == m_spamAttributes->get_Item(cvUUID,&bstrValue))
            {
                m_spbsUUID = bstrValue;
                m_spamAttributes->Remove(cvUUID);
            }

            CComVariant cvLevel(L"tve-level");
            if(S_OK == m_spamAttributes->get_Item(cvLevel,&bstrValue))
            {
                m_rTveLevel = atof(W2A(bstrValue));
                m_spamAttributes->Remove(cvLevel);		
            }


            CComVariant cvSize(L"tve-size");
            if(S_OK == m_spamAttributes->get_Item(cvSize,&bstrValue))
            {
                m_ulTveSize = atoi(W2A(bstrValue));
                m_spamAttributes->Remove(cvSize);		
            }

            CComVariant  cvType(L"type");
            if(S_OK == m_spamAttributes->get_Item(cvType,&bstrValue))
            {
                m_spbsType = bstrValue;
                m_spamAttributes->Remove(cvType);		
                // should fail somewhere if type != 'tve'
            }

            CComVariant  cvTveType(L"tve-type");
            if(S_OK == m_spamAttributes->get_Item(cvTveType,&bstrValue))
            {
                //	m_spbsTveType = bstrValue;

                // parse string to find 'primary'
                wchar_t *psPrime = wcsstr(bstrValue,L"primary");
                wchar_t wcsbuff[1024];
                wcsbuff[0] = NULL;
                if(NULL != psPrime)
                {	
                    m_fIsPrimary = true;									// mark as primary, then look for something else in string
                    int cEnd = psPrime - bstrValue + wcslen(L"primary");	// code to extract 'primary' fromstring
                    wcsncat(wcsbuff,psPrime+cEnd,wcslen(bstrValue)-cEnd);	// may leave extra space..
                }
                m_spbsTveType = wcsbuff;
                m_spamAttributes->Remove(cvTveType);		

            }

            CComVariant cvEnds(L"tve-ends");
            if(S_OK == m_spamAttributes->get_Item(cvEnds,&bstrValue))
            {
                long lSeconds = _wtol(bstrValue);
                SYSTEMTIME SysTimeNow;
                GetSystemTime(&SysTimeNow);			// initialize with currrent time.
                SystemTimeToVariantTime(&SysTimeNow, &m_dateStop);
                m_dateStop += lSeconds / (24.0 * 60 * 60);		// convert seconds to DATE format

                m_spamAttributes->Remove(cvEnds);	
            }

            CComVariant cvLang(L"lang");
            if(S_OK == m_spamAttributes->get_Item(cvLang,&bstrValue))
            {	
                wchar_t *pb = bstrValue;			
                while(*pb) {
                    // extract a language  - perhaps change to use wcstok()
                    while(*pb && (iswspace(*pb) || *pb == ',')) pb++;		// skip spaces
                    wchar_t *pbs = pb;
                    while(*pb && !iswspace(*pb) && *pb != ',') pb++;		// skip over the language
                    wchar_t wcsLang[100];
                    wcsncpy(wcsLang, pbs, pb-pbs + 1);			// +1 to get the zero terminator...
                    wcsLang[pb-pbs] = 0;						// null terminate..

                    // insert it into the base languages
                    ITVEAttrMapPtr spAttrsFrom;
                    hr = m_spVariationBase->get_Languages(&spAttrsFrom);		
                    if(S_OK == hr && spAttrsFrom != NULL)
                    {
                        hr = spAttrsFrom->Add1(wcsLang);					// fail if > 1000 languages (need %2d)
                    }
                }
                m_spamAttributes->Remove(cvLang);
            }

            CComVariant cvLangSDP(L"sdplang");
            if(S_OK == m_spamAttributes->get_Item(cvLangSDP,&bstrValue))
            {	
                wchar_t *pb = bstrValue;			
                while(*pb) {
                    // extract a language  - perhaps change to use wcstok()
                    while(*pb && (iswspace(*pb) || *pb == ',')) pb++;		// skip spaces
                    wchar_t *pbs = pb;
                    while(*pb && !iswspace(*pb) && *pb != ',') pb++;		// skip over the language
                    wchar_t wcsLang[100];
                    wcsncpy(wcsLang, pbs, pb-pbs + 1);
                    wcsLang[pb-pbs] = 0;						// null terminate..

                    // insert it into the base languages
                    ITVEAttrMapPtr spAttrsFrom;
                    hr = m_spVariationBase->get_SDPLanguages(&spAttrsFrom);		
                    if(S_OK == hr && spAttrsFrom != NULL)
                    {
                        hr = spAttrsFrom->Add1(wcsLang);					// fail if > 1000 languages (need %2d)
                    }
                }
                m_spamAttributes->Remove(cvLangSDP);
            }	
        }

        return hr;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}
// -------------------------------------------------------------------------

#if 0
HRESULT ATVEF_SDPParser::Parse(char *szSDP)
{
    ATVEF_Announcement *panncCur = &m_anncDef;

    if ((strncmp(szSDP, c_szSDPVersion, sizeof(c_szSDPVersion) -1 ) != 0) &&
	(strncmp(szSDP, c_szSDPVersionCR, sizeof(c_szSDPVersionCR) -1 ) != 0))
        return E_INVALIDARG;

    if (strstr(szSDP, c_szATVEFTypeTVE) == NULL)
        return E_INVALIDARG;

    while (*szSDP)
        {
        char chCmd = *szSDP++;
        char *szArg = szSDP;
        char *szNL = strchr(szSDP, '\n');
        boolean fCRLF = FALSE;

        if (szNL != NULL)
            {
            *szNL = '\0';

            // Ignore CR immediately before LF
            if ((szNL > szSDP) && (szNL[-1] == '\r'))
                {
                fCRLF = TRUE;
                szNL[-1] = '\0';
                }

            szSDP = szNL + 1;

            // Ignore CR immediately after LF
            if (*szSDP == '\r')
                szSDP++;
            }

        if (*szArg++ == '=')
            {
            switch (chCmd)
                {
                case 's':
                    panncCur->SetSessionName(szArg);
                    break;

                case 'o':
                    panncCur->SetOwner(szArg);
                    break;

                case 'i':
                    panncCur->SetInfo(szArg);
                    break;

                case 't':
                    panncCur->SetTime(szArg);
                    break;

                case 'b':
                    panncCur->SetBandwidth(szArg);
                    break;

                case 'm':
                    if ((panncCur == &m_anncDef)
                            || ((panncCur->DataIPPort() != 0) && (panncCur->TriggerIPPort() != 0)))
                        {
                        // Advance to next announcement.
                        ATVEF_Announcement *pannc = new ATVEF_Announcement(m_anncDef);
                        if (pannc == NULL)
                            return E_OUTOFMEMORY;

                        HRESULT hr = AddAnnc(pannc);
                        if (FAILED(hr))
                            {
                            delete pannc;
                            return hr;
                            }

                        panncCur = pannc;
                        }

                    panncCur->SetMedia(szArg);
                    break;

                case 'c':
                    panncCur->SetConnection(szArg);
                    break;

                case 'a':
                    panncCur->AddAttr(szArg);
                    break;
                }
            }

        if (szNL == NULL)
            break;

        // Restore the newline.
        *szNL = '\n';

        // Restore the CR (if any)
        if (fCRLF)
            szNL[-1] = '\r';
        }

    return S_OK;
}

#endif


//--------------------------------------------------------------
// Creates multicasts for file/trigger streams associated with all variations on this enhancement.
//  Then it joins them
STDMETHODIMP CTVEEnhancement::Activate()
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::Activate"));

	try 
	{
		_ASSERT(NULL != m_pService);							// need to call ConnectParent first...
		IUnknownPtr			spUnk;
		hr = get_Parent(&spUnk);
		if(FAILED(hr))
			return hr;
		
		ITVEServicePtr	spService(spUnk);
		if(NULL == spService)
			return E_NOINTERFACE;


		IUnknownPtr			spUnk2;
		hr = spService->get_Parent(&spUnk2);
	//	hr = m_pService->get_Parent(&spUnk2);
		_ASSERT(!FAILED(hr) && NULL != spUnk2);					// forgot it's ConnectParent (called in CTVESupervisor::ConnectAnncListener())

		ITVESupervisorPtr			spSuper(spUnk2);
		if(NULL == spSuper)
			return E_NOINTERFACE;

		ITVESupervisor_HelperPtr	spSuperHelper(spUnk2);
		if(NULL == spSuperHelper)
			return E_NOINTERFACE;

		ITVEMCastManagerPtr spMCM;
		hr = spSuperHelper->GetMCastManager(&spMCM);
		if(FAILED(hr))
			return hr;

		try {
			CComBSTR bstrAdapter;
			long cVariations;
			m_spVariations->get_Count(&cVariations);

			CComPtr<ITVEEnhancement> spEnhancement(this);

			for(int iVar = 0; iVar < cVariations; iVar++)
			{
				CComVariant vc(iVar);			// perhaps should do this in a Variation method...
				ITVEVariationPtr spVaria;
				m_spVariations->get_Item(vc,&spVaria);

				CComBSTR spbsFileIPAdapt;
				CComBSTR spbsTrigIPAdapt;
				CComBSTR spbsFileIPAddr;
				CComBSTR spbsTrigIPAddr;
				LONG	 lFilePort;
				LONG	 lTrigPort;
						
				spVaria->get_FileIPAdapter(&spbsFileIPAdapt);
				spVaria->get_TriggerIPAdapter(&spbsTrigIPAdapt);
				spVaria->get_FileIPAddress(&spbsFileIPAddr);
				spVaria->get_TriggerIPAddress(&spbsTrigIPAddr);
				spVaria->get_FilePort(&lFilePort);
				spVaria->get_TriggerPort(&lTrigPort);

				ITVECBFilePtr spCBFilePtr;							// create the file reader (UHTTP decoder/cache stuffer) callback
				CComObject<CTVECBFile> *pCBFile;
				hr = CComObject<CTVECBFile>::CreateInstance(&pCBFile);
				if(FAILED(hr))
					goto exit_this;
				hr = pCBFile->QueryInterface(&spCBFilePtr);	
				if(FAILED(hr)) {
					delete pCBFile;
					goto exit_this;
				}

				ITVECBTrigPtr spCBTrigPtr;							// create trigger parser callback
				CComObject<CTVECBTrig> *pCBTrig;
				hr = CComObject<CTVECBTrig>::CreateInstance(&pCBTrig);
				if(FAILED(hr))
					goto exit_this;
				hr = pCBTrig->QueryInterface(&spCBTrigPtr);	
				if(FAILED(hr)) {
					delete pCBTrig;
					goto exit_this;
				}	

				spCBFilePtr->Init(spVaria, spService);				// bind the downpointers in the callback objects
				spCBTrigPtr->Init(spVaria);

				ITVEMCastPtr spMCastFile;
				static int kFileCbuffers	= 25;
				hr = spMCM->AddMulticast(NWHAT_Data, spbsFileIPAdapt, spbsFileIPAddr, lFilePort, kFileCbuffers, spCBFilePtr, &spMCastFile);	// NULL param could contain returned created multicast
				if(FAILED(hr))
					goto exit_this;
			
				ITVEMCastPtr spMCastTrigger;
				static int kTriggerCbuffers = 5;
				hr = spMCM->AddMulticast(NWHAT_Trigger, spbsTrigIPAdapt, spbsTrigIPAddr, lTrigPort, kTriggerCbuffers, spCBTrigPtr, &spMCastTrigger);
				if(FAILED(hr))
					goto exit_this;

													// now join them
	#if 1
				LONG lHaltFlags;
				spMCM->get_HaltFlags(&lHaltFlags);
				if(0 != (lHaltFlags & NFLT_grfTB_DataDecode))			// if flags set, suspend things..
					hr = spMCastFile->Suspend(true);
				if(0 != (lHaltFlags & NFLT_grfTB_TrigDecode))	
					hr = spMCastTrigger->Suspend(true);

				if(0 == (lHaltFlags & NFLT_grfTB_DataListen))
					hr = spMCastFile->Join();
				if(0 == (lHaltFlags & NFLT_grfTB_TrigListen))
					hr = spMCastTrigger->Join();
	#else
				hr = spMCastFile->Join();
				hr = spMCastTrigger->Join();
	#endif
						
			}	
							// note it doesn't join these multicasts...
            } catch (HRESULT hrCatch) {
				hr = hrCatch;
			} catch (...) {
			hr = E_FAIL;
		}
	exit_this:
		{
			int x =1;
		}
	} catch (_com_error e) {
        hr = e.Error();
 	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}

	_ASSERT(S_OK == hr);
	return hr;
}


// ----------------------------------------
// Nasty Method  (YECK! This IS Ugly!)
//
//	Given an existing running enhancement and a new announcement for it that may change it,
//	  this routine finds what actually changed, and depending on what happened, either does
//	  nothing (duplicate resend), changes a few fields, or tears down the whole running multicasts
//	  for this enhancement and flushes out the variations.  In this last case, the multicasts
//	  and variations need to be reset.
//			(Reset can be determined by (*pulNENH_grfChanged & NENH_grfSomeVarIP != 0)
//
//	  It updates the existing enhancement and returns the changed fields in *pulNENH_grfChanged;
//	
//   Possible BUG!  - Doesn't do any locking yet.. How?
// ---------------------------------------------------------------------------
STDMETHODIMP CTVEEnhancement::UpdateEnhancement(ITVEEnhancement *pEnhNew, long *pulNENH_grfChanged)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::Activate"));
	try 
	{
		// this modifies an existing announcement
		CComBSTR spbsNew;
		CComBSTR spbsOld;
		int		 iNew;
		short	 sNew;
		long	 lNew;
		ULONG	 ulNew;
		USHORT	 usNew;
		DATE	 dateNew;
		double	 rNew;
		IUnknownPtr		spUnk;
		IDispatchPtr	spDsp;
		VARIANT_BOOL varfNew;

		const double kThreshTime = 5.0 / (24.0 * 60 * 60);			// (5 seconds) diff in time is same time...
						// is everything valid?
		ULONG lgrfChanged = 0;
		if(!m_fIsValid)
			return E_INVALIDARG;
		VARIANT_BOOL vbValid;
		pEnhNew->get_IsValid(&vbValid);
		if(VARIANT_FALSE == vbValid)
			return E_INVALIDARG;



		/// ---------- SAP
		pEnhNew->get_SAPHeaderBits(&sNew);			
		if((BYTE) m_ucSAPHeaderBits != sNew)
		{
			SAPHeaderBits SAPHead, SAPHeadNew;
			SAPHead.uc    = m_ucSAPHeaderBits;
			SAPHeadNew.uc = sNew;
			if(SAPHead.s.Version != SAPHeadNew.s.Version)          lgrfChanged |= NENH_grfSAPVersion;
			if(SAPHead.s.AddressType != SAPHeadNew.s.AddressType)  lgrfChanged |= NENH_grfSAPAddressType;
			if(SAPHead.s.Reserved != SAPHeadNew.s.Reserved)        lgrfChanged |= NENH_grfSAPOther;
			if(SAPHead.s.MessageType != SAPHeadNew.s.MessageType)  lgrfChanged |= NENH_grfSAPOther;
			if(SAPHead.s.Encrypted != SAPHeadNew.s.Encrypted)      lgrfChanged |= NENH_grfSAPEncryptComp;
			if(SAPHead.s.Compressed != SAPHeadNew.s.Compressed)    lgrfChanged |= NENH_grfSAPEncryptComp;
			m_ucSAPHeaderBits = sNew;
		}

		pEnhNew->get_SAPAuthLength(&sNew);	
		if(m_ucSAPAuthLength != sNew)
			{m_ucSAPAuthLength = sNew;				lgrfChanged |= NENH_grfSAPOther;}

		pEnhNew->get_SAPMsgIDHash(&lNew);
		if(m_usSAPMsgIDHash != lNew)
			{m_usSAPMsgIDHash = lNew;				lgrfChanged |= NENH_grfSAPOther;}

		spbsNew.Empty();
		pEnhNew->get_SAPSendingIP(&spbsNew);
		if(!(m_spbsSAPSendingIP == spbsNew))		// caution, CComBSTR doesn't support '!=' operator use !(==)
			{m_spbsSAPSendingIP = spbsNew;			lgrfChanged |= NENH_grfSAPOther;}


			/// -----------
		spbsNew.Empty();
		pEnhNew->get_Description(&spbsNew);				
		if(!(m_spbsDescription == spbsNew))		// caution, CComBSTR doesn't support '!=' operator use !(==)
			{m_spbsDescription = spbsNew;			lgrfChanged |= NENH_grfDescription;}

		spbsNew.Empty();
		pEnhNew->get_DescriptionURI(&spbsNew);				
		if(!(m_spbsDescriptionURI == spbsNew))		// caution, CComBSTR doesn't support '!=' operator use !(==)
			{m_spbsDescriptionURI = spbsNew;		lgrfChanged |= NENH_grfDescriptionURI;}

		pEnhNew->get_IsPrimary(&varfNew);
		iNew = varfNew ? true : false;		
		if(!(m_fIsPrimary == iNew))				
			{m_fIsPrimary = iNew;					lgrfChanged |= NENH_grfIsPrimary;}

		spbsNew.Empty();
		pEnhNew->get_ProtocolVersion(&spbsNew);		
		if(!(m_spbsProtocolVersion == spbsNew))	
			{m_spbsProtocolVersion = spbsNew;		lgrfChanged |= NENH_grfProtocolVersion;}

		spbsNew.Empty();
		pEnhNew->get_SessionUserName(&spbsNew);				
		if(!(m_spbsSessionUserName == spbsNew))
			{m_spbsSessionUserName = spbsNew;		lgrfChanged |= NENH_grfSessionUserName;}

		pEnhNew->get_SessionId(&lNew);				
		if(!(m_ulSessionId == (ULONG) lNew))
			{m_ulSessionId = (ULONG) lNew;			lgrfChanged |= NENH_grfSessionId;}

		pEnhNew->get_SessionVersion(&lNew);		
		if(!(m_ulSessionVersion == (ULONG) lNew))
			{m_ulSessionVersion = (ULONG) lNew;		lgrfChanged |= NENH_grfSessionVersion;}
		
		spbsNew.Empty();
		pEnhNew->get_SessionIPAddress(&spbsNew);	
		if(!(m_spbsSessionIPAddress == spbsNew))
			{m_spbsSessionIPAddress = spbsNew;		lgrfChanged |= NENH_grfSessionIPAddress;}
		
		spbsNew.Empty();
		pEnhNew->get_SessionName(&spbsNew);			
		if(!(m_spbsSessionName == spbsNew))
			{m_spbsSessionName = spbsNew;			lgrfChanged |= NENH_grfSessionName;}
		
		ITVEAttrMapPtr spamNewEmail;
		pEnhNew->get_EmailAddresses(&spamNewEmail);		// for email and phone, string compare dump representations for any changes
		spbsNew.Empty();
		spamNewEmail->DumpToBSTR(&spbsNew);
		m_spamEmailAddresses->DumpToBSTR(&spbsOld);
		if(!(spbsOld == spbsNew))				
			{m_spamEmailAddresses = spamNewEmail;	lgrfChanged |= NENH_grfEmailAddresses;}


		ITVEAttrMapPtr spamNewPhone;
		pEnhNew->get_PhoneNumbers(&spamNewPhone);
		spbsNew.Empty();
		spamNewPhone->DumpToBSTR(&spbsNew);
		m_spamPhoneNumbers->DumpToBSTR(&spbsOld);	
		if(!(spbsOld == spbsNew))		
			{m_spamPhoneNumbers = spamNewEmail;		lgrfChanged |= NENH_grfPhoneNumbers;}

		spbsNew.Empty();
		pEnhNew->get_UUID(&spbsNew);				
		if(!(m_spbsUUID == spbsNew))
			{m_spbsUUID = spbsNew;					lgrfChanged |= NENH_grfUUID;}

		pEnhNew->get_StartTime(&dateNew);			// note - need to change start/stop times to lists		
		if(ABS(m_dateStart - dateNew) >= kThreshTime)			
			{m_dateStart = dateNew;					lgrfChanged |= NENH_grfStartTime;}

		pEnhNew->get_StopTime(&dateNew);			
		if(ABS(m_dateStop - dateNew) >= kThreshTime)			
			{m_dateStop = dateNew;					lgrfChanged |= NENH_grfStopTime;}


		spbsNew.Empty();
		pEnhNew->get_Type(&spbsNew);				
		if(!(m_spbsType == spbsNew))			
			{m_spbsType = spbsNew;					lgrfChanged |= NENH_grfType;}

		spbsNew.Empty();
		pEnhNew->get_TveType(&spbsNew);				
		if(!(m_spbsTveType == spbsNew))			
			{m_spbsTveType = spbsNew;				lgrfChanged |= NENH_grfTveType;}

		spbsNew.Empty();
		pEnhNew->get_TveSize(&lNew);				
		if(!(m_ulTveSize == (LONG) lNew))				
			{m_ulTveSize = (LONG) lNew;				lgrfChanged |= NENH_grfTveSize;}

		pEnhNew->get_TveLevel(&rNew);				
		if(!(m_rTveLevel == rNew))				
			{m_rTveLevel = rNew;					lgrfChanged |= NENH_grfTveLevel;}

		ITVEAttrMapPtr spamAttributes;				// for attributes and rest, do string compare...
		pEnhNew->get_Attributes(&spamAttributes);
		spbsNew.Empty();
		spamAttributes->DumpToBSTR(&spbsNew);
		spbsOld.Empty();
		m_spamAttributes->DumpToBSTR(&spbsOld);
		if(!(spbsOld == spbsNew))					
		{	m_spamAttributes = spamAttributes;		lgrfChanged |= NENH_grfAttributes;}


		ITVEAttrMapPtr spamRest;
		pEnhNew->get_Rest(&spamRest);
		spbsNew.Empty();
		spamRest->DumpToBSTR(&spbsNew);
		spbsOld.Empty();
		m_spamRest->DumpToBSTR(&spbsOld);
		if(!(spbsOld == spbsNew))					
		{	m_spamRest = spamAttributes;			lgrfChanged |= NENH_grfRest; }


							// variations...
		long cVariationsOld, cVariationsNew;
		m_spVariations->get_Count(&cVariationsOld);
		ITVEVariationsPtr spVariationsNew;
		pEnhNew->get_Variations(&spVariationsNew);
		spVariationsNew->get_Count(&cVariationsNew);
		if(cVariationsOld < cVariationsNew) lgrfChanged |= NENH_grfVariationAdded;
		if(cVariationsOld > cVariationsNew) lgrfChanged |= NENH_grfVariationRemoved;

							// this is interesting... how do we detect which variation is which?
		int *rgBestMatchNewToOld = (int*) _alloca(cVariationsNew*sizeof(int));
		int *rgBestMatchOldToNew = (int*) _alloca(cVariationsOld*sizeof(int));
		long *rggrfEVAROld       =   (long*) _alloca(cVariationsOld*sizeof(int));

		int j;
		for(j = 0; j < cVariationsNew; j++) rgBestMatchNewToOld[j] = -1;
		for(j = 0; j < cVariationsOld; j++) {rgBestMatchOldToNew[j] = -1; rggrfEVAROld[j] = 0;}

		long grfEVARTotal = 0;
		for(long iOld = 0; iOld < cVariationsOld; iOld++)
		{
			CComVariant var(iOld);
			ITVEVariationPtr spVariationOld;
			hr = m_spVariations->get_Item(var, &spVariationOld);
			if(FAILED(hr)) break;

            LONG lFilePortOld;
			LONG lTriggerPortOld;
			CComBSTR  bstrFileAddressOld, bstrFileAdapterOld;
			CComBSTR  bstrTriggerAddressOld, bstrTriggerAdapterOld;

			spVariationOld->get_FilePort(&lFilePortOld);
			spVariationOld->get_TriggerPort(&lTriggerPortOld);
			spVariationOld->get_FileIPAddress(&bstrFileAddressOld);
			spVariationOld->get_TriggerIPAddress(&bstrTriggerAddressOld);
			spVariationOld->get_FileIPAdapter(&bstrFileAdapterOld);
			spVariationOld->get_TriggerIPAdapter(&bstrTriggerAdapterOld);

			long iBestMatchSoFar = -1;
			long sBestMatchSoFar = 0;
			for(long iSearch = 0; iSearch < cVariationsNew; iSearch++)
			{
				long sBestMatch = 0;
				if(rgBestMatchNewToOld[iSearch] != -1) continue;			// already have one...
					
				CComVariant varNew(iSearch);
				ITVEVariationPtr spVariationNew;
				hr = spVariationsNew->get_Item(varNew, &spVariationNew);
				

				LONG lFilePortNew;
				LONG lTriggerPortNew;
				CComBSTR  bstrFileAddressNew, bstrFileAdapterNew;
				CComBSTR  bstrTriggerAddressNew, bstrTriggerAdapterNew;

				spVariationNew->get_FilePort(&lFilePortNew);
				spVariationNew->get_TriggerPort(&lTriggerPortNew);
				spVariationNew->get_FileIPAddress(&bstrFileAddressNew);
				spVariationNew->get_TriggerIPAddress(&bstrTriggerAddressNew);
				spVariationNew->get_FileIPAdapter(&bstrFileAdapterNew);
				spVariationNew->get_TriggerIPAdapter(&bstrTriggerAdapterNew);

				if(lFilePortNew == lFilePortOld)					sBestMatch += 1;
				if(lTriggerPortNew == lTriggerPortOld)				sBestMatch += 1;
				if(bstrFileAddressNew == bstrFileAddressOld)		sBestMatch += 1;
				if(bstrTriggerAddressNew == bstrTriggerAddressOld)	sBestMatch += 1;
				if(bstrFileAdapterNew == bstrFileAdapterOld)		sBestMatch += 1;
				if(bstrTriggerAdapterNew == bstrTriggerAdapterOld)	sBestMatch += 1;
				if(sBestMatch > sBestMatchSoFar) {
					iBestMatchSoFar = iSearch;
					sBestMatchSoFar = sBestMatch;
				}
			}
			if(iBestMatchSoFar >= 0) {
				ITVEVariationPtr spVariationNew;
				CComVariant varNew(iBestMatchSoFar);
				hr = spVariationsNew->get_Item(varNew, &spVariationNew);
				_ASSERT(S_OK == hr);

				ITVEVariation_HelperPtr	spVarOldHelper(spVariationOld);

				rgBestMatchOldToNew[iBestMatchSoFar] = iBestMatchSoFar;
				rgBestMatchNewToOld[iBestMatchSoFar] = iSearch;
				spVarOldHelper->UpdateVariation(spVariationNew, &rggrfEVAROld[iOld]);			// what specifically changed
				grfEVARTotal |= rggrfEVAROld[iOld];
			}
		}			// end of iOld Loop;

									// merge Variant changes in with the enhancement ones

		if(grfEVARTotal & (long) NVAR_grfAnyIP)			lgrfChanged |= NENH_grfSomeVarIP;
		if(grfEVARTotal & (long) NVAR_grfAnyText)		lgrfChanged |= NENH_grfSomeVarText;
		if(grfEVARTotal & (long) NVAR_grfAnyBandwidth)	lgrfChanged |= NENH_grfSomeVarBandwidth;
		if(grfEVARTotal & (long) NVAR_grfLanguages)		lgrfChanged |= NENH_grfSomeVarLanguages;
		if(grfEVARTotal & (long) NVAR_grfAnyAttribute)	lgrfChanged |= NENH_grfSomeVarAttribute;

						// if changed any IP port, address, adapter, or # of variations
						//  then we need to tear down existing all IP addresses and recreate them (easier than doing specific ones)
						//  Do this in CTEService::ParseCBAnnouncement

		if(pulNENH_grfChanged) {
			*pulNENH_grfChanged = lgrfChanged;
		}

	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}

	return hr;
}


					// if changed any IP port, address, adapter, or # of variations
					//  then we need to tear down/recreate the callbacks for these ports.
					//  -- do this in calling routine..

STDMETHODIMP CTVEEnhancement::Deactivate()
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::Deactivate"));

	_ASSERT(NULL != m_pService);							// need to call ConnectParent first...
	IUnknownPtr			spUnk;
	hr = get_Parent(&spUnk);
	ITVEServicePtr	spService(spUnk);
	if(NULL == spService)
		return E_NOINTERFACE;

	IUnknownPtr			spUnk2;
	hr = spService->get_Parent(&spUnk2);
//	hr = m_pService->get_Parent(&spUnk2);
	_ASSERT(!FAILED(hr) && NULL != spUnk2);					// forgot it's ConnectParent (called in CTVESupervisor::ConnectAnncListener())

	ITVESupervisor_HelperPtr	spSuperHelper(spUnk2);
	if(NULL == spSuperHelper)
		return E_NOINTERFACE;

	ITVEMCastManagerPtr spMCM;
	hr = spSuperHelper->GetMCastManager(&spMCM);
	if(FAILED(hr))
		return hr;

					// this is going to be tricky.. Have to squash those multicasts that
					//   point to this enhancement (the Annc one) and any variation under it
					//   (file and trig ones).
	try {
		CComBSTR bstrAdapter;
		long cVariations;
		m_spVariations->get_Count(&cVariations);

		CComPtr<ITVEEnhancement> spEnhancement(this);

                    // array to keep track of MCasts we want to remove...
                    //   a bit easier on the system to do it this way, we can Lock only what we want.
		ITVEMCastPtr *rgspMCasts = (ITVEMCastPtr *) _alloca(cVariations*2 * sizeof(ITVEMCastPtr));	
        if(NULL == rgspMCasts)
            return E_OUTOFMEMORY;
        
        memset(rgspMCasts, 0, cVariations*2 * sizeof(ITVEMCastPtr));
        int cMCasts = 0;

		for(int iVar = 0; iVar < cVariations; iVar++)
		{
			CComVariant vc(iVar);			
			ITVEVariationPtr spVaria;
			m_spVariations->get_Item(vc,&spVaria);

			CComBSTR spbsFileIPAdapt;
			CComBSTR spbsTrigIPAdapt;
			CComBSTR spbsFileIPAddr;
			CComBSTR spbsTrigIPAddr;
			LONG	 lFilePort;
			LONG	 lTrigPort;
			
			spVaria->get_FileIPAdapter(&spbsFileIPAdapt);
			spVaria->get_FileIPAddress(&spbsFileIPAddr);
			spVaria->get_FilePort(&lFilePort);

			spVaria->get_TriggerIPAdapter(&spbsTrigIPAdapt);
			spVaria->get_TriggerIPAddress(&spbsTrigIPAddr);
			spVaria->get_TriggerPort(&lTrigPort);

                                // The Leave() call simply stops the MCast from reading more messages, it
                                //  doesn't stop it from processing more messages. However, the SetReadCallback below
                                //  null's (e.g. deletes) out the object it's calling the messages on.
                                // Hence, it seems that to avoid bug, we dont' want to womp that object here...
                                // >>> HOWEVER, other objects that these messages will be using are getting womped.
                                //    So, let's null it out, make make the process message call
                                //      (CTEVMCastManager::queueThreadBody() - PacketEvent section)
                                //    check for the null callback and not preform the process...
                                // - side note -
                                //    we want to avoid putting reference counts on objects in the QueueThread's message Queue
                                //    just because we may not be able to de-ref them when we're womping it.. In future
                                //    world, we actually probably want to rewrite the code to actually do that (maybe not use
                                //    window messages but something of our own devising?)

			long cMatches;
			ITVEMCastPtr spMCastFile;
			hr = spMCM->FindMulticast(spbsFileIPAdapt, spbsFileIPAddr, lFilePort, &spMCastFile, &cMatches);
			_ASSERT(S_OK == hr && 1 == cMatches);
			if(S_OK == hr) {
				hr = spMCastFile->Leave();                      // syncronous call
				hr = spMCastFile->SetReadCallback(0, 0, NULL);	// this should Release the callback to 0,
																//  which should release it's pointers into the graph...
		//		hr = spMCM->RemoveMulticast(spMCastFile);		// remove the  multicast listener
                rgspMCasts[cMCasts++] = spMCastFile;
			}



			ITVEMCastPtr spMCastTrig;
			hr = spMCM->FindMulticast(spbsTrigIPAdapt, spbsTrigIPAddr, lTrigPort, &spMCastTrig, &cMatches);
			_ASSERT(S_OK == hr && 1 == cMatches);
			if(S_OK == hr) {
				hr = spMCastTrig->Leave();
				hr = spMCastTrig->SetReadCallback(0, 0, NULL);
			//	hr = spMCM->RemoveMulticast(spMCastTrig);		// remove the  multicast listener
                rgspMCasts[cMCasts++] = spMCastTrig;
			}
		}	// end FOR loop

                            // know that we know Multicasts we want to womp, remove them.
                            // (in future, there may be active MCasts for other services, which is why we did above search
                            //   rather than just delete the whole MCast list.)
        for(int i = 0; i < cMCasts; i++)
        {
            hr = spMCM->RemoveMulticast(rgspMCasts[i]);         // RemoveMulticast is an asyncronous call (post WM_TVEKILLMCAST_EVENT message to queue thread)
                                                                //  perhaps should block here until it's done, but
        }
        for(int i = 0; i < cMCasts; i++)
        {
            rgspMCasts[i] = 0;                                  // clean up those final references
        }
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}

	_ASSERT(S_OK == hr);
	return hr;
}

	// initializes this one enhancement as the one that takes Crossover links...
STDMETHODIMP CTVEEnhancement::InitAsXOver()
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::InitAsXOver"));

	try 
	{
		long cVars;
		m_spVariations->get_Count(&cVars);
		if(cVars != 0)
			return E_INVALIDARG;		// called already...

				// create the one and only variation for all Line21 triggers
		CComObject<CTVEVariation> *pVariation;
		hr = CComObject<CTVEVariation>::CreateInstance(&pVariation);
		if(FAILED(hr))
			return hr;
							// point to it with our current 'spVariation' variable
		ITVEVariationPtr spVariation;						// changes to non-base on first m= field
		hr = pVariation->QueryInterface(&spVariation);			// typesafe QI
		if(FAILED(hr)) {
			delete pVariation;
			return hr;
		}
			
				// keep track of it
		hr = m_spVariations->Add(spVariation);
		if(FAILED(hr)) return hr;

				// tell it what it is..
		CComPtr<ITVEEnhancement>	spEnhancementThis(this);		// interface pointer to stuff into parent-pointers
		ITVEVariation_HelperPtr spVariationHelper(spVariation);
		hr = spVariationHelper->InitAsXOver();
		if(FAILED(hr)) return hr;

 				// set it's back pointer.	(do after the Init call)
		spVariationHelper->ConnectParent(spEnhancementThis);		// Don't use SmartPTR's (CComPtr<ITVEEnhancement>) for ConnectParent calls (ATLDebug Blow's it)

				// Get Received Time
		DATE dateNow = DateNow();		
		put_Description(L"Crossover Links Enhancement");

					// fake a bunch of parameters

		m_dateStart				= dateNow;
		m_dateStop				= dateNow + 1000;		// only active for 3 years...
		m_fInit					= true;
		m_fDataMedia			= false;
		m_fTriggerMedia			= true;
		m_fIsPrimary			= true;
		m_fIsValid				= true;
		m_rTveLevel				= 0.0;					// non atvef triggers...
		m_spbsSessionName		= L"Crossover Links";
		m_spbsSessionUserName	= L"-";
		m_spbsUUID				= L"";
		m_spamEmailAddresses->Add(L"Missing Link",L"Missing@BogusLinks.com");

	} catch (_com_error e) {
        hr = e.Error();
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}

	return hr;
}

	// initializes this one enhancement as the one that takes Crossover links...
STDMETHODIMP CTVEEnhancement::NewXOverLink(BSTR bstrLine21Trigger)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_ENHANCEMENT, _T("CTVEEnhancement::NewXOverLink"));
	
	try {

		long cVars;
		m_spVariations->get_Count(&cVars);		// could conceiveably have multiple variations for
		if(cVars != 1)							//   line21 triggers, but one is enough for now
			return E_UNEXPECTED;

		CComVariant varFirst(0);
		ITVEVariationPtr spXoverVariation;
		hr = m_spVariations->get_Item(varFirst, &spXoverVariation);
		if(FAILED(hr))
			return hr;

		ITVEVariation_HelperPtr spXoverVariation_Helper(spXoverVariation);
		hr = spXoverVariation_Helper->NewXOverLink(bstrLine21Trigger);
	
	} catch (_com_error e) {
        hr = e.Error();
 	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveenhans.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEEnhancements.cpp : Implementation of CTVEEnhancements
#include "stdafx.h"
#include "MSTvE.h"
#include "TVEEnhans.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTVEEnhancements


STDMETHODIMP CTVEEnhancements::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEEnhancements
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvefeature.cpp ===
// Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------
//  TVEFeature.cpp : Implementation of CTVEFeature
//
//	CTVEFeature is the "active service' object.  It navigates
//	around the TVESupervisor to a particular service, and forwards
//	all method calls to the service.
//
//	Typically, this object is agregated with the TVE graph segment,
//	but it may be created on it's own if not using the VidControl.
//
//
//	Note - The AdviseCall creates a circular reference loop onto the TVESupervisor.
//		   To avoid this preventing us from removing the object,
//		   I use the decrement in the constructor/increment in the descructor trick
//		   Look for comments below...
// -----------------------------------------------------------------

#include "stdafx.h"
#include <stdio.h>

#include "TveDbg.h"

#include "MSTvE.h"
#include "TVEFeature.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CTVETrigger_Helper
	

STDMETHODIMP 
CTVEFeature::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEFeature
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

// ////////////////////////////////////////////////////////////////
		// Active Template Library - A Developer's Guide: pg 274-276

HRESULT 
CTVEFeature::FinalRelease()
{
	if(0 != m_dwSuperTVEEventsAdviseCookie)
	{
		AddRef();						// CIRC_REF_HACK - add an extra reference
		TeardownTVEEventReflector();	// remove the event sink, (releasing a reference)
	}

	return S_OK;
}



HRESULT 
CTVEFeature::SetupTVEEventReflector()
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("SetupTVEEventReflector"));

	if(NULL==m_spSuper)
	{
		 TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("TVESupervisor Not yet Bound")));
		 return E_POINTER;
	}

	if(0 != m_dwSuperTVEEventsAdviseCookie)		// already have an event sink
		return S_FALSE;

	IUnknownPtr spPunkSuper(m_spSuper);				// the event source
	IUnknownPtr spPunkSink(GetUnknown());		// this new event sink...

	if(NULL == spPunkSuper)
		return E_NOINTERFACE;
	DWORD dwCookie;

	hr = AtlAdvise(spPunkSuper,					// event source (TveSupervisor)
				   spPunkSink,					// event sink (Feature listener...)
				   DIID__ITVEEvents,			// <--- hard line
				   &m_dwSuperTVEEventsAdviseCookie);		// need to pass to AtlUnad	if(FAILED(hr))

	if(!FAILED(hr))
	{
		Release();								// CIRC_REF_HACK -- this call added an extra reference to THIS
												//                  release it, and add it back when releasing this object
	}
	return hr;
}

HRESULT			// ok to call if not there, will simply do nothing...
CTVEFeature::TeardownTVEEventReflector()
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("TeardownTVEEventReflector"));

	HRESULT hr = S_OK;
	if(0 != m_dwSuperTVEEventsAdviseCookie)
	{
		if(NULL == m_spSuper)
			return E_POINTER;
		IUnknownPtr spPunkSuper(m_spSuper);

		hr = AtlUnadvise(spPunkSuper,
	//					 MSTvELib::DIID__ITVEEvents,
						 DIID__ITVEEvents,
						 m_dwSuperTVEEventsAdviseCookie);		// need to pass to AtlUnadvise...
		m_dwSuperTVEEventsAdviseCookie = 0;

	}
	return hr;
}


///////////////////////////////////////////////////////////////////
//  ITVEFeature

					// Null input value OK, releases the binding

STDMETHODIMP CTVEFeature::BindToSupervisor(/*[in]*/ ITVESupervisor *pSupervisor)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::BindToSupervisor"));
	
	CSmartLock spLock(&m_sLk);		// Feature lock...			(don't allow other Bind's/Tunes during this one)

	if(m_spSuper)				// if already bound..
	{
		hr = TeardownTVEEventReflector();
		m_spSuper = NULL;
	}

	m_spSuper = pSupervisor;				// save away the down pointer
	if(NULL != pSupervisor)
		hr = SetupTVEEventReflector();			// 

	return hr;
}

			// either finds an existing or creates a new service, and tunes to it.
			//  If both values are null, turns off ATVEF.

STDMETHODIMP CTVEFeature::ReTune(/*[in]*/ ITVEService *pService)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::ReTune"));
	CSmartLock spLock(&m_sLk);		// Feature lock...			(don't allow other TuneTo's during this one)

	HRESULT hr = S_OK;
	if(NULL == m_spSuper)
		return E_INVALIDARG;

	hr = m_spSuper->ReTune(pService);
	if(!FAILED(hr))
	{
		m_spService = pService;				// keep track of this one
	}

	return  hr;
}


			// either finds an existing or creates a new service, and tunes to it.
			//  If both values are null, turns off ATVEF.

STDMETHODIMP CTVEFeature::TuneTo(/*[in]*/ BSTR bstrDescription, /*[in]*/ BSTR bstrIPAdapter)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::TuneTo"));

	CSmartLock spLock(&m_sLk);		// Feature lock...			(don't allow other TuneTo's during this one)

	HRESULT hr = S_OK;
	if(NULL == m_spSuper)
		return E_INVALIDARG;

	m_spService = NULL;			// release previous reference (just in case of error)

	hr = m_spSuper->TuneTo(bstrDescription, bstrIPAdapter);
	if(FAILED(hr))
		return hr;

	if((NULL == bstrDescription  || NULL == bstrDescription[0])&&	// turned off Atvef
       (NULL == bstrIPAdapter    || NULL == bstrIPAdapter[0]))		
		return S_OK;

	ITVEServicesPtr spServices;
	hr = m_spSuper->get_Services(&spServices);
	if(FAILED(hr))
		return hr;

								// There should only be one active service in the collection.
								//   New ones should be the first one, but one never knows.
								//   Search until we get it

	long cServices;
	hr = spServices->get_Count(&cServices);
	if(FAILED(hr))
		return hr;

	ITVEServicePtr m_spActiveService;

	bool fMoreThanOneActiveService = false;
	for(long i = 0; i < cServices; i++)
	{
		CComVariant cv(0);
		ITVEServicePtr spService;
		hr = spServices->get_Item(cv, &spService);
		if(FAILED(hr))
			return hr;
		VARIANT_BOOL fActive;
		hr = spService->get_IsActive(&fActive);
		if(fActive)
		{
			if(m_spActiveService = NULL) 
			{
				m_spActiveService = spService;
			// break;
			} else {
				fMoreThanOneActiveService = true;
				_ASSERT(fMoreThanOneActiveService != false);
			}
		}
	} // end loop

	return S_OK;
}

//////////////////////////////////////////////////////////////////
//  ITVEService

								// simple little macro so we can do same test in all methods
#define RETURN_IF_NOT_BOUND_TO_SERVICE	\
	if(NULL == m_spService)	\
		return E_INVALIDARG;

STDMETHODIMP CTVEFeature::get_Parent(/*[out, retval]*/ IUnknown* *ppVal)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::get_Parent"));
	
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->get_Parent(ppVal);

}

STDMETHODIMP CTVEFeature::get_Enhancements(/*[out, retval]*/ ITVEEnhancements* *ppVal)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::get_Enhancements"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->get_Enhancements(ppVal);
}

STDMETHODIMP CTVEFeature::get_Description(/*[out, retval]*/ BSTR *pVal)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::get_Description"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->get_Description(pVal);
}

STDMETHODIMP CTVEFeature::put_Description(/*[in]*/ BSTR newVal)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::put_Description"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->put_Description(newVal);
}

STDMETHODIMP CTVEFeature::get_XOverEnhancement(/*out, retval*/ ITVEEnhancement **ppVal)	// special for tree views... (use get_XOverLinks)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::get_XOverEnhancement"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->get_XOverEnhancement(ppVal);
}

STDMETHODIMP CTVEFeature::get_XOverLinks(/*[out, retval]*/ ITVETracks* *ppVal)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::get_XOverLinks"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->get_XOverLinks(ppVal);
}

STDMETHODIMP CTVEFeature::NewXOverLink(/*[in]*/ BSTR bstrLine21Trigger)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::NewXOverLink"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->NewXOverLink(bstrLine21Trigger);
}

STDMETHODIMP CTVEFeature::get_ExpireOffset(/*[out, retval]*/ DATE *pDate)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::get_ExpireOffset"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->get_ExpireOffset(pDate);
}

STDMETHODIMP CTVEFeature::put_ExpireOffset(/*[in]*/ DATE newDateOffset)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::put_ExpireOffset"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->put_ExpireOffset(newDateOffset);
}

STDMETHODIMP CTVEFeature::get_ExpireQueue(/*[out]*/ ITVEAttrTimeQ **ppVal)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::get_ExpireQueue"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->get_ExpireQueue(ppVal);
}

STDMETHODIMP CTVEFeature::ExpireForDate(/*[in]*/ DATE dateExpireTime)		// if DATE=0, use <NOW>-offset

{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::ExpireForDate"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->ExpireForDate(dateExpireTime);
}

STDMETHODIMP CTVEFeature::Activate()
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::Activate"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->Activate();
}

STDMETHODIMP CTVEFeature::Deactivate()
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::Deactivate"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->Deactivate();
}

STDMETHODIMP CTVEFeature::get_IsActive(VARIANT_BOOL *pfIsActive)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::get_IsActive"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->get_IsActive(pfIsActive);
}

STDMETHODIMP CTVEFeature::put_Property(/*[in]*/ BSTR bstrPropName,/*[in]*/ BSTR bstrPropVal)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::put_Property"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->put_Property(bstrPropName, bstrPropVal);
}

STDMETHODIMP CTVEFeature::get_Property(/*[in]*/ BSTR bstrPropName,/*[in]*/ BSTR *pbstrPropVal)
{
	DBG_HEADER(CDebugLog::DBG_FEATURE, _T("CTVEFeature::get_Property"));
	RETURN_IF_NOT_BOUND_TO_SERVICE
	
	return m_spService->get_Property(bstrPropName, pbstrPropVal);
}
//////////////////////////////////////////////////////////////////////////////////////////////
// _ITVEEvents
//
//			These event methods receive all ALL the TveSupervisor events.
//			However, the filter out all events not pertaining to this service, only sending
//			the desired ones upward.
//
//			The one exception is the AuxInfo event - there is no way to filter it...
// ----------------------------------------------------------
STDMETHODIMP CTVEFeature::NotifyTVETune(/*[in]*/ NTUN_Mode tuneMode,/*[in]*/ ITVEService *pService,/*[in]*/ BSTR bstrDescription,/*[in]*/ BSTR bstrIPAdapter)
{
	DBG_HEADER(CDebugLog::DBG_FEAT_EVENTS, _T("NotifyTVETune"));
	RETURN_IF_NOT_BOUND_TO_SERVICE

	if(pService == m_spService)
		return Fire_NotifyTVETune(tuneMode, pService, bstrDescription, bstrIPAdapter); 
	else
		return S_OK;		
}

STDMETHODIMP CTVEFeature::NotifyTVEEnhancementNew(/*[in]*/ ITVEEnhancement *pEnh)
{
	DBG_HEADER(CDebugLog::DBG_FEAT_EVENTS, _T("NotifyTVEEnhancementNew"));
	RETURN_IF_NOT_BOUND_TO_SERVICE

	if(pEnh)
	{
		ITVEServicePtr spService;
		HRESULT hr = pEnh->get_Service(&spService);
		if(hr == S_OK && spService == m_spService)
			return Fire_NotifyTVEEnhancementNew( pEnh); 
	} 
	return S_OK;
}

		// changedFlags : NENH_grfDiff
STDMETHODIMP CTVEFeature::NotifyTVEEnhancementUpdated(/*[in]*/ ITVEEnhancement *pEnh, /*[in]*/ long lChangedFlags)
{
	DBG_HEADER(CDebugLog::DBG_FEAT_EVENTS, _T("NotifyTVEEnhancementUpdated"));
	RETURN_IF_NOT_BOUND_TO_SERVICE

	if(pEnh)
	{
		ITVEServicePtr spService;
		HRESULT hr = pEnh->get_Service(&spService);
		if(hr == S_OK && spService == m_spService)
			return Fire_NotifyTVEEnhancementUpdated( pEnh, lChangedFlags); 
	} 
	return S_OK;
}
	
STDMETHODIMP CTVEFeature::NotifyTVEEnhancementStarting(/*[in]*/ ITVEEnhancement *pEnh)
{
	DBG_HEADER(CDebugLog::DBG_FEAT_EVENTS, _T("NotifyTVEEnhancementStarting"));
	RETURN_IF_NOT_BOUND_TO_SERVICE

	if(pEnh)
	{
		ITVEServicePtr spService;
		HRESULT hr = pEnh->get_Service(&spService);
		if(hr == S_OK && spService == m_spService)
			return Fire_NotifyTVEEnhancementStarting( pEnh); 
	} 
	return S_OK;
}

STDMETHODIMP CTVEFeature::NotifyTVEEnhancementExpired(/*[in]*/ ITVEEnhancement *pEnh)
{
	DBG_HEADER(CDebugLog::DBG_FEAT_EVENTS, _T("NotifyTVEEnhancementExpired"));
	RETURN_IF_NOT_BOUND_TO_SERVICE

	if(pEnh)
	{
		ITVEServicePtr spService;
		HRESULT hr = pEnh->get_Service(&spService);
		if(hr == S_OK && spService == m_spService)
			return Fire_NotifyTVEEnhancementExpired ( pEnh); 
	} 
	return S_OK;
}

STDMETHODIMP CTVEFeature::NotifyTVETriggerNew(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive)
{
	DBG_HEADER(CDebugLog::DBG_FEAT_EVENTS, _T("NotifyTVETriggerNew"));
	RETURN_IF_NOT_BOUND_TO_SERVICE

	if(pTrigger)
	{
		ITVEServicePtr spService;
		HRESULT hr = pTrigger->get_Service(&spService);
		if(hr == S_OK && spService == m_spService)
			return Fire_NotifyTVETriggerNew( pTrigger, fActive ); 
	} 
	return S_OK;
}

		// changedFlags : NTRK_grfDiff
STDMETHODIMP CTVEFeature::NotifyTVETriggerUpdated(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive, /*[in]*/ long lChangedFlags)
{
	DBG_HEADER(CDebugLog::DBG_FEAT_EVENTS, _T("NotifyTVETriggerUpdated"));
	RETURN_IF_NOT_BOUND_TO_SERVICE

	if(pTrigger)
	{
		ITVEServicePtr spService;
		HRESULT hr = pTrigger->get_Service(&spService);
		if(hr == S_OK && spService == m_spService)
			return Fire_NotifyTVETriggerUpdated(  pTrigger, fActive, lChangedFlags ); 
	} 
	return S_OK;
}
	
STDMETHODIMP CTVEFeature::NotifyTVETriggerExpired(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive)
{
	DBG_HEADER(CDebugLog::DBG_FEAT_EVENTS, _T("NotifyTVETriggerExpired"));
	RETURN_IF_NOT_BOUND_TO_SERVICE

	if(pTrigger)
	{
		ITVEServicePtr spService;
		HRESULT hr = pTrigger->get_Service(&spService);
		if(hr == S_OK && spService == m_spService)
			return Fire_NotifyTVETriggerExpired( pTrigger, fActive); 
	} 
	return S_OK;
}

STDMETHODIMP CTVEFeature::NotifyTVEPackage(/*[in]*/ NPKG_Mode engPkgMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUUID, /*[in]*/ long  cBytesTotal, /*[in]*/ long  cBytesReceived)
{
	DBG_HEADER(CDebugLog::DBG_FEAT_EVENTS, _T("NotifyTVEPackage"));
	RETURN_IF_NOT_BOUND_TO_SERVICE

	if(pVariation)
	{
		ITVEServicePtr spService;
		HRESULT hr = pVariation->get_Service(&spService);
		if(hr == S_OK && spService == m_spService)
			return Fire_NotifyTVEPackage( engPkgMode, pVariation, bstrUUID, cBytesTotal, cBytesReceived); 
	} 
	return S_OK;
}

STDMETHODIMP CTVEFeature::NotifyTVEFile(/*[in]*/ NFLE_Mode engFileMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUrlName, /*[in]*/ BSTR bstrFileName)
{
	DBG_HEADER(CDebugLog::DBG_FEAT_EVENTS, _T("NotifyTVEFile"));
	RETURN_IF_NOT_BOUND_TO_SERVICE

	if(pVariation)
	{
		ITVEServicePtr spService;
		HRESULT hr = pVariation->get_Service(&spService);
		if(hr == S_OK && spService == m_spService)
			return Fire_NotifyTVEFile( engFileMode, pVariation, bstrUrlName, bstrFileName); 
	} 
	return S_OK;
}

		// WhatIsIt is NWHAT_Mode - lChangedFlags is NENH_grfDiff or NTRK_grfDiff treated as error bits
STDMETHODIMP CTVEFeature::NotifyTVEAuxInfo(/*[in]*/ NWHAT_Mode engAuxInfoMode, /*[in]*/ BSTR bstrAuxInfoString, /*[in]*/ long lChangedFlags, /*[in]*/ long lErrorLine)
{
	DBG_HEADER(CDebugLog::DBG_FEAT_EVENTS, _T("NotifyTVEAuxInfo"));

	return Fire_NotifyTVEAuxInfo( engAuxInfoMode, bstrAuxInfoString, lChangedFlags, lErrorLine); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveenhan.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEEnhancement.h : Declaration of the CTVEEnhancement

#ifndef __TVEENHANCEMENT_H_
#define __TVEENHANCEMENT_H_

#include "resource.h"       // main symbols

#include "TVEAttrM.h"
#include "TVEVarias.h"
#include "TVEVaria.h"

_COM_SMARTPTR_TYPEDEF(ITVEAttrMap, __uuidof(ITVEAttrMap));
_COM_SMARTPTR_TYPEDEF(ITVEVariation, __uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEVariation_Helper, __uuidof(ITVEVariation_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEVariations, __uuidof(ITVEVariations));


/////////////////////////////////////////////////////////////////////////////
const BSTR kbstrSDPVersion(L"v=0\n");
const BSTR kbstrSDPVersionCR(L"v=0\r");
const BSTR kbstrATVEFTypeTVE(L"a=type:tve");
const BSTR kbstrATVEFBandwithCT(L"CT:");
const BSTR kbstrATVEFBandwithAS(L"AS:");
const BSTR kbstrTveFile(L"tve-file");
const BSTR kbstrTveTrigger(L"tve-trigger");
const BSTR kbstrData(L"data");
const BSTR kbstrConnection(L"IN IP4 ");

/////////////////////////////////////////////////////////////////////////////
//  SAP header (http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sap-v2-02.txt)

struct SAPHeaderBits				// first 8 bits in the SAP header (comments indicate ATVEF state)
{
	union {
		struct {
			unsigned Compressed:1;		// if 1, SAP packet is compressed (0 only) 
			unsigned Encrypted:1;		// if 1, SAP packet is encrypted (0 only) 
			unsigned MessageType:1;		// if 0, session announcement packet, if 1, session deletion packet (0 only)
			unsigned Reserved:1;		// must be 0, readers ignore this	(ignored)
			unsigned AddressType:1;		// if 0, 32bit IPv4 address, if 1, 128-bit IPv6 (0 only)
			unsigned Version:3;			// must be 1  (1 only)
		} s; 
		unsigned char uc;
	};
};


/////////////////////////////////////////////////////////////////////////////
// CTVEEnhancement
class ATL_NO_VTABLE CTVEEnhancement : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTVEEnhancement, &CLSID_TVEEnhancement>,
	public ITVEEnhancement_Helper,
	public ISupportErrorInfo,
	public IDispatchImpl<ITVEEnhancement, &IID_ITVEEnhancement, &LIBID_MSTvELib>
{
public:
	CTVEEnhancement()
	{
		m_fInit		= false;

		m_pService = NULL;							// up pointer, not reference counted

		m_dateStart = 0;
		m_dateStop = 0;
		m_fIsPrimary = false;
		m_fIsValid   = false;

		m_ulSessionId = 0;
		m_ulSessionVersion = 0;
		
		m_rTveLevel = 0.0;
		m_ulTveSize = 0;

        m_fDataMedia	= TRUE;							// used when parsing data and trigger ports
        m_fTriggerMedia = TRUE;

		m_ucSAPHeaderBits = 0;
		m_ucSAPAuthLength = 0;		
		m_usSAPMsgIDHash = 0;
	} 
	
	HRESULT FinalConstruct();							// create internal objects

	virtual ~CTVEEnhancement()
	{
		static int cDel = 0;					// place to hang a breakpoint
		cDel++;
	}

	HRESULT	FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_TVEENHANCEMENT)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVEEnhancement)
	COM_INTERFACE_ENTRY(ITVEEnhancement)
	COM_INTERFACE_ENTRY(ITVEEnhancement_Helper)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(__uuidof(IMarshal), m_spUnkMarshaler.p)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	CComPtr<IUnknown> m_spUnkMarshaler;

// ITVEEnhancement
public:
	STDMETHOD(get_Parent)(/*[out, retval]*/ IUnknown* *pVal);			// may return NULL!
	STDMETHOD(get_Service)(/*[out, retval]*/ ITVEService* *pVal);		// may return NULL!
	STDMETHOD(get_Variations)(/*[out, retval]*/ ITVEVariations* *pVal);

	void Initialize(BSTR strDesc);					// debug

	STDMETHOD(get_IsValid)(/*[out, retval]*/ VARIANT_BOOL *pVal);

	STDMETHOD(get_SAPHeaderBits)(/*[out, retval]*/short *pVal);			// from the SAP header (first 8 bits)
	STDMETHOD(get_SAPAuthLength)(/*[out, retval]*/short *pVal);
	STDMETHOD(get_SAPMsgIDHash)(/*[out, retval]*/ LONG *pVal);	
	STDMETHOD(get_SAPSendingIP)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SAPAuthData)(/*[out, retval]*/BSTR *pVal);

	STDMETHOD(get_ProtocolVersion)(/*[out, retval]*/ BSTR *pVal);		// v=?
	STDMETHOD(get_SessionUserName)(/*[out, retval]*/ BSTR *pVal);		// o=username SID Version <IN IP4> ipaddress
	STDMETHOD(get_SessionId)(/*[out, retval]*/ LONG *plVal);
	STDMETHOD(get_SessionVersion)(/*[out, retval]*/ LONG *plVal);
	STDMETHOD(get_SessionIPAddress)(/*[out, retval]*/ BSTR *pVal);

	STDMETHOD(get_SessionName)(/*[out, retval]*/ BSTR *pVal);			// s=

	STDMETHOD(get_EmailAddresses)(/*[out, retval]*/ ITVEAttrMap **ppVal);	// e=?   (ITVEAttrMap)
	STDMETHOD(get_PhoneNumbers)(/*[out, retval]*/ ITVEAttrMap **ppVal);	// p=?	 (ITVEAttrMap)

	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);			// (i=?)
	STDMETHOD(put_Description)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_DescriptionURI)(/*[out, retval]*/ BSTR *pVal);		// (u=?)

	STDMETHOD(get_UUID)(/*[out, retval]*/ BSTR *pVal);					// a=UUID:?
	STDMETHOD(get_StartTime)(/*[out, retval]*/ DATE *pVal);				// t=? ?
	STDMETHOD(get_StopTime)(/*[out, retval]*/ DATE *pVal);				//     or a=tve-ends:
	STDMETHOD(get_Type)(/*out, retval]*/ BSTR *pVal);					// a=type:? <should be tve>
	STDMETHOD(get_TveType)(/*out, retval]*/ BSTR *pVal);				// a=tve-type:?  
	STDMETHOD(get_IsPrimary)(/*[out, retval]*/ VARIANT_BOOL *pVal);		// (did tve-type: include 'primary'
	STDMETHOD(get_TveSize)(/*[out, retval]*/ LONG *plVal);				// a=tve-size:?
	STDMETHOD(get_TveLevel)(/*[out, retval]*/ double *pVal);			// a=tve-level:? <should be 1.0>

	STDMETHOD(get_Attributes)(/*[out, retval]*/ ITVEAttrMap **ppVal);	// other a=? fields  (ITVEAttrMap)
	STDMETHOD(get_Rest)(/*[out, retval]*/ ITVEAttrMap **ppVal);			// other non a=? fields

	STDMETHOD(ParseAnnouncement)(BSTR bstrAdapter, const BSTR *pbstVal, long *plgrfParseError, long *plLineError);						// parses SAP/SDP header

	// ITVEEnhancement_Helper
public:
	STDMETHOD(InitAsXOver)();			// creates as the one and only XOver enhancement (takes Line21 triggers)
	STDMETHOD(NewXOverLink)(/*in*/ BSTR bstrLine21Trigger);
	STDMETHOD(UpdateEnhancement)(/*[in]*/ ITVEEnhancement *pEnhNew,/*[out]*/ long *plNENH_grfChanged);
	STDMETHOD(ConnectParent)(/*[in]*/ ITVEService * pService);
	STDMETHOD(RemoveYourself)();
	STDMETHOD(DumpToBSTR)(/*[in,out]*/ BSTR *pbstrBuff);
	STDMETHOD(Activate)();					// creates and joins all multicast's associated with this enhancement..
	STDMETHOD(Deactivate)();				// removes all multicast's associated with this enhancement..

private:
	HRESULT	ParseSAPHeader(const BSTR *pbstVal, DWORD *pcBytesSAP, long *plgrfParseError);		// parses SAP header part of SDP.. returns # bytes to SDP part
	HRESULT ParseOwner(const wchar_t *wszArg, long *plgrfParseError);
	HRESULT ParseStartStopTime(const wchar_t *wszArg);
	HRESULT ParseAttributes();


private:
	CTVESmartLock		m_sLk;

private:
//	CRITICAL_SECTION			m_crt ;
 //	void lock_ ()				{ EnterCriticalSection (&m_crt) ; }
 //   void unlock_ ()				{ LeaveCriticalSection (&m_crt) ; }

	HRESULT SetBandwidth(const wchar_t *wszArg);
	bool						m_fInit;			// set to true when structure initialized

	ITVEService					*m_pService;		// up tree pointer, no addref

	ITVEVariationPtr		m_spVariationBase;	// default variation parameters (pre-media type)
	ITVEVariationsPtr		m_spVariations;		// down tree collection pointer

	BYTE		m_ucSAPHeaderBits;
	BYTE		m_ucSAPAuthLength;		
	USHORT		m_usSAPMsgIDHash;
	CComBSTR	m_spbsSAPSendingIP;					// SAP header 
	CComBSTR	m_spbsSAPAuthData;					// SAP authorization data

	BOOL		m_fIsValid;

	CComBSTR	m_spbsProtocolVersion;				// v=
	CComBSTR	m_spbsDescription;					// i=(optional hacky set)
	CComBSTR	m_spbsDescriptionURI;				// u=

	CComBSTR	m_spbsSessionUserName;				// o: userName SID version IN IP4 ipaddress
	DWORD		m_ulSessionId;
	DWORD		m_ulSessionVersion;
	CComBSTR	m_spbsSessionIPAddress;

	CComBSTR	m_spbsSessionName;					// s:

	ITVEAttrMapPtr	m_spamEmailAddresses;	// e: parameters
	ITVEAttrMapPtr	m_spamPhoneNumbers;		// p: parameters

	CComBSTR	m_spbsUUID;							// in a:UUID: field
	DATE		m_dateStart;						// t=start stop
	DATE		m_dateStop;							//    or a=tve-ends

	CComBSTR	m_spbsType;							// the a:type attribute - should be 'tve'
	CComBSTR	m_spbsTveType;						// the a:tve-type attribute, may contain 'primary'
	BOOL		m_fIsPrimary;						// extracted from above..

	DWORD		m_ulTveSize;						// a=tve-size
	double		m_rTveLevel;						// a=tve-level

	ITVEAttrMapPtr	m_spamAttributes;		// a: parameters
	ITVEAttrMapPtr	m_spamRest;				// anything left over, seperated by New lines

	BOOL		m_fDataMedia;
    BOOL		m_fTriggerMedia;
};

#endif //__TVEENHANCEMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvefile.cpp ===
// Copyright (c) 1999, 2000, 2001  Microsoft Corporation.  All Rights Reserved.
// TVEFile.cpp : Implementation of CTVEFile

#include "stdafx.h"
#include <stdio.h>

#include "MSTvE.h"
#include "TVEFile.h"
#include "TveSmartLock.h"
#include "TveAttrQ.h"		// expireQ

#include "TveDbg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,		__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,	__uuidof(ITVEEnhancement_Helper));

_COM_SMARTPTR_TYPEDEF(ITVEAttrTimeQ,			__uuidof(ITVEAttrTimeQ));		// expire queue


/////////////////////////////////////////////////////////////////////////////
// CTVEFile
STDMETHODIMP 
CTVEFile::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] =
	{
		&IID_ITVEFile
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT 
CTVEFile::FinalRelease()
{
/*	if(m_spVariation)		// don't want this here, after all, should have no refcounts
	{						// need to make sure that File removed from ExpQueue before this
		ITVEServicePtr spService;
		HRESULT hr = m_spVariation->get_Service(&spService);
		if(!FAILED(hr) && NULL != spService)
		{
			ITVEService_HelperPtr spServHelper(spService);
			IUnknownPtr spPunkThis(this);
			spServHelper->RemoveFromExpireQueue(spPunkThis);
		}
	}
*/
	m_spVariation    = NULL;
	m_spUnkMarshaler = NULL;


	return S_OK;
}



STDMETHODIMP 
CTVEFile::InitializeFile(/*[in]*/ ITVEVariation *pVaria, /*[in]*/ BSTR bsName, /*[in]*/ BSTR bsLoc, /*[in]*/ DATE dateExpires)
{
	m_fIsPackage = false;
	if(NULL == pVaria)
		return E_INVALIDARG;


	m_spVariation = pVaria;			// non-refcounted up pointer (??? should I refcount this?)
	m_dateExpires = dateExpires;
	m_spbsDesc = bsName;
	m_spbsLoc = bsLoc;
	return S_OK;
}

STDMETHODIMP 
CTVEFile::InitializePackage(/*[in]*/ ITVEVariation *pVaria, /*[in]*/ BSTR bsName, /*[in]*/ BSTR bsLoc, /*[in]*/ DATE dateExpires)
{
	m_fIsPackage = true;
	if(NULL == pVaria)
		return E_INVALIDARG;

	m_spVariation = pVaria;
	m_dateExpires = dateExpires;
	m_spbsDesc = bsName;
	m_spbsLoc = "";

	return S_OK;
}

STDMETHODIMP 
CTVEFile::RemoveYourself()
{
	if(m_spVariation == NULL)
		return S_OK;
	ITVEServicePtr spService;
	HRESULT hr = m_spVariation->get_Service(&spService);
	if(!FAILED(hr) && NULL != spService) 
	{
		ITVEService_HelperPtr spServHelper(spService);

		IUnknownPtr spPunkSuper;
		hr = spService->get_Parent(&spPunkSuper);
		if(!FAILED(hr) && NULL != spPunkSuper)
		{
			ITVESupervisor_HelperPtr spSuperHelper(spPunkSuper);
			if(m_fIsPackage)
			{
					// do nothing here, do PurgeExpiredPackages() down deep 
					// in the package code
					//   since are having trouble getting hold of the UHTTP_Receiver object
			} else {
				spSuperHelper->NotifyFile(NFLE_Expired, m_spVariation, m_spbsDesc, m_spbsLoc);  
				m_spVariation = NULL;
			}
		}
	} else {
		m_spVariation = NULL;		// for paranoia
	}
	return hr;
}


STDMETHODIMP 
CTVEFile::get_IsPackage(/*[out, retval]*/ BOOL *pfVal)
{
	if(NULL == pfVal)
		return E_POINTER;
	*pfVal = m_fIsPackage;

	return S_OK;
}

STDMETHODIMP 
CTVEFile::get_Variation(/*[out, retval]*/ ITVEVariation* *pVal)
{
	*pVal = m_spVariation;
	if(*pVal)
		(*pVal)->AddRef();
	return S_OK;
}

STDMETHODIMP 
CTVEFile::get_Service(/*[out, retval]*/ ITVEService* *pVal)
{
	if(m_spVariation)
	{
		return m_spVariation->get_Service(pVal);
	}
	*pVal = NULL;
	return S_OK;
	
}

STDMETHODIMP 
CTVEFile::get_Description(BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);
    try {
        return m_spbsDesc.CopyTo(pVal);
	} catch(HRESULT hr) {
		return hr;
    } catch(...) {
        return E_POINTER;
    }
}

STDMETHODIMP 
CTVEFile::get_Location(BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);
    try {
        return m_spbsLoc.CopyTo(pVal);
 	} catch(HRESULT hr) {
		return hr;
	} catch(...) {
        return E_POINTER;
    }
}


STDMETHODIMP 
CTVEFile::get_ExpireTime(DATE *pDateExpires)
{
	CHECK_OUT_PARAM(pDateExpires);
    try {
        *pDateExpires = m_dateExpires;
		return S_OK;
 	} catch(HRESULT hr) {
		return hr;
    } catch(...) {
        return E_POINTER;
    }
}

STDMETHODIMP 
CTVEFile::DumpToBSTR(/*out*/ BSTR *pBstrBuff)
{
	const int kMaxChars = 1024;
	WCHAR wtBuff[kMaxChars];
	CComBSTR bstrOut;
	CComBSTR spbstrTmp;
	bstrOut.Empty();

	swprintf(wtBuff,L" - Expires %s (%s)\n",DateToBSTR(m_dateExpires), DateToDiffBSTR(m_dateExpires));
	bstrOut.AppendBSTR(m_spbsDesc);
	bstrOut.Append(wtBuff);

	bstrOut.CopyTo(pBstrBuff);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvefile.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVETrack.h : Declaration of the CTVETrack

#ifndef __TVEFILE_H_
#define __TVEFILE_H_

#include "resource.h"			// main symbols
#include "TveSmartLock.h"
#include "TveSuper.h"

_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
/////////////////////////////////////////////////////////////////////////////
// CTVETrack
class ATL_NO_VTABLE CTVEFile : 
	public CComObjectRootEx<CComMultiThreadModel>,		// CComSingleThreadModel
	public CComCoClass<CTVEFile, &CLSID_TVEFile>,
	public ISupportErrorInfo,
	public IDispatchImpl<ITVEFile, &IID_ITVEFile, &LIBID_MSTvELib>
{
public:
	CTVEFile()
	{
		m_fIsPackage		= NULL;
		m_dateExpires		= NULL;
		m_spbsDesc.Empty();
		m_spbsLoc.Empty();
	} 

	HRESULT FinalConstruct()								// create internal objects
	{
		HRESULT hr = S_OK;
		hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_spUnkMarshaler.p);
		if(FAILED(hr)) {
			_ASSERT(FALSE);
			return hr;
		}
		return hr;
	}

	HRESULT FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_TVEFILE)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVEFile)
	COM_INTERFACE_ENTRY(ITVEFile)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	CComPtr<IUnknown> m_spUnkMarshaler;

// ITVEFile
public:
	STDMETHOD(InitializePackage)(/*[in]*/ ITVEVariation *pVaria, /*[in]*/ BSTR bsName, /*[in]*/ BSTR bsLoc, /*[in]*/ DATE dateExpires);
	STDMETHOD(InitializeFile)(/*[in]*/ ITVEVariation *pVaria, /*[in]*/ BSTR bsName, /*[in]*/ BSTR bsLoc, /*[in]*/ DATE dateExpires);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pbsDesc);
	STDMETHOD(get_Location)(/*[out, retval]*/ BSTR *pbsLocation);
	STDMETHOD(get_ExpireTime)(/*[out, retval]*/ DATE *pdateExpire);
	STDMETHOD(get_IsPackage)(/*[out, retval]*/ BOOL *pfVal);
	STDMETHOD(get_Variation)(/*[out, retval]*/ ITVEVariation* *pVal);
	STDMETHOD(get_Service)(/*[out, retval]*/ ITVEService* *pVal);
	STDMETHOD(RemoveYourself)();			// remove out of the queue, fire various events.

// ITVEFile_Helper
public:

	STDMETHOD(DumpToBSTR)(BSTR *pbstrBuff);

private:
	CTVESmartLock		m_sLk;

private:
	ITVEVariationPtr	m_spVariation;			// up pointer - non add'refed. (watch it - this may become bad)
	BOOL				m_fIsPackage;			// TRUE if package, instead of a file

	CComBSTR			m_spbsDesc;				// name for files, or string from UUID for package
	CComBSTR			m_spbsLoc;				// where its stored, ignored for packages 
	DATE				m_dateExpires;

};

#endif //__TVEFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvefeature.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEFeature.h : Declaration of the CTVEFeature
//


#ifndef __TVEFEATURE_H__
#define __TVEFEATURE_H__

#include "resource.h"       // main symbols
#include "TveSmartLock.h"
#include "mstveCP.h"


_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEServices,				__uuidof(ITVEServices));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,		__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,	__uuidof(ITVEEnhancement_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEVariation_Helper,		__uuidof(ITVEVariation_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrack,				__uuidof(ITVETrack));
_COM_SMARTPTR_TYPEDEF(ITVETrack_Helper,			__uuidof(ITVETrack_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,				__uuidof(ITVETrigger));
_COM_SMARTPTR_TYPEDEF(ITVETrigger_Helper,		__uuidof(ITVETrigger_Helper));


/////////////////////////////////////////////////////////////////////////////
// CTVEFeature
class ATL_NO_VTABLE CTVEFeature : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTVEFeature, &CLSID_TVEFeature>,
//	public ITVEService,
//	public ITVEService_Helper,
	public ISupportErrorInfo,
	public IDispatchImpl<ITVEFeature, &IID_ITVEFeature, &LIBID_MSTvELib>,
	public CProxy_ITVEEvents< CTVEFeature >,
	public IConnectionPointContainerImpl<CTVEFeature>,
	public IProvideClassInfo2Impl<&CLSID_TVEFeature, &DIID__ITVEEvents, &LIBID_MSTvELib>
{
public:
	CTVEFeature()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVEFEATURE)

DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CTVEFeature)
	COM_INTERFACE_ENTRY(ITVEFeature)
//	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY2(IDispatch, ITVEFeature)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IProvideClassInfo)					// used by EventBinder
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CTVEFeature)
	CONNECTION_POINT_ENTRY(DIID__ITVEEvents)
END_CONNECTION_POINT_MAP()

//
	HRESULT FinalConstruct()								// create internal objects
	{
		HRESULT hr = S_OK;
		m_dwSuperTVEEventsAdviseCookie = 0;
		return hr;
	}

	HRESULT FinalRelease();

	HRESULT SetupTVEEventReflector();
	HRESULT TeardownTVEEventReflector();

// ISupportsErrorInfo
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	// ITVEFeature
	STDMETHOD(BindToSupervisor)(/*[in]*/ ITVESupervisor *pSupervisor);
	STDMETHOD(TuneTo)(/*[in]*/ BSTR bstrStation, /*[in]*/ BSTR bstrIPAdapter);
	STDMETHOD(ReTune)(/*[in]*/ ITVEService *ITVEService);

	// ITVEService
	STDMETHOD(get_Parent)(/*[out, retval]*/ IUnknown **ppVal);
	STDMETHOD(get_Enhancements)(/*[out, retval]*/ ITVEEnhancements* *ppVal);

	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *ppVal);
	STDMETHOD(put_Description)(/*[in]*/ BSTR newVal);

	STDMETHOD(get_XOverEnhancement)(/*out, retval*/ ITVEEnhancement **ppVal);	// special for tree views... (use get_XOverLinks)
	STDMETHOD(get_XOverLinks)(/*[out, retval]*/ ITVETracks* *pVal);				// ITVETracks collection
	STDMETHOD(NewXOverLink)(/*[in]*/ BSTR bstrLine21Trigger);
	STDMETHOD(get_ExpireOffset)(/*[out, retval]*/ DATE *pDate);
	STDMETHOD(put_ExpireOffset)(/*[in]*/ DATE newVal);
	STDMETHOD(get_ExpireQueue)(/*[out]*/ ITVEAttrTimeQ **ppVal);
	STDMETHOD(ExpireForDate)(/*[in]*/ DATE dateExpireTime);		// if DATE=0, use <NOW>-offset

	STDMETHOD(Activate)();
	STDMETHOD(Deactivate)();
	STDMETHOD(get_IsActive)(VARIANT_BOOL *pfActive);

	STDMETHOD(put_Property)(/*[in]*/ BSTR bstrPropName,/*[in]*/ BSTR bstrPropVal);
	STDMETHOD(get_Property)(/*[in]*/ BSTR bstrPropName, /*[out, retval]*/  BSTR *pbstrPropVal);

	// _ITVEEvents (sink)

	STDMETHOD(NotifyTVETune)(/*[in]*/ NTUN_Mode tuneMode,/*[in]*/ ITVEService *pService,/*[in]*/ BSTR bstrDescription,/*[in]*/ BSTR bstrIPAdapter);
	STDMETHOD(NotifyTVEEnhancementNew)(/*[in]*/ ITVEEnhancement *pEnh);
		// changedFlags : NENH_grfDiff
	STDMETHOD(NotifyTVEEnhancementUpdated)(/*[in]*/ ITVEEnhancement *pEnh, /*[in]*/ long lChangedFlags);	
	STDMETHOD(NotifyTVEEnhancementStarting)(/*[in]*/ ITVEEnhancement *pEnh);
	STDMETHOD(NotifyTVEEnhancementExpired)(/*[in]*/ ITVEEnhancement *pEnh);
	STDMETHOD(NotifyTVETriggerNew)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive);
		// changedFlags : NTRK_grfDiff
	STDMETHOD(NotifyTVETriggerUpdated)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive, /*[in]*/ long lChangedFlags);	
	STDMETHOD(NotifyTVETriggerExpired)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive);
	STDMETHOD(NotifyTVEPackage)(/*[in]*/ NPKG_Mode engPkgMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUUID, /*[in]*/ long  cBytesTotal, /*[in]*/ long  cBytesReceived);
	STDMETHOD(NotifyTVEFile)(/*[in]*/ NFLE_Mode engFileMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUrlName, /*[in]*/ BSTR bstrFileName);
		// WhatIsIt is NWHAT_Mode - lChangedFlags is NENH_grfDiff or NTRK_grfDiff treated as error bits
	STDMETHOD(NotifyTVEAuxInfo)(/*[in]*/ NWHAT_Mode engAuxInfoMode, /*[in]*/ BSTR bstrAuxInfoString, /*[in]*/ long lChangedFlags, /*[in]*/ long lErrorLine);	


public:

// ITVEFeature_Helper
public:

private:
	CTVESmartLock		m_sLk;
 
private:
	ITVESupervisorPtr	m_spSuper;
	ITVEServicePtr		m_spService;		// currently active service

	DWORD	m_dwSuperTVEEventsAdviseCookie;		// from Advise to get _ITVEEvents

public :


};

#endif //__TVEFEATURE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvefilt.cpp ===
//==========================================================================;
//  TveFilt.cpp
//
//			TVE Receiver Filter - major filter objects
//
//		Input filters:
// 			The 'Tune' pin connects to the BDA IPSink Filter  (BDA Rendering Filters) 
//			The 'CC' pin connects to the CC Decoder filter (WDM Streaming VBI Codes)
//			
//
//	------------------------------------------------------------------------
//
//	Notes:
//
//		CDShowTVEFilter class does most of the DShow stuff, forwarding specific stuff.
//		CTVEFilter class does all stuff specific to this class.
//
//		Main methods in CTVEFilter are:
//
//			DoCCConnect()		- sets CC Decoder filter to just send T2 data
//			DoTuneConnect()		- retrieves the IP adapter address from IP Sink filter
//			ParseCCBytePair()	- called by CC Pin Receive() method to collect byte pairs
//								  up into full XOver Triggers... (See L21Buff class).
//
//

#include "stdafx.h"

#include "MSTvE.h"			// MIDL generated file...

#include "CommCtrl.h"

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#include <Iphlpapi.h>		// GetAdaptersInfo, GetUniDirectionalAdaptersInfo

#include <bdaiface.h>		// D:\nt\multimedia\Published\DXMDev\dshowdev\idl\objd\i386\bdaiface.h

/*
		// this loads F:\nt\multimedia\Published\DXMDev\dshowdev\base\wxdebug.h
		// which uses lots of Debug in it..
#ifdef DEBUG
#define DEBUG_XXX
#undef DEBUG
#endif 
#include <streams.h>
#ifdef DEBUG_XXX
#define DEBUG
#endif
*/
#include <streams.h>

//#include <initguid.h>		// cause Guids to be declared in this DLL
#include "TveReg.h"			// registry setting...

#include "TveDbg.h"			// My debug tracing 
#include "TveFilt.h"		// all the stuff for this file... 

//DBG_INIT(DEF_LOG_TVEFILT);


///////////////////////////////////////////////////////////////////

#ifndef _T
#define _T(_x_) TEXT(_x_)
#endif

#define O_TRACE_ENTER_0(x)
#define O_TRACE_ENTER_1(x,y)
#define O_TRACE_ENTER_2(x,y,z)
#define TRACE_CONSTRUCTOR(x)
#define TRACE_DESTRUCTOR(x)

// ------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------
_COM_SMARTPTR_TYPEDEF(ITVESupervisor,		    __uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,    __uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(IGlobalInterfaceTable,    __uuidof(IGlobalInterfaceTable));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,		    __uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager_Helper,	__uuidof(ITVEMCastManager_Helper));

// -------------------------------------------------------------------------
// -------------------------------------------------------------------------

const AMOVIESETUP_MEDIATYPE sudTunePinTypes =
{
    &KSDATAFORMAT_TYPE_BDA_IP_CONTROL,            // Major type
    &KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL          // Minor type
};



const AMOVIESETUP_MEDIATYPE sudCCPinTypes =
{
    &KSDATAFORMAT_TYPE_AUXLine21Data,				// Major type
    &KSDATAFORMAT_SUBTYPE_Line21_BytePair    // Minor type
};

const AMOVIESETUP_PIN rgSudPins[] =
{
	{
    INPUT_PIN0_NAME,            // Pin string name ("Tune")
    TRUE,                       // Is it rendered
    FALSE,                      // Is it an output
    TRUE,                       // Allowed none
    FALSE,                      // Likewise many
    &CLSID_NULL,				// Connects to filter (IPSink) - now bogus...
    L"Bogus0",                  // Connects to pin
    1,                          // Number of types
    &sudTunePinTypes,           // Pin information
	},
	{
    INPUT_PIN1_NAME,            // Pin string name ("Line21 CC")
    TRUE,                       // Is it rendered
    FALSE,                      // Is it an output
    FALSE,                      // Allowed none
    FALSE,                      // Likewise many
    &CLSID_NULL,				// Connects to filter  (Line21 decoder)
    L"Bogus1",                  // Connects to pin
    1,                          // Number of types
    &sudCCPinTypes              // Pin information
	}
};

const AMOVIESETUP_FILTER sudTveFilter =
{
    &CLSID_DShowTVEFilter,    // Filter CLSID
    FILTER_NAME,				// String name
    MERIT_NORMAL,               // Filter merit
    NUMELMS(rgSudPins),         // Number pins
    rgSudPins                   // Pin details
};

//
//  class factory registration (done the DirectShow way)
//
CFactoryTemplate g_Templates[]=
{
		// filter
	{	FILTER_NAME,
		&CLSID_DShowTVEFilter,			//
		CTVEFilter::CreateInstance,		// Create instance routine
		NULL,								// Init routine
		&sudTveFilter						// Filter Pin description
	},
	// property page
	{
		PROP_PAGE_NAME_TUNE,
		&CLSID_TVEFilterTuneProperties,
		CTVEFilterTuneProperties::CreateInstance
	},
	// property page
	{
		PROP_PAGE_NAME_CC,
		&CLSID_TVEFilterCCProperties,
		CTVEFilterCCProperties::CreateInstance
	},
	// property page
	{
		PROP_PAGE_NAME_STATS,
		&CLSID_TVEFilterStatsProperties,
		CTVEFilterStatsProperties::CreateInstance
	}
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
// ------------------------------------------------------------------------
//  local functions
// ------------------------------------------------------------------------
		
		//Get the IP address of the network adapter.
		//  returns unidirectional adapters followed by bi-directional adapters

static HRESULT
ListIPAdapters(int *pcAdaptersUniDi, int *pcAdaptersBiDi, int cAdapts, Wsz32 *rrgIPAdapts)
{
    try{
        HRESULT				hr				=	 E_FAIL;
        BSTR				bstrIP			= 0;
        PIP_ADAPTER_INFO	pAdapterInfo;
        ULONG				Size			= NULL;
        DWORD				Status;
        WCHAR				wszIP[16];
        int					cAdapters		= 0;
        int					cAdaptersUni	= 0;

        if(NULL == rrgIPAdapts)		// passed in a bad value... (hacky method - must be preallocated...)
            return E_INVALIDARG;

        if(NULL == pcAdaptersUniDi || NULL== pcAdaptersBiDi)
            return E_POINTER;
        *pcAdaptersUniDi = *pcAdaptersBiDi = 0;					// initalize

        memset((void *) rrgIPAdapts, 0, cAdapts*sizeof(Wsz32));


        memset(wszIP, 0, sizeof(wszIP));

        // staticly allocate a buffer to store the data
        const int kMaxAdapts = 10;
        const int kSize = sizeof (IP_UNIDIRECTIONAL_ADAPTER_ADDRESS) + kMaxAdapts * sizeof(IPAddr);
        char szBuff[kSize];
        IP_UNIDIRECTIONAL_ADAPTER_ADDRESS *pPIfInfo = (IP_UNIDIRECTIONAL_ADAPTER_ADDRESS *) szBuff;

        // get the data..
        ULONG ulSize = kSize;
        hr =  GetUniDirectionalAdapterInfo(pPIfInfo, &ulSize);
        if(S_OK == hr)
        {
            USES_CONVERSION;
            while(cAdaptersUni < (int) pPIfInfo->NumAdapters) {
                in_addr inadr;
                inadr.s_addr = pPIfInfo->Address[cAdaptersUni];
                char *szApAddr = inet_ntoa(inadr);
                WCHAR *wApAddr = A2W(szApAddr);
                if(wApAddr)
                    wcscpy(rrgIPAdapts[cAdaptersUni++], wApAddr);
                else 
                    return E_OUTOFMEMORY;
            }
        }


        if ((Status = GetAdaptersInfo(NULL, &Size)) != 0)
        {
            if (Status != ERROR_BUFFER_OVERFLOW)
            {
                return S_OK;
            }
        }

        // Allocate memory from sizing information
        pAdapterInfo = (PIP_ADAPTER_INFO) GlobalAlloc(GPTR, Size);
        if(pAdapterInfo)
        {
            // Get actual adapter information
            Status = GetAdaptersInfo(pAdapterInfo, &Size);

            if (!Status)
            {
                PIP_ADAPTER_INFO pinfo = pAdapterInfo;

                while(pinfo && (cAdapters < cAdapts))
                {
                    MultiByteToWideChar(CP_ACP, 0, pinfo->IpAddressList.IpAddress.String, -1, wszIP, 16);
                    if(wszIP)
                        wcscpy(rrgIPAdapts[cAdaptersUni + cAdapters++], wszIP);
                    pinfo = pinfo->Next;
                }

            }
            GlobalFree(pAdapterInfo);
        }

        *pcAdaptersUniDi = cAdaptersUni;
        *pcAdaptersBiDi  = cAdapters;
        return hr;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
//
// CreateInstance
//
// Creator function for the class ID
//
//  called by the DirectShow class factory code
//
CUnknown *
WINAPI
CTVEFilter::CreateInstance(
			IN IUnknown *pIUnknown,
			IN HRESULT *pHr
			)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::CreateInstance"));
	ASSERT(pHr);
	*pHr = S_OK;
	CTVEFilter *pTVEFilter = NULL;

#if 0
	DBG_APPEND_LOGFLAGS(
	// bank 1
		CDebugLog::DBG_SEV1 | 			// Basic Structure
		CDebugLog::DBG_SEV2	|			// Error Conditions
		CDebugLog::DBG_SEV3	|			// Warning Conditions
//		CDebugLog::DBG_SEV4	|			// Warning Conditions
		CDebugLog::DBG_FLT			 |	// General Filter stuff
		CDebugLog::DBG_FLT_DSHOW	 |	// DShow events in the Filter 
		CDebugLog::DBG_FLT_PIN_TUNE |	// IPSink Filter pin events
		CDebugLog::DBG_FLT_PIN_CC |		// CC Filter pin events
		CDebugLog::DBG_FLT_CC_DECODER |	// CC Filter pin events
		CDebugLog::DBG_FLT_CC_PARSER  | // Internal CC Decoder state
//		CDebugLog::DBG_FLT_CC_PARSER2 | // Internal CC Decoder state
		CDebugLog::DBG_FLT_PROPS	  |	// Property page messages and events

		CDebugLog::DBG_WRITELOG |		// write to a fresh log file (only need 0 or 1 of these last two flags)
//		CDebugLog::DBG_APPENDLOG |		// append to existing to log file, 
		0,

	// bank 2
		0,								// terminating value for '|'

	// bank 3
		0,

	// bank 4									// need one of these last two flags
//		CDebugLog::DBG4_ATLTRACE |		// atl interface count tracing
		CDebugLog::DBG4_WRITELOG |		// write to a fresh log file (only need 0 or 1 of these last two flags)
//		CDebugLog::DBG4_APPENDLOG |		// append to existing to log file, 


	// Default Level
		5);	
#endif
	
    pTVEFilter = new CTVEFilter (
                    NAME ("CTVEFilter"),
                    pIUnknown,
                    CLSID_DShowTVEFilter,			// filter interfaces?
                    pHr
                    );

    if (pTVEFilter == NULL) {
        if(*pHr == S_OK)
			*pHr = E_OUTOFMEMORY ;
    }

	if(FAILED(*pHr)) 
		return NULL;

    return pTVEFilter;
}
	
#define DEF_REG_FILTER_HALTFLAGS _T("HaltFlags")

HRESULT
CTVEFilter::InitParamsFromRegistry()
{
	if(m_dwGrfHaltFlags == 0)
	{
		if (ERROR_SUCCESS != GetRegValue(DEF_DBG_BASE,			// key	--> "Software/Debug"
										 DEF_REG_LOCATION,		// key1 --> "MSTve"
										 DEF_REG_FILTER_SUBKEY,
										 DEF_REG_FILTER_HALTFLAGS,
										 &m_dwGrfHaltFlags))
		{
			m_dwGrfHaltFlags = 0;									// do nothing, or let SetLogFlags override

			SetRegValue(DEF_DBG_BASE, DEF_REG_LOCATION, 			// set it just so users can find it...
						DEF_REG_FILTER_SUBKEY, 
						DEF_REG_FILTER_HALTFLAGS,
						m_dwGrfHaltFlags
						);
                    
		}
	}
	return S_OK;
}

// Constructor

CTVEFilter::CTVEFilter(
		IN	TCHAR		*pClassName,
		IN	IUnknown	*pUnk,
		IN  REFCLSID	rclsid,
		OUT HRESULT		*pHr
		) :
			CBaseFilter(pClassName, pUnk, &m_Lock, rclsid),
//			CPersistStream (pIUnknown, pHr),
			m_pPinTune(NULL),
			m_pPinCC(NULL),
			m_hkeyRoot(NULL),
			m_pDShowTVEFilter(NULL),
			m_spbsStationId(NULL),
			m_spbsIPAddr(NULL),
			m_dwSuperCookie(0),
			m_fThingsChanged(false),
			m_dwGrfHaltFlags(0)
{
    LONG    l;
    DWORD   dwDisposition ;

	ASSERT(pHr);
	ITVESupervisorPtr	spSuper;


	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::CTVEFilter"));

    //  open our registry key; creates it if it does not exist
    l = RegCreateKeyEx (
                    HKEY_CURRENT_USER,
                    DEF_REG_TVE_FILTER,
                    NULL,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    & m_hkeyRoot,
                    & dwDisposition
                    ) ;
    if (l != ERROR_SUCCESS) {
		*pHr = E_FAIL;
		return;
	}

  //  if this is NULL, it means we failed the base class constructor
    if (m_pLock == NULL) {
        * pHr = E_OUTOFMEMORY ;
        return;
    }


    //  instantiate our dshow-style interface
    m_pDShowTVEFilter = new CDShowTVEFilter(this) ;
    if (m_pDShowTVEFilter == NULL) {
        * pHr = E_OUTOFMEMORY ;
        return;
    }

	// try reading registry values
	InitParamsFromRegistry();

	try
	{
		spSuper = ITVESupervisorPtr(CLSID_TVESupervisor);
	} catch (HRESULT hrCatch) {
		*pHr = hrCatch;
	} catch (...) {
		*pHr = REGDB_E_CLASSNOTREG;
	}

	if(FAILED(*pHr))
		return;

	if(NULL == spSuper) {
//		MessageBox(_T("Failed To Create TVE Supervisor"),_T("This Sucks"));
		*pHr = E_OUTOFMEMORY;
		return;
	}
	m_spSuper = spSuper;


                // turn off the QueueThread that gets automatically created...
	ITVESupervisorPtr spSuperOtherThread;
    HRESULT hr;
	*pHr = get_Supervisor(&spSuperOtherThread);
    if(FAILED(*pHr))
    {
		TVEDebugLog((CDebugLog::DBG_SEV1,  1, _T("Failed to get Supervisor")));
        return;
    }

    ITVESupervisor_HelperPtr spSuperHelper(spSuperOtherThread);

    ITVEMCastManagerPtr spMCManager;
    *pHr = spSuperHelper->GetMCastManager(&spMCManager);
    if(FAILED(*pHr))
    {
 		TVEDebugLog((CDebugLog::DBG_SEV1,  1, _T("Failed to get MCastManager")));
        return;
    }

    ITVEMCastManager_HelperPtr spMCHelper(spMCManager);
    if(FAILED(*pHr))
    {
 		TVEDebugLog((CDebugLog::DBG_SEV1,  1, _T("Failed to get MCastManager Helper")));
        return;
    }

    *pHr = spMCHelper->KillQueueThread();


				// create a fake station so can get CC triggers without an actual
				//  IPSink based station.

//#define ALLOW_CCTRIGGER_STATION
#if ALLOW_CCTRIGGER_STATION
	{
		HRESULT hr = spSuper->TuneTo(L"Fake CCTrigger Station",L"0.0.0.0");
		if(FAILED(hr))
			hr = S_OK;
	}
#endif

    m_pPinTune = new CTVEInputPinTune(this,GetOwner(),
										&m_Lock,
										&m_ReceiveLock,
										pHr);
    if (m_pPinTune == NULL) {
        *pHr = E_OUTOFMEMORY;
        return;
    }

    m_pPinCC = new CTVEInputPinCC(this,GetOwner(),
									&m_Lock,
									&m_ReceiveLock,
									pHr);
    if (m_pPinCC == NULL) {
  		delete m_pPinTune; m_pPinTune = NULL;
        *pHr = E_OUTOFMEMORY;
        return;
    }

// stuff to fake initailzation
			// get list of available IP adapter addresses

	int cAdaptersUniDi=0, cAdaptersBiDi=0;
	Wsz32 *rgAdaptersUniDi, *rgAdaptersBiDi;
	*pHr = get_IPAdapterAddresses(&cAdaptersUniDi, &cAdaptersBiDi, &rgAdaptersUniDi, &rgAdaptersBiDi);
	ASSERT(cAdaptersUniDi + cAdaptersBiDi > 0);		// no IP ports...
	if(FAILED(*pHr) || cAdaptersUniDi + cAdaptersBiDi == 0) {
		*pHr = E_FAIL;
		return;
	}


				// set default values and Tune to it...
	
	if(cAdaptersUniDi > 0)
		put_IPAdapterAddress(rgAdaptersUniDi[0]);		// use first adapter. (hope it's a UniOne)
	else 
		put_IPAdapterAddress(rgAdaptersBiDi[0]);		// HACK - if no Uni, try BiDi first adapter. 

	if(cAdaptersUniDi)
		put_StationID(L"TVEFilt Initial IPSink Station");
	else 
		put_StationID(L"TVEFilt Initial Adapter Station");

	m_spSuper->put_Description(L"TVE Filter");

//#define TUNE_TO_FAKE_MULTICAST_SESSION
#ifdef TUNE_TO_FAKE_MULTICAST_SESSION
	*pHr = ReTune();
#endif

	return;
}

// Destructor

CTVEFilter::~CTVEFilter()
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::~CTVEFilter"));

    if(m_pPinTune) delete m_pPinTune; m_pPinTune=NULL;
    if(m_pPinCC)   delete m_pPinCC;   m_pPinCC  =NULL;


			// global interface table references to the TVE supervisor...
	HRESULT hr;
	if(m_dwSuperCookie)
		hr = m_spIGlobalInterfaceTable->RevokeInterfaceFromGlobal(m_dwSuperCookie);
	m_dwSuperCookie = 0;

			// cause these sub-objects to release themselves...
	m_spIGlobalInterfaceTable = NULL;
	m_spSuper = NULL;

     //  our registry key

	if((m_hkeyRoot) != NULL)
	{
		RegCloseKey(m_hkeyRoot);
		m_hkeyRoot = NULL;
	}

		// simple back pointers - just 
	m_pDShowTVEFilter = NULL;
	m_dwSuperCookie = NULL;

}

STDMETHODIMP
CTVEFilter::NonDelegatingQueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
	HRESULT hr;

	if (riid == IID_ITVEFilter)
	{
  //      return GetInterface((ITVEFilter *) this, ppv);		// WACKO CODE HERE!
        hr =  GetInterface (
                    (ITVEFilter *) m_pDShowTVEFilter,
                    ppv
                    );
		return hr;
	}
//	else if (riid == IID_IPersistStream) {
//		return GetInterface ((IPersistStream *) this, ppv) ;
//	}

    //  property pages use the dshow type COM interfaces

    else if (riid == IID_ISpecifyPropertyPages &&
			 m_pDShowTVEFilter != NULL)
	{
        hr =  GetInterface (
                    (ISpecifyPropertyPages *) m_pDShowTVEFilter,
                    ppv
                    ) ;
		return hr;
    }

	// This is the private DShow type interface
    else if (riid == IID_ITVEFilter &&
			 m_pDShowTVEFilter != NULL)
	{
        return GetInterface (
                    (ITVEFilter *) m_pDShowTVEFilter,
                    ppv
                    ) ;
    }

 /*   else if (riid == IID_ITVEFilter_Helper &&
			 m_pDShowTVEFilter != NULL)
	{
        return GetInterface (
                    (ITVEFilter_Helper *) m_pDShowTVEFilter,
                    ppv
                    ) ;
    }
*/
	return CBaseFilter::NonDelegatingQueryInterface (riid, ppv) ;
}

//
// Stop
//
//
STDMETHODIMP CTVEFilter::Stop()
{
 	DBG_HEADER(CDebugLog::DBG_FLT_DSHOW, _T("CTVEFilter::Stop"));		/// Should these stop the IP listens?
	
    CAutoLock cObjectLock(&m_Lock);
    return CBaseFilter::Stop();
}


//
// Pause
//
//	overridden to connect and disconnect Multicast listeners to the IPSinksink filter

STDMETHODIMP CTVEFilter::Pause()
{
 	DBG_HEADER(CDebugLog::DBG_FLT_DSHOW, _T("CTVEFilter::Pause"));

    // reject it when we're already paused
	CComBSTR spComment;
	HRESULT hr = S_OK;

	CComBSTR spbsIPSinkAdapter;
	hr = get_IPSinkAdapterAddress(&spbsIPSinkAdapter);		// what's currently their?
	if(FAILED(hr) || spbsIPSinkAdapter.Length() == 0)
	{
		TVEDebugLog((CDebugLog::DBG_SEV1,  1, _T("Failed to get IPSink Adapter address")));
		return CBaseFilter::Pause();						// do base filter stuff anyway...
	}

	ITVESupervisorPtr spSuperOtherThread;
	hr = get_Supervisor(&spSuperOtherThread);
    if(FAILED(hr))
    {
		TVEDebugLog((CDebugLog::DBG_SEV1,  1, _T("Failed to get Supervisor")));
        return hr;
    }

    ITVESupervisor_HelperPtr spSuperHelper(spSuperOtherThread);

    ITVEMCastManagerPtr spMCManager;
    hr = spSuperHelper->GetMCastManager(&spMCManager);
    if(FAILED(hr))
    {
 		TVEDebugLog((CDebugLog::DBG_SEV1,  1, _T("Failed to get MCastManager")));
        return hr;
    }

    ITVEMCastManager_HelperPtr spMCHelper(spMCManager);
    if(FAILED(hr))
    {
 		TVEDebugLog((CDebugLog::DBG_SEV1,  1, _T("Failed to get MCastManager Helper")));
        return hr;
    }

    
    switch( m_State ) 
	{
#define DO_INITIAL_TUNE
#ifdef DO_INITIAL_TUNE
            if(0 == m_spbsStationIdTemp.Length() || 0 == m_spbsIPAddrTemp.Length())
            {
                if(0 == m_spbsStationIdTemp.Length())
		            put_StationID(L"TveFilt - Running");			// BUGBUG - TODO TODO TODO - need a real Station ID			
	    	                                                        //   -- need something along the lines of CMSVidTVEGSeg::DoTuneChanged() here..
                if(0 != m_spbsIPSinkAddr.Length())
                    put_IPAdapterAddress(m_spbsIPSinkAddr);
            }
#endif
			// -----------------------------
			spComment += L"Stopped->Running";
			break;

		default:
        case State_Paused:
			TVEDebugLog((CDebugLog::DBG_FLT_DSHOW,  2, _T("Leaving Pause state - WIERD!!")));
			
			spComment += L"Was Paused";							// this should never happen...
			break;

        case State_Running:
			TVEDebugLog((CDebugLog::DBG_FLT_DSHOW,  2, _T("Leaving Run state")));

			if(!FAILED(hr) && spbsIPSinkAdapter.Length() > 0)								// disconnect any thing on this adapter...
			{

				if(spSuperOtherThread)
				{
					ITVESupervisor_HelperPtr spSuperHelper(spSuperOtherThread);
					hr = spSuperHelper->RemoveAllListenersOnAdapter(spbsIPSinkAdapter);
				}

                if(spMCHelper)                                  // kill the queue thread if it's running...
                   spMCHelper->KillQueueThread();               // -- NOTE - this is bad if Supervisor was really a singleton.. 
			}
			spComment += L"Running->Stopped";
			break;
	}

	if(DBG_FSET(CDebugLog::DBG_FLT_PIN_TUNE))				// debug only code - DBG_FSET removes it in the relase build
	{						
		IPin *pPinIPSink;
		hr = m_pPinTune->ConnectedTo(&pPinIPSink);
		if(FAILED(hr))
			return hr;
		if(NULL == pPinIPSink)
			return S_FALSE;


		PIN_INFO pinInfo;
		hr = pPinIPSink->QueryPinInfo(&pinInfo);
		if (SUCCEEDED(hr)) {
			
			IBaseFilter *pFilt = pinInfo.pFilter;
			
			FILTER_INFO filtInfo;
			hr = pFilt->QueryFilterInfo(&filtInfo);
			if(!FAILED(hr))
			{

				CComBSTR spFilt(filtInfo.achName);
				CComBSTR spPin(pinInfo.achName);
				CComPtr<IBDA_IPSinkInfo> spISinkInfo;		// was IBDA_IPSinkControl, IID_IBDA_IPSinkControl
				hr = pFilt->QueryInterface(IID_IBDA_IPSinkInfo, (void **) &spISinkInfo);
				if(!FAILED(hr))
				{
					CComBSTR spBufferIPDesc;
					hr = spISinkInfo->get_AdapterDescription(&spBufferIPDesc);

					CComBSTR spBufferIPAddr;
					hr = spISinkInfo->get_AdapterIPAddress(&spBufferIPAddr);

					if(FAILED(hr)) 
					{
						TVEDebugLog((CDebugLog::DBG_SEV2, 2, 
									 _T("Failed To %s : Pins - %s<%s> - IP Addr %s (%s)"), 
									  spComment, spFilt, spPin, spBufferIPAddr, spBufferIPDesc));
					} else {
						TVEDebugLog((CDebugLog::DBG_FLT_PIN_TUNE, 1, 
									 _T("%s : Pins - %s<%s> - IP Addr %s (%s)"), 
									  spComment, spFilt, spPin, spBufferIPAddr, spBufferIPDesc));	
					}
				}
			}
		}
	}

    return CBaseFilter::Pause();
}


//
// Run
//
// Overriden to open the dump file
//
STDMETHODIMP CTVEFilter::Run(REFERENCE_TIME tStart)
{
	DBG_HEADER(CDebugLog::DBG_FLT_DSHOW, _T("CTVEFilter::Run"));

    CAutoLock cObjectLock(&m_Lock);

	CComBSTR spbsIPSinkAdapter;
	HRESULT hr = get_IPSinkAdapterAddress(&spbsIPSinkAdapter);		// what's currently their?
	if(!FAILED(hr) && spbsIPSinkAdapter.Length() > 0) 
	{

	    ITVESupervisorPtr spSuperOtherThread;
	    hr = get_Supervisor(&spSuperOtherThread);
        if(FAILED(hr))
        {
		    TVEDebugLog((CDebugLog::DBG_SEV1,  1, _T("Failed to get Supervisor")));
            return hr;
        }

        ITVESupervisor_HelperPtr spSuperHelper(spSuperOtherThread);

        ITVEMCastManagerPtr spMCManager;
        hr = spSuperHelper->GetMCastManager(&spMCManager);
        if(FAILED(hr))
        {
 		    TVEDebugLog((CDebugLog::DBG_SEV1,  1, _T("Failed to get MCastManager")));
            return hr;
        }

        ITVEMCastManager_HelperPtr spMCHelper(spMCManager);
        if(FAILED(hr))
        {
 		    TVEDebugLog((CDebugLog::DBG_SEV1,  1, _T("Failed to get MCastManager Helper")));
            return hr;
        }

        if(spMCHelper)                                  // create the queue thread when coming out of Pause...
            spMCHelper->CreateQueueThread();

		hr = ReTune();                                  // set to latest and greatest values
	}

    return CBaseFilter::Run(tStart);
}

//
// GetPin
//
CBasePin * CTVEFilter::GetPin(int n)
{
//	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::GetPin"));
	if (n == 0)
	{
        return m_pPinTune;
    }
	else if (n == 1)
	{
        return m_pPinCC;
    }
	else
	{
        return NULL;
    }
}


//
// GetPinCount
//
int CTVEFilter::GetPinCount()
{
    return 2;
}

//  ---------------------------------------------------------------------------
//      ITVEFilter methods
//  ---------------------------------------------------------------------------

HRESULT 
CTVEFilter::get_Supervisor(/*OUT*/ ITVESupervisor **ppSuper)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::get_Supervisor"));

	try 
	{
		CheckOutPtr<ITVESupervisor *>(ppSuper);

						// supervisor could be running in a different apartment/thread.  
						// must Marshal interface over to it.
		if(FAILED(hr = CreateGITCookies()))
			return hr;
		
		ITVESupervisorPtr spSuperOtherThread;
		hr = m_spIGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwSuperCookie,
																__uuidof(spSuperOtherThread), 
																reinterpret_cast<void**>(&spSuperOtherThread));

		if(FAILED(hr)) {
			DBG_WARN(CDebugLog::DBG_SEV1, _T("Get Interface from Global Failed"))
			return hr;
		}
		*ppSuper = spSuperOtherThread;
		spSuperOtherThread.AddRef();

    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}

	return hr;
}

		// returns known adapter addresses in a fixed static string.  Client shouldn't free it.
		//  This is a bogus routine - test use only...

HRESULT
CTVEFilter::get_IPAdapterAddresses(/*[out]*/ int *pcAdaptersUniDi, /*[out]*/ int *pcAdaptersBiDi, 
								   /*[out]*/ Wsz32 **rgAdaptersUniDi,  /*[out]*/ Wsz32 **rgAdaptersBiDi)
{
	HRESULT hr = S_OK;

	try {
		CheckOutPtr<int>(pcAdaptersUniDi);
		CheckOutPtr<int>(pcAdaptersBiDi);


		static Wsz32 grgAdapters[kcMaxIpAdapts];	// array of possible IP adapters
		hr = ListIPAdapters(pcAdaptersUniDi, pcAdaptersBiDi, kcMaxIpAdapts, grgAdapters);
		if(FAILED(hr)) 
			return hr;

		if(NULL != rgAdaptersUniDi)
			*rgAdaptersUniDi = grgAdapters;
		if(NULL != rgAdaptersBiDi)
			*rgAdaptersBiDi = grgAdapters + *pcAdaptersUniDi;
	
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}

	return hr;
}

static HRESULT 
CheckIPAdapterSyntax(BSTR bstrIPAdapter)
{
    try{
	USES_CONVERSION;
	HRESULT hr = S_OK;
	ULONG ipAddr = inet_addr(W2A(bstrIPAdapter));
	if(ipAddr == INADDR_NONE) return E_INVALIDARG;

			// allow 0.0.0.0 address (ADDR_ANY?)
//	if(ipAddr == 0)	return E_INVALIDARG;

	return S_OK;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}


// -----------------
//		Get/Put property methods get the 'real' value, but puts the 'Temp' one.
//		The SubmitChanges methods overwrites the real values with the temp ones. 
//		(SubmitChanges actually swaps them, so a second call will undo the first.)
//
//		Initial values for the gets are created during the DoTuneConnect() call,
//		where they are read out of the supervisor.
//		Values are written from the real 'put' values during the ReTune() method.
// --------------------
STDMETHODIMP
CTVEFilter::put_IPAdapterAddress(/*[in]*/ BSTR bstrIPAddr)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::put_IPAdapterAddress"));
	HRESULT hr = S_OK;

	if(bstrIPAddr || bstrIPAddr[0])
	{
		if(FAILED(hr = CheckIPAdapterSyntax(bstrIPAddr)))
			return hr;
	}

	if(!(m_spbsIPAddrTemp == bstrIPAddr)) {
		m_spbsIPAddrTemp = bstrIPAddr;
		m_fThingsChanged = true;
		return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP 
CTVEFilter::get_IPAdapterAddress(BSTR *pVal)
{
    
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        hr = m_spbsIPAddr.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

		// --------------------------

HRESULT			// this method not in the interface....		returns S_FALSE if no change
CTVEFilter::put_IPSinkAdapterAddress(/*[in]*/ BSTR bstrIPAddr)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::put_IPSinkAdapterAddress"));
	HRESULT hr = S_OK;

	if(NULL != bstrIPAddr)
	{
		if(FAILED(hr = CheckIPAdapterSyntax(bstrIPAddr)))
			return hr;
	}

	if(!(m_spbsIPSinkAddr == bstrIPAddr))
	{
		m_spbsIPSinkAddr = bstrIPAddr;
		return S_OK;
	} else {
		return S_FALSE;
	}
}

STDMETHODIMP 
CTVEFilter::get_IPSinkAdapterAddress(BSTR *pVal)
{
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        hr = m_spbsIPSinkAddr.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

		// --------------------------

STDMETHODIMP
CTVEFilter::put_StationID(/*[in]*/ BSTR bstrStationID)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::put_StationID"));
	HRESULT hr = S_OK;

	if(!(m_spbsStationIdTemp == bstrStationID)) {
		m_spbsStationIdTemp = bstrStationID;
		m_fThingsChanged = true;
		return S_OK;
	}
	return S_FALSE;
}


STDMETHODIMP 
CTVEFilter::get_StationID(BSTR *pVal)
{
    HRESULT hr = S_OK;
    try {
        CheckOutPtr<BSTR>(pVal);
        return m_spbsStationId.CopyTo(pVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

void 
CTVEFilter::SubmitChanges()			// swap temp with real
{
	CComBSTR bstrTemp;
	bstrTemp			= m_spbsStationId;
	m_spbsStationId		= m_spbsStationIdTemp;
	m_spbsStationIdTemp = bstrTemp;


	bstrTemp			= m_spbsIPAddr;
	m_spbsIPAddr		= m_spbsIPAddrTemp;
	m_spbsIPAddrTemp	= bstrTemp;
}

void 
CTVEFilter::CommitChanges()			// copy real back to temp 
{
	m_spbsStationIdTemp		= m_spbsStationId;
	m_spbsIPAddrTemp		= m_spbsIPAddr;

}
STDMETHODIMP
CTVEFilter::ReTune()
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::ReTune"));
	if(!m_fThingsChanged)
		return S_FALSE;			// nothing new...

	SubmitChanges();				// copy over the changes...

	HRESULT hr = S_OK;
	if(0 == m_spbsStationId.Length() || 0 == m_spbsIPAddr.Length() )
		return E_INVALIDARG;

					// supervisor could be running in a different apartment/thread.  Marshal interface over to it.
	if(FAILED(hr = CreateGITCookies()))
		return hr;
	
	ITVESupervisorPtr spSuperOtherThread;
	hr = get_Supervisor(&spSuperOtherThread);

	if(FAILED(hr)) {
		DBG_WARN(CDebugLog::DBG_SEV1, _T("get_Supervisor Failed"))
		return hr;
	}

	try {
		TVEDebugLog((CDebugLog::DBG_FLT, 3, _T("CTVEFilter::TuneTo  - %s %s\n"),m_spbsStationId.m_str, m_spbsIPAddr.m_str));
		hr = spSuperOtherThread->TuneTo(m_spbsStationId.m_str, m_spbsIPAddr.m_str);
	} catch (_com_error ccc) {
		hr = ccc.Error();
	}

	if(FAILED(hr))
	{
		TCHAR tbuff[256];
		_stprintf(tbuff,_T("TuneTo() failed - error 0x%08x"),hr);
		MessageBox(NULL, tbuff,  _T("TVE Receiver problems"), MB_OK);
	}

	if(FAILED(hr)) 
		SubmitChanges();	// undo changes...
	else
		CommitChanges();	// make sure can't undo again...

	return hr;
}

STDMETHODIMP
CTVEFilter::ParseCCBytePair(LONG lType, BYTE cbFirst, BYTE cbSecond )
{

	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_FLT_CC_DECODER, _T("CTVEFilter::ParseCCBytePair"));
/*	TVEDebugLog((CDebugLog::DBG_FLT_CC_DECODER, 5,  
		       _T("Parsing 0x%08x '%c'(0x%02x) '%c'(0x%02x)"), lType,
			   isprint(cbFirst  & 0x7f) ? cbFirst & 0x7f :'?',cbFirst & 0x7f,
			   isprint(cbSecond & 0x7f) ? cbSecond & 0x7f :'?',cbSecond & 0x7f)); */


	bool fDoneWithLine = false;
	hr = m_L21Buff.ParseCCBytePair((DWORD) lType, cbFirst, cbSecond, &fDoneWithLine);
	if(FAILED(hr)) 
		return hr;


	if(fDoneWithLine)	// got a whole trigger string, ship it off to the control...
	{
		
		ITVESupervisorPtr spSuperOtherThread;
		hr = get_Supervisor(&spSuperOtherThread);

		if(FAILED(hr))
		{
			TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("CTVEFilter::ParseCCBytePair  - failed get_Supervisor")));
			return hr;
		}

		CComBSTR bstrBuff;
		hr = m_L21Buff.GetBuffTrig(&bstrBuff);

		TVEDebugLog((CDebugLog::DBG_FLT_CC_DECODER, 3,  
					 _T("New Trigger : '%s'"),bstrBuff));

		LONG lgrfHaltFlags;
		get_HaltFlags(&lgrfHaltFlags);

		if(S_OK == hr && !(lgrfHaltFlags & NFLT_grfTA_Parse))
		{
			try {
			hr = spSuperOtherThread->NewXOverLink(bstrBuff.m_str);
			} catch(HRESULT hr) {
				return hr;
			} catch(...) {
				return E_POINTER;
			}
		}

		m_L21Buff.ClearBuff();			// restart dumping into the buffer
	}
    
	return hr;
}
//  ---------------------------------------------------------------------------
//      CDShowTVEFilter
//  ---------------------------------------------------------------------------


CDShowTVEFilter::CDShowTVEFilter (
    IN  CTVEFilter *  punk         //  controlling unknown, always the filter
    ) :
        m_pTVEFilter(punk)
{
    DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::CDShowTVEFilter"));

    ASSERT (punk) ;
}

CDShowTVEFilter::~CDShowTVEFilter (
    )
{
     DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::~CDShowTVEFilter"));
}

//  IUnknown


STDMETHODIMP
CDShowTVEFilter::QueryInterface (
    IN  REFIID  riid,
    OUT void ** ppv
    )
{
    //  delegate always
    return m_pTVEFilter->QueryInterface (riid, ppv) ;
}

STDMETHODIMP_(ULONG)
CDShowTVEFilter::AddRef (
    )
{
   DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::AddRef"));
     //  delegate always
    return m_pTVEFilter->AddRef () ;
}

STDMETHODIMP_(ULONG)
CDShowTVEFilter::Release (
    )
{
    DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::Release"));
    //  hmm.. if we return what the demuxfilter returns, could be the case where
    //  the demux filter destroys itself, and thus destroys this object (if we're
    //  in the destructor), and the code then comes back out through here ..
    //  could this happen .. ?  The remedy is to not explicitely delete this object
    //  from the filter's destructor, but instead to examine the value of the
    //  the Release call to the filter and delete self if it's 0

    //  delegate always
    return m_pTVEFilter->Release () ;
}


STDMETHODIMP
CDShowTVEFilter::GetPages (
    CAUUID * pPages
    )
{
    DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::GetPages"));
	HRESULT hr = S_OK;

	try 
	{
		CheckOutPtr<CAUUID>(pPages);

#ifdef _DEBUG
		pPages->cElems = 3 ;
#else
		pPages->cElems = 2 ;
#endif
		pPages->pElems = (GUID *) CoTaskMemAlloc(pPages->cElems * sizeof GUID) ;

		if (pPages->pElems == NULL)
		{
			pPages->cElems = 0;
			return E_OUTOFMEMORY;
		}
		(pPages->pElems)[0] = CLSID_TVEFilterTuneProperties;
		(pPages->pElems)[1] = CLSID_TVEFilterStatsProperties;		
		if(pPages->cElems > 2)
			(pPages->pElems)[2] = CLSID_TVEFilterCCProperties;			// really HaltFlags now...

    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}

	return hr;
}

STDMETHODIMP
CDShowTVEFilter::get_SupervisorPunk(IUnknown **ppVal)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::get_SupervisorPunk"));
	HRESULT hr = S_OK;

	try
	{
		CheckOutPtr<IUnknown *>(ppVal);

	//	CSmartLock spLock(&m_sLk)
		ASSERT(m_pTVEFilter != NULL);

		ITVESupervisorPtr	spSuper;

		hr = m_pTVEFilter->get_Supervisor(&spSuper);		// may fail if GIT not setup yet due to break point in constructor...
		if(!FAILED(hr))
			hr = spSuper->QueryInterface(ppVal);
	
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}

	return hr;
}

/*
STDMETHODIMP
CDShowTVEFilter::get_Supervisor(IDispatch **ppVal)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::get_Supervisor"));
	HRESULT hr = S_OK;
	CheckOutPtr<IDispatch *>(ppVal);

//	CSmartLock spLock(&m_sLk)
	ASSERT(m_pTVEFilter != NULL);

	ITVESupervisorPtr	spSuper;

	hr = m_pTVEFilter->get_Supervisor(&spSuper);
	hr = spSuper->QueryInterface(ppVal);

	return hr;
}
*/

STDMETHODIMP
CDShowTVEFilter::put_IPAdapterAddress(BSTR bstrIPAddr)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::put_IPAdapterAddress"));
	TVEDebugLog((CDebugLog::DBG_FLT,3,_T("Putting Adapter Address %s"),bstrIPAddr));

	return m_pTVEFilter->put_IPAdapterAddress(bstrIPAddr);
}


STDMETHODIMP 
CDShowTVEFilter::get_IPAdapterAddress(BSTR *pbstrIPAddr)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::get_IPAdapterAddress"));

	HRESULT hr = S_OK;

    try {
		CheckOutPtr<BSTR>(pbstrIPAddr);
		hr = m_pTVEFilter->get_IPAdapterAddress(pbstrIPAddr);
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}

	return hr;
}


STDMETHODIMP 
CDShowTVEFilter::get_IPSinkAdapterAddress(BSTR *pbstrIPAddr)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::get_IPSinkAdapterAddress"));

	HRESULT hr = S_OK;
	try {
		CheckOutPtr<BSTR>(pbstrIPAddr);
		hr = m_pTVEFilter->get_IPSinkAdapterAddress(pbstrIPAddr);
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}

STDMETHODIMP
CDShowTVEFilter::ReTune()
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::ReTune"));

	if(!m_pTVEFilter) 
		return E_POINTER;

 	CComBSTR spbsStationID;
	CComBSTR spbsAdapterAddr;
									// gets get the old values....
	HRESULT hr = m_pTVEFilter->get_StationID(&spbsStationID);
	if(!FAILED(hr)) 
		hr = m_pTVEFilter->get_IPAdapterAddress(&spbsAdapterAddr);
	if(!FAILED(hr))
	{
		TVEDebugLog((CDebugLog::DBG_FLT,3,_T("Tuning From %s on %s"),spbsStationID, spbsAdapterAddr));
	}

	if(FAILED(hr))
		return hr;
	try {
		hr =  m_pTVEFilter->ReTune();
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		return E_POINTER;	// need to return good errno here
	}

	if(!FAILED(hr))
	{									// gets get the old values....
		hr = m_pTVEFilter->get_StationID(&spbsStationID);
		if(!FAILED(hr)) hr = m_pTVEFilter->get_IPAdapterAddress(&spbsAdapterAddr);
		if(!FAILED(hr))
		{
			TVEDebugLog((CDebugLog::DBG_FLT,3,_T("Tuning To %s on %s"),spbsStationID, spbsAdapterAddr));
		}

	}
	return hr;
}

STDMETHODIMP 
CDShowTVEFilter::get_StationID(BSTR *pbstrStation)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::get_StationID"));

	HRESULT hr = S_OK;
    try {
		CheckOutPtr<BSTR>(pbstrStation);
		hr = m_pTVEFilter->get_StationID(pbstrStation);
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}

STDMETHODIMP 
CDShowTVEFilter::put_StationID(BSTR bstrStation)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::get_StationID"));

	HRESULT hr;
    try {
		hr = m_pTVEFilter->put_StationID(bstrStation);
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}


STDMETHODIMP			// talks through IPSINK filter pin interface to get updated value
CDShowTVEFilter::get_MulticastList(BSTR *pbsMulticastList)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::get_MulticastList"));

	HRESULT hr = S_OK;
    try {
		CheckOutPtr<BSTR>(pbsMulticastList);
		hr = m_pTVEFilter->get_MulticastList(pbsMulticastList);
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}

STDMETHODIMP
CDShowTVEFilter::get_AdapterDescription(BSTR *pbsAdapterDescription)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::get_AdapterDescription"));
	try {
		CheckOutPtr<BSTR>(pbsAdapterDescription);
		hr = m_pTVEFilter->get_AdapterDescription(pbsAdapterDescription);
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}

STDMETHODIMP
CDShowTVEFilter::ParseCCBytePair(LONG lType, BYTE byte1, BYTE byte2)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::ParseCCBytePair"));

	if(!m_pTVEFilter) return E_INVALIDARG;

	HRESULT hr = S_OK;
    try {
		return m_pTVEFilter->ParseCCBytePair(lType, byte1, byte2);
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}



STDMETHODIMP
CDShowTVEFilter::put_HaltFlags(LONG lgrfHaltFlags)			// see NFLT_grfHaltFlags
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::put_HaltFlags"));

	return m_pTVEFilter->put_HaltFlags(lgrfHaltFlags);
}

STDMETHODIMP
CDShowTVEFilter::get_HaltFlags(LONG *plgrfHaltFlags)		// see NFLT_grfHaltFlags
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CDShowTVEFilter::get_HaltFlags"));

	HRESULT hr = S_OK;
	try {
		CheckOutPtr<LONG>(plgrfHaltFlags);
		hr = m_pTVEFilter->get_HaltFlags(plgrfHaltFlags);
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}



// -----------------------------------------------------------------
// -----------------------------------------------------------------

HRESULT
CTVEFilter::CreateGITCookies()		// can't use SuperHelper at ALL!, class isn't in the proxy-styb DLL
{

	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::CreateGITCookies"));
	HRESULT hr = S_OK;
 
	if(m_dwSuperCookie)									// already created, simply return
		return hr;

 			// used this to marshal calls to the TVESuper

	hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, 
							  IID_IGlobalInterfaceTable, reinterpret_cast<void**>(&m_spIGlobalInterfaceTable));

	if(FAILED(hr))
	{
		DBG_WARN(CDebugLog::DBG_SEV1, _T("CTVEFilter::Error getting GIT"));
		return hr;
	}

	try			// caution - below will throw if PoxryStub not set up right (problem with SuperHelper!)
	{
		hr = m_spIGlobalInterfaceTable->RegisterInterfaceInGlobal(m_spSuper,	     __uuidof(m_spSuper),		  &m_dwSuperCookie);
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = TYPE_E_LIBNOTREGISTERED;			// didn't register the proxy-stub DLL (see Prof ATL Com Prog.  Pg 395)
		_ASSERTE(TYPE_E_LIBNOTREGISTERED);
	}

	if(FAILED(hr))
	{
		DBG_WARN(CDebugLog::DBG_SEV1, _T("CTVEFilter::Error Registering Interfaces in GIT"));
		return hr;
	}

/*		// test code - did it work?
 
	ITVESupervisorPtr spSuperMainThread;
	hr = m_spIGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwSuperCookie,
																__uuidof(spSuperMainThread), 
																reinterpret_cast<void**>(&spSuperMainThread));
*/

	
	return hr;
}



HRESULT
CTVEFilter::DoTuneConnect()
{
    try{
        DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::DoTuneConnect"));
        HRESULT hr;
        USES_CONVERSION;
        IPin *pPinIPSink;
        hr = m_pPinTune->ConnectedTo(&pPinIPSink);
        if(FAILED(hr))
            return hr;
        if(NULL == pPinIPSink)
            return S_FALSE;


        PIN_INFO pinInfo;
        hr = pPinIPSink->QueryPinInfo(&pinInfo);
        if (SUCCEEDED(hr)) {

            IBaseFilter *pFilt = pinInfo.pFilter;

            FILTER_INFO filtInfo;
            hr = pFilt->QueryFilterInfo(&filtInfo);
            if(!FAILED(hr)) {


                CComPtr<IBDA_IPSinkInfo> spISinkInfo;		// was IBDA_IPSinkControl, IID_IBDA_IPSinkControl
                hr = pFilt->QueryInterface(IID_IBDA_IPSinkInfo, (void **) &spISinkInfo);
                if(!FAILED(hr))
                {


#if 0													// debug stuff
                    ULONG cbMulticastList;
                    BYTE  *pBufferMulticastList;
                    hr = pISinkInfo->get_MulticastList(&cbMulticastList, &pBufferMulticastList);
                    if(pBufferMulticastList) CoTaskMemFree((void *) pBufferMulticastList);
#endif
                    CComBSTR spBufferIPDesc;
                    hr = spISinkInfo->get_AdapterDescription(&spBufferIPDesc);

                    // real call
                    CComBSTR spBufferIPAddr;
                    hr = spISinkInfo->get_AdapterIPAddress(&spBufferIPAddr);

                    if(!FAILED(hr) && spBufferIPAddr.Length() > 0)
                    {
                        hr = put_IPSinkAdapterAddress(spBufferIPAddr);

                        // work around the startup bug - (get-unidirectional adapter not returning IPSink address right after boot)
                        if(0 == wcsncmp(m_spbsStationIdTemp,L"TVEFilt Initial Adapter Station",wcslen(L"TVEFilt Initial Adapter Station")))
                        {
                            put_IPAdapterAddress(spBufferIPAddr);
                            put_StationID(L"TVEFilt Initial IPSink Station");
                        }
                    }


#define IPSINK_HACK
#ifdef IPSINK_HACK		// remove when get IPSink working
                    if(!FAILED(hr)) {
                        TVEDebugLog((CDebugLog::DBG_SEV1, 1,
                            _T("YIPPIE!  Successfully retrived IP adapter address from IP Sink : %s - YEAH!"),
                            spBufferIPAddr));
                    } else {
                        TVEDebugLog((CDebugLog::DBG_SEV1, 1,
                            _T("Must Fake IP Adapter Address, IPSink isn't working correctly!")));

                        // stuff to fake initailzation
                        // get list of available IP adapter addresses


                        int cAdaptersUniDi=0, cAdaptersBiDi=0;
                        Wsz32 *rgAdaptersUniDi;
                        Wsz32 *rgAdaptersBiDi;
                        hr = get_IPAdapterAddresses(&cAdaptersUniDi, &cAdaptersBiDi, &rgAdaptersUniDi, &rgAdaptersBiDi);
                        ASSERT(cAdaptersUniDi + cAdaptersBiDi > 0);		// no IP ports...
                        if(FAILED(hr) || cAdaptersUniDi + cAdaptersBiDi == 0) {
                            hr = E_FAIL;
                            TVEDebugLog((CDebugLog::DBG_SEV1, 1,
                                _T("***ERROR*** No IP adapters found at all!!!!")));
                            return hr;
                        }
                        if(cAdaptersUniDi == 0) {
                            TVEDebugLog((CDebugLog::DBG_SEV2, 1,
                                _T("***WARNING*** No Unidirectional IP adapters found - using Multicast Read")));
                        }

                        // set default values and Tune to it...

                        char *pszbAdapts;
                        if(rgAdaptersUniDi > 0)
                            pszbAdapts = W2A(rgAdaptersUniDi[0]);		// grab the first one...
                        else
                            pszbAdapts = W2A(rgAdaptersBiDi[0]); 

                        CComBSTR spbBAddr(pszbAdapts);			// fake memory CoTaskMemAlloc in GetAdapterIPAddress so can free it the same way..
                        spBufferIPAddr = spbBAddr;		

                        TVEDebugLog((CDebugLog::DBG_SEV1, 1,
                            _T("***WARNING*** Faking IP Adapter Address to: %s"),
                            spbBAddr));
                        hr = S_OK;
                    }
#endif

#ifdef CONNECT_IN_CONNECT
                    if(!FAILED(hr)) {
                        put_StationID(L"TveFilt - Connected");			// TODO TODO TODO - need a real Station ID
                        put_IPAdapterAddress(spBufferIPAddr);		

                        hr = ReTune();
                    }

                    CComBSTR spFilt(filtInfo.achName);
                    CComBSTR spPin(pinInfo.achName);

                    if(FAILED(hr)) 
                    {
                        TVEDebugLog((CDebugLog::DBG_SEV2, 2, 
                            _T("Failed To Connect to: %s<%s> - IP Addr %s (%s)"), 
                            spFilt, spPin, spBufferIPAddr, spBufferIPDesc));
                    } else {
                        TVEDebugLog((CDebugLog::DBG_FLT_PIN_TUNE, 1, 
                            _T("Tune Pin connected to: %s<%s> - IP Addr %s (%s)"), 
                            spFilt, spPin, spBufferIPAddr, spBufferIPDesc));	
                    }
#endif
                }
                filtInfo.pGraph->Release();
            }
            pinInfo.pFilter->Release();
        }

        return hr;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}

HRESULT
CTVEFilter::DoTuneBreakConnect()
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::DoTuneBreakConnect"));
	CComBSTR spbsIPSinkAdapter;
	HRESULT hr = get_IPSinkAdapterAddress(&spbsIPSinkAdapter);		// what's currently their?
	if(spbsIPSinkAdapter.Length() > 0)								// disconnect any thing on this adapter...
	{
		ITVESupervisorPtr spSuperOtherThread;
		hr = get_Supervisor(&spSuperOtherThread);
		if(spSuperOtherThread)
		{
#ifdef CONNECT_IN_CONNECT
			ITVESupervisor_HelperPtr spSuperHelper(spSuperOtherThread);
			spSuperHelper->RemoveAllListenersOnAdapter(spbsIPSinkAdapter);
#endif
		}
	}

	hr = put_IPSinkAdapterAddress(NULL);
 	return S_OK;
}

HRESULT
CTVEFilter::DoCCBreakConnect()
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::DoCCBreakConnect"));
	return S_OK;
}

typedef struct
{ 
	KSPROPERTY							m_ksThingy;
	VBICODECFILTERING_CC_SUBSTREAMS		ccSubStreamMask;
} KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS;

HRESULT
CTVEFilter::DoCCConnect()
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::DoCCConnect"));
 	HRESULT hr;

	try {

		IPin *pPinCCDecoder;
		hr = m_pPinCC->ConnectedTo(&pPinCCDecoder);		
		if(FAILED(hr))
			return hr;
		if(NULL == pPinCCDecoder)
			return S_FALSE;

		PIN_INFO pinInfo;
		hr = pPinCCDecoder->QueryPinInfo(&pinInfo);
		if (SUCCEEDED(hr)) {
			
			IBaseFilter *pFilt = pinInfo.pFilter;
			
			// Triggers are just on the T2 stream of closed captioning.
			//  Tell the nice CC filter to only give us that stream out of the 9 possible

			
			IKsPropertySet *pksPSet = NULL;
//			HRESULT hr2 = pFilt->QueryInterface(IID_IKsPropertySet, (void **) &pksPSet);
			HRESULT hr2 = pPinCCDecoder->QueryInterface(IID_IKsPropertySet, (void **) &pksPSet);
			if(!FAILED(hr2))
			{
				DWORD rgdwData[20];
				DWORD cbMax = sizeof(rgdwData);
				DWORD cbData;
				hr2 = pksPSet->Get(KSPROPSETID_VBICodecFiltering, 
									KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
									NULL, 0, 
									(BYTE *) rgdwData, cbMax, &cbData); 
				if(FAILED(hr2))
				{
					TVEDebugLog((CDebugLog::DBG_SEV2, 3,
							_T("Error Getting CC Filtering, hr = 0x%08x"),hr2));
				}

				DWORD dwFiltType;
				

	#if 0
    			dwFiltType = KS_CC_SUBSTREAM_ODD ; // | KS_CC_SUBSTREAM_EVEN;
				TVEDebugLog((CDebugLog::DBG_FLT_PIN_CC, 3,
						  _T("*** ALL streams Set ***") ));
    #else
				
				dwFiltType = KS_CC_SUBSTREAM_SERVICE_T2;		// f:\nt\public\sdk\inc\ksmedia.h
				TVEDebugLog((CDebugLog::DBG_FLT_PIN_CC, 3,
						  _T("Setting CC Filtering to KS_CC_SUBSTREAM_SERVICE_T2")));
				ATLTRACE(_T("%s 0x%08x \n"), _T("Setting CC Filtering to KS_CC_SUBSTREAM_SERVICE_T2"),dwFiltType );

	#endif

				KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS ksThing = {0};
				ksThing.ccSubStreamMask.SubstreamMask = dwFiltType;
																		// ring3 to ring0 propset call
				hr2 = pksPSet->Set(KSPROPSETID_VBICodecFiltering, 
									 KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY, 
									 &ksThing.ccSubStreamMask, 
									 sizeof(ksThing) - sizeof(KSPROPERTY), 
									 &ksThing, 
									 sizeof(ksThing));
			
				if(FAILED(hr2))
				{
					TVEDebugLog((CDebugLog::DBG_SEV2, 3,
							_T("Error Setting CC Filtering, hr = 0x%08x"),hr2));
				}

			} else {
				TVEDebugLog((CDebugLog::DBG_SEV2, 3,
						_T("Error Getting CC's IKsPropertySet, hr = 0x%08x"),hr2));

			}
			if(pksPSet) 
				pksPSet->Release();


			FILTER_INFO filtInfo;
			hr = pFilt->QueryFilterInfo(&filtInfo);

			if(!FAILED(hr) && FAILED(hr2)) {
				CComBSTR bstrFilt(filtInfo.achName);
				CComBSTR bstrPin(pinInfo.achName);
				TVEDebugLog((CDebugLog::DBG_SEV2, 1,
						  _T("Failed To Connect CC Pin to  %s:%s, or Set T2 stream"), 
							bstrFilt, bstrPin));
				if(FAILED(hr2)) hr = hr2;
			}


			if(!FAILED(hr) && DBG_FSET(CDebugLog::DBG_FLT_PIN_CC))
			{
				CComBSTR bstrFilt(filtInfo.achName);
				CComBSTR bstrPin(pinInfo.achName);
				TVEDebugLog((CDebugLog::DBG_FLT_PIN_CC, 3,
							_T("CC Pin Connected to:  %s<%s>"), 
							bstrFilt, bstrPin));
			}
			if(filtInfo.pGraph)
				filtInfo.pGraph->Release();
			if(pinInfo.pFilter)
				pinInfo.pFilter->Release();
		}
	} catch (HRESULT hrCatch) {
		TVEDebugLog((CDebugLog::DBG_SEV1, 1,
				  TEXT("Threw Badly - (hr=0x%08x) Giving Up"),hrCatch ));
		hr = hrCatch;
	} catch (...) {
		TVEDebugLog((CDebugLog::DBG_SEV1, 1,
				  TEXT("Threw Badly - Giving Up") ));

		hr = E_FAIL;
	}


	return hr;
}

// -----------
//		Returns comma separated list of IP addresses... Top byte is wrong
// ---------------
STDMETHODIMP			// talks through IPSINK filter pin interface to get updated value, 
CTVEFilter::get_MulticastList(BSTR *pbsMulticastList)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::get_MulticastList"));
	HRESULT hr = S_OK;
	CComBSTR spbsMulticastList;
	CComBSTR spbsIPDesc;
	CComBSTR spbsIPAddr;
	CComBSTR bstrNotConnected(L"Not Connected To IPSink");
	CComBSTR bstrError(L"Error Getting Value");

	IPin *pPinIPSink;
	hr = m_pPinTune->ConnectedTo(&pPinIPSink);
	if(FAILED(hr) || NULL == pPinIPSink)
	{ 
		bstrNotConnected.CopyTo(pbsMulticastList);
		if(NULL == pPinIPSink) hr = S_FALSE;
		return hr;
	}
				
	PIN_INFO pinInfo;
	hr = pPinIPSink->QueryPinInfo(&pinInfo);
	if (SUCCEEDED(hr)) {
		
		IBaseFilter *pFilt = pinInfo.pFilter;
		
		FILTER_INFO filtInfo;
		hr = pFilt->QueryFilterInfo(&filtInfo);
		if(!FAILED(hr)) {


			CComPtr<IBDA_IPSinkInfo> spISinkInfo;		// was IBDA_IPSinkControl, IID_IBDA_IPSinkControl
			hr = pFilt->QueryInterface(IID_IBDA_IPSinkInfo, (void **) &spISinkInfo);
			if(!FAILED(hr))
			{
				USES_CONVERSION;
#if _DEBUG
				hr = spISinkInfo->get_AdapterDescription(&spbsIPDesc);
				if(FAILED(hr)) 
					bstrError.CopyTo(&spbsIPDesc);
				hr = spISinkInfo->get_AdapterIPAddress(&spbsIPAddr);
				if(FAILED(hr)) 
					bstrError.CopyTo(&spbsIPAddr);
#endif

				ULONG dwBytes;
				BYTE *rgbMulticastData = NULL;
				hr = spISinkInfo->get_MulticastList(&dwBytes, &rgbMulticastData);
				if(!FAILED(hr))
				{
					int cAddrs = (int) dwBytes / 6;
					BYTE *pbBuffer = rgbMulticastData;

					CComBSTR bstrTmp(cAddrs*(4*3+4));
					if(!bstrTmp)
						return ERROR_NOT_ENOUGH_MEMORY;
																// convert to ',' separated list
					bstrTmp.Empty();
					for(int i = 0; i < cAddrs; i++)
					{
						if(pbBuffer[0] != 0x01 ||
							pbBuffer[1] != 0x00 ||
							pbBuffer[2] != 0x5e ||
							(pbBuffer[3] & 0x80) != 0x00)
						{
							// invalid ethernet multicast address
						}

						bstrTmp = "?.?";					// todo - what is real address here? (range of 218-239)
						for(int j = 3; j < 6; j++)
						{
							char szB[4];
							_itoa(pbBuffer[j],szB, 10);
							bstrTmp += szB;
							if(j != 5)
								bstrTmp += ".";
						}
						if(i < cAddrs-1)				// 'tween commans
							bstrTmp += ",";
						pbBuffer += 6;
					}

					bstrTmp.CopyTo(&spbsMulticastList);
					if(rgbMulticastData) CoTaskMemFree((void *) rgbMulticastData);
				} else { 
					bstrError.CopyTo(&spbsMulticastList);
				}
			}
			filtInfo.pGraph->Release();
		}
		pinInfo.pFilter->Release();
	}

	return spbsMulticastList.CopyTo(pbsMulticastList);
}

STDMETHODIMP
CTVEFilter::get_AdapterDescription(BSTR *pbsAdapterDescription)
{
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilter::get_AdapterDescription"));
	HRESULT hr = S_OK;
	CComBSTR spbsAdapterDescription;

	return spbsAdapterDescription.CopyTo(pbsAdapterDescription);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvefilt.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
//		CDShowTVEFilter :			- Main filter object (encapsulates a CTVEFilter)
//			public ITVEFilter,
//			public ISpecifyPropertyPages
//
//		CTVEFilter :				- Working filter object (contains pins, storage, working methods)
//			public CBaseFilter 
//--------------------------------------------------------------------------;
#ifndef __TVEFILT_H__
#define __TVEFILT_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include "resource.h"

#include <winsock2.h>				// seems to be needed when compiling under bogus NTC environment
#include <atlbase.h>

#undef ATLTRACE
#define ATLTRACE AtlTrace

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "valid.h"
#include "TveL21Dec.h"				// line 21 decoder interfaces

/*		
extern WCHAR * GetTVEError(HRESULT hr, ...);			//  Extended Error Message Handler

inline HRESULT WINAPI ImplReportError(const CLSID& clsid, UINT nID, const IID& iid,
	HRESULT hRes, HINSTANCE hInst = _Module.GetResourceInstance())
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), 0, NULL, iid, hRes, hInst);
};
*/

#include "resource.h"	// main symbols...

#ifdef SEAN_CODE
#include <atlhost.h>	//# - grabing Sean's which doesn't compile Win64
#endif

#include <windows.h>
#include <commdlg.h>
#include <streams.h>

#include "..\Common\IsoTime.h"
#include <Time.h>
									// raw_interfaces_only gets rid of the exception tossing on errors
//#import "..\TveContr\TveContr.tlb" no_namespace named_guids raw_interfaces_only
#include "comdef.h"
#include "MSTvE.h"				// MIDL Generated File


//#include "..\TveContr\TveContr.h"
//#import "TVEFilt.tlb" no_namespace named_guids raw_interfaces_only 
//#include "TVEFilt.h"				// MIDL generated file

#include "TVEFiltProps.h"
#include "TVEFiltPins.h"

#include "Ks.h"				
#include "KsMedia.h"
#include "BdaTypes.h"
#include "BdaMedia.h"		// IPSink Media types	


#include <stdio.h>			// needed in release build
#include <OleAuto.h>		// IErrorInfo

#if 1
static void __stdcall DbgAssert(unsigned short * xxx, unsigned short * yyy, int zzz)
{}
#endif

_COM_SMARTPTR_TYPEDEF(ITVESupervisor,           __uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,    __uuidof(ITVESupervisor_Helper));

// ---------------------------------------------------------------
//   foward declarations
// ---------------------------------------------------------------

class CDShowTVEFilter;
class CTVEFilter;

//  --------------------------------------------------------------
//      CONSTANTS
//  --------------------------------------------------------------

//  filter - associated names
#define FILTER_NAME                             L"TVE Receiver"
#define FILTER_CTL_NAME                         L"TVE Receiver Control"

#define PROP_PAGE_NAME_TUNE                     L"TVE Tune"
#define PROP_PAGE_NAME_CC						L"TVE CC"
#define PROP_PAGE_NAME_STATS                    L"TVE Stats"


#define INPUT_PIN0_NAME                         L"Tune"
#define INPUT_PIN1_NAME                         L"Line21 CC"

//  ---------------------------------------------------------------------------
//      REGISTRY
//  ---------------------------------------------------------------------------

//  registry - names
#define DEF_REG_TVE_KEY					DEF_REG_BASE TEXT("\\") DEF_REG_LOCATION
#define DEF_REG_FILTER_SUBKEY			TEXT ("Filter")
#define DEF_REG_TVE_FILTER				DEF_REG_TVE_KEY TEXT("\\") DEF_REG_FILTER_SUBKEY

// ---------------------------------------------------------------

// Main filter object

class CDShowTVEFilter :
	public ITVEFilter,
//	public ITVEFilter_Helper,
//	public ISupportErrorInfo,
	public ISpecifyPropertyPages
{
public:


DECLARE_REGISTRY_RESOURCEID(IDR_TVEFILTER)

//BEGIN_COM_MAP(CDShowTVEFilter)
//	COM_INTERFACE_ENTRY(ITVEFilter)
//	COM_INTERFACE_ENTRY(ITVEFilter_Helper)
//	COM_INTERFACE_ENTRY(ISupportErrorInfo)
//END_COM_MAP()


// ISupportsErrorInfo
//	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    CDShowTVEFilter (
        IN  CTVEFilter *  punk         //  controlling unknown, always the filter
        ) ;

    ~CDShowTVEFilter (
        ) ;


 //  IUnknown

    STDMETHODIMP
    QueryInterface (
        IN  REFIID  riid,
        OUT void ** ppv
        ) ;

    STDMETHODIMP_(ULONG)
    AddRef (
        ) ;

    STDMETHODIMP_(ULONG)
    Release (
        ) ;

    //  ISpecifyPropertyPages  --------------------------------------------

    STDMETHODIMP 
    GetPages (
        CAUUID * pPages
        ) ;

		  //  -------------------------------------------------------------------
    //  private COM interfaces
    //  see stubs.cpp for entry points
 
	// ITVEFilter
	STDMETHOD(get_SupervisorPunk)(/*[out]*/ IUnknown **pVal);		// delegate to CTVEFilter one
	STDMETHOD(put_IPAdapterAddress)(/*[in]*/ BSTR bstrIPAddr);
	STDMETHOD(get_IPAdapterAddress)(/*[out]*/ BSTR *pbstrIPAddr);
	STDMETHOD(get_StationID)(/*[out]*/ BSTR *pbstrStationID);	// returns what TuneTo set
	STDMETHOD(put_StationID)(/*[in]*/ BSTR bstrStationID);	    // use instead of TuneTo

	STDMETHOD(get_MulticastList)(/*[out]*/ BSTR *pbstrMulticastList);		// talks through IPSINK filter pin interface to get updated value
	STDMETHOD(get_AdapterDescription)(/*[out]*/ BSTR *pbstrAdapterDescription);	

	// should be in helper function
	STDMETHOD(put_HaltFlags)(/*[in]*/ LONG lGrfHaltFlags);		// turns processing on and off - see NFLT_grfHaltFlags
	STDMETHOD(get_HaltFlags)(/*[out]*/ LONG *plGrfHaltFlags);

	STDMETHOD(get_IPSinkAdapterAddress)(/*[in]*/ BSTR *pbstrIPSinkAdapter);

													// called on new Tune event	out of Tune Pin (IPSink Filter)
	STDMETHOD(ReTune)();
													// called for each BytePair out of CC Pin (CC Decoder Filter)
	STDMETHOD(ParseCCBytePair)(LONG lType, BYTE byte1, BYTE byte2);

	// ITVEFilter_Helper

private:

	CTVEFilter					*m_pTVEFilter;				// true filter object
	
}; 


// ------------------------------------------------------
// ------------------------------------------------------
const int kWsz32Size = 32;
const int kcMaxIpAdapts = 10;
typedef WCHAR Wsz32[kWsz32Size];		// simple fixed length string class for IP adapters

class CTVEFilter : 
	public CBaseFilter
 //   public CPersistStream

{
	friend class CTVEInputPinTune;
	friend class CTVEInputPinCC;
	friend class CDShowTVEFilter;

protected:
    CDShowTVEFilter			*m_pDShowTVEFilter;		// our DShow interfaces
 
	CTVEInputPinTune		*m_pPinTune;			// tuning pin (from IPSink)
	CTVEInputPinCC			*m_pPinCC;				// Line21 CC (T2) pin (From CC decoder)
	
	CCritSec				m_Lock;					// Main filter critical section
    CCritSec				m_ReceiveLock;			// Sublock for received samples
 
	HKEY					m_hkeyRoot;				// registry location for TVEFilter info
 
	CComBSTR				m_spbsIPAddr;			// set IP adapter (used for next tune)
	CComBSTR				m_spbsStationId;

	CComBSTR				m_spbsIPAddrTemp;		// set IP adapter (used for next tune)
	CComBSTR				m_spbsStationIdTemp;

	CComBSTR				m_spbsIPSinkAddr;		// Adapter address provide by IPSink

private:
	
	ITVESupervisorPtr		m_spSuper;				// pointers to supervisor (caution, may be in wrong thread!)

public:

			// Constructor / destructor

    CTVEFilter(
		IN	TCHAR		*pName, 
		IN	IUnknown	*pUnk,  
		IN  REFCLSID	rclsid,
		OUT HRESULT		*phr
		);
	~CTVEFilter();

	HRESULT InitParamsFromRegistry();
			
			// ITVEFilter Methods
	STDMETHOD(get_Supervisor)(OUT ITVESupervisor **ppSuper);	// complicated, needs to marshall
	STDMETHOD(put_IPAdapterAddress)(IN BSTR bstrIPAdapter);
	STDMETHOD(get_IPAdapterAddress)(OUT BSTR *pbstrIPAddr);

	STDMETHOD(put_StationID)(IN BSTR	bstrStationID);
	STDMETHOD(get_StationID)(OUT BSTR	*pbstrStationID);

	STDMETHOD(get_MulticastList)(OUT BSTR *pbstrMulticastList);		// talks through IPSINK filter pin interface to get updated value
	STDMETHOD(get_AdapterDescription)(OUT BSTR *pbstrAdapterDescription);	

	STDMETHOD(ReTune)();													// when change station

	STDMETHOD(ParseCCBytePair)(LONG byteType, BYTE byte1, BYTE byte2);	// when get data out of CC
	
			// (eventually ITVEFilter_HelperMethods)					// turn various parts of code on and off
	STDMETHOD(put_HaltFlags)(IN LONG lGrfHaltFlags)	{
															m_dwGrfHaltFlags = (DWORD) lGrfHaltFlags; 	
															ITVESupervisorPtr spSuper;
															HRESULT hr = get_Supervisor(&spSuper);
															if(!FAILED(hr))
															{	 
																ITVESupervisor_HelperPtr spSuperHelper(spSuper);
																if(spSuperHelper)
																	return spSuperHelper->put_HaltFlags(lGrfHaltFlags);
																else 
																	return S_FALSE;	// wasn't there to set
															}
															return hr;
														}
	STDMETHOD(get_HaltFlags)(OUT LONG *plGrfHaltFlags)	{if(NULL == plGrfHaltFlags) return E_POINTER; *plGrfHaltFlags = (LONG) m_dwGrfHaltFlags; return S_OK;}

	STDMETHOD(get_IPSinkAdapterAddress)(OUT BSTR *pbstrIPSinkAdapter);

			// non-interface methods
	HRESULT get_IPAdapterAddresses(OUT int *pcAdaptersUniDi, OUT int *pcAdaptersBiDi,			 // utility function
								   OUT Wsz32 **rgAdaptersUniDi,  OUT Wsz32 **rgAdaptersBiDi);

	HRESULT put_IPSinkAdapterAddress(IN BSTR bstrIPSinkAdapter);

	HRESULT DoTuneConnect();		// called when the IPSink connects - set's adapter address
	HRESULT DoTuneBreakConnect();	// called when the IPSink disconncents - nulls out the adapter address
	HRESULT DoCCConnect();			// called when the WDM CC Decoder connects - set's T2 data type
	HRESULT DoCCBreakConnect();		// called when the WDM CC Decoder disconnects


			// Pin enumeration

    int GetPinCount(void);
	CBasePin * GetPin(int n);
 
			// Open and close  as necessary
    STDMETHOD(Run)(REFERENCE_TIME tStart);
    STDMETHOD(Pause)();
    STDMETHOD(Stop)();

        //  called by the DirectShow class factory code when the object
        //  is instantiated via CoCreateInstance call

    static 
	CUnknown * 
	WINAPI 
	CreateInstance(
		IN  IUnknown *pIUnknown,
		OUT HRESULT *phr);

   // IUnknown ---------------------

    DECLARE_IUNKNOWN;


    STDMETHODIMP
    NonDelegatingQueryInterface (
        IN  REFIID  riid,
        OUT void ** ppv
        ) ;

private:
	CComPtr<IGlobalInterfaceTable>	m_spIGlobalInterfaceTable;		// Prof ATL COM Prog, pg 395-398
	DWORD							m_dwSuperCookie;				// cookie to supervisor object registered in the global interface table

	HRESULT							CreateGITCookies();				// connect SuperCookie's if not created

	L21Buff							m_L21Buff;						// buffer we parse Line21 data in

	void							SubmitChanges();				// swap real and temp data...
	void							CommitChanges();				// push real data into temp data.. 
	bool							m_fThingsChanged;				// dirty flag
	DWORD							m_dwGrfHaltFlags;				// magic run flags to turn things off (zero means all on)

};



#endif	\\ __TVEFILT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvefiltpins.cpp ===
//==========================================================================;
//  TveFiltPins.cpp
//
//			Input Pin interfaces for TVE Receiver Filter
//
//
#include "stdafx.h"
#include "TVEFilt.h"	
	
#include "CommCtrl.h"

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#include "TVEDbg.h"

#include "ksmedia.h"		// STATIC_KSDATAFORMAT_TYPE_AUXLine21Data

_COM_SMARTPTR_TYPEDEF(IMediaSample2,		__uuidof(IMediaSample2));

// ----------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------
//
//  Definition of CTVEInputPinCC
//
CTVEInputPinTune::CTVEInputPinTune(CTVEFilter *pTveFilter,
								LPUNKNOWN pUnk,
								CCritSec *pLock,
								CCritSec *pReceiveLock,
								HRESULT *phr) :

    CRenderedInputPin(NAME("CTVEInputPinTune"),
                  pTveFilter,					// Filter
                  pLock,						// Locking
                  phr,							// Return code
                  L"IPSink (Tune)"),              // Pin name
    m_pReceiveLock(pReceiveLock),
    m_pTVEFilter(pTveFilter),
    m_tLast(0)
{
		ASSERT(phr);
		*phr = S_OK;
		return;
}
//
// CheckMediaType
//
// Check if the pin can support this specific proposed type and format
//
HRESULT CTVEInputPinTune::CheckMediaType(const CMediaType *pmtype)
{
	DBG_HEADER(CDebugLog::DBG_FLT_PIN_TUNE, _T("CTVEInputPinTune::CheckMediaType"));

  
	if (KSDATAFORMAT_TYPE_BDA_IP_CONTROL      == pmtype->majortype &&
		KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL   == pmtype->subtype)
		return S_OK;


	return S_FALSE;
}


//
// ReceiveCanBlock
//
// We don't hold up source threads on Receive
//
STDMETHODIMP CTVEInputPinTune::ReceiveCanBlock()
{
 	DBG_HEADER(CDebugLog::DBG_FLT_PIN_TUNE, _T("CTVEInputPinTune::ReceiveCanBlock"));

    return S_FALSE;
}


//
// Receive
//
// Do something with this media sample
//		doesn't actually do much other than check for disconituity....  
//		Tune pin does nearly all useful work in Connect, and data comes over IP.
//
STDMETHODIMP CTVEInputPinTune::Receive(IMediaSample *pSample)
{
	DBG_HEADER(CDebugLog::DBG_FLT_PIN_TUNE, _T("CTVEInputPinTune::Receive"));
 
	CAutoLock lock(m_pReceiveLock);
    PBYTE pbData;

    REFERENCE_TIME tStart, tStop;
    pSample->GetTime(&tStart, &tStop);

	if(DBG_FSET(CDebugLog::DBG_FLT_PIN_TUNE))
	{	
		USES_CONVERSION;

		WCHAR wszBuff[256];
		swprintf(wszBuff,L"tStart(%s), tStop(%s), Diff(%d ms), Bytes(%d)",
           (LPCTSTR) CDisp(tStart),
           (LPCTSTR) CDisp(tStop),
           (LONG)((tStart - m_tLast) / 10000),
           pSample->GetActualDataLength());
		DBG_WARN(CDebugLog::DBG_FLT_PIN_TUNE, W2T(wszBuff));
	} 

    m_tLast = tStart;

    // Copy the data to the file

    HRESULT hr = pSample->GetPointer(&pbData);
    if (FAILED(hr)) {
        return hr;
    }

	if(S_OK == pSample->IsDiscontinuity())
	{
		TVEDebugLog((CDebugLog::DBG_FLT_PIN_TUNE, 3, _T("Discontinuity") ));
		return S_OK;	
	}	
		// do something interesting...
	return hr;
}



//
// EndOfStream
//
STDMETHODIMP CTVEInputPinTune::EndOfStream(void)
{
 	DBG_HEADER(CDebugLog::DBG_FLT_PIN_TUNE, _T("CTVEInputPinTune::EndOfStream"));
 
	CAutoLock lock(m_pReceiveLock);
    return CRenderedInputPin::EndOfStream();

} // EndOfStream


//
// CompleteConnect
//
// Call the filter to actually connect up the pin to the BDA IPSink FIlter
//
HRESULT CTVEInputPinTune::CompleteConnect(IPin *pPin)
{
	DBG_HEADER(CDebugLog::DBG_FLT_PIN_TUNE, _T("CTVEInputPinTune::CompleteConnect"));
	HRESULT hr = CBaseInputPin::CompleteConnect(pPin);
	if(!FAILED(hr))
	{
		hr = m_pTVEFilter->DoTuneConnect();
	
	} else {
		DBG_WARN(CDebugLog::DBG_SEV3,_T("CTVEInputPinTune::CompleteConnect - Failed to connect"));
	}

    return hr;
}

HRESULT CTVEInputPinTune::BreakConnect()
{
	DBG_HEADER(CDebugLog::DBG_FLT_PIN_TUNE, _T("CTVEInputPinTune::BreakConnect"));

	m_pTVEFilter->DoTuneBreakConnect();
	return CRenderedInputPin::BreakConnect();
}



// -----------------------------------------------------------------------------------
CTVEInputPinCC::CTVEInputPinCC(CTVEFilter *pTveFilter,
								LPUNKNOWN pUnk,
								CCritSec *pLock,
								CCritSec *pReceiveLock,
								HRESULT *phr) :

    CRenderedInputPin(NAME("CTVEInputPinCC"),
                  pTveFilter,					// Filter
                  pLock,						// Locking
                  phr,							// Return code
                  L"CC Input"),               // Pin name
    m_pReceiveLock(pReceiveLock),
    m_pTVEFilter(pTveFilter),
    m_tLast(0)
{
		ASSERT(phr);
		*phr = S_OK;
		return;
}

//
// CheckMediaType
//
// Check if the pin can support this specific proposed type and format
// KSDATARANGE StreamFormatCC =
// {
//     // Definition of the CC stream
//    {
//         sizeof (KSDATARANGE),           // FormatSize
//         0,                              // Flags
//         2,                              // SampleSize
//         0,                              // Reserved
//         { STATIC_KSDATAFORMAT_TYPE_AUXLine21Data },
//         { STATIC_KSDATAFORMAT_SUBTYPE_Line21_BytePair },
//         { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
//     }
// };

	// KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY
	//		see   D:\nt\drivers\wdm\vbi\cc\codprop.c

//
HRESULT CTVEInputPinCC::CheckMediaType(const CMediaType *pmtype)
{
	DBG_HEADER(CDebugLog::DBG_FLT_PIN_CC, _T("CTVEInputPinCC::CheckMediaType"));

  
	if (KSDATAFORMAT_TYPE_AUXLine21Data      == pmtype->majortype &&
		KSDATAFORMAT_SUBTYPE_Line21_BytePair == pmtype->subtype)
		return S_OK;

	return S_FALSE;

}


//
// ReceiveCanBlock
//
// We don't hold up source threads on Receive
//
STDMETHODIMP CTVEInputPinCC::ReceiveCanBlock()
{
	DBG_HEADER(CDebugLog::DBG_FLT_PIN_CC, _T("CTVEInputPinCC::ReceiveCanBlock"));
     return S_FALSE;
}


//
// Receive
//
// Do something with this media sample
//
STDMETHODIMP CTVEInputPinCC::Receive(IMediaSample *pSample)
{

	LONG lGrfHaltFlags;
	m_pTVEFilter->get_HaltFlags(&lGrfHaltFlags);
	if(lGrfHaltFlags & NFLT_grfTA_Listen)					// quick return if turned off...
		return S_OK;

 
    HRESULT hr = S_OK;
//	DBG_HEADER(CDebugLog::DBG_FLT_PIN_CC, _T("CTVEInputPinCC::Receive"));
	DBG_HEADER(0x80000000, _T("CTVEInputPinCC::Receive"));

	CAutoLock lock(m_pReceiveLock);
    PBYTE pbData;

//    REFERENCE_TIME tStart, tStop;
 //   pSample->GetTime(&tStart, &tStop);

/*	if(DBG_FSET(CDebugLog::DBG_FLT_PIN_CC))
	{	
		USES_CONVERSION;

		WCHAR wszBuff[256];
		swprintf(wszBuff,L"tStart(%s), tStop(%s), Diff(%d ms), Bytes(%d)",
           (LPCTSTR) CDisp(tStart),
           (LPCTSTR) CDisp(tStop),
           (LONG)((tStart - m_tLast) / 10000),
           pSample->GetActualDataLength());
		DBG_WARN(CDebugLog::DBG_FLT_PIN_CC, W2T(wszBuff));
	} 

    m_tLast = tStart;
*/
    // Check the data

	if(S_OK == pSample->IsDiscontinuity())
	{
		TVEDebugLog((CDebugLog::DBG_FLT_PIN_CC, 3, _T("Discontinuity") ));
		return S_OK;	
	}

	if(pSample->GetActualDataLength() == 0)		// no data
		return S_OK;

	if(pSample->GetActualDataLength() != 2)
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 2, 
			        _T("Unexpected Length of CC data (%d != 2 bytes)"),
					pSample->GetActualDataLength() ));
		return E_UNEXPECTED;
	}

	hr = pSample->GetPointer(&pbData);
    if (FAILED(hr)) 
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 2,  _T("Empty Buffer for CC data, hr = 0x%08x"),hr));
        return hr;
	}
	
	BYTE byte0 = pbData[0];
	BYTE byte1 = pbData[1];
	DWORD dwType = 0;					// todo - default to some useful value
										//  incase get an old type sample
	
	{
		IMediaSample2Ptr spSample2(pSample);
		if(NULL != spSample2) 
		{
			AM_SAMPLE2_PROPERTIES Samp2Props;
			DWORD cbProperties =  sizeof(AM_SAMPLE2_PROPERTIES);		// smaller?
			hr = spSample2->GetProperties(cbProperties, (BYTE *) &Samp2Props);

			if(!FAILED(hr)) {
				dwType = Samp2Props.dwTypeSpecificFlags;
				//dwType = Samp2Props.dwSampleFlags;
			} else {
				TVEDebugLog((CDebugLog::DBG_SEV2, 2,  _T("Couldn't get AM_SAMPLE2 props, hr = 0x%08x"),hr));
			}

		}
	}

#if 0	// hack code!
	if(byte0 != byte1 && byte0&0x7f != 0x00 && byte0 != 0xff) {
		DBG_HEADER(CDebugLog::DBG_FLT_PIN_CC, _T("CTVEInputPinCC::Receive"));
		TVEDebugLog((CDebugLog::DBG_FLT_PIN_CC, 5,  _T("0x%08x 0x%2x 0x%2x (%c %c)"),
					dwType, byte0&0x7f, byte1&0x7f, 
					isprint(byte0&0x7f) ? byte0&0x7f : '?', 
					isprint(byte1&0x7f) ? byte1&0x7f : '?' ));
	}
	return S_OK;
#endif
	
	if(pSample->IsPreroll() == S_OK)
	{
					// do something here if *really* need to.. (no renders yet!)
	}

					// quick optimization
	if((byte0 == byte1) && ((byte0 & 0x7f) == 0x00 || (byte0 & 0x7f) == 0x7f))
		return S_OK;

	if(lGrfHaltFlags & NFLT_grfTA_Decode)		// stop decode if flags set ('parse' is after we get a full line of data.)
		return S_OK;

	hr = m_pTVEFilter->ParseCCBytePair(dwType, byte0, byte1);
	if(FAILED(hr))
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 2,  _T("Couldn't ParseCCBytePair, hr = 0x%08x"),hr));
	}

	return S_OK;
}



//
// EndOfStream
//
STDMETHODIMP CTVEInputPinCC::EndOfStream(void)
{
 	DBG_HEADER(CDebugLog::DBG_FLT_PIN_CC, _T("CTVEInputPinCC::EndOfStream"));
 
	CAutoLock lock(m_pReceiveLock);
    return CRenderedInputPin::EndOfStream();

} // EndOfStream


//
// CompleteConnect
//
// Call the filter to actually connect up pin to the Closed Caption Decoder
//

HRESULT CTVEInputPinCC::CompleteConnect(IPin *pPin)
{
	DBG_HEADER(CDebugLog::DBG_FLT_PIN_TUNE, _T("CTVEInputPinTune::CompleteConnect"));
	HRESULT hr = CRenderedInputPin::CompleteConnect(pPin);
	if(!FAILED(hr))
	{
		hr = m_pTVEFilter->DoCCConnect();
	
	} else {
		DBG_WARN(CDebugLog::DBG_SEV3,_T("CTVEInputPinCC::CompleteConnect - Failed to connect"));
	}

    return hr;
}

HRESULT CTVEInputPinCC::BreakConnect()
{
	DBG_HEADER(CDebugLog::DBG_FLT_PIN_TUNE, _T("CTVEInputPinCC::BreakConnect"));

	m_pTVEFilter->DoCCBreakConnect();
	return CRenderedInputPin::BreakConnect();
}
//
// NewSegment
//
// Called when we are seeked
//
/*
STDMETHODIMP CTVEInputPinCC::NewSegment(REFERENCE_TIME tStart,
											   REFERENCE_TIME tStop,
											   double dRate)
{
//    m_tLast = 0;
    return S_OK;

} // NewSegment
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvefiltpins.h ===
#ifndef __TVEFILTPINS_H__
#define __TVEFILTPINS_H__

// ----------------------------------
//  forward declarations
// ----------------------------------

class CTVEInputPinTune;
class CTVEInputPinCC;


class CTVEFilter;

// ----------------------------------------------------------------
//
// -----------------------------------------------------------------
//  Pin object

class CTVEInputPinCC : 
	public CRenderedInputPin
{
    CTVEFilter  * const m_pTVEFilter;			// Main renderer object
    CCritSec	* const m_pReceiveLock;			// Sample critical section
    REFERENCE_TIME		m_tLast;				// Last sample receive time

public:

    CTVEInputPinCC(CTVEFilter *pTveFilter,
					LPUNKNOWN pUnk,
					CCritSec *pLock,
					CCritSec *pReceiveLock,
					HRESULT *phr);

	virtual ~CTVEInputPinCC()
	{
		return;			// place for a breakpoint
	}


	STDMETHODIMP ReceiveCanBlock();			// always returns false
    // Do something with this media sample
    STDMETHODIMP Receive(IMediaSample *pSample);
    STDMETHODIMP EndOfStream(void);

    // Check if the pin can support this specific proposed type and format
    HRESULT CheckMediaType(const CMediaType *);

	virtual HRESULT CompleteConnect(IPin *pReceivePin);		// override to get the IP Addr after the connect
	virtual HRESULT BreakConnect();	
};


class CTVEInputPinTune : public CRenderedInputPin
{
	CTVEFilter    * const m_pTVEFilter;				// Main renderer object
    CCritSec	  * const m_pReceiveLock;			// Sample critical section
    REFERENCE_TIME		m_tLast;					// Last sample receive time
public:
	
	CTVEInputPinTune(CTVEFilter *pTveFilter,
						LPUNKNOWN pUnk,
						CCritSec *pLock,
						CCritSec *pReceiveLock,
						HRESULT *phr);

		
	virtual ~CTVEInputPinTune()
	{
		return;			// place for a breakpoint
	}

	STDMETHODIMP ReceiveCanBlock();			// always returns false
    // Do something with this media sample
    STDMETHODIMP Receive(IMediaSample *pSample);
    STDMETHODIMP EndOfStream(void);
	virtual HRESULT CompleteConnect(IPin *pReceivePin);		// override to get the IP Addr after the connect
	virtual HRESULT BreakConnect();							

    // Check if the pin can support this specific proposed type and format
    HRESULT CheckMediaType(const CMediaType *);

};

#endif // __TVEFILTPINS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvefiltprops.cpp ===
//==========================================================================;
//  TveFiltProps.cpp
//
//			Property Sheet for TVE Receiver Filter
//
//
#include "stdafx.h"
#include "TveFilt.h"			

#include "CommCtrl.h"

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#include "TVEDbg.h"
#include "TVEStats.h"

#include "dbgstuff.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

_COM_SMARTPTR_TYPEDEF(ITVEService,              __uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEServices,             __uuidof(ITVEServices));
// ---------------------------------------------------------------------------
//
//  see inet_addr() for details on how parsing ip address 
//
// ---------------------------------------------------------------------------
//
// Filter property page code
//
CUnknown * WINAPI 
CTVEFilterCCProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CTVEFilterCCProperties(NAME("ATVEF CC Filter Properties"),
											  lpunk, 
											  phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CTVEFilterCCProperties::CTVEFilterCCProperties(
			IN  TCHAR		*   pClassName,
			IN	IUnknown	*	pIUnknown, 
			HRESULT			*	phr)
    : CBasePropertyPage(pClassName, 
						pIUnknown,
						IDD_TVEFILTER_CCPROPPAGE, 
						IDS_TVEFILTER_CCPROPNAME
						),
    m_hwnd(NULL),
	m_pITVEFilter(NULL)
{
	ASSERT(phr);
	*phr = S_OK;

	INITCOMMONCONTROLSEX icce;					// needs Comctl32.dll
	icce.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icce.dwICC = ICC_INTERNET_CLASSES;
	BOOL fOK = InitCommonControlsEx(&icce);
	if(!fOK)
		*phr = E_FAIL;

	return;
}

CTVEFilterCCProperties::~CTVEFilterCCProperties()
{
	return;
}

HRESULT CTVEFilterCCProperties::OnConnect(IUnknown *pUnknown) 
{
	ASSERT(!m_pITVEFilter);  // pUnk is to CTVEFilter, not CDShowTVEFilter...
	HRESULT hr = pUnknown->QueryInterface(IID_ITVEFilter, (void**) &m_pITVEFilter);

	if (FAILED(hr)) {
		m_pITVEFilter = NULL;
		return hr;
	}
	return S_OK;
}

HRESULT CTVEFilterCCProperties::OnDisconnect() 
{
  if (!m_pITVEFilter)
      return E_UNEXPECTED;
   m_pITVEFilter->Release(); 
   m_pITVEFilter = NULL;
   return S_OK;
}

HRESULT CTVEFilterCCProperties::OnActivate(void)
{
   UpdateFields();
   return S_OK;
}

#define _SETBUT(buttonIDC, grfFlag)	SetDlgItemTextW(m_hwnd, (buttonIDC), (lGrfHaltFlags & (grfFlag)) ? L"Stopped" : L"Running");

void CTVEFilterCCProperties::UpdateFields() 
{
	CComBSTR spbsStationID;
	CComBSTR spbsIPAddr;
	if(!m_pITVEFilter) return;		// haven't inited yet....
	
	long lGrfHaltFlags;
	m_pITVEFilter->get_HaltFlags(&lGrfHaltFlags);
	
	_SETBUT(IDC_TVECC_XOVER_LISTEN, NFLT_grfTA_Listen);			// don't listen for CC (XOverLink) triggers
	_SETBUT(IDC_TVECC_XOVER_DECODE, NFLT_grfTA_Decode);			// don't accumulate byte data for XOverLink triggers into strings
	_SETBUT(IDC_TVECC_XOVER_PARSE,  NFLT_grfTA_Parse);			// don't parse any XOverLink data
	
	_SETBUT(IDC_TVECC_ANNC_LISTEN, NFLT_grfTB_AnncListen);		// suspend listening for announcement packets if set
	_SETBUT(IDC_TVECC_ANNC_DECODE, NFLT_grfTB_AnncDecode);		// suspend decoding and processing of announcement packets if set
	_SETBUT(IDC_TVECC_ANNC_PARSE,  NFLT_grfTB_AnncParse);		// don't parse any announcements

	_SETBUT(IDC_TVECC_TRIG_LISTEN, NFLT_grfTB_TrigListen);		// suspend listening for transport B triggers
	_SETBUT(IDC_TVECC_TRIG_DECODE, NFLT_grfTB_TrigDecode);		// suspend listening for transport B triggers
	_SETBUT(IDC_TVECC_TRIG_PARSE,  NFLT_grfTB_TrigParse);		// don't parse any transport B triggers

	_SETBUT(IDC_TVECC_DATA_LISTEN, NFLT_grfTB_DataListen);		// suspend listening for transport B data (files)
	_SETBUT(IDC_TVECC_DATA_DECODE, NFLT_grfTB_DataDecode);		// suspend listening for transport B data (files)
	_SETBUT(IDC_TVECC_DATA_PARSE,  NFLT_grfTB_DataParse);		// don't parse any transport B data (files)

	_SETBUT(IDC_TVECC_EXPIREQ,     NFLT_grf_ExpireQueue);		// turn expire queue processing on and off
	_SETBUT(IDC_TVECC_EXTRA,	   NFLT_grf_Extra1);			// extra flag
}

HRESULT CTVEFilterCCProperties::OnDeactivate(void)
{
   return S_OK;
}


HRESULT CTVEFilterCCProperties::OnApplyChanges(void)
{
    return S_OK;
}


#define _CHGFLAGS(theFlag, runFlags, haltFlags) \
{										\
	lGrfHaltFlags ^= theFlag;			\
	if(lGrfHaltFlags & theFlag)		\
		lGrfHaltFlags |= (haltFlags);	\
	else								\
		lGrfHaltFlags &= ~(runFlags);	\
	m_pITVEFilter->put_HaltFlags(lGrfHaltFlags); \
	UpdateFields(); \
}

INT_PTR 
CTVEFilterCCProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam)
{
    switch (uMsg) {

    case WM_INITDIALOG:
    {
        ASSERT (m_hwnd == NULL) ;
        m_hwnd = hwnd ;
        break;
    }

    //  see ::OnDeactivate()'s comment block
    case WM_DESTROY :
    {
        m_hwnd = NULL ;
        break ;
    }

    case WM_COMMAND:

        if (HIWORD(wParam) == EN_KILLFOCUS) {
//           m_bDirty = TRUE;
 //          if (m_pPageSite)
 //              m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }

		long lGrfHaltFlags;
		m_pITVEFilter->get_HaltFlags(&lGrfHaltFlags);
		
		if(LOWORD(wParam) == IDC_TVECC_XOVER_LISTEN) _CHGFLAGS(NFLT_grfTA_Listen,    NFLT_grfNone	       , NFLT_grfTA_Decode|NFLT_grfTA_Parse);
		if(LOWORD(wParam) == IDC_TVECC_XOVER_DECODE) _CHGFLAGS(NFLT_grfTA_Decode,    NFLT_grfTA_Listen     , NFLT_grfTA_Parse);
		if(LOWORD(wParam) == IDC_TVECC_XOVER_PARSE)  _CHGFLAGS(NFLT_grfTA_Parse,     NFLT_grfTA_Decode | NFLT_grfTA_Listen, NFLT_grfNone);
		
		if(LOWORD(wParam) == IDC_TVECC_ANNC_LISTEN) _CHGFLAGS(NFLT_grfTB_AnncListen, NFLT_grfNone	       , NFLT_grfTB_AnncDecode|NFLT_grfTB_AnncParse);
		if(LOWORD(wParam) == IDC_TVECC_ANNC_DECODE) _CHGFLAGS(NFLT_grfTB_AnncDecode, NFLT_grfTB_AnncListen , NFLT_grfTB_AnncParse);
		if(LOWORD(wParam) == IDC_TVECC_ANNC_PARSE)  _CHGFLAGS(NFLT_grfTB_AnncParse,  NFLT_grfTB_AnncListen | NFLT_grfTB_AnncDecode, NFLT_grfNone);

		if(LOWORD(wParam) == IDC_TVECC_TRIG_LISTEN) _CHGFLAGS(NFLT_grfTB_TrigListen, NFLT_grfNone	       , NFLT_grfTB_TrigDecode|NFLT_grfTB_TrigParse);
		if(LOWORD(wParam) == IDC_TVECC_TRIG_DECODE) _CHGFLAGS(NFLT_grfTB_TrigDecode, NFLT_grfTB_TrigListen , NFLT_grfTB_TrigParse);
		if(LOWORD(wParam) == IDC_TVECC_TRIG_PARSE)  _CHGFLAGS(NFLT_grfTB_TrigParse,  NFLT_grfTB_TrigListen | NFLT_grfTB_TrigDecode, NFLT_grfNone);
	
		if(LOWORD(wParam) == IDC_TVECC_DATA_LISTEN) _CHGFLAGS(NFLT_grfTB_DataListen, NFLT_grfNone          , NFLT_grfTB_DataDecode|NFLT_grfTB_DataParse);
		if(LOWORD(wParam) == IDC_TVECC_DATA_DECODE) _CHGFLAGS(NFLT_grfTB_DataDecode, NFLT_grfTB_DataListen , NFLT_grfTB_DataParse);
		if(LOWORD(wParam) == IDC_TVECC_DATA_PARSE)  _CHGFLAGS(NFLT_grfTB_DataParse,  NFLT_grfTB_DataListen | NFLT_grfTB_DataDecode, NFLT_grfNone);

		if(LOWORD(wParam) == IDC_TVECC_EXPIREQ)     _CHGFLAGS(NFLT_grf_ExpireQueue,  NFLT_grfNone          , NFLT_grfNone);
		if(LOWORD(wParam) == IDC_TVECC_EXTRA)       _CHGFLAGS(NFLT_grf_Extra1,       NFLT_grfNone          , NFLT_grfNone);
	        break;
    }	// end uMsg switch

   return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}

// ---------------------------------------------------------------------------
//
// Tune property page code
//
CUnknown * WINAPI 
CTVEFilterTuneProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CTVEFilterTuneProperties(NAME("ATVEF Filter Tune Properties"),
											  lpunk, 
											  phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CTVEFilterTuneProperties::CTVEFilterTuneProperties(
			IN  TCHAR		*   pClassName,
			IN	IUnknown	*	pIUnknown, 
			HRESULT			*	phr)
    : CBasePropertyPage(pClassName, 
						pIUnknown,
						IDD_TVEFILTER_TUNEPROPPAGE, 
						IDS_TVEFILTER_TUNEPROPNAME
						),
    m_hwnd(NULL),
	m_pITVEFilter(NULL)
{
	ASSERT(phr);
	*phr = S_OK;

	INITCOMMONCONTROLSEX icce;					// needs Comctl32.dll
	icce.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icce.dwICC = ICC_INTERNET_CLASSES;
	BOOL fOK = InitCommonControlsEx(&icce);
	if(!fOK)
		*phr = E_FAIL;

	return;
}

CTVEFilterTuneProperties::~CTVEFilterTuneProperties()
{
	return;
}

HRESULT CTVEFilterTuneProperties::OnConnect(IUnknown *pUnknown) 
{
	ASSERT(!m_pITVEFilter);
	HRESULT hr = pUnknown->QueryInterface(IID_ITVEFilter, (void**) &m_pITVEFilter);
	if (FAILED(hr)) {
		m_pITVEFilter = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CTVEFilterTuneProperties::OnDisconnect() 
{
  if (!m_pITVEFilter)
      return E_UNEXPECTED;
   m_pITVEFilter->Release(); 
   m_pITVEFilter = NULL;
   return S_OK;
}



HRESULT CTVEFilterTuneProperties::OnActivate(void)
{
   UpdateFields();
   return S_OK;
}


void CTVEFilterTuneProperties::UpdateMulticastList(BOOL fConnectToIPSink)
{
	if(fConnectToIPSink)
	{
		CComBSTR spbsMulticastList;
		HRESULT hr = m_pITVEFilter->get_MulticastList(&spbsMulticastList);

						// a trivial List Box implementation...
		HWND hLBox = GetDlgItem(m_hwnd, IDC_LIST_ADDRESSES);
		SendMessage(hLBox, LB_RESETCONTENT, 0, 0);				// clear previous items

		int iItem = 0;
		if(spbsMulticastList.Length() > 0)					// comma separated list...
		{
			WCHAR *pwc = spbsMulticastList.m_str;
			while(NULL != *pwc)
			{
				WCHAR *pwcT = pwc;
				WCHAR *pwcS = pwc;
				while(NULL != *pwcT && ',' != *pwcT)
					pwcT++;
				if(NULL != *pwcT) {
					*pwcT = NULL;					// null terminate the string on the comma
					pwc = pwcT+1;					
				} else {
					pwc = pwcT;						// at the end...
				}

				SendMessage(hLBox, LB_ADDSTRING,       0, (LPARAM) W2T(pwcS));	
				SendMessage(hLBox, LB_SETITEMDATA, iItem, (LPARAM) iItem); 
			}
		}
	} else {
		HWND hLBox = GetDlgItem(m_hwnd, IDC_LIST_ADDRESSES);
		SendMessage(hLBox, LB_RESETCONTENT, 0, 0);				// clear previous items
		SendMessage(hLBox, LB_ADDSTRING,       0, (LPARAM) _T("Not Conneced to IPSink"));	
		SendMessage(hLBox, LB_SETITEMDATA,  0, 0); 
	}
}

void CTVEFilterTuneProperties::UpdateFields() 
{
	HRESULT hr;
	CComBSTR spbsStationID;
	CComBSTR spbsIPAddr;
	CComBSTR spbsMulticastList;
	if(!m_pITVEFilter) return;		// haven't inited yet....

	m_pITVEFilter->get_StationID(&spbsStationID);
	m_pITVEFilter->get_IPAdapterAddress(&spbsIPAddr);

	SetDlgItemText(m_hwnd, IDC_EDIT_STATION, W2T(spbsStationID));

	int cAdaptersUniDi, cAdaptersBiDi;
	Wsz32 *rgAdaptersUniDi;
	Wsz32 *rgAdaptersBiDi;				// nasty cast!!!
	hr = ((CTVEFilter *) m_pITVEFilter)->get_IPAdapterAddresses(&cAdaptersUniDi, &cAdaptersBiDi, 
											  &rgAdaptersUniDi,  &rgAdaptersBiDi);

	USES_CONVERSION;
	int iItemSelected = -1;

	HWND hCBox = GetDlgItem(m_hwnd, IDC_COMBO_IPADDRESS);

    SendMessage(hCBox, CB_RESETCONTENT, 0, 0);		// initalize the list

	if(cAdaptersUniDi + cAdaptersBiDi == 0) 
		SendMessage(hCBox, CB_INSERTSTRING,  -1, (LPARAM) _T("No IP Adapters Found!"));
	else
	{
		int iItem = 0;
		CComBSTR spbsIPSinkAddr, spbsIPAddrSelected;

		hr = m_pITVEFilter->get_IPSinkAdapterAddress(&spbsIPSinkAddr);		// IPSink adapter if selected
		hr = m_pITVEFilter->get_IPAdapterAddress(&spbsIPAddrSelected);				// currently selected one

		if(!FAILED(hr) && spbsIPSinkAddr.Length() > 0) 
		{
			CComBSTR spbsTmp(spbsIPSinkAddr);
			spbsTmp += L" (IP Sink)";
			if(spbsIPAddrSelected == spbsIPSinkAddr)
				iItemSelected = iItem;
			SendMessage(hCBox, CB_INSERTSTRING,  -1, (LPARAM) W2T(spbsTmp));
			SendMessage(hCBox, LB_SETITEMDATA, iItem, (LPARAM) iItem); iItem++;
		}
		for(int i = 0; i < cAdaptersUniDi + cAdaptersBiDi; i++)
		{
			CComBSTR spbsAddr;
			CComBSTR spbsTag;
			if(i < cAdaptersUniDi)
			{	spbsAddr = rgAdaptersUniDi[i];
				spbsTag = " (IPSink ???)";
			} else {
				spbsAddr = rgAdaptersBiDi[i-cAdaptersUniDi];
				spbsTag = " (Ethernet)";
			}
			if(!(spbsAddr == spbsIPSinkAddr) || (i >= cAdaptersUniDi))		// no != operator, '>' test to see if IPSink is in BiDi adapter list
			{
				if(spbsIPAddrSelected == spbsAddr && (iItemSelected < 0))
					iItemSelected = iItem;
				spbsAddr += spbsTag;
				SendMessage(hCBox, CB_INSERTSTRING,  -1, (LPARAM) W2T(spbsAddr));
				SendMessage(hCBox, LB_SETITEMDATA, iItem, (LPARAM) iItem); iItem++;
			}
		}
	}

	int cItems = (int) SendMessage(hCBox, CB_GETCOUNT, 0, 0);			

		// Place the word in the selection field. 
    SendMessage(hCBox,CB_SETCURSEL,	  iItemSelected<0 ? 0 : iItemSelected, 0);			// reselect the first one... (should be IPSinks!)
 
	UpdateMulticastList(iItemSelected==0);
}

HRESULT CTVEFilterTuneProperties::OnDeactivate(void)
{
   return S_OK;
}


HRESULT CTVEFilterTuneProperties::OnApplyChanges(void)
{
	HRESULT hr = E_POINTER;
	if (NULL != m_pITVEFilter)
	{
		hr = m_pITVEFilter->ReTune();			// this will kick up a MessageBox if it fails...
	}

    return hr;
}


INT_PTR CTVEFilterTuneProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam)
{
	HRESULT hr;
	const int kMaxStrLen = 128;
 	bool fThingsChanged = false;
    switch (uMsg) {

    case WM_INITDIALOG:
    {
        ASSERT (m_hwnd == NULL) ;
        m_hwnd = hwnd ;
		UpdateFields();
		break;
    }

    //  see ::OnDeactivate()'s comment block
    case WM_DESTROY :
    {
        m_hwnd = NULL ;
        break ;
    }

    case WM_COMMAND:

		if (HIWORD(wParam) != EN_KILLFOCUS)
		{
			switch(LOWORD(wParam))
			{
			case IDC_COMBO_IPADDRESS:
				if(HIWORD(wParam) != CBN_SELCHANGE)
					break;
						// for a double-click, process the OK case
			case IDOK:
				{
					TCHAR szIPAddress[kMaxStrLen];
					SendDlgItemMessage(m_hwnd, IDC_COMBO_IPADDRESS, WM_GETTEXT, kMaxStrLen, (LPARAM) szIPAddress);
					TCHAR *tz = szIPAddress;
					while(!isspace(*tz) && *tz != NULL)	// null off the comment at the end of the string...		
						tz++;
					*tz=NULL;

					CComBSTR spbsIPAdapterCurr(szIPAddress);
					hr = m_pITVEFilter->put_IPAdapterAddress(spbsIPAdapterCurr);		// returns S_FALSE if it changed
					if(S_OK == hr)
						fThingsChanged = true;

					CComBSTR spbsIPSinkAdapter;
					hr = m_pITVEFilter->get_IPSinkAdapterAddress(&spbsIPSinkAdapter);	// IPSink adapter...
					if(fThingsChanged)
					{
						if(spbsIPAdapterCurr == spbsIPSinkAdapter)
						{
							UpdateMulticastList(true);
						} else {
							UpdateMulticastList(false);
						}
					}
				}
			}
		}
        if (HIWORD(wParam) == EN_KILLFOCUS) 		//  on exit of edit windows, snarf up changed values
		{
			USES_CONVERSION;

							// get/put current values just to fill up the 'Temp' values
		    CComBSTR spbsIPAddressCurr;
		    CComBSTR spbsStationIDCurr;
		    hr = m_pITVEFilter->get_IPAdapterAddress(&spbsIPAddressCurr);
		    hr = m_pITVEFilter->get_StationID(&spbsStationIDCurr);

			switch (LOWORD(wParam)) {
			case IDC_COMBO_IPADDRESS:
				{
				   TCHAR szIPAddress[kMaxStrLen];
				   GetDlgItemText(m_hwnd, IDC_COMBO_IPADDRESS, szIPAddress, kMaxStrLen-1);

/*					hr = m_pITVEFilter->put_IPAdapterAddress(T2W(szIPAddress));
					if(S_OK == hr)
						fThingsChanged = true;
					else if (FAILED(hr))
					{
						MessageBox(NULL, _T("Invalid IP Address"), NULL, MB_OK);
						SetDlgItemText(m_hwnd, IDC_COMBO_IPADDRESS, W2T(spbsIPAddressCurr));
					} */
			   }
			   break;
			case IDC_EDIT_STATION:
			   {
				   TCHAR szStation[kMaxStrLen];
				   GetDlgItemText(m_hwnd, IDC_EDIT_STATION, szStation, kMaxStrLen-1);

					hr = m_pITVEFilter->put_StationID(T2W(szStation));			// returns S_FALSE if not changing
					if(S_OK == hr)
						fThingsChanged = true;
					else if (FAILED(hr))
					{
						MessageBox(NULL, _T("Invalid Station ID"), NULL, MB_OK);
						SetDlgItemText(m_hwnd, IDC_EDIT_STATION, W2T(spbsStationIDCurr));
					}
			   }
			   break;
						// todo - actually do something with these values..
           default:
               break;
           }			// end switch
		} // end EN_KILLFOCUS if

		if(fThingsChanged) 
		{
			m_bDirty = TRUE;
		    if (m_pPageSite)
			   m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
		}
		break;				// end WM_COMMAND test
        //return TRUE;
    }	// end umsg switch
   return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}

// ---------------------------------------------------------------------------
//
// Stats property page code
//
CUnknown * WINAPI 
CTVEFilterStatsProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CTVEFilterStatsProperties(NAME("ATVEF Filter Stats Properties"),
											  lpunk, 
											  phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CTVEFilterStatsProperties::CTVEFilterStatsProperties(
			IN  TCHAR		*   pClassName,
			IN	IUnknown	*	pIUnknown, 
			HRESULT			*	phr)
    : CBasePropertyPage(pClassName, 
						pIUnknown,
						IDD_TVEFILTER_STATSPROPPAGE, 
						IDS_TVEFILTER_STATSPROPNAME
						),
    m_hwnd(NULL),
	m_pITVEFilter(NULL)
{
	ASSERT(phr);
	*phr = S_OK;

	INITCOMMONCONTROLSEX icce;					// needs Comctl32.dll
	icce.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icce.dwICC = ICC_INTERNET_CLASSES;
	BOOL fOK = InitCommonControlsEx(&icce);
	if(!fOK)
		*phr = E_FAIL;

	return;
}


CTVEFilterStatsProperties::~CTVEFilterStatsProperties()
{
	return;
}

HRESULT CTVEFilterStatsProperties::OnConnect(IUnknown *pUnknown) 
{
	ASSERT(!m_pITVEFilter);
	HRESULT hr = pUnknown->QueryInterface(IID_ITVEFilter, (void**) &m_pITVEFilter);
	if (FAILED(hr)) {
		m_pITVEFilter = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CTVEFilterStatsProperties::OnDisconnect() 
{
 	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilterStatsProperties::OnDisconnect"));
	if (!m_pITVEFilter)
      return E_UNEXPECTED;
   m_pITVEFilter->Release(); 
   m_pITVEFilter = NULL;
   return S_OK;
}

HRESULT CTVEFilterStatsProperties::OnActivate(void)
{
   UpdateFields();
   return S_OK;
}

void CTVEFilterStatsProperties::UpdateFields() 
{
	HRESULT hr=S_OK;
	DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilterStatsProperties::UpdateFields"));
	

	if(!m_pITVEFilter)
		return;

	IUnknownPtr spSuperPunk;
	hr = m_pITVEFilter->get_SupervisorPunk(&spSuperPunk);

	if(FAILED(hr)) 
		return;

	if(NULL == spSuperPunk)
		return;

	ITVESupervisorPtr spSuper(spSuperPunk);


	if(NULL == spSuper)
		return;


	CComBSTR bstrFakeStats;
	hr = spSuper->GetStats(&bstrFakeStats);
	if(FAILED(hr))
		return;

	if(NULL == bstrFakeStats.m_str)
		return;

	CTVEStats *pTveStats = (CTVEStats *) bstrFakeStats.m_str;

	SetDlgItemInt(m_hwnd, IDC_TVESTATS_TUNES,			pTveStats->m_cTunes,	true);
	SetDlgItemInt(m_hwnd, IDC_TVESTATS_FILES,			pTveStats->m_cFiles,	true);
	SetDlgItemInt(m_hwnd, IDC_TVESTATS_PACKAGES,		pTveStats->m_cPackages, true);
	SetDlgItemInt(m_hwnd, IDC_TVESTATS_TRIGGERS,		pTveStats->m_cTriggers, true);
	SetDlgItemInt(m_hwnd, IDC_TVESTATS_XOVERLINKS,		pTveStats->m_cXOverLinks, true);
	SetDlgItemInt(m_hwnd, IDC_TVESTATS_ENHANCEMENTS,	pTveStats->m_cEnhancements, true);
	SetDlgItemInt(m_hwnd, IDC_TVESTATS_AUXINFO,			pTveStats->m_cAuxInfos,	true);

	ITVEServicesPtr spServices;
	hr = spSuper->get_Services(&spServices);
	if(FAILED(hr) || NULL == spServices)
		return;

	long cServices;
	hr = spServices->get_Count(&cServices);
	if(FAILED(hr)) 
		return;

	SetDlgItemInt(m_hwnd, IDC_TVESTATS_SERVICES,		cServices,				true);

}

HRESULT CTVEFilterStatsProperties::OnDeactivate(void)
{
	return S_OK;
}


HRESULT CTVEFilterStatsProperties::OnApplyChanges(void)
{
	return S_OK;
}


INT_PTR CTVEFilterStatsProperties::OnReceiveMessage( HWND hwnd
                                , UINT uMsg
                                , WPARAM wParam
                                , LPARAM lParam)
{
    switch (uMsg) {
    case WM_INITDIALOG:
    {
        ASSERT (m_hwnd == NULL) ;
        m_hwnd = hwnd ;
        const UINT uWait = 1000;
        SetTimer(m_Dlg, 1, uWait, NULL);
        break;
    }

    //  see ::OnDeactivate()'s comment block
    case WM_DESTROY :
    {
        m_hwnd = NULL;
        KillTimer(m_Dlg, 1);
        break ;
    }

    case WM_TIMER:
    {
        UpdateFields();
        break;
    }

    case WM_COMMAND:
	{
        if (HIWORD(wParam) == EN_KILLFOCUS) {
		}

		if(LOWORD(wParam) == IDC_TVESTATS_RESET)
		{
			DBG_HEADER(CDebugLog::DBG_FLT, _T("CTVEFilterStatsProperties::OnReceiveMessage"));

			if(!m_pITVEFilter)
				break;

			IUnknownPtr spSuperPunk;
			HRESULT hr;
			hr = m_pITVEFilter->get_SupervisorPunk(&spSuperPunk);

			if(FAILED(hr)) 
				break;

			if(NULL == spSuperPunk)
				break;

			ITVESupervisorPtr spSuper(spSuperPunk);
			if(NULL == spSuper)
				break;

			try {
				hr = spSuper->InitStats();		// set them all to zero...
			}
			catch(const _com_error& e)
			{
			//	printf("Error 0x%08x): %s\n", e.Error(), e.ErrorMessage());
				hr = e.Error();
			}

	//		if(!FAILED(hr))
	//			UpdateFields();
		}
		break;
	}

	default:
		break;

	}
	return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvefiltprops.h ===
// ---------------------------------------------------------------
// TveFiltProps.h
//
// ---------------------------------------------------------------


#ifndef __TVEFILTPROPS_H__
#define __TVEFILTPROPS_H__

// ----------------------------------
//  forward declarations
// ----------------------------------

class CTVEFilterTuneProperties;
class CTVEFilterCCProperties;
class CTVEFilterStatsProperties;

// ----------------------------------
// ----------------------------------

class CTVEFilterTuneProperties : 
	public CBasePropertyPage 
{
 
public:
   CTVEFilterTuneProperties(IN  TCHAR		*pClassName,
							  IN  IUnknown	*lpUnk, 
							  OUT HRESULT	*phr);
	~CTVEFilterTuneProperties();


    HRESULT
    OnActivate (
        ) ;

    HRESULT
    OnApplyChanges (
        ) ;

    HRESULT
    OnConnect (
        IN  IUnknown *  pIUnknown
        ) ;

    HRESULT
    OnDeactivate (
        ) ;

    HRESULT
    OnDisconnect (
        ) ;

    INT_PTR
    OnReceiveMessage (
        IN  HWND    hwnd,
        IN  UINT    uMsg,
        IN  WPARAM  wParam,
        IN  LPARAM  lParam
            ) ;

	DECLARE_IUNKNOWN ;

    static
    CUnknown *
    WINAPI
    CreateInstance (
        IN  IUnknown *  pIUnknown,
        IN  HRESULT *   pHr
        ) ;

private:
   void UpdateFields();
   void UpdateMulticastList(BOOL fConnectToIPSink);

   ITVEFilter		*m_pITVEFilter;
   HWND				m_hwnd ;

};
	

				// ----------------------------


class CTVEFilterCCProperties : 
	public CBasePropertyPage 
{
 
public:
   CTVEFilterCCProperties(IN  TCHAR		*pClassName,
							IN  IUnknown	*lpUnk, 
							OUT HRESULT		*phr);
	~CTVEFilterCCProperties();


    HRESULT
    OnActivate (
        ) ;

    HRESULT
    OnApplyChanges (
        ) ;

    HRESULT
    OnConnect (
        IN  IUnknown *  pIUnknown
        ) ;

    HRESULT
    OnDeactivate (
        ) ;

    HRESULT
    OnDisconnect (
        ) ;

    INT_PTR
    OnReceiveMessage (
        IN  HWND    hwnd,
        IN  UINT    uMsg,
        IN  WPARAM  wParam,
        IN  LPARAM  lParam
            ) ;

	DECLARE_IUNKNOWN ;

    static
    CUnknown *
    WINAPI
    CreateInstance (
        IN  IUnknown *  pIUnknown,
        IN  HRESULT *   pHr
        ) ;

private:
   void UpdateFields();

   ITVEFilter		*m_pITVEFilter;
   HWND				m_hwnd ;
};
	
				// ---------------------------


class CTVEFilterStatsProperties : 
	public CBasePropertyPage 
{
 
public:
   CTVEFilterStatsProperties(IN  TCHAR		*pClassName,
							IN  IUnknown	*lpUnk, 
							OUT HRESULT		*phr);
	~CTVEFilterStatsProperties();


    HRESULT
    OnActivate (
        ) ;

    HRESULT
    OnApplyChanges (
        ) ;

    HRESULT
    OnConnect (
        IN  IUnknown *  pIUnknown
        ) ;

    HRESULT
    OnDeactivate (
        ) ;

    HRESULT
    OnDisconnect (
        ) ;

    INT_PTR
    OnReceiveMessage (
        IN  HWND    hwnd,
        IN  UINT    uMsg,
        IN  WPARAM  wParam,
        IN  LPARAM  lParam
            ) ;

	DECLARE_IUNKNOWN ;

    static
    CUnknown *
    WINAPI
    CreateInstance (
        IN  IUnknown *  pIUnknown,
        IN  HRESULT *   pHr
        ) ;

private:
   void UpdateFields();

   ITVEFilter		*m_pITVEFilter;
   HWND				m_hwnd ;

};

#endif //__TVEFILTPROPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvel21dec.h ===
//--------------------------------------------------------
// TveL21Dec.h
// -------------------------------------------------------

const int kMaxLen = 256;		// max length of buffer

//
//  A set of values indicating what type of control code was received
//
#define L21_CONTROLCODE_NOTCONTROL  0
#define L21_CONTROLCODE_PAC         1
#define L21_CONTROLCODE_MIDROW      2
#define L21_CONTROLCODE_MISCCONTROL 3
#define L21_CONTROLCODE_SPECIAL		4
#define L21_CONTROLCODE_TR_OR_RTD	5

class L21Buff
{
public:
	L21Buff();

	void ClearBuff()		
	{
		m_szBuff[0] = 0;				// null terminate string
		m_cChars = 0;					// zero length
		m_iBracketCount = 0;			// no brackets to worry about
		m_fInsideOfTrigger = false;		// not inside a trigger 
		m_fInsideOfURL     = false;		// not inside the URL <>
		m_fInsideOfTrigger = false;		
		m_fHadBracket	   = false;
		m_fHadURL          = false;
		m_fMayBeAtEndOfTrigger = false;	// haven't found any ']' yet.
	}

	HRESULT ParseCCBytePair(DWORD dwMode, char cb1, char cb2, bool *pfDoneWithLine);
	HRESULT GetBuff(BSTR *pBstrBuff);		// returns copy of current working buffer
	HRESULT GetBuffTrig(BSTR *pBstrBuff);	// returns copy of last fully parsed trigger

private:

	BOOL IsTRorRTD(BYTE chFirst, BYTE chSecond);
	BOOL IsPAC(BYTE chFirst, BYTE chSecond);
	BOOL IsMiscControlCode(BYTE chFirst, BYTE chSecond);
	BOOL IsMidRowCode(BYTE chFirst, BYTE chSecond);
	BOOL IsSpecialChar(BYTE chFirst, BYTE chSecond);
	UINT CheckControlCode(BYTE chFirst, BYTE chSecond);

	BOOL	ValidParity(BYTE ch);

	BOOL	AddChar(char c);			// add in a new character, return false on invalid parity
	BOOL	ParseForTrigger();			// look for start/end of trigger, if find it, stuff it and return true

	
	char	m_szBuff[kMaxLen];
	int		m_cChars;
	char	m_szBuffTrig[kMaxLen];		// fully parsed trigger string

	int 	m_iBracketCount;			// square bracket count for tiggers (0 count means possible end)
	bool	m_fInsideOfURL;				// true if inside a trigger (false if at end)
	bool	m_fInsideOfTrigger;			// true if inside a trigger (false if at end)

	bool	m_fMayBeAtEndOfTrigger;		// true when hit a trailing ']' and waiting to find next '['
	bool	m_fHadBracket;				// true if inside of trigger and saw any ']'
	bool	m_fHadURL;					// true if inside of trigger and saw any '>'


	bool	m_bExpectRepeat;

	bool	m_fCCDecoderBugs