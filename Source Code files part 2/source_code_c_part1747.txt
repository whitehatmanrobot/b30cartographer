-1, -1},
/*02823*/     {1213, -1, -1},
/*02824*/     {2832, 12, 1},
/*02825*/     {0, -1, -1},
/*02826*/     {2834, 12, 1},
/*02827*/     {2836, 12, 1},
/*02828*/     {0, -1, -1},
/*02829*/     {2838, 12, 1},
/*02830*/     {2840, 12, 1},
/*02831*/     {2842, 12, 1},
/*02832*/     {1134, -1, -1},
/*02833*/     {1135, -1, -1},
/*02834*/     {1150, -1, -1},
/*02835*/     {1151, -1, -1},
/*02836*/     {1166, -1, -1},
/*02837*/     {1167, -1, -1},
/*02838*/     {1182, -1, -1},
/*02839*/     {1183, -1, -1},
/*02840*/     {1198, -1, -1},
/*02841*/     {1199, -1, -1},
/*02842*/     {1214, -1, -1},
/*02843*/     {1215, -1, -1},
/*02844*/     {2852, 12, 2},
/*02845*/     {2864, 12, 2},
/*02846*/     {2876, 13, 1},
/*02847*/     {2878, 26, 1},
/*02848*/     {0, -1, -1},
/*02849*/     {0, -1, -1},
/*02850*/     {167, -1, -1},
/*02851*/     {172, -1, -1},
/*02852*/     {2856, 36, 1},
/*02853*/     {2858, 36, 1},
/*02854*/     {2860, 36, 1},
/*02855*/     {2862, 36, 1},
/*02856*/     {174, -1, -1},
/*02857*/     {176, -1, -1},
/*02858*/     {175, -1, -1},
/*02859*/     {177, -1, -1},
/*02860*/     {182, -1, -1},
/*02861*/     {184, -1, -1},
/*02862*/     {183, -1, -1},
/*02863*/     {185, -1, -1},
/*02864*/     {2868, 36, 1},
/*02865*/     {2870, 36, 1},
/*02866*/     {2872, 36, 1},
/*02867*/     {2874, 36, 1},
/*02868*/     {178, -1, -1},
/*02869*/     {180, -1, -1},
/*02870*/     {179, -1, -1},
/*02871*/     {181, -1, -1},
/*02872*/     {186, -1, -1},
/*02873*/     {188, -1, -1},
/*02874*/     {187, -1, -1},
/*02875*/     {189, -1, -1},
/*02876*/     {168, -1, -1},
/*02877*/     {169, -1, -1},
/*02878*/     {170, -1, -1},
/*02879*/     {171, -1, -1},
/*02880*/     {445, -1, -1},
/*02881*/     {446, -1, -1},
/*02882*/     {445, -1, -1},
/*02883*/     {447, -1, -1},
/*02884*/     {448, -1, -1},
/*02885*/     {449, -1, -1},
/*02886*/     {448, -1, -1},
/*02887*/     {450, -1, -1},
/*02888*/     {451, -1, -1},
/*02889*/     {452, -1, -1},
/*02890*/     {451, -1, -1},
/*02891*/     {453, -1, -1},
/*02892*/     {454, -1, -1},
/*02893*/     {455, -1, -1},
/*02894*/     {454, -1, -1},
/*02895*/     {456, -1, -1},
/*02896*/     {457, -1, -1},
/*02897*/     {458, -1, -1},
/*02898*/     {457, -1, -1},
/*02899*/     {459, -1, -1},
/*02900*/     {460, -1, -1},
/*02901*/     {461, -1, -1},
/*02902*/     {460, -1, -1},
/*02903*/     {462, -1, -1},
/*02904*/     {463, -1, -1},
/*02905*/     {464, -1, -1},
/*02906*/     {463, -1, -1},
/*02907*/     {465, -1, -1},
/*02908*/     {466, -1, -1},
/*02909*/     {467, -1, -1},
/*02910*/     {466, -1, -1},
/*02911*/     {468, -1, -1},
/*02912*/     {469, -1, -1},
/*02913*/     {470, -1, -1},
/*02914*/     {469, -1, -1},
/*02915*/     {471, -1, -1},
/*02916*/     {472, -1, -1},
/*02917*/     {473, -1, -1},
/*02918*/     {472, -1, -1},
/*02919*/     {474, -1, -1},
/*02920*/     {475, -1, -1},
/*02921*/     {476, -1, -1},
/*02922*/     {475, -1, -1},
/*02923*/     {477, -1, -1},
/*02924*/     {478, -1, -1},
/*02925*/     {479, -1, -1},
/*02926*/     {478, -1, -1},
/*02927*/     {480, -1, -1},
/*02928*/     {481, -1, -1},
/*02929*/     {482, -1, -1},
/*02930*/     {481, -1, -1},
/*02931*/     {483, -1, -1},
/*02932*/     {484, -1, -1},
/*02933*/     {485, -1, -1},
/*02934*/     {484, -1, -1},
/*02935*/     {486, -1, -1},
/*02936*/     {487, -1, -1},
/*02937*/     {488, -1, -1},
/*02938*/     {487, -1, -1},
/*02939*/     {489, -1, -1},
/*02940*/     {490, -1, -1},
/*02941*/     {491, -1, -1},
/*02942*/     {490, -1, -1},
/*02943*/     {492, -1, -1},
/*02944*/     {493, -1, -1},
/*02945*/     {494, -1, -1},
/*02946*/     {493, -1, -1},
/*02947*/     {495, -1, -1},
/*02948*/     {496, -1, -1},
/*02949*/     {497, -1, -1},
/*02950*/     {496, -1, -1},
/*02951*/     {498, -1, -1},
/*02952*/     {499, -1, -1},
/*02953*/     {500, -1, -1},
/*02954*/     {499, -1, -1},
/*02955*/     {501, -1, -1},
/*02956*/     {502, -1, -1},
/*02957*/     {503, -1, -1},
/*02958*/     {502, -1, -1},
/*02959*/     {504, -1, -1},
/*02960*/     {505, -1, -1},
/*02961*/     {506, -1, -1},
/*02962*/     {505, -1, -1},
/*02963*/     {507, -1, -1},
/*02964*/     {508, -1, -1},
/*02965*/     {509, -1, -1},
/*02966*/     {508, -1, -1},
/*02967*/     {510, -1, -1},
/*02968*/     {511, -1, -1},
/*02969*/     {512, -1, -1},
/*02970*/     {511, -1, -1},
/*02971*/     {513, -1, -1},
/*02972*/     {514, -1, -1},
/*02973*/     {515, -1, -1},
/*02974*/     {514, -1, -1},
/*02975*/     {516, -1, -1},
/*02976*/     {0, -1, -1},
/*02977*/     {0, -1, -1},
/*02978*/     {0, -1, -1},
/*02979*/     {0, -1, -1},
/*02980*/     {0, -1, -1},
/*02981*/     {0, -1, -1},
/*02982*/     {0, -1, -1},
/*02983*/     {0, -1, -1},
/*02984*/     {0, -1, -1},
/*02985*/     {0, -1, -1},
/*02986*/     {0, -1, -1},
/*02987*/     {0, -1, -1},
/*02988*/     {517, -1, -1},
/*02989*/     {518, -1, -1},
/*02990*/     {517, -1, -1},
/*02991*/     {519, -1, -1},
/*02992*/     {0, -1, -1},
/*02993*/     {0, -1, -1},
/*02994*/     {0, -1, -1},
/*02995*/     {0, -1, -1},
/*02996*/     {0, -1, -1},
/*02997*/     {0, -1, -1},
/*02998*/     {0, -1, -1},
/*02999*/     {0, -1, -1},
/*03000*/     {0, -1, -1},
/*03001*/     {0, -1, -1},
/*03002*/     {0, -1, -1},
/*03003*/     {0, -1, -1},
/*03004*/     {0, -1, -1},
/*03005*/     {0, -1, -1},
/*03006*/     {0, -1, -1},
/*03007*/     {0, -1, -1},
/*03008*/     {520, -1, -1},
/*03009*/     {521, -1, -1},
/*03010*/     {520, -1, -1},
/*03011*/     {522, -1, -1},
/*03012*/     {523, -1, -1},
/*03013*/     {524, -1, -1},
/*03014*/     {523, -1, -1},
/*03015*/     {525, -1, -1},
/*03016*/     {526, -1, -1},
/*03017*/     {527, -1, -1},
/*03018*/     {526, -1, -1},
/*03019*/     {528, -1, -1},
/*03020*/     {529, -1, -1},
/*03021*/     {530, -1, -1},
/*03022*/     {529, -1, -1},
/*03023*/     {531, -1, -1},
/*03024*/     {532, -1, -1},
/*03025*/     {533, -1, -1},
/*03026*/     {532, -1, -1},
/*03027*/     {534, -1, -1},
/*03028*/     {535, -1, -1},
/*03029*/     {536, -1, -1},
/*03030*/     {535, -1, -1},
/*03031*/     {537, -1, -1},
/*03032*/     {538, -1, -1},
/*03033*/     {539, -1, -1},
/*03034*/     {538, -1, -1},
/*03035*/     {540, -1, -1},
/*03036*/     {541, -1, -1},
/*03037*/     {542, -1, -1},
/*03038*/     {541, -1, -1},
/*03039*/     {543, -1, -1},
/*03040*/     {544, -1, -1},
/*03041*/     {545, -1, -1},
/*03042*/     {544, -1, -1},
/*03043*/     {546, -1, -1},
/*03044*/     {547, -1, -1},
/*03045*/     {548, -1, -1},
/*03046*/     {547, -1, -1},
/*03047*/     {549, -1, -1},
/*03048*/     {550, -1, -1},
/*03049*/     {551, -1, -1},
/*03050*/     {550, -1, -1},
/*03051*/     {552, -1, -1},
/*03052*/     {553, -1, -1},
/*03053*/     {554, -1, -1},
/*03054*/     {553, -1, -1},
/*03055*/     {555, -1, -1},
/*03056*/     {0, -1, -1},
/*03057*/     {0, -1, -1},
/*03058*/     {0, -1, -1},
/*03059*/     {0, -1, -1},
/*03060*/     {0, -1, -1},
/*03061*/     {0, -1, -1},
/*03062*/     {0, -1, -1},
/*03063*/     {0, -1, -1},
/*03064*/     {0, -1, -1},
/*03065*/     {0, -1, -1},
/*03066*/     {0, -1, -1},
/*03067*/     {0, -1, -1},
/*03068*/     {0, -1, -1},
/*03069*/     {0, -1, -1},
/*03070*/     {0, -1, -1},
/*03071*/     {0, -1, -1},
/*03072*/     {574, -1, -1},
/*03073*/     {574, -1, -1},
/*03074*/     {574, -1, -1},
/*03075*/     {575, -1, -1},
/*03076*/     {576, -1, -1},
/*03077*/     {576, -1, -1},
/*03078*/     {576, -1, -1},
/*03079*/     {577, -1, -1},
/*03080*/     {578, -1, -1},
/*03081*/     {578, -1, -1},
/*03082*/     {578, -1, -1},
/*03083*/     {579, -1, -1},
/*03084*/     {580, -1, -1},
/*03085*/     {580, -1, -1},
/*03086*/     {580, -1, -1},
/*03087*/     {581, -1, -1},
/*03088*/     {582, -1, -1},
/*03089*/     {582, -1, -1},
/*03090*/     {582, -1, -1},
/*03091*/     {583, -1, -1},
/*03092*/     {584, -1, -1},
/*03093*/     {584, -1, -1},
/*03094*/     {584, -1, -1},
/*03095*/     {585, -1, -1},
/*03096*/     {586, -1, -1},
/*03097*/     {586, -1, -1},
/*03098*/     {586, -1, -1},
/*03099*/     {587, -1, -1},
/*03100*/     {588, -1, -1},
/*03101*/     {588, -1, -1},
/*03102*/     {588, -1, -1},
/*03103*/     {589, -1, -1},
/*03104*/     {0, -1, -1},
/*03105*/     {0, -1, -1},
/*03106*/     {0, -1, -1},
/*03107*/     {0, -1, -1},
/*03108*/     {0, -1, -1},
/*03109*/     {0, -1, -1},
/*03110*/     {0, -1, -1},
/*03111*/     {0, -1, -1},
/*03112*/     {0, -1, -1},
/*03113*/     {0, -1, -1},
/*03114*/     {0, -1, -1},
/*03115*/     {0, -1, -1},
/*03116*/     {590, -1, -1},
/*03117*/     {590, -1, -1},
/*03118*/     {590, -1, -1},
/*03119*/     {591, -1, -1},
/*03120*/     {0, -1, -1},
/*03121*/     {0, -1, -1},
/*03122*/     {0, -1, -1},
/*03123*/     {0, -1, -1},
/*03124*/     {0, -1, -1},
/*03125*/     {0, -1, -1},
/*03126*/     {0, -1, -1},
/*03127*/     {0, -1, -1},
/*03128*/     {0, -1, -1},
/*03129*/     {0, -1, -1},
/*03130*/     {0, -1, -1},
/*03131*/     {0, -1, -1},
/*03132*/     {0, -1, -1},
/*03133*/     {0, -1, -1},
/*03134*/     {0, -1, -1},
/*03135*/     {0, -1, -1},
/*03136*/     {1406, -1, -1},
/*03137*/     {1407, -1, -1},
/*03138*/     {3146, 12, 1},
/*03139*/     {3148, 12, 1},
/*03140*/     {3150, 12, 1},
/*03141*/     {3152, 12, 1},
/*03142*/     {3154, 12, 1},
/*03143*/     {3156, 12, 1},
/*03144*/     {3158, 12, 1},
/*03145*/     {3160, 12, 1},
/*03146*/     {1216, -1, -1},
/*03147*/     {1217, -1, -1},
/*03148*/     {1218, -1, -1},
/*03149*/     {1219, -1, -1},
/*03150*/     {1220, -1, -1},
/*03151*/     {1221, -1, -1},
/*03152*/     {1222, -1, -1},
/*03153*/     {1223, -1, -1},
/*03154*/     {1224, -1, -1},
/*03155*/     {1225, -1, -1},
/*03156*/     {1226, -1, -1},
/*03157*/     {1227, -1, -1},
/*03158*/     {1228, -1, -1},
/*03159*/     {1229, -1, -1},
/*03160*/     {1230, -1, -1},
/*03161*/     {1231, -1, -1},
/*03162*/     {3290, 27, 3},
/*03163*/     {3298, 27, 3},
/*03164*/     {3306, 27, 3},
/*03165*/     {3314, 27, 3},
/*03166*/     {3322, 27, 3},
/*03167*/     {3330, 27, 3},
/*03168*/     {3338, 27, 3},
/*03169*/     {3346, 27, 3},
/*03170*/     {3354, 27, 3},
/*03171*/     {3362, 27, 3},
/*03172*/     {3370, 27, 3},
/*03173*/     {3378, 27, 3},
/*03174*/     {3386, 27, 3},
/*03175*/     {3394, 27, 3},
/*03176*/     {3402, 27, 3},
/*03177*/     {3410, 27, 3},
/*03178*/     {0, -1, -1},
/*03179*/     {0, -1, -1},
/*03180*/     {0, -1, -1},
/*03181*/     {0, -1, -1},
/*03182*/     {0, -1, -1},
/*03183*/     {0, -1, -1},
/*03184*/     {0, -1, -1},
/*03185*/     {0, -1, -1},
/*03186*/     {0, -1, -1},
/*03187*/     {0, -1, -1},
/*03188*/     {0, -1, -1},
/*03189*/     {3418, 27, 3},
/*03190*/     {3426, 27, 1},
/*03191*/     {3428, 27, 1},
/*03192*/     {3430, 27, 1},
/*03193*/     {3432, 27, 1},
/*03194*/     {3434, 27, 3},
/*03195*/     {3442, 27, 3},
/*03196*/     {3450, 27, 3},
/*03197*/     {3458, 27, 3},
/*03198*/     {3466, 27, 3},
/*03199*/     {3474, 27, 3},
/*03200*/     {3482, 27, 3},
/*03201*/     {3490, 27, 3},
/*03202*/     {0, -1, -1},
/*03203*/     {0, -1, -1},
/*03204*/     {0, -1, -1},
/*03205*/     {0, -1, -1},
/*03206*/     {3498, 27, 3},
/*03207*/     {3506, 27, 3},
/*03208*/     {3514, 27, 3},
/*03209*/     {3522, 27, 3},
/*03210*/     {3530, 27, 3},
/*03211*/     {3538, 27, 3},
/*03212*/     {3546, 27, 3},
/*03213*/     {3554, 27, 3},
/*03214*/     {0, -1, -1},
/*03215*/     {0, -1, -1},
/*03216*/     {0, -1, -1},
/*03217*/     {0, -1, -1},
/*03218*/     {0, -1, -1},
/*03219*/     {0, -1, -1},
/*03220*/     {0, -1, -1},
/*03221*/     {3562, 27, 3},
/*03222*/     {0, -1, -1},
/*03223*/     {0, -1, -1},
/*03224*/     {0, -1, -1},
/*03225*/     {0, -1, -1},
/*03226*/     {3570, 27, 3},
/*03227*/     {3578, 27, 3},
/*03228*/     {3586, 27, 3},
/*03229*/     {3594, 27, 3},
/*03230*/     {3602, 27, 3},
/*03231*/     {3610, 27, 3},
/*03232*/     {3618, 27, 3},
/*03233*/     {3626, 27, 3},
/*03234*/     {3634, 27, 3},
/*03235*/     {3642, 27, 3},
/*03236*/     {3650, 27, 3},
/*03237*/     {3658, 27, 3},
/*03238*/     {3666, 27, 3},
/*03239*/     {3674, 27, 3},
/*03240*/     {3682, 27, 3},
/*03241*/     {3690, 27, 3},
/*03242*/     {0, -1, -1},
/*03243*/     {0, -1, -1},
/*03244*/     {0, -1, -1},
/*03245*/     {0, -1, -1},
/*03246*/     {0, -1, -1},
/*03247*/     {0, -1, -1},
/*03248*/     {0, -1, -1},
/*03249*/     {0, -1, -1},
/*03250*/     {0, -1, -1},
/*03251*/     {0, -1, -1},
/*03252*/     {0, -1, -1},
/*03253*/     {3698, 27, 3},
/*03254*/     {0, -1, -1},
/*03255*/     {0, -1, -1},
/*03256*/     {0, -1, -1},
/*03257*/     {0, -1, -1},
/*03258*/     {3706, 27, 3},
/*03259*/     {3714, 27, 3},
/*03260*/     {3722, 27, 3},
/*03261*/     {3730, 27, 3},
/*03262*/     {3738, 27, 3},
/*03263*/     {3746, 27, 3},
/*03264*/     {3754, 27, 3},
/*03265*/     {3762, 27, 3},
/*03266*/     {0, -1, -1},
/*03267*/     {0, -1, -1},
/*03268*/     {0, -1, -1},
/*03269*/     {0, -1, -1},
/*03270*/     {3770, 27, 3},
/*03271*/     {3778, 27, 3},
/*03272*/     {3786, 27, 3},
/*03273*/     {3794, 27, 3},
/*03274*/     {0, -1, -1},
/*03275*/     {0, -1, -1},
/*03276*/     {0, -1, -1},
/*03277*/     {0, -1, -1},
/*03278*/     {0, -1, -1},
/*03279*/     {0, -1, -1},
/*03280*/     {0, -1, -1},
/*03281*/     {0, -1, -1},
/*03282*/     {0, -1, -1},
/*03283*/     {0, -1, -1},
/*03284*/     {0, -1, -1},
/*03285*/     {0, -1, -1},
/*03286*/     {0, -1, -1},
/*03287*/     {0, -1, -1},
/*03288*/     {0, -1, -1},
/*03289*/     {0, -1, -1},
/*03290*/     {601, -1, -1},
/*03291*/     {0, -1, -1},
/*03292*/     {602, -1, -1},
/*03293*/     {0, -1, -1},
/*03294*/     {601, -1, -1},
/*03295*/     {0, -1, -1},
/*03296*/     {603, -1, -1},
/*03297*/     {0, -1, -1},
/*03298*/     {598, -1, -1},
/*03299*/     {843, -1, -1},
/*03300*/     {599, -1, -1},
/*03301*/     {844, -1, -1},
/*03302*/     {598, -1, -1},
/*03303*/     {843, -1, -1},
/*03304*/     {600, -1, -1},
/*03305*/     {845, -1, -1},
/*03306*/     {592, -1, -1},
/*03307*/     {837, -1, -1},
/*03308*/     {593, -1, -1},
/*03309*/     {838, -1, -1},
/*03310*/     {592, -1, -1},
/*03311*/     {837, -1, -1},
/*03312*/     {594, -1, -1},
/*03313*/     {839, -1, -1},
/*03314*/     {595, -1, -1},
/*03315*/     {840, -1, -1},
/*03316*/     {596, -1, -1},
/*03317*/     {841, -1, -1},
/*03318*/     {595, -1, -1},
/*03319*/     {840, -1, -1},
/*03320*/     {597, -1, -1},
/*03321*/     {842, -1, -1},
/*03322*/     {613, -1, -1},
/*03323*/     {0, -1, -1},
/*03324*/     {614, -1, -1},
/*03325*/     {0, -1, -1},
/*03326*/     {613, -1, -1},
/*03327*/     {0, -1, -1},
/*03328*/     {615, -1, -1},
/*03329*/     {0, -1, -1},
/*03330*/     {610, -1, -1},
/*03331*/     {852, -1, -1},
/*03332*/     {611, -1, -1},
/*03333*/     {853, -1, -1},
/*03334*/     {610, -1, -1},
/*03335*/     {852, -1, -1},
/*03336*/     {612, -1, -1},
/*03337*/     {854, -1, -1},
/*03338*/     {604, -1, -1},
/*03339*/     {846, -1, -1},
/*03340*/     {605, -1, -1},
/*03341*/     {847, -1, -1},
/*03342*/     {604, -1, -1},
/*03343*/     {846, -1, -1},
/*03344*/     {606, -1, -1},
/*03345*/     {848, -1, -1},
/*03346*/     {607, -1, -1},
/*03347*/     {849, -1, -1},
/*03348*/     {608, -1, -1},
/*03349*/     {850, -1, -1},
/*03350*/     {607, -1, -1},
/*03351*/     {849, -1, -1},
/*03352*/     {609, -1, -1},
/*03353*/     {851, -1, -1},
/*03354*/     {625, -1, -1},
/*03355*/     {0, -1, -1},
/*03356*/     {626, -1, -1},
/*03357*/     {0, -1, -1},
/*03358*/     {625, -1, -1},
/*03359*/     {0, -1, -1},
/*03360*/     {627, -1, -1},
/*03361*/     {0, -1, -1},
/*03362*/     {622, -1, -1},
/*03363*/     {861, -1, -1},
/*03364*/     {623, -1, -1},
/*03365*/     {862, -1, -1},
/*03366*/     {622, -1, -1},
/*03367*/     {861, -1, -1},
/*03368*/     {624, -1, -1},
/*03369*/     {863, -1, -1},
/*03370*/     {616, -1, -1},
/*03371*/     {855, -1, -1},
/*03372*/     {617, -1, -1},
/*03373*/     {856, -1, -1},
/*03374*/     {616, -1, -1},
/*03375*/     {855, -1, -1},
/*03376*/     {618, -1, -1},
/*03377*/     {857, -1, -1},
/*03378*/     {619, -1, -1},
/*03379*/     {858, -1, -1},
/*03380*/     {620, -1, -1},
/*03381*/     {859, -1, -1},
/*03382*/     {619, -1, -1},
/*03383*/     {858, -1, -1},
/*03384*/     {621, -1, -1},
/*03385*/     {860, -1, -1},
/*03386*/     {637, -1, -1},
/*03387*/     {0, -1, -1},
/*03388*/     {638, -1, -1},
/*03389*/     {0, -1, -1},
/*03390*/     {637, -1, -1},
/*03391*/     {0, -1, -1},
/*03392*/     {639, -1, -1},
/*03393*/     {0, -1, -1},
/*03394*/     {634, -1, -1},
/*03395*/     {870, -1, -1},
/*03396*/     {635, -1, -1},
/*03397*/     {871, -1, -1},
/*03398*/     {634, -1, -1},
/*03399*/     {870, -1, -1},
/*03400*/     {636, -1, -1},
/*03401*/     {872, -1, -1},
/*03402*/     {628, -1, -1},
/*03403*/     {864, -1, -1},
/*03404*/     {629, -1, -1},
/*03405*/     {865, -1, -1},
/*03406*/     {628, -1, -1},
/*03407*/     {864, -1, -1},
/*03408*/     {630, -1, -1},
/*03409*/     {866, -1, -1},
/*03410*/     {631, -1, -1},
/*03411*/     {867, -1, -1},
/*03412*/     {632, -1, -1},
/*03413*/     {868, -1, -1},
/*03414*/     {631, -1, -1},
/*03415*/     {867, -1, -1},
/*03416*/     {633, -1, -1},
/*03417*/     {869, -1, -1},
/*03418*/     {640, -1, -1},
/*03419*/     {0, -1, -1},
/*03420*/     {641, -1, -1},
/*03421*/     {0, -1, -1},
/*03422*/     {640, -1, -1},
/*03423*/     {0, -1, -1},
/*03424*/     {642, -1, -1},
/*03425*/     {0, -1, -1},
/*03426*/     {0, -1, -1},
/*03427*/     {1041, -1, -1},
/*03428*/     {0, -1, -1},
/*03429*/     {1042, -1, -1},
/*03430*/     {0, -1, -1},
/*03431*/     {1043, -1, -1},
/*03432*/     {0, -1, -1},
/*03433*/     {1044, -1, -1},
/*03434*/     {652, -1, -1},
/*03435*/     {0, -1, -1},
/*03436*/     {653, -1, -1},
/*03437*/     {0, -1, -1},
/*03438*/     {652, -1, -1},
/*03439*/     {0, -1, -1},
/*03440*/     {654, -1, -1},
/*03441*/     {0, -1, -1},
/*03442*/     {649, -1, -1},
/*03443*/     {879, -1, -1},
/*03444*/     {650, -1, -1},
/*03445*/     {880, -1, -1},
/*03446*/     {649, -1, -1},
/*03447*/     {879, -1, -1},
/*03448*/     {651, -1, -1},
/*03449*/     {881, -1, -1},
/*03450*/     {643, -1, -1},
/*03451*/     {873, -1, -1},
/*03452*/     {644, -1, -1},
/*03453*/     {874, -1, -1},
/*03454*/     {643, -1, -1},
/*03455*/     {873, -1, -1},
/*03456*/     {645, -1, -1},
/*03457*/     {875, -1, -1},
/*03458*/     {646, -1, -1},
/*03459*/     {876, -1, -1},
/*03460*/     {647, -1, -1},
/*03461*/     {877, -1, -1},
/*03462*/     {646, -1, -1},
/*03463*/     {876, -1, -1},
/*03464*/     {648, -1, -1},
/*03465*/     {878, -1, -1},
/*03466*/     {664, -1, -1},
/*03467*/     {0, -1, -1},
/*03468*/     {665, -1, -1},
/*03469*/     {0, -1, -1},
/*03470*/     {664, -1, -1},
/*03471*/     {0, -1, -1},
/*03472*/     {666, -1, -1},
/*03473*/     {0, -1, -1},
/*03474*/     {661, -1, -1},
/*03475*/     {888, -1, -1},
/*03476*/     {662, -1, -1},
/*03477*/     {889, -1, -1},
/*03478*/     {661, -1, -1},
/*03479*/     {888, -1, -1},
/*03480*/     {663, -1, -1},
/*03481*/     {890, -1, -1},
/*03482*/     {655, -1, -1},
/*03483*/     {882, -1, -1},
/*03484*/     {656, -1, -1},
/*03485*/     {883, -1, -1},
/*03486*/     {655, -1, -1},
/*03487*/     {882, -1, -1},
/*03488*/     {657, -1, -1},
/*03489*/     {884, -1, -1},
/*03490*/     {658, -1, -1},
/*03491*/     {885, -1, -1},
/*03492*/     {659, -1, -1},
/*03493*/     {886, -1, -1},
/*03494*/     {658, -1, -1},
/*03495*/     {885, -1, -1},
/*03496*/     {660, -1, -1},
/*03497*/     {887, -1, -1},
/*03498*/     {945, -1, -1},
/*03499*/     {0, -1, -1},
/*03500*/     {946, -1, -1},
/*03501*/     {0, -1, -1},
/*03502*/     {947, -1, -1},
/*03503*/     {0, -1, -1},
/*03504*/     {948, -1, -1},
/*03505*/     {0, -1, -1},
/*03506*/     {949, -1, -1},
/*03507*/     {0, -1, -1},
/*03508*/     {950, -1, -1},
/*03509*/     {0, -1, -1},
/*03510*/     {951, -1, -1},
/*03511*/     {0, -1, -1},
/*03512*/     {952, -1, -1},
/*03513*/     {0, -1, -1},
/*03514*/     {953, -1, -1},
/*03515*/     {0, -1, -1},
/*03516*/     {954, -1, -1},
/*03517*/     {0, -1, -1},
/*03518*/     {955, -1, -1},
/*03519*/     {0, -1, -1},
/*03520*/     {956, -1, -1},
/*03521*/     {0, -1, -1},
/*03522*/     {957, -1, -1},
/*03523*/     {0, -1, -1},
/*03524*/     {958, -1, -1},
/*03525*/     {0, -1, -1},
/*03526*/     {959, -1, -1},
/*03527*/     {0, -1, -1},
/*03528*/     {960, -1, -1},
/*03529*/     {0, -1, -1},
/*03530*/     {823, -1, -1},
/*03531*/     {0, -1, -1},
/*03532*/     {823, -1, -1},
/*03533*/     {0, -1, -1},
/*03534*/     {823, -1, -1},
/*03535*/     {0, -1, -1},
/*03536*/     {824, -1, -1},
/*03537*/     {0, -1, -1},
/*03538*/     {821, -1, -1},
/*03539*/     {0, -1, -1},
/*03540*/     {821, -1, -1},
/*03541*/     {0, -1, -1},
/*03542*/     {821, -1, -1},
/*03543*/     {0, -1, -1},
/*03544*/     {822, -1, -1},
/*03545*/     {0, -1, -1},
/*03546*/     {817, -1, -1},
/*03547*/     {0, -1, -1},
/*03548*/     {817, -1, -1},
/*03549*/     {0, -1, -1},
/*03550*/     {817, -1, -1},
/*03551*/     {0, -1, -1},
/*03552*/     {818, -1, -1},
/*03553*/     {0, -1, -1},
/*03554*/     {819, -1, -1},
/*03555*/     {0, -1, -1},
/*03556*/     {819, -1, -1},
/*03557*/     {0, -1, -1},
/*03558*/     {819, -1, -1},
/*03559*/     {0, -1, -1},
/*03560*/     {820, -1, -1},
/*03561*/     {0, -1, -1},
/*03562*/     {825, -1, -1},
/*03563*/     {0, -1, -1},
/*03564*/     {825, -1, -1},
/*03565*/     {0, -1, -1},
/*03566*/     {825, -1, -1},
/*03567*/     {0, -1, -1},
/*03568*/     {826, -1, -1},
/*03569*/     {0, -1, -1},
/*03570*/     {676, -1, -1},
/*03571*/     {0, -1, -1},
/*03572*/     {677, -1, -1},
/*03573*/     {0, -1, -1},
/*03574*/     {676, -1, -1},
/*03575*/     {0, -1, -1},
/*03576*/     {678, -1, -1},
/*03577*/     {0, -1, -1},
/*03578*/     {673, -1, -1},
/*03579*/     {897, -1, -1},
/*03580*/     {674, -1, -1},
/*03581*/     {898, -1, -1},
/*03582*/     {673, -1, -1},
/*03583*/     {897, -1, -1},
/*03584*/     {675, -1, -1},
/*03585*/     {899, -1, -1},
/*03586*/     {667, -1, -1},
/*03587*/     {891, -1, -1},
/*03588*/     {668, -1, -1},
/*03589*/     {892, -1, -1},
/*03590*/     {667, -1, -1},
/*03591*/     {891, -1, -1},
/*03592*/     {669, -1, -1},
/*03593*/     {893, -1, -1},
/*03594*/     {670, -1, -1},
/*03595*/     {894, -1, -1},
/*03596*/     {671, -1, -1},
/*03597*/     {895, -1, -1},
/*03598*/     {670, -1, -1},
/*03599*/     {894, -1, -1},
/*03600*/     {672, -1, -1},
/*03601*/     {896, -1, -1},
/*03602*/     {688, -1, -1},
/*03603*/     {0, -1, -1},
/*03604*/     {689, -1, -1},
/*03605*/     {0, -1, -1},
/*03606*/     {688, -1, -1},
/*03607*/     {0, -1, -1},
/*03608*/     {690, -1, -1},
/*03609*/     {0, -1, -1},
/*03610*/     {685, -1, -1},
/*03611*/     {906, -1, -1},
/*03612*/     {686, -1, -1},
/*03613*/     {907, -1, -1},
/*03614*/     {685, -1, -1},
/*03615*/     {906, -1, -1},
/*03616*/     {687, -1, -1},
/*03617*/     {908, -1, -1},
/*03618*/     {679, -1, -1},
/*03619*/     {900, -1, -1},
/*03620*/     {680, -1, -1},
/*03621*/     {901, -1, -1},
/*03622*/     {679, -1, -1},
/*03623*/     {900, -1, -1},
/*03624*/     {681, -1, -1},
/*03625*/     {902, -1, -1},
/*03626*/     {682, -1, -1},
/*03627*/     {903, -1, -1},
/*03628*/     {683, -1, -1},
/*03629*/     {904, -1, -1},
/*03630*/     {682, -1, -1},
/*03631*/     {903, -1, -1},
/*03632*/     {684, -1, -1},
/*03633*/     {905, -1, -1},
/*03634*/     {700, -1, -1},
/*03635*/     {0, -1, -1},
/*03636*/     {701, -1, -1},
/*03637*/     {0, -1, -1},
/*03638*/     {700, -1, -1},
/*03639*/     {0, -1, -1},
/*03640*/     {702, -1, -1},
/*03641*/     {0, -1, -1},
/*03642*/     {697, -1, -1},
/*03643*/     {915, -1, -1},
/*03644*/     {698, -1, -1},
/*03645*/     {916, -1, -1},
/*03646*/     {697, -1, -1},
/*03647*/     {915, -1, -1},
/*03648*/     {699, -1, -1},
/*03649*/     {917, -1, -1},
/*03650*/     {691, -1, -1},
/*03651*/     {909, -1, -1},
/*03652*/     {692, -1, -1},
/*03653*/     {910, -1, -1},
/*03654*/     {691, -1, -1},
/*03655*/     {909, -1, -1},
/*03656*/     {693, -1, -1},
/*03657*/     {911, -1, -1},
/*03658*/     {694, -1, -1},
/*03659*/     {912, -1, -1},
/*03660*/     {695, -1, -1},
/*03661*/     {913, -1, -1},
/*03662*/     {694, -1, -1},
/*03663*/     {912, -1, -1},
/*03664*/     {696, -1, -1},
/*03665*/     {914, -1, -1},
/*03666*/     {712, -1, -1},
/*03667*/     {0, -1, -1},
/*03668*/     {713, -1, -1},
/*03669*/     {0, -1, -1},
/*03670*/     {712, -1, -1},
/*03671*/     {0, -1, -1},
/*03672*/     {714, -1, -1},
/*03673*/     {0, -1, -1},
/*03674*/     {709, -1, -1},
/*03675*/     {924, -1, -1},
/*03676*/     {710, -1, -1},
/*03677*/     {925, -1, -1},
/*03678*/     {709, -1, -1},
/*03679*/     {924, -1, -1},
/*03680*/     {711, -1, -1},
/*03681*/     {926, -1, -1},
/*03682*/     {703, -1, -1},
/*03683*/     {918, -1, -1},
/*03684*/     {704, -1, -1},
/*03685*/     {919, -1, -1},
/*03686*/     {703, -1, -1},
/*03687*/     {918, -1, -1},
/*03688*/     {705, -1, -1},
/*03689*/     {920, -1, -1},
/*03690*/     {706, -1, -1},
/*03691*/     {921, -1, -1},
/*03692*/     {707, -1, -1},
/*03693*/     {922, -1, -1},
/*03694*/     {706, -1, -1},
/*03695*/     {921, -1, -1},
/*03696*/     {708, -1, -1},
/*03697*/     {923, -1, -1},
/*03698*/     {715, -1, -1},
/*03699*/     {0, -1, -1},
/*03700*/     {716, -1, -1},
/*03701*/     {0, -1, -1},
/*03702*/     {715, -1, -1},
/*03703*/     {0, -1, -1},
/*03704*/     {717, -1, -1},
/*03705*/     {0, -1, -1},
/*03706*/     {727, -1, -1},
/*03707*/     {0, -1, -1},
/*03708*/     {728, -1, -1},
/*03709*/     {0, -1, -1},
/*03710*/     {727, -1, -1},
/*03711*/     {0, -1, -1},
/*03712*/     {729, -1, -1},
/*03713*/     {0, -1, -1},
/*03714*/     {724, -1, -1},
/*03715*/     {933, -1, -1},
/*03716*/     {725, -1, -1},
/*03717*/     {934, -1, -1},
/*03718*/     {724, -1, -1},
/*03719*/     {933, -1, -1},
/*03720*/     {726, -1, -1},
/*03721*/     {935, -1, -1},
/*03722*/     {718, -1, -1},
/*03723*/     {927, -1, -1},
/*03724*/     {719, -1, -1},
/*03725*/     {928, -1, -1},
/*03726*/     {718, -1, -1},
/*03727*/     {927, -1, -1},
/*03728*/     {720, -1, -1},
/*03729*/     {929, -1, -1},
/*03730*/     {721, -1, -1},
/*03731*/     {930, -1, -1},
/*03732*/     {722, -1, -1},
/*03733*/     {931, -1, -1},
/*03734*/     {721, -1, -1},
/*03735*/     {930, -1, -1},
/*03736*/     {723, -1, -1},
/*03737*/     {932, -1, -1},
/*03738*/     {739, -1, -1},
/*03739*/     {0, -1, -1},
/*03740*/     {740, -1, -1},
/*03741*/     {0, -1, -1},
/*03742*/     {739, -1, -1},
/*03743*/     {0, -1, -1},
/*03744*/     {741, -1, -1},
/*03745*/     {0, -1, -1},
/*03746*/     {736, -1, -1},
/*03747*/     {942, -1, -1},
/*03748*/     {737, -1, -1},
/*03749*/     {943, -1, -1},
/*03750*/     {736, -1, -1},
/*03751*/     {942, -1, -1},
/*03752*/     {738, -1, -1},
/*03753*/     {944, -1, -1},
/*03754*/     {730, -1, -1},
/*03755*/     {936, -1, -1},
/*03756*/     {731, -1, -1},
/*03757*/     {937, -1, -1},
/*03758*/     {730, -1, -1},
/*03759*/     {936, -1, -1},
/*03760*/     {732, -1, -1},
/*03761*/     {938, -1, -1},
/*03762*/     {733, -1, -1},
/*03763*/     {939, -1, -1},
/*03764*/     {734, -1, -1},
/*03765*/     {940, -1, -1},
/*03766*/     {733, -1, -1},
/*03767*/     {939, -1, -1},
/*03768*/     {735, -1, -1},
/*03769*/     {941, -1, -1},
/*03770*/     {961, -1, -1},
/*03771*/     {0, -1, -1},
/*03772*/     {962, -1, -1},
/*03773*/     {0, -1, -1},
/*03774*/     {963, -1, -1},
/*03775*/     {0, -1, -1},
/*03776*/     {964, -1, -1},
/*03777*/     {0, -1, -1},
/*03778*/     {965, -1, -1},
/*03779*/     {0, -1, -1},
/*03780*/     {966, -1, -1},
/*03781*/     {0, -1, -1},
/*03782*/     {967, -1, -1},
/*03783*/     {0, -1, -1},
/*03784*/     {968, -1, -1},
/*03785*/     {0, -1, -1},
/*03786*/     {969, -1, -1},
/*03787*/     {0, -1, -1},
/*03788*/     {970, -1, -1},
/*03789*/     {0, -1, -1},
/*03790*/     {971, -1, -1},
/*03791*/     {0, -1, -1},
/*03792*/     {972, -1, -1},
/*03793*/     {0, -1, -1},
/*03794*/     {973, -1, -1},
/*03795*/     {0, -1, -1},
/*03796*/     {974, -1, -1},
/*03797*/     {0, -1, -1},
/*03798*/     {975, -1, -1},
/*03799*/     {0, -1, -1},
/*03800*/     {976, -1, -1},
/*03801*/     {0, -1, -1},
/*03802*/     {1556, -1, -1},
/*03803*/     {0, -1, -1},
/*03804*/     {0, -1, -1},
/*03805*/     {0, -1, -1},
/*03806*/     {3836, 28, 2},
/*03807*/     {0, -1, -1},
/*03808*/     {0, -1, -1},
/*03809*/     {0, -1, -1},
/*03810*/     {3848, 28, 4},
/*03811*/     {0, -1, -1},
/*03812*/     {3864, 28, 4},
/*03813*/     {0, -1, -1},
/*03814*/     {3880, 28, 4},
/*03815*/     {0, -1, -1},
/*03816*/     {3896, 28, 4},
/*03817*/     {0, -1, -1},
/*03818*/     {3912, 28, 4},
/*03819*/     {0, -1, -1},
/*03820*/     {3928, 28, 4},
/*03821*/     {0, -1, -1},
/*03822*/     {3944, 28, 4},
/*03823*/     {0, -1, -1},
/*03824*/     {3960, 28, 4},
/*03825*/     {0, -1, -1},
/*03826*/     {0, -1, -1},
/*03827*/     {0, -1, -1},
/*03828*/     {3976, 28, 4},
/*03829*/     {0, -1, -1},
/*03830*/     {0, -1, -1},
/*03831*/     {0, -1, -1},
/*03832*/     {3992, 28, 4},
/*03833*/     {0, -1, -1},
/*03834*/     {0, -1, -1},
/*03835*/     {0, -1, -1},
/*03836*/     {3840, 30, 2},
/*03837*/     {126, -1, -1},
/*03838*/     {3844, 30, 2},
/*03839*/     {125, -1, -1},
/*03840*/     {154, -1, -1},
/*03841*/     {161, -1, -1},
/*03842*/     {0, -1, -1},
/*03843*/     {0, -1, -1},
/*03844*/     {151, -1, -1},
/*03845*/     {0, -1, -1},
/*03846*/     {0, -1, -1},
/*03847*/     {0, -1, -1},
/*03848*/     {0, -1, -1},
/*03849*/     {159, -1, -1},
/*03850*/     {0, -1, -1},
/*03851*/     {157, -1, -1},
/*03852*/     {0, -1, -1},
/*03853*/     {0, -1, -1},
/*03854*/     {0, -1, -1},
/*03855*/     {0, -1, -1},
/*03856*/     {0, -1, -1},
/*03857*/     {166, -1, -1},
/*03858*/     {0, -1, -1},
/*03859*/     {0, -1, -1},
/*03860*/     {0, -1, -1},
/*03861*/     {0, -1, -1},
/*03862*/     {0, -1, -1},
/*03863*/     {0, -1, -1},
/*03864*/     {0, -1, -1},
/*03865*/     {144, -1, -1},
/*03866*/     {0, -1, -1},
/*03867*/     {0, -1, -1},
/*03868*/     {138, -1, -1},
/*03869*/     {145, -1, -1},
/*03870*/     {141, -1, -1},
/*03871*/     {0, -1, -1},
/*03872*/     {129, -1, -1},
/*03873*/     {0, -1, -1},
/*03874*/     {132, -1, -1},
/*03875*/     {148, -1, -1},
/*03876*/     {0, -1, -1},
/*03877*/     {0, -1, -1},
/*03878*/     {0, -1, -1},
/*03879*/     {0, -1, -1},
/*03880*/     {135, -1, -1},
/*03881*/     {0, -1, -1},
/*03882*/     {136, -1, -1},
/*03883*/     {146, -1, -1},
/*03884*/     {139, -1, -1},
/*03885*/     {0, -1, -1},
/*03886*/     {142, -1, -1},
/*03887*/     {147, -1, -1},
/*03888*/     {130, -1, -1},
/*03889*/     {0, -1, -1},
/*03890*/     {133, -1, -1},
/*03891*/     {0, -1, -1},
/*03892*/     {0, -1, -1},
/*03893*/     {127, -1, -1},
/*03894*/     {0, -1, -1},
/*03895*/     {128, -1, -1},
/*03896*/     {0, -1, -1},
/*03897*/     {0, -1, -1},
/*03898*/     {0, -1, -1},
/*03899*/     {0, -1, -1},
/*03900*/     {0, -1, -1},
/*03901*/     {0, -1, -1},
/*03902*/     {0, -1, -1},
/*03903*/     {0, -1, -1},
/*03904*/     {0, -1, -1},
/*03905*/     {0, -1, -1},
/*03906*/     {149, -1, -1},
/*03907*/     {0, -1, -1},
/*03908*/     {0, -1, -1},
/*03909*/     {0, -1, -1},
/*03910*/     {0, -1, -1},
/*03911*/     {0, -1, -1},
/*03912*/     {0, -1, -1},
/*03913*/     {0, -1, -1},
/*03914*/     {0, -1, -1},
/*03915*/     {0, -1, -1},
/*03916*/     {0, -1, -1},
/*03917*/     {164, -1, -1},
/*03918*/     {0, -1, -1},
/*03919*/     {0, -1, -1},
/*03920*/     {0, -1, -1},
/*03921*/     {0, -1, -1},
/*03922*/     {150, -1, -1},
/*03923*/     {0, -1, -1},
/*03924*/     {0, -1, -1},
/*03925*/     {0, -1, -1},
/*03926*/     {0, -1, -1},
/*03927*/     {0, -1, -1},
/*03928*/     {155, -1, -1},
/*03929*/     {0, -1, -1},
/*03930*/     {152, -1, -1},
/*03931*/     {0, -1, -1},
/*03932*/     {162, -1, -1},
/*03933*/     {0, -1, -1},
/*03934*/     {0, -1, -1},
/*03935*/     {0, -1, -1},
/*03936*/     {0, -1, -1},
/*03937*/     {0, -1, -1},
/*03938*/     {0, -1, -1},
/*03939*/     {0, -1, -1},
/*03940*/     {0, -1, -1},
/*03941*/     {0, -1, -1},
/*03942*/     {0, -1, -1},
/*03943*/     {0, -1, -1},
/*03944*/     {156, -1, -1},
/*03945*/     {0, -1, -1},
/*03946*/     {153, -1, -1},
/*03947*/     {0, -1, -1},
/*03948*/     {163, -1, -1},
/*03949*/     {0, -1, -1},
/*03950*/     {0, -1, -1},
/*03951*/     {0, -1, -1},
/*03952*/     {0, -1, -1},
/*03953*/     {0, -1, -1},
/*03954*/     {0, -1, -1},
/*03955*/     {0, -1, -1},
/*03956*/     {0, -1, -1},
/*03957*/     {0, -1, -1},
/*03958*/     {0, -1, -1},
/*03959*/     {0, -1, -1},
/*03960*/     {0, -1, -1},
/*03961*/     {160, -1, -1},
/*03962*/     {0, -1, -1},
/*03963*/     {158, -1, -1},
/*03964*/     {0, -1, -1},
/*03965*/     {0, -1, -1},
/*03966*/     {0, -1, -1},
/*03967*/     {0, -1, -1},
/*03968*/     {0, -1, -1},
/*03969*/     {0, -1, -1},
/*03970*/     {0, -1, -1},
/*03971*/     {0, -1, -1},
/*03972*/     {0, -1, -1},
/*03973*/     {0, -1, -1},
/*03974*/     {0, -1, -1},
/*03975*/     {0, -1, -1},
/*03976*/     {0, -1, -1},
/*03977*/     {0, -1, -1},
/*03978*/     {137, -1, -1},
/*03979*/     {0, -1, -1},
/*03980*/     {140, -1, -1},
/*03981*/     {0, -1, -1},
/*03982*/     {143, -1, -1},
/*03983*/     {0, -1, -1},
/*03984*/     {131, -1, -1},
/*03985*/     {0, -1, -1},
/*03986*/     {134, -1, -1},
/*03987*/     {0, -1, -1},
/*03988*/     {0, -1, -1},
/*03989*/     {0, -1, -1},
/*03990*/     {0, -1, -1},
/*03991*/     {0, -1, -1},
/*03992*/     {0, -1, -1},
/*03993*/     {0, -1, -1},
/*03994*/     {0, -1, -1},
/*03995*/     {0, -1, -1},
/*03996*/     {0, -1, -1},
/*03997*/     {165, -1, -1},
/*03998*/     {0, -1, -1},
/*03999*/     {0, -1, -1},
/*04000*/     {0, -1, -1},
/*04001*/     {0, -1, -1},
/*04002*/     {0, -1, -1},
/*04003*/     {0, -1, -1},
/*04004*/     {0, -1, -1},
/*04005*/     {0, -1, -1},
/*04006*/     {0, -1, -1},
/*04007*/     {0, -1, -1},
/*04008*/     {751, -1, -1},
/*04009*/     {752, -1, -1},
/*04010*/     {751, -1, -1},
/*04011*/     {753, -1, -1},
/*04012*/     {748, -1, -1},
/*04013*/     {749, -1, -1},
/*04014*/     {748, -1, -1},
/*04015*/     {750, -1, -1},
/*04016*/     {742, -1, -1},
/*04017*/     {743, -1, -1},
/*04018*/     {742, -1, -1},
/*04019*/     {744, -1, -1},
/*04020*/     {745, -1, -1},
/*04021*/     {746, -1, -1},
/*04022*/     {745, -1, -1},
/*04023*/     {747, -1, -1},
/*04024*/     {763, -1, -1},
/*04025*/     {764, -1, -1},
/*04026*/     {763, -1, -1},
/*04027*/     {765, -1, -1},
/*04028*/     {760, -1, -1},
/*04029*/     {761, -1, -1},
/*04030*/     {760, -1, -1},
/*04031*/     {762, -1, -1},
/*04032*/     {754, -1, -1},
/*04033*/     {755, -1, -1},
/*04034*/     {754, -1, -1},
/*04035*/     {756, -1, -1},
/*04036*/     {757, -1, -1},
/*04037*/     {758, -1, -1},
/*04038*/     {757, -1, -1},
/*04039*/     {759, -1, -1},
/*04040*/     {775, -1, -1},
/*04041*/     {776, -1, -1},
/*04042*/     {775, -1, -1},
/*04043*/     {777, -1, -1},
/*04044*/     {772, -1, -1},
/*04045*/     {773, -1, -1},
/*04046*/     {772, -1, -1},
/*04047*/     {774, -1, -1},
/*04048*/     {766, -1, -1},
/*04049*/     {767, -1, -1},
/*04050*/     {766, -1, -1},
/*04051*/     {768, -1, -1},
/*04052*/     {769, -1, -1},
/*04053*/     {770, -1, -1},
/*04054*/     {769, -1, -1},
/*04055*/     {771, -1, -1},
/*04056*/     {787, -1, -1},
/*04057*/     {788, -1, -1},
/*04058*/     {787, -1, -1},
/*04059*/     {789, -1, -1},
/*04060*/     {784, -1, -1},
/*04061*/     {785, -1, -1},
/*04062*/     {784, -1, -1},
/*04063*/     {786, -1, -1},
/*04064*/     {778, -1, -1},
/*04065*/     {779, -1, -1},
/*04066*/     {778, -1, -1},
/*04067*/     {780, -1, -1},
/*04068*/     {781, -1, -1},
/*04069*/     {782, -1, -1},
/*04070*/     {781, -1, -1},
/*04071*/     {783, -1, -1},
/*04072*/     {0, -1, -1},
/*04073*/     {0, -1, -1},
/*04074*/     {0, -1, -1},
/*04075*/     {0, -1, -1},
/*04076*/     {0, -1, -1},
/*04077*/     {0, -1, -1},
/*04078*/     {0, -1, -1},
/*04079*/     {0, -1, -1},
/*04080*/     {0, -1, -1},
/*04081*/     {0, -1, -1},
/*04082*/     {0, -1, -1},
/*04083*/     {0, -1, -1},
/*04084*/     {0, -1, -1},
/*04085*/     {0, -1, -1},
/*04086*/     {0, -1, -1},
/*04087*/     {0, -1, -1},
/*04088*/     {0, -1, -1},
/*04089*/     {0, -1, -1},
/*04090*/     {0, -1, -1},
/*04091*/     {0, -1, -1},
/*04092*/     {0, -1, -1},
/*04093*/     {0, -1, -1},
/*04094*/     {0, -1, -1},
/*04095*/     {0, -1, -1},
/*04096*/     {0, -1, -1},
/*04097*/     {0, -1, -1},
/*04098*/     {0, -1, -1},
/*04099*/     {0, -1, -1},
/*04100*/     {0, -1, -1},
/*04101*/     {0, -1, -1},
/*04102*/     {0, -1, -1},
/*04103*/     {0, -1, -1},
/*04104*/     {0, -1, -1},
/*04105*/     {0, -1, -1},
/*04106*/     {0, -1, -1},
/*04107*/     {0, -1, -1},
/*04108*/     {0, -1, -1},
/*04109*/     {0, -1, -1},
/*04110*/     {0, -1, -1},
/*04111*/     {0, -1, -1},
/*04112*/     {0, -1, -1},
/*04113*/     {0, -1, -1},
/*04114*/     {0, -1, -1},
/*04115*/     {0, -1, -1},
/*04116*/     {790, -1, -1},
/*04117*/     {791, -1, -1},
/*04118*/     {790, -1, -1},
/*04119*/     {792, -1, -1},
/*04120*/     {0, -1, -1},
/*04121*/     {0, -1, -1},
/*04122*/     {0, -1, -1},
/*04123*/     {0, -1, -1},
/*04124*/     {0, -1, -1},
/*04125*/     {0, -1, -1},
/*04126*/     {0, -1, -1},
/*04127*/     {0, -1, -1},
/*04128*/     {0, -1, -1},
/*04129*/     {0, -1, -1},
/*04130*/     {0, -1, -1},
/*04131*/     {0, -1, -1},
/*04132*/     {0, -1, -1},
/*04133*/     {0, -1, -1},
/*04134*/     {0, -1, -1},
/*04135*/     {0, -1, -1},
/*04136*/     {802, -1, -1},
/*04137*/     {803, -1, -1},
/*04138*/     {802, -1, -1},
/*04139*/     {804, -1, -1},
/*04140*/     {799, -1, -1},
/*04141*/     {800, -1, -1},
/*04142*/     {799, -1, -1},
/*04143*/     {801, -1, -1},
/*04144*/     {793, -1, -1},
/*04145*/     {794, -1, -1},
/*04146*/     {793, -1, -1},
/*04147*/     {795, -1, -1},
/*04148*/     {796, -1, -1},
/*04149*/     {797, -1, -1},
/*04150*/     {796, -1, -1},
/*04151*/     {798, -1, -1},
/*04152*/     {814, -1, -1},
/*04153*/     {815, -1, -1},
/*04154*/     {814, -1, -1},
/*04155*/     {816, -1, -1},
/*04156*/     {811, -1, -1},
/*04157*/     {812, -1, -1},
/*04158*/     {811, -1, -1},
/*04159*/     {813, -1, -1},
/*04160*/     {805, -1, -1},
/*04161*/     {806, -1, -1},
/*04162*/     {805, -1, -1},
/*04163*/     {807, -1, -1},
/*04164*/     {808, -1, -1},
/*04165*/     {809, -1, -1},
/*04166*/     {808, -1, -1},
/*04167*/     {810, -1, -1},
/*04168*/     {0, -1, -1},
/*04169*/     {0, -1, -1},
/*04170*/     {0, -1, -1},
/*04171*/     {0, -1, -1},
/*04172*/     {0, -1, -1},
/*04173*/     {0, -1, -1},
/*04174*/     {0, -1, -1},
/*04175*/     {0, -1, -1},
/*04176*/     {0, -1, -1},
/*04177*/     {0, -1, -1},
/*04178*/     {0, -1, -1},
/*04179*/     {0, -1, -1},
/*04180*/     {0, -1, -1},
/*04181*/     {0, -1, -1},
/*04182*/     {0, -1, -1},
/*04183*/     {0, -1, -1},
/*04184*/     {977, -1, -1},
/*04185*/     {978, -1, -1},
/*04186*/     {979, -1, -1},
/*04187*/     {980, -1, -1},
/*04188*/     {981, -1, -1},
/*04189*/     {982, -1, -1},
/*04190*/     {983, -1, -1},
/*04191*/     {984, -1, -1},
/*04192*/     {985, -1, -1},
/*04193*/     {986, -1, -1},
/*04194*/     {987, -1, -1},
/*04195*/     {988, -1, -1},
/*04196*/     {989, -1, -1},
/*04197*/     {990, -1, -1},
/*04198*/     {991, -1, -1},
/*04199*/     {992, -1, -1},
/*04200*/     {833, -1, -1},
/*04201*/     {833, -1, -1},
/*04202*/     {833, -1, -1},
/*04203*/     {834, -1, -1},
/*04204*/     {831, -1, -1},
/*04205*/     {831, -1, -1},
/*04206*/     {831, -1, -1},
/*04207*/     {832, -1, -1},
/*04208*/     {827, -1, -1},
/*04209*/     {827, -1, -1},
/*04210*/     {827, -1, -1},
/*04211*/     {828, -1, -1},
/*04212*/     {829, -1, -1},
/*04213*/     {829, -1, -1},
/*04214*/     {829, -1, -1},
/*04215*/     {830, -1, -1},
/*04216*/     {0, -1, -1},
/*04217*/     {0, -1, -1},
/*04218*/     {0, -1, -1},
/*04219*/     {0, -1, -1},
/*04220*/     {0, -1, -1},
/*04221*/     {0, -1, -1},
/*04222*/     {0, -1, -1},
/*04223*/     {0, -1, -1},
/*04224*/     {0, -1, -1},
/*04225*/     {0, -1, -1},
/*04226*/     {0, -1, -1},
/*04227*/     {0, -1, -1},
/*04228*/     {0, -1, -1},
/*04229*/     {0, -1, -1},
/*04230*/     {0, -1, -1},
/*04231*/     {0, -1, -1},
/*04232*/     {0, -1, -1},
/*04233*/     {0, -1, -1},
/*04234*/     {0, -1, -1},
/*04235*/     {0, -1, -1},
/*04236*/     {0, -1, -1},
/*04237*/     {0, -1, -1},
/*04238*/     {0, -1, -1},
/*04239*/     {0, -1, -1},
/*04240*/     {0, -1, -1},
/*04241*/     {0, -1, -1},
/*04242*/     {0, -1, -1},
/*04243*/     {0, -1, -1},
/*04244*/     {835, -1, -1},
/*04245*/     {835, -1, -1},
/*04246*/     {835, -1, -1},
/*04247*/     {836, -1, -1},
/*04248*/     {0, -1, -1},
/*04249*/     {0, -1, -1},
/*04250*/     {0, -1, -1},
/*04251*/     {0, -1, -1},
/*04252*/     {0, -1, -1},
/*04253*/     {0, -1, -1},
/*04254*/     {0, -1, -1},
/*04255*/     {0, -1, -1},
/*04256*/     {0, -1, -1},
/*04257*/     {0, -1, -1},
/*04258*/     {0, -1, -1},
/*04259*/     {0, -1, -1},
/*04260*/     {0, -1, -1},
/*04261*/     {0, -1, -1},
/*04262*/     {0, -1, -1},
/*04263*/     {0, -1, -1},
/*04264*/     {4328, 35, 1},
/*04265*/     {0, -1, -1},
/*04266*/     {0, -1, -1},
/*04267*/     {0, -1, -1},
/*04268*/     {0, -1, -1},
/*04269*/     {0, -1, -1},
/*04270*/     {0, -1, -1},
/*04271*/     {0, -1, -1},
/*04272*/     {4330, 35, 1},
/*04273*/     {0, -1, -1},
/*04274*/     {0, -1, -1},
/*04275*/     {0, -1, -1},
/*04276*/     {0, -1, -1},
/*04277*/     {0, -1, -1},
/*04278*/     {0, -1, -1},
/*04279*/     {0, -1, -1},
/*04280*/     {4332, 35, 1},
/*04281*/     {0, -1, -1},
/*04282*/     {0, -1, -1},
/*04283*/     {0, -1, -1},
/*04284*/     {0, -1, -1},
/*04285*/     {0, -1, -1},
/*04286*/     {0, -1, -1},
/*04287*/     {0, -1, -1},
/*04288*/     {4334, 35, 1},
/*04289*/     {0, -1, -1},
/*04290*/     {0, -1, -1},
/*04291*/     {0, -1, -1},
/*04292*/     {0, -1, -1},
/*04293*/     {0, -1, -1},
/*04294*/     {0, -1, -1},
/*04295*/     {0, -1, -1},
/*04296*/     {0, -1, -1},
/*04297*/     {0, -1, -1},
/*04298*/     {0, -1, -1},
/*04299*/     {0, -1, -1},
/*04300*/     {0, -1, -1},
/*04301*/     {0, -1, -1},
/*04302*/     {0, -1, -1},
/*04303*/     {0, -1, -1},
/*04304*/     {0, -1, -1},
/*04305*/     {0, -1, -1},
/*04306*/     {0, -1, -1},
/*04307*/     {0, -1, -1},
/*04308*/     {0, -1, -1},
/*04309*/     {0, -1, -1},
/*04310*/     {0, -1, -1},
/*04311*/     {0, -1, -1},
/*04312*/     {0, -1, -1},
/*04313*/     {0, -1, -1},
/*04314*/     {0, -1, -1},
/*04315*/     {0, -1, -1},
/*04316*/     {0, -1, -1},
/*04317*/     {0, -1, -1},
/*04318*/     {0, -1, -1},
/*04319*/     {0, -1, -1},
/*04320*/     {0, -1, -1},
/*04321*/     {0, -1, -1},
/*04322*/     {0, -1, -1},
/*04323*/     {0, -1, -1},
/*04324*/     {0, -1, -1},
/*04325*/     {0, -1, -1},
/*04326*/     {0, -1, -1},
/*04327*/     {0, -1, -1},
/*04328*/     {1296, -1, -1},
/*04329*/     {1297, -1, -1},
/*04330*/     {1298, -1, -1},
/*04331*/     {1299, -1, -1},
/*04332*/     {1300, -1, -1},
/*04333*/     {1301, -1, -1},
/*04334*/     {1302, -1, -1},
/*04335*/     {1303, -1, -1},
/*04336*/     {4344, 29, 4},
/*04337*/     {0, -1, -1},
/*04338*/     {4384, 27, 6},
/*04339*/     {4474, 29, 4},
/*04340*/     {18, -1, -1},
/*04341*/     {0, -1, -1},
/*04342*/     {19, -1, -1},
/*04343*/     {0, -1, -1},
/*04344*/     {4360, 27, 2},
/*04345*/     {4364, 27, 2},
/*04346*/     {4368, 27, 2},
/*04347*/     {4372, 27, 2},
/*04348*/     {11, -1, -1},
/*04349*/     {0, -1, -1},
/*04350*/     {12, -1, -1},
/*04351*/     {0, -1, -1},
/*04352*/     {0, -1, -1},
/*04353*/     {4376, 27, 2},
/*04354*/     {0, -1, -1},
/*04355*/     {4380, 27, 2},
/*04356*/     {0, -1, -1},
/*04357*/     {0, -1, -1},
/*04358*/     {0, -1, -1},
/*04359*/     {0, -1, -1},
/*04360*/     {2, -1, -1},
/*04361*/     {3, -1, -1},
/*04362*/     {0, -1, -1},
/*04363*/     {0, -1, -1},
/*04364*/     {5, -1, -1},
/*04365*/     {4, -1, -1},
/*04366*/     {0, -1, -1},
/*04367*/     {0, -1, -1},
/*04368*/     {6, -1, -1},
/*04369*/     {0, -1, -1},
/*04370*/     {0, -1, -1},
/*04371*/     {0, -1, -1},
/*04372*/     {7, -1, -1},
/*04373*/     {8, -1, -1},
/*04374*/     {9, -1, -1},
/*04375*/     {10, -1, -1},
/*04376*/     {0, -1, -1},
/*04377*/     {13, -1, -1},
/*04378*/     {0, -1, -1},
/*04379*/     {0, -1, -1},
/*04380*/     {14, -1, -1},
/*04381*/     {15, -1, -1},
/*04382*/     {16, -1, -1},
/*04383*/     {17, -1, -1},
/*04384*/     {4448, 36, 1},
/*04385*/     {4450, 36, 1},
/*04386*/     {4452, 36, 1},
/*04387*/     {4454, 36, 1},
/*04388*/     {4456, 36, 1},
/*04389*/     {4458, 36, 1},
/*04390*/     {4460, 36, 1},
/*04391*/     {4462, 36, 1},
/*04392*/     {0, -1, -1},
/*04393*/     {0, -1, -1},
/*04394*/     {4464, 36, 1},
/*04395*/     {4466, 36, 1},
/*04396*/     {0, -1, -1},
/*04397*/     {0, -1, -1},
/*04398*/     {4468, 36, 1},
/*04399*/     {0, -1, -1},
/*04400*/     {0, -1, -1},
/*04401*/     {0, -1, -1},
/*04402*/     {0, -1, -1},
/*04403*/     {0, -1, -1},
/*04404*/     {0, -1, -1},
/*04405*/     {0, -1, -1},
/*04406*/     {0, -1, -1},
/*04407*/     {0, -1, -1},
/*04408*/     {0, -1, -1},
/*04409*/     {0, -1, -1},
/*04410*/     {0, -1, -1},
/*04411*/     {0, -1, -1},
/*04412*/     {0, -1, -1},
/*04413*/     {0, -1, -1},
/*04414*/     {0, -1, -1},
/*04415*/     {0, -1, -1},
/*04416*/     {0, -1, -1},
/*04417*/     {0, -1, -1},
/*04418*/     {0, -1, -1},
/*04419*/     {0, -1, -1},
/*04420*/     {4470, 36, 1},
/*04421*/     {4472, 36, 1},
/*04422*/     {0, -1, -1},
/*04423*/     {0, -1, -1},
/*04424*/     {0, -1, -1},
/*04425*/     {0, -1, -1},
/*04426*/     {0, -1, -1},
/*04427*/     {0, -1, -1},
/*04428*/     {0, -1, -1},
/*04429*/     {0, -1, -1},
/*04430*/     {0, -1, -1},
/*04431*/     {0, -1, -1},
/*04432*/     {0, -1, -1},
/*04433*/     {0, -1, -1},
/*04434*/     {0, -1, -1},
/*04435*/     {0, -1, -1},
/*04436*/     {0, -1, -1},
/*04437*/     {0, -1, -1},
/*04438*/     {0, -1, -1},
/*04439*/     {0, -1, -1},
/*04440*/     {0, -1, -1},
/*04441*/     {0, -1, -1},
/*04442*/     {0, -1, -1},
/*04443*/     {0, -1, -1},
/*04444*/     {0, -1, -1},
/*04445*/     {0, -1, -1},
/*04446*/     {0, -1, -1},
/*04447*/     {0, -1, -1},
/*04448*/     {93, -1, -1},
/*04449*/     {95, -1, -1},
/*04450*/     {96, -1, -1},
/*04451*/     {0, -1, -1},
/*04452*/     {98, -1, -1},
/*04453*/     {0, -1, -1},
/*04454*/     {100, -1, -1},
/*04455*/     {0, -1, -1},
/*04456*/     {102, -1, -1},
/*04457*/     {104, -1, -1},
/*04458*/     {105, -1, -1},
/*04459*/     {0, -1, -1},
/*04460*/     {107, -1, -1},
/*04461*/     {0, -1, -1},
/*04462*/     {109, -1, -1},
/*04463*/     {0, -1, -1},
/*04464*/     {111, -1, -1},
/*04465*/     {0, -1, -1},
/*04466*/     {113, -1, -1},
/*04467*/     {0, -1, -1},
/*04468*/     {115, -1, -1},
/*04469*/     {0, -1, -1},
/*04470*/     {117, -1, -1},
/*04471*/     {119, -1, -1},
/*04472*/     {120, -1, -1},
/*04473*/     {122, -1, -1},
/*04474*/     {4490, 27, 2},
/*04475*/     {4502, 27, 2},
/*04476*/     {4514, 27, 2},
/*04477*/     {4522, 27, 2},
/*04478*/     {4528, 36, 1},
/*04479*/     {0, -1, -1},
/*04480*/     {4530, 36, 1},
/*04481*/     {0, -1, -1},
/*04482*/     {0, -1, -1},
/*04483*/     {4532, 27, 2},
/*04484*/     {0, -1, -1},
/*04485*/     {0, -1, -1},
/*04486*/     {0, -1, -1},
/*04487*/     {0, -1, -1},
/*04488*/     {0, -1, -1},
/*04489*/     {0, -1, -1},
/*04490*/     {4494, 36, 1},
/*04491*/     {4496, 36, 1},
/*04492*/     {4498, 36, 1},
/*04493*/     {4500, 36, 1},
/*04494*/     {94, -1, -1},
/*04495*/     {0, -1, -1},
/*04496*/     {97, -1, -1},
/*04497*/     {0, -1, -1},
/*04498*/     {99, -1, -1},
/*04499*/     {0, -1, -1},
/*04500*/     {101, -1, -1},
/*04501*/     {0, -1, -1},
/*04502*/     {4506, 36, 1},
/*04503*/     {4508, 36, 1},
/*04504*/     {4510, 36, 1},
/*04505*/     {4512, 36, 1},
/*04506*/     {103, -1, -1},
/*04507*/     {0, -1, -1},
/*04508*/     {106, -1, -1},
/*04509*/     {0, -1, -1},
/*04510*/     {108, -1, -1},
/*04511*/     {0, -1, -1},
/*04512*/     {110, -1, -1},
/*04513*/     {0, -1, -1},
/*04514*/     {0, -1, -1},
/*04515*/     {0, -1, -1},
/*04516*/     {4518, 36, 1},
/*04517*/     {4520, 36, 1},
/*04518*/     {112, -1, -1},
/*04519*/     {0, -1, -1},
/*04520*/     {114, -1, -1},
/*04521*/     {0, -1, -1},
/*04522*/     {0, -1, -1},
/*04523*/     {0, -1, -1},
/*04524*/     {4526, 36, 1},
/*04525*/     {0, -1, -1},
/*04526*/     {116, -1, -1},
/*04527*/     {0, -1, -1},
/*04528*/     {123, -1, -1},
/*04529*/     {0, -1, -1},
/*04530*/     {124, -1, -1},
/*04531*/     {0, -1, -1},
/*04532*/     {4536, 36, 1},
/*04533*/     {4538, 36, 1},
/*04534*/     {0, -1, -1},
/*04535*/     {0, -1, -1},
/*04536*/     {118, -1, -1},
/*04537*/     {0, -1, -1},
/*04538*/     {121, -1, -1},
/*04539*/     {0, -1, -1},
/*04540*/     {4548, 29, 4},
/*04541*/     {0, -1, -1},
/*04542*/     {4588, 27, 6},
/*04543*/     {4678, 29, 4},
/*04544*/     {18, -1, -1},
/*04545*/     {0, -1, -1},
/*04546*/     {19, -1, -1},
/*04547*/     {0, -1, -1},
/*04548*/     {4564, 27, 2},
/*04549*/     {4568, 27, 2},
/*04550*/     {4572, 27, 2},
/*04551*/     {4576, 27, 2},
/*04552*/     {11, -1, -1},
/*04553*/     {0, -1, -1},
/*04554*/     {12, -1, -1},
/*04555*/     {0, -1, -1},
/*04556*/     {0, -1, -1},
/*04557*/     {4580, 27, 2},
/*04558*/     {0, -1, -1},
/*04559*/     {4584, 27, 2},
/*04560*/     {0, -1, -1},
/*04561*/     {0, -1, -1},
/*04562*/     {0, -1, -1},
/*04563*/     {0, -1, -1},
/*04564*/     {2, -1, -1},
/*04565*/     {3, -1, -1},
/*04566*/     {0, -1, -1},
/*04567*/     {0, -1, -1},
/*04568*/     {5, -1, -1},
/*04569*/     {4, -1, -1},
/*04570*/     {0, -1, -1},
/*04571*/     {0, -1, -1},
/*04572*/     {6, -1, -1},
/*04573*/     {0, -1, -1},
/*04574*/     {0, -1, -1},
/*04575*/     {0, -1, -1},
/*04576*/     {7, -1, -1},
/*04577*/     {8, -1, -1},
/*04578*/     {9, -1, -1},
/*04579*/     {10, -1, -1},
/*04580*/     {0, -1, -1},
/*04581*/     {13, -1, -1},
/*04582*/     {0, -1, -1},
/*04583*/     {0, -1, -1},
/*04584*/     {14, -1, -1},
/*04585*/     {15, -1, -1},
/*04586*/     {16, -1, -1},
/*04587*/     {17, -1, -1},
/*04588*/     {4652, 36, 1},
/*04589*/     {4654, 36, 1},
/*04590*/     {4656, 36, 1},
/*04591*/     {4658, 36, 1},
/*04592*/     {4660, 36, 1},
/*04593*/     {4662, 36, 1},
/*04594*/     {4664, 36, 1},
/*04595*/     {4666, 36, 1},
/*04596*/     {0, -1, -1},
/*04597*/     {0, -1, -1},
/*04598*/     {4668, 36, 1},
/*04599*/     {4670, 36, 1},
/*04600*/     {0, -1, -1},
/*04601*/     {0, -1, -1},
/*04602*/     {4672, 36, 1},
/*04603*/     {0, -1, -1},
/*04604*/     {0, -1, -1},
/*04605*/     {0, -1, -1},
/*04606*/     {0, -1, -1},
/*04607*/     {0, -1, -1},
/*04608*/     {0, -1, -1},
/*04609*/     {0, -1, -1},
/*04610*/     {0, -1, -1},
/*04611*/     {0, -1, -1},
/*04612*/     {0, -1, -1},
/*04613*/     {0, -1, -1},
/*04614*/     {0, -1, -1},
/*04615*/     {0, -1, -1},
/*04616*/     {0, -1, -1},
/*04617*/     {0, -1, -1},
/*04618*/     {0, -1, -1},
/*04619*/     {0, -1, -1},
/*04620*/     {0, -1, -1},
/*04621*/     {0, -1, -1},
/*04622*/     {0, -1, -1},
/*04623*/     {0, -1, -1},
/*04624*/     {4674, 36, 1},
/*04625*/     {4676, 36, 1},
/*04626*/     {0, -1, -1},
/*04627*/     {0, -1, -1},
/*04628*/     {0, -1, -1},
/*04629*/     {0, -1, -1},
/*04630*/     {0, -1, -1},
/*04631*/     {0, -1, -1},
/*04632*/     {0, -1, -1},
/*04633*/     {0, -1, -1},
/*04634*/     {0, -1, -1},
/*04635*/     {0, -1, -1},
/*04636*/     {0, -1, -1},
/*04637*/     {0, -1, -1},
/*04638*/     {0, -1, -1},
/*04639*/     {0, -1, -1},
/*04640*/     {0, -1, -1},
/*04641*/     {0, -1, -1},
/*04642*/     {0, -1, -1},
/*04643*/     {0, -1, -1},
/*04644*/     {0, -1, -1},
/*04645*/     {0, -1, -1},
/*04646*/     {0, -1, -1},
/*04647*/     {0, -1, -1},
/*04648*/     {0, -1, -1},
/*04649*/     {0, -1, -1},
/*04650*/     {0, -1, -1},
/*04651*/     {0, -1, -1},
/*04652*/     {93, -1, -1},
/*04653*/     {95, -1, -1},
/*04654*/     {96, -1, -1},
/*04655*/     {0, -1, -1},
/*04656*/     {98, -1, -1},
/*04657*/     {0, -1, -1},
/*04658*/     {100, -1, -1},
/*04659*/     {0, -1, -1},
/*04660*/     {102, -1, -1},
/*04661*/     {104, -1, -1},
/*04662*/     {105, -1, -1},
/*04663*/     {0, -1, -1},
/*04664*/     {107, -1, -1},
/*04665*/     {0, -1, -1},
/*04666*/     {109, -1, -1},
/*04667*/     {0, -1, -1},
/*04668*/     {111, -1, -1},
/*04669*/     {0, -1, -1},
/*04670*/     {113, -1, -1},
/*04671*/     {0, -1, -1},
/*04672*/     {115, -1, -1},
/*04673*/     {0, -1, -1},
/*04674*/     {117, -1, -1},
/*04675*/     {119, -1, -1},
/*04676*/     {120, -1, -1},
/*04677*/     {122, -1, -1},
/*04678*/     {4694, 27, 2},
/*04679*/     {4706, 27, 2},
/*04680*/     {4718, 27, 2},
/*04681*/     {4726, 27, 2},
/*04682*/     {4732, 36, 1},
/*04683*/     {0, -1, -1},
/*04684*/     {4734, 36, 1},
/*04685*/     {0, -1, -1},
/*04686*/     {0, -1, -1},
/*04687*/     {4736, 27, 2},
/*04688*/     {0, -1, -1},
/*04689*/     {0, -1, -1},
/*04690*/     {0, -1, -1},
/*04691*/     {0, -1, -1},
/*04692*/     {0, -1, -1},
/*04693*/     {0, -1, -1},
/*04694*/     {4698, 36, 1},
/*04695*/     {4700, 36, 1},
/*04696*/     {4702, 36, 1},
/*04697*/     {4704, 36, 1},
/*04698*/     {94, -1, -1},
/*04699*/     {0, -1, -1},
/*04700*/     {97, -1, -1},
/*04701*/     {0, -1, -1},
/*04702*/     {99, -1, -1},
/*04703*/     {0, -1, -1},
/*04704*/     {101, -1, -1},
/*04705*/     {0, -1, -1},
/*04706*/     {4710, 36, 1},
/*04707*/     {4712, 36, 1},
/*04708*/     {4714, 36, 1},
/*04709*/     {4716, 36, 1},
/*04710*/     {103, -1, -1},
/*04711*/     {0, -1, -1},
/*04712*/     {106, -1, -1},
/*04713*/     {0, -1, -1},
/*04714*/     {108, -1, -1},
/*04715*/     {0, -1, -1},
/*04716*/     {110, -1, -1},
/*04717*/     {0, -1, -1},
/*04718*/     {0, -1, -1},
/*04719*/     {0, -1, -1},
/*04720*/     {4722, 36, 1},
/*04721*/     {4724, 36, 1},
/*04722*/     {112, -1, -1},
/*04723*/     {0, -1, -1},
/*04724*/     {114, -1, -1},
/*04725*/     {0, -1, -1},
/*04726*/     {0, -1, -1},
/*04727*/     {0, -1, -1},
/*04728*/     {4730, 36, 1},
/*04729*/     {0, -1, -1},
/*04730*/     {116, -1, -1},
/*04731*/     {0, -1, -1},
/*04732*/     {123, -1, -1},
/*04733*/     {0, -1, -1},
/*04734*/     {124, -1, -1},
/*04735*/     {0, -1, -1},
/*04736*/     {4740, 36, 1},
/*04737*/     {4742, 36, 1},
/*04738*/     {0, -1, -1},
/*04739*/     {0, -1, -1},
/*04740*/     {118, -1, -1},
/*04741*/     {0, -1, -1},
/*04742*/     {121, -1, -1},
/*04743*/     {0, -1, -1},
/*04744*/     {1322, -1, -1},
/*04745*/     {1323, -1, -1},
/*04746*/     {1324, -1, -1},
/*04747*/     {1325, -1, -1},
/*04748*/     {1326, -1, -1},
/*04749*/     {1327, -1, -1},
/*04750*/     {1328, -1, -1},
/*04751*/     {1329, -1, -1},
/*04752*/     {1330, -1, -1},
/*04753*/     {1331, -1, -1},
/*04754*/     {1332, -1, -1},
/*04755*/     {1333, -1, -1},
/*04756*/     {1334, -1, -1},
/*04757*/     {1335, -1, -1},
/*04758*/     {1336, -1, -1},
/*04759*/     {1337, -1, -1},
/*04760*/     {1338, -1, -1},
/*04761*/     {1339, -1, -1},
/*04762*/     {1340, -1, -1},
/*04763*/     {1341, -1, -1},
/*04764*/     {1342, -1, -1},
/*04765*/     {1343, -1, -1},
/*04766*/     {1344, -1, -1},
/*04767*/     {1345, -1, -1},
/*04768*/     {1346, -1, -1},
/*04769*/     {1347, -1, -1},
/*04770*/     {1348, -1, -1},
/*04771*/     {1349, -1, -1},
/*04772*/     {1350, -1, -1},
/*04773*/     {1351, -1, -1},
/*04774*/     {1352, -1, -1},
/*04775*/     {1353, -1, -1},
/*04776*/     {4784, 36, 1},
/*04777*/     {4790, 36, 1},
/*04778*/     {4796, 36, 1},
/*04779*/     {4802, 36, 1},
/*04780*/     {4808, 12, 1},
/*04781*/     {4810, 12, 1},
/*04782*/     {4812, 12, 1},
/*04783*/     {4814, 12, 1},
/*04784*/     {4786, 12, 1},
/*04785*/     {4788, 12, 1},
/*04786*/     {21, -1, -1},
/*04787*/     {24, -1, -1},
/*04788*/     {45, -1, -1},
/*04789*/     {48, -1, -1},
/*04790*/     {4792, 12, 1},
/*04791*/     {4794, 12, 1},
/*04792*/     {27, -1, -1},
/*04793*/     {30, -1, -1},
/*04794*/     {51, -1, -1},
/*04795*/     {54, -1, -1},
/*04796*/     {4798, 12, 1},
/*04797*/     {4800, 12, 1},
/*04798*/     {33, -1, -1},
/*04799*/     {36, -1, -1},
/*04800*/     {57, -1, -1},
/*04801*/     {60, -1, -1},
/*04802*/     {4804, 12, 1},
/*04803*/     {4806, 12, 1},
/*04804*/     {39, -1, -1},
/*04805*/     {42, -1, -1},
/*04806*/     {63, -1, -1},
/*04807*/     {66, -1, -1},
/*04808*/     {69, -1, -1},
/*04809*/     {72, -1, -1},
/*04810*/     {75, -1, -1},
/*04811*/     {78, -1, -1},
/*04812*/     {81, -1, -1},
/*04813*/     {84, -1, -1},
/*04814*/     {87, -1, -1},
/*04815*/     {90, -1, -1},
/*04816*/     {4824, 36, 1},
/*04817*/     {4830, 36, 1},
/*04818*/     {4836, 36, 1},
/*04819*/     {4842, 36, 1},
/*04820*/     {4848, 12, 1},
/*04821*/     {4850, 12, 1},
/*04822*/     {4852, 12, 1},
/*04823*/     {4854, 12, 1},
/*04824*/     {4826, 12, 1},
/*04825*/     {4828, 12, 1},
/*04826*/     {21, -1, -1},
/*04827*/     {24, -1, -1},
/*04828*/     {45, -1, -1},
/*04829*/     {48, -1, -1},
/*04830*/     {4832, 12, 1},
/*04831*/     {4834, 12, 1},
/*04832*/     {27, -1, -1},
/*04833*/     {30, -1, -1},
/*04834*/     {51, -1, -1},
/*04835*/     {54, -1, -1},
/*04836*/     {4838, 12, 1},
/*04837*/     {4840, 12, 1},
/*04838*/     {33, -1, -1},
/*04839*/     {36, -1, -1},
/*04840*/     {57, -1, -1},
/*04841*/     {60, -1, -1},
/*04842*/     {4844, 12, 1},
/*04843*/     {4846, 12, 1},
/*04844*/     {39, -1, -1},
/*04845*/     {42, -1, -1},
/*04846*/     {63, -1, -1},
/*04847*/     {66, -1, -1},
/*04848*/     {69, -1, -1},
/*04849*/     {72, -1, -1},
/*04850*/     {75, -1, -1},
/*04851*/     {78, -1, -1},
/*04852*/     {81, -1, -1},
/*04853*/     {84, -1, -1},
/*04854*/     {87, -1, -1},
/*04855*/     {90, -1, -1},
/*04856*/     {1354, -1, -1},
/*04857*/     {1355, -1, -1},
/*04858*/     {1356, -1, -1},
/*04859*/     {1357, -1, -1},
/*04860*/     {1358, -1, -1},
/*04861*/     {1359, -1, -1},
/*04862*/     {1360, -1, -1},
/*04863*/     {1361, -1, -1},
/*04864*/     {4872, 6, 3},
/*04865*/     {4882, 6, 3},
/*04866*/     {4892, 6, 3},
/*04867*/     {4902, 6, 3},
/*04868*/     {4912, 6, 3},
/*04869*/     {4922, 6, 3},
/*04870*/     {4932, 6, 3},
/*04871*/     {4942, 6, 3},
/*04872*/     {4880, 12, 1},
/*04873*/     {0, -1, -1},
/*04874*/     {0, -1, -1},
/*04875*/     {0, -1, -1},
/*04876*/     {0, -1, -1},
/*04877*/     {0, -1, -1},
/*04878*/     {0, -1, -1},
/*04879*/     {0, -1, -1},
/*04880*/     {1557, -1, -1},
/*04881*/     {1558, -1, -1},
/*04882*/     {4890, 12, 1},
/*04883*/     {0, -1, -1},
/*04884*/     {0, -1, -1},
/*04885*/     {0, -1, -1},
/*04886*/     {0, -1, -1},
/*04887*/     {0, -1, -1},
/*04888*/     {0, -1, -1},
/*04889*/     {0, -1, -1},
/*04890*/     {1559, -1, -1},
/*04891*/     {1560, -1, -1},
/*04892*/     {4900, 12, 1},
/*04893*/     {0, -1, -1},
/*04894*/     {0, -1, -1},
/*04895*/     {0, -1, -1},
/*04896*/     {0, -1, -1},
/*04897*/     {0, -1, -1},
/*04898*/     {0, -1, -1},
/*04899*/     {0, -1, -1},
/*04900*/     {1561, -1, -1},
/*04901*/     {1562, -1, -1},
/*04902*/     {4910, 12, 1},
/*04903*/     {0, -1, -1},
/*04904*/     {0, -1, -1},
/*04905*/     {0, -1, -1},
/*04906*/     {0, -1, -1},
/*04907*/     {0, -1, -1},
/*04908*/     {0, -1, -1},
/*04909*/     {0, -1, -1},
/*04910*/     {1563, -1, -1},
/*04911*/     {1564, -1, -1},
/*04912*/     {4920, 12, 1},
/*04913*/     {0, -1, -1},
/*04914*/     {0, -1, -1},
/*04915*/     {0, -1, -1},
/*04916*/     {0, -1, -1},
/*04917*/     {0, -1, -1},
/*04918*/     {0, -1, -1},
/*04919*/     {0, -1, -1},
/*04920*/     {1565, -1, -1},
/*04921*/     {1566, -1, -1},
/*04922*/     {4930, 12, 1},
/*04923*/     {0, -1, -1},
/*04924*/     {0, -1, -1},
/*04925*/     {0, -1, -1},
/*04926*/     {0, -1, -1},
/*04927*/     {0, -1, -1},
/*04928*/     {0, -1, -1},
/*04929*/     {0, -1, -1},
/*04930*/     {1567, -1, -1},
/*04931*/     {1568, -1, -1},
/*04932*/     {4940, 12, 1},
/*04933*/     {0, -1, -1},
/*04934*/     {0, -1, -1},
/*04935*/     {0, -1, -1},
/*04936*/     {0, -1, -1},
/*04937*/     {0, -1, -1},
/*04938*/     {0, -1, -1},
/*04939*/     {0, -1, -1},
/*04940*/     {1569, -1, -1},
/*04941*/     {1570, -1, -1},
/*04942*/     {4950, 12, 1},
/*04943*/     {0, -1, -1},
/*04944*/     {0, -1, -1},
/*04945*/     {0, -1, -1},
/*04946*/     {0, -1, -1},
/*04947*/     {0, -1, -1},
/*04948*/     {0, -1, -1},
/*04949*/     {0, -1, -1},
/*04950*/     {1571, -1, -1},
/*04951*/     {1572, -1, -1},
/*04952*/     {4960, 36, 1},
/*04953*/     {4966, 36, 1},
/*04954*/     {4972, 36, 1},
/*04955*/     {4978, 36, 1},
/*04956*/     {4984, 12, 1},
/*04957*/     {4986, 12, 1},
/*04958*/     {4988, 12, 1},
/*04959*/     {4990, 12, 1},
/*04960*/     {4962, 12, 1},
/*04961*/     {4964, 12, 1},
/*04962*/     {22, -1, -1},
/*04963*/     {25, -1, -1},
/*04964*/     {46, -1, -1},
/*04965*/     {49, -1, -1},
/*04966*/     {4968, 12, 1},
/*04967*/     {4970, 12, 1},
/*04968*/     {28, -1, -1},
/*04969*/     {31, -1, -1},
/*04970*/     {52, -1, -1},
/*04971*/     {55, -1, -1},
/*04972*/     {4974, 12, 1},
/*04973*/     {4976, 12, 1},
/*04974*/     {34, -1, -1},
/*04975*/     {37, -1, -1},
/*04976*/     {58, -1, -1},
/*04977*/     {61, -1, -1},
/*04978*/     {4980, 12, 1},
/*04979*/     {4982, 12, 1},
/*04980*/     {40, -1, -1},
/*04981*/     {43, -1, -1},
/*04982*/     {64, -1, -1},
/*04983*/     {67, -1, -1},
/*04984*/     {70, -1, -1},
/*04985*/     {73, -1, -1},
/*04986*/     {76, -1, -1},
/*04987*/     {79, -1, -1},
/*04988*/     {82, -1, -1},
/*04989*/     {85, -1, -1},
/*04990*/     {88, -1, -1},
/*04991*/     {91, -1, -1},
/*04992*/     {5000, 36, 1},
/*04993*/     {5006, 36, 1},
/*04994*/     {5012, 36, 1},
/*04995*/     {5018, 36, 1},
/*04996*/     {5024, 12, 1},
/*04997*/     {5026, 12, 1},
/*04998*/     {5028, 12, 1},
/*04999*/     {5030, 12, 1},
/*05000*/     {5002, 12, 1},
/*05001*/     {5004, 12, 1},
/*05002*/     {22, -1, -1},
/*05003*/     {25, -1, -1},
/*05004*/     {46, -1, -1},
/*05005*/     {49, -1, -1},
/*05006*/     {5008, 12, 1},
/*05007*/     {5010, 12, 1},
/*05008*/     {28, -1, -1},
/*05009*/     {31, -1, -1},
/*05010*/     {52, -1, -1},
/*05011*/     {55, -1, -1},
/*05012*/     {5014, 12, 1},
/*05013*/     {5016, 12, 1},
/*05014*/     {34, -1, -1},
/*05015*/     {37, -1, -1},
/*05016*/     {58, -1, -1},
/*05017*/     {61, -1, -1},
/*05018*/     {5020, 12, 1},
/*05019*/     {5022, 12, 1},
/*05020*/     {40, -1, -1},
/*05021*/     {43, -1, -1},
/*05022*/     {64, -1, -1},
/*05023*/     {67, -1, -1},
/*05024*/     {70, -1, -1},
/*05025*/     {73, -1, -1},
/*05026*/     {76, -1, -1},
/*05027*/     {79, -1, -1},
/*05028*/     {82, -1, -1},
/*05029*/     {85, -1, -1},
/*05030*/     {88, -1, -1},
/*05031*/     {91, -1, -1},
/*05032*/     {1362, -1, -1},
/*05033*/     {1363, -1, -1},
/*05034*/     {1364, -1, -1},
/*05035*/     {1365, -1, -1},
/*05036*/     {1366, -1, -1},
/*05037*/     {1367, -1, -1},
/*05038*/     {1368, -1, -1},
/*05039*/     {1369, -1, -1},
/*05040*/     {5048, 12, 1},
/*05041*/     {5050, 12, 1},
/*05042*/     {5052, 12, 1},
/*05043*/     {5054, 12, 1},
/*05044*/     {5056, 12, 1},
/*05045*/     {5058, 12, 1},
/*05046*/     {5060, 12, 1},
/*05047*/     {5062, 12, 1},
/*05048*/     {1573, -1, -1},
/*05049*/     {1574, -1, -1},
/*05050*/     {1575, -1, -1},
/*05051*/     {1576, -1, -1},
/*05052*/     {1577, -1, -1},
/*05053*/     {1578, -1, -1},
/*05054*/     {1579, -1, -1},
/*05055*/     {1580, -1, -1},
/*05056*/     {1581, -1, -1},
/*05057*/     {1582, -1, -1},
/*05058*/     {1583, -1, -1},
/*05059*/     {1584, -1, -1},
/*05060*/     {1585, -1, -1},
/*05061*/     {1586, -1, -1},
/*05062*/     {1587, -1, -1},
/*05063*/     {1588, -1, -1},
/*05064*/     {5072, 36, 1},
/*05065*/     {5078, 36, 1},
/*05066*/     {5084, 36, 1},
/*05067*/     {5090, 36, 1},
/*05068*/     {5096, 12, 1},
/*05069*/     {5098, 12, 1},
/*05070*/     {5100, 12, 1},
/*05071*/     {5102, 12, 1},
/*05072*/     {5074, 12, 1},
/*05073*/     {5076, 12, 1},
/*05074*/     {23, -1, -1},
/*05075*/     {26, -1, -1},
/*05076*/     {47, -1, -1},
/*05077*/     {50, -1, -1},
/*05078*/     {5080, 12, 1},
/*05079*/     {5082, 12, 1},
/*05080*/     {29, -1, -1},
/*05081*/     {32, -1, -1},
/*05082*/     {53, -1, -1},
/*05083*/     {56, -1, -1},
/*05084*/     {5086, 12, 1},
/*05085*/     {5088, 12, 1},
/*05086*/     {35, -1, -1},
/*05087*/     {38, -1, -1},
/*05088*/     {59, -1, -1},
/*05089*/     {62, -1, -1},
/*05090*/     {5092, 12, 1},
/*05091*/     {5094, 12, 1},
/*05092*/     {41, -1, -1},
/*05093*/     {44, -1, -1},
/*05094*/     {65, -1, -1},
/*05095*/     {68, -1, -1},
/*05096*/     {71, -1, -1},
/*05097*/     {74, -1, -1},
/*05098*/     {77, -1, -1},
/*05099*/     {80, -1, -1},
/*05100*/     {83, -1, -1},
/*05101*/     {86, -1, -1},
/*05102*/     {89, -1, -1},
/*05103*/     {92, -1, -1},
/*05104*/     {5112, 36, 1},
/*05105*/     {5118, 36, 1},
/*05106*/     {5124, 36, 1},
/*05107*/     {5130, 36, 1},
/*05108*/     {5136, 12, 1},
/*05109*/     {5138, 12, 1},
/*05110*/     {5140, 12, 1},
/*05111*/     {5142, 12, 1},
/*05112*/     {5114, 12, 1},
/*05113*/     {5116, 12, 1},
/*05114*/     {23, -1, -1},
/*05115*/     {26, -1, -1},
/*05116*/     {47, -1, -1},
/*05117*/     {50, -1, -1},
/*05118*/     {5120, 12, 1},
/*05119*/     {5122, 12, 1},
/*05120*/     {29, -1, -1},
/*05121*/     {32, -1, -1},
/*05122*/     {53, -1, -1},
/*05123*/     {56, -1, -1},
/*05124*/     {5126, 12, 1},
/*05125*/     {5128, 12, 1},
/*05126*/     {35, -1, -1},
/*05127*/     {38, -1, -1},
/*05128*/     {59, -1, -1},
/*05129*/     {62, -1, -1},
/*05130*/     {5132, 12, 1},
/*05131*/     {5134, 12, 1},
/*05132*/     {41, -1, -1},
/*05133*/     {44, -1, -1},
/*05134*/     {65, -1, -1},
/*05135*/     {68, -1, -1},
/*05136*/     {71, -1, -1},
/*05137*/     {74, -1, -1},
/*05138*/     {77, -1, -1},
/*05139*/     {80, -1, -1},
/*05140*/     {83, -1, -1},
/*05141*/     {86, -1, -1},
/*05142*/     {89, -1, -1},
/*05143*/     {92, -1, -1},
/*05144*/     {1373, -1, -1},
/*05145*/     {5146, 34, 2},
/*05146*/     {1370, -1, -1},
/*05147*/     {0, -1, -1},
/*05148*/     {1372, -1, -1},
/*05149*/     {1371, -1, -1}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\decem\decoder.c ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <assert.h>
#define INT64
#include "decfn_emdb.h"
#include "decision_tree.h"
#pragma function (memset)


#include "decoder_priv.h"

/***************************************************************************/

#define STATIC

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#define PRED_SIZE EM_PREDICATE_BITS

#define INIT_PSEUDO_TROLES_TAB_ENTRY(Entry,Slot0,Slot1,Slot2)				\
{																			\
	pseudo_troles_tab[Entry][0] = (Slot0);									\
	pseudo_troles_tab[Entry][1] = (Slot1);									\
	pseudo_troles_tab[Entry][2] = (Slot2);									\
}

#define EM_DECODER_FLAGS__NO_MEMSET(Flags) ((Flags) & EM_DECODER_FLAG_NO_MEMSET)

/***************************************************************************/

U4byte IEL_t1, IEL_t2, IEL_t3, IEL_t4;
U32  IEL_tempc;
U64  IEL_et1, IEL_et2;
U128 IEL_ext1, IEL_ext2, IEL_ext3, IEL_ext4, IEL_ext5;
S128 IEL_ts1, IEL_ts2;

extern struct EM_version_s deccpu_emdb_version;

const U32 decoder_bundle_size = IEL_CONST32(EM_BUNDLE_SIZE);
    
STATIC Temp_role_t 		pseudo_troles_tab[16][3];
STATIC int				troles_tab_initialized = FALSE;

STATIC EM_Decoder_Err em_decoding(const EM_Decoder_Id, const unsigned char *,
                                  const int, const EM_IL, EM_Decoder_Info *);

STATIC EM_Decoder_Err em_inst_decode(const EM_Decoder_Id,  U64, const Temp_role_t,
                                     const U128 *, EM_Decoder_Info *);

STATIC void em_decoder_init_decoder_info(EM_Decoder_Info *decoder_info);

STATIC void em_decoder_init_bundle_info(EM_Decoder_Bundle_Info *bundle_info);

STATIC void init_pseudo_troles_tab(void);


/****************************************************************************
 *                      init_pseudo_troles_tab                              *
 *  initalizes pseudo_troles_tab. If only template-# changes, update EM.h   *
 *  is enough to update the decoder.                                        *
 ****************************************************************************/

STATIC void init_pseudo_troles_tab(void)
{
	/*** In the following table EM_TEMP_ROLE_MEM means M/A & same for _INT ***/
	int i;
	
	/*** initialize all entries as reserved ***/
	for (i = 0; i < EM_NUM_OF_TEMPLATES; i++)
		INIT_PSEUDO_TROLES_TAB_ENTRY(i, EM_TEMP_ROLE_NONE, EM_TEMP_ROLE_NONE,
									 EM_TEMP_ROLE_NONE);

	/*** initialize specific entries ***/

    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mii  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_INT , EM_TEMP_ROLE_INT );
    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mi_i , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_INT , EM_TEMP_ROLE_INT );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mlx  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_LONG, EM_TEMP_ROLE_LONG);
    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mmi  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_MEM , EM_TEMP_ROLE_INT );
    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_m_mi , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_MEM , EM_TEMP_ROLE_INT );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mfi  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_FP  , EM_TEMP_ROLE_INT );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mmf  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_MEM , EM_TEMP_ROLE_FP  );
    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mib  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_INT , EM_TEMP_ROLE_BR  );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mbb  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_BR  , EM_TEMP_ROLE_BR  );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_bbb  , EM_TEMP_ROLE_BR  , \
								 EM_TEMP_ROLE_BR  , EM_TEMP_ROLE_BR  );
	INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mmb  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_MEM , EM_TEMP_ROLE_BR );
    INIT_PSEUDO_TROLES_TAB_ENTRY(EM_template_mfb  , EM_TEMP_ROLE_MEM , \
								 EM_TEMP_ROLE_FP  , EM_TEMP_ROLE_BR  );
 
	/*** avoid multpiple initializations ***/
	troles_tab_initialized = TRUE;  
};


#ifdef BIG_ENDIAN

#define ENTITY_SWAP(E)  entity_swap((unsigned char *)(&(E)), sizeof(E))


/***************************** entity_swap *******************************/
/* swap any number of bytes                                              */
/*************************************************************************/

STATIC  void    entity_swap(unsigned char *entity_1st, unsigned int size)
{
    unsigned char       tmp8, *p, *q;
    
    for (q = (p = entity_1st) + (size-1);
         p < q;
         p++, q--)
    {
        tmp8 = *q;
        *q = *p;
        *p = tmp8;
    }
}
#else

#define ENTITY_SWAP(E)  {}

#endif

/*
STATIC dec_2_emdb_trole[] = 
{
	EM_TEMP_ROLE_INT,
	EM_TEMP_ROLE_MEM,
	EM_TEMP_ROLE_FP,
	EM_TEMP_ROLE_BR,
	EM_TEMP_ROLE_LONG
};
*/

/********************************************************************************/
/* em_decoder_open: opens a new entry in the em_clients_table and returns the   */
/*               index of the entry.                                            */
/********************************************************************************/

 EM_Decoder_Id em_decoder_open(void)
{
    int i;
    Client_Entry initiate_entry={1,
                                 DEFAULT_MACHINE_TYPE, 
                                 DEFAULT_MACHINE_MODE,
                                 NULL
                                };

    
    for (i=0 ; i < EM_DECODER_MAX_CLIENTS ; i++)
    {
        if ( !(em_clients_table[i].is_used) )
        {
            em_clients_table[i] = initiate_entry;
			if (!troles_tab_initialized)
				init_pseudo_troles_tab();
            return(i);
        }
    }
    return(-1);
}

/*****************************************************************************/
/* legal_id: check whether a given id suits an active entry in the           */
/*   clients table.                                                          */
/*****************************************************************************/

STATIC int legal_id(int id)
{
    if ((id<0)||(id>=EM_DECODER_MAX_CLIENTS))
    {
        return(FALSE);
    }
    if (!em_clients_table[id].is_used)
    {
        return(FALSE);
    }
    return(TRUE);
}

/*****************************************************************************/
/* em_decoder_close: closes an entry in the clients table for later use.     */
/*****************************************************************************/

 EM_Decoder_Err em_decoder_close(const EM_Decoder_Id id)
{
    if (legal_id(id))
    {
        em_clients_table[id].is_used=0;
        if (em_clients_table[id].info_ptr != NULL)
        {
            free(em_clients_table[id].info_ptr);
        }
        return(EM_DECODER_NO_ERROR);
    }
    else
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }
}

/*****************************************************************************/
/* legal_type:                                                               */
/*****************************************************************************/

STATIC int legal_type(EM_Decoder_Machine_Type type)
{
    if (type < EM_DECODER_CPU_LAST)
    {
        return(TRUE);
    }
    return(FALSE);
}

/*****************************************************************************/
/* legal_mode:                                                               */
/*****************************************************************************/

STATIC int legal_mode(EM_Decoder_Machine_Type type, EM_Decoder_Machine_Mode mode)
{
    if (mode == EM_DECODER_MODE_NO_CHANGE)
    {
        return(TRUE);
    }

    if ((mode > EM_DECODER_MODE_NO_CHANGE) && (mode < EM_DECODER_MODE_LAST))
    {
        if ((mode == EM_DECODER_MODE_EM) && (type != EM_DECODER_CPU_P7))
        {
            return(FALSE);
        }
        else
        {
            return(TRUE);
        }

    }
    return(FALSE);
}


/*****************************************************************************/
/* legal_inst:                                                               */
/*****************************************************************************/

STATIC int legal_inst(EM_Decoder_Inst_Id inst, EM_Decoder_Machine_Type type)
{
    if (inst < EM_INST_LAST)
    {
		/* unsigned int cpu_flag = deccpu_EMDB_info[inst].impls; */
		
		switch (type)
		{
			case EM_DECODER_CPU_P7:
			  return TRUE;
			default:
			  /*assert(0);*/
			  break;
		}	
    }
    return(FALSE);
}

/****************************************************************************/
/* em_decoder_setenv: sets the machine type and machine mode variables.     */
/****************************************************************************/

 EM_Decoder_Err em_decoder_setenv(const EM_Decoder_Id            id,
                                  const EM_Decoder_Machine_Type  type,
                                  const EM_Decoder_Machine_Mode  mode)
{
    if (!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }

    if (!legal_type(type))
    {
        return(EM_DECODER_INVALID_MACHINE_TYPE);
    }

    if (!legal_mode(type, mode))
    {
        return(EM_DECODER_INVALID_MACHINE_MODE);
    }

    if (type == EM_DECODER_CPU_DEFAULT)
    {
        em_clients_table[id].machine_type = DEFAULT_MACHINE_TYPE;
    }
    else if (type != EM_DECODER_CPU_NO_CHANGE)
    {
        em_clients_table[id].machine_type = type;
    }

    if (mode == EM_DECODER_MODE_DEFAULT)
    {
        em_clients_table[id].machine_mode = DEFAULT_MACHINE_MODE;
    }
    else if (mode != EM_DECODER_MODE_NO_CHANGE)
    {
        em_clients_table[id].machine_mode = mode;
    }

    return(EM_DECODER_NO_ERROR);
}

/******************************************************************************/
/* em_decoder_setup: sets the machine type, machine mode variables and flags. */
/******************************************************************************/

 EM_Decoder_Err em_decoder_setup(const EM_Decoder_Id            id,
                                 const EM_Decoder_Machine_Type  type,
                                 const EM_Decoder_Machine_Mode  mode,
								 unsigned long            flags)
{
	EM_Decoder_Err err;
	
	if ((err=em_decoder_setenv(id, type, mode)) != EM_DECODER_NO_ERROR)
	{
		return (err);
	}

	em_clients_table[id].flags = flags;

	return (EM_DECODER_NO_ERROR);
}

/********************************************************************************/
/* em_decoder_init_decoder_info: initializes decoder_info in case of no memset. */
/********************************************************************************/

STATIC void em_decoder_init_decoder_info(EM_Decoder_Info *decoder_info)
{
	decoder_info->pred.valid = FALSE;
	
	decoder_info->src1.type = EM_DECODER_NO_OPER;
	decoder_info->src1.oper_flags = 0;
	decoder_info->src2.type = EM_DECODER_NO_OPER;
	decoder_info->src2.oper_flags = 0;
	decoder_info->src3.type = EM_DECODER_NO_OPER;
	decoder_info->src3.oper_flags = 0;
	decoder_info->src4.type = EM_DECODER_NO_OPER;
	decoder_info->src4.oper_flags = 0;
	decoder_info->src5.type = EM_DECODER_NO_OPER;
	decoder_info->src5.oper_flags = 0;
	decoder_info->dst1.type = EM_DECODER_NO_OPER;
	decoder_info->dst1.oper_flags = 0;
	decoder_info->dst2.type = EM_DECODER_NO_OPER;
	decoder_info->dst1.oper_flags = 0;
}

/******************************************************************************/
/* em_decoder_init_bundle_info: initializes bundle_info in case of no memset. */
/******************************************************************************/

STATIC void em_decoder_init_bundle_info(EM_Decoder_Bundle_Info *bundle_info)
{
	unsigned int slot;
	  
	for (slot=0; slot<3; slot++)
	{  
	  em_decoder_init_decoder_info(bundle_info->inst_info+slot);
	  bundle_info->inst_info[slot].EM_info.em_flags = 0;
	}  
}	

/*******************************************************************************/
/* em_decoder_associate_one: adds to the client's entry a pointer to an extra  */
/* information about a single instruction (inst).                              */
/*******************************************************************************/

 EM_Decoder_Err em_decoder_associate_one(const EM_Decoder_Id       id,
                                         const EM_Decoder_Inst_Id  inst,
                                         const void *           client_info)
{
    int     i;
    int     n_insts;
    
    if (!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }

    if (!legal_inst(inst, em_clients_table[id].machine_type))
    {
        return(EM_DECODER_INVALID_INST_ID);
    }
    {
        n_insts = EM_INST_LAST;  /*** assume MAX. repair ***/
    }
    if (em_clients_table[id].info_ptr == NULL)
    {
        em_clients_table[id].info_ptr = calloc((size_t)n_insts, sizeof(void *));
        if (!em_clients_table[id].info_ptr)
        {
            return EM_DECODER_INTERNAL_ERROR;
        }

        for (i=0 ; i < n_insts ; i++)
        {
            em_clients_table[id].info_ptr[i] = NULL;
        }
    }
    em_clients_table[id].info_ptr[inst] = (void *)client_info;
    return(EM_DECODER_NO_ERROR);
}


/***************************************************************************** 
 * em_decoder_associate_check - check the client's array of association      * 
 *                           valid for P7 cpu only                           * 
 *****************************************************************************/

 EM_Decoder_Err em_decoder_associate_check(const EM_Decoder_Id  id,
                                           EM_Decoder_Inst_Id * inst)
{
    EM_Decoder_Inst_Id i;
    
    if(!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }
    if (em_clients_table[id].machine_type == EM_DECODER_CPU_P7)
    {
        if (em_clients_table[id].machine_mode == EM_DECODER_MODE_EM)
        {
            if(em_clients_table[id].info_ptr == NULL)
            {
                *inst = 1;
                return(EM_DECODER_ASSOCIATE_MISS);
            }

            for (i = 1;
                 (i < EM_INST_LAST) &&
                 (em_clients_table[id].info_ptr[i] != NULL);
                 i++);

            if (i < EM_INST_LAST)
            {
                *inst = i;
                return(EM_DECODER_ASSOCIATE_MISS);
            }
        }
        else    /***   iA   ***/
        {
        }
        *inst = EM_DECODER_INST_NONE;
        return(EM_DECODER_NO_ERROR);
    }
    else     /* cpu is p5, p6 */
    {
        *inst = EM_DECODER_INST_NONE;
        return(EM_DECODER_NO_ERROR);
    }
}


/******************************************************************************
 * em_decoder_decode                                                          *
 *                                                                            *
 * params:                                                                    *
 *          id - decoder client id                                            *
 *          code - pointer to instruction buffer                              *
 *          max_code_size - instruction buffer size                           *
 *          decoder_info - pointer to decoder_info to fill                    *
 *                                                                            *
 * returns:                                                                   *
 *          EM_Decoder_Err                                                    *
 *                                                                            *
 *****************************************************************************/

 EM_Decoder_Err em_decoder_decode(const EM_Decoder_Id   id,
                                  const unsigned char * code,
                                  const int             max_code_size,
                                  const EM_IL           location,
                                  EM_Decoder_Info *     decoder_info)
{
    EM_Decoder_Err     err = EM_DECODER_NO_ERROR;


    if (!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }

    if (decoder_info == NULL)
    {
        return(EM_DECODER_NULL_PTR);
    }

    if (code == NULL)
    {
        return(EM_DECODER_TOO_SHORT_ERR);
    }

	if (EM_DECODER_FLAGS__NO_MEMSET(em_clients_table[id].flags))
	{
		em_decoder_init_decoder_info(decoder_info);
	}
	else
	{  
		memset(decoder_info, 0, sizeof(EM_Decoder_Info));
	}	

	if (em_clients_table[id].machine_mode == EM_DECODER_MODE_EM)
    {
        err = em_decoding(id, code, max_code_size, location, decoder_info);
    }
    else 
    {
        err = EM_DECODER_INVALID_MACHINE_MODE;
    }

    return(err);
}

/*****************************************************************************/
/* em_decoder_inst_static_info: return instruction static info (flags,       */
/*             client_info pointer and static_info pointer)                  */
/*****************************************************************************/

 EM_Decoder_Err em_decoder_inst_static_info(const EM_Decoder_Id            id,
      									    const EM_Decoder_Inst_Id       inst_id,
									        EM_Decoder_Inst_Static_Info *  static_info)
{
    if (!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }

    if (!legal_inst(inst_id, em_clients_table[id].machine_type))
    {
        return(EM_DECODER_INVALID_INST_ID);
    }

    if (static_info == NULL)
    {
        return(EM_DECODER_NULL_PTR);
    }

    if (em_clients_table[id].info_ptr != NULL)
    {
        static_info->client_info = em_clients_table[id].info_ptr[inst_id];
    }
    else
    {
        static_info->client_info = NULL;
    }

	static_info->static_info = em_decoder_static_info + inst_id;
	
    return(EM_DECODER_NO_ERROR);
}



/******************************************************************************
 * em_decoder_decode_bundle - decode em bundle                                *
 *                                                                            *
 * params:                                                                    *
 *          id - decoder client id                                            *
 *          code - pointer to instruction buffer                              *
 *          max_code_size - instruction buffer size(Should be at least 3*128  *
 *          bundle_info - pointer to bundle_info to fill                      *
 *                                                                            *
 * returns:                                                                   *
 *          EM_Decoder_Err                                                    *
 *                                                                            *
 *****************************************************************************/

 EM_Decoder_Err em_decoder_decode_bundle(const EM_Decoder_Id      id,
                                         const unsigned char*     code,
                                         const int                max_size,
                                         EM_Decoder_Bundle_Info*  bundle_info)
{
    unsigned int        slot_no;
    U128                bundle;
    U64                 instr;
    EM_template_t       templt;
    Temp_role_t         temp_role;
    EM_Decoder_Info    *decoder_info;
    int                 bundle_stop;
    EM_Decoder_Err      err, return_err = EM_DECODER_NO_ERROR;

	if (!legal_id(id))
    {
        return(EM_DECODER_INVALID_CLIENT_ID);
    }

	if (bundle_info == NULL)
    {
        return(EM_DECODER_NULL_PTR);
    }
	
	if (EM_DECODER_FLAGS__NO_MEMSET(em_clients_table[id].flags))
	{
		em_decoder_init_bundle_info(bundle_info);
	}
	else
	{  
		memset(bundle_info, 0, sizeof(EM_Decoder_Bundle_Info));
	}
	
	bundle = *(const U128 *)code;
	ENTITY_SWAP(bundle);
	templt = EM_GET_TEMPLATE(bundle);
	
    if (max_size < EM_BUNDLE_SIZE)
    {
        return(EM_DECODER_TOO_SHORT_ERR);
    }

    bundle_info->em_bundle_info.flags = 0;
    
    if (bundle_stop = (IEL_GETDW0(bundle) & (1<<EM_SBIT_POS)))
        bundle_info->em_bundle_info.flags |= EM_DECODER_BIT_BUNDLE_STOP;
    
    if (EM_TEMPLATE_IS_RESERVED(templt))
        return(EM_DECODER_INVALID_TEMPLATE);

    bundle_info->em_bundle_info.b_template = templt;

    /*** Decode 3 instruction (unless long 2-slot instruction) ***/
       
    for(slot_no = 0;  slot_no < 3; slot_no++)
    {
        decoder_info = &(bundle_info->inst_info[slot_no]);
		decoder_info->EM_info.slot_no = slot_no;

        temp_role = pseudo_troles_tab[templt][slot_no];
		
		/*** DECODER_NEXT should work even if error occurs ***/
		decoder_info->size = 1 + (temp_role == EM_TEMP_ROLE_LONG);
	
		if (temp_role == EM_TEMP_ROLE_LONG)  /*** 2-slot instruction ***/
		{
			EM_GET_SYLLABLE(instr, bundle, slot_no+1); /* opcode is in slot 3 */
			err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);

		   	if (err == EM_DECODER_INVALID_PRM_OPCODE)
			{
				/* try to find nop.i or break.i in this slot */
				temp_role = EM_TEMP_ROLE_INT;

				err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);
				if (!err)
				{
					if (!EM_DECODER_CHECK_OK_IN_MLX(decoder_info))
						err = EM_DECODER_INVALID_PRM_OPCODE;
				}
			}
		}

		else
		{
			EM_GET_SYLLABLE(instr, bundle, slot_no);
		
			err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);
		

			if (!err)
			{
				if ((EM_DECODER_CHECK_SLOT2_ONLY(decoder_info)) && (slot_no != 2))
					/*** intruction must be in slot 2 only, but... ***/  
					err = EM_DECODER_INVALID_SLOT_BRANCH_INST;
				else if (EM_DECODER_CHECK_GROUP_LAST(decoder_info) &&
					    (((slot_no != 2) || !bundle_stop) && ((slot_no != 0) || (templt != EM_template_m_mi))))
				     /*** instruction fails to be the last in instruction group ***/
				     err = EM_DECODER_MUST_BE_GROUP_LAST;
				  
			}
		}

        /* return_err = the first worst error */
		if (err)
		{  
			FILL_PREDICATE_INFO(instr, decoder_info);
        	if ((!return_err) || (EM_DECODER_ERROR_IS_INST_FATAL(err)
								  && !EM_DECODER_ERROR_IS_INST_FATAL(return_err)))
            	return_err = err;
		}	
        bundle_info->error[slot_no] = err;

        decoder_info->EM_info.em_bundle_info = bundle_info->em_bundle_info;
		
        if (decoder_info->size == 2) /*** 2-slot instruction - exit for loop ***/
		{
			slot_no++;
            break;
		}
    }

/*   if ((!err) && EM_DECODER_CHECK_GROUP_LAST(decoder_info) &&
		(!EM_DECODER_BUNDLE_STOP(decoder_info)))
	{  
		*** instruction fails to be the last in instruction group ***
		bundle_info->error[slot_no-1] = EM_DECODER_MUST_BE_GROUP_LAST;
		if (!return_err)
		   return_err = EM_DECODER_MUST_BE_GROUP_LAST;
	}*/
	
    bundle_info->inst_num = slot_no;

    bundle_info->inst_info[slot_no-1].EM_info.em_flags |=
        EM_DECODER_BIT_LAST_INST;
    
    if (bundle_stop)
        bundle_info->inst_info[slot_no-1].EM_info.em_flags |=
            EM_DECODER_BIT_CYCLE_BREAK;

    if (templt == EM_template_m_mi)
        bundle_info->inst_info[0].EM_info.em_flags |=
            EM_DECODER_BIT_CYCLE_BREAK;
    
    if (templt == EM_template_mi_i)
        bundle_info->inst_info[1].EM_info.em_flags |=
            EM_DECODER_BIT_CYCLE_BREAK;
    
    return(return_err);
}

/******************************************************************************
 * em_decoding - decode em (2.0- till ??) single instruction + bundle info    *
 *                                                                            *
 * params:                                                                    *
 *          id - decoder client id                                            *
 *          code - pointer to instruction buffer                              *
 *          max_code_size - instruction buffer size                           *
 *          location - syllable location, used to get slot #                  *
 *          decoder_info - pointer to decoder_info to fill                    *
 *                                                                            *
 * returns:                                                                   *
 *          EM_Decoder_Err                                                    *
 *                                                                            *
 *****************************************************************************/

STATIC EM_Decoder_Err      em_decoding   ( const EM_Decoder_Id    id,
                                           const unsigned char  * code,
                                           const int              max_code_size,
                                           const EM_IL            location,
                                           EM_Decoder_Info      * decoder_info)
{
    unsigned int            slot_no = EM_IL_GET_SLOT_NO(location);
    U128                    bundle;
    U64                     instr;
    EM_template_t           templt;
    Temp_role_t             temp_role;
    int                     bundle_stop, cycle_break;
    EM_Decoder_Err          err;

    bundle = *(const U128 *)code;
    ENTITY_SWAP(bundle);
    templt = EM_GET_TEMPLATE(bundle);

	/*** DECODER_NEXT should work even if error occurs ***/
	decoder_info->size = 1;
	
    if (max_code_size < EM_BUNDLE_SIZE)
    {
        return(EM_DECODER_TOO_SHORT_ERR);
    }
    
    /******************************************************************/
    /** fill EM_Info  and check it                                  ***/
    /******************************************************************/
    
    decoder_info->EM_info.em_flags =
        decoder_info->EM_info.em_bundle_info.flags = 0;
    
    if (bundle_stop = (IEL_GETDW0(bundle) & (1<<EM_SBIT_POS)))
        decoder_info->EM_info.em_bundle_info.flags |=
            EM_DECODER_BIT_BUNDLE_STOP;

    
    if (EM_TEMPLATE_IS_RESERVED(templt))
        return(EM_DECODER_INVALID_TEMPLATE);

    decoder_info->EM_info.em_bundle_info.b_template = templt;

    if (slot_no > EM_SLOT_2)
    {
        return(EM_DECODER_INVALID_INST_SLOT);
    }
    
	decoder_info->EM_info.slot_no = slot_no;
    
    /***********************/
    /*** decode syllable ***/
    /***********************/

    /*** get instruction binary. DON'T mask bits 41 and on ***/

    temp_role = pseudo_troles_tab[templt][slot_no];

	if (temp_role == EM_TEMP_ROLE_LONG)  /*** 2-slot instruction ***/
	{
		decoder_info->size = 2;
		EM_GET_SYLLABLE(instr, bundle, slot_no+1); /* opcode is in slot 3 */
		err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);
		if (err == EM_DECODER_INVALID_PRM_OPCODE)
		{
			/* try to find nop.i or break.i in this slot */
			temp_role = EM_TEMP_ROLE_INT;
			slot_no = EM_DECODER_SLOT_2;
			err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);
			if (!err)
			{
				if (!EM_DECODER_CHECK_OK_IN_MLX(decoder_info))
					err = EM_DECODER_INVALID_PRM_OPCODE;
			}
		}
	}
	else
	{
		EM_GET_SYLLABLE(instr, bundle, slot_no);

		err = em_inst_decode(id, instr, temp_role, &bundle, decoder_info);
	

		if (!err)
		{  
			if ((EM_DECODER_CHECK_SLOT2_ONLY(decoder_info)) && (slot_no != 2))
			{  
				/*** intruction must be in slot 2 only, but... ***/
				err = EM_DECODER_INVALID_SLOT_BRANCH_INST;
			}	
			else if (EM_DECODER_CHECK_GROUP_LAST(decoder_info) && 
					(((slot_no != 2) || !bundle_stop) && ((slot_no != 0) || (templt != EM_template_m_mi))))
			{  
				  /* instruction fails to be the last in instruction group */
				  err = EM_DECODER_MUST_BE_GROUP_LAST;
			}
		}	

	}
	if (err) FILL_PREDICATE_INFO(instr, decoder_info);
	
    if ((slot_no == EM_DECODER_SLOT_2)||(decoder_info->size == 2) /* 2-slot instruction */)
    {
        cycle_break = (bundle_stop != 0);
        decoder_info->EM_info.em_flags |= EM_DECODER_BIT_LAST_INST;
    }
    else
    {
        cycle_break = ((slot_no==0) && (templt == EM_template_m_mi)) ||
                      ((slot_no==1) && (templt == EM_template_mi_i));
    }
    decoder_info->EM_info.em_flags |= (cycle_break*EM_DECODER_BIT_CYCLE_BREAK);
    
	return(err);
}

/******************************************************************************
 * em_inst_decode - decode em (2.0- till ??) single syllable                  *
 *                                                                            *
 * params:                                                                    *
 *          id - decoder client id                                            *
 *          instr - 64 bit, 0-40 are the syllable binary, 41-63 irrelevant    *
 *          pseudo_trole - M/A, I/A, FP, or BR                                *
 *          bundle - original pointer to bundle, for 64-bit imm extraction    *
 *          decoder_info - pointer to decoder_info to fill                    *
 *                                                                            *
 * returns:                                                                   *
 *          EM_Decoder_Err                                                    *
 *                                                                            *
 *****************************************************************************/

STATIC EM_Decoder_Err  em_inst_decode( const EM_Decoder_Id    id,
                                       U64                    instr,
                                       const Temp_role_t      pseudo_trole,
                                       const U128           * bundle_p,
                                       EM_Decoder_Info      * decoder_info)
{
    Inst_id_t         inst_id;
    EM_Decoder_Err    err;
    U64               tmp64;
    unsigned int      major_opc, inst_center;
    Node_t            node;
    int               part_place, part_size, part_value, index;
    deccpu_EMDB_info_t * emdb_entry_p;
	EM_Decoder_static_info_t *static_entry_p;
    Template_role_t   trole;

	
    /*** find major opcode ***/

    major_opc = IEL_GETDW1(instr);              /*** assumes pos > 31    ***/
    major_opc >>= (EM_MAJOR_OPCODE_POS - 32);   
    major_opc &= ((1<<EM_MAJOR_OPCODE_BITS)-1); /*** mask out bits 41-64 ***/
    
    /*** instruction bits 6-36 (without pred/major-opcode) to inst_center ***/
    /*** done to accelerate mask/shift in main loop (aviods IEL use).     ***/
	
    IEL_SHR(tmp64, instr, PRED_SIZE); /*** bits 6-40 --> 0-34 ***/
    inst_center = IEL_GETDW0(tmp64);  /*** original bits 6-37 ***/

    /*** walk through decoder decision tree ***/
    
    node = em_decision_tree[SQUARE(major_opc, pseudo_trole)];
    while (!NODE_IS_LEAF(node))
    {
        part_place = GET_NODE_POS(node) - PRED_SIZE;
        part_size  = GET_NODE_SIZE(node);
		
		if (part_place < 0)     /*** extensions in bits 0-5 ***/
		{
			part_place += PRED_SIZE;
			part_value = (IEL_GETDW0(instr) >> part_place) & ((1<<part_size)-1);
		}	
		else	
		    part_value = (inst_center >> part_place) & ((1<<part_size)-1);
		
        index = GET_NEXT_NODE_INDEX(node) + part_value;
        node = em_decision_tree[index];
    }

    /*** leaf found - emdb line identified ***/
    
    inst_id = GET_NEXT_NODE_INDEX(node);
	decoder_info->flags = 0;
	/*define machine behaviour within illegal opcode */
	{
		Behaviour_ill_opcode machine_behaviour;
		/*Template_role_t em_trole = dec_2_emdb_trole[pseudo_trole];*/
		PRED_BEHAVIOUR(pseudo_trole, major_opc, machine_behaviour);
		if (machine_behaviour == BEHAVIOUR_UNDEF)
		{
			/* branch region with opcode 0 */
			/* check bit 32*/
			int decision_bit;
			GET_BRANCH_BEHAVIOUR_BIT(instr, decision_bit);
			if (decision_bit)
			{
				machine_behaviour = BEHAVIOUR_FAULT;
			}
			else
			{
				machine_behaviour = BEHAVIOUR_IGNORE_ON_FALSE_QP;
			}
		}
		if (machine_behaviour == BEHAVIOUR_FAULT)
		{
			EM_DECODER_SET_UNC_ILLEGAL_FAULT(decoder_info);
		}
	}
    if ((inst_id >= EM_INST_LAST) || inst_id == EM_ILLOP)
    {
		if (pseudo_trole == EM_TEMP_ROLE_BR)
		{
			/*** search for ignored fields ***/
			switch (major_opc)
			{
				case 0:
				{
				   unsigned int x6_ext;
				   U64 ext;

   				   /*** get extention in bits 27:32 ***/
				   IEL_SHR(ext, instr, 27);
				   x6_ext = IEL_GETDW0(ext) & ((1<<6) - 1);
				   if (x6_ext == 1)
				   {
					   /*** nop.b has to be returned ***/
					   inst_id = EM_NOP_B_IMM21;
				   }
				   else
					 return(EM_DECODER_INVALID_PRM_OPCODE);

				   break;
				}   
				   
				case 2:
				{
				   unsigned int x6_ext;
				   U64 ext;

   				   /*** get extention in bits 27:32 ***/
				   IEL_SHR(ext, instr, 27);
				   x6_ext = IEL_GETDW0(ext) & ((1<<6) - 1);
				   switch (x6_ext)
				   {
					   case 0:
					   case 16:
					   case 17:
					      return (EM_DECODER_INVALID_PRM_OPCODE);
					   default:
						  /*** nop.b has to be returned ***/
						  inst_id = EM_NOP_B_IMM21;
				   }

				   break;
				}  
				   
				default:
				   return(EM_DECODER_INVALID_PRM_OPCODE);
			}

			/*** zero the inst encoding: pred and operands extracted below will be 0 ***/
			IEL_ZERO(instr);
		}	
        else return(EM_DECODER_INVALID_PRM_OPCODE);
    }

	if (! legal_inst(inst_id, em_clients_table[id].machine_type))
	{   /*** inst does not belong to the specified machine IS ***/
		return(EM_DECODER_INVALID_PRM_OPCODE);
	}
	
    decoder_info->inst = inst_id;
    emdb_entry_p = deccpu_EMDB_info + inst_id;
	static_entry_p = (EM_Decoder_static_info_t *)em_decoder_static_info + inst_id;

    /*** get instruction static info ***/

    decoder_info->flags |= static_entry_p->flags;
    decoder_info->EM_info.eut = trole = static_entry_p->template_role;
    
    if (EM_DECODER_CHECK_TWO_SLOT(decoder_info))
    {
		/*** IMPORTANT: emdb flags already set from the static info !!! ***/
        decoder_info->EM_info.em_flags |= EM_DECODER_BIT_LONG_INST;
        /*** decoder_info->size = 2; *** should be already done ***/
    }
    /*** else *** should be already done ***
    {
        decoder_info->size = 1;
    }
	***/

    /*** handle client and static info ***/
    
    if (em_clients_table[id].info_ptr != NULL)
    {
        decoder_info->client_info = em_clients_table[id].info_ptr[inst_id];
    }
    else
    {
        decoder_info->client_info = NULL;
    }

	decoder_info->static_info = static_entry_p;

    
    /*** Decode predicate register ***/

    if (static_entry_p->flags & EM_FLAG_PRED)
    {
		FILL_PREDICATE_INFO(instr, decoder_info)
    }

    /*** decode operands NYI ***/

    err = emdb_entry_p->format_function(emdb_entry_p, instr, bundle_p, 
                                        decoder_info);
    return(err);
}


/************************ misc. API functions ********************************/


const char* em_decoder_ver_str()
{
    return(em_ver_string);
}

const char* em_decoder_err_msg(EM_Decoder_Err error)
{
    if (error>=EM_DECODER_LAST_ERROR)
    {
        error = EM_DECODER_INTERNAL_ERROR;
    }
    return(em_err_msg[error]);
}

void em_decoder_get_version(EM_library_version_t *dec_version)
{
	if (dec_version != NULL)
	{
	  dec_version->xversion.major = XVER_MAJOR;
	  dec_version->xversion.minor = XVER_MINOR;
	  dec_version->api.major      = API_MAJOR;
	  dec_version->api.minor      = API_MINOR;
	  dec_version->emdb.major     = deccpu_emdb_version.major;
	  dec_version->emdb.minor     = deccpu_emdb_version.minor;
	  strcpy(dec_version->date, __DATE__);
	  strcpy(dec_version->time, __TIME__);
	}
}


/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\decem\decoder.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef EM_DECODER_H
#define EM_DECODER_H

#include "inst_ids.h"
#include "emdb_types.h"
#include "EM.h"

#define EM_DECODER_INST_NONE  EM_INST_NONE

typedef Inst_id_t  EM_Decoder_Inst_Id;

typedef unsigned char  EM_Decoder_imp_oper_t;

#include "EM_tools.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef enum em_cmp_rel_s
{
	EM_CMP_REL_NONE  = 0,
	EM_CMP_REL_GEU   = 1,
	EM_CMP_REL_LTU   = 2,
	EM_CMP_REL_EQ    = 3,
	EM_CMP_REL_NE    = 4,
	EM_CMP_REL_LT    = 5,
	EM_CMP_REL_GE    = 6,
	EM_CMP_REL_GT    = 7,
	EM_CMP_REL_LE    = 8,
    EM_CMP_REL_UNORD = 9,
	EM_CMP_REL_ORD   = 10,
	EM_CMP_REL_NEQ   = 11,
	EM_CMP_REL_NLT   = 12,
	EM_CMP_REL_NLE   = 13,
	EM_CMP_REL_LAST  = 14
} EM_cmp_rel_t;

typedef enum em_fp_precision_s
{
	EM_FP_PRECISION_NONE    = 0,
	EM_FP_PRECISION_SINGLE  = 1,
	EM_FP_PRECISION_DOUBLE  = 2,
	EM_FP_PRECISION_DYNAMIC = 3,
	EM_FP_PRECISION_LAST    = 4
} EM_fp_precision_t;	

typedef enum em_fp_status_s
{
	EM_FP_STATUS_NONE = 0,
	EM_FP_STATUS_S0   = 1,
	EM_FP_STATUS_S1   = 2,
	EM_FP_STATUS_S2   = 3,
	EM_FP_STATUS_S3   = 4,
	EM_FP_STATUS_LAST = 5
} EM_fp_status_t;

typedef enum EM_decoder_imp_operand
{
	EM_DECODER_IMP_OPERAND_NONE = 0,
	EM_DECODER_IMP_OPERAND_AR_LC,
	EM_DECODER_IMP_OPERAND_RR,
    EM_DECODER_IMP_OPERAND_AR_BSPSTORE,
    EM_DECODER_IMP_OPERAND_APP_REG_GRP_HIGH,
    EM_DECODER_IMP_OPERAND_DTR,
    EM_DECODER_IMP_OPERAND_AR_UNAT,
    EM_DECODER_IMP_OPERAND_CR_IIM,
    EM_DECODER_IMP_OPERAND_PSR,
    EM_DECODER_IMP_OPERAND_CFM,
    EM_DECODER_IMP_OPERAND_CR_IFS,
    EM_DECODER_IMP_OPERAND_CR_ISR,
    EM_DECODER_IMP_OPERAND_AR_BSP,
    EM_DECODER_IMP_OPERAND_AR_RSC,
    EM_DECODER_IMP_OPERAND_AR_EC,
    EM_DECODER_IMP_OPERAND_AR_PFS,
    EM_DECODER_IMP_OPERAND_FPSR,
    EM_DECODER_IMP_OPERAND_APP_CCV,
	EM_DECODER_IMP_OPERAND_PR63,
	EM_DECODER_IMP_OPERAND_DCR,
	EM_DECODER_IMP_OPERAND_CR_IIP,
	EM_DECODER_IMP_OPERAND_IPSR,
	EM_DECODER_IMP_OPERAND_CSD,
	EM_DECODER_IMP_OPERAND_IP,
	EM_DECODER_IMP_OPERAND_EIP,
	EM_DECODER_IMP_OPERAND_MSR_XIP,
	EM_DECODER_IMP_OPERAND_MSR_XPSR,
	EM_DECODER_IMP_OPERAND_MSR_XFS,
    EM_DECODER_IMP_OPERAND_AR_ITC,
    EM_DECODER_IMP_OPERAND_AR_RNAT,
    EM_DECODER_IMP_OPERAND_AR_RCS,
    EM_DECODER_IMP_OPERAND_CR_CMCV,
    EM_DECODER_IMP_OPERAND_CR_EOI,
    EM_DECODER_IMP_OPERAND_CR_GPTA,
    EM_DECODER_IMP_OPERAND_CR_IFA,
    EM_DECODER_IMP_OPERAND_CR_IHA,
    EM_DECODER_IMP_OPERAND_CR_IIPA,
    EM_DECODER_IMP_OPERAND_CR_ITIR,
    EM_DECODER_IMP_OPERAND_CR_ITM,
    EM_DECODER_IMP_OPERAND_CR_ITV,
    EM_DECODER_IMP_OPERAND_CR_IVA,
    EM_DECODER_IMP_OPERAND_CR_IVR,
    EM_DECODER_IMP_OPERAND_CR_LID,
    EM_DECODER_IMP_OPERAND_CR_PMV,
    EM_DECODER_IMP_OPERAND_CR_PTA,
    EM_DECODER_IMP_OPERAND_CR_TPR,
	EM_DECODER_IMP_OPERAND_LAST
} EM_Decoder_Imp_Operand;

typedef enum EM_decoder_err
{ 
    EM_DECODER_NO_ERROR = 0,
	EM_DECODER_INVALID_SLOT_BRANCH_INST,
    EM_DECODER_MUST_BE_GROUP_LAST,
	EM_DECODER_BASE_EQUAL_DEST,
	EM_DECODER_EQUAL_DESTS,
	EM_DECODER_ODD_EVEN_DESTS,
	EM_DECODER_WRITE_TO_ZERO_REGISTER,
	EM_DECODER_WRITE_TO_SPECIAL_FP_REGISTER,
	EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE,
	EM_DECODER_REGISTER_RESERVED_VALUE,
	EM_DECODER_IMMEDIATE_VALUE_OUT_OF_RANGE,
	EM_DECODER_IMMEDIATE_INVALID_VALUE,
	EM_DECODER_STACK_FRAME_SIZE_OUT_OF_RANGE,
	EM_DECODER_LOCALS_SIZE_LARGER_STACK_FRAME,
	EM_DECODER_ROTATING_SIZE_LARGER_STACK_FRAME,
	EM_DECODER_HARD_CODED_PREDICATE_INVALID_VALUE,
	EM_DECODER_FIRST_FATAL_INST_ERROR,
    EM_DECODER_INVALID_PRM_OPCODE = EM_DECODER_FIRST_FATAL_INST_ERROR,
	EM_DECODER_INVALID_INST_SLOT,
	EM_DECODER_FIRST_FATAL_ERROR,
	EM_DECODER_INVALID_TEMPLATE = EM_DECODER_FIRST_FATAL_ERROR,
    EM_DECODER_INVALID_CLIENT_ID,
    EM_DECODER_NULL_PTR,
    EM_DECODER_TOO_SHORT_ERR,
    EM_DECODER_ASSOCIATE_MISS,
    EM_DECODER_INVALID_INST_ID,
    EM_DECODER_INVALID_MACHINE_MODE,
    EM_DECODER_INVALID_MACHINE_TYPE,
    EM_DECODER_INTERNAL_ERROR,
    EM_DECODER_LAST_ERROR
} EM_Decoder_Err;

typedef EM_Decoder_Err DecErr();

typedef enum EM_decoder_machine_type
{ 
    EM_DECODER_CPU_NO_CHANGE=0,
    EM_DECODER_CPU_DEFAULT,
    EM_DECODER_CPU_P7 = 4,
    EM_DECODER_CPU_LAST = 7
} EM_Decoder_Machine_Type;

typedef enum EM_decoder_machine_mode
{
    EM_DECODER_MODE_NO_CHANGE = 0,
    EM_DECODER_MODE_DEFAULT,
	EM_DECODER_MODE_EM = 8,
    EM_DECODER_MODE_LAST = 9
} EM_Decoder_Machine_Mode;

typedef enum EM_decoder_operand_type
{
    EM_DECODER_NO_OPER = 0,
    EM_DECODER_REGISTER,
    EM_DECODER_MEMORY,
    EM_DECODER_IMMEDIATE,
    EM_DECODER_IP_RELATIVE,
	EM_DECODER_REGFILE,
    EM_DECODER_OPERAND_LAST
} EM_Decoder_Operand_Type;

typedef enum EM_decoder_reg_type
{
    EM_DECODER_NO_REG_TYPE = 0,
    EM_DECODER_INT_REG = 7,
    EM_DECODER_FP_REG,
    EM_DECODER_APP_REG,
    EM_DECODER_BR_REG,
    EM_DECODER_PRED_REG = 13,
	EM_DECODER_CR_REG,
	EM_DECODER_APP_CCV_REG,
	EM_DECODER_APP_PFS_REG,
	EM_DECODER_PR_REG,
	EM_DECODER_PR_ROT_REG,
	EM_DECODER_PSR_REG,
	EM_DECODER_PSR_L_REG,
	EM_DECODER_PSR_UM_REG = 20,
	EM_DECODER_IP_REG,            /* IP register type */
    EM_DECODER_REG_TYPE_LAST
} EM_Decoder_Reg_Type;

typedef enum EM_decoder_reg_name
{
    EM_DECODER_NO_REG=0,
    EM_DECODER_REG_R0 = 98,
    EM_DECODER_REG_R1,
    EM_DECODER_REG_R2,
    EM_DECODER_REG_R3,
    EM_DECODER_REG_R4,
    EM_DECODER_REG_R5,
    EM_DECODER_REG_R6,
    EM_DECODER_REG_R7,
    EM_DECODER_REG_R8,
    EM_DECODER_REG_R9,
    EM_DECODER_REG_R10,
    EM_DECODER_REG_R11,
    EM_DECODER_REG_R12,
    EM_DECODER_REG_R13,
    EM_DECODER_REG_R14,
    EM_DECODER_REG_R15,
    EM_DECODER_REG_R16,
    EM_DECODER_REG_R17,
    EM_DECODER_REG_R18,
    EM_DECODER_REG_R19,
    EM_DECODER_REG_R20,
    EM_DECODER_REG_R21,
    EM_DECODER_REG_R22,
    EM_DECODER_REG_R23,
    EM_DECODER_REG_R24,
    EM_DECODER_REG_R25,
    EM_DECODER_REG_R26,
    EM_DECODER_REG_R27,
    EM_DECODER_REG_R28,
    EM_DECODER_REG_R29,
    EM_DECODER_REG_R30,
    EM_DECODER_REG_R31,
    EM_DECODER_REG_R32,
    EM_DECODER_REG_R33,
    EM_DECODER_REG_R34,
    EM_DECODER_REG_R35,
    EM_DECODER_REG_R36,
    EM_DECODER_REG_R37,
    EM_DECODER_REG_R38,
    EM_DECODER_REG_R39,
    EM_DECODER_REG_R40,
    EM_DECODER_REG_R41,
    EM_DECODER_REG_R42,
    EM_DECODER_REG_R43,
    EM_DECODER_REG_R44,
    EM_DECODER_REG_R45,
    EM_DECODER_REG_R46,
    EM_DECODER_REG_R47,
    EM_DECODER_REG_R48,
    EM_DECODER_REG_R49,
    EM_DECODER_REG_R50,
    EM_DECODER_REG_R51,
    EM_DECODER_REG_R52,
    EM_DECODER_REG_R53,
    EM_DECODER_REG_R54,
    EM_DECODER_REG_R55,
    EM_DECODER_REG_R56,
    EM_DECODER_REG_R57,
    EM_DECODER_REG_R58,
    EM_DECODER_REG_R59,
    EM_DECODER_REG_R60,
    EM_DECODER_REG_R61,
    EM_DECODER_REG_R62,
    EM_DECODER_REG_R63,
    EM_DECODER_REG_R64,
    EM_DECODER_REG_R65,
    EM_DECODER_REG_R66,
    EM_DECODER_REG_R67,
    EM_DECODER_REG_R68,
    EM_DECODER_REG_R69,
    EM_DECODER_REG_R70,
    EM_DECODER_REG_R71,
    EM_DECODER_REG_R72,
    EM_DECODER_REG_R73,
    EM_DECODER_REG_R74,
    EM_DECODER_REG_R75,
    EM_DECODER_REG_R76,
    EM_DECODER_REG_R77,
    EM_DECODER_REG_R78,
    EM_DECODER_REG_R79,
    EM_DECODER_REG_R80,
    EM_DECODER_REG_R81,
    EM_DECODER_REG_R82,
    EM_DECODER_REG_R83,
    EM_DECODER_REG_R84,
    EM_DECODER_REG_R85,
    EM_DECODER_REG_R86,
    EM_DECODER_REG_R87,
    EM_DECODER_REG_R88,
    EM_DECODER_REG_R89,
    EM_DECODER_REG_R90,
    EM_DECODER_REG_R91,
    EM_DECODER_REG_R92,
    EM_DECODER_REG_R93,
    EM_DECODER_REG_R94,
    EM_DECODER_REG_R95,
    EM_DECODER_REG_R96,
    EM_DECODER_REG_R97,
    EM_DECODER_REG_R98,
    EM_DECODER_REG_R99,
    EM_DECODER_REG_R100,
    EM_DECODER_REG_R101,
    EM_DECODER_REG_R102,
    EM_DECODER_REG_R103,
    EM_DECODER_REG_R104,
    EM_DECODER_REG_R105,
    EM_DECODER_REG_R106,
    EM_DECODER_REG_R107,
    EM_DECODER_REG_R108,
    EM_DECODER_REG_R109,
    EM_DECODER_REG_R110,
    EM_DECODER_REG_R111,
    EM_DECODER_REG_R112,
    EM_DECODER_REG_R113,
    EM_DECODER_REG_R114,
    EM_DECODER_REG_R115,
    EM_DECODER_REG_R116,
    EM_DECODER_REG_R117,
    EM_DECODER_REG_R118,
    EM_DECODER_REG_R119,
    EM_DECODER_REG_R120,
    EM_DECODER_REG_R121,
    EM_DECODER_REG_R122,
    EM_DECODER_REG_R123,
    EM_DECODER_REG_R124,
    EM_DECODER_REG_R125,
    EM_DECODER_REG_R126,
    EM_DECODER_REG_R127,
    EM_DECODER_REG_F0,
    EM_DECODER_REG_F1,
    EM_DECODER_REG_F2,
    EM_DECODER_REG_F3,
    EM_DECODER_REG_F4,
    EM_DECODER_REG_F5,
    EM_DECODER_REG_F6,
    EM_DECODER_REG_F7,
    EM_DECODER_REG_F8,
    EM_DECODER_REG_F9,
    EM_DECODER_REG_F10,
    EM_DECODER_REG_F11,
    EM_DECODER_REG_F12,
    EM_DECODER_REG_F13,
    EM_DECODER_REG_F14,
    EM_DECODER_REG_F15,
    EM_DECODER_REG_F16,
    EM_DECODER_REG_F17,
    EM_DECODER_REG_F18,
    EM_DECODER_REG_F19,
    EM_DECODER_REG_F20,
    EM_DECODER_REG_F21,
    EM_DECODER_REG_F22,
    EM_DECODER_REG_F23,
    EM_DECODER_REG_F24,
    EM_DECODER_REG_F25,
    EM_DECODER_REG_F26,
    EM_DECODER_REG_F27,
    EM_DECODER_REG_F28,
    EM_DECODER_REG_F29,
    EM_DECODER_REG_F30,
    EM_DECODER_REG_F31,
    EM_DECODER_REG_F32,
    EM_DECODER_REG_F33,
    EM_DECODER_REG_F34,
    EM_DECODER_REG_F35,
    EM_DECODER_REG_F36,
    EM_DECODER_REG_F37,
    EM_DECODER_REG_F38,
    EM_DECODER_REG_F39,
    EM_DECODER_REG_F40,
    EM_DECODER_REG_F41,
    EM_DECODER_REG_F42,
    EM_DECODER_REG_F43,
    EM_DECODER_REG_F44,
    EM_DECODER_REG_F45,
    EM_DECODER_REG_F46,
    EM_DECODER_REG_F47,
    EM_DECODER_REG_F48,
    EM_DECODER_REG_F49,
    EM_DECODER_REG_F50,
    EM_DECODER_REG_F51,
    EM_DECODER_REG_F52,
    EM_DECODER_REG_F53,
    EM_DECODER_REG_F54,
    EM_DECODER_REG_F55,
    EM_DECODER_REG_F56,
    EM_DECODER_REG_F57,
    EM_DECODER_REG_F58,
    EM_DECODER_REG_F59,
    EM_DECODER_REG_F60,
    EM_DECODER_REG_F61,
    EM_DECODER_REG_F62,
    EM_DECODER_REG_F63,
    EM_DECODER_REG_F64,
    EM_DECODER_REG_F65,
    EM_DECODER_REG_F66,
    EM_DECODER_REG_F67,
    EM_DECODER_REG_F68,
    EM_DECODER_REG_F69,
    EM_DECODER_REG_F70,
    EM_DECODER_REG_F71,
    EM_DECODER_REG_F72,
    EM_DECODER_REG_F73,
    EM_DECODER_REG_F74,
    EM_DECODER_REG_F75,
    EM_DECODER_REG_F76,
    EM_DECODER_REG_F77,
    EM_DECODER_REG_F78,
    EM_DECODER_REG_F79,
    EM_DECODER_REG_F80,
    EM_DECODER_REG_F81,
    EM_DECODER_REG_F82,
    EM_DECODER_REG_F83,
    EM_DECODER_REG_F84,
    EM_DECODER_REG_F85,
    EM_DECODER_REG_F86,
    EM_DECODER_REG_F87,
    EM_DECODER_REG_F88,
    EM_DECODER_REG_F89,
    EM_DECODER_REG_F90,
    EM_DECODER_REG_F91,
    EM_DECODER_REG_F92,
    EM_DECODER_REG_F93,
    EM_DECODER_REG_F94,
    EM_DECODER_REG_F95,
    EM_DECODER_REG_F96,
    EM_DECODER_REG_F97,
    EM_DECODER_REG_F98,
    EM_DECODER_REG_F99,
    EM_DECODER_REG_F100,
    EM_DECODER_REG_F101,
    EM_DECODER_REG_F102,
    EM_DECODER_REG_F103,
    EM_DECODER_REG_F104,
    EM_DECODER_REG_F105,
    EM_DECODER_REG_F106,
    EM_DECODER_REG_F107,
    EM_DECODER_REG_F108,
    EM_DECODER_REG_F109,
    EM_DECODER_REG_F110,
    EM_DECODER_REG_F111,
    EM_DECODER_REG_F112,
    EM_DECODER_REG_F113,
    EM_DECODER_REG_F114,
    EM_DECODER_REG_F115,
    EM_DECODER_REG_F116,
    EM_DECODER_REG_F117,
    EM_DECODER_REG_F118,
    EM_DECODER_REG_F119,
    EM_DECODER_REG_F120,
    EM_DECODER_REG_F121,
    EM_DECODER_REG_F122,
    EM_DECODER_REG_F123,
    EM_DECODER_REG_F124,
    EM_DECODER_REG_F125,
    EM_DECODER_REG_F126,
    EM_DECODER_REG_F127,
    EM_DECODER_REG_AR0,
    EM_DECODER_REG_AR1,
    EM_DECODER_REG_AR2,
    EM_DECODER_REG_AR3,
    EM_DECODER_REG_AR4,
    EM_DECODER_REG_AR5,
    EM_DECODER_REG_AR6,
    EM_DECODER_REG_AR7,
    EM_DECODER_REG_AR8,
    EM_DECODER_REG_AR9,
    EM_DECODER_REG_AR10,
    EM_DECODER_REG_AR11,
    EM_DECODER_REG_AR12,
    EM_DECODER_REG_AR13,
    EM_DECODER_REG_AR14,
    EM_DECODER_REG_AR15,
    EM_DECODER_REG_AR16,
    EM_DECODER_REG_AR17,
    EM_DECODER_REG_AR18,
    EM_DECODER_REG_AR19,
    EM_DECODER_REG_AR20,
    EM_DECODER_REG_AR21,
    EM_DECODER_REG_AR22,
    EM_DECODER_REG_AR23,
    EM_DECODER_REG_AR24,
    EM_DECODER_REG_AR25,
    EM_DECODER_REG_AR26,
    EM_DECODER_REG_AR27,
    EM_DECODER_REG_AR28,
    EM_DECODER_REG_AR29,
    EM_DECODER_REG_AR30,
    EM_DECODER_REG_AR31,
    EM_DECODER_REG_AR32,
    EM_DECODER_REG_AR33,
    EM_DECODER_REG_AR34,
    EM_DECODER_REG_AR35,
    EM_DECODER_REG_AR36,
    EM_DECODER_REG_AR37,
    EM_DECODER_REG_AR38,
    EM_DECODER_REG_AR39,
    EM_DECODER_REG_AR40,
    EM_DECODER_REG_AR41,
    EM_DECODER_REG_AR42,
    EM_DECODER_REG_AR43,
    EM_DECODER_REG_AR44,
    EM_DECODER_REG_AR45,
    EM_DECODER_REG_AR46,
    EM_DECODER_REG_AR47,
    EM_DECODER_REG_AR48,
    EM_DECODER_REG_AR49,
    EM_DECODER_REG_AR50,
    EM_DECODER_REG_AR51,
    EM_DECODER_REG_AR52,
    EM_DECODER_REG_AR53,
    EM_DECODER_REG_AR54,
    EM_DECODER_REG_AR55,
    EM_DECODER_REG_AR56,
    EM_DECODER_REG_AR57,
    EM_DECODER_REG_AR58,
    EM_DECODER_REG_AR59,
    EM_DECODER_REG_AR60,
    EM_DECODER_REG_AR61,
    EM_DECODER_REG_AR62,
    EM_DECODER_REG_AR63,
    EM_DECODER_REG_AR64,
    EM_DECODER_REG_AR65,
    EM_DECODER_REG_AR66,
    EM_DECODER_REG_AR67,
    EM_DECODER_REG_AR68,
    EM_DECODER_REG_AR69,
    EM_DECODER_REG_AR70,
    EM_DECODER_REG_AR71,
    EM_DECODER_REG_AR72,
    EM_DECODER_REG_AR73,
    EM_DECODER_REG_AR74,
    EM_DECODER_REG_AR75,
    EM_DECODER_REG_AR76,
    EM_DECODER_REG_AR77,
    EM_DECODER_REG_AR78,
    EM_DECODER_REG_AR79,
    EM_DECODER_REG_AR80,
    EM_DECODER_REG_AR81,
    EM_DECODER_REG_AR82,
    EM_DECODER_REG_AR83,
    EM_DECODER_REG_AR84,
    EM_DECODER_REG_AR85,
    EM_DECODER_REG_AR86,
    EM_DECODER_REG_AR87,
    EM_DECODER_REG_AR88,
    EM_DECODER_REG_AR89,
    EM_DECODER_REG_AR90,
    EM_DECODER_REG_AR91,
    EM_DECODER_REG_AR92,
    EM_DECODER_REG_AR93,
    EM_DECODER_REG_AR94,
    EM_DECODER_REG_AR95,
    EM_DECODER_REG_AR96,
    EM_DECODER_REG_AR97,
    EM_DECODER_REG_AR98,
    EM_DECODER_REG_AR99,
    EM_DECODER_REG_AR100,
    EM_DECODER_REG_AR101,
    EM_DECODER_REG_AR102,
    EM_DECODER_REG_AR103,
    EM_DECODER_REG_AR104,
    EM_DECODER_REG_AR105,
    EM_DECODER_REG_AR106,
    EM_DECODER_REG_AR107,
    EM_DECODER_REG_AR108,
    EM_DECODER_REG_AR109,
    EM_DECODER_REG_AR110,
    EM_DECODER_REG_AR111,
    EM_DECODER_REG_AR112,
    EM_DECODER_REG_AR113,
    EM_DECODER_REG_AR114,
    EM_DECODER_REG_AR115,
    EM_DECODER_REG_AR116,
    EM_DECODER_REG_AR117,
    EM_DECODER_REG_AR118,
    EM_DECODER_REG_AR119,
    EM_DECODER_REG_AR120,
    EM_DECODER_REG_AR121,
    EM_DECODER_REG_AR122,
    EM_DECODER_REG_AR123,
    EM_DECODER_REG_AR124,
    EM_DECODER_REG_AR125,
    EM_DECODER_REG_AR126,
    EM_DECODER_REG_AR127,
    EM_DECODER_REG_P0,
    EM_DECODER_REG_P1,
    EM_DECODER_REG_P2,
    EM_DECODER_REG_P3,
    EM_DECODER_REG_P4,
    EM_DECODER_REG_P5,
    EM_DECODER_REG_P6,
    EM_DECODER_REG_P7,
    EM_DECODER_REG_P8,
    EM_DECODER_REG_P9,
    EM_DECODER_REG_P10,
    EM_DECODER_REG_P11,
    EM_DECODER_REG_P12,
    EM_DECODER_REG_P13,
    EM_DECODER_REG_P14,
    EM_DECODER_REG_P15,
    EM_DECODER_REG_P16,
    EM_DECODER_REG_P17,
    EM_DECODER_REG_P18,
    EM_DECODER_REG_P19,
    EM_DECODER_REG_P20,
    EM_DECODER_REG_P21,
    EM_DECODER_REG_P22,
    EM_DECODER_REG_P23,
    EM_DECODER_REG_P24,
    EM_DECODER_REG_P25,
    EM_DECODER_REG_P26,
    EM_DECODER_REG_P27,
    EM_DECODER_REG_P28,
    EM_DECODER_REG_P29,
    EM_DECODER_REG_P30,
    EM_DECODER_REG_P31,
    EM_DECODER_REG_P32,
    EM_DECODER_REG_P33,
    EM_DECODER_REG_P34,
    EM_DECODER_REG_P35,
    EM_DECODER_REG_P36,
    EM_DECODER_REG_P37,
    EM_DECODER_REG_P38,
    EM_DECODER_REG_P39,
    EM_DECODER_REG_P40,
    EM_DECODER_REG_P41,
    EM_DECODER_REG_P42,
    EM_DECODER_REG_P43,
    EM_DECODER_REG_P44,
    EM_DECODER_REG_P45,
    EM_DECODER_REG_P46,
    EM_DECODER_REG_P47,
    EM_DECODER_REG_P48,
    EM_DECODER_REG_P49,
    EM_DECODER_REG_P50,
    EM_DECODER_REG_P51,
    EM_DECODER_REG_P52,
    EM_DECODER_REG_P53,
    EM_DECODER_REG_P54,
    EM_DECODER_REG_P55,
    EM_DECODER_REG_P56,
    EM_DECODER_REG_P57,
    EM_DECODER_REG_P58,
    EM_DECODER_REG_P59,
    EM_DECODER_REG_P60,
    EM_DECODER_REG_P61,
    EM_DECODER_REG_P62,
    EM_DECODER_REG_P63,
    EM_DECODER_REG_BR0 ,
    EM_DECODER_REG_BR1,
    EM_DECODER_REG_BR2,
    EM_DECODER_REG_BR3,
    EM_DECODER_REG_BR4,
    EM_DECODER_REG_BR5,
    EM_DECODER_REG_BR6,
    EM_DECODER_REG_BR7,
	EM_DECODER_REG_PR,
	EM_DECODER_REG_PR_ROT,
	EM_DECODER_REG_CR0,
	EM_DECODER_REG_CR1,
	EM_DECODER_REG_CR2,
	EM_DECODER_REG_CR3,
	EM_DECODER_REG_CR4,
	EM_DECODER_REG_CR5,
	EM_DECODER_REG_CR6,
	EM_DECODER_REG_CR7,
	EM_DECODER_REG_CR8,
	EM_DECODER_REG_CR9,
	EM_DECODER_REG_CR10,
	EM_DECODER_REG_CR11,
	EM_DECODER_REG_CR12,
	EM_DECODER_REG_CR13,
	EM_DECODER_REG_CR14,
	EM_DECODER_REG_CR15,
	EM_DECODER_REG_CR16,
	EM_DECODER_REG_CR17,
	EM_DECODER_REG_CR18,
	EM_DECODER_REG_CR19,
	EM_DECODER_REG_CR20,
	EM_DECODER_REG_CR21,
	EM_DECODER_REG_CR22,
	EM_DECODER_REG_CR23,
	EM_DECODER_REG_CR24,
	EM_DECODER_REG_CR25,
	EM_DECODER_REG_CR26,
	EM_DECODER_REG_CR27,
	EM_DECODER_REG_CR28,
	EM_DECODER_REG_CR29,
	EM_DECODER_REG_CR30,
	EM_DECODER_REG_CR31,
	EM_DECODER_REG_CR32,
	EM_DECODER_REG_CR33,
	EM_DECODER_REG_CR34,
	EM_DECODER_REG_CR35,
	EM_DECODER_REG_CR36,
	EM_DECODER_REG_CR37,
	EM_DECODER_REG_CR38,
	EM_DECODER_REG_CR39,
	EM_DECODER_REG_CR40,
	EM_DECODER_REG_CR41,
	EM_DECODER_REG_CR42,
	EM_DECODER_REG_CR43,
	EM_DECODER_REG_CR44,
	EM_DECODER_REG_CR45,
	EM_DECODER_REG_CR46,
	EM_DECODER_REG_CR47,
	EM_DECODER_REG_CR48,
	EM_DECODER_REG_CR49,
	EM_DECODER_REG_CR50,
	EM_DECODER_REG_CR51,
	EM_DECODER_REG_CR52,
	EM_DECODER_REG_CR53,
	EM_DECODER_REG_CR54,
	EM_DECODER_REG_CR55,
	EM_DECODER_REG_CR56,
	EM_DECODER_REG_CR57,
	EM_DECODER_REG_CR58,
	EM_DECODER_REG_CR59,
	EM_DECODER_REG_CR60,
	EM_DECODER_REG_CR61,
	EM_DECODER_REG_CR62,
	EM_DECODER_REG_CR63,
	EM_DECODER_REG_CR64,
	EM_DECODER_REG_CR65,
	EM_DECODER_REG_CR66,
	EM_DECODER_REG_CR67,
	EM_DECODER_REG_CR68,
	EM_DECODER_REG_CR69,
	EM_DECODER_REG_CR70,
	EM_DECODER_REG_CR71,
	EM_DECODER_REG_CR72,
	EM_DECODER_REG_CR73,
	EM_DECODER_REG_CR74,
	EM_DECODER_REG_CR75,
	EM_DECODER_REG_CR76,
	EM_DECODER_REG_CR77,
	EM_DECODER_REG_CR78,
	EM_DECODER_REG_CR79,
	EM_DECODER_REG_CR80,
	EM_DECODER_REG_CR81,
	EM_DECODER_REG_CR82,
	EM_DECODER_REG_CR83,
	EM_DECODER_REG_CR84,
	EM_DECODER_REG_CR85,
	EM_DECODER_REG_CR86,
	EM_DECODER_REG_CR87,
	EM_DECODER_REG_CR88,
	EM_DECODER_REG_CR89,
	EM_DECODER_REG_CR90,
	EM_DECODER_REG_CR91,
	EM_DECODER_REG_CR92,
	EM_DECODER_REG_CR93,
	EM_DECODER_REG_CR94,
	EM_DECODER_REG_CR95,
	EM_DECODER_REG_CR96,
	EM_DECODER_REG_CR97,
	EM_DECODER_REG_CR98,
	EM_DECODER_REG_CR99,
	EM_DECODER_REG_CR100,
	EM_DECODER_REG_CR101,
	EM_DECODER_REG_CR102,
	EM_DECODER_REG_CR103,
	EM_DECODER_REG_CR104,
	EM_DECODER_REG_CR105,
	EM_DECODER_REG_CR106,
	EM_DECODER_REG_CR107,
	EM_DECODER_REG_CR108,
	EM_DECODER_REG_CR109,
	EM_DECODER_REG_CR110,
	EM_DECODER_REG_CR111,
	EM_DECODER_REG_CR112,
	EM_DECODER_REG_CR113,
	EM_DECODER_REG_CR114,
	EM_DECODER_REG_CR115,
	EM_DECODER_REG_CR116,
	EM_DECODER_REG_CR117,
	EM_DECODER_REG_CR118,
	EM_DECODER_REG_CR119,
	EM_DECODER_REG_CR120,
	EM_DECODER_REG_CR121,
	EM_DECODER_REG_CR122,
	EM_DECODER_REG_CR123,
	EM_DECODER_REG_CR124,
	EM_DECODER_REG_CR125,
	EM_DECODER_REG_CR126,
	EM_DECODER_REG_CR127,
	EM_DECODER_REG_PSR,
	EM_DECODER_REG_PSR_L,
	EM_DECODER_REG_PSR_UM,
    EM_DECODER_REG_IP,      /* register IP name */ 
	EM_DECODER_EM_REG_LAST,

	EM_DECODER_REG_AR_K0   = EM_DECODER_REG_AR0+EM_AR_KR0,
	EM_DECODER_REG_AR_K1   = EM_DECODER_REG_AR0+EM_AR_KR1,
	EM_DECODER_REG_AR_K2   = EM_DECODER_REG_AR0+EM_AR_KR2,
	EM_DECODER_REG_AR_K3   = EM_DECODER_REG_AR0+EM_AR_KR3,
	EM_DECODER_REG_AR_K4   = EM_DECODER_REG_AR0+EM_AR_KR4, /* added AR_K4-7 */
	EM_DECODER_REG_AR_K5   = EM_DECODER_REG_AR0+EM_AR_KR5,
	EM_DECODER_REG_AR_K6   = EM_DECODER_REG_AR0+EM_AR_KR6,
	EM_DECODER_REG_AR_K7   = EM_DECODER_REG_AR0+EM_AR_KR7,
	EM_DECODER_REG_AR_RSC  = EM_DECODER_REG_AR0+EM_AR_RSC,
	EM_DECODER_REG_AR_BSP  = EM_DECODER_REG_AR0+EM_AR_BSP,
	EM_DECODER_REG_AR_BSPSTORE = EM_DECODER_REG_AR0+EM_AR_BSPSTORE,
	EM_DECODER_REG_AR_RNAT = EM_DECODER_REG_AR0+EM_AR_RNAT,
	EM_DECODER_REG_AR_EFLAG= EM_DECODER_REG_AR0+EM_AR_EFLAG,
   	EM_DECODER_REG_AR_CSD  = EM_DECODER_REG_AR0+EM_AR_CSD,
	EM_DECODER_REG_AR_SSD  = EM_DECODER_REG_AR0+EM_AR_SSD,
	EM_DECODER_REG_AR_CFLG = EM_DECODER_REG_AR0+EM_AR_CFLG,
	EM_DECODER_REG_AR_FSR  = EM_DECODER_REG_AR0+EM_AR_FSR,
	EM_DECODER_REG_AR_FIR  = EM_DECODER_REG_AR0+EM_AR_FIR,
	EM_DECODER_REG_AR_FDR  = EM_DECODER_REG_AR0+EM_AR_FDR,
	EM_DECODER_REG_AR_CCV  = EM_DECODER_REG_AR0+EM_AR_CCV,
	EM_DECODER_REG_AR_UNAT = EM_DECODER_REG_AR0+EM_AR_UNAT,
	EM_DECODER_REG_AR_FPSR = EM_DECODER_REG_AR0+EM_AR_FPSR,
	EM_DECODER_REG_AR_ITC  = EM_DECODER_REG_AR0+EM_AR_ITC,	
	EM_DECODER_REG_AR_PFS  = EM_DECODER_REG_AR0+EM_AR_PFS,
	EM_DECODER_REG_AR_LC   = EM_DECODER_REG_AR0+EM_AR_LC,
	EM_DECODER_REG_AR_EC   = EM_DECODER_REG_AR0+EM_AR_EC,

	EM_DECODER_REG_CR_DCR  = EM_DECODER_REG_CR0+EM_CR_DCR,
	EM_DECODER_REG_CR_ITM  = EM_DECODER_REG_CR0+EM_CR_ITM,
	EM_DECODER_REG_CR_IVA  = EM_DECODER_REG_CR0+EM_CR_IVA,
	EM_DECODER_REG_CR_PTA  = EM_DECODER_REG_CR0+EM_CR_PTA,
	EM_DECODER_REG_CR_GPTA = EM_DECODER_REG_CR0+EM_CR_GPTA,
	EM_DECODER_REG_CR_IPSR = EM_DECODER_REG_CR0+EM_CR_IPSR,
	EM_DECODER_REG_CR_ISR  = EM_DECODER_REG_CR0+EM_CR_ISR,
	EM_DECODER_REG_CR_IIP  = EM_DECODER_REG_CR0+EM_CR_IIP,
	EM_DECODER_REG_CR_IFA  = EM_DECODER_REG_CR0+EM_CR_IFA,
	EM_DECODER_REG_CR_ITIR = EM_DECODER_REG_CR0+EM_CR_ITIR,
	EM_DECODER_REG_CR_IIPA = EM_DECODER_REG_CR0+EM_CR_IIPA,
	EM_DECODER_REG_CR_IFS  = EM_DECODER_REG_CR0+EM_CR_IFS,
	EM_DECODER_REG_CR_IIM  = EM_DECODER_REG_CR0+EM_CR_IIM,
	EM_DECODER_REG_CR_IHA  = EM_DECODER_REG_CR0+EM_CR_IHA,

	EM_DECODER_REG_CR_LID  = EM_DECODER_REG_CR0+EM_CR_LID,
	EM_DECODER_REG_CR_IVR  = EM_DECODER_REG_CR0+EM_CR_IVR,
	EM_DECODER_REG_CR_TPR  = EM_DECODER_REG_CR0+EM_CR_TPR,
	EM_DECODER_REG_CR_EOI  = EM_DECODER_REG_CR0+EM_CR_EOI,
	EM_DECODER_REG_CR_IRR0 = EM_DECODER_REG_CR0+EM_CR_IRR0,
	EM_DECODER_REG_CR_IRR1 = EM_DECODER_REG_CR0+EM_CR_IRR1,
	EM_DECODER_REG_CR_IRR2 = EM_DECODER_REG_CR0+EM_CR_IRR2,
	EM_DECODER_REG_CR_IRR3 = EM_DECODER_REG_CR0+EM_CR_IRR3,
	EM_DECODER_REG_CR_ITV  = EM_DECODER_REG_CR0+EM_CR_ITV,
	EM_DECODER_REG_CR_PMV  = EM_DECODER_REG_CR0+EM_CR_PMV,
	EM_DECODER_REG_CR_LRR0 = EM_DECODER_REG_CR0+EM_CR_LRR0,
	EM_DECODER_REG_CR_LRR1 = EM_DECODER_REG_CR0+EM_CR_LRR1,
	EM_DECODER_REG_CR_CMCV = EM_DECODER_REG_CR0+EM_CR_CMCV,
		
/************************************************************/
    EM_DECODER_REG_LAST
} EM_Decoder_Reg_Name;

typedef struct EM_decoder_reg_info
{
    int                  valid;
    EM_Decoder_Reg_Type  type;
    EM_Decoder_Reg_Name  name;
    long                 value;
} EM_Decoder_Reg_Info;

typedef enum EM_DECODER_regfile_name
{
	EM_DECODER_NO_REGFILE = 0,
	EM_DECODER_REGFILE_PMC,
	EM_DECODER_REGFILE_PMD,
	EM_DECODER_REGFILE_PKR,
	EM_DECODER_REGFILE_RR,
	EM_DECODER_REGFILE_IBR,
	EM_DECODER_REGFILE_DBR,
	EM_DECODER_REGFILE_ITR,
	EM_DECODER_REGFILE_DTR,
	EM_DECODER_REGFILE_MSR,
	EM_DECODER_REGFILE_CPUID,
	EM_DECODER_REGFILE_LAST
} EM_Decoder_Regfile_Name;

typedef enum EM_decoder_operand_2nd_role
{
    EM_DECODER_OPER_2ND_ROLE_NONE = 0,
    EM_DECODER_OPER_2ND_ROLE_SRC,
    EM_DECODER_OPER_2ND_ROLE_DST
} EM_Decoder_Operand_2nd_Role;

typedef enum EM_decoder_oper_size
{
    EM_DECODER_OPER_NO_SIZE =  0,
    EM_DECODER_OPER_SIZE_1 =   1,
    EM_DECODER_OPER_SIZE_2 =   2,
    EM_DECODER_OPER_SIZE_4 =   4,
    EM_DECODER_OPER_SIZE_8 =   8,
    EM_DECODER_OPER_SIZE_10 = 10,
    EM_DECODER_OPER_SIZE_16 = 16,
    EM_DECODER_OPER_SIZE_20 = 20,
    EM_DECODER_OPER_SIZE_22 = 22,
    EM_DECODER_OPER_SIZE_24 = 24,  
    EM_DECODER_OPER_SIZE_32 = 32,
    EM_DECODER_OPER_SIZE_64 = 64
} EM_Decoder_Oper_Size;

typedef enum EM_decoder_imm_type
{
	EM_DECODER_IMM_NONE,
	EM_DECODER_IMM_SIGNED,
	EM_DECODER_IMM_UNSIGNED,
	EM_DECODER_IMM_FCLASS,
	EM_DECODER_IMM_MUX1,
	EM_DECODER_IMM_LAST
} EM_Decoder_Imm_Type;

typedef enum EM_decoder_slot
{
	EM_DECODER_SLOT_0 = 0,
	EM_DECODER_SLOT_1 = 1,
	EM_DECODER_SLOT_2 = 2,
	EM_DECODER_SLOT_LAST = 2
} EM_Decoder_Slot;


/***** EM_decoder Structure Defenition ****/

typedef struct EM_decoder_modifiers_s
{
	EM_cmp_type_t           cmp_type;
	EM_cmp_rel_t            cmp_rel;
	EM_branch_type_t        branch_type;
	EM_branch_hint_t        branch_hint;
	EM_fp_precision_t       fp_precision;
	EM_fp_status_t          fp_status;
	EM_memory_access_hint_t mem_access_hint;
} EM_Decoder_modifiers_t;	


typedef struct EM_decoder_oper_static_s
{
	Operand_role_t role;
	Operand_type_t type;
	unsigned long  flags;
} EM_Decoder_oper_static_t;


#define EM_DECODER_MAX_EXP_DST (2)
#define EM_DECODER_MAX_EXP_SRC (5)
#define EM_DECODER_MAX_IMP_DST (8)
#define EM_DECODER_MAX_IMP_SRC (8)

typedef struct EM_decoder_static_info_s
{
	Mnemonic_t               mnemonic;
	Template_role_t          template_role;
	EM_Decoder_oper_static_t explicit_dst[EM_DECODER_MAX_EXP_DST];
	EM_Decoder_oper_static_t explicit_src[EM_DECODER_MAX_EXP_SRC];
	EM_Decoder_imp_oper_t    implicit_dst[EM_DECODER_MAX_IMP_DST];
	EM_Decoder_imp_oper_t    implicit_src[EM_DECODER_MAX_IMP_SRC];
	EM_Decoder_modifiers_t   modifiers;
	Flags_t                  flags;
} EM_Decoder_static_info_t;


extern const EM_Decoder_static_info_t em_decoder_static_info[];


typedef struct EM_decoder_regfile_info
{
    EM_Decoder_Regfile_Name  name;
    EM_Decoder_Reg_Info      index;
} EM_Decoder_Regfile_Info;


typedef struct EM_decoder_imm_info
{
    EM_Decoder_Imm_Type  imm_type;
    unsigned int         size;
    U64                  val64;
} EM_Decoder_Imm_Info;

typedef struct EM_decoder_mem_info
{
    EM_Decoder_Reg_Info    mem_base;
    EM_Decoder_Oper_Size   size;
} EM_Decoder_Mem_Info;

typedef struct em_decoder_em_bundle_info
{
	EM_template_t           b_template;
	unsigned long		    flags;
} EM_Decoder_EM_Bundle_Info;

typedef struct em_decoder_em_info
{
	EM_Decoder_EM_Bundle_Info  em_bundle_info;
	EM_Decoder_Slot            slot_no;
	Template_role_t            eut;
	unsigned long              em_flags;
} EM_Decoder_EM_Info;

typedef struct EM_decoder_inst_static_info
{
    void *                client_info;
	const EM_Decoder_static_info_t *static_info;
    unsigned long         flags;
} EM_Decoder_Inst_Static_Info;


typedef struct EM_decoder_operand_info
{
    EM_Decoder_Operand_Type     type;
	EM_Decoder_Regfile_Info     regfile_info;
    EM_Decoder_Reg_Info         reg_info;
    EM_Decoder_Mem_Info         mem_info;
    EM_Decoder_Imm_Info         imm_info;
    long                        ip_relative_offset;
    unsigned long               oper_flags;
} EM_Decoder_Operand_Info;


typedef struct em_decoder_info
{
    EM_Decoder_Inst_Id       inst;
    EM_Decoder_Reg_Info      pred;
    EM_Decoder_Operand_Info  src1;
    EM_Decoder_Operand_Info  src2;
    EM_Decoder_Operand_Info  src3;
    EM_Decoder_Operand_Info  src4;
    EM_Decoder_Operand_Info  src5;
    EM_Decoder_Operand_Info  dst1;
    EM_Decoder_Operand_Info  dst2;
	EM_Decoder_EM_Info       EM_info;
    void *                   client_info;
    unsigned long            flags;
    unsigned char            size;
	const EM_Decoder_static_info_t *static_info;
} EM_Decoder_Info;


typedef struct em_decoder_bundle_info
{
	unsigned int          	    inst_num;
	EM_Decoder_EM_Bundle_Info	em_bundle_info;
	EM_Decoder_Err           	error[3];
	EM_Decoder_Info          	inst_info[3];
} EM_Decoder_Bundle_Info;
	

typedef int EM_Decoder_Id;


/***********************************************/
/***          Setup flags                    ***/
/***********************************************/
  
#define EM_DECODER_FLAG_NO_MEMSET       0X00000001


extern const U32 em_decoder_bundle_size;

EM_Decoder_Id  em_decoder_open(void);

EM_Decoder_Err em_decoder_associate_one(const EM_Decoder_Id		 id,
								   const EM_Decoder_Inst_Id	     inst,
								   const void                  * client_info);

EM_Decoder_Err em_decoder_associate_check(const EM_Decoder_Id    id,
									       EM_Decoder_Inst_Id  * inst);

EM_Decoder_Err em_decoder_setenv(const EM_Decoder_Id,
                           const EM_Decoder_Machine_Type,
                           const EM_Decoder_Machine_Mode);

EM_Decoder_Err em_decoder_setup(const EM_Decoder_Id,
                           const EM_Decoder_Machine_Type,
                           const EM_Decoder_Machine_Mode,
						   unsigned long flags);

EM_Decoder_Err em_decoder_close(const EM_Decoder_Id);

EM_Decoder_Err em_decoder_decode(const EM_Decoder_Id    id,
						         const unsigned char  * code,
						         const int			    max_code_size,
						         const EM_IL		    location,
						         EM_Decoder_Info      * decoder_info);

 EM_Decoder_Err em_decoder_inst_static_info(const  EM_Decoder_Id,
                                            const  EM_Decoder_Inst_Id,
                                            EM_Decoder_Inst_Static_Info *);

 const char* em_decoder_ver_str(void);

 void  em_decoder_get_version(EM_library_version_t  * dec_version);

 const char* em_decoder_err_msg(EM_Decoder_Err error);

 EM_Decoder_Err em_decoder_decode_bundle(const EM_Decoder_Id        id,
								         const unsigned char      * code,
								         const int                  max_size,
								         EM_Decoder_Bundle_Info   * bundle_info);

/**********************  GET next IL  *************************/
#define EM_DECODER_NEXT(IL, decoder_info)                       \
{                                                               \
	U32 rem_size;												\
	int slot_no = EM_IL_GET_SLOT_NO(IL),						\
	    size = (decoder_info)->size;							\
	switch (slot_no)											\
	{															\
	  case 0:													\
		break;													\
	  case 1:													\
		if (size < 2)											\
			break;		/*** else fall-through ***/				\
	  case 2:													\
		size = EM_BUNDLE_SIZE - slot_no;						\
	}															\
	IEL_CONVERT1(rem_size, size);								\
	IEL_ADDU(IL, IL, rem_size);                                 \
}

#define EM_DECODER_BUNDLE_NEXT(addr)          	                \
{                                                               \
	IEL_ADDU(addr, addr, em_decoder_bundle_size);               \
}


#define EM_DECODER_ERROR_IS_FATAL(_Err)          \
     ((_Err) >= EM_DECODER_FIRST_FATAL_ERROR)

#define EM_DECODER_ERROR_IS_INST_FATAL(_Err)      \
     (((_Err) >= EM_DECODER_FIRST_FATAL_INST_ERROR) && ((_Err) < EM_DECODER_FIRST_FATAL_ERROR))


/*************   EM Instruction Flags Related Macros   ***************/

/*** EM_decoder and static infos flags ***/

/* Flags that copied directly from EMDB */

#define EM_DECODER_BIT_PREDICATE          EM_FLAG_PRED               /* The instruction can get pred  */
#define EM_DECODER_BIT_PRIVILEGED         EM_FLAG_PRIVILEGED         /* The instruction is privileged */
#define EM_DECODER_BIT_LMEM               EM_FLAG_LMEM               /* The instuction is a load inst */
#define EM_DECODER_BIT_SMEM               EM_FLAG_SMEM               /* The instruction is a store    */
#define EM_DECODER_BIT_CHECK_BASE_EQ_DST  EM_FLAG_CHECK_BASE_EQ_DST  /* Base value must differ from destination's */
#define EM_DECODER_BIT_GROUP_FIRST        EM_FLAG_FIRST_IN_INSTRUCTION_GROUP /* Instruction must be the first in instruction group */
#define EM_DECODER_BIT_GROUP_LAST         EM_FLAG_LAST_IN_INSTRUCTION_GROUP  /* Instruction must be the last in instruction group */
#define EM_DECODER_BIT_CHECK_SAME_DSTS    EM_FLAG_CHECK_SAME_DSTS    /* Two destinations should have different values */
#define EM_DECODER_BIT_SLOT2_ONLY         EM_FLAG_SLOT2_ONLY         /* The instruction is allowed in the last slot of bundle */
#define EM_DECODER_BIT_TWO_SLOT           EM_FLAG_TWO_SLOT           /* The instruction is long (2 slots length) */
#define EM_DECODER_BIT_OK_IN_MLX          EM_FLAG_OK_IN_MLX
#define EM_DECODER_BIT_CHECK_EVEN_ODD_FREGS EM_FLAG_CHECK_EVEN_ODD_FREGS
#define EM_DECODER_BIT_CTYPE_UNC          EM_FLAG_CTYPE_UNC          /* If two destinations are equal the instruction
																		allways causes illegal operation fault */
#define EM_DECODER_BIT_UNUSED_HINT_ALIAS  EM_FLAG_UNUSED_HINT_ALIAS
#define EM_DECODER_BIT_ILLEGAL_OP		  EM_FLAG_ILLEGAL_OP
#define EM_DECODER_BIT_IGNORED_OP		  EM_FLAG_IGNORED_OP
#define EM_DECODER_BIT_ENDS_GROUP		  EM_FLAG_ENDS_INSTRUCTION_GROUP
 
 /* Others */
#define EM_DECODER_BIT_SPECULATION        (EMDB_LAST_FLAG << 1)      /* Speculative form of instruction */
#define EM_DECODER_BIT_POSTINCREMENT      (EMDB_LAST_FLAG << 2)      /* Post increment form of instruction */
#define EM_DECODER_BIT_FALSE_PRED_EXEC    (EMDB_LAST_FLAG << 3)      /* Instruction executed when predicate is false */
#define EM_DECODER_BIT_BR_HINT            (EMDB_LAST_FLAG << 4)      /* Branch-hint form of instruction */ 
#define EM_DECODER_BIT_BR                 (EMDB_LAST_FLAG << 5)      /* Branch instruction              */
#define EM_DECODER_BIT_ADV_LOAD           (EMDB_LAST_FLAG << 6)      /* Instruction is an advanced or speculative advanced load */
#define EM_DECODER_BIT_CONTROL_TRANSFER   (EMDB_LAST_FLAG << 7)      /* Instruction violates sequential control flow */
#define EM_DECODER_BIT_UNC_ILLEGAL_FAULT  (EMDB_LAST_FLAG << 8)      /* Illegal opcode causes illegal operation fault 
                                                                        undependent on predicate value */
 
/* Flags that depend on the current bundle encoding */

/* in em_flags: */
#define EM_DECODER_BIT_CYCLE_BREAK 0x10000 /*Inst is last in its group */
#define EM_DECODER_BIT_LAST_INST   0x20000 /*Last instruction in bundle   */

/* Static flags (depend only on inst id) */
 
#define EM_DECODER_BIT_LONG_INST   0x40000 /* 2 slots Inst */

/* in em_bundle_info flags */
#define EM_DECODER_BIT_BUNDLE_STOP 0x80000 /*Stop bit is set in bundle*/


#define EM_DECODER_PREDICATE(di)                (EM_DECODER_BIT_PREDICATE & ((di)->flags))
#define EM_DECODER_PRIVILEGED(di)               (EM_DECODER_BIT_PRIVILEGED & ((di)->flags))
#define EM_DECODER_LMEM(di)                     (EM_DECODER_BIT_LMEM & ((di)->flags))      
#define EM_DECODER_SMEM(di)                     (EM_DECODER_BIT_SMEM & ((di)->flags))
#define EM_DECODER_CHECK_BASE_EQ_DST(di)        (EM_DECODER_BIT_CHECK_BASE_EQ_DST & ((di)->flags))
#define EM_DECODER_CHECK_SPECULATION(di)        (EM_DECODER_BIT_SPECULATION & ((di)->flags))
#define EM_DECODER_CHECK_POSTINCREMENT(di)      (EM_DECODER_BIT_POSTINCREMENT & ((di)->flags))
#define EM_DECODER_CHECK_FALSE_PRED_EXEC(di)    (EM_DECODER_BIT_FALSE_PRED_EXEC & ((di)->flags))
#define EM_DECODER_CHECK_BR_HINT(di)            (EM_DECODER_BIT_BR_HINT & ((di)->flags))
#define EM_DECODER_CHECK_BR(di)                 (EM_DECODER_BIT_BR & ((di)->flags))
#define EM_DECODER_CHECK_GROUP_FIRST(di)        (EM_DECODER_BIT_GROUP_FIRST & ((di)->flags))
#define EM_DECODER_CHECK_GROUP_LAST(di)         (EM_DECODER_BIT_GROUP_LAST & ((di)->flags))
#define EM_DECODER_CHECK_SAME_DSTS(di)          (EM_DECODER_BIT_CHECK_SAME_DSTS & ((di)->flags))
#define EM_DECODER_CHECK_SLOT2_ONLY(di)         (EM_DECODER_BIT_SLOT2_ONLY & ((di)->flags))
#define EM_DECODER_CHECK_TWO_SLOT(di)           (EM_DECODER_BIT_TWO_SLOT & ((di)->flags))
#define EM_DECODER_CHECK_ADV_LOAD(di)           (EM_DECODER_BIT_ADV_LOAD & ((di)->flags))
#define EM_DECODER_CHECK_CONTROL_TRANSFER(di)   (EM_DECODER_BIT_CONTROL_TRANSFER & ((di)->flags))
#define EM_DECODER_CHECK_UNC_ILLEGAL_FAULT(di)  (EM_DECODER_BIT_CTYPE_UNC & ((di)->flags))
#define EM_DECODER_CHECK_OK_IN_MLX(di)          (EM_DECODER_BIT_OK_IN_MLX & ((di)->flags))
#define EM_DECODER_CHECK_UNUSED_HINT_ALIAS(di)	(EM_DECODER_BIT_UNUSED_HINT_ALIAS & ((di)->flags))
#define EM_DECODER_CHECK_ILLEGAL_OP(di)			(EM_DECODER_BIT_ILLEGAL_OP & ((di)->flags))
#define EM_DECODER_CHECK_IGNORED_OP(di)			(EM_DECODER_BIT_IGNORED_OP & ((di)->flags))
#define EM_DECODER_CHECK_ENDS_GROUP(di)			(EM_DECODER_BIT_ENDS_GROUP & ((di)->flags))


#define EM_DECODER_LONG_INST(di)   		\
		(EM_DECODER_BIT_LONG_INST & (((di)->EM_info).em_flags))

#define EM_DECODER_LAST_INST(di)  				\
		(EM_DECODER_BIT_LAST_INST & (((di)->EM_info).em_flags))

#define EM_DECODER_CYCLE_BREAK(di) 		\
		(EM_DECODER_BIT_CYCLE_BREAK & (((di)->EM_info).em_flags))

#define EM_DECODER_BUNDLE_STOP(di) 		\
		(EM_DECODER_BIT_BUNDLE_STOP & 	\
		 (((di)->EM_info).em_bundle_info.flags))



/************** Operand Related macros ****************/
									
#define EM_DECODER_OPER_2ND_ROLE_SRC_BIT  0x00000001  /* Oper second role:  src */
#define EM_DECODER_OPER_2ND_ROLE_DST_BIT  0x00000002  /* Oper second role: dest */
#define EM_DECODER_OPER_IMM_IREG_BIT      0x00000040  /* Operand type is IREG_NUM */
#define EM_DECODER_OPER_IMM_FREG_BIT      0x00000080  /* Operand type is FREG_NUM */

#define EM_DECODER_OPER_2ND_ROLE_SRC(oi)                                         \
							(((oi)->oper_flags) & EM_DECODER_OPER_2ND_ROLE_SRC_BIT)
#define EM_DECODER_OPER_2ND_ROLE_DST(oi)                                         \
							(((oi)->oper_flags) & EM_DECODER_OPER_2ND_ROLE_DST_BIT)
#define EM_DECODER_OPER_NOT_TRUE_SRC(oi)                                         \
							(((oi)->oper_flags) & EM_DECODER_OPER_NOT_TRUE_SRC_BIT)
#define EM_DECODER_OPER_IMP_ENCODED(oi)                                          \
							(((oi)->oper_flags) & EM_DECODER_OPER_IMP_ENCODED_BIT)

#define EM_DECODER_OPER_IMM_REG(oi) 		                                    \
	(((oi)->oper_flags) & (EM_DECODER_OPER_IMM_IREG_BIT |						\
						   EM_DECODER_OPER_IMM_FREG_BIT))

#define EM_DECODER_OPER_IMM_IREG(oi)                                     \
							(((oi)->oper_flags) & EM_DECODER_OPER_IMM_IREG_BIT)
#define EM_DECODER_OPER_IMM_FREG(oi)                                     \
							(((oi)->oper_flags) & EM_DECODER_OPER_IMM_FREG_BIT)



/************* EM_decoder Static Info Related macros ************/

/****** Macros receive pointer to modifiers ******/

#define EM_DECODER_MODIFIERS_CMP_TYPE(Mo) \
                            ((Mo)->cmp_type)

#define EM_DECODER_MODIFIERS_CMP_REL(Mo) \
                            ((Mo)->cmp_rel)

#define EM_DECODER_MODIFIERS_BRANCH_TYPE(Mo) \
                            ((Mo)->branch_type)

#define EM_DECODER_MODIFIERS_BRANCH_HINT(Mo) \
                            ((Mo)->branch_hint)
 
#define EM_DECODER_MODIFIERS_FP_PRECISION(Mo) \
                            ((Mo)->fp_precision)

#define EM_DECODER_MODIFIERS_FP_STATUS(Mo) \
                            ((Mo)->fp_status)

#define EM_DECODER_MODIFIERS_MEMORY_ACCESS_HINT(Mo) \
                            ((Mo)->mem_access_hint)


/****** Macros receive operand flags value ******/

#define EM_DECODER_OPER_FLAGS_2ND_ROLE_SRC(of) \
							((of) & EM_DECODER_OPER_2ND_ROLE_SRC_BIT)

#define EM_DECODER_OPER_FLAGS_2ND_ROLE_DST(of) \
                            ((of) & EM_DECODER_OPER_2ND_ROLE_DST_BIT)

#define EM_DECODER_OPER_FLAGS_IMM_REG(of) \
            	            ((of) & (EM_DECODER_OPER_IMM_IREG_BIT | \
						    EM_DECODER_OPER_IMM_FREG_BIT))

#define EM_DECODER_OPER_FLAGS_IMM_IREG(of) \
							((of) & EM_DECODER_OPER_IMM_IREG_BIT)

#define EM_DECODER_OPER_FLAGS_IMM_FREG(of) \
							((of) & EM_DECODER_OPER_IMM_FREG_BIT)


/****** Macros receive pointer to operand ******/

#define EM_DECODER_OPER_STAT_2ND_ROLE_SRC(oi) \
							EM_DECODER_OPER_FLAGS_2ND_ROLE_SRC((oi)->flags)

#define EM_DECODER_OPER_STAT_2ND_ROLE_DST(oi) \
                            EM_DECODER_OPER_FLAGS_2ND_ROLE_DST((oi)->flags)

#define EM_DECODER_OPER_STAT_IMM_REG(oi) \
                            EM_DECODER_OPER_FLAGS_IMM_REG((oi)->flags)

#define EM_DECODER_OPER_STAT_IMM_BREG(oi) \
							EM_DECODER_OPER_FLAGS_IMM_BREG((oi)->flags)

#define EM_DECODER_OPER_STAT_IMM_IREG(oi) \
							EM_DECODER_OPER_FLAGS_IMM_IREG((oi)->flags)
												  

#define EM_DECODER_OPER_STAT_IMM_FREG(oi) \
							EM_DECODER_OPER_FLAGS_IMM_FREG((oi)->flags)



#define EM_DECODER_OPER_ROLE(oi) \
                            ((oi)->role)

#define EM_DECODER_OPER_TYPE(oi) \
                            ((oi)->type)

#define EM_DECODER_OPER_FLAGS(oi) \
                            ((oi)->flags)


/****** Macros receive instruction flags value ******/

#define EM_DECODER_FLAGS_FLAG_PRED(if) \
                            ((if) & EM_DECODER_BIT_PREDICATE)

#define EM_DECODER_FLAGS_FLAG_PRIVILEGED(if) \
                            ((if) & EM_DECODER_BIT_PRIVILEGED)

#define EM_DECODER_FLAGS_FLAG_LMEM(if) \
                            ((if) & EM_DECODER_BIT_LMEM)

#define EM_DECODER_FLAGS_FLAG_SMEM(if) \
                            ((if) & EM_DECODER_BIT_SMEM)

#define EM_DECODER_FLAGS_FLAG_CHECK_BASE_EQ_DST(if) \
                            ((if) & EM_DECODER_BIT_CHECK_BASE_EQ_DST)

#define EM_DECODER_FLAGS_FLAG_SPECULATION(if) \
                            ((if) & EM_DECODER_BIT_SPECULATION)

#define EM_DECODER_FLAGS_FLAG_POSTINCREMENT(if) \
                            ((if) & EM_DECODER_BIT_POSTINCREMENT)

#define EM_DECODER_FLAGS_FLAG_FALSE_PRED_EXEC(if) \
                            ((if) & EM_DECODER_BIT_FALSE_PRED_EXEC)

#define EM_DECODER_FLAGS_FLAG_BR_HINT(if) \
                            ((if) & EM_DECODER_BIT_BR_HINT)

#define EM_DECODER_FLAGS_FLAG_BR(if) \
                            ((if) & EM_DECODER_BIT_BR)

#define EM_DECODER_FLAGS_FLAG_ADV_LOAD(if) \
                            ((if) & EM_DECODER_CHECK_ADV_LOAD)

#define EM_DECODER_FLAGS_FLAG_GROUP_FIRST(if) \
                            ((if) & EM_DECODER_BIT_GROUP_FIRST)

#define EM_DECODER_FLAGS_FLAG_GROUP_LAST(if) \
                            ((if) & EM_DECODER_BIT_GROUP_LAST)

#define EM_DECODER_FLAGS_FLAG_CHECK_SAME_DSTS(if) \
                            ((if) & EM_DECODER_BIT_CHECK_SAME_DSTS)

#define EM_DECODER_FLAGS_FLAG_CONTROL_TRANSFER(if) \
                            ((if) & EM_DECODER_BIT_CONTROL_TRANSFER)

#define EM_DECODER_FLAGS_FLAG_UNUSED_HINT_ALIAS(if) \
							((if) & EM_DECODER_BIT_UNUSED_HINT_ALIAS)

#define EM_DECODER_FLAGS_FLAG_ILLEGAL_OP(if) \
							((if) & EM_DECODER_BIT_ILLEGAL_OP)

#define EM_DECODER_FLAGS_FLAG_IGNORED_OP(if) \
							((if) & EM_DECODER_BIT_IGNORED_OP)

#define EM_DECODER_FLAGS_FLAG_ENDS_GROUP(if) \
							((if) & EM_DECODER_BIT_ENDS_GROUP)


/****** Macros receive pointer to EM_decoder static info ******/

#define EM_DECODER_STATIC_MNEMONIC(si) \
                            ((si)->mnemonic)

#define EM_DECODER_STATIC_TEMPLATE_ROLE(si) \
                            ((si)->template_role)


#define EM_DECODER_STATIC_EXP_DST_ROLE(si, n) \
                            EM_DECODER_OPER_ROLE(((si)->explicit_dst) + (n))

#define EM_DECODER_STATIC_EXP_DST_TYPE(si, n) \
                            EM_DECODER_OPER_TYPE(((si)->explicit_dst) + (n))

#define EM_DECODER_STATIC_EXP_DST_FLAGS(si, n) \
                            EM_DECODER_OPER_FLAGS(((si)->explicit_dst) + (n))

#define EM_DECODER_STATIC_EXP_SRC_ROLE(si, n) \
                            EM_DECODER_OPER_ROLE(((si)->explicit_src) + (n))

#define EM_DECODER_STATIC_EXP_SRC_TYPE(si, n) \
                            EM_DECODER_OPER_TYPE(((si)->explicit_src) + (n))

#define EM_DECODER_STATIC_EXP_SRC_FLAGS(si, n) \
                            EM_DECODER_OPER_FLAGS(((si)->explicit_src) + (n))


#define EM_DECODER_STATIC_IMP_DST(si, n) \
                            ((si)->implicit_dst[(n)])

#define EM_DECODER_STATIC_IMP_SRC(si, n) \
                            ((si)->implicit_src[(n)])


#define EM_DECODER_STATIC_CMP_TYPE(si) \
                            EM_DECODER_MODIFIERS_CMP_TYPE(&((si)->modifiers))

#define EM_DECODER_STATIC_CMP_REL(si) \
                            EM_DECODER_MODIFIERS_CMP_REL(&((si)->modifiers))

#define EM_DECODER_STATIC_BRANCH_TYPE(si) \
                            EM_DECODER_MODIFIERS_BRANCH_TYPE(&((si)->modifiers))

#define EM_DECODER_STATIC_BRANCH_HINT(si) \
                            EM_DECODER_MODIFIERS_BRANCH_HINT(&((si)->modifiers))

#define EM_DECODER_STATIC_FP_PRECISION(si) \
                            EM_DECODER_MODIFIERS_FP_PRECISION(&((si)->modifiers))

#define EM_DECODER_STATIC_FP_STATUS(si) \
                            EM_DECODER_MODIFIERS_FP_STATUS(&((si)->modifiers))

#define EM_DECODER_STATIC_MEMORY_ACCESS_HINT(si) \
                            EM_DECODER_MODIFIERS_MEMORY_ACCESS_HINT(&((si)->modifiers))


#define EM_DECODER_STATIC_FLAGS(si) \
                            ((si)->flags)

#define EM_DECODER_STATIC_FLAG_PRED(si) \
                            EM_DECODER_FLAGS_FLAG_PRED((si)->flags)

#define EM_DECODER_STATIC_FLAG_PRIVILEGED(si) \
                            EM_DECODER_FLAGS_FLAG_PRIVILEGED((si)->flags)

#define EM_DECODER_STATIC_FLAG_LMEM(si) \
                            EM_DECODER_FLAGS_FLAG_LMEM((si)->flags)

#define EM_DECODER_STATIC_FLAG_SMEM(si) \
                            EM_DECODER_FLAGS_FLAG_SMEM((si)->flags)

#define EM_DECODER_STATIC_FLAG_CHECK_BASE_EQ_DST(si) \
                            EM_DECODER_FLAGS_FLAG_CHECK_BASE_EQ_DST((si)->flags)

#define EM_DECODER_STATIC_FLAG_SPECULATION(si) \
                            EM_DECODER_FLAGS_FLAG_SPECULATION((si)->flags)

#define EM_DECODER_STATIC_FLAG_POSTINCREMENT(si) \
                            EM_DECODER_FLAGS_FLAG_POSTINCREMENT((si)->flags)

#define EM_DECODER_STATIC_FLAG_FALSE_PRED_EXEC(si) \
                            EM_DECODER_FLAGS_FLAG_FALSE_PRED_EXEC((si)->flags)

#define EM_DECODER_STATIC_FLAG_BR_HINT(si) \
                            EM_DECODER_FLAGS_FLAG_BR_HINT((si)->flags)

#define EM_DECODER_STATIC_FLAG_BR(si) \
                            EM_DECODER_FLAGS_FLAG_BR((si)->flags)

#define EM_DECODER_STATIC_FLAG_GROUP_FIRST(si) \
                            EM_DECODER_FLAGS_FLAG_GROUP_FIRST((si)->flags)

#define EM_DECODER_STATIC_FLAG_GROUP_LAST(si) \
                            EM_DECODER_FLAGS_FLAG_GROUP_LAST((si)->flags)

#define EM_DECODER_STATIC_FLAG_CHECK_SAME_DSTS(si) \
                            EM_DECODER_FLAGS_FLAG_CHECK_SAME_DSTS((si)->flags)

#define EM_DECODER_STATIC_FLAG_CONTROL_TRANSFER(si) \
                            EM_DECODER_FLAGS_FLAG_CONTROL_TRANSFER((si)->flags)

#ifdef __cplusplus
}
#endif

#endif /*** EM_DECODER_H ***/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\decem\decoder_priv.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


/*****************************************************************************/
/* decoder_priv.h                                                            */
/*****************************************************************************/

#ifndef _DECODER_PRIV_H_
#define _DECODER_PRIV_H_

#define EM_DECODER_MAX_CLIENTS     20

#define DEFAULT_MACHINE_TYPE    EM_DECODER_CPU_P7
#define DEFAULT_MACHINE_MODE    EM_DECODER_MODE_EM


typedef struct
{
    int                      is_used;
    EM_Decoder_Machine_Type  machine_type;
    EM_Decoder_Machine_Mode  machine_mode;
    void **                  info_ptr;     /*** after dynamic allocation,     ***/
                                           /*** info_ptr points to an array   ***/
                                           /*** of pointers. The i'th pointer ***/
                                           /*** in the array is a ptr to the  ***/
                                           /*** client info.                  ***/
	unsigned long            flags;
} Client_Entry;

Client_Entry   em_clients_table[EM_DECODER_MAX_CLIENTS];

#define FILL_PREDICATE_INFO(Inst_code, Dinfo_p)                          \
{                                                                        \
    int pred_no = (IEL_GETDW0(Inst_code) >> EM_PREDICATE_POS) &          \
                  ((1 << EM_PREDICATE_BITS)-1);                          \
    Dinfo_p->pred.valid = TRUE;                                          \
    Dinfo_p->pred.value = pred_no;                                       \
    Dinfo_p->pred.type = EM_DECODER_PRED_REG;                            \
    Dinfo_p->pred.name = EM_DECODER_REG_P0 + pred_no;                    \
}

#define GET_BRANCH_BEHAVIOUR_BIT(Inst_code,Bit)                          \
{                                                                        \
	unsigned int tmp;                                                    \
	U64 tmp64;                                                           \
	IEL_SHR(tmp64,(Inst_code),BRANCH_BEHAVIOUR_BIT);                  \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Bit) = tmp & 1;                                                     \
}

#define EM_DECODER_SET_UNC_ILLEGAL_FAULT(di)  ((di)->flags |= EM_DECODER_BIT_UNC_ILLEGAL_FAULT)



/*** Static variables initialization ***/

static const char em_ver_string[] = VER_STR;  /*** initialized by Makefile ***/
static const char *em_err_msg[EM_DECODER_LAST_ERROR] =
{
	"",
	"EM_DECODER_INVALID_SLOT_BRANCH_INST: Instruction must be in the last slot of the current bundle",
	"EM_DECODER_MUST_BE_GROUP_LAST: Instruction must be the last in instruction group",
	"EM_DECODER_BASE_EQUAL_DEST: Source and destination operands have the same value",
	"EM_DECODER_EQUAL_DESTS: Two destination operands have the same value",
	"EM_DECODER_ODD_EVEN_DESTS: Both destination floating-point registers have odd or even values",
	"EM_DECODER_WRITE_TO_ZERO_REGISTER: Destination general register r0 is invalid",
	"EM_DECODER_WRITE_TO_SPECIAL_FP_REGISTER: Destination floating point register is f0 or f1",
	"EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE: Register value is out of permitted range",
	"EM_DECODER_REGISTER_RESERVED_VALUE: Register operand value is reserved",
	"EM_DECODER_IMMEDIATE_VALUE_OUT_OF_RANGE: Immediate operand value is out of permitted range",
	"EM_DECODER_IMMEDIATE_INVALID_VALUE: Invalid immediate operand value",
	"EM_DECODER_STACK_FRAME_SIZE_OUT_OF_RANGE: Stack frame size is larger than maximum permitted value", 
	"EM_DECODER_LOCALS_SIZE_LARGER_STACK_FRAME: Size of locals is larger than the stack frame",
	"EM_DECODER_ROTATING_SIZE_LARGER_STACK_FRAME: Size of rotating region is larger than the stack frame",
	"EM_DECODER_HARD_CODED_PREDICATE_INVALID_VALUE: Invalid hard-coded predicate value",
	"EM_DECODER_INVALID_PRM_OPCODE: Instruction contains an invalid opcode",
	"EM_DECODER_INVALID_INST_SLOT: Instruction slot is invalid in current bundle",
	"EM_DECODER_INVALID_TEMPLATE: Invalid template is specified",
	"EM_DECODER_INVALID_CLIENT_ID: Invalid client id",
	"EM_DECODER_NULL_PTR: A null pointer was specified in call",
	"EM_DECODER_TOO_SHORT_ERR: Instruction buffer is too short for instruction",
	"EM_DECODER_ASSOCIATE_MISS: There is an unassociated instruction",
	"EM_DECODER_INVALID_INST_ID: Invalid instruction id",
	"EM_DECODER_INVALID_MACHINE_MODE: Invalid machine mode",
	"EM_DECODER_INVALID_MACHINE_TYPE: Invalid machine type",
	"EM_DECODER_INTERNAL_ERROR: Internal data-base collisions"};


typedef enum
{
    BEHAVIOUR_UNDEF = 0,
    BEHAVIOUR_IGNORE_ON_FALSE_QP,
    BEHAVIOUR_FAULT
}Behaviour_ill_opcode;

static const Behaviour_ill_opcode branch_ill_opcode[]=
{
    /* 0*/ BEHAVIOUR_UNDEF,
    /* 1*/ BEHAVIOUR_FAULT,
    /* 2*/ BEHAVIOUR_IGNORE_ON_FALSE_QP,
    /* 3*/ BEHAVIOUR_IGNORE_ON_FALSE_QP,
    /* 4*/ BEHAVIOUR_FAULT,
    /* 5*/ BEHAVIOUR_FAULT,
    /* 6*/ BEHAVIOUR_IGNORE_ON_FALSE_QP,
    /* 7*/ BEHAVIOUR_IGNORE_ON_FALSE_QP,
    /* 8*/ BEHAVIOUR_FAULT,
    /* 9*/ BEHAVIOUR_FAULT,
    /* a*/ BEHAVIOUR_FAULT,
    /* b*/ BEHAVIOUR_FAULT,
    /* c*/ BEHAVIOUR_FAULT,
    /* d*/ BEHAVIOUR_FAULT,
    /* e*/ BEHAVIOUR_FAULT,
    /* f*/ BEHAVIOUR_FAULT
};

#define PRED_BEHAVIOUR(trole, maj_op, behav)             \
{                                                        \
    switch(trole)                                        \
    {                                                    \
        case(EM_TEMP_ROLE_MEM):                          \
        case(EM_TEMP_ROLE_INT):                          \
        case(EM_TEMP_ROLE_LONG):                         \
        case(EM_TEMP_ROLE_FP):                           \
            (behav) = BEHAVIOUR_IGNORE_ON_FALSE_QP;      \
            break;                                       \
        case(EM_TEMP_ROLE_BR):                           \
            (behav) = branch_ill_opcode[(maj_op)];       \
            break;                                       \
        default:                                         \
            (behav) = BEHAVIOUR_FAULT;                   \
    }                                                    \
}

/* this bit is crtical for machine behaviour within
   illegal branch instruction with major opcode 0 */
#define BRANCH_BEHAVIOUR_BIT 32

#endif /* _DECODER_PRIV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\decem\frmt_mac.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef _FRMT_MAC_H_
#define _FRMT_MAC_H_

#include "decoder_priv.h"
#define PRED_SIZE EM_PREDICATE_BITS

#define GET_REG_VALUE(Value,Binary,Pos,Sz)                   \
{                                                            \
	int mask = (1<<(Sz))-1;                                  \
	U64 tmp64;                                               \
	IEL_SHR(tmp64,(Binary),(Pos));                           \
	(Value) = IEL_GETDW0(tmp64);                             \
	(Value) &= mask;                                         \
}

#define FILL_REG_INFO(Reg_type, Reg_name, Value, Max_value, Dec_oper, Err) \
{                                                                        \
	(Dec_oper).type = EM_DECODER_REGISTER;                               \
	(Dec_oper).reg_info.valid = 1;                                       \
	(Dec_oper).reg_info.value = (Value);                                 \
	(Dec_oper).reg_info.type = (Reg_type);                               \
	(Dec_oper).reg_info.name = (Reg_name)+(Value);                       \
                                                                         \
	if ((Value)>=(Max_value))                                            \
	{                                                                    \
		(Dec_oper).reg_info.valid = 0;                                   \
		if (!(Err))														 \
		   (Err) = EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE;               \
	}                                                                    \
}

#define CHECK_REG_VALUE_0(Value, Dec_oper, Err)                          \
{                                                                        \
    if ((Value) == 0)                                                    \
	{                                                                    \
		(Dec_oper).reg_info.valid = 0;	                                 \
		if (!(Err))                                                      \
		   (Err) = EM_DECODER_WRITE_TO_ZERO_REGISTER;                    \
	}                                                                    \
}

#define CHECK_FP_REG_VALUE_0_1(Value, Dec_oper, Err)                     \
{                                                                        \
    if (((Value) == 0) || ((Value) == 1))                                \
	{                                                                    \
		(Dec_oper).reg_info.valid = 0;	                                 \
		if (!(Err))                                                      \
		   (Err) = EM_DECODER_WRITE_TO_SPECIAL_FP_REGISTER;              \
	}                                                                    \
}

#define CHECK_DEST_AND_BASE(Dec_oper_dest, Dec_oper_base, Err)           \
{                                                                        \
	if ((Dec_oper_dest).reg_info.value ==                                \
		(Dec_oper_base).mem_info.mem_base.value)                         \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_BASE_EQUAL_DEST;                            \
}

#define CHECK_DEST_AND_DEST(Dec_info_p, Err)                             \
{                                                                        \
	if ((Dec_info_p)->dst1.reg_info.value ==                             \
		(Dec_info_p)->dst2.reg_info.value)                               \
	{                                                                    \
	   if (!(Err))														 \
		  (Err) = EM_DECODER_EQUAL_DESTS;                                \
	   if (EM_DECODER_CHECK_UNC_ILLEGAL_FAULT(Dec_info_p))               \
		  EM_DECODER_SET_UNC_ILLEGAL_FAULT(Dec_info_p);                  \
	}																	 \
}

#define CHECK_ODD_EVEN_DSTS(Dec_oper_dest1, Dec_oper_dest2, Err)        \
{                                                                       \
	int reg_val1 = (Dec_oper_dest1).reg_info.value;                     \
	int reg_val2 = (Dec_oper_dest2).reg_info.value;                     \
	if (((reg_val1<32)&& (reg_val2<32))||                               \
		((reg_val1>32)&& (reg_val2>32)))                                \
	  {                                                                 \
		  if (!((reg_val1^reg_val2)&1)) /* both even of odd */          \
		  {                                                             \
			  if (!(Err))                                               \
			    (Err) = EM_DECODER_ODD_EVEN_DESTS;                      \
		  }                                                             \
	  }                                                                 \
}

#define GET_SIMM_VALUE1(Value,Pos1,Sz1,Binary)                           \
{                                                                        \
	int mask = (1<<(Sz1))-1;                                             \
	int or_mask, is_neg,imm_size = (Sz1);                                \
	U64 tmp64;                                                           \
	IEL_SHR(tmp64,(Binary),((Pos1)+PRED_SIZE));                          \
	(Value) = IEL_GETDW0(tmp64);                                         \
	(Value) &= mask;                                                     \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_SIMM_VALUE2(Value,Pos1,Sz1,Pos2,Sz2,Binary)                  \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2);                          \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)));  \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_SIMM_VALUE_NP2(Value,Pos1,Sz1,Pos2,Sz2,Binary)               \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2);                          \
	U64 tmp64;                                                           \
	int tmp;                                                             \
    IEL_SHR(tmp64, Binary, Pos1);                                        \
    tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (tmp & mask1);                                             \
	IEL_SHR(tmp64, Binary, Pos2);                                        \
    tmp = IEL_GETDW0(tmp64);                                             \
    (Value) |= ((tmp & mask2)<<(Sz1));                                   \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_CMP4_UIMM_VALUE2(Value,Pos1,Sz1,Pos2,Sz2,Binary)             \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int or_mask, to_complete,imm_size = (Sz1)+(Sz2);                     \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)));  \
	to_complete = (Value)>>(imm_size-1);                                 \
	or_mask = to_complete * (((1<<(32-imm_size))-1)<<imm_size);          \
	(Value) |= or_mask;                                                  \
}

#define GET_CMP_UIMM_VALUE2(Value64,Pos1,Sz1,Pos2,Sz2,Binary)            \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int or_mask, to_complete,imm_size = (Sz1)+(Sz2);                     \
	U64 tmp64;                                                           \
	int tmp, val1, val2;                                                 \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	val1 = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)));     \
	to_complete = val1>>(imm_size-1);                                    \
	or_mask = to_complete * (((1<<(32-imm_size))-1)<<imm_size);          \
	val1 |= or_mask;                                                     \
	val2 = to_complete * (-1);                                           \
	IEL_CONVERT2((Value64),val1,val2);                                   \
}

#define GET_SIMM_VALUE3(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Binary)         \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2)+(Sz3);                    \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))));                  \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_SIMM_VALUE4(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Pos4,Sz4,Binary) \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	int mask4 = (1<<(Sz4))-1;                                            \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2)+(Sz3)+(Sz4);              \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))) |                  \
	           (((tmp>>(Pos4))&mask4)<<((Sz1)+(Sz2)+(Sz3))));            \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_SIMM_VALUE5(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Pos4,Sz4,       \
						Pos5,Sz5,Binary)                                 \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	int mask4 = (1<<(Sz4))-1;                                            \
	int mask5 = (1<<(Sz5))-1;                                            \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2)+(Sz3)+(Sz4)+(Sz5);        \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))) |                  \
	           (((tmp>>(Pos4))&mask4)<<((Sz1)+(Sz2)+(Sz3))) |            \
	           (((tmp>>(Pos5))&mask5)<<((Sz1)+(Sz2)+(Sz3)+(Sz4))));      \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}


#define GET_UIMM_VALUE_NP1(Value,Pos1,Sz1,Binary) \
           GET_UIMM_VALUE1((Value),((Pos1)-PRED_SIZE),(Sz1),(Binary))

#define GET_UIMM_VALUE_NP2(Value,Pos1,Sz1,Pos2,Sz2,Binary)               \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	U64 tmp64;                                                           \
	int tmp1,tmp2;                                                       \
	IEL_SHR(tmp64,(Binary),(Pos1));                                      \
	tmp1 = IEL_GETDW0(tmp64);                                            \
	IEL_SHR(tmp64,(Binary),(Pos2));                                      \
	tmp2 = IEL_GETDW0(tmp64);                                            \
	(Value) = (tmp1 & mask1) | ((tmp2 & mask2)<<(Sz1));                  \
}

#define GET_SIMM_VALUE_NP3(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Binary)      \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	U64 tmp64;                                                           \
	int or_mask, is_neg,imm_size = (Sz1)+(Sz2)+(Sz3);                    \
	int tmp1,tmp2,tmp3;                                                  \
	IEL_SHR(tmp64,(Binary),(Pos1));                                      \
	tmp1 = IEL_GETDW0(tmp64);                                            \
	IEL_SHR(tmp64,(Binary),(Pos2));                                      \
	tmp2 = IEL_GETDW0(tmp64);                                            \
	IEL_SHR(tmp64,(Binary),(Pos3));                                      \
	tmp3 = IEL_GETDW0(tmp64);                                            \
	(Value) = (tmp1 & mask1) | ((tmp2 & mask2)<<(Sz1)) |                 \
	          ((tmp3 & mask3)<<((Sz1)+(Sz2)));                           \
	is_neg = (Value)>>(imm_size-1);                                      \
	or_mask = is_neg * (((1<<(32-imm_size))-1)<<imm_size);               \
	(Value) |= or_mask;                                                  \
}

#define GET_UIMM_VALUE1(Value,Pos1,Sz1,Binary)                           \
{                                                                        \
	int mask = (1<<(Sz1))-1;                                             \
	U64 tmp64;                                                           \
	IEL_SHR(tmp64,(Binary),((Pos1)+PRED_SIZE));                          \
	(Value) = IEL_GETDW0(tmp64);                                         \
	(Value) &= mask;                                                     \
}

#define GET_UIMM_VALUE2(Value,Pos1,Sz1,Pos2,Sz2,Binary)                  \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)));  \
}

#define GET_UIMM_VALUE3(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Binary)         \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))));                  \
}

#define GET_UIMM_VALUE4(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Pos4,Sz4,Binary) \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	int mask4 = (1<<(Sz4))-1;                                            \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))) |                  \
	           (((tmp>>(Pos4))&mask4)<<((Sz1)+(Sz2)+(Sz3))));            \
}
#define GET_UIMM_VALUE5(Value,Pos1,Sz1,Pos2,Sz2,Pos3,Sz3,Pos4,Sz4,       \
						Pos5,Sz5,Binary)                                 \
{                                                                        \
	int mask1 = (1<<(Sz1))-1;                                            \
	int mask2 = (1<<(Sz2))-1;                                            \
	int mask3 = (1<<(Sz3))-1;                                            \
	int mask4 = (1<<(Sz4))-1;                                            \
	int mask5 = (1<<(Sz5))-1;                                            \
	U64 tmp64;                                                           \
	int tmp;                                                             \
	IEL_SHR(tmp64,(Binary),PRED_SIZE);                                   \
	tmp = IEL_GETDW0(tmp64);                                             \
	(Value) = (((tmp>>(Pos1))&mask1) | (((tmp>>(Pos2))&mask2)<<(Sz1)) |  \
	           (((tmp>>(Pos3))&mask3)<<((Sz1)+(Sz2))) |                  \
	           (((tmp>>(Pos4))&mask4)<<((Sz1)+(Sz2)+(Sz3))) |            \
	           (((tmp>>(Pos5))&mask5)<<((Sz1)+(Sz2)+(Sz3)+(Sz4))));      \
}

#define FILL_IMM_INFO(Imm_type, Value, Size, Dec_oper)                   \
{                                                                        \
	(Dec_oper).type = EM_DECODER_IMMEDIATE;                              \
	(Dec_oper).imm_info.imm_type = (Imm_type);                           \
	(Dec_oper).imm_info.size = (Size);                                   \
	if (((Imm_type)==EM_DECODER_IMM_SIGNED) && ((Value)<0))              \
	   IEL_CONVERT2((Dec_oper).imm_info.val64,(Value),0xffffffff);       \
	else                                                                 \
	   IEL_CONVERT2((Dec_oper).imm_info.val64,(Value),0);                \
}

#define FILL_LONG_IMM_INFO(Imm_type, Value64, Size, Dec_oper)            \
{                                                                        \
	(Dec_oper).type = EM_DECODER_IMMEDIATE;                              \
	(Dec_oper).imm_info.imm_type = (Imm_type);                           \
	(Dec_oper).imm_info.size = (Size);                                   \
	(Dec_oper).imm_info.val64 = (Value64);                               \
}

#define FILL_MEM_INFO(Value, Mem_size, Dec_oper, Err)                    \
{                                                                        \
	(Dec_oper).type = EM_DECODER_MEMORY;                                 \
	(Dec_oper).mem_info.mem_base.type = EM_DECODER_INT_REG;              \
	(Dec_oper).mem_info.mem_base.name = EM_DECODER_REG_R0+(Value);       \
	(Dec_oper).mem_info.mem_base.value = (Value);                        \
	(Dec_oper).mem_info.mem_base.valid = 1;                              \
	(Dec_oper).mem_info.size = (Mem_size);                               \
	                                                                     \
	if ((Value)>=EM_NUM_OF_GREGS)                                        \
	{                                                                    \
		(Dec_oper).mem_info.mem_base.valid = 0;                          \
		if (!(Err))														 \
		   (Err) = EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE;               \
	}                                                                    \
}

#define FILL_REGFILE_INFO(Reg_name, Value, Dec_oper, Err)                \
{                                                                        \
	(Dec_oper).type = EM_DECODER_REGFILE;                                \
	(Dec_oper).regfile_info.name = (Reg_name);                           \
	(Dec_oper).regfile_info.index.valid = 1;                             \
	(Dec_oper).regfile_info.index.type  = EM_DECODER_INT_REG;            \
	(Dec_oper).regfile_info.index.name  = EM_DECODER_REG_R0+(Value);     \
	(Dec_oper).regfile_info.index.value = (Value);                       \
                                                                         \
	if ((Value)>=EM_NUM_OF_GREGS)                                        \
	{                                                                    \
		(Dec_oper).regfile_info.index.valid = 0;                         \
		if (!(Err))														 \
		   (Err) = EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE;               \
	}                                                                    \
}

#define FILL_LONG_IPREL_INFO(Value64, Size, Dec_oper)                        \
{                                                                            \
        (Dec_oper).type = EM_DECODER_IP_RELATIVE;                            \
        (Dec_oper).imm_info.size = (Size);                                   \
        (Dec_oper).imm_info.val64 = (Value64);	  	 		     \
}

#define FILL_IPREL_INFO(Value, Size, Dec_oper)                           \
{                                                                        \
	(Dec_oper).type = EM_DECODER_IP_RELATIVE;                            \
	(Dec_oper).imm_info.size = (Size);                                   \
	if ((Value)<0)									                     \
	{                                                                    \
		IEL_CONVERT2((Dec_oper).imm_info.val64,(Value),0xffffffff);      \
	}                                                                    \
	else                                                                 \
	{                                                                    \
		IEL_CONVERT2((Dec_oper).imm_info.val64,(Value),0);               \
	}                                                                    \
}

#define CHECK_REG_CR(Value, Dec_oper, Err)                               \
{                                                                        \
	if (EM_CREG_IS_RESERVED(Value))                                      \
	{                                                                    \
	   (Dec_oper).reg_info.valid = 0;	                                 \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_REGISTER_RESERVED_VALUE;                    \
	}                                                                    \
}


#define CHECK_REG_APP_GRP_HIGH(Value, Dec_oper, Err)                     \
{                                                                        \
	if (!EM_APP_REG_IS_I_ROLE(Value))                                    \
	{                                                                    \
	   (Dec_oper).reg_info.valid = 0;	                                 \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE;                \
	}                                                                    \
	else if (EM_APP_REG_IS_RESERVED(Value))                              \
	{                                                                    \
	   (Dec_oper).reg_info.valid = 0;	                                 \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_REGISTER_RESERVED_VALUE;                    \
    }                                                                    \
}

#define CHECK_REG_APP_GRP_LOW(Value, Dec_oper, Err)                      \
{                                                                        \
	if (EM_APP_REG_IS_I_ROLE(Value))                                     \
	{                                                                    \
	   (Dec_oper).reg_info.valid = 0;	                                 \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_REGISTER_VALUE_OUT_OF_RANGE;                \
	}                                                                    \
	else if (EM_APP_REG_IS_RESERVED(Value))                              \
	{                                                                    \
	   (Dec_oper).reg_info.valid = 0;	                                 \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_REGISTER_RESERVED_VALUE;                    \
	}                                                                    \
}

#define CHECK_IMM_COUNT_123(Value, Err)                                  \
{                                                                        \
	if (((Value)<1)||((Value)>3))                                        \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_IMMEDIATE_VALUE_OUT_OF_RANGE;               \
}

#define CHECK_IMM_COUNT_1234(Value, Err)                                 \
{                                                                        \
	if (((Value)<1)||((Value)>4))                                        \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_IMMEDIATE_VALUE_OUT_OF_RANGE;               \
}

#define CHECK_IMM_COUNT_PACK(Value, Err)                                 \
{                                                                        \
	if (((Value)!=0)&&((Value)!=7)&&((Value)!=15)&&((Value)!=16))        \
	   if (!(Err))														 \
	      (Err) = EM_DECODER_IMMEDIATE_INVALID_VALUE;                    \
}

#define CHECK_IMM_MUX1(Value, Err)                                       \
{                                                                        \
    switch(Value)                                                        \
	{                                                                    \
		case EM_MUX_BRCST:                                               \
		case EM_MUX_MIX:                                                 \
		case EM_MUX_SHUF:                                                \
		case EM_MUX_ALT:                                                 \
		case EM_MUX_REV:                                                 \
		   break;                                                        \
		default:                                                         \
		   (Err) = EM_DECODER_IMMEDIATE_INVALID_VALUE;                   \
	}                                                                    \
}

#define CONVERT_IMM_SEMAPHORE_INC(Value, Err)                            \
{                                                                        \
    switch (Value)                                                       \
	{                                                                    \
	   case 0:                                                           \
	     Value = 16;                                                     \
		 break;                                                          \
	   case 1:                                                           \
		 Value = 8;                                                      \
		 break;                                                          \
	   case 2:                                                           \
		 Value = 4;                                                      \
		 break;                                                          \
	   case 3:                                                           \
		 Value = 1;                                                      \
		 break;                                                          \
	   case (-4):                                                        \
		 Value = -16;                                                    \
		 break;                                                          \
	   case (-3):                                                        \
		 Value = -8;                                                     \
		 break;                                                          \
	   case (-2):                                                        \
		 Value = -4;                                                     \
		 break;                                                          \
	   case (-1):                                                        \
		 Value = -1;                                                     \
		 break;                                                          \
	   default:                                                          \
	     if (!(Err))												     \
		    (Err) = EM_DECODER_IMMEDIATE_INVALID_VALUE;                  \
	}	                                                                 \
}

#define CONVERT_IMM_COUNT_PACK(Value)                                    \
{                                                                        \
	switch(Value)                                                        \
	{                                                                    \
	  case (0):                                                          \
		break;                                                           \
	  case (1):                                                          \
		(Value) = 7;                                                     \
		break;                                                           \
	  case (2):                                                          \
		(Value) = 15;                                                    \
		break;                                                           \
	  case (3):                                                          \
		(Value) = 16;                                                    \
		break;                                                           \
	}                                                                    \
}

#define GET_UIMM64_VALUE1(Value64,Start,Pos1,Sz1,Bin128)                 \
{																		 \
	U128 tmp128; 													     \
	U64 mask;															 \
	IEL_CONVERT2(mask, 1, 0);										     \
	IEL_SHL(mask, mask, (Sz1));										     \
	IEL_DECU(mask);													     \
    IEL_SHR(tmp128,(Bin128),(5+41)+(Pos1));	                             \
    IEL_AND(tmp128, tmp128, mask);                                       \
    IEL_SHL(tmp128,tmp128,(Start));                      	             \
    IEL_OR((Value64),(Value64),tmp128);                                  \
}

#define GET_UIMM_2_U64_VALUE1(Value64,Start,Pos1,Sz1,Binary)		     \
{							    									     \
	int mask = (1<<(Sz1))-1;                                             \
	unsigned int Value;												     \
        U64 tmp64;                                                       \
        IEL_SHR(tmp64,(Binary),((Pos1)+PRED_SIZE));                      \
        (Value) = IEL_GETDW0(tmp64);                                     \
        (Value) &= mask;                          					     \
	IEL_CONVERT2(tmp64, Value, 0);										 \
	IEL_SHL(tmp64, tmp64, (Start));										 \
	IEL_OR((Value64), (Value64), tmp64);			  					 \
}

#define GET_UIMM64_VALUE6_1(Value64, Pos1, Sz1, Pos2, Sz2, Pos3, Sz3,    \
						  Pos4, Sz4, Pos5, Sz5, Pos6, Sz6, Bin128)       \
{                                                                        \
	U128 tmp128;                                                         \
	U64  mask;                                                           \
	IEL_SHR(tmp128,Bin128,(5+41));                                       \
	IEL_CONVERT2(mask, 0xffffffff,0x1ff);                                \
	IEL_AND(tmp128, tmp128, mask);                                       \
	IEL_SHL(tmp128,tmp128,((Sz1)+(Sz2)+(Sz3)+(Sz4)));                    \
	IEL_OR((Value64),(Value64),tmp128);                                  \
                                                                         \
}

#define GET_UIMM64_VALUE6_2(Value64, Pos1, Sz1, Pos2, Sz2, Pos3, Sz3,    \
						  Pos4, Sz4, Pos5, Sz5, Pos6, Sz6, Bin128)       \
{                                                                        \
	U128 tmp128;                                                         \
	U64  mask;                                                           \
	IEL_SHR(tmp128,Bin128,((Pos6)+5+41+41));                             \
	IEL_CONVERT2(mask, 1,0);                                             \
	IEL_AND(tmp128, tmp128, mask);                                       \
	IEL_SHL(tmp128,tmp128,((Sz1)+(Sz2)+(Sz3)+(Sz4)+(Sz5)));              \
	IEL_OR((Value64),(Value64),tmp128);                                  \
}	

#define SET_2ND_ROLE_TO_DEST(Dec_oper)  \
               ((Dec_oper).oper_flags |= EM_DECODER_OPER_2ND_ROLE_DST_BIT)

#define SET_2ND_ROLE_TO_SRC(Dec_oper)  \
               ((Dec_oper).oper_flags |= EM_DECODER_OPER_2ND_ROLE_SRC_BIT)


#define GET_PREDICATE_HARD_CODED_VALUE(Value,Binary) \
		   GET_UIMM_VALUE1((Value),((EM_PREDICATE_POS)-PRED_SIZE),(PRED_SIZE),(Binary))
									   
#define CHECK_PREDICATE_HARD_CODED(Value, HC_Value, Err)             \
{                                                                    \
    if ((Value) != (HC_Value))                                       \
	{                                                                \
		if (!(Err))                                                  \
		   (Err) = EM_DECODER_HARD_CODED_PREDICATE_INVALID_VALUE;    \
	}                                                                \
}


#define GET_FIELD_HARD_CODED_VALUE(Value,Pos,Sz,Binary)              \
		   GET_UIMM_VALUE1((Value),((Pos)-PRED_SIZE),(Sz),(Binary))

#define CHECK_FIELD_HARD_CODED(Value, HC_Value, Err)                 \
{                                                                    \
    if ((Value) != (HC_Value))                                       \
	{                                                                \
		if (!(Err))                                                  \
		   (Err) = EM_DECODER_HARD_CODED_FIELD_INVALID_VALUE;        \
	}                                                                \
}


#endif /* FRMT_MAC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\decem\build\decision_tree.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef _DECISION_TREE_H
#define _DECISION_TREE_H

typedef enum
{
	EM_TEMP_ROLE_NONE = 0,
	EM_TEMP_ROLE_INT = EM_TEMP_ROLE_NONE,
	EM_TEMP_ROLE_MEM,
	EM_TEMP_ROLE_FP,
	EM_TEMP_ROLE_BR,
	EM_TEMP_ROLE_LONG,
	EM_TEMP_ROLE_LAST
} Temp_role_t;

typedef struct Node_s
{
	unsigned short next_node;
	char pos;
	char size;
} Node_t;

#define GET_NODE_POS(node) \
        ((node).pos)

#define GET_NODE_SIZE(node) \
        ((node).size)

#define GET_NEXT_NODE_INDEX(node) \
        ((node).next_node)

#define SQUARE(opcode, template_role) \
        (((opcode) * EM_TEMP_ROLE_LAST) + (template_role))

#define NODE_IS_LEAF(node) \
        ((unsigned char)((node).pos) == 0xff)

extern Node_t em_decision_tree[];

#endif /*_DECISION_TREE_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\decem\build\tree.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef _TREE_H
#define _TREE_H

#include "inst_ids.h"

/* 41 bit instruction minus qp(6 bits) and major opcode(4 bits) */
#define EXTENSION_SIZE 31

typedef struct Internal_node_s
{
	int next_node;
	int pos;
	int size;
} Internal_node_t;

typedef enum
{
	EM_TEMP_ROLE_NONE = 0,
	EM_TEMP_ROLE_INT = EM_TEMP_ROLE_NONE,
	EM_TEMP_ROLE_MEM,
	EM_TEMP_ROLE_FP,
	EM_TEMP_ROLE_BR,
	EM_TEMP_ROLE_LAST
} Temp_role_t;

#define SQUARE(opcode, template_role) \
        (((opcode) * EM_TEMP_ROLE_LAST) + (template_role));

#endif /*_TREE_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\decem\build\dec_priv_col.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef DEC_PRIV_COL_H
#define DEC_PRIV_COL_H
#include "decem.h"
#include "func.h"
typedef unsigned int Mem_size_t;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\decem\makefile.inc ===
!include ..\makefile.inc

COMMON_HEADERS = emdb_types.h EM.h EM_tools.h iel.h EM_hints.h inst_ids.h
EMDB_SOURCES = $(EMDBDIR)\emdb.txt $(EMDBDIR)\emdb_cut.pl \
               $(EMDBDIR)\dec_private.perl $(EMDBDIR)\emdb_formats.txt \
               $(IA64_DIS_INC)\EM_perl.h

EM_BUILDIR = .\build
PERL_INCLIST = $(PERL_INCLIST) -I $(EM_BUILDIR) -I $O
INCLUDES = $(INCLUDES);$(EM_BUILDIR)

$(IA64_DIS_INC)\decem.h : decoder.h
        copy decoder.h $(IA64_DIS_INC)\decem.h

$O\frmt_func.c : $(EM_BUILDIR)/func_build_1.pl \
                 $(EM_BUILDIR)/func_build_2.pl $(EMDB_SOURCES) \
                 $O\deccpu_emdb.h $O\inst_ids.h
	$(PERL) $(PERL_INCLIST) $(EM_BUILDIR)\func_build_1.pl $O $(EMDBDIR)
	$(PERL) $(PERL_INCLIST) $(EM_BUILDIR)\func_build_2.pl $O $(EMDBDIR)

$O\deccpu_emdb.c $O\deccpu_emdb.h : $(EMDB_SOURCES) $O\decoder.txt
        $(PERL) $(EMDBDIR)\emdb_cut.pl -emdb_path $(EMDBDIR) -dir $O \
            -columns $O\decoder.txt \
            -fields inst_id,extensions,format,template_role,ops,flags,mem_size,dec_flags,impls \
            -include $(EM_BUILDIR)\dec_priv_col.h -prefix deccpu

$O\dec_emdb.tab: $(EMDBDIR)\emdb.txt $(EMDBDIR)\emdb_cut.pl \
            $(EM_BUILDIR)\dec_priv_col.h
	echo "building dec_emdb.tab"
        $(PERL) $(EMDBDIR)\emdb_cut.pl -table -emdb_path $(EMDBDIR) -dir $O \
            -fields inst_id,format,major_opcode,template_role -prefix dec


###ign_inst.txt must be the last in '-row' sequence 

$O\dec_ign_emdb.tab: $(EMDBDIR)\emdb.txt $(EMDBDIR)\emdb_cut.pl \
            $O\ign_inst.txt $(EM_BUILDIR)\dec_priv_col.h
	echo "building dec_ign_emdb.tab"
        $(PERL) $(EMDBDIR)\emdb_cut.pl -rows $O\ign_inst.txt \
            -table -emdb_path $(EMDBDIR) -dir $O \
            -fields inst_id,format,major_opcode,template_role \
            -prefix dec_ign

$O\inst_ign_ids.h $O\ign_inst.txt: $(EMDBDIR)\emdb.txt \
            $(EMDBDIR)\emdb_formats.txt $(EM_BUILDIR)\build_ignored_flds.pl
	$(PERL) $(PERL_INCLIST) \
            $(EM_BUILDIR)\build_ignored_flds.pl $O $(EMDBDIR)

$O\inst_emdb.tab: $(EMDBDIR)\emdb.txt $(EMDBDIR)\emdb_cut.pl \
            $(EM_BUILDIR)\dec_priv_col.h
        $(PERL) $(EMDBDIR)\emdb_cut.pl -table -emdb_path $(EMDBDIR) \
            -dir $O -fields inst_id -prefix inst

$O\builder_info.c $O\builder_info.h: $(EMDBDIR)\emdb_formats.txt \
            $(EM_BUILDIR)\tree_builder.perl $O\dec_ign_emdb.tab \
            $(IA64_DIS_INC)\EM_perl.h
	echo "building builder_info.c"
	$(PERL) $(PERL_INCLIST) $(EM_BUILDIR)\tree_builder.perl $O $(EMDBDIR)

$O\decfn_emdb.c: $O\deccpu_emdb.c $O\deccpu_emdb.h \
            $(EM_BUILDIR)\func_build_1.pl \
            $(EM_BUILDIR)\hard_coded_fields_h.perl 
	$(PERL) $(PERL_INCLIST) $(EM_BUILDIR)\func_build_1.pl $O $(EMDBDIR)

$O\dec_static.c: $O\dec1_emdb.c $O\dec1_emdb.h \
            $(EM_BUILDIR)\build_static_info.pl $(IA64_DIS_INC)\EM_perl.h
	$(PERL) $(PERL_INCLIST) $(EM_BUILDIR)\build_static_info.pl $O $(EMDBDIR)


###ign_inst.txt must be the last in '-row' sequence

$O\dec_ign_emdb.c $O\dec_ign_emdb.h : $O\ign_inst.txt \
            $(EMDB_SOURCES)
        $(PERL) $(EMDBDIR)\emdb_cut.pl -emdb_path $(EMDBDIR) -dir $O \
             -rows $O\ign_inst.txt \
             -fields inst_id,extensions,format,template_role,ops,flags \
             -include $(EM_BUILDIR)\dec_priv_col.h -prefix dec_ign
        $(PERL) -p -i.bak -e "s/_IGN\d+// if ( /\s*\{EM_\S*\_IGN\d+,/)" \
            $O\dec_ign_emdb.c	

$O\dec1_emdb.c $O\dec1_emdb.h : $(EMDBDIR)\emdb.txt $(EMDBDIR)\emdb_cut.pl \
            $O\decoder.txt $(EMDBDIR)\dec_stat.txt 
        $(PERL) $(EMDBDIR)\emdb_cut.pl -emdb_path $(EMDBDIR) -dir $O -columns \
            $O\decoder.txt,$(EMDBDIR)\dec_stat.txt -fields\
mnemonic,dec_flags,template_role,ops,modifiers,flags,specul_flag,false_pred_flag,imp_dsts,imp_srcs,br_hint_flag,br_flag,adv_load_flag,control_transfer_flag \
            -prefix dec1

$(IA64_DIS_INC)\EM_hints.h: $O\EM_hints.h
        copy $O\EM_hints.h $(IA64_DIS_INC)\EM_hints.h

$(IA64_DIS_INC)\inst_ids.h: $O\inst_ids.h
        copy $O\inst_ids.h $(IA64_DIS_INC)\inst_ids.h

$O\inst_ids.h: $O\inst_emdb.tab $(EM_BUILDIR)\inst_id.perl \
            ..\copyright\external\c_file
	$(PERL) $(EM_BUILDIR)\inst_id.perl $O $(EMDBDIR)

$O\all_emdb.tab: $(EMDBDIR)\emdb.txt
        $(PERL) $(EMDBDIR)\emdb_cut.pl -table -emdb_path $(EMDBDIR) -dir $O \
             -fields inst_id,mnemonic -prefix all

$O\decoder.txt $O\EM_hints.h: $O\all_emdb.tab $(EMDBDIR)\emdb_cut.pl
	$(PERL) $(EMDBDIR)\dec_private.perl $O $(EMDBDIR)

!if "$(GENERATE_DECISION_TREE)" == ""

$O\decision_tree.c: decision_tree.c
	copy decision_tree.c $O

!else

$O\tree_builder.h : $(EM_BUILDIR)\tree_builder.c 
	echo "building tree_builder.h"
	$(MHDR) $O\tree_builder.h $(EM_BUILDIR)\tree_builder.c

$O\decision_tree.c: $O\tree_builder$(EEXT)
	"$O\tree_builder$(EEXT)" $O\decision_tree.c

$O\builder_info.obj: $O\builder_info.c

$O\dec_ign_emdb.obj: $O\dec_ign_emdb.c

$O\tree_builder.c: $(EM_BUILDIR)\tree_builder.c
        copy $(EM_BUILDIR)\tree_builder.c $O
        
$O\tree_builder.obj: $O\tree_builder.c

$O\tree_builder$(EEXT): $(EM_BUILDIR)\tree.h $O\tree_builder.h \
            $O\inst_ids.h $O\inst_ign_ids.h \
            $O\builder_info.obj $O\dec_ign_emdb.obj $O\tree_builder.obj
        $(LINKER) @<<
$(LINKER_FLAGS: =
)
-subsystem:console
$O\builder_info.obj
$O\dec_ign_emdb.obj
$O\tree_builder.obj
..\iel\$O\iel.lib
$(CRTLIBS)
$(UMLIBS)
$(LINKLIBS)
<<NOKEEP

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\decem\build\tree_builder.c ===
/***                                                                                 ***/
/***   INTEL CORPORATION PROPRIETARY INFORMATION                                     ***/
/***                                                                                 ***/
/***   This software is supplied under the terms of a license                        ***/
/***   agreement or nondisclosure agreement with Intel Corporation                   ***/
/***   and may not be copied or disclosed except in accordance with                  ***/
/***   the terms of that agreement.                                                  ***/
/***   Copyright (c) 1992,1993,1994,1995,1996,1997,1998,1999,2000 Intel Corporation. ***/
/***                                                                                 ***/


/* tree_builder.c */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "builder_info.h"
#include "tree_builder.h"
#include "tree.h"
#include "deccpu_emdb.h"
#include "dec_ign_emdb.h"

#define FUNC
#define START_BIT 6     /* start bit of extension calculations, after qp */
#define MAX_NODES 10000  /* empirical desicion of tree size */ 

unsigned int next_free_node = 0; /* global variable, which points to the next
									free node at all times. At the end of
									build_tree(), it holds the number of
									entries in the tree */
U64 ONE64 = IEL_CONST64(1, 0);

U64 emdb_ext_values[DEC_IGN_NUM_INST];
short cover_emdb_lines[DEC_IGN_NUM_INST];
Internal_node_t tree[MAX_NODES];  /* change this when number is known */

/***********************************************************************
  main - this function calculates the value of the extensions for each
  emdb line, builds the decision tree, and prints em_decision_tree
  in decision_tree.c.
***********************************************************************/

FUNC void __cdecl main(int argc, char** argv)
{
	init_arrays();

	build_tree();

	/*** check emdb line coverage ***/
	check_coverage();
	print_tree(argv[1]);
	
	exit(0);
}

/***********************************************************************
  init_arrays - this function calculates the value of the
  extensions for each emdb line, that is, it creates a bit pattern which
  represents the encoding of the extensions of an emdb line.
***********************************************************************/
FUNC void init_arrays()
{
	U64 value, ext_val;
	int i, pos;
	Inst_id_t emdb_entry;
	Format_t format;

	/*** calculate emdb lines extensions ***/
	IEL_ZERO(emdb_ext_values[0]); /* illop */
	for (emdb_entry = EM_INST_NONE+1; emdb_entry < EM_INST_NONE+DEC_IGN_NUM_INST;
		 emdb_entry++)
	{
		format = dec_ign_EMDB_info[emdb_entry].format;
		IEL_ZERO(value);
		for (i = 0; i < MAX_NUM_OF_EXT; i++)
		{
			pos = format_extensions[format][i].pos;
			IEL_CONVERT2(ext_val, dec_ign_EMDB_info[emdb_entry].extensions[i], 0);
			IEL_SHL(ext_val, ext_val, pos);
			IEL_OR(value, value, ext_val);
		}
		IEL_ASSIGNU(emdb_ext_values[emdb_entry], value);
	}

	/*** init cover_emdb_lines[] ***/
	for (emdb_entry = EM_INST_NONE+1; emdb_entry < EM_INST_NONE+DEC_IGN_NUM_INST;
		 emdb_entry++)
	{
		cover_emdb_lines[emdb_entry] = 0;
	}
}

/***********************************************************************
  build_tree - builds the decision tree
***********************************************************************/
FUNC void build_tree()
{
	Square_t square;
	unsigned int cur_node = 0;
	
	next_free_node = cur_node + EM_SQUARE_LAST;
	
	for (square = EM_SQUARE_FIRST; square < EM_SQUARE_LAST; square++)
	{
		build_node(format_extension_masks,
					   square_emdb_lines[square], cur_node);
		cur_node++;
	}
}

/***********************************************************************
  build_node - input: array extension bit masks of each format
                      emdb lines list
					  currrent node
		       builds the current node, calls build_node recursively
			   for each son.
***********************************************************************/
FUNC void build_node(U64 *format_masks,
					 Inst_id_list_t emdb_lines, unsigned int cur_node)
{
	U64 emdb_values[MAX_EMDB_LINES];
	unsigned int i, j;
	U64 intersect, delete_bits;
	U64 intersect_mask = IEL_CONST64(0xffffffff, 0xffffffff);
	int pos, size, number_of_sons;
	unsigned int line_count;
	Format_t format;
	U64 new_format_masks[EM_FORMAT_LAST];
	Inst_id_list_t new_emdb_lines;

	/*** empty node - ILLOP ***/
	if (emdb_lines.num_of_lines == 0)
	{
		tree[cur_node].pos = tree[cur_node].size = -1;
		tree[cur_node].next_node = EM_ILLOP;
		return;
	}
	/*** one line in node - a single emdb entry ***/
	if (emdb_lines.num_of_lines == 1)
	{
		format = dec_ign_EMDB_info[emdb_lines.inst_ids[0]].format;
		if (IEL_ISZERO(format_masks[format]))
		{
			/* all extensions are cheked */
			tree[cur_node].pos = tree[cur_node].size = -1;
			tree[cur_node].next_node = dec_ign_EMDB_info[emdb_lines.inst_ids[0]].inst_id;
			cover_emdb_lines[tree[cur_node].next_node]++;
			return;
		}
		intersect_mask =   format_masks[format];
	}
	else
	{
		/*** this line is reached when there are more than one emdb lines
		  which participate in this node ***/
		/*** calculate intersecting extensions ***/
		for (i = 0; i < (unsigned int)emdb_lines.num_of_lines; i++)
		{
			format = dec_ign_EMDB_info[emdb_lines.inst_ids[i]].format;
			IEL_AND(intersect_mask, intersect_mask, format_masks[format]);
		}
	}

	find_largest_intersection(intersect_mask, &pos, &size);
	if (pos == -1)  /*** no intersection found ***/
	{
		fprintf(stderr, "no intersection in node %d\n", cur_node);
		exit(1);
	}

	/*** delete intersect mask bits from participating formats ***/
	for (i = EM_FORMAT_NONE; i < EM_FORMAT_LAST; i++)
	{
		IEL_ASSIGNU(new_format_masks[i], format_masks[i]);
	}

	/*** intersect = ((1 << size) -1) << pos; ***/
	IEL_SHL(intersect, ONE64, size);
	IEL_DECU(intersect);
	IEL_SHL(intersect, intersect, pos);
	
	IEL_NOT(delete_bits, intersect);
	for (i = 0; i < (unsigned int)emdb_lines.num_of_lines; i++)
	{
		format = dec_ign_EMDB_info[emdb_lines.inst_ids[i]].format;
		IEL_AND(new_format_masks[format], delete_bits, format_masks[format]);
	}

	/*** calculate values of participating emdb lines in intersection bits ***/
	build_emdb_values(emdb_values, emdb_lines, intersect, pos, size);
	
	/*** update current node ***/
	tree[cur_node].next_node = next_free_node;
	tree[cur_node].pos = pos;
	tree[cur_node].size = size;

	cur_node = next_free_node;
	if (next_free_node >= MAX_NODES)
	{
		fprintf (stderr, "tree is larger than %d\n", MAX_NODES);
		exit(1);
	}
	number_of_sons = (int)pow((double)2, (double)size);
	next_free_node += number_of_sons;

	/*** loop on each of the node's sons, build the tree recursively ***/
	for (i = 0; i < (unsigned int)number_of_sons; i++)
	{
		line_count = 0;
		new_emdb_lines.num_of_lines = 0;
		for (j = 0; j < (unsigned int)emdb_lines.num_of_lines; j++)
		{
			if (IEL_GETDW0(emdb_values[j]) == i && (!IEL_GETDW1(emdb_values[j])))
			            /*** emdb line has the value i ***/
			{
				new_emdb_lines.num_of_lines++;
				new_emdb_lines.inst_ids[line_count++] = emdb_lines.inst_ids[j];
			}
		}
		build_node(new_format_masks, new_emdb_lines, cur_node);
		cur_node++;
	}
}

/***********************************************************************
  build_emdb_values - input: - pointer to an array into which
                               calculated values of extensions
							   will be written.
							 - emdb lines list
							 - bit pattern in which to calculate values
							 - pos - start bit of pattern
				      calculates values of emdb lines in all bits which
					  are set in pattern
***********************************************************************/
FUNC void build_emdb_values(U64 *emdb_values,
							Inst_id_list_t emdb_lines,
							U64 pattern,
							int pos, int size)
{
	int i;
	U64 value;
/*	Format_t format;
	int j;
	char match;
	int new_pos, new_size;
*/
	for (i = 0; i < emdb_lines.num_of_lines; i++)
	{
		IEL_ASSIGNU(value, emdb_ext_values[emdb_lines.inst_ids[i]]);
		
		/*** emdb_values[i] = (value & pattern) >> pos; ***/
		IEL_AND(emdb_values[i], value, pattern);
		IEL_SHR(emdb_values[i], emdb_values[i], pos);
		

/*		format = dec_ign_EMDB_info[emdb_lines.inst_ids[i]].format;
		new_pos = pos+START_BIT;
		new_size = size;
		match = 0;
		for (j = MAX_NUM_OF_EXT-1; j >= 0; j--)
		{
			if (format_extensions[format][j].pos == new_pos)
			{
				if (format_extensions[format][j].size == new_size)
				{
					match = 1;
				}
				else if (format_extensions[format][j].size > new_size)
				{
					fprintf(stderr,
							"the intersection of emdb line %d is not full\n",
							emdb_lines.inst_ids[i]);
					exit(1);
				}
				else
				{
					new_pos += format_extensions[format][j].size;
					new_size -= format_extensions[format][j].size;
				}
			}
		}
		if (!match)
		{
			fprintf(stderr,
					"the intersection of emdb line %d is not full\n",
					emdb_lines.inst_ids[i]);
			exit(1);
		}
		*/
	}
}

/***********************************************************************
  find_largest_intersection - fast algorithm for finding largest group of
                              consecutive set bits in pattern.
							  (Yigal's algorithm)
***********************************************************************/
FUNC void find_largest_intersection(U64 pattern, int *pos, int *size)
{
	U64 x;
	U64 y, z, u;

	IEL_ASSIGNU(x, pattern);
	*size = 0;     /* largest intersection counter */
	IEL_SHR(y, x, 1);
	IEL_NOT(z, x); /* negation of the input pattern */
	IEL_OR(y, y, z); /* y - mask */

	while (!IEL_ISZERO(x))
	{
		IEL_ASSIGNU(u, x); /* for saving the last bit pattern */
		IEL_AND(x, x, y);
		IEL_SHR(y, y, 1);  /* shift right mask */
		(*size)++;
	}

	/* inspect the high word for left most 1 */
	if (IEL_GETDW1(u) & 0xffe00000)  /* something in bits 21-31 */
	{
		*pos = 21 + LOG2[IEL_GETDW1(u) >> 21] + 32;
	}
	else if (IEL_GETDW1(u) & 0x1ffc00)  /* something in bits 10-20 */
	{
		*pos = 10 + LOG2[IEL_GETDW1(u) >> 10] + 32;
	}
	else if (IEL_GETDW1(u))
	{
		*pos = LOG2[IEL_GETDW1(u)] + 32;
	}
	/* inspect the low word for left most 1 */
	else if (IEL_GETDW0(u) & 0xffe00000)  /* something in bits 21-31 */
	{
		*pos = 21 + LOG2[IEL_GETDW0(u) >> 21];
	}
	else if (IEL_GETDW0(u) & 0x1ffc00)  /* something in bits 10-20 */
	{
		*pos = 10 + LOG2[IEL_GETDW0(u) >> 10];
	}
	else
	{
		*pos = LOG2[IEL_GETDW0(u)];
	}
}	

	

/***********************************************************************
  check_coverage - check coverage of emdb lines in the tree
***********************************************************************/
FUNC void check_coverage()
{
	Inst_id_t emdb_entry;

	for (emdb_entry = EM_INST_NONE+1; emdb_entry < DECCPU_NUM_INST; emdb_entry++)
	{
		if (cover_emdb_lines[emdb_entry] < 1)
		{
			fprintf(stderr, "%d doesn't appear in the tree\n",
					emdb_entry);
		}
	}
}

/***********************************************************************
  print_tree - prints the initialized em_decision_tree in decision_tree.c
***********************************************************************/
FUNC void print_tree(char* file)
{
	FILE *fd;
	int i;

	if ((fd = fopen(file, "w")) == NULL)
	{
		fprintf(stderr, "Couldn't open decision_tree.c\n");
		exit(1);
	}

	fprintf(fd, "/*** decision_tree.c ***/\n\n#include \"decision_tree.h\"\n\n");

	fprintf(fd, "Node_t em_decision_tree[] = {\n");

	/*** traverse the tree ***/
	for (i = 0; i < (int)next_free_node; i++)
	{
		fprintf(fd, "/*%05d*/     {%d, %d, %d}", i, tree[i].next_node,
				tree[i].pos, tree[i].size);
		if (i != (int)next_free_node-1)
		{
			fprintf(fd, ",");
		}
		fprintf(fd, "\n");
	}
	fprintf(fd, "};\n");
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\iel\iel_ver.c ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


void IEL_VER (void); 
void IEL_VER () {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\iel\iel_glob.c ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "iel.h"

#ifdef LP64
Ulong64         IEL_temp64;
#endif

unsigned int IEL_t1, IEL_t2, IEL_t3, IEL_t4;
U32  IEL_tempc;
U64  IEL_et1, IEL_et2;
U128 IEL_ext1, IEL_ext2, IEL_ext3, IEL_ext4, IEL_ext5;
S128 IEL_ts1, IEL_ts2;

U128 IEL_POSINF = IEL_CONST128(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x7fffffff);
U128 IEL_NEGINF = IEL_CONST128( 0,  0,  0, 0x80000000);
U128 IEL_MINUS1 = IEL_CONST128(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF); /* added by myself, since there are
                                                                                   references to the variable in
                                                                                   iel.h (iel.h.base).              */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\include\emdb_types.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef EMDB_TYPES_H
#define EMDB_TYPES_H

/* Flags */
#define EM_FLAG_PRED   0x1
#define EM_FLAG_PRIVILEGED   0x2
#define EM_FLAG_LMEM   0x4
#define EM_FLAG_SMEM   0x8
#define EM_FLAG_CHECK_BASE_EQ_DST  0x10
#define EM_FLAG_FIRST_IN_INSTRUCTION_GROUP 0x20
#define EM_FLAG_LAST_IN_INSTRUCTION_GROUP 0x40
#define EM_FLAG_CHECK_SAME_DSTS 0x80
#define EM_FLAG_SLOT2_ONLY 0x100
#define EM_FLAG_TWO_SLOT 0x200
#define EM_FLAG_OK_IN_MLX 0x400
#define EM_FLAG_CHECK_EVEN_ODD_FREGS 0x800
#define EM_FLAG_CTYPE_UNC 0x1000            /* designates all cmp.unc like instructions */
#define EM_FLAG_UNUSED_HINT_ALIAS 0x02000
#define EM_FLAG_ILLEGAL_OP 0x04000
#define EM_FLAG_IGNORED_OP 0x08000
#define EM_FLAG_ENDS_INSTRUCTION_GROUP 0x10000
#define EMDB_LAST_FLAG EM_FLAG_ENDS_INSTRUCTION_GROUP


/* Implementations */

#define ArchRev0      0
#define Impl_Brl      0x100
#define Impl_Ipref    0x200
#define Impl_Itanium  0x400
#define Impl_McKinley 0x800


#define MAX_EXTENSION 8

typedef enum {
    EM_OPROLE_NONE = 0,
    EM_OPROLE_SRC,
    EM_OPROLE_DST,
    EM_OPROLE_SRC_DST,
    EM_OPROLE_DST_SRC,
    EM_OPROLE_LAST
} Operand_role_t;

typedef enum {
    EM_OPTYPE_NONE = 0,
    EM_OPTYPE_REG_FIRST,      /* The following types are registers */
    EM_OPTYPE_IREG,           /* Integer register */
    EM_OPTYPE_IREG_R0_3,      /* r0-r3 */
    EM_OPTYPE_IREG_R0,        /* Integer register R0 */
    EM_OPTYPE_IREG_R1_127,    /* r1-r127 */
    EM_OPTYPE_FREG,           /* FP register */
	EM_OPTYPE_FREG_F2_127,    /* f2-f127 */
    EM_OPTYPE_BR,             /* branch register */
    EM_OPTYPE_IP,             /* instruction pointer, not encoded */
    EM_OPTYPE_PREG,           /* predicate */
    EM_OPTYPE_PREGS_ALL,      /* the predicate register */
    EM_OPTYPE_PREGS_ROT,      /* rotating predicates */
    EM_OPTYPE_APP_REG_GRP_LOW,         /* application registers 0-63*/
    EM_OPTYPE_APP_REG_GRP_HIGH,        /* application registers 64-127*/
    EM_OPTYPE_APP_CCV,        /* ar.ccv */
    EM_OPTYPE_APP_PFS,        /* ar.pfs */
    EM_OPTYPE_CR,             /* control registers */
    EM_OPTYPE_PSR_L,          /* psr.l */
    EM_OPTYPE_PSR_UM,         /* psr.um */
    EM_OPTYPE_FPSR,           /* decoder operand types */
    EM_OPTYPE_CFM,
    EM_OPTYPE_PSR,
    EM_OPTYPE_IFM,
    EM_OPTYPE_REG_LAST,       /* End of register - types */
    EM_OPTYPE_REGFILE_FIRST,  /* The following types are register-files */
    EM_OPTYPE_PMC,
    EM_OPTYPE_PMD,
    EM_OPTYPE_PKR,
    EM_OPTYPE_RR,
    EM_OPTYPE_IBR,
    EM_OPTYPE_DBR,
    EM_OPTYPE_ITR,
    EM_OPTYPE_DTR,
    EM_OPTYPE_MSR,
    EM_OPTYPE_CPUID,
    EM_OPTYPE_REGFILE_LAST,   /* End of register-file types */
    EM_OPTYPE_IMM_FIRST,      /* The following types are immediates */
    EM_OPTYPE_UIMM,           /* unsigned immediate */
    EM_OPTYPE_SIMM,           /* signed immediate */
    EM_OPTYPE_IREG_NUM,       /* ireg in syntax and imm7 in encodings */
    EM_OPTYPE_FREG_NUM,       /* freg in syntax and imm7 in encodings */
    EM_OPTYPE_SSHIFT_REL,     /* pc relative signed immediate
                                 which is shifted by 4 */
    EM_OPTYPE_SSHIFT_1,       /* unsigned immediate which has to be
                                 shifted 1 bit */
    EM_OPTYPE_SSHIFT_16,      /* unsigned immediate which has to be
                                 shifted 16 bits */
    EM_OPTYPE_COUNT_123,      /* immediate which can have the values of
                                 1, 2, 3 only */
    EM_OPTYPE_COUNT_PACK,     /* immediate which can have the values of
                                        0, 7, 15, 16 only */
    EM_OPTYPE_UDEC,           /* unsigned immediate which has to be
                                 decremented by 1 by the assembler */
    EM_OPTYPE_SDEC,           /* signed immediate which has to be
                                 decremented by 1 by the assembler */
    EM_OPTYPE_CCOUNT,         /* in pshl[24] - uimm5 in syntax, but encoded
                                 as its 2's complement */
    EM_OPTYPE_CPOS,           /* in dep fixed form - uimm6 in syntax, but encoded
                                 as its 2's complement */
    EM_OPTYPE_SEMAPHORE_INC,  /* immediate which is a semaphore increment amount
                                 can have the values of -16,-8,-4,-1,
                                 1,4,8,16 */
    EM_OPTYPE_ONE,            /* the number 1 */
    EM_OPTYPE_FCLASS,         /* immediate of the fclass instruction */
    EM_OPTYPE_CMP_UIMM,       /* unsigned immediate of cmp geu and ltu */
    EM_OPTYPE_CMP_UIMM_DEC,   /* unsigned immediate of cmp gtu and leu */
    EM_OPTYPE_CMP4_UIMM,      /* unsigned immediate of cmp4 geu and ltu */
    EM_OPTYPE_CMP4_UIMM_DEC,  /* unsigned immediate of cmp4 gtu and leu */
    EM_OPTYPE_ALLOC_IOL,      /* for alloc : input, local, and output
                                 can be 0-96 */
    EM_OPTYPE_ALLOC_ROT,      /* for alloc : rotating, can be 0-96 */
    EM_OPTYPE_MUX1,           /* immediate of the mux1 instruction */
    EM_OPTYPE_EIGHT,          /* immediate for ldfps base update form can have value 8 */
    EM_OPTYPE_SIXTEEN,        /* immediate for ldfp8 and ldfpd base update form can have value 16 */
    EM_OPTYPE_IMM_LAST,       /* End of immediate types */
    EM_OPTYPE_MEM,            /* memory address */
    EM_OPTYPE_LAST
} Operand_type_t;

typedef enum {
      EM_FORMAT_NONE = 0,
      EM_FORMAT_A1,
      EM_FORMAT_A2,
      EM_FORMAT_A3,
      EM_FORMAT_A4,
      EM_FORMAT_A4_1,
      EM_FORMAT_A5,
      EM_FORMAT_A6,
      EM_FORMAT_A6_1,
      EM_FORMAT_A6_2,
      EM_FORMAT_A6_3,
      EM_FORMAT_A6_4,
      EM_FORMAT_A6_5,
      EM_FORMAT_A6_6,
      EM_FORMAT_A6_7,
      EM_FORMAT_A7,
      EM_FORMAT_A7_1,
      EM_FORMAT_A7_2,
      EM_FORMAT_A7_3,
      EM_FORMAT_A7_4,
      EM_FORMAT_A7_5,
      EM_FORMAT_A7_6,
      EM_FORMAT_A7_7,
      EM_FORMAT_A8,
      EM_FORMAT_A8_1,
      EM_FORMAT_A8_2,
      EM_FORMAT_A8_3,
      EM_FORMAT_A9,
      EM_FORMAT_A10,
      EM_FORMAT_I1,
      EM_FORMAT_I2,
      EM_FORMAT_I3,
      EM_FORMAT_I4,
      EM_FORMAT_I5,
      EM_FORMAT_I6,
      EM_FORMAT_I7,
      EM_FORMAT_I8,
      EM_FORMAT_I9,
      EM_FORMAT_I10,
      EM_FORMAT_I11,
      EM_FORMAT_I12,
      EM_FORMAT_I13,
      EM_FORMAT_I14,
      EM_FORMAT_I15,
      EM_FORMAT_I16,
      EM_FORMAT_I16_1,
      EM_FORMAT_I16_2,
      EM_FORMAT_I16_3,
      EM_FORMAT_I17,
      EM_FORMAT_I17_1,
      EM_FORMAT_I17_2,
      EM_FORMAT_I17_3,
      EM_FORMAT_I19,
      EM_FORMAT_I20,
      EM_FORMAT_I21,
      EM_FORMAT_I22,
      EM_FORMAT_I23,
      EM_FORMAT_I24,
      EM_FORMAT_I25,
      EM_FORMAT_I26,
      EM_FORMAT_I27,
      EM_FORMAT_I28,
      EM_FORMAT_I29,
      EM_FORMAT_M1,
      EM_FORMAT_M2,
      EM_FORMAT_M3,
      EM_FORMAT_M4,
      EM_FORMAT_M5,
      EM_FORMAT_M6,
      EM_FORMAT_M7,
      EM_FORMAT_M8,
      EM_FORMAT_M9,
      EM_FORMAT_M10,
      EM_FORMAT_M11,
      EM_FORMAT_M12,
      EM_FORMAT_M13,
      EM_FORMAT_M14,
      EM_FORMAT_M15,
      EM_FORMAT_M16,
      EM_FORMAT_M17,
      EM_FORMAT_M18,
      EM_FORMAT_M19,
      EM_FORMAT_M20,
      EM_FORMAT_M21,
      EM_FORMAT_M22,
      EM_FORMAT_M23,
      EM_FORMAT_M24,
      EM_FORMAT_M25,
      EM_FORMAT_M26,
      EM_FORMAT_M27,
      EM_FORMAT_M28,
      EM_FORMAT_M29,
      EM_FORMAT_M30,
      EM_FORMAT_M31,
      EM_FORMAT_M32,
      EM_FORMAT_M33,
      EM_FORMAT_M34,
      EM_FORMAT_M34_1,
      EM_FORMAT_M35,
      EM_FORMAT_M36,
      EM_FORMAT_M37,
      EM_FORMAT_M38,
      EM_FORMAT_M39,
      EM_FORMAT_M40,
      EM_FORMAT_M41,
      EM_FORMAT_M42,
      EM_FORMAT_M43,
      EM_FORMAT_M44,
      EM_FORMAT_M45,
      EM_FORMAT_M46,
      EM_FORMAT_M1001,
      EM_FORMAT_B1,
      EM_FORMAT_B2,
      EM_FORMAT_B3,
      EM_FORMAT_B4,
      EM_FORMAT_B5,
      EM_FORMAT_B6,
      EM_FORMAT_B7,
      EM_FORMAT_B8,
      EM_FORMAT_B9,
      EM_FORMAT_F1,
      EM_FORMAT_F1_1,
      EM_FORMAT_F2,
      EM_FORMAT_F3,
      EM_FORMAT_F4,
      EM_FORMAT_F4_1,
      EM_FORMAT_F4_2,
      EM_FORMAT_F4_3,
      EM_FORMAT_F4_4,
      EM_FORMAT_F4_5,
      EM_FORMAT_F4_6,
      EM_FORMAT_F4_7,
      EM_FORMAT_F5,
      EM_FORMAT_F5_1,
      EM_FORMAT_F5_2,
      EM_FORMAT_F5_3,
      EM_FORMAT_F6,
      EM_FORMAT_F7,
      EM_FORMAT_F8,
      EM_FORMAT_F8_4,
      EM_FORMAT_F9,
      EM_FORMAT_F9_1,
      EM_FORMAT_F10,
      EM_FORMAT_F11,
      EM_FORMAT_F12,
      EM_FORMAT_F13,
      EM_FORMAT_F14,
      EM_FORMAT_F15,
      EM_FORMAT_X1,
      EM_FORMAT_X2,
      EM_FORMAT_X3,
      EM_FORMAT_X4,
      EM_FORMAT_X41,
      EM_FORMAT_LAST
} Format_t;

typedef enum {
    EM_TROLE_NONE = 0,
    EM_TROLE_ALU,
    EM_TROLE_BR,
    EM_TROLE_FP,
    EM_TROLE_INT,
    EM_TROLE_LONG,
    EM_TROLE_MEM,
    EM_TROLE_MIBF,
    EM_TROLE_LAST
} Template_role_t;

typedef char *Mnemonic_t;
typedef char Major_opcode_t;
typedef short Extension_t[MAX_EXTENSION];
typedef struct {
    Operand_role_t operand_role;
    Operand_type_t operand_type;
} Operand_t;
typedef unsigned long Flags_t;
typedef unsigned long Implementation_t;


#endif /*** EMDB_TYPES_H ***/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\include\em.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef EM_H
#define EM_H

/*** UPDATED TO 2.6 draft ***/

#include "iel.h"
#include "EM_hints.h"

/*****************************************************************************/
/***                                                                       ***/
/***       Enhanced mode architecture constants and macros                 ***/
/***                                                                       ***/
/***  NOTE: this header files assumes that the following typedef's exist:  ***/
/***        U8, U16, U32, U64. iel.h contains these typedefs, but one      ***/
/***        may want to define them differently.                           ***/
/***                                                                       ***/
/*****************************************************************************/

#define EM_BUNDLE_SIZE              16
#define EM_SYLLABLE_BITS            41
#define EM_DISPERSAL_POS            0
#define EM_DISPERSAL_BITS           5
#define EM_SBIT_POS                 0
#define EM_TEMPLATE_POS             1
#define EM_TEMPLATE_BITS            4
#define EM_NUM_OF_TEMPLATES         (1<<EM_TEMPLATE_BITS) 
                                        /*** including the reserved!!! ***/
#define EM_SYL2_POS                 (EM_DISPERSAL_POS+EM_DISPERSAL_BITS)

#define EM_MAJOR_OPCODE_POS         37
#define EM_MAJOR_OPCODE_BITS        4
#define EM_PREDICATE_POS            0
#define EM_PREDICATE_BITS           6

#define EM_IL_SLOT_BITS             4
#define EM_IL_SLOTS_MASK32      ((1<<EM_IL_SLOT_BITS)-1)

typedef enum
{
    EM_SLOT_0=0,
    EM_SLOT_1=1,
    EM_SLOT_2=2,
    EM_SLOT_LAST=3
} EM_slot_num_t;

/****************************************************************************/
/*** the following macros needs iel. Bundle assumed to be in U128         ***/

/*** Bring syllable binary to bits 0-40 of Syl; DO NOT mask off bits 41   ***/
/*** and on (for movl, can use Slot=2 but then Maj.Op. is in bits 79-82!) ***/

#define EM_GET_SYLLABLE(syl,bundle,slot) \
        IEL_SHR((syl), (bundle), EM_SYL2_POS+(slot)*EM_SYLLABLE_BITS)

#define EM_GET_TEMPLATE(bundle) \
        ((IEL_GETDW0(bundle) >> EM_TEMPLATE_POS) & ((1<<EM_TEMPLATE_BITS)-1))

#define EM_TEMPLATE_IS_RESERVED(templt) \
(((templt)==3)||((templt)==10)||((templt)==13)||((templt)==15))

#define EM_IL_GET_BUNDLE_ADDRESS(il,addr) \
        IEL_CONVERT2((addr),IEL_GETDW0(il) & \
                            (unsigned int)(~EM_IL_SLOTS_MASK32), \
                     IEL_GETDW1(il))

#define EM_IL_GET_SLOT_NO(il)  (IEL_GETDW0(il) & EM_IL_SLOTS_MASK32)

#define EM_IL_SET(il,addr,slot) \
        IEL_CONVERT2((il), IEL_GETDW0(addr) | (slot), IEL_GETDW1(addr))

#define EM_IS_IGNORED_SQUARE(template_role, major_opcode)       \
        (((template_role) == EM_TROLE_BR) &&                    \
         (major_opcode == 3 || major_opcode == 6) ? 1 : 0)

#define EM_IS_GENERIC_INST(impls_flag) \
		((impls_flag == ArchRev0) || (impls_flag & Impl_Brl))

#define EM_IS_ITANIUM_INST(impls_flag) \
		(EM_IS_GENERIC_INST(impls_flag) || (impls_flag & Impl_Ipref) || (impls_flag & Impl_Itanium))


/*****************************************************************************/

typedef U64     EM_IL;     /* Instruction (syllable) Location */

typedef enum em_branch_type_s
{
    EM_branch_type_none          = 0x0,
    EM_branch_type_direct_cond   = 0x1,
    EM_branch_type_direct_wexit  = 0x2,
    EM_branch_type_direct_wtop   = 0x3,   
    EM_branch_type_direct_cloop  = 0x4,   
    EM_branch_type_direct_cexit  = 0x5,   
    EM_branch_type_direct_ctop   = 0x6,   
    EM_branch_type_direct_call   = 0x7,   
    EM_branch_type_direct_last   = 0x8,   
    EM_branch_type_indirect_cond = 0x9,
    EM_branch_type_indirect_ia   = 0xa,
    EM_branch_type_indirect_ret  = 0xb,
    EM_branch_type_indirect_call = 0xc,
    EM_branch_type_last
} EM_branch_type_t;

typedef enum em_cmp_type_s
{
    EM_cmp_type_none     = 0,  /* none (dstT=REL, dstF=!REL)        */
    EM_cmp_type_and      = 1,  /* and (dstT&=REL, dstF&=REL)        */
    EM_cmp_type_or       = 2,  /* or (dstT|=REL, dstF|=REL)         */
    EM_cmp_type_unc      = 3,  /* uncond (dstT=P&REL, dstF=P&!REL)  */
    EM_cmp_type_or_andcm = 4,  /* or.andcm (dstT|=REL, dstF&=!REL)  */
    EM_cmp_type_last
} EM_cmp_type_t;

typedef enum EM_template_e
{
    EM_template_mii   = 0,
    EM_template_mi_i  = 1,
    EM_template_mlx   = 2,
    /*** 3  reserved ***/
    EM_template_mmi   = 4,
    EM_template_m_mi  = 5,
    EM_template_mfi   = 6,
    EM_template_mmf   = 7,
    EM_template_mib   = 8,
    EM_template_mbb   = 9,
    /*** 10 reserved ***/
    EM_template_bbb   = 11,
    EM_template_mmb   = 12,
    /*** 13 reserved ***/
    EM_template_mfb   = 14,
    /*** 15 reserved ***/
    EM_template_last 
} EM_template_t;


/***** Misc operands values: fclass, sync (stype), mux *****/

typedef enum em_fclass_bit
{
    EM_fclass_bit_pos    = 0 ,
    EM_fclass_bit_neg    = 1 ,
    EM_fclass_bit_zero   = 2 ,
    EM_fclass_bit_unorm  = 3 ,
    EM_fclass_bit_norm   = 4 ,
    EM_fclass_bit_inf    = 5 ,
    EM_fclass_bit_signan = 6 ,
    EM_fclass_bit_qnan   = 7 ,
    EM_fclass_bit_nat    = 8
} EM_fclass_bit_t;
    
#define EM_FCLASS_POS           (1<<EM_fclass_bit_pos   )  /*** 0x001 ***/
#define EM_FCLASS_NEG           (1<<EM_fclass_bit_neg   )  /*** 0x002 ***/
#define EM_FCLASS_ZERO          (1<<EM_fclass_bit_zero  )  /*** 0x004 ***/
#define EM_FCLASS_UNORM         (1<<EM_fclass_bit_unorm )  /*** 0x008 ***/
#define EM_FCLASS_NORM          (1<<EM_fclass_bit_norm  )  /*** 0x010 ***/
#define EM_FCLASS_INF           (1<<EM_fclass_bit_inf   )  /*** 0x020 ***/
#define EM_FCLASS_SIGNAN        (1<<EM_fclass_bit_signan)  /*** 0x040 ***/
#define EM_FCLASS_QNAN          (1<<EM_fclass_bit_qnan  )  /*** 0x080 ***/
#define EM_FCLASS_NAT           (1<<EM_fclass_bit_nat   )  /*** 0x100 ***/

#define EM_MUX_BRCST              0x0
#define EM_MUX_MIX                0x8
#define EM_MUX_SHUF               0x9
#define EM_MUX_ALT                0xA
#define EM_MUX_REV                0xB

/*** sync-stype: arbitrary! need fix!!! <flags> ***/ /* !!!!!??? */
#define EM_STYPE_LOAD             0x0
#define EM_STYPE_STORE            0x1
#define EM_STYPE_EXT              0x2
#define EM_STYPE_PURGE            0x4

#define EM_MAX_MEM_OPERAND_SIZE     32

#define EM_NUM_OF_PRIVILEGE_LEVELS  4

/*** shift of branch/chk (target21 <--> target25) ***/
#define EM_IPREL_TARGET_SHIFT_AMOUNT    4

/*****************************************************/
/***** register-related constants and structures *****/
/*****************************************************/



/* branch register structure definition */

typedef U64 EM_branch_reg_t;

typedef struct EM_FPSR_s
{
    U4byte trap:6,sf0:13,sf1:13;
    U4byte sf2:13,sf3:13,reserved:6;
} EM_FPSR_t;

#define EM_FPSR_S0_ABSOLUTE_MASK           0x7f
#define EM_FPSR_SFX_TD_MASK                0x40
#define EM_FPSR_SFX_PC_MASK                0x0c
#define EM_FPSR_SFX_RESERVED_PC_VALUE      0x04

typedef struct EM_RSC_s
{
    U4byte mode:2, pl:2, be:1, reserved1:11, loadrs:14, reserved2:2;
    U4byte reserved3;
} EM_RSC_t;

typedef struct EM_BSP_s
{
    U4byte ignored:3,pointer_low:29;
    U4byte pointer_high;
} EM_BSP_t;

typedef EM_BSP_t EM_BSPSTORE_t;

typedef struct EM_EC_s
{
    U4byte count:6, ignored1:26;
    U4byte ignored2;
} EM_EC_t;

typedef struct EM_RNAT_s
{
    U4byte rse_nats_low;
    U4byte rse_nats_high:31, ignored:1;
} EM_RNAT_t;

#define EM_FRAME_RRB_MASK_LOW   0x3ffff
#define EM_FRAME_RRB_MASK_HIGH  0xffffffc0
#define EM_FRAME_FP_RRB_MASK 0xfe000000
#define EM_FRAME_FP_RRB_BIT_POS 25
#define EM_FRAME_RRB_FR_LOW_BIT_MASK 0x2000000
#define EM_FRAME_SOL_POS 7
#define EM_FRAME_SOL_MASK 0x3f80
#define EM_FRAME_SOR_POS 14
#define EM_FRAME_SOR_MASK 0x3c000
#define EM_FRAME_SOR_ZERO_BITS_NUM 3
#define EM_FRAME_SOF_MASK 0x7f

typedef struct EM_frame_marker_s
{
    U4byte sof:7, sol:7, sor:4, rrb_int:7, rrb_fp:7;
    U4byte rrb_pred:6, reserved:26;
} EM_frame_marker_t;

#define EM_PFS_CPL_BIT_POS 30
#define EM_PFS_HIGH_EC_BIT_POS 20
#define EM_PFS_CPL_MASK 0xc0000000
#define EM_PFS_EC_MASK 0x03f00000

typedef struct EM_PFS_s
{
    U4byte pfm_l;
    U4byte pfm_h:6, reserved1:14, pec:6, reserved2:4, ppl:2;
} EM_PFS_t;

#define EM_PSR_CPL_MASK      0x3
#define EM_PSR_CPL_BIT_POS   0
#define EM_PSR_H_ED_MASK     0x800
#define EM_PSR_H_ED_BIT_POS  0xb
#define EM_PSR_H_MC_MASK     0x8
#define EM_PSR_H_IT_MASK     0x10

/*** PSR ***/
typedef struct EM_PSR_s
{
    U4byte
    reserved1:1, /*  0 */
    be:1, /*  1 */
    up:1, /*  2 */
    ac:1, /*  3 */
    mfl:1,/*  4 */
    mfh:1,/*  5 */
    reserved2:7,/* 6-12 */
    ic:1, /* 13 */
    i:1,  /* 14 */
    pk:1, /* 15 */
    reserved3:1, /* 16 */ 
    dt:1, /* 17 */
    dfl:1,/* 18 */ 
    dfh:1,/* 19 */
    sp:1, /* 20 */
    pp:1, /* 21 */
    di:1, /* 22 */
    si:1, /* 23 */
    db:1, /* 24 */
    lp:1, /* 25 */
    tb:1, /* 26 */
    rt:1, /* 27 */
    reserved4:4; /* 28-31 */
    U4byte
    cpl:2, /* 32,33 */
    is:1,  /* 34 */
    mc:1,  /* 35 */
    it:1,  /* 36 */
    id:1,  /* 37 */
    da:1,  /* 38 */
    dd:1,  /* 39 */
    ss:1,  /* 40 */
    ri:2,  /* 41,42 */
    ed:1,  /* 43 */
    bn:1,  /* 44 */
    ia:1,  /* 45 */
  reserved5:18; /* 46-63 */
} EM_PSR_t;

/*** DCR ***/
typedef struct EM_DCR_s
{
    U4byte
    pp:1, /*  0 */
    be:1, /*  1 */
    lc:1, /*  2 */
    reserved1:5, /* 3-7 */ 
    dm:1, /*  8 */
    dp:1, /*  9 */
    dk:1, /* 10 */
    dx:1, /* 11 */
    dr:1, /* 12 */
    da:1, /* 13 */
    dd:1, /* 14 */
    reserved4:1,  /* 15 , - was 'du' before eas24 and became reserved */
    reserved2:16; /* 16-31 */
    U4byte reserved3; /* 32-63 */
} EM_DCR_t;

/**** ITM ****/
typedef U64 EM_ITM_t;

/**** IVA ****/
typedef struct EM_IVA_s
{
    U4byte
    ignored:15,
    iva_low:17;
    U4byte iva_high;
} EM_IVA_t;

/**** PTA ****/
typedef struct EM_pta_s
{
    U4byte
    ve:1,        /*  0    */
    reserved1:1, /*  1    */ 
    size:6,      /* 2-7   */ 
    vf:1,        /*  8    */
    reserved2:6, /* 9-14  */  
    base_low:17; /* 15-31 */
    U4byte
    base_high:32;/* 32-63 */
} EM_PTA_t;

/**** IPSR ****/
typedef EM_PSR_t EM_IPSR_t;

/**** ISR ****/
typedef struct EM_ISR_s
{
    U4byte
    code:16,     /*  0-15 */ 
    iA_vector:8, /* 16-23 */  
    reserved1:8; /* 24-31 */
    U4byte
    x:1,         /* 32 */
    w:1,         /* 33 */
    r:1,         /* 34 */
    na:1,        /* 35 */
    sp:1,        /* 36 */
    rs:1,        /* 37 */
    ir:1,        /* 38 */
    ni:1,        /* 39 */
    so:1,        /* 40 */
    ei:2,        /* 41-42 */
    ed:1,        /* 43 */
    reserved2:20;/* 44-63 */
} EM_ISR_t;

/* Low 12 bits of low word of IFA is defined as 
   ignored according to the TLB insertion format */

typedef struct EM_IFA_s
{
    U4byte
    ignored:12,
    vpn_low:20;
    U4byte
    vpn_high;
} EM_IFA_t;

typedef struct EM_IIP_s
{
    U4byte
    vpn_low;
    U4byte
    vpn_high;
} EM_IIP_t;

typedef EM_IIP_t EM_vaddr_t;

/* Unimplemented virtual and physical addresses */
#define   EM_MAX_IMPL_VA_MSB 60  
#define   EM_MIN_IMPL_VA_MSB 50  
#define   EM_MAX_IMPL_PA_MSB 62  
#define   EM_MIN_IMPL_PA_MSB 31

/**** ITIR ***/
typedef struct EM_itir_s
{
    U4byte
    reserved1:2, /* 0-1 */
    ps:6,        /* 2-7 */
    key:24;      /* 8-31 */ 
    U4byte
    reserved2:16, /* 32-47 */
    reserved4:15, /* 48-62 - was ppn */
    reserved3:1;  /* 63 */
} EM_ITIR_t;

#define EM_ITR_PPN_HIGH_OFFSET 24

/**** IIPA ****/
typedef U64 EM_IIPA_t;

/**** IFS ****/
typedef struct
{
    U4byte
    ifm_low;       /* 0-31 */
    U4byte
    ifm_high:6,    /* 32-37 */
    reserved:25,   /* 38-62 */
    v:1;           /* 63    */
} EM_IFS_t;

/**** IIM ****/
typedef struct
{
    U4byte
    imm21:21,    /*  0-20 */
    ignored1:11; /* 21-31 */  
    U4byte ignored2; /* 32-63 */
} EM_IIM_t;

typedef struct EM_IHA_s
{
    U4byte ignored:3,iha_low:29;
    U4byte iha_high;
} EM_IHA_t;

/**** LID ****/
typedef struct
{
    U4byte
    reserved:16,
    eid:8,
    id:8;
    U4byte ignored;
} EM_LID_t;

/**** IVR ****/
typedef struct
{
    U4byte
    vec:8,       /* not "vector" due to IAS issues */
    reserved:8,
    ignored1:16;
    U4byte ignored2;
} EM_IVR_t;

/**** TPR ****/
typedef struct
{
    U4byte
    ignored1:4,
    mic:4,
    reserved:8,
    mmi:1,
    ignored2:15;
    U4byte ignored3;
} EM_TPR_t;

/**** EOI ****/
typedef struct
{
    U4byte ignored1;
    U4byte ignored2;
} EM_EOI_t;

/**** IRR ****/
typedef U64 EM_IRR_t;

/**** ITV ****/
typedef struct
{
    U4byte
    vec:8,         /* not "vector" due to IAS issues */
    reserved1:4,
    zero:1,
    reserved2:3,
    m:1,
    ignored1:15;
    U4byte ignored2;
} EM_ITV_t;

/**** PMV ****/
typedef EM_ITV_t EM_PMV_t;

/**** LRR ****/
typedef struct
{
    U4byte
    vec:8,         /* not "vector" due to IAS issues */
    dm:3,
    reserved1:1,
    ignored3:1,
    ipp:1,
    reserved2:1,
    tm:1,
    m:1,
    ignored1:15;
    U4byte ignored2;
} EM_LRR_t;

/**** BHB ****/
typedef struct
{
    U4byte
    max:10,
    ignored:2,
    base_low:20;
    U4byte 
    base_high;
} EM_BHB_t;

/**** THA ****/
typedef struct
{
    U4byte
    ptr:10,
    bh:1,
    ignored1:1,
    vaddr:20;
    U4byte 
    ignored2;
} EM_THA_t;

/**** CMCV ****/
typedef EM_ITV_t EM_CMCV_t;


/**** RR ****/
typedef struct EM_region_register_s
{
    U4byte
    ve:1,          /*  0 */
    reserved1:1,   /*  1 */
    ps:6,          /*  2-7 */
    rid:24;        /*  8-31 */ 
    U4byte  reserved2; /* 32-63 */
} EM_RR_t;

/**** PKR ****/
typedef struct EM_key_register_s
{
    U4byte
    v:1,   /* 0 */
    wd:1,  /* 1 */
    rd:1,  /* 2 */
    xd:1,  /* 3 */
    reserved1:4,  /* 4-7  */
    key:24;       /* 8-31 */
    U4byte reserved2; /* 32-63 */
} EM_PKR_t;      

typedef U64 EM_DBR_EVEN_t;
typedef U64 EM_IBR_EVEN_t;

typedef struct EM_DBR_ODD_s
{
    U4byte mask_low;           /* 0 - 31  */
    U4byte mask_high:24,       /* 32 - 55 */
           plm:4,              /* 56 - 59 */
           ignored:2,          /* 60 - 61 */
           w:1,                /* 62      */
           r:1;                /* 63      */
} EM_DBR_ODD_t;

typedef struct EM_IBR_ODD_s
{
    U4byte mask_low;           /* 0 - 31  */
    U4byte mask_high:24,       /* 32 - 55 */
           plm:4,              /* 56 - 59 */
           ignored:3,          /* 60 - 62 */
           x:1;                /* 63      */
} EM_IBR_ODD_t;

/**** PMC Registers ****/
/**** PMC0 ****/

typedef struct EM_PMC0_register_s
{
    U4byte 
    fr:1,                      /*   0     */    
    ignored1:3,                /* 1 - 3   */
    overflow:4,                /* 4 - 7   */
    ignored2:24;               /* 8 - 31  */
    U4byte ignored3;           /* 32 - 63 */
} EM_PMC0_t;

/**** PMC1 -  PMC3 ****/

typedef U64 EM_PMC1_3_t;

/**** PMC4 - ****/

typedef struct EM_PMC_register_s
{
    U4byte
    plm:4,                     /* 0 - 3   */
    ev:1,                      /* 4       */
    oi:1,                      /* 5       */
    pm:1,                      /* 6       */
    ignored1:1,                /* 7       */
    es:8,                      /* 8 - 15  */
    umask:4,                   /* 16 - 19 */
    ignored2:12;               /* 20 - 31 */
    U4byte ignored3;           /* 32 - 63 */
} EM_PMC_t;

typedef struct EM_PMD_register_s
{
    U4byte count;             /* 0 - 31  */
    U4byte sxt;               /* 32 - 63 */
} EM_PMD_t;

/* Number of implementet count bits in PMD */
#define EM_PMD_COUNT_SIZE     32

typedef U64 EM_MSR_t;

typedef struct EM_tlb_insert_reg_s
{
    U4byte
    p:1,        /* 0     */
    mx:1,       /* 1     */
    ma:3,       /* 2-4   */
    a:1,        /* 5     */
    d:1,        /* 6     */
    pl:2,       /* 7-8   */
    ar:3,       /* 9-11  */
    ppn_low:20; /* 12-31 */
    U4byte
    ppn_high:12, /* 32-43 */
    reserved2:4, /* 44-47 - was ppn_high */        
    reserved1:4, /* 48-51 */
    ed:1,        /* 52    */
    ignored:11;  /* 63-63 */
} EM_tlb_insert_reg_t;

typedef enum
{
    EM_TLB_ar_r_r_r,         /* 000 */
    EM_TLB_ar_rx_rx_rx,      /* 001 */
    EM_TLB_ar_rw_rw_rw,      /* 010 */
    EM_TLB_ar_rwx_rwx_rwx,   /* 011 */
    EM_TLB_ar_r_rw_rw,       /* 100 */     
    EM_TLB_ar_rx_rx_rwx,     /* 101 */
    EM_TLB_ar_rwx_rw_rw,     /* 110 */
    EM_TLB_ar_x_x_rx,        /* 111 */
    EM_TLB_ar_last
} EM_page_access_right_t;

typedef enum
{                                /* ma  mx */
    EM_VA_MA_WB      = 0x0,      /* 000 0  */
    EM_VA_MA_WT      = 0x4,      /* 010 0 */
    EM_VA_MA_WP      = 0x6,      /* 011 0 */
    EM_VA_MA_UC      = 0x8,      /* 100 0 */
    EM_VA_MA_UCC     = 0x9,      /* 100 1 */
    EM_VA_MA_UCE     = 0xa,      /* 101 0 */
    EM_VA_MA_WC      = 0xc,      /* 110 0 */
    EM_VA_MA_NATPAGE = 0xe       /* 111 0 */
} EM_vaddr_mem_attribute_t;

/* encodings of guest memory attributes */
typedef enum
{
    EM_IA_GVA_MA_UC        = 0x0,      /* 000 */
    EM_IA_GVA_MA_WC        = 0x1,      /* 001 */
    EM_IA_GVA_MA_WT        = 0x4,      /* 100 */
    EM_IA_GVA_MA_WP        = 0x5,      /* 101 */
    EM_IA_GVA_MA_WB        = 0x6,      /* 110 */
    EM_IA_GVA_MA_UC_MINUS  = 0x7       /* 111 */    
} EM_IA_vaddr_gmem_attribute_t;

/* In eas24: attr = ma + mx */
#define EM_VA_IS_MA_ATTRIBUTE_RESERVED(attr)                  \
    (((attr) == 0x2) || ((attr) == 0x4) || ((attr) == 0x6) ||    \
     ((attr) & 0x1))

#define EM_GVA_IS_MA_ATTRIBUTE_RESERVED(attr)                    \
    (((attr) == 0x1) || ((attr) == 0x2) || ((attr) == 0x3) ||    \
     ((attr) == 0x5) || ((attr) == 0x7) || ((attr) == 0xb) ||    \
     ((attr) == 0xd) || ((attr) == 0xf)) 
     
typedef EM_tlb_insert_reg_t EM_vhpt_short_format_t;

typedef struct EM_vhpt_long_format_s
{
    U4byte
    p:1,         /* 0     */
    mx:1,        /* 1     */
    ma:3,        /* 2-4   */
    a:1,         /* 5     */
    d:1,         /* 6     */
    pl:2,        /* 7-8   */
    ar:3,        /* 9-11  */
    ppn_low:20;  /* 12-31 */
    
    U4byte
    ppn_mid:12,  /* 32-43 */
    reserved5:4, /* 44-47 - was ppn_mid*/
    reserved1:4, /* 48-51 */
    ed:1,        /* 52    */ 
    ignored:11;  /* 53-63 */
    
    U4byte
    reserved2:2, /* 0-1   */
    ps:6,        /* 2-7   */
    key:24;      /* 8-31  */
    
    U4byte
    reserved3:16,/* 32-47 */
    reserved6:15, /* 48-62 - was ppn_high */
    reserved4:1; /* 63    */
    
    U64 tag;
    U64 avl3;
} EM_vhpt_long_format_t;

typedef struct EM_gvhpt_short_format_s
{
    U4byte
    p:1,         /* 0     */
    w:1,         /* 1     */
    u:1,         /* 2     */
    pa10:2,      /* 3-4   */
    a:1,         /* 5     */
    d:1,         /* 6     */
    pa2:1,       /* 7     */
    g:1,         /* 8     */
    ignored:3,   /* 9-11  */
    ppn:20;      /* 12 - 31 */     
}EM_gvhpt_short_format_t;

typedef struct EM_gvhpt_long_format_s
{
    U4byte
    p:1,         /* 0     */
    w:1,         /* 1     */
    u:1,         /* 2     */
    pa10:2,      /* 3-4   */
    a:1,         /* 5     */
    d:1,         /* 6     */
    pa2:1,       /* 7     */
    g:1,         /* 8     */
    ignored:3,   /* 9-11  */
    ppn_low:20;  /* 12 - 31 */ 
    U4byte
    ppn_high:16, /* 32-47 */
    reserved:16; /* 48-63 */
}EM_gvhpt_long_format_t;

/* the minimum VHPT size is 2^14 = 16K */
#define EM_MIN_VHPT_SIZE_POWER      14

/* define the number of registers */
#define EM_NUM_OF_GREGS            128
#define EM_NUM_OF_ADD22_GREGS        4
#define EM_NUM_OF_FPREGS           128
#define EM_NUM_OF_PREGS             64
#define EM_NUM_OF_BREGS              8
#define EM_NUM_OF_AREGS            128
#define EM_NUM_OF_CREGS            128
#define EM_NUM_OF_RREGS              8
#define EM_NUM_OF_PKREGS            16
#define EM_NUM_OF_DBREGS            32 /* guess for max value*/
#define EM_NUM_OF_IBREGS            32 /* guess for max value*/
#define EM_NUM_OF_PMCREGS           32 /* guess for max value*/
#define EM_NUM_OF_PMDREGS           32 /* guess for max value*/
#define EM_NUM_OF_MSREGS          2048 /* guess for max value*/
#define EM_NUM_OF_KREGS              8 /* kernel registers are AREGS */
#define EM_NUM_OF_CPUID_REGS         5 /* implementation independent part */
#define EM_NUM_OF_IRREGS             4
#define EM_NUM_OF_BANKED_REGS       16
#define EM_FIRST_BANKED_REG         16
#define EM_FIRST_IN_FP_LOW_REG_SET   0
#define EM_FIRST_IN_FP_HIGH_REG_SET 32

#define EM_PREDICATE_WIRED_TRUE      0
#define EM_STACK_BASE_REGISTER      32
#define EM_REGISTER_STACK_SIZE      96
#define EM_GREG_ROTATING_BASE       32
#define EM_PREG_ROTATING_BASE       16
#define EM_NUM_OF_ROTATING_PREGS    (EM_NUM_OF_PREGS - EM_PREG_ROTATING_BASE)
#define EM_FPREG_ROTATING_BASE      32
#define EM_NUM_OF_ROTATING_FPREGS   (EM_NUM_OF_FPREGS - EM_FPREG_ROTATING_BASE)
#define EM_GREGS_ROTATING_GROUPS    8    

/* kernel registers macros */
#define EM_IS_AREG_A_KREG(n)     (((n) >= EM_AR_KR0) && ((n) <= EM_AR_KR7))
#define EM_AREG_NUM_TO_KREG(n)   ((n) - EM_AR_KR0)
#define EM_KREG_NUM_TO_AREG(n)   ((n) + EM_AR_KR0)
#define EM_IS_KREG_A_AREG(n)     ((n) < 7)

/* PSR user and system mask */
#define EM_PSR_UM_MASK              0x3f
#define EM_PSR_SM_MASK              0xffffff
#define EM_PSR_MFL_MASK             0x10
#define EM_PSR_MFH_MASK             0x20


/* instruction and data TLB translation registers information */
#define EM_TLB_MIN_DATA_TR_NUM         8
#define EM_TLB_MIN_INST_TR_NUM         8
#define EM_TLB_MAX_DATA_TR_NUM       256
#define EM_TLB_MAX_INST_TR_NUM       256
#define EM_TLB_MIN_TLB_TC_NUM          8
#define EM_TLB_MAX_TLB_TC_NUM        256
#define EM_TLB_DATA_TR_NUM_MASK     0xff
#define EM_TLB_INST_TR_NUM_MASK     0xff

/* define the special purpose application registers */
typedef enum
{
    EM_AR_KR0  = 0,
    EM_AR_KR1  = 1,
    EM_AR_KR2  = 2,
    EM_AR_KR3  = 3,
    EM_AR_KR4  = 4,
    EM_AR_KR5  = 5,
    EM_AR_KR6  = 6,
    EM_AR_KR7  = 7,
    /* ar8-15 reserved */
    EM_AR_RSC  = 16,
    EM_AR_BSP  = 17,
    EM_AR_BSPSTORE = 18,
    EM_AR_RNAT = 19,
    /* ar20 reserved */
    EM_AR_FCR  = 21, 
    /* ar22-23 reserved */
    EM_AR_EFLAG  = 24,
    EM_AR_CSD    = 25,
    EM_AR_SSD    = 26,
    EM_AR_CFLG   = 27,
    EM_AR_FSR    = 28,
    EM_AR_FIR    = 29,
    EM_AR_FDR    = 30,
    /* ar31 reserved */
    EM_AR_CCV    = 32,
    /* ar33-35 reserved */
    EM_AR_UNAT = 36,
    /* ar37-39 reserved */
    EM_AR_FPSR = 40,
    /* ar41-43 reserved */
    EM_AR_ITC  = 44,
    /* ar45-47 reserved */
    /* ar48-63 ignored */
    EM_AR_PFS  = 64,
    EM_AR_LC   = 65,
    EM_AR_EC   = 66,
    /* ar67-111 reserved */
    /* ar112-128 ignored */
    EM_AR_LAST = 128
} EM_areg_num_t;

/*****************************/
/*** Control     Registers ***/
/*****************************/
typedef enum
{
    EM_CR_DCR  = 0,
    EM_CR_ITM  = 1,
    EM_CR_IVA  = 2,
    /*** 3-7 reserved ***/
    EM_CR_PTA  = 8,
    EM_CR_GPTA = 9,
    /*** 10-15 reserved ***/
    EM_CR_IPSR = 16,
    EM_CR_ISR  = 17,
    /*** 18 reserved ***/
    EM_CR_IIP  = 19,
    EM_CR_IFA  = 20,
    EM_CR_ITIR = 21,
    EM_CR_IIPA = 22,
    EM_CR_IFS  = 23,
    EM_CR_IIM  = 24,
    EM_CR_IHA  = 25,
    /*** 25-63 reserved ***/
    /*** SAPIC registers ***/
    EM_CR_LID  = 64,
    EM_CR_IVR  = 65,
    EM_CR_TPR  = 66,
    EM_CR_EOI  = 67,
    EM_CR_IRR0 = 68,
    EM_CR_IRR1 = 69,
    EM_CR_IRR2 = 70,
    EM_CR_IRR3 = 71,
    EM_CR_ITV  = 72,
    EM_CR_PMV  = 73,
    EM_CR_CMCV = 74,
    /*** 75-79 reserved  ***/
    EM_CR_LRR0 = 80,
    EM_CR_LRR1 = 81,
    /*** 82-127 reserved ***/
    EM_CR_LAST = 128
} EM_creg_num_t;

typedef enum
{
    EM_CPUID_VENDOR0    = 0,
    EM_CPUID_VENDOR1    = 1,
    EM_CPUID_SERIAL_NUM = 2,
    EM_CPUID_VERSION    = 3,
    EM_CPUID_FEATURES   = 4,
    EM_CPUID_LAST
} EM_cpuid_num_t;

typedef enum
{
    EM_GR_BHB = 6,
    EM_GR_THA = 7
} EM_greg_num_t;

typedef struct EM_CPUID_version_s
{
    U4byte
        number:8,
        revision:8,
        model:8,
        family:8;
    U4byte
        archrev:8,
        reserved1:24;
} EM_CPUID_version_t;

#define EM_NUM_OF_M_ROLE_APP_REGS               64
#define EM_NUM_OF_I_ROLE_APP_REGS       (EM_NUM_OF_AREGS - \
                                         EM_NUM_OF_M_ROLE_APP_REGS)

#define EM_APP_REG_IS_I_ROLE(ar_no)     ((ar_no) >= EM_NUM_OF_M_ROLE_APP_REGS)

#define EM_APP_REG_IS_RESERVED(ar_no)   ((((ar_no) > 7)  && ((ar_no) < 16)) ||\
                                         (((ar_no) > 19) && ((ar_no) < 21)) ||\
                                         (((ar_no) > 21) && ((ar_no) < 24)) ||\
                                         (((ar_no) > 30) && ((ar_no) < 32)) ||\
                                         (((ar_no) > 32) && ((ar_no) < 36)) ||\
                                         (((ar_no) > 36) && ((ar_no) < 40)) ||\
                                         (((ar_no) > 40) && ((ar_no) < 44)) ||\
                                         (((ar_no) > 44) && ((ar_no) < 48)) ||\
                                         (((ar_no) > 66) && ((ar_no) < 112)))

#define EM_APP_REG_IS_IGNORED(ar_no)    ((((ar_no) > 47)  && ((ar_no) < 64))||\
                                         ((ar_no) > 111))

#define EM_CREG_IS_I_ROLE(cr_no)        0
#define EM_CREG_IS_RESERVED(cr_no)      ((((cr_no) > 2)  && ((cr_no) < 8))  ||\
                                         (((cr_no) > 9)  && ((cr_no) < 16)) ||\
                                         ((cr_no) == 18)                    ||\
                                         (((cr_no) > 25) && ((cr_no) < 64)) ||\
                                         (((cr_no) > 74) && ((cr_no) < 80)) ||\
                                         ((cr_no) > 81))

#define EM_PMD_IS_IMPLEMENTED(pmd_no)    ((pmd_no) > 3 && (pmd_no) < 8)
#define EM_PMC_IS_IMPLEMENTED(pmc_no)    ((pmc_no) < 8)

/* Interruption Priorities, taken from Table 10-5 in EAS2.4. */
typedef enum EM_interruption_e
{
    EM_INTR_NONE                                  = 0,
    /* Aborts: IA32, IA64 */
    EM_INTR_MACHINE_RESET                         = 1,
    EM_INTR_MACHINE_CHECK_ABORT                   = 2,
    /* Interrupts: IA32, IA64 */
    EM_INTR_PLATFORM_MANAGEMENT_INTERRUPT         = 3,
    EM_INTR_EXTERNAL_INTERRUPT                    = 4,
    /* Faults: IA64 */
    EM_INTR_IR_UNIMPLEMENTED_DATA_ADDRESS_FAULT   = 5,
    EM_INTR_IR_DATA_NESTED_TLB_FAULT              = 6,
    EM_INTR_IR_ALT_DATA_TLB_FAULT                 = 7,
    EM_INTR_IR_VHPT_DATA_FAULT                    = 8,
    EM_INTR_IR_DATA_TLB_FAULT                     = 9,
    EM_INTR_IR_DATA_PAGE_NOT_PRESENT_FAULT        = 10,
    EM_INTR_IR_DATA_NAT_PAGE_CONSUMPTION_FAULT    = 11,
    EM_INTR_IR_DATA_KEY_MISS_FAULT                = 12,
    EM_INTR_IR_DATA_KEY_PERMISSION_FAULT          = 13,
    EM_INTR_IR_DATA_ACCESS_RIGHT_FAULT            = 14,
    EM_INTR_IR_DATA_ACCESS_BIT_FAULT              = 15,
    EM_INTR_IR_DATA_DEBUG_FAULT                   = 16,
    /* Faults: IA32 */
    EM_INTR_IA_INST_BREAKPOINT_FAULT              = 17,
    EM_INTR_IA_CODE_FETCH_FAULT                   = 18,
    /* Faults: IA32, IA64 */
    EM_INTR_INST_ALT_TLB_FAULT                    = 19,
    EM_INTR_INST_VHPT_FAULT                       = 20,
    EM_INTR_INST_TLB_FAULT                        = 21,
    EM_INTR_INST_PAGE_NOT_PRESENT_FAULT           = 22,
    EM_INTR_INST_NAT_PAGE_CONSUMPTION_FAULT       = 23,
    EM_INTR_INST_KEY_MISS_FAULT                   = 24,
    EM_INTR_INST_KEY_PERMISSION_FAULT             = 25,
    EM_INTR_INST_ACCESS_RIGHT_FAULT               = 26,
    EM_INTR_INST_ACCESS_BIT_FAULT                 = 27,
    /* Faults: IA64 */
    EM_INTR_INST_DEBUG_FAULT                      = 28,
    /* Faults: IA32 */
    EM_INTR_IA_INST_LENGTH_FAULT                  = 29,
    EM_INTR_IA_INVALID_OPCODE_FAULT               = 30,
    EM_INTR_IA_INST_INTERCEPT_FAULT               = 31,
    /* Faults: IA64 */
    EM_INTR_ILLEGAL_OPERATION_FAULT               = 32,
    EM_INTR_BREAK_INSTRUCTION_FAULT               = 33,
    EM_INTR_PRIVILEGED_OPERATION_FAULT            = 34,
    /* Faults: IA32, IA64 */
    EM_INTR_DISABLED_FP_REGISTER_FAULT            = 35,
    EM_INTR_DISABLED_ISA_TRANSITION_FAULT         = 36,
    /* Faults: IA32 */
    EM_INTR_IA_COPROCESSOR_NOT_AVAILABLE_FAULT    = 37,
    EM_INTR_IA_FP_ERROR_FAULT                     = 38,
    /* Faults: IA32, IA64 */
    EM_INTR_REGISTER_NAT_CONSUMPTION_FAULT        = 39,
    /* Faults: IA64 */
    EM_INTR_RESERVED_REGISTER_FIELD_FAULT         = 40,
    EM_INTR_PRIVILEGED_REGISTER_FAULT             = 41,
    EM_INTR_SPECULATIVE_OPERATION_FAULT           = 42,
    /* Faults: IA32 */
    EM_INTR_IA_STACK_EXCEPTION_FAULT              = 43,
    EM_INTR_IA_GENERAL_PROTECTION_FAULT           = 44,
    /* Faults: IA32, IA64 */
    EM_INTR_DATA_NESTED_TLB_FAULT                 = 45, 
    EM_INTR_DATA_ALT_TLB_FAULT                    = 46,
    EM_INTR_DATA_VHPT_FAULT                       = 47,
    EM_INTR_DATA_TLB_FAULT                        = 48,
    EM_INTR_DATA_PAGE_NOT_PRESENT_FAULT           = 49,
    EM_INTR_DATA_NAT_PAGE_CONSUMPTION_FAULT       = 50,
    EM_INTR_DATA_KEY_MISS_FAULT                   = 51,
    EM_INTR_DATA_KEY_PERMISSION_FAULT             = 52,
    EM_INTR_DATA_ACCESS_RIGHT_FAULT               = 53,
    EM_INTR_DATA_DIRTY_BIT_FAULT                  = 54,
    EM_INTR_DATA_ACCESS_BIT_FAULT                 = 55,
    /* Faults: IA64 */
    EM_INTR_DATA_DEBUG_FAULT                      = 56,
    EM_INTR_UNALIGNED_DATA_REFERENCE_FAULT        = 57,
    /* Faults: IA32 */
    EM_INTR_IA_UNALIGNED_DATA_REFERENCE_FAULT     = 58,
    EM_INTR_IA_LOCKED_DATA_REFERENCE_FAULT        = 59,
    EM_INTR_IA_SEGMENT_NOT_PRESENT_FAULT          = 60,
    EM_INTR_IA_DIVIDE_BY_ZERO_FAULT               = 61,
    EM_INTR_IA_BOUND_FAULT                        = 62,
    EM_INTR_IA_KNI_NUMERIC_ERROR_FAULT            = 63,
    /* Faults: IA64 */
    EM_INTR_LOCKED_DATA_REFERENCE_FAULT           = 64,
    EM_INTR_FP_EXCEPTION_FAULT                    = 65,
    /* Traps: IA64 */
    EM_INTR_UNIMPLEMENTED_INST_ADDRESS_TRAP       = 66,
    EM_INTR_FP_TRAP                               = 67,
    EM_INTR_LOWER_PRIVILEGE_TARNSFER_TRAP         = 68,
    EM_INTR_TAKEN_BRANCH_TRAP                     = 69,
    EM_INTR_SINGLE_STEP_TRAP                      = 70,
    /* Traps: IA32 */
    EM_INTR_IA_SYSTEM_FLAG_INTERCEPT_TRAP         = 71,
    EM_INTR_IA_GATE_INTERCEPT_TRAP                = 72,
    EM_INTR_IA_INTO_TRAP                          = 73,
    EM_INTR_IA_BREAKPOINT_TRAP                    = 74,
    EM_INTR_IA_SOFTWARE_INTERRUPT_TRAP            = 75,
    EM_INTR_IA_DATA_DEBUG_TRAP                    = 76,
    EM_INTR_IA_TAKEN_BRANCH_TRAP                  = 77,
    EM_INTR_IA_SINGLE_STEP_TRAP                   = 78,

    EM_INTR_LAST                                  = 79
} EM_interruption_t;


/* Interruption Vectors, taken from Table 10-6 in EAS2.4. */
typedef enum
{
    EM_VECTOR_VHPT_TRANSLATION         = 0x0000,
    EM_VECTOR_INST_TLB                 = 0x0400,
    EM_VECTOR_DATA_TLB                 = 0x0800,
    EM_VECTOR_INST_ALT_TLB             = 0x0c00,
    EM_VECTOR_DATA_ALT_TLB             = 0x1000,
    EM_VECTOR_DATA_NESTED_TLB          = 0x1400,
    EM_VECTOR_INST_KEY_MISS            = 0x1800,
    EM_VECTOR_DATA_KEY_MISS            = 0x1C00,
    EM_VECTOR_DIRTY_BIT                = 0x2000,
    EM_VECTOR_INST_ACCESS_BIT          = 0x2400,
    EM_VECTOR_DATA_ACCESS_BIT          = 0x2800,
    EM_VECTOR_BREAK_INSTRUCTION        = 0x2C00,
    EM_VECTOR_EXTERNAL_INTERRUPT       = 0x3000,
    /*** reserved: 0x3400 through 0x4c00 ***/
    EM_VECTOR_PAGE_NOT_PRESENT         = 0x5000,
    EM_VECTOR_KEY_PERMISSION           = 0x5100,
    EM_VECTOR_INST_ACCESS_RIGHT        = 0x5200,
    EM_VECTOR_DATA_ACCESS_RIGHT        = 0x5300,
    EM_VECTOR_GENERAL_EXCEPTION        = 0x5400,
    EM_VECTOR_DISABLED_FP_REGISTER     = 0x5500,
    EM_VECTOR_NAT_CONSUMPTION          = 0x5600,
    EM_VECTOR_SPECULATION              = 0x5700,
    /*** reserved: 0x5800 ***/
    EM_VECTOR_DEBUG                    = 0x5900,
    EM_VECTOR_UNALIGNED_REFERENCE      = 0x5A00,
    EM_VECTOR_LOCKED_DATA_REFERENCE    = 0x5B00,
    EM_VECTOR_FP_EXCEPTION             = 0x5C00,
    EM_VECTOR_FP_TRAP                  = 0x5D00,
    EM_VECTOR_LOWER_PRIVILEGE_TRANSFER = 0x5E00,
    EM_VECTOR_TAKEN_BRANCH             = 0x5F00,
    EM_VECTOR_SINGLE_STEP              = 0x6000,
    /*** reserved: 0x6100 through 0x6800 ***/
    EM_VECTOR_IA_EXCEPTIONS            = 0x6900,
    EM_VECTOR_IA_INTERCEPTIONS         = 0x6A00,
    EM_VECTOR_IA_INTERRUPTIONS         = 0x6B00
    /*** reserved: 0x6c00 through 0x7f00 ***/
} EM_vector_t;

#define EM_INTR_ISR_CODE_TPA               0
#define EM_INTR_ISR_CODE_FC                1
#define EM_INTR_ISR_CODE_PROBE             2
#define EM_INTR_ISR_CODE_TAK               3
#define EM_INTR_ISR_CODE_LFETCH            4
#define EM_INTR_ISR_CODE_PROBE_FAULT       5



#define EM_ISR_CODE_ILLEGAL_OPERATION            0x0
#define EM_ISR_CODE_PRIVILEGED_OPERATION         0x10
#define EM_ISR_CODE_PRIVILEGED_REGISTER          0x20
#define EM_ISR_CODE_RESERVED_REGISTER_FIELD      0x30
#define EM_ISR_CODE_ILLEGAL_ISA_TRANSITION       0x40

#define EM_ISR_CODE_F0_F15        0
#define EM_ISR_CODE_F16_F127      1

#define EM_ISR_CODE_NAT_REGISTER_CONSUMPTION  0x10
#define EM_ISR_CODE_NAT_PAGE_CONSUMPTION      0x20

#define EM_ISR_CODE_INST_DEBUG        0
#define EM_ISR_CODE_DATA_DEBUG        1

#define EM_ISR_CODE_FP_IEEE_V          0x0001
#define EM_ISR_CODE_FP_IA_DENORMAL     0x0002
#define EM_ISR_CODE_FP_IEEE_Z          0x0004
#define EM_ISR_CODE_FP_SOFT_ASSIST     0x0008
#define EM_ISR_CODE_FP_IEEE_O          0x0800
#define EM_ISR_CODE_FP_IEEE_U          0x1000
#define EM_ISR_CODE_FP_IEEE_I          0x2000
#define EM_ISR_CODE_FP_EXPONENT        0x4000
#define EM_ISR_CODE_FP_ROUNDING_ADD_1  0x8000

#define EM_ISR_CODE_MASK_IA_TRAP            0x02
#define EM_ISR_CODE_MASK_IA_DATA_DEBUG_TRAP 0x00
#define EM_ISR_CODE_MASK_FP_TRAP            0x01
#define EM_ISR_CODE_MASK_LOWER_PRIV         0x02
#define EM_ISR_CODE_MASK_TAKEN_BRANCH       0x04
#define EM_ISR_CODE_MASK_SINGLE_STEP        0x08
#define EM_ISR_CODE_MASK_UNIMPLEMENTED_INST 0x10

#define EM_ISR_VECTOR_MASK_IA_TRAP          0x1
#define EM_ISR_VECTOR_MASK_EM_TRAP          0x0

#define EM_ISR_CODE_CHK_A_GR          0
#define EM_ISR_CODE_CHK_S_GR          1
#define EM_ISR_CODE_CHK_A_FP          2
#define EM_ISR_CODE_CHK_S_FP          3
#define EM_ISR_CODE_CHK_FCHK          4

/*** SAPIC definitions ***/
#define EM_SAPIC_SPURIOUS_VECTOR_NUM        0x0f
#define EM_SAPIC_SIZE_OF_INTERRUPT_GROUP      16
#define EM_SAPIC_NUM_OF_INTERRUPT_GROUPS      16
#define EM_SAPIC_GROUPS_IN_IRR                 4
#define EM_SAPIC_GROUP(vec) \
        ((vec) / EM_SAPIC_NUM_OF_INTERRUPT_GROUPS)
#define EM_SAPIC_IRR(vec) \
        ((vec) / (EM_SAPIC_NUM_OF_INTERRUPT_GROUPS*EM_SAPIC_GROUPS_IN_IRR))
#define EM_SAPIC_IRR_BIT_POS(vec) \
        ((vec) % (EM_SAPIC_NUM_OF_INTERRUPT_GROUPS*EM_SAPIC_GROUPS_IN_IRR))

/***  version strings at the .comment section ***/
#define EM_IAS_OBJECT_FILE_NAME "!!!!Object file name: "
#define EM_IAS_VER_NUMBER       "!!!!Major Version "
#define EM_IAS_VERSION_COMMENT  "!!!!EM_EAS2.6"
      
/***  architecture and API versions ***/
#define EM_EAS_MAJOR_VERSION   2
#define EM_EAS_MINOR_VERSION   6

#define EM_API_MAJOR_VERSION   9
#define EM_API_MINOR_VERSION   6

/*** END OF EM_H Enhanced Mode ARCHITECTURE ***/

#endif /*** EM_H ***/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\iel\iel.c ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "ctype.h"
#include "iel.h"

typedef struct
{
    unsigned short  w[8];
} MUL128;


U32 digits_value[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};


IEL_Err IEL_mul(U128 *xr, U128 *y, U128 *z)
{
	MUL128 	y1, z1;
	U128   	temp[16], x;
	char   	ovfl=0;
	unsigned long 	 i, j, ui, uj, tmin, tmax;
	unsigned long    meanterm;

	for (i=0; i<16; i++)
	  IEL_ZERO (temp[i]);

    y1 = *(MUL128*)(y);
	z1 = *(MUL128*)(z);

	#ifndef BIG_ENDIAN
		for (ui=8; ((ui>0) && (!y1.w[ui-1])); ui--);
		for (uj=8; ((uj>0) && (!z1.w[uj-1])); uj--);
		if ((ui+uj)<8)
		{
			tmin = ui+uj;
			tmax = 0;
		} else
		{
			tmin = 8;
			tmax = ui+uj-8;
		}
	#else
		ui=8;
		uj=8;
		tmin = 8;
		tmax = 8;
	#endif
	

	for (i=0; i<ui; i++)
	  for (j=0; j<uj; j++)
	  {
	   	#ifndef BIG_ENDIAN
		      meanterm = y1.w[i] * z1.w[j];
		#else
			  meanterm = y1.w[7-i] * z1.w[7-j];
		#endif	  
		IEL_ADDU (temp[i+j], temp[i+j], IEL32(meanterm));
	  }
	for (i=1; i<tmin; i++)
	  ovfl = IEL_SHL128 (temp[i], temp[i], 16*i) || ovfl;
	
	for (i=0; i<tmax; i++)
	  ovfl = !(IEL_ISZERO (temp[i+8])) || ovfl;
	
	IEL_ZERO (x);

	for (i=0; i<tmin; i++)
	  ovfl = IEL_ADDU (x, x, temp[i]) || ovfl;
	IEL_ASSIGNU (IEL128(*xr), x);
	return (ovfl);
}


/* char find_hi_bit(U128 x) 
{
	char place;
	long num, k;
	char parts[4];
	char j,part;

	
	if ((num = DW3(x))) place=96; else
	  if ((num = DW2(x))) place=64; else
		if ((num = DW1(x))) place=32; else
		  if ((num = DW0(x))) place=0; else
			return(0);
		  
	*(long *)(parts) = num;

	if ((part = parts[0])) place+=24; else
	  if ((part = parts[1])) place+=16; else
		if ((part = parts[2])) place+=8; else
		  part = parts[3];

	j = 8;
	k = 128;

	for (j=8, k=128; !(part & k); j--, k=k>>1);

	part+=j;
}
*/

	


	


IEL_Err IEL_rem(U128 *x, U128 *y, U128 *z)
{
	U128 	x1, y1, z1, t1, z2;
	long 	carry, i,j;
	
	
	if (IEL_ISZERO(*z)) 
	{
        IEL_ASSIGNU(*x, *y);
		return (IEL_OVFL);
	}

	IEL_ASSIGNU(y1, *y);
	IEL_ZERO(x1);

    while (IEL_CMPGEU(y1, *z))
	{
		IEL_CONVERT(t1, 1, 0, 0, 0);
		IEL_ASSIGNU(z1, *z);
		IEL_ASSIGNU(z2, z1);

		j = 0;
		for (i=64; i>0; i=i>>1)
		{
			carry = IEL_SHL(z2, z2, i);
			if (IEL_CMPGEU(y1, z2) && (!carry))
			{
				j+=i;
				IEL_ASSIGNU(z1, z2);
			} else
			{
				IEL_ASSIGNU(z2, z1);
			}
		}


		IEL_SHL(t1, t1, j);
		IEL_SUBU(y1, y1, z2);
		IEL_ADDU(x1, x1, t1);
	}
	IEL_ASSIGNU(IEL128(*x), y1);
	return (IEL_OK);
}

		

IEL_Err IEL_div(U128 *x, U128 *y, U128 *z)
{
	U128 	x1, y1, z1, t1, z2;
	long 	carry, i, j;
	
	IEL_ASSIGNU(y1, *y);
	IEL_ZERO(x1);
	

	if (IEL_ISZERO(*z)) 
	{
		(*x).dw3_128 = 0;
		return (IEL_OVFL);
	}

	while (IEL_CMPGEU (y1, *z))
	{
		IEL_CONVERT(t1, 1, 0, 0, 0);
		IEL_ASSIGNU(z1, *z);
		IEL_ASSIGNU(z2, z1);

		j = 0;
		for (i=64; i>0; i=i>>1)
		{
			carry = IEL_SHL(z2, z2, i);
			if (IEL_CMPGEU(y1, z2) && (!carry))
			{
				j+=i;
				IEL_ASSIGNU(z1, z2);
			} else
			{
				IEL_ASSIGNU(z2, z1);
			}
		}

		IEL_SHL(t1, t1, j);
		IEL_SUBU(y1, y1, z2);
		IEL_ADDU(x1, x1, t1);
	}
	IEL_ASSIGNU(IEL128(*x), x1);
	return (IEL_OK);
}


static void transpose(char *st)
{
	unsigned long i;
	char c;
	unsigned long len;

	len = strlen(st);
	for (i=0; i<(strlen(st)/2); i++)
	{
		c = st[i];
		st[i]=st[len-i-1];
		st[len-i-1]=c;
	}
}

static long leadzero(char *st)
{
	long j=0, i=0;
	while (st[i++]=='0') j++;
    return(j);
}

static void backzero(char *st)
{
	unsigned long i;
	i = strlen(st);
	while (st[--i]=='0');
	st[++i]='\0';
}



IEL_Err IEL_U128tostr(const U128 *x, char *strptr, int base, const unsigned int length)
{
	char	digit[17] = "0123456789abcdef";
	U128	x1, y1, z1, t1;
	unsigned long 	i, j = 0, k, len, lead;
	char    tempplace[1100];
	char	*tempstr = tempplace, negative = IEL_FALSE;
	unsigned long	dwtemp=0, bit;

		  
	IEL_ASSIGNU (t1, IEL128(*x));
	tempstr[0]='\0';

	if (base == 100)
	{
		if (IEL_ISNEG(t1))
		{
			IEL_COMPLEMENTS(t1, t1);
			negative = IEL_TRUE;
		}
		base = 10;
	}


	if IEL_ISZERO(t1) 
	{
		tempstr[0]='0';
		tempstr[1]='\0';
	} else

	if ((base==16) || (base == 116))
	{
		if (base ==16)
		{
			sprintf(tempstr,"%lx%08lx%08lx%08lx",DW3(t1),DW2(t1),DW1(t1),DW0(t1));
		} else
		{
			sprintf(tempstr,"%lX%08lX%08lX%08lX",DW3(t1),DW2(t1),DW1(t1),DW0(t1));
		}
		
		lead = leadzero(tempstr);
		for(i=lead; i<=strlen(tempstr); i++)
		{
			tempstr[i-lead]=tempstr[i];
		}
	} else
	  if (base==2)
	  {
		 len = 0;
		 for (j=0; j<4; j++)	
		 {
			 switch(j)
			 {
			   case 0:
				 dwtemp = DW0(t1);
				 break;
			   case 1:
				 dwtemp = DW1(t1);
				 break;
			   case 2:
				 dwtemp = DW2(t1);
				 break;
			   case 3:
				 dwtemp = DW3(t1);
				 break;
			 }
			 bit = 1;
			 for (i=0; i<32; i++)
			 {
				 if (bit & dwtemp)
				 {
					 tempstr[len]='1';
				 } else
				 {
					 tempstr[len]='0';
				 }
				 bit<<=1;
				 len++;
			 }
		 }
	 
		 tempstr[len]='\0';
		 transpose(tempstr);
		 lead = leadzero(tempstr);
		 for(i=lead; i<=strlen(tempstr); i++)
		 {
			 tempstr[i-lead]=tempstr[i];
		 }
	  } else
		if (base==10)
		{
			len=0;
			IEL_ASSIGNU(y1, t1);
			IEL_CONVERT(z1, 1000000000, 0, 0, 0);
			while (!IEL_ISZERO(y1))
			{
				IEL_rem (&x1, &y1, &z1);
				IEL_ASSIGNU (IEL32(i), x1);
				for (k=0; k<9; k++)
				{
					j=i%10;
					tempstr[len+1]='\0';
					tempstr[len]=digit[j];
					i=i/10;
					len++;
				}
				IEL_div(&y1, &y1, &z1);
			}
			if (negative)
			{
				backzero(tempstr);
				tempstr[strlen(tempstr)+1]='\0';
				tempstr[strlen(tempstr)]='-';
				transpose(tempstr);
			} else
			{
				transpose(tempstr);
				lead = leadzero(tempstr);
				for(i=lead; i<=strlen(tempstr); i++)
				{
					tempstr[i-lead]=tempstr[i];
				}
			}
		} else
		  if (base==8)
		  {
			  len=0;
			  IEL_ASSIGNU(y1, t1);
			  IEL_CONVERT(z1, 010000000000, 0, 0, 0);
			  while (!IEL_ISZERO(y1))
			  {
				IEL_rem (&x1, &y1, &z1);
				IEL_ASSIGNU (IEL32(i), x1);
				for (k=0; k<10; k++)
				{
					j=i%8;
					tempstr[len+1]='\0';
					tempstr[len]=digit[j];
					i=i/8;
					len++;
				}
				IEL_div(&y1, &y1, &z1);
			}
			  if (negative)
			  {
				  backzero(tempstr);
				  tempstr[strlen(tempstr)+1]='\0';
				  tempstr[strlen(tempstr)]='-';
				  transpose(tempstr);
			  } else
			  {
				  transpose(tempstr);
				  lead = leadzero(tempstr);
				  for(i=lead; i<=strlen(tempstr); i++)
				  {
					  tempstr[i-lead]=tempstr[i];
				  }
			  }
		  } else
		  {
			  IEL_ASSIGNU (z1, IEL32(base));
			  IEL_ASSIGNU (y1, t1);
			  while (!IEL_ISZERO(y1))
			  {
				  IEL_rem (&x1, &y1, &z1);
				  IEL_ASSIGNU (IEL32(i), x1);
				  tempstr[strlen(tempstr)+1]='\0';
				  tempstr[strlen(tempstr)]=digit[i];
				  IEL_div (&y1, &y1, &z1);
			  }
			  transpose(tempstr);
	  }

	if (length < strlen (tempstr)+1)
	{
		return (IEL_OVFL);
	} else
	{
		for (i=0; i<=strlen(tempstr); i++)
		  strptr[i]=tempstr[i];
		return (IEL_OK);
	}
}

IEL_Err IEL_U64tostr(const U64 *x, char *strptr, int  base, const unsigned int  length)
{
	U128 y;    

	IEL_ASSIGNU(y, (*x));
	return (IEL_U128tostr (&y, strptr, base, length));
}



IEL_Err IEL_S128tostr(const S128 *x, char *strptr, int  base, const unsigned int  length)
{
	U128 y;
	IEL_ASSIGNU(y, (*x));
	return(IEL_U128tostr( &y, strptr, base, length));
}

IEL_Err IEL_S64tostr(const S64 *x, char *strptr, int  base, const unsigned int  length)
{
	U128 y;

	IEL_SEXT(y, (*x));
	return(IEL_U128tostr( &y, strptr, base, length));
}	   	


	
IEL_Err IEL_strtoU128( char *str1, char **endptr, int base, U128 *x)
{
	U128	sum;
	unsigned long	i, j=0;
	int     negative=IEL_FALSE;
	unsigned long 	inbase, insum;
	IEL_Err ovfl = IEL_OK;
	

	if (str1[0]=='-')
	{
		negative = IEL_TRUE;
		str1++;
	}
	
	if (base == 0) 
	{
		if (str1[0]=='0')
		{
			if (strlen(str1)==1) 
			{
				IEL_ZERO((*x));
				return (IEL_OK);
			} else
			if (strchr("01234567",str1[1])) 
			{
				base = 8;
				str1++;
			} else
			{
				switch (str1[1])
				{
				  case 'B':
				  case 'b': base=2;
							str1+=2;
							break;
				  case 'X':
				  case 'x':
				  case 'H':
				  case 'h': base=16;
							str1+=2;
							break;
				  default:	return (IEL_OVFL);
				}
			}
		} else 
		{
			base = 10;
		}
	}
   
	switch(base)
	{
	  case 10:
		for (j=0; str1[j]>='0' && str1[j]<='9';)
		{
			insum = str1[j++]-'0';
			inbase = 10;
			i=1;
			while ((i<9) && str1[j]>='0' && str1[j]<='9')
			{
				i++;
				inbase = inbase * 10;
				insum *= 10;
				insum += str1[j++]-'0';
			}
			if (j<10)
			{
				IEL_ASSIGNU (sum, IEL32(insum));
			} else
			{
				ovfl = IEL_MULU(sum, sum, IEL32(inbase)) || ovfl;
				ovfl = IEL_ADDU(sum, sum, IEL32(insum)) || ovfl;
			}
		}
		break;
	  case 2:
		for (j=0; str1[j]>='0' && str1[j]<='1';)
		{
			insum = str1[j++]-'0';
			inbase = 1;
			i=1;
			while ((i<32) && str1[j]>='0' && str1[j]<='9')
			{
				i++;
				inbase++;
				insum *= 2;
				insum += str1[j++]-'0';
			}
			if (j<33)
			{
				IEL_ASSIGNU (sum, IEL32(insum));
			} else
			{
				ovfl = IEL_SHL128(sum, sum, inbase) || ovfl;
				ovfl = IEL_ADDU(sum, sum, IEL32(insum)) || ovfl;
			}
		}
		break;
	  case 8:
		for (j=0; str1[j]>='0' && str1[j]<='7';)
		{
			insum = str1[j++]-'0';
			inbase = 3;
			i=1;
			while ((i<10) && str1[j]>='0' && str1[j]<='7')
			{
				i++;
				inbase+=3;
				insum *= 8;
				insum += str1[j++]-'0';
			}
			if (j<11)
			{
				IEL_ASSIGNU (sum, IEL32(insum));
			} else
			{
				ovfl = IEL_SHL128(sum, sum, inbase) || ovfl;
				ovfl = IEL_ADDU(sum, sum, IEL32(insum)) || ovfl;
			}
		}
		break;
	  case 16:
		for (j=0; ((str1[j]>='0' && str1[j]<='9') ||
				   (tolower(str1[j])>='a' && tolower(str1[j]<='f'))); )
		{
			if (str1[j]<='9')
			{
				insum = str1[j++]-'0';
			} else
			{
				insum = tolower(str1[j++])-'a'+10;
			}
			inbase = 4;
			i=1;
			while ((i<8) && ((str1[j]>='0' && str1[j]<='9') ||
				   (tolower(str1[j])>='a' && tolower(str1[j]<='f'))))
			{
				i++;
				inbase += 4;
				insum *= 16;
				if (str1[j]<='9')
				{
					insum += (str1[j++]-'0');
				} else
				{
					insum += (tolower(str1[j++])-'a'+10);
				}
			}
			if (j<9)
			{
				IEL_ASSIGNU (sum, IEL32(insum));
			} else
			{
				ovfl = IEL_SHL128(sum, sum, inbase) || ovfl;
				ovfl = IEL_ADDU(sum, sum, IEL32(insum)) || ovfl;
			}
		}
		break;

	}


	IEL_ASSIGNU(IEL128(*x), sum);	
	if (negative)
	{
		ovfl = ovfl || (IEL_ISNEG(*x) && !IEL_ISNINF(*x));
		IEL_COMPLEMENTS(IEL128(*x), IEL128(*x));
	}
	*endptr = str1+j;
	if (ovfl)
	{
		IEL_CONVERT4((*x), 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);
	}
	return (ovfl);
}

IEL_Err IEL_strtoU64(char *str1, char **endptr, int base, U64 *x)
{
	U128	y1;

	IEL_Err ovfl = IEL_strtoU128(str1, endptr, base, &y1);
	ovfl = IEL_ASSIGNU((*x), y1) || ovfl;
	if (ovfl)
	{
		IEL_CONVERT2(*x, 0xFFFFFFFF, 0xFFFFFFFF);
	}
	return (ovfl);
	
}

IEL_Err IEL_strtoS128(char *str1, char **endptr, int base, S128 *x)
{
	U128	y1;

	IEL_Err ovfl = IEL_strtoU128(str1, endptr, base, &y1);
	if (str1[0] == '-')
	{
		IEL_ASSIGNU((*x), y1);
		if (ovfl)
		{
			IEL_CONVERT4(*x, 0, 0, 0, 0x80000000);
		}
	} else
	{
		IEL_ASSIGNU((*x), y1);
		ovfl = (IEL_ISNEG(y1)) || ovfl;
		if (ovfl)
		{
			IEL_CONVERT4(*x, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x7fffffff);
		}
	}

	return (ovfl);
	
}

IEL_Err IEL_strtoS64(char *str1, char **endptr, int base, S64 *x)
{
	U128	y1;

	IEL_Err ovfl = IEL_strtoU128(str1, endptr, base, &y1);
	if (str1[0] == '-')
	{
		ovfl = IEL_ASSIGNS((*x), y1) || ovfl;
		if (ovfl)
		{
			IEL_CONVERT2(*x, 0, 0x80000000);
		}
	} else
	{
		ovfl = IEL_ASSIGNU((*x), y1) || ovfl;
		ovfl = IEL_ISNEG(*x) || ovfl;
		if (ovfl)
		{
			IEL_CONVERT2(*x, 0xFFFFFFFF, 0x7fffffff);
		}
	}
	return (ovfl);
	
}

#ifndef LP64
int IEL_c0(void *x, int sx)
{

	U64 u64x;
	U128 u128x;

	/* sx can be only 64 or 128 bits */

	
    if (sx == sizeof(U64))
	{
		IEL_ASSIGNU(u64x,*((U64 *)(x)));
		return(IEL_R_C0(u64x));
	} else
	{
		IEL_ASSIGNU(u128x, *((U128 *)(x)));
		return(IEL_R_C0(u128x));
	}
}

int IEL_c1(void *x, int sx)
{

	U64 u64x;
	U128 u128x;

	/* sx can be only 64 or 128 bits */

	
    if (sx == sizeof(U64))
	{
		IEL_ASSIGNU(u64x,*((U64 *)(x)));
		return(IEL_R_C1(u64x));
	} else
	{
		IEL_ASSIGNU(u128x, *((U128 *)(x)));
		return(IEL_R_C1(u128x));
	}
}

int IEL_c2(void *x, int sx)
{

	U64 u64x;
	U128 u128x;

	/* sx can be only 64 or 128 bits */

	
    if (sx == sizeof(U64))
	{
		IEL_ASSIGNU(u64x,*((U64 *)(x)));
		return(IEL_R_C2(u64x));
	} else
	{
		IEL_ASSIGNU(u128x, *((U128 *)(x)));
		return(IEL_R_C2(u128x));
	}
}

int IEL_c3(void *x, int sx)
{

	U64 u64x;
	U128 u128x;

	/* sx can be only 64 or 128 bits */

	
    if (sx == sizeof(U64))
	{
		IEL_ASSIGNU(u64x,*((U64 *)(x)));
		return(IEL_R_C3(u64x));
	} else
	{
		IEL_ASSIGNU(u128x, *((U128 *)(x)));
		return(IEL_R_C3(u128x));
	}
}



int IEL_au(void *x, void *y, int sx, int sy)
{
        U128 tmp, zero;

		if (x==y)
		  return (IEL_OK);
		
        IEL_ZERO(zero);
        if (sx>=sy)
        {
                memset(x, 0, (size_t)sx);
                memcpy(x, y, (size_t)sy);
        } else
        {
                memset(&tmp, 0, sizeof(U128));
                memcpy(x, y, (size_t)sx);
                memcpy(&tmp, y, (size_t)sy);
                memset(&tmp, 0, (size_t)sx);
                if (memcmp(&zero, &tmp, sizeof(U128)))
                {
                        return(IEL_OVFL);
                }
        }
        return (IEL_OK);
}


IEL_Err IEL_as(void *x, void *y, int sx, int sy)
{
	S32		s32y;
	S64		s64y;
	S128	s128y;
	S32		s32x;
	S64		s64x;
	S128	s128x;
	IEL_Err	ov=IEL_OK;

	switch (sy)
	{
		case sizeof(S32): s32y = *(S32 *)y; IEL_SEXT(s128y, s32y); break;
		case sizeof(S64): s64y = *(S64 *)y; IEL_SEXT(s128y, s64y); break;
		case sizeof(S128): s128y = *(S128 *)y; break;
	}

	switch (sx)
	{
		case sizeof(S32):
			ov = IEL_REAL_ASSIGNS(s32x, s128y);
			memcpy((char *)x, (char *)&s32x, (size_t)sx);
			break;

		case sizeof(S64):
			ov = IEL_REAL_ASSIGNS(s64x, s128y);
			memcpy((char *)x, (char *)&s64x, (size_t)sx);
			break;

		case sizeof(S128):
			ov = IEL_REAL_ASSIGNS(s128x, s128y);
			memcpy((char *)x, (char *)&s128x, (size_t)sx);
			break;
	}
	return(ov);
}

#endif /* LP64 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\include\make_arch.inc ===
##
## Copyright (c) 2000, Intel Corporation
## All rights reserved.
##
## WARRANTY DISCLAIMER
##
## THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
## A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
## PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
## OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
## NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
## MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##
## Intel Corporation is the author of the Materials, and requests that all
## problem reports or change requests be submitted to it directly at
## http://developer.intel.com/opensource.
##



######################################################################## 
#
# Tools common Make_isa.inc
#

# Common isa defenitions 

ifeq ($(TOOL_ARCH), P6V)
    TOOL_ARCH := P62
endif

ifeq ($(TOOL_ARCH), P6_SIMD)
    TOOL_ARCH := P62
endif

ifeq ($(TOOL_ARCH), P5_SIMD)
    TOOL_ARCH := P5V
endif

ifeq ($(TOOL_ARCH), EX86)
    TOOL_ARCH := PAX
endif

ifeq ($(TOOL_ARCH), P5)
    IA5_TOOLS = 1
    SUFFIX = p5
else
ifeq ($(TOOL_ARCH), P6)
    IA5_TOOLS = 1
    IA6_TOOLS = 1
    SUFFIX = p6
else
ifeq ($(TOOL_ARCH), P5V)
    IA5_TOOLS = 1
    SIMD_TOOLS = 1
    SUFFIX = p5v
else
ifeq ($(TOOL_ARCH), P62)
    IA5_TOOLS = 1
    IA6_TOOLS = 1
    SIMD_TOOLS = 1
    SUFFIX = p62
    
else
ifeq ($(TOOL_ARCH), P6_VX)
    IA5_TOOLS = 1
    IA6_TOOLS = 1
    SIMD_TOOLS = 1
	VX_TOOLS = 1
    SUFFIX = p62x
    
else
ifeq ($(TOOL_ARCH), P68)
    IA5_TOOLS = 1
    IA6_TOOLS = 1
    SIMD_TOOLS = 1
    VX_TOOLS = 1
    WMT_TOOLS =1	
    SUFFIX = p68
    
else
ifeq ($(TOOL_ARCH), P62_EM)
    IA5_TOOLS = 1
    IA6_TOOLS = 1
    SIMD_TOOLS = 1
    VX_TOOLS =1
    EMA_TOOLS = 1
    SUFFIX = eia
    
else
ifeq ($(TOOL_ARCH), P7)
	IAX1K_TOOLS = 1
    IAX_TOOLS = 1
    SUFFIX = p7
else
ifeq ($(TOOL_ARCH), PAX)
    IAX_TOOLS = 1
    SUFFIX = ex86
else
ifeq ($(TOOL_ARCH), P1K)
    IAX1K_TOOLS = 1
    SUFFIX = p1k
else
ifeq ($(TOOL_ARCH), EAS)
    TAHOE_TOOLS = 1
    IAX1K_TOOLS = 1  
    SUFFIX = eas
else
ifeq ($(TOOL_ARCH), TAHOE)
    TAHOE_TOOLS = 1
    IAX1K_TOOLS = 1  
    SUFFIX = eas
else
ifeq ($(TOOL_ARCH), EMA)
    EMA_TOOLS = 1
    SUFFIX = em
else
ifeq ($(TOOL_ARCH), ALL)
    IA5_TOOLS = 1
    SIMD_TOOLS= 1
    IA6_TOOLS = 1
    IAX_TOOLS = 1
    IAX1K_TOOLS = 1
    TAHOE_TOOLS = 1
    EMA_TOOLS = 1
    VX_TOOLS = 1
    WMT_TOOLS = 1
    SUFFIX = all
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif

ifndef TOOL_ARCH
ifndef IAX_TOOLS
ifndef IAX1K_TOOLS
IA5_TOOLS = 1
endif
endif
endif

DECODER_LIB = dec$(SUFFIX)
DECODER_INC = dec$(SUFFIX).h
INSTID_INC  = insid$(SUFFIX).h

ENCODER_LIB = enc$(SUFFIX)
ENCODER_INC = enc$(SUFFIX).h

DISASM_LIB = dis$(SUFFIX)
DISASM_INC = dis$(SUFFIX).h

# Each makefile should recognize the following set of flag
# and translate them to private USER_CFLAGS for the compiler:

# IA5_TOOLS    - handle P5 isa
# IA6_TOOLS    - handle P6 isa
# SIMD_TOOLS   - handle SIMD/DSP IA-extention isa
# IAX_TOOLS    - handle iAX ("old") isa
# IAX1K_TOOLS  - handle 1K (STRAWMAN) isa
# TAHOE_TOOLS  - handle TAHOE (EAS 1.0) isa.
# EMA_TOOLS    - handle EM (EAS 2.0-, true encoding) isa.
# VX_TOOLS     - handle Katmai isa
# WMT_TOOLS    - handle Willamette isa
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\include\makefile.inc ===
##
## Copyright (c) 2000, Intel Corporation
## All rights reserved.
##
## WARRANTY DISCLAIMER
##
## THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
## A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
## PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
## OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
## NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
## MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##
## Intel Corporation is the author of the Materials, and requests that all
## problem reports or change requests be submitted to it directly at
## http://developer.intel.com/opensource.
##


########################################################################
#
# Tools common Makefile.inc
#


# NOTES FOR Windows/NT environment
# 1. In WINNT, absolute path must BEGIN with back-slash (\) in order
#    to find the RCS file for an absolute file-name on the server.
# 2. The substitution of /topg_drive is done only by the ToolBuster tools.
#    It souldn't be used for other tools, e.g. cl.exe -I/topg_drive... won't work
#    This variable should be substituted before the command issuing.
# 3. Absolute path with leading back-slash is not recognized as expected by MS tools.
#    Either use absolute path with leading slash, or qoute the name with Double-Qoutes (").
#    Different set of variables (macros) can contain Absolute path with leading slash,
#    and with leading back-slash


# add the server drive to VAPTH to find RCS files for absolute file-names
VPATH += /topg_drive

ifeq ($(HOSTTYPE), WINNT)
   # ???????
   WINNT = winnt
endif # of WINNT



ifndef LOCALBASEDIR
   ifeq ($(HOSTTYPE), PARISC)
      LOCALBASEDIR = $(WORK_AREA)
      LOCALDIR   = $(LOCALBASEDIR)
   else # of PARISC
      ifeq ($(HOSTTYPE), WINNT)
         # For absolute path name in NT, use leading back-slash
         LOCALDIR = \x86sw
      else # of WINNT
         LOCALBASEDIR = $(HOME)
         ifndef WORK_AREA
            LOCALDIR   = $(LOCALBASEDIR)/x86sw
         else # of WORK_AREA
            LOCALDIR = $(WORK_AREA)
         endif # of WORK_AREA
      endif # of WINNT
   endif # of PARISC
else # of LOCALBASEDIR
   ifndef LOCALDIR
      LOCALDIR   = $(LOCALBASEDIR)/x86sw
   endif # of LOCALDIR
endif # of LOCALBASEDIR

ifndef SERVER_AREA
   ifeq ($(HOSTTYPE), WINNT)
      # This variable cann't be use in dependencies, the : are the problem
      SERVER_AREA = j:/x86sw
   else # of WINNT
      ifeq ($(HOSTTYPE), PARISC)
         SERVER_AREA = /gambit/src/official
      else # of PARISC
         SERVER_AREA = /home/x86sw
      endif # of PARISC
   endif # of WINNT
endif # of SERVER_AREA


ifndef STT_LOCAL_BIN
    STT_LOCAL_BIN = /usr/local/bin
endif

CI      = $(STT_LOCAL_BIN)/ci
CO      = $(STT_LOCAL_BIN)/co

ifdef REMOTE
   INSTALLDIR = $(LOCALDIR)
   ifeq ($(REMOTE), SC)
      RELEASEDIR = /md7/arch/tools/current/tools
   else # of SC
      ifeq ($(REMOTE), OR)
         RELEASEDIR = /home2/tools64/current/tools
      else # of OR
		@echo check your REMOTE environment variable, should be one of
		@echo SC, OR
		@exit 1
      endif # of OR
   endif # of SC
else # of REMOTE
   ifeq ($(HOSTTYPE), PARISC)
      INSTALLDIR = $(WORK_AREA)
      PINSTALLDIR = $(WORK_AREA)/prereleases
   else # of PARISC
      INSTALLDIR = $(SERVER_AREA)
      PINSTALLDIR = $(INSTALLDIR)/preleases
   endif
   RELEASEDIR = /export/iswp_02/tools64/current/tools
endif # of REMOTE

ifneq ($(HOSTTYPE), WINNT)
   DATE  := $(shell date "+%d-%m-%y, %H:%M")
   UNAME := $(shell uname)
endif # of WINNT


#ifeq ($(HOSTTYPE), PARISC)
#   SERVER_DIR = $(WORK_AREA)
#else # of PARISC
#   ifdef SERVER_AREA
#      SERVER_DIR = $(SERVER_AREA)
#   else # of SERVER_AREA
#      ifeq ($(HOSTTYPE), WINNT)
#         SERVER_DIR = j:/x86sw
#      else # of WINNT
#         SERVER_DIR = /home/x86sw
#   endif # of SERVER_AREA
#endif # of PARISC

ifeq ($(HOSTTYPE), i386)
    HOSTTYPE := UNIX386
endif

ifeq ($(HOSTTYPE), i486)
    HOSTTYPE := UNIX386
endif

ifeq ($(HOSTTYPE), iAPX386)
ifeq ($(UNAME), SunOS)
    HOSTTYPE := x86Solaris
else
    HOSTTYPE := UNIX386
endif
endif

ifeq ($(HOSTTYPE), UNIX)
    HOSTTYPE := UNIX386
endif
ifeq ($(UNAME), OSF1)
    HOSTTYPE := MACH386
endif



ifneq ($(HOSTTYPE), PARISC)
RCSDIFF = rcsdiff -q
else
RCSDIFF = rcsdiff
endif



ifeq ($(HOSTTYPE), UNIX386)
ifeq ($(OSTYPE), svr5)
	OS_DIR    = svr5
    SYS       = -DSVR4 -DSVR5 -DUNIX
    GCC_BIN       = /usr/ccs/bin/cc
    CC_BIN    = /usr/ccs/bin/cc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN       = /usr/bin/nawk
    AS_BIN    = /usr/ccs/bin/as
    LD_BIN    = /usr/ccs/bin/ld
    YACC_BIN  = /usr/ccs/bin/yacc
    GCC_WARN  = -Xc
    GCC_FLAGS =
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O $(GCC_WARN)
    CC_FLAGS  = -Xc -Xt
    CC_DEBUG  = -g $(PROF_FLAGS)
    CC_OPT    = -O
    RGCC_FLAGS= -Xa -Di386
    RGCC_DEBUG= -g
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/ccs/bin/ar
    CP_BIN    = /usr/bin/cp
    LN_BIN    = /usr/bin/ln
    MV_BIN    = /usr/bin/mv
    RM_BIN    = /usr/bin/rm
    CHMOD_BIN = /usr/bin/chmod
    STRIP_BIN = /usr/ccs/bin/strip
    AWK       = gawk
    PERL      = /usr/intel/bin/perl -I /usr/gnu/lib/perl5/
    AS_FLAGS = -n
else
    OS_DIR    = svr4
    SYS       = -DSVR4 -DUNIX
    GCC_BIN       = /usr/local/bin/gcc
    CC_BIN    = /usr/bin/cc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN       = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2 -DNDEBUG $(GCC_WARN)
    CC_FLAGS  = -Xa -Di386
    CC_DEBUG  = -g $(PROF_FLAGS)
    CC_OPT    = -O
    RGCC_FLAGS= -Xa -Di386
    RGCC_DEBUG= -g
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/bin/ar
    CP_BIN    = /usr/bin/cp
    LN_BIN    = /usr/bin/ln
    MV_BIN    = /usr/bin/mv
    RM_BIN    = /usr/bin/rm
    CHMOD_BIN = /usr/bin/chmod
    STRIP_BIN = /usr/bin/strip
    AWK       = gawk
    AS_FLAGS = -n
#    GCC_O_WS = -Wmissing-prototypes
endif
else
ifeq ($(HOSTTYPE), i386-linux)
    OS_DIR    = linux
    SYS       = -DSVR4 -DUNIX
    GCC_BIN   = /usr/cygnus/redhat-980810/H-i386-pc-linux-gnu/bin/gcc
    GCC_BIN   = /usr/bin/gcc
    CC_BIN    = /usr/cygnus/redhat-980810/H-i386-pc-linux-gnu/bin/gcc
    CC_BIN    = /usr/bin/gcc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN   = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2 -DNDEBUG $(GCC_WARN)
    CC_FLAGS  = $(GCC_FLAGS)
    CC_DEBUG  = $(GCC_DEBUG)
    CC_OPT    = $(GCC_OPT)
    RGCC_FLAGS= -Xa -Di386
    RGCC_DEBUG= -g
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /usr/bin/strip
    AWK       = gawk
    AS_FLAGS  = -n
    CO	      = /usr/bin/co
    CI	      = /usr/bin/ci
else
ifeq ($(HOSTTYPE), i486-linux)
    OS_DIR    = linux
    PERL      = /usr/bin/perl
    SYS       = -DSVR4 -DUNIX
    GCC_BIN   = /usr/bin/gcc
    CC_BIN    = /usr/bin/gcc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN   = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2 -DNDEBUG $(GCC_WARN)
    CC_FLAGS  = $(GCC_FLAGS)
    CC_DEBUG  = $(GCC_DEBUG)
    CC_OPT    = $(GCC_OPT)
    RGCC_FLAGS= -Xa -Di386
    RGCC_DEBUG= -g
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /usr/bin/strip
    AWK       = gawk
    AS_FLAGS  = -n
    CO	      = /usr/intel/bin/co
    CI	      = /usr/intel/bin/ci
else
ifeq ($(HOSTTYPE), PARISC)
    OS_DIR    = $(MACHINE)
    SYS       =  -DHPUX -DSVR4 -DUNIX -DPY -DSTRICT_ALIGN
    GCC_BIN	  = /usr/local/bin/gcc
    CC_BIN    = /usr/bin/cc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN	  = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS =
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  = -Xa -Di386
    CC_DEBUG  = -g $(PROF_FLAGS)
    CC_OPT    = -O
    RGCC_FLAGS= -Xa -Di386
    GCC_DEBUG = -g $(GCC_WARN)
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
#
# Changed for HPUX, from /usr/bin/ar for SVR4.
#
    AR_BIN    = /bin/ar
    CP_BIN    = /usr/bin/cp
    LN_BIN    = /usr/bin/ln
    MV_BIN    = /usr/bin/mv
    RM_BIN    = /usr/bin/rm
    CHMOD_BIN = /usr/bin/chmod
    STRIP_BIN = /usr/bin/strip
    AWK       = gawk
    AS_FLAGS = -n
#    GCC_O = -ansi -Wall -Wshadow -Wpointer-arith -Wcast-align \
#            -Wconversion -Wmissing-prototypes \
#            -Wnested-externs
else
ifeq ($(HOSTTYPE), UNIX386_TEST)
    OS_DIR    = svr4
    SYS       = -DSVR4 -DUNIX
    GCC_BIN       = /usr/local/bin/gcc -Wa,-t386 -Wa,-Nwa
    CC_BIN    = /usr/bin/cc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN       = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  = -Xa -Di386
    CC_DEBUG  = -g
    CC_OPT    = -O
    RGCC_FLAGS= -Xa -Di386
    GCC_DEBUG = -g $(GCC_WARN)
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/bin/ar
    CP_BIN    = /usr/bin/cp
    LN_BIN    = /usr/bin/ln
    MV_BIN    = /usr/bin/mv
    RM_BIN    = /usr/bin/rm
    CHMOD_BIN = /usr/bin/chmod
    STRIP_BIN = /usr/bin/strip
else
ifeq ($(HOSTTYPE), WINNT)
#   ToolBusterDir should be defined in the environment
    PERL      = perl -I$(ToolBusterDir)/lib/perl
    EXEXT     = .exe
    OS_DIR    = win32
    PWD       =
    SYS       = -DWINNT
    GCC_BIN   = cl.exe
    CXX       = cl.exe
    CC_BIN    = cl.exe
    AS_BIN    = $(ToolBusterDir)/lib/gcc-lib/winnt386/2_4_5/as
    LD_BIN    = $(ToolBusterDir)/lib/gcc-lib/winnt386/2_4_5/ld
    LD_BIN    = lib
    CAT_BIN   = cat.exe
    AR_BIN    = lib.exe
    CP_BIN    = cp.exe
    MV_BIN    = mv.exe
    RM_BIN    = rm.exe
    CHMOD_BIN = chmod.exe
    AWK_BIN   = gawk
	CO        = co.exe
	CI        = ci.exe
    LIBMOFL   = libmofl.lib
    ELF_H     = elf.h
    GCC_OPT   = -O2 -DNDEBUG
    CFLAGS_D_DEXE32 = /nologo /Za /W3 /YX /D "_X86_" /D "_DEBUG"  \
		      /D "_CONSOLE" /D "__WINNT__" /D "EX86stuff"  \
		      /FR /ML /Fd"ILD.PDB" /Fp"ILD.PCH"
else
ifeq ($(HOSTTYPE), x86Solaris)
    OS_DIR    = solaris
    SYS       = -DSVR4 -DUNIX
    GCC_BIN       = /usr/local/bin/gcc
    CC_BIN    = /usr/bin/cc
    RGCC_BIN  = /usr/topgun/bin/rgcc
    AWK_BIN       = /usr/bin/nawk
    AS_BIN    = /usr/bin/as
    LD_BIN    = /usr/ccs/bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  = -Xa -Di386
    CC_DEBUG  = -g
    CC_OPT    = -O
    RGCC_FLAGS= -Xa -Di386
    RGCC_DEBUG= -g
    RGCC_OPT  = -Knoieee -Kinline -O ### -Kpentium
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /usr/bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /usr/bin/ln
    MV_BIN    = /usr/bin/mv
    RM_BIN    = /usr/bin/rm
    CHMOD_BIN = /usr/bin/chmod
    STRIP_BIN = /usr/ccs/bin/strip
else
ifeq ($(HOSTTYPE), MACH386)
    OS_DIR    = osf
    SYS       = -DOSF1 -DUNIX
    GCC_BIN       = /usr/local/bin/ngcc
    CC_BIN    = /bin/cc
    AWK_BIN       = /usr/local/bin/gawk
    AS_BIN    = /bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /bin/yacc
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  =
    CC_DEBUG  = -g
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), rs6000)
	OS_DIR    = aix
    SYS       = -DRS6000 -DAIX -DUNIX -DBIG_ENDIAN -DSTRICT_ALIGN
    GCC_BIN       = /usr/intel/bin/gcc
    CC_BIN    = /bin/cc
    AWK_BIN       = /usr/local/bin/gawk
    AS_BIN    = /bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /bin/yacc
    GCC_FLAGS =
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  =
    CC_DEBUG  = -g
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), sun4)
    OS_DIR    = sparc
    SYS       = -DSPARC -DSUNOS -DUNIX -DBIG_ENDIAN -DEWS -DSTRICT_ALIGN
    GCC_BIN   = /usr/local/bin/gcc
    CC_BIN    = /bin/cc
    AWK_BIN   = /usr/local/bin/gawk
    AS_BIN    = /bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /bin/yacc
    GCC_FLAGS =
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  =
    CC_DEBUG  = -g
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), HP)
    OS_DIR    = hp
    SYS       = -DUNIX -DHPUX -DBIG_ENDIAN -DSTRICT_ALIGN
    GCC_BIN   = /usr/local/gnu/cygnus/progressive-95q2/H-hppa1.1-hp-hpux9.05/bin/gcc
    CC_BIN    = /bin/cc
    AWK_BIN   = /usr/local/bin/gawk
    AS_BIN    = /bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /bin/yacc
    GCC_FLAGS =
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_OPT   = -O2
    CC_FLAGS  =
    CC_DEBUG  = -g
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE),hp9000s700)
    OS_DIR    = hp
    SYS       = -DUNIX -DHPUX -DBIG_ENDIAN -DSTRICT_ALIGN
    GCC_BIN   = /usr/intel/bin/gcc -fPIC
    CC_BIN    = /bin/cc
    AWK_BIN   = /usr/local/bin/gawk
    AS_BIN    = /bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /bin/yacc
    GCC_FLAGS =
    GCC_WARN  = -Wall -Wshadow -Wpointer-arith -Wcast-align \
                -Wconversion -Wmissing-prototypes -Wnested-externs
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2 -DNDEBUG
    CC_FLAGS  =
    CC_DEBUG  =
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), SCO)
    OS_DIR    = sco
    SYS       = -DSCO -DUNIX
    GCC_BIN       = /usr/local/bin/gcc
    CC_BIN    = /bin/cc
    AWK_BIN       = /usr/local/bin/gawk
    AS_BIN    = /usr/local/bin/as
    LD_BIN    = /bin/ld
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS = -m486
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
    CC_FLAGS  = -Xa -Di386
    CC_DEBUG  = -g
    CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = /bin/ar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), UNIX64)
    OS_DIR    =
    SYS       = -DSVR4 -DUNIX
    GCC_BIN       = gcc64
#   CC_BIN    = /bin/cc
    AWK_BIN       = /usr/local/bin/gawk
    AS_BIN    = ias
    LD_BIN    = ild
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS = -milp32
    GCC_DEBUG = -g $(GCC_WARN)
    GCC_OPT   = -O2
#   CC_FLAGS  = -Xa -Di386
#   CC_DEBUG  = -g
#   CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = iar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), UNIX64E) #Electron, 32 bit, EM
    OS_DIR    = eas
    SYS       = -DSVR4 -DUNIX
    GCC_BIN   = ecc.eas -32 -noannotate -D__PTR32__
#   CC_BIN    = /bin/cc
    AWK_BIN       = /usr/local/bin/gawk
    AS_BIN    = ias.eas
    LD_BIN    = ild.eas
    YACC_BIN  = /usr/bin/yacc
    GCC_FLAGS =
    GCC_DEBUG =  $(GCC_WARN)
    GCC_OPT   =
#   CC_FLAGS  = -Xa -Di386
#   CC_DEBUG  = -g
#   CC_OPT    = -O
    AS_FLAGS  =
    LD_FLAGS  = -r
    YC_FLAGS  = -d -v
    AR_BIN    = iar
    CP_BIN    = /bin/cp
    LN_BIN    = /bin/ln
    MV_BIN    = /bin/mv
    RM_BIN    = /bin/rm
    CHMOD_BIN = /bin/chmod
    STRIP_BIN = /bin/strip
else
ifeq ($(HOSTTYPE), WINNT64E) #Electron, 32 bit, EM
#   ToolBusterDir should be defined in the environment
    PERL      = perl -I$(ToolBusterDir)/lib/perl
    EXEXT     = .exe
    OS_DIR    = win32em
    PWD       =
    SYS       = -DWINNT
    GCC_BIN   = icl.exe
    CXX       = icl.exe
    CC_BIN    = icl.exe
    AS_BIN    = ias.exe
    LD_BIN    = ilib ### ??
    CAT_BIN   = cat.exe
    AR_BIN    = ilib.exe
    CP_BIN    = cp.exe
    MV_BIN    = mv.exe
    RM_BIN    = rm.exe
    CHMOD_BIN = chmod.exe
    AWK_BIN   = gawk
	CO        = co.exe
	CI        = ci.exe
    LIBMOFL   = libmofl.lib
    ELF_H     = elf.h
    GCC_OPT   = -DNDEBUG
    CFLAGS_D_DEXE32 = /nologo /Za /W3 /YX /D "_X86_" /D "_DEBUG"  \
		      /D "_CONSOLE" /D "__WINNT__" /D "EX86stuff"  \
		      /FR /ML /Fd"ILD.PDB" /Fp"ILD.PCH" ### ??
else
    GCC_BIN       = @echo HOSTTYPE undefined
    CC_BIN    = $(GCC_BIN)

hosttype_error:
	@echo check your HOSTTYPE environment variable, should be one of
	@echo i386, i486 iAPX386, UNIX386, UNIX, MACH386, rs6000, sun4, HP
	@exit 1

endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif
endif

ifeq ($(HOSTTYPE), WINNT)
	AR_OPT = /out:
	OEXT   = obj
	LEXT   = lib
	LDEXT  = dll
	EEXT   = .exe
	DOPT   = /D
	IOPT   = /I
ifdef STAT_LIB
	COPT   = /c
else
	COPT   = /c /MD
endif
	FOPT   =
	TC_FLAG = /Tc
	FE_FLAG = /Fe
	FO_FLAG = /Fo
	R_FLAG  =
	O_FLAG  =
	OUT_FLAG  = /out:
    DEBUG_FLAG = /Zi
    NT_O_FLAG  = /Fo
	DLL_LINK_FLAG  = /link /DLL
	NAME_FLAG  = /name:
	DLL       = dll
	ECHO      = $(ToolBusterDir)/bin/echo
	DELPARA = $(PERL) $(ToolBusterDir)/perlScripts/delpara
	SEPR   = &
	LINK_CC = link /SUBSYSTEM:console /MACHINE:i386
	LINK_DEBUG_FLAG = /DEBUG /FORCE:MULTIPLE
else
	AR_OPT = cr 
	OEXT   = o
	LEXT   = a
	LDEXT  = so
	EEXT   =
	DOPT   = -D
	IOPT   = -I
    COPT   = -c
	FOPT   = -f
	TC_FLAG =
	FE_FLAG =
	FO_FLAG =
	R_FLAG  = -r
	O_FLAG  = -o
	OUT_FLAG  =
    DEBUG_FLAG = -g
	NAME_FLAG =
	DLL_LINK_FLAG = -G
	DLL       = so
	LIB       = a
	ECHO      = echo
	DELPARA = $(PERL) $(SERVER_AREA)/scripts/delpara
	SEPR   = ;
	LINK_CC = $(CC)
	LINK_DEBUG_FLAG = $(DEBUG_FLAG)
endif


ifdef USE_LPROF
	PROF_FLAGS = -ql
	USECC = 1
	CC_OPT =
endif

# ToolBusterDir should be defined in the environment
# $$$ Default should be supplied
ifeq ($(HOSTTYPE), WINNT)
	MHDR =  $(PERL) $(ToolBusterDir)/perlScripts/mhdr -c
else
	MHDR =  $(PERL) $(SERVER_AREA)/scripts/mhdr -c
endif

LOCALBIN    = $(LOCALDIR)/bin.$(OS_DIR)
LOCALLIB    = $(LOCALDIR)/lib.$(OS_DIR)
INSTALLBIN  = $(INSTALLDIR)/bin.$(OS_DIR)
INSTALLLIB  = $(INSTALLDIR)/lib.$(OS_DIR)
PINSTALLBIN  = $(PINSTALLDIR)/bin.$(OS_DIR)
PINSTALLLIB  = $(PINSTALLDIR)/lib.$(OS_DIR)
ifndef INSTALLINC
   ifeq ($(HOSTTYPE), WINNT)
      INSTALLINC  = /topg_drive/x86sw/include
   else
      INSTALLINC  = $(INSTALLDIR)/include
   endif
endif
RELEASEBIN  = $(RELEASEDIR)/bin.$(OS_DIR)
RELEASELIB  = $(RELEASEDIR)/lib.$(OS_DIR)
RELEASEINC  = $(RELEASEDIR)/include
RELEASEMAN  = $(RELEASEDIR)/man/man1
RELEASEDEMO = $(RELEASEDIR)/demo

EAS_EXT = .eas

ifneq ($(HOSTTYPE), WINNT)
CUR_DIR  = $(shell pwd)
MAKE_DIR = $(PWD)
endif

BINDIR   = $(LOCALBIN)
SRCDIR   = $(LOCALDIR)/src
INCDIR   = $(INSTALLINC)
CTLDIR   = $(SRCDIR)/CTL64
DECDIR   = $(SRCDIR)/idecoder
DISDIR   = $(SRCDIR)/idasm
EMDBDIR   = $(SRCDIR)/emdb
DEC_TST_DIR   = $(LOCALDIR)/tst/idecoder
DIS_TST_DIR   = $(LOCALDIR)/tst/idasm

SIGNON   = $(INCDIR)/signon.h

USER_CFLAGS =
CFLAGS   = $(COPT) $(TOOL_FLAG) $(VFLAG) $(SYS) $(USER_CFLAGS)
CXXFLAGS = $(CFLAGS)

# additional suffixes
.SUFFIXES: .spec .dir .s .c .o .l .a

ifdef OPTIMIZE # default is using debug info
CC_COM  = $(CC_BIN) $(CC_FLAGS) $(CC_OPT)
GCC_COM = $(GCC_BIN) $(GCC_FLAGS) $(GCC_OPT)
RGCC_COM = $(RGCC_BIN) $(RGCC_FLAGS) $(RGCC_OPT)
else
CC_COM  = $(CC_BIN) $(CC_FLAGS) $(CC_DEBUG)
GCC_COM = $(GCC_BIN) $(GCC_FLAGS) $(GCC_DEBUG)
RGCC_COM = $(RGCC_BIN) $(RGCC_FLAGS) $(RGCC_DEBUG)
endif

ifdef USECC
	CC = $(CC_COM)
else
ifdef USERGCC
	CC = $(RGCC_COM)
else                                    # default is using gcc !
    USEGCC = 1                  # allow user to condition his flags upon this one
    CC = $(GCC_COM)
endif
endif

AWK     = $(AWK_BIN)
AS      = $(AS_BIN) $(AS_FLAGS)
LD      = $(LD_BIN) $(LD_FLAGS)
LD2     = $(CC)
AR      = $(AR_BIN)
CP      = $(CP_BIN)
LN      = $(LN_BIN)
MV      = $(MV_BIN) $(FOPT)
RM      = $(RM_BIN) $(FOPT)
CHMOD   = $(CHMOD_BIN)
STRIP   = $(STRIP_BIN)
YACC    = $(YACC_BIN) $(YC_FLAGS)


ifdef RCS_NO_UPDATE # default is update RCS
ifneq ($(HOSTTYPE),WINNT)
%:: RCS/%,v
	@test ! -f $@ || $(RCSDIFF) $@ > /dev/null || echo $@ need to be checked out 1>&2
	@test -f $@ || $(CO) $(COFLAGS) $< $@
else # of WINNT
%:: RCS/%,v
	@test ! -f "$@" || $(RCSDIFF) "$@" > NUL: || echo $@ need to be checked out 1>&2
	@test -f "$@" || $(CO) $(COFLAGS) "$@"
endif # of WINNT
else # of RCS_NO_UPDATE
ifneq ($(HOSTTYPE),WINNT)
%:: RCS/%,v
	@echo updating $@ 1>&2
	$(CO) $(COFLAGS) $@
else # of WINNT
%:: RCS/%,v
	@echo updating "$@" 1>&2
	$(CO) $(COFLAGS)   "$@"
endif # of WINNT
endif # of RCS_NO_UPDATE

ifeq ($(HOSTTYPE),WINNT)
%.obj: %.c
	$(CC) $(CFLAGS) /Fo$@ /Tc$<
endif

.c.o:
ifneq ($(HOSTTYPE),WINNT)
ifdef USECC
	$(CC) $(CFLAGS) ${CUR_DIR}/$<
# Do the move only if not in place
	$(patsubst $@-noexist,$(MV) $(@F) $@, $(filter-out $(filter $(@F), $@),$(firstword $(filter $(@F), $@) $@-noexist)))
else
	$(CC) $(CFLAGS) -o ${CUR_DIR}/$@ ${CUR_DIR}/$<
endif
else
	$(CC) $(CFLAGS) /Fo$@ /Tc$<
endif

.PHONY: force

include $(INCDIR)/Make_Arch.inc


ifeq ($(HOSTTYPE), WINNT)
    CUTPERL = $(PERL) cut.perl
else
    CUTPERL = cut.perl
endif


# Hook for Makefile debug purpose
echo_%:
	+@echo variable $* is "$($*)" its origin is "$(origin $*)"

# Every file of this type is not erased if it was an intermediate target
.PRECIOUS: %.c %.s %.h

# to avoid infinite loop, don't retry if.
# in case no other rule apply, try to build the target in that directory
ifndef TRIED_THIS_TRICK
.DEFAULT: %
	@echo !!!! Trying last resort default
	$(MAKE) -C $(@D) TRIED_THIS_TRICK=1 $(@F)
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\bind.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bind.c

Abstract:

Author:

Revision History:

--*/

#include <private.h>

BOOL
Match(
    char *Pattern,
    char *Text
    )
{
    switch (*Pattern) {
       case '\0':
            return *Text == '\0';

        case '?':
            return *Text != '\0' && Match( Pattern + 1, Text + 1 );

        case '*':
            do {
                if (Match( Pattern + 1, Text ))
                    return TRUE;
                    }
            while (*Text++);
            return FALSE;

        default:
            return toupper( *Text ) == toupper( *Pattern ) && Match( Pattern + 1, Text + 1 );
        }
}


BOOL
AnyMatches(
    char *Name,
    int  *NumList,
    int  Length,
    char **StringList
    )
{
    if (Length == 0) {
        return FALSE;
        }

    return (Match( StringList[ NumList[ 0 ] ], Name ) ||
            AnyMatches( Name, NumList + 1, Length - 1, StringList )
           );
}

BOOL
BindStatusRoutine(
    IMAGEHLP_STATUS_REASON Reason,
    LPSTR ImageName,
    LPSTR DllName,
    PVOID Va,
    ULONG_PTR Parameter
    );

#define BIND_ERR 99
#define BIND_OK  0

PCHAR SymbolPath;

BOOL fVerbose;
BOOL fNoUpdate = TRUE;
BOOL fDisableNewImports;
BOOL fNoCacheImportDlls;
BOOL fBindSysImages;
DWORD BindFlags;

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *p;
    int ExcludeList[256];
    int ExcludeListLength = 0;

    BOOL fUsage = FALSE;
    LPSTR DllPath;
    LPSTR CurrentImageName;

    int ArgNumber = argc;
    char **ArgList = argv;

    envp;

    DllPath = NULL;
    CurrentImageName = NULL;

    if (argc < 2) {
        goto usage;
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (toupper( c )) {
                case '?':
                    fUsage = TRUE;
                    break;

                case 'C':
                    fNoCacheImportDlls = TRUE;
                    break;

                case 'O':
                    fDisableNewImports = TRUE;
                    break;

                case 'P':
                    if (--argc) {
                        DllPath = *++argv;
                    } else {
                        fprintf( stderr, "BIND: Parameter missing for /%c\n", c );
                        fUsage = TRUE;
                    }
                    break;

                case 'S':
                    if (--argc) {
                        SymbolPath = *++argv;
                    } else {
                        fprintf( stderr, "BIND: Parameter missing for /%c\n", c );
                        fUsage = TRUE;
                    }
                    break;

                case 'U':
                    fNoUpdate = FALSE;
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'X' :
                    if (--argc) {
                        ++argv;
                        ExcludeList[ExcludeListLength] = ArgNumber - argc;
                        ExcludeListLength++;
                    } else {
                        fprintf( stderr, "BIND: Parameter missing for /%c\n", c );
                        fUsage = TRUE;
                    }
                    break;

                case 'Y':
                    fBindSysImages = TRUE;
                    break;

                default:
                    fprintf( stderr, "BIND: Invalid switch - /%c\n", c );
                    fUsage = TRUE;
                    break;
                }
            if (fUsage) {
usage:
                fputs("usage: BIND [switches] image-names... \n"
                      "            [-?] display this message\n"
                      "            [-c] no caching of import dlls\n"
                      "            [-o] disable new import descriptors\n"
                      "            [-p dll search path]\n"
                      "            [-s Symbol directory] update any associated .DBG file\n"
                      "            [-u] update the image\n"
                      "            [-v] verbose output\n"
                      "            [-x image name] exclude this image from binding\n"
                      "            [-y] allow binding on images located above 2G",
                      stderr
                     );
                return BIND_ERR;
            }
        } else {
            CurrentImageName = p;
            if (fVerbose) {
                fprintf( stdout,
                         "BIND: binding %s using DllPath %s\n",
                         CurrentImageName,
                         DllPath ? DllPath : "Default"
                       );
            }

            if (AnyMatches( CurrentImageName, ExcludeList, ExcludeListLength, ArgList )) {
                if (fVerbose) {
                    fprintf( stdout, "BIND: skipping %s\n", CurrentImageName );
                }
            } else {
                BindFlags = 0;

                if (!fNoCacheImportDlls) {
                    // Always cache across calls unless the user indicates otherwise.
                    BindFlags |= BIND_CACHE_IMPORT_DLLS;
                }
                if (fNoUpdate) {
                    BindFlags |= BIND_NO_UPDATE;
                }
                if (fDisableNewImports) {
                    BindFlags |= BIND_NO_BOUND_IMPORTS;
                }
                if (fBindSysImages) {
                    BindFlags |= BIND_ALL_IMAGES;
                }

                BindImageEx( BindFlags,
                             CurrentImageName,
                             DllPath,
                             SymbolPath,
                             (PIMAGEHLP_STATUS_ROUTINE)BindStatusRoutine
                           );
            }
        }
    }

    return BIND_OK;
}


BOOL
BindStatusRoutine(
    IMAGEHLP_STATUS_REASON Reason,
    LPSTR ImageName,
    LPSTR DllName,
    PVOID Va,
    ULONG_PTR Parameter
    )
{
    PIMAGE_BOUND_IMPORT_DESCRIPTOR NewImports, NewImport;
    PIMAGE_BOUND_FORWARDER_REF NewForwarder;
    UINT i;

    switch( Reason ) {
        case BindOutOfMemory:
            fprintf( stderr, "BIND: Out of memory - needed %u bytes.\n", Parameter );
            ExitProcess( 1 );

        case BindRvaToVaFailed:
            fprintf( stderr, "BIND: %s contains invalid Rva - %p\n", ImageName, Va );
            break;

        case BindNoRoomInImage:
            fprintf( stderr,
                     "BIND: Not enough room for new format import table.  Defaulting to unbound image.\n"
                   );
            break;

        case BindImportModuleFailed:
            fprintf( stderr,"BIND: %s - Unable to find %s\n", ImageName, DllName );
            break;

        case BindImportProcedureFailed:
            fprintf( stderr,
                     "BIND: %s - %s entry point not found in %s\n",
                     ImageName,
                     Parameter,
                     DllName
                   );
            break;

        case BindImportModule:
            if (fVerbose) {
                fprintf( stderr,"BIND: %s - Imports from %s\n", ImageName, DllName );
                }
            break;

        case BindImportProcedure:
            if (fVerbose) {
                fprintf( stderr,
                         "BIND: %s - %s Bound to %p\n",
                         ImageName,
                         Parameter,
                         Va
                       );
                }
            break;

        case BindForwarder:
            if (fVerbose) {
                fprintf( stderr, "BIND: %s - %s forwarded to %s [%p]\n",
                         ImageName,
                         DllName,
                         Parameter,
                         Va
                       );
            }
            break;

        case BindForwarderNOT:
            if (fVerbose) {
                fprintf( stderr,
                         "BIND: %s - Forwarder %s not snapped [%p]\n",
                         ImageName,
                         Parameter,
                         Va
                       );
                }
            break;

        case BindImageModified:
            fprintf( stdout, "BIND: binding %s\n", ImageName );
            break;


        case BindExpandFileHeaders:
            if (fVerbose) {
                fprintf( stderr,
                         "    Expanded %s file headers to %x\n",
                         ImageName,
                         Parameter
                       );
                }
            break;

        case BindMismatchedSymbols:
            fprintf(stderr, "BIND: Warning: %s checksum did not match %s\n",
                            ImageName,
                            (LPSTR)Parameter);
            break;

        case BindSymbolsNotUpdated:
            fprintf(stderr, "BIND: Warning: symbol file %s not updated.\n",
                            (LPSTR)Parameter);
            break;

        case BindImageComplete:
            if (fVerbose) {
                fprintf(stderr, "BIND: Details of binding of %s\n", ImageName );
                NewImports = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)Va;
                NewImport = NewImports;
                while (NewImport->OffsetModuleName) {
                    fprintf( stderr, "    Import from %s [%x]",
                             (LPSTR)NewImports + NewImport->OffsetModuleName,
                             NewImport->TimeDateStamp
                           );
                    if (NewImport->NumberOfModuleForwarderRefs != 0) {
                        fprintf( stderr, " with %u forwarders", NewImport->NumberOfModuleForwarderRefs );
                    }
                    fprintf( stderr, "\n" );
                    NewForwarder = (PIMAGE_BOUND_FORWARDER_REF)(NewImport+1);
                    for ( i=0; i<NewImport->NumberOfModuleForwarderRefs; i++ ) {
                        fprintf( stderr, "        Forward to %s [%x]\n",
                                 (LPSTR)NewImports + NewForwarder->OffsetModuleName,
                                 NewForwarder->TimeDateStamp
                               );
                        NewForwarder += 1;
                    }
                    NewImport = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)NewForwarder;
                }
            }
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\bindi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    bindi.c

Abstract:
    Implementation for the BindImage API

Author:

Revision History:

--*/

#include <private.h>

typedef struct _BOUND_FORWARDER_REFS {
    struct _BOUND_FORWARDER_REFS *Next;
    ULONG TimeDateStamp;
    LPSTR ModuleName;
} BOUND_FORWARDER_REFS, *PBOUND_FORWARDER_REFS;

typedef struct _IMPORT_DESCRIPTOR {
    struct _IMPORT_DESCRIPTOR *Next;
    LPSTR ModuleName;
    ULONG TimeDateStamp;
    USHORT NumberOfModuleForwarderRefs;
    PBOUND_FORWARDER_REFS Forwarders;
} IMPORT_DESCRIPTOR, *PIMPORT_DESCRIPTOR;

typedef struct _BINDP_PARAMETERS {
    DWORD Flags;
    BOOLEAN fNoUpdate;
    BOOLEAN fNewImports;
    LPSTR ImageName;
    LPSTR DllPath;
    LPSTR SymbolPath;
    PIMAGEHLP_STATUS_ROUTINE StatusRoutine;
} BINDP_PARAMETERS, *PBINDP_PARAMETERS;

BOOL
BindpLookupThunk(
    PBINDP_PARAMETERS Parms,
    PIMAGE_THUNK_DATA ThunkName,
    PLOADED_IMAGE Image,
    PIMAGE_THUNK_DATA SnappedThunks,
    PIMAGE_THUNK_DATA FunctionAddress,
    PLOADED_IMAGE Dll,
    PIMAGE_EXPORT_DIRECTORY Exports,
    PIMPORT_DESCRIPTOR NewImport,
    LPSTR DllPath,
    PULONG *ForwarderChain
    );

PVOID
BindpRvaToVa(
    PBINDP_PARAMETERS Parms,
    ULONG Rva,
    PLOADED_IMAGE Image
    );

VOID
BindpWalkAndProcessImports(
    PBINDP_PARAMETERS Parms,
    PLOADED_IMAGE Image,
    LPSTR DllPath,
    PBOOL ImageModified
    );

BOOL
BindImage(
    IN LPSTR ImageName,
    IN LPSTR DllPath,
    IN LPSTR SymbolPath
    )
{
    return BindImageEx( 0,
                        ImageName,
                        DllPath,
                        SymbolPath,
                        NULL
                      );
}

UCHAR BindpCapturedModuleNames[4096];
LPSTR BindpEndCapturedModuleNames;

LPSTR
BindpCaptureImportModuleName(
    LPSTR DllName
    )
{
    LPSTR s;

    s = (LPSTR) BindpCapturedModuleNames;
    if (BindpEndCapturedModuleNames == NULL) {
        *s = '\0';
        BindpEndCapturedModuleNames = s;
        }

    while (*s) {
        if (!_stricmp(s, DllName)) {
            return s;
            }

        s += strlen(s)+1;
        }

    strcpy(s, DllName);
    BindpEndCapturedModuleNames = s + strlen(s) + 1;
    *BindpEndCapturedModuleNames = '\0';
    return s;
}

PIMPORT_DESCRIPTOR
BindpAddImportDescriptor(
    PBINDP_PARAMETERS Parms,
    PIMPORT_DESCRIPTOR *NewImportDescriptor,
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor,
    LPSTR ModuleName,
    PLOADED_IMAGE Dll
    )
{
    PIMPORT_DESCRIPTOR p, *pp;

    if (!Parms->fNewImports) {
        return NULL;
        }

    pp = NewImportDescriptor;
    while (p = *pp) {
        if (!_stricmp( p->ModuleName, ModuleName )) {
            return p;
            }

        pp = &p->Next;
        }

    p = (PIMPORT_DESCRIPTOR) MemAlloc( sizeof( *p ) );
    if (p != NULL) {
        if (Dll != NULL) {
            p->TimeDateStamp = ((PIMAGE_NT_HEADERS32)Dll->FileHeader)->FileHeader.TimeDateStamp;
            }
        p->ModuleName = BindpCaptureImportModuleName( ModuleName );
        *pp = p;
        }
    else
    if (Parms->StatusRoutine != NULL) {
        (Parms->StatusRoutine)( BindOutOfMemory, NULL, NULL, 0, sizeof( *p ) );
        }

    return p;
}


PUCHAR
BindpAddForwarderReference(
    PBINDP_PARAMETERS Parms,
    LPSTR ImageName,
    LPSTR ImportName,
    PIMPORT_DESCRIPTOR NewImportDescriptor,
    LPSTR DllPath,
    PUCHAR ForwarderString,
    PBOOL BoundForwarder
    )
{
    CHAR DllName[ MAX_PATH ];
    PUCHAR s;
    PLOADED_IMAGE Dll;
    ULONG cb;
    USHORT OrdinalNumber;
    USHORT HintIndex;
    ULONG ExportSize;
    PIMAGE_EXPORT_DIRECTORY Exports;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG FunctionTableBase;
    LPSTR NameTableName;
    ULONG64 ForwardedAddress;
    PBOUND_FORWARDER_REFS p, *pp;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    *BoundForwarder = FALSE;
BindAnotherForwarder:
    s = ForwarderString;
    while (*s && *s != '.') {
        s++;
        }
    if (*s != '.') {
        return ForwarderString;
        }
    cb = (ULONG) (s - ForwarderString);
    if (cb >= MAX_PATH) {
        return ForwarderString;
        }
    strncpy( DllName, (LPSTR) ForwarderString, cb );
    DllName[ cb ] = '\0';
    strcat( DllName, ".DLL" );

    Dll = ImageLoad( DllName, DllPath );
    if (!Dll) {
        return ForwarderString;
        }
    s += 1;

    Exports = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData(
                                         (PVOID)Dll->MappedAddress,
                                         FALSE,
                                         IMAGE_DIRECTORY_ENTRY_EXPORT,
                                         &ExportSize
                                         );
    if (!Exports) {
        return ForwarderString;
    }

    FileHeader = &((PIMAGE_NT_HEADERS32)Dll->FileHeader)->FileHeader;
    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Dll->FileHeader,
                                 &OptionalHeader32,
                                 &OptionalHeader64);

    if ( *s == '#' ) {
        // Binding for ordinal forwarders

        OrdinalNumber = (atoi((PCHAR)s + 1)) - (USHORT)Exports->Base;

        if (OrdinalNumber >= Exports->NumberOfFunctions) {
            return ForwarderString;
        }
    } else {
        // Regular binding for named forwarders

        OrdinalNumber = 0xFFFF;
    }

    NameTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfNames, Dll );
    NameOrdinalTableBase = (PUSHORT) BindpRvaToVa( Parms, Exports->AddressOfNameOrdinals, Dll );
    FunctionTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfFunctions, Dll );

    if (OrdinalNumber == 0xFFFF) {
        for ( HintIndex = 0; HintIndex < Exports->NumberOfNames; HintIndex++){
            NameTableName = (LPSTR) BindpRvaToVa( Parms, NameTableBase[HintIndex], Dll );
            if ( NameTableName ) {
                OrdinalNumber = NameOrdinalTableBase[HintIndex];

                if (!strcmp((PCHAR)s, NameTableName)) {
                    break;
                }
            }
        }

        if (HintIndex >= Exports->NumberOfNames) {
            return ForwarderString;
        }
    }

    do {
       ForwardedAddress = FunctionTableBase[OrdinalNumber] +
           OPTIONALHEADER(ImageBase);

       pp = &NewImportDescriptor->Forwarders;
       while (p = *pp) {
           if (!_stricmp(DllName, p->ModuleName)) {
               break;
           }

           pp = &p->Next;
       }

       if (p == NULL) {
           p = (PBOUND_FORWARDER_REFS) MemAlloc( sizeof( *p ) );
           if (p == NULL) {
               if (Parms->StatusRoutine != NULL) {
                   (Parms->StatusRoutine)( BindOutOfMemory, NULL, NULL, 0, sizeof( *p ) );
               }

               break;
           }

           p->ModuleName = BindpCaptureImportModuleName( DllName );
           *pp = p;
           NewImportDescriptor->NumberOfModuleForwarderRefs += 1;
       }

       p->TimeDateStamp = FileHeader->TimeDateStamp;
       if (Parms->StatusRoutine != NULL)
       {
           (Parms->StatusRoutine)( BindForwarder,
                                   ImageName,
                                   ImportName,
                                   (ULONG_PTR)ForwardedAddress,
                                   (ULONG_PTR)ForwarderString
                                 );
       }

       Exports = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData(
                                            (PVOID)Dll->MappedAddress,
                                            TRUE,
                                            IMAGE_DIRECTORY_ENTRY_EXPORT,
                                            &ExportSize
                                            );

       Exports = (PIMAGE_EXPORT_DIRECTORY) ((ULONG_PTR)Exports -
                     (ULONG_PTR) Dll->MappedAddress +
                     OPTIONALHEADER(ImageBase));

       if ((ForwardedAddress >= (ULONG_PTR)Exports) &&
           (ForwardedAddress < ((ULONG_PTR)Exports + ExportSize)))
       {
           ForwarderString = (PUCHAR)BindpRvaToVa(Parms,
                                          FunctionTableBase[OrdinalNumber],
                                          Dll);
           goto BindAnotherForwarder;
       } else {
           ForwarderString = (PUCHAR)ForwardedAddress;
           *BoundForwarder = TRUE;
           break;
       }
    }
    while (0);

    return ForwarderString;
}

PIMAGE_BOUND_IMPORT_DESCRIPTOR
BindpCreateNewImportSection(
    PBINDP_PARAMETERS Parms,
    PIMPORT_DESCRIPTOR *NewImportDescriptor,
    PULONG NewImportsSize
    )
{
    ULONG cbString, cbStruct;
    PIMPORT_DESCRIPTOR p, *pp;
    PBOUND_FORWARDER_REFS p1, *pp1;
    LPSTR CapturedStrings;
    PIMAGE_BOUND_IMPORT_DESCRIPTOR NewImports, NewImport;
    PIMAGE_BOUND_FORWARDER_REF NewForwarder;


    *NewImportsSize = 0;
    cbString = 0;
    cbStruct = 0;
    pp = NewImportDescriptor;
    while (p = *pp) {
        cbStruct += sizeof( IMAGE_BOUND_IMPORT_DESCRIPTOR );
        pp1 = &p->Forwarders;
        while (p1 = *pp1) {
            cbStruct += sizeof( IMAGE_BOUND_FORWARDER_REF );
            pp1 = &p1->Next;
            }

        pp = &p->Next;
        }
    if (cbStruct == 0) {
        BindpEndCapturedModuleNames = NULL;
        return NULL;
        }
    cbStruct += sizeof(IMAGE_BOUND_IMPORT_DESCRIPTOR);    // Room for terminating zero entry
    cbString = (ULONG) (BindpEndCapturedModuleNames - (LPSTR) BindpCapturedModuleNames);
    BindpEndCapturedModuleNames = NULL;
    *NewImportsSize = cbStruct+((cbString + sizeof(ULONG) - 1) & ~(sizeof(ULONG)-1));
    NewImports = (PIMAGE_BOUND_IMPORT_DESCRIPTOR) MemAlloc( *NewImportsSize );
    if (NewImports != NULL) {
        CapturedStrings = (LPSTR)NewImports + cbStruct;
        memcpy(CapturedStrings, BindpCapturedModuleNames, cbString);

        NewImport = NewImports;
        pp = NewImportDescriptor;
        while (p = *pp) {
            NewImport->TimeDateStamp = p->TimeDateStamp;
            NewImport->OffsetModuleName = (USHORT)(cbStruct + (p->ModuleName - (LPSTR) BindpCapturedModuleNames));
            NewImport->NumberOfModuleForwarderRefs = p->NumberOfModuleForwarderRefs;

            NewForwarder = (PIMAGE_BOUND_FORWARDER_REF)(NewImport+1);
            pp1 = &p->Forwarders;
            while (p1 = *pp1) {
                NewForwarder->TimeDateStamp = p1->TimeDateStamp;
                NewForwarder->OffsetModuleName = (USHORT)(cbStruct + (p1->ModuleName - (LPSTR) BindpCapturedModuleNames));
                NewForwarder += 1;
                pp1 = &p1->Next;
                }
            NewImport = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)NewForwarder;

            pp = &p->Next;
            }
        }
    else
    if (Parms->StatusRoutine != NULL) {
        (Parms->StatusRoutine)( BindOutOfMemory, NULL, NULL, 0, *NewImportsSize );
        }

    pp = NewImportDescriptor;
    while ((p = *pp) != NULL) {
        *pp = p->Next;
        pp1 = &p->Forwarders;
        while ((p1 = *pp1) != NULL) {
            *pp1 = p1->Next;
            MemFree(p1);
            }

        MemFree(p);
        }

    return NewImports;
}

BOOL
BindpExpandImageFileHeaders(
    PBINDP_PARAMETERS Parms,
    PLOADED_IMAGE Dll,
    ULONG NewSizeOfHeaders
    )
{
    HANDLE hMappedFile;
    LPVOID lpMappedAddress;
    DWORD dwFileSizeLow, dwOldFileSize;
    DWORD dwFileSizeHigh;
    DWORD dwSizeDelta;
    PIMAGE_SECTION_HEADER Section;
    ULONG SectionNumber;
    PIMAGE_DEBUG_DIRECTORY DebugDirectories;
    ULONG DebugDirectoriesSize;
    ULONG OldSizeOfHeaders;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    dwFileSizeLow = GetFileSize( Dll->hFile, &dwFileSizeHigh );
    if (dwFileSizeLow == 0xFFFFFFFF || dwFileSizeHigh != 0) {
        return FALSE;
    }

    FileHeader = &((PIMAGE_NT_HEADERS32)Dll->FileHeader)->FileHeader;
    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Dll->FileHeader,
                                 &OptionalHeader32,
                                 &OptionalHeader64);

    if (!OptionalHeader32 && !OptionalHeader64) {
        return FALSE;
    }

    OldSizeOfHeaders = OPTIONALHEADER(SizeOfHeaders);
    dwOldFileSize = dwFileSizeLow;
    dwSizeDelta = NewSizeOfHeaders - OldSizeOfHeaders;
    dwFileSizeLow += dwSizeDelta;

    hMappedFile = CreateFileMapping(Dll->hFile,
                                    NULL,
                                    PAGE_READWRITE,
                                    dwFileSizeHigh,
                                    dwFileSizeLow,
                                    NULL
                                   );
    if (!hMappedFile) {
        return FALSE;
    }


    FlushViewOfFile(Dll->MappedAddress, Dll->SizeOfImage);
    UnmapViewOfFile(Dll->MappedAddress);
    lpMappedAddress = MapViewOfFileEx(hMappedFile,
                                      FILE_MAP_WRITE,
                                      0,
                                      0,
                                      0,
                                      Dll->MappedAddress
                                     );
    if (!lpMappedAddress) {
        lpMappedAddress = MapViewOfFileEx(hMappedFile,
                                          FILE_MAP_WRITE,
                                          0,
                                          0,
                                          0,
                                          0
                                         );
    }

    CloseHandle(hMappedFile);

    if (lpMappedAddress != Dll->MappedAddress) {
        Dll->MappedAddress = (PUCHAR) lpMappedAddress;
        CalculateImagePtrs(Dll);
        FileHeader = &((PIMAGE_NT_HEADERS32)Dll->FileHeader)->FileHeader;
        OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Dll->FileHeader,
                                     &OptionalHeader32,
                                     &OptionalHeader64);
    }

    if (Dll->SizeOfImage != dwFileSizeLow) {
        Dll->SizeOfImage = dwFileSizeLow;
    }

    DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryEntryToData(
                                            (PVOID)Dll->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_DEBUG,
                                            &DebugDirectoriesSize
                                            );

    if (DebugDirectoryIsUseful(DebugDirectories, DebugDirectoriesSize)) {
        while (DebugDirectoriesSize != 0) {
            DebugDirectories->PointerToRawData += dwSizeDelta;
            DebugDirectories += 1;
            DebugDirectoriesSize -= sizeof( *DebugDirectories );
        }
    }

    OPTIONALHEADER_LV(SizeOfHeaders) = NewSizeOfHeaders;
    if (FileHeader->PointerToSymbolTable != 0) {
        // Only adjust if it's already set

        FileHeader->PointerToSymbolTable += dwSizeDelta;
    }
    Section = Dll->Sections;
    for (SectionNumber=0; SectionNumber<FileHeader->NumberOfSections; SectionNumber++) {
        if (Section->PointerToRawData != 0) {
            Section->PointerToRawData += dwSizeDelta;
        }
        if (Section->PointerToRelocations != 0) {
            Section->PointerToRelocations += dwSizeDelta;
        }
        if (Section->PointerToLinenumbers != 0) {
            Section->PointerToLinenumbers += dwSizeDelta;
        }
        Section += 1;
    }

    memmove((LPSTR)lpMappedAddress + NewSizeOfHeaders,
            (LPSTR)lpMappedAddress + OldSizeOfHeaders,
            dwOldFileSize - OldSizeOfHeaders
           );

    if (Parms->StatusRoutine != NULL) {
        (Parms->StatusRoutine)( BindExpandFileHeaders, Dll->ModuleName, NULL, 0, NewSizeOfHeaders );
    }

    return TRUE;
}

BOOL
BindImageEx(
    IN DWORD Flags,
    IN LPSTR ImageName,
    IN LPSTR DllPath,
    IN LPSTR SymbolPath,
    IN PIMAGEHLP_STATUS_ROUTINE StatusRoutine
    )
{
    BINDP_PARAMETERS Parms;
    LOADED_IMAGE LoadedImageBuffer;
    PLOADED_IMAGE LoadedImage;
    ULONG CheckSum;
    ULONG HeaderSum;
    BOOL fSymbolsAlreadySplit, fRC;
    SYSTEMTIME SystemTime;
    FILETIME LastWriteTime;
    BOOL ImageModified;
    DWORD OldChecksum;
    CHAR DebugFileName[ MAX_PATH ];
    CHAR DebugFilePath[ MAX_PATH ];
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    Parms.Flags         = Flags;
    if (Flags & BIND_NO_BOUND_IMPORTS) {
        Parms.fNewImports = FALSE;
    } else {
        Parms.fNewImports = TRUE;
    }
    if (Flags & BIND_NO_UPDATE) {
        Parms.fNoUpdate = TRUE;
    } else {
        Parms.fNoUpdate = FALSE;
    }
    Parms.ImageName     = ImageName;
    Parms.DllPath       = DllPath;
    Parms.SymbolPath    = SymbolPath;
    Parms.StatusRoutine = StatusRoutine;

    fRC = FALSE;            // Assume we'll fail to bind

    __try {

        // Map and load the image

        LoadedImage = &LoadedImageBuffer;
        memset( LoadedImage, 0, sizeof( *LoadedImage ) );
        if (MapAndLoad( ImageName, DllPath, LoadedImage, TRUE, Parms.fNoUpdate )) {
            LoadedImage->ModuleName = ImageName;

            //
            // Now locate and walk through and process the images imports
            //
            if (LoadedImage->FileHeader != NULL &&
                ((Flags & BIND_ALL_IMAGES) || (!LoadedImage->fSystemImage)) ) {

                FileHeader = &((PIMAGE_NT_HEADERS32)LoadedImage->FileHeader)->FileHeader;
                OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)LoadedImage->FileHeader,
                                             &OptionalHeader32,
                                             &OptionalHeader64);

                if (OPTIONALHEADER(DllCharacteristics) & IMAGE_DLLCHARACTERISTICS_NO_BIND) {
                    goto NoBind;
                }

                {
                    DWORD dwDataSize;
                    PVOID pData = ImageDirectoryEntryToData(
                                                        LoadedImage->MappedAddress,
                                                        FALSE,
                                                        IMAGE_DIRECTORY_ENTRY_SECURITY,
                                                        &dwDataSize
                                                        );

                    if (pData || dwDataSize) {
                        // Signed - can't bind it.
                        goto NoBind;
                    }

                    pData = ImageDirectoryEntryToData(
                                                      LoadedImage->MappedAddress,
                                                      FALSE,
                                                      IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                                      &dwDataSize
                                                      );
            
                    if (pData || dwDataSize) {
                        // COR header found - see if it's strong signed
                        if (((IMAGE_COR20_HEADER *)pData)->StrongNameSignature.VirtualAddress &&
                            ((IMAGE_COR20_HEADER *)pData)->StrongNameSignature.Size)
                        {
                            goto NoBind;
                        }
                    }
                }


                BindpWalkAndProcessImports(
                                &Parms,
                                LoadedImage,
                                DllPath,
                                &ImageModified
                                );

                //
                // If the file is being updated, then recompute the checksum.
                // and update image and possibly stripped symbol file.
                //

                if (!Parms.fNoUpdate && ImageModified &&
                    (LoadedImage->hFile != INVALID_HANDLE_VALUE)) {
                    // The image may have been moved as part of remapping it to add space for the
                    // bound imports.  Recalculate the file and optional headers.
                    FileHeader = &((PIMAGE_NT_HEADERS32)LoadedImage->FileHeader)->FileHeader;
                    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)LoadedImage->FileHeader,
                                                 &OptionalHeader32,
                                                 &OptionalHeader64);
    
                    if ( (FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) &&
                         (SymbolPath != NULL) ) {
                        PIMAGE_DEBUG_DIRECTORY DebugDirectories;
                        ULONG DebugDirectoriesSize;
                        PIMAGE_DEBUG_MISC MiscDebug;

                        fSymbolsAlreadySplit = TRUE;
                        strcpy( DebugFileName, ImageName );
                        DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryEntryToData(
                                                                LoadedImage->MappedAddress,
                                                                FALSE,
                                                                IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                                &DebugDirectoriesSize
                                                                );
                        if (DebugDirectoryIsUseful(DebugDirectories, DebugDirectoriesSize)) {
                            while (DebugDirectoriesSize != 0) {
                                if (DebugDirectories->Type == IMAGE_DEBUG_TYPE_MISC) {
                                    MiscDebug = (PIMAGE_DEBUG_MISC)
                                        ((PCHAR)LoadedImage->MappedAddress +
                                         DebugDirectories->PointerToRawData
                                        );
                                    strcpy( DebugFileName, (PCHAR) MiscDebug->Data );
                                    break;
                                } else {
                                    DebugDirectories += 1;
                                    DebugDirectoriesSize -= sizeof( *DebugDirectories );
                                }
                            }
                        }
                    } else {
                        fSymbolsAlreadySplit = FALSE;
                    }

                    OldChecksum = OPTIONALHEADER(CheckSum);
                    CheckSumMappedFile(
                                (PVOID)LoadedImage->MappedAddress,
                                GetFileSize(LoadedImage->hFile, NULL),
                                &HeaderSum,
                                &CheckSum
                                );

                    OPTIONALHEADER_LV(CheckSum) = CheckSum;
                    FlushViewOfFile(LoadedImage->MappedAddress, LoadedImage->SizeOfImage);

                    if (fSymbolsAlreadySplit) {
                        if ( UpdateDebugInfoFileEx(ImageName,
                                                   SymbolPath,
                                                   DebugFilePath,
                                                   (PIMAGE_NT_HEADERS32)(LoadedImage->FileHeader),
                                                   OldChecksum)) {
                            if (GetLastError() == ERROR_INVALID_DATA) {
                                if (Parms.StatusRoutine != NULL) {
                                    (Parms.StatusRoutine)( BindMismatchedSymbols,
                                                           LoadedImage->ModuleName,
                                                           NULL,
                                                           0,
                                                           (ULONG_PTR)DebugFileName
                                                         );
                                }
                            }
                        } else {
                            if (Parms.StatusRoutine != NULL) {
                                (Parms.StatusRoutine)( BindSymbolsNotUpdated,
                                                       LoadedImage->ModuleName,
                                                       NULL,
                                                       0,
                                                       (ULONG_PTR)DebugFileName
                                                     );
                            }
                        }
                    }

                    GetSystemTime(&SystemTime);
                    if (SystemTimeToFileTime( &SystemTime, &LastWriteTime )) {
                        SetFileTime( LoadedImage->hFile, NULL, NULL, &LastWriteTime );
                    }
                }
            }

NoBind:
            fRC = TRUE;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // Nothing to do...
    }

    if (LoadedImage->MappedAddress) {
        UnmapViewOfFile( LoadedImage->MappedAddress );
    }    
    if (LoadedImage->hFile != INVALID_HANDLE_VALUE) {
        CloseHandle( LoadedImage->hFile );
    }

    if (!(Flags & BIND_CACHE_IMPORT_DLLS)) {
        UnloadAllImages();
    }

    return (fRC);
}


BOOL
BindpLookupThunk(
    PBINDP_PARAMETERS Parms,
    PIMAGE_THUNK_DATA ThunkName,
    PLOADED_IMAGE Image,
    PIMAGE_THUNK_DATA SnappedThunks,
    PIMAGE_THUNK_DATA FunctionAddress,
    PLOADED_IMAGE Dll,
    PIMAGE_EXPORT_DIRECTORY Exports,
    PIMPORT_DESCRIPTOR NewImport,
    LPSTR DllPath,
    PULONG *ForwarderChain
    )
{
    BOOL Ordinal;
    USHORT OrdinalNumber;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG FunctionTableBase;
    PIMAGE_IMPORT_BY_NAME ImportName;
    USHORT HintIndex;
    LPSTR NameTableName;
    ULONG64 ExportsBase;
    ULONG ExportSize;
    UCHAR NameBuffer[ 32 ];
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_OPTIONAL_HEADER32 DllOptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 DllOptionalHeader64 = NULL;

    NameTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfNames, Dll );
    if (!NameTableBase)
        return FALSE;
    NameOrdinalTableBase = (PUSHORT) BindpRvaToVa( Parms, Exports->AddressOfNameOrdinals, Dll );
    FunctionTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfFunctions, Dll );

    if (!FunctionTableBase) {
        return FALSE;
    }

    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Image->FileHeader,
                                 &OptionalHeader32,
                                 &OptionalHeader64);

    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Dll->FileHeader,
                                 &DllOptionalHeader32,
                                 &DllOptionalHeader64);
    //
    // Determine if snap is by name, or by ordinal
    //

    Ordinal = (BOOL)IMAGE_SNAP_BY_ORDINAL(ThunkName->u1.Ordinal);

    if (Ordinal) {
        UCHAR szOrdinal[8];
        OrdinalNumber = (USHORT)(IMAGE_ORDINAL(ThunkName->u1.Ordinal) - Exports->Base);
        if ( (ULONG)OrdinalNumber >= Exports->NumberOfFunctions ) {
            return FALSE;
            }
        ImportName = (PIMAGE_IMPORT_BY_NAME)NameBuffer;
        // Can't use sprintf w/o dragging in more CRT support than we want...  Must run on Win95.
        strcpy((PCHAR) ImportName->Name, "Ordinal");
        strcat((PCHAR) ImportName->Name, _ultoa((ULONG) OrdinalNumber, (LPSTR) szOrdinal, 16));
        }
    else {
        ImportName = (PIMAGE_IMPORT_BY_NAME)BindpRvaToVa(
                                                Parms,
                                                (ULONG)(ULONG_PTR)(ThunkName->u1.AddressOfData),
                                                Image
                                                );
        if (!ImportName) {
            return FALSE;
            }

        //
        // now check to see if the hint index is in range. If it
        // is, then check to see if it matches the function at
        // the hint. If all of this is true, then we can snap
        // by hint. Otherwise need to scan the name ordinal table
        //

        OrdinalNumber = (USHORT)(Exports->NumberOfFunctions+1);
        HintIndex = ImportName->Hint;
        if ((ULONG)HintIndex < Exports->NumberOfNames ) {
            NameTableName = (LPSTR) BindpRvaToVa( Parms, NameTableBase[HintIndex], Dll );
            if ( NameTableName ) {
                if ( !strcmp((PCHAR)ImportName->Name, NameTableName) ) {
                    OrdinalNumber = NameOrdinalTableBase[HintIndex];
                    }
                }
            }

        if ((ULONG)OrdinalNumber >= Exports->NumberOfFunctions) {
            for (HintIndex = 0; HintIndex < Exports->NumberOfNames; HintIndex++) {
                NameTableName = (LPSTR) BindpRvaToVa( Parms, NameTableBase[HintIndex], Dll );
                if (NameTableName) {
                    if (!strcmp( (PCHAR)ImportName->Name, NameTableName )) {
                        OrdinalNumber = NameOrdinalTableBase[HintIndex];
                        break;
                        }
                    }
                }

            if ((ULONG)OrdinalNumber >= Exports->NumberOfFunctions) {
                return FALSE;
                }
            }
    }

    (FunctionAddress->u1.Function) = (ULONG)(FunctionTableBase[OrdinalNumber] +
                                            (DllOptionalHeader32 ?
                                               DllOptionalHeader32->ImageBase :
                                               DllOptionalHeader64->ImageBase)
                                           );
    ExportsBase = (ULONG64)ImageDirectoryEntryToData(
                          (PVOID)Dll->MappedAddress,
                          TRUE,
                          IMAGE_DIRECTORY_ENTRY_EXPORT,
                          &ExportSize
                          ) - (ULONG_PTR)Dll->MappedAddress;
    ExportsBase += (DllOptionalHeader32 ?
                      DllOptionalHeader32->ImageBase :
                      DllOptionalHeader64->ImageBase);

    if ((ULONG64)FunctionAddress->u1.Function > (ULONG64)ExportsBase &&
        (ULONG64)FunctionAddress->u1.Function < ((ULONG64)ExportsBase + ExportSize)
       ) {
        BOOL BoundForwarder;

        BoundForwarder = FALSE;
        if (NewImport != NULL) {
            (FunctionAddress->u1.ForwarderString) = (ULONG_PTR)BindpAddForwarderReference(Parms,
                                           Image->ModuleName,
                                           (LPSTR) ImportName->Name,
                                           NewImport,
                                           DllPath,
                                           (PUCHAR) BindpRvaToVa( Parms, FunctionTableBase[OrdinalNumber], Dll ),
                                           &BoundForwarder
                                          );
            }

        if (!BoundForwarder) {
            **ForwarderChain = (ULONG) (FunctionAddress - SnappedThunks);
            *ForwarderChain = (ULONG *)&FunctionAddress->u1.Ordinal;

            if (Parms->StatusRoutine != NULL) {
                (Parms->StatusRoutine)( BindForwarderNOT,
                                        Image->ModuleName,
                                        Dll->ModuleName,
                                        (ULONG_PTR)FunctionAddress->u1.Function,
                                        (ULONG_PTR)(ImportName->Name)
                                      );
                }
            }
        }
    else {
        if (Parms->StatusRoutine != NULL) {
            (Parms->StatusRoutine)( BindImportProcedure,
                                    Image->ModuleName,
                                    Dll->ModuleName,
                                    (ULONG_PTR)FunctionAddress->u1.Function,
                                    (ULONG_PTR)(ImportName->Name)
                                  );
            }
        }

    return TRUE;
}

PVOID
BindpRvaToVa(
    PBINDP_PARAMETERS Parms,
    ULONG Rva,
    PLOADED_IMAGE Image
    )
{
    PVOID Va;

    Va = ImageRvaToVa( Image->FileHeader,
                       Image->MappedAddress,
                       Rva,
                       &Image->LastRvaSection
                     );
    if (!Va && Parms->StatusRoutine != NULL) {
        (Parms->StatusRoutine)( BindRvaToVaFailed,
                                Image->ModuleName,
                                NULL,
                                (ULONG)Rva,
                                0
                              );
        }

    return Va;
}

VOID
SetIdataToRo(
    PLOADED_IMAGE Image
    )
{
    PIMAGE_SECTION_HEADER Section;
    ULONG i;

    for(Section = Image->Sections,i=0; i<Image->NumberOfSections; i++,Section++) {
        if (!_stricmp((PCHAR) Section->Name, ".idata")) {
            if (Section->Characteristics & IMAGE_SCN_MEM_WRITE) {
                Section->Characteristics &= ~IMAGE_SCN_MEM_WRITE;
                Section->Characteristics |= IMAGE_SCN_MEM_READ;
                }

            break;
            }
        }
}

VOID
BindpWalkAndProcessImports(
    PBINDP_PARAMETERS Parms,
    PLOADED_IMAGE Image,
    LPSTR DllPath,
    PBOOL ImageModified
    )
{

    ULONG  ForwarderChainHead;
    PULONG ForwarderChain;
    ULONG ImportSize;
    ULONG ExportSize;
    PIMPORT_DESCRIPTOR NewImportDescriptorHead, NewImportDescriptor;
    PIMAGE_BOUND_IMPORT_DESCRIPTOR PrevNewImports, NewImports;
    ULONG PrevNewImportsSize, NewImportsSize;
    PIMAGE_IMPORT_DESCRIPTOR Imports;
    PIMAGE_EXPORT_DIRECTORY Exports;
    LPSTR ImportModule;
    PLOADED_IMAGE Dll;
    PIMAGE_THUNK_DATA tname,tsnap;
    PIMAGE_THUNK_DATA ThunkNames;
    PIMAGE_THUNK_DATA SnappedThunks;
    PIMAGE_IMPORT_BY_NAME ImportName;
    ULONG NumberOfThunks;
    ULONG i, cb;
    BOOL Ordinal, BindThunkFailed, NoErrors;
    USHORT OrdinalNumber;
    UCHAR NameBuffer[ 32 ];
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;
                                   
    NoErrors = FALSE;
    *ImageModified = FALSE;

    //
    // Locate the import array for this image/dll
    //

    NewImportDescriptorHead = NULL;
    Imports = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
                                            (PVOID)Image->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_IMPORT,
                                            &ImportSize
                                            );
    if (Imports == NULL) {
        //
        // Nothing to bind if no imports
        //

        return;
    }

    FileHeader = &((PIMAGE_NT_HEADERS32)Image->FileHeader)->FileHeader;
    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Image->FileHeader,
                                 &OptionalHeader32,
                                 &OptionalHeader64);

    PrevNewImports = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
                                                (PVOID)Image->MappedAddress,
                                                FALSE,
                                                IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,
                                                &PrevNewImportsSize
                                                );

    // If the user asked for an old style bind and there are new style bind records
    // already in the image, zero them out first.  This is the fix the problem where
    // you bind on NT (creating new import descriptors), boot Win95 and bind there
    // (creating old bind format), and then reboot to NT (the loader will only check
    // the BOUND_IMPORT array.

    if (PrevNewImports &&
        (Parms->fNewImports == FALSE) &&
        (Parms->fNoUpdate == FALSE ))
    {
        OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress) = 0;
        OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size) = 0;
        PrevNewImports = 0;
        PrevNewImportsSize = 0;
        *ImageModified = TRUE;
    }

    //
    // For each import record
    //

    for(;Imports;Imports++) {
        if ( !Imports->Name ) {
            break;
        }

        //
        // Locate the module being imported and load the dll
        //

        ImportModule = (LPSTR)BindpRvaToVa( Parms, Imports->Name, Image );

        if (ImportModule) {
            Dll = ImageLoad( ImportModule, DllPath );
            if (!Dll) {
                if (Parms->StatusRoutine != NULL) {
                    (Parms->StatusRoutine)( BindImportModuleFailed,
                                            Image->ModuleName,
                                            ImportModule,
                                            0,
                                            0
                                          );
                }
                //
                // Unless specifically told not to, generate the new style
                // import descriptor.
                //

                BindpAddImportDescriptor(Parms,
                                         &NewImportDescriptorHead,
                                         Imports,
                                         ImportModule,
                                         Dll
                                        );
                continue;
            }

            if (Parms->StatusRoutine != NULL) {
                (Parms->StatusRoutine)( BindImportModule,
                                        Image->ModuleName,
                                        ImportModule,
                                        0,
                                        0
                                      );
            }
            //
            // If we can load the DLL, locate the export section and
            // start snapping the thunks
            //

            Exports = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData(
                                                    (PVOID)Dll->MappedAddress,
                                                    FALSE,
                                                    IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                    &ExportSize
                                                    );
            if ( !Exports ) {
                continue;
            }

            //
            // assert that the export directory addresses can be translated
            //

            if ( !BindpRvaToVa( Parms, Exports->AddressOfNames, Dll ) ) {
                continue;
            }

            if ( !BindpRvaToVa( Parms, Exports->AddressOfNameOrdinals, Dll ) ) {
                continue;
            }

            if ( !BindpRvaToVa( Parms, Exports->AddressOfFunctions, Dll ) ) {
                continue;
            }

            //
            // For old style bind, bypass the bind if it's already bound.
            // New style binds s/b looked up in PrevNewImport.
            //

            if ( Parms->fNewImports == FALSE &&
                 Imports->TimeDateStamp &&
                 Imports->TimeDateStamp == FileHeader->TimeDateStamp ) {
                    continue;
            }

            //
            // Now we need to size our thunk table and
            // allocate a buffer to hold snapped thunks. This is
            // done instead of writting to the mapped view so that
            // thunks are only updated if we find all the entry points
            //

            ThunkNames = (PIMAGE_THUNK_DATA) BindpRvaToVa( Parms, Imports->OriginalFirstThunk, Image );

            if (!ThunkNames || ThunkNames->u1.Function == 0) {
                //
                // Skip this one if no thunks or first thunk is the terminating null thunk
                //
                continue;
            }

            //
            // Unless specifically told not to, generate the new style
            // import descriptor.
            //

            NewImportDescriptor = BindpAddImportDescriptor(Parms,
                                                           &NewImportDescriptorHead,
                                                           Imports,
                                                           ImportModule,
                                                           Dll
                                                          );
            NumberOfThunks = 0;
            tname = ThunkNames;
            while (tname->u1.AddressOfData) {
                NumberOfThunks++;
                tname++;
            }
            SnappedThunks = (PIMAGE_THUNK_DATA) MemAlloc( NumberOfThunks*sizeof(*SnappedThunks) );
            if ( !SnappedThunks ) {
                continue;
            }

            tname = ThunkNames;
            tsnap = SnappedThunks;
            NoErrors = TRUE;
            ForwarderChainHead = (ULONG)-1;
            ForwarderChain = &ForwarderChainHead;
            for(i=0;i<NumberOfThunks;i++) {
                BindThunkFailed = FALSE;
                __try {
                    if (!BindpLookupThunk( Parms,
                                           tname,
                                           Image,
                                           SnappedThunks,
                                           tsnap,
                                           Dll,
                                           Exports,
                                           NewImportDescriptor,
                                           DllPath,
                                           &ForwarderChain
                                         )
                       ) {
                        BindThunkFailed = TRUE;
                    }
                } __except ( EXCEPTION_EXECUTE_HANDLER ) {
                    BindThunkFailed = TRUE;
                }

                if (BindThunkFailed) {
                    if (NewImportDescriptor != NULL) {
                        NewImportDescriptor->TimeDateStamp = 0;
                    }

                    if (Parms->StatusRoutine != NULL) {
                        Ordinal = (BOOL)IMAGE_SNAP_BY_ORDINAL(tname->u1.Ordinal);
                        if (Ordinal) {
                            UCHAR szOrdinal[8];

                            OrdinalNumber = (USHORT)(IMAGE_ORDINAL(tname->u1.Ordinal) - Exports->Base);
                            ImportName = (PIMAGE_IMPORT_BY_NAME)NameBuffer;
                            // Can't use sprintf w/o dragging in more CRT support than we want...  Must run on Win95.
                            strcpy((PCHAR) ImportName->Name, "Ordinal");
                            strcat((PCHAR) ImportName->Name, _ultoa((ULONG) OrdinalNumber, (LPSTR)szOrdinal, 16));
                        }
                        else {
                            ImportName = (PIMAGE_IMPORT_BY_NAME)BindpRvaToVa(
                                                                    Parms,
                                                                    (ULONG)(ULONG_PTR)(tname->u1.AddressOfData),
                                                                    Image
                                                                    );
                        }

                        (Parms->StatusRoutine)( BindImportProcedureFailed,
                                                Image->ModuleName,
                                                Dll->ModuleName,
                                                (ULONG_PTR)tsnap->u1.Function,
                                                (ULONG_PTR)(ImportName->Name)
                                              );
                    }

                    break;
                }

                tname++;
                tsnap++;
            }

            tname = (PIMAGE_THUNK_DATA) BindpRvaToVa( Parms, Imports->FirstThunk, Image );
            if ( !tname ) {
                NoErrors = FALSE;
            }

            //
            // If we were able to locate all of the entrypoints in the
            // target dll, then copy the snapped thunks into the image,
            // update the time and date stamp, and flush the image to
            // disk
            //

            if ( NoErrors && Parms->fNoUpdate == FALSE ) {
                if (ForwarderChainHead != -1) {
                    *ImageModified = TRUE;
                    *ForwarderChain = -1;
                }
                if (Imports->ForwarderChain != ForwarderChainHead) {
                    Imports->ForwarderChain = ForwarderChainHead;
                    *ImageModified = TRUE;
                }
                cb = NumberOfThunks*sizeof(*SnappedThunks);
                if (memcmp(tname,SnappedThunks,cb)) {
                    MoveMemory(tname,SnappedThunks,cb);
                    *ImageModified = TRUE;
                }
                if (NewImportDescriptorHead == NULL) {
                    if (Imports->TimeDateStamp != FileHeader->TimeDateStamp) {
                        Imports->TimeDateStamp = FileHeader->TimeDateStamp;
                        *ImageModified = TRUE;
                    }
                }
                else
                if (Imports->TimeDateStamp != 0xFFFFFFFF) {
                    Imports->TimeDateStamp = 0xFFFFFFFF;
                    *ImageModified = TRUE;
                }
            }

            MemFree(SnappedThunks);
        }
    }

    NewImports = BindpCreateNewImportSection(Parms, &NewImportDescriptorHead, &NewImportsSize);
    if (PrevNewImportsSize != NewImportsSize ||
        memcmp( PrevNewImports, NewImports, NewImportsSize )
       ) {
        *ImageModified = TRUE;
    }

    if (!*ImageModified) {
        return;
    }

    if (Parms->StatusRoutine != NULL) {
        (Parms->StatusRoutine)( BindImageModified,
                                Image->ModuleName,
                                NULL,
                                0,
                                0
                              );
    }

    if (NewImports != NULL) {
        ULONG cbFreeFile, cbFreeHeaders, OffsetHeaderFreeSpace, cbFreeSpaceOnDisk;

        if (NoErrors && Parms->fNoUpdate == FALSE) {
            OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress) = 0;
            OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size) = 0;
        }
        OffsetHeaderFreeSpace = GetImageUnusedHeaderBytes( Image, &cbFreeFile );
        cbFreeHeaders = Image->Sections->VirtualAddress -
                        OPTIONALHEADER(SizeOfHeaders) +
                        cbFreeFile;

        // FreeSpace on Disk may be larger that FreeHeaders in the headers (the linker
        // can start the first section on a page boundary already)

        cbFreeSpaceOnDisk = Image->Sections->PointerToRawData -
                            OPTIONALHEADER(SizeOfHeaders) +
                            cbFreeFile;

        if (NewImportsSize > cbFreeFile) {
            if (NewImportsSize > cbFreeHeaders) {
                if (Parms->StatusRoutine != NULL) {
                    (Parms->StatusRoutine)( BindNoRoomInImage,
                                            Image->ModuleName,
                                            NULL,
                                            0,
                                            0
                                          );
                }
                NoErrors = FALSE;
            }
            else
            if (NoErrors && (Parms->fNoUpdate == FALSE)) {
                if (NewImportsSize <= cbFreeSpaceOnDisk) {

                    // There's already space on disk.  Just adjust the header size.

                    OPTIONALHEADER_LV(SizeOfHeaders) =
                        (OPTIONALHEADER(SizeOfHeaders) -
                         cbFreeFile + NewImportsSize + (OPTIONALHEADER(FileAlignment)-1)
                        ) & ~(OPTIONALHEADER(FileAlignment)-1);

                } else  {

                    NoErrors = BindpExpandImageFileHeaders( Parms,
                                                            Image,
                                                           (OPTIONALHEADER(SizeOfHeaders) -
                                                             cbFreeFile +
                                                             NewImportsSize +
                                                             (OPTIONALHEADER(FileAlignment)-1)
                                                            ) &
                                                             ~(OPTIONALHEADER(FileAlignment)-1)
                                                          );
                    // Expand may have remapped the image.  Recalc the header ptrs.
                    FileHeader = &((PIMAGE_NT_HEADERS32)Image->FileHeader)->FileHeader;
                    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Image->FileHeader,
                                                 &OptionalHeader32,
                                                 &OptionalHeader64);

                }
            }
        }

        if (Parms->StatusRoutine != NULL) {
            (Parms->StatusRoutine)( BindImageComplete,
                                    Image->ModuleName,
                                    NULL,
                                    (ULONG_PTR)NewImports,
                                    NoErrors
                                  );
        }

        if (NoErrors && Parms->fNoUpdate == FALSE) {
            OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress) = OffsetHeaderFreeSpace;
            OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size) = NewImportsSize;
            memcpy( (LPSTR)(Image->MappedAddress) + OffsetHeaderFreeSpace,
                    NewImports,
                    NewImportsSize
                  );
        }

        MemFree(NewImports);
    }

    if (NoErrors && Parms->fNoUpdate == FALSE) {
        SetIdataToRo( Image );
    }
}


DWORD
GetImageUnusedHeaderBytes(
    PLOADED_IMAGE LoadedImage,
    LPDWORD SizeUnusedHeaderBytes
    )
{
    DWORD OffsetFirstUnusedHeaderByte;
    DWORD i;
    DWORD OffsetHeader;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_NT_HEADERS32 NtHeaders;

    NtHeaders = (PIMAGE_NT_HEADERS32)LoadedImage->FileHeader;

    //
    // this calculates an offset, not an address, so DWORD is correct
    //
    OffsetFirstUnusedHeaderByte = (DWORD)
       (((LPSTR)NtHeaders - (LPSTR)LoadedImage->MappedAddress) +
        (FIELD_OFFSET( IMAGE_NT_HEADERS32, OptionalHeader ) +
         NtHeaders->FileHeader.SizeOfOptionalHeader +
         (NtHeaders->FileHeader.NumberOfSections *
          sizeof(IMAGE_SECTION_HEADER)
         )
        )
       );

    OptionalHeadersFromNtHeaders(NtHeaders,
                                 &OptionalHeader32,
                                 &OptionalHeader64);

    for ( i=0; i<OPTIONALHEADER(NumberOfRvaAndSizes); i++ ) {
        OffsetHeader = OPTIONALHEADER(DataDirectory[i].VirtualAddress);
        if (OffsetHeader < OPTIONALHEADER(SizeOfHeaders)) {
            if (OffsetHeader >= OffsetFirstUnusedHeaderByte) {
                OffsetFirstUnusedHeaderByte = OffsetHeader +
                    OPTIONALHEADER(DataDirectory[i].Size);
                }
            }
        }

    *SizeUnusedHeaderBytes = OPTIONALHEADER(SizeOfHeaders) -
                             OffsetFirstUnusedHeaderByte;

    return OffsetFirstUnusedHeaderByte;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\binplace.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>
#include <crt\io.h>
#include <share.h>
#include <time.h>
#include <process.h>
#include <setupapi.h>
#include "rsa.h"
#include "md5.h"
#include "symutil.h"
#include "dbgimage.h"
#include "splitsymx.h"
#include <string.h>
#include "wppfmt.h"

#define BINPLACE_LOG_SYNC_OBJECT "WRITE_BINPLACE_LOG"

#ifndef MOVEFILE_CREATE_HARDLINK
    #define MOVEFILE_CREATE_HARDLINK  0x00000010
#endif

#define BINPLACE_ERR 77
#define BINPLACE_OK 0

BOOL fUpDriver;
BOOL fUsage;
BOOL fVerbose;
BOOL fSymChecking;
BOOL fTestMode;
BOOL fSplitSymbols;
BOOL fSetupMode;
BOOL fSetupModeAllFiles;
BOOL fSetupModeScriptFile;
BOOL fPatheticOS;
BOOL fLiveSystem;
BOOL fKeepAttributes;
BOOL fDigitalSign;
BOOL fHardLinks;
BOOL fIgnoreHardLinks;
BOOL fDontLog;
BOOL fPlaceWin95SymFile;
BOOL fNoClassInSymbolsDir;
BOOL fMakeErrorOnDumpCopy;
BOOL fDontExit;
BOOL fForcePlace;
BOOL fSignCode;
BOOL fVerifyLc;
BOOL fWppFmt;
BOOL fCheckDelayload;
BOOL fChangeAsmsToRetailForSymbols;
BOOL fSrcControl;
BOOL fDbgControl;

HINSTANCE hSetupApi;
HINSTANCE hLcManager;
HRESULT (WINAPI * pVerifyLocConstraintA) (IN PCSTR FileName, IN PCSTR LcFileName);
BOOL (WINAPI * pSetupGetIntField) (IN PINFCONTEXT Context, IN DWORD FieldIndex, OUT PINT IntegerValue);
BOOL (WINAPI * pSetupFindFirstLineA) (IN HINF InfHandle, IN PCSTR Section, IN PCSTR Key, OPTIONAL OUT PINFCONTEXT Context );
BOOL (WINAPI * pSetupGetStringFieldA) (IN PINFCONTEXT Context, IN DWORD FieldIndex, OUT PSTR ReturnBuffer, OPTIONAL IN DWORD ReturnBufferSize, OUT PDWORD RequiredSize);
HINF (WINAPI * pSetupOpenInfFileA) ( IN PCSTR FileName, IN PCSTR InfClass, OPTIONAL IN DWORD InfStyle, OUT PUINT ErrorLine OPTIONAL );
HINF (WINAPI * pSetupOpenMasterInf) (VOID);

ULONG SplitFlags = 0;

LPSTR CurrentImageName;
LPSTR PlaceFileName;
LPSTR PlaceRootName;
LPSTR ExcludeFileName;
LPSTR DumpOverride;
LPSTR LayoutInfName;
LPSTR NormalPlaceSubdir;
LPSTR CommandScriptName;
LPSTR SymbolFilePath;
LPSTR PrivateSymbolFilePath;
LPSTR BinplaceLcDir;
LPSTR LcFilePart;
LPSTR szRSDSDllToLoad = NULL;

HINF LayoutInf;

FILE *PlaceFile;
FILE *LogFile;
FILE *CommandScriptFile;
CHAR* gDelayLoadModule;
CHAR* gDelayLoadHandler;
CHAR gFullFileName[MAX_PATH+1];
CHAR gFullDestName[MAX_PATH+1];
CHAR gPublicSymbol[MAX_PATH+1];
CHAR gPrivateSymbol[MAX_PATH+1];
UCHAR SetupFilePath[ MAX_PATH+1 ];
UCHAR DebugFilePath[ MAX_PATH+1 ];
UCHAR PlaceFilePath[ MAX_PATH+1 ];
UCHAR ExcludeFilePath[ MAX_PATH+1 ];
UCHAR DefaultSymbolFilePath[ MAX_PATH+1 ];
UCHAR szAltPlaceRoot[ MAX_PATH+1 ];
UCHAR LcFullFileName[ MAX_PATH+1 ];
UCHAR szExtraInfo[4096];
UCHAR TraceFormatFilePath[ MAX_PATH+1 ] ;
UCHAR LastPdbName[ MAX_PATH+1 ] ;
UCHAR TraceDir[ MAX_PATH+1 ] ;

PEXCLUDE_LIST ExcludeList;

struct {
    WORD  Machine;
    int   RC;
    CHAR  **Argv;
    int   Argc;
} ImageCheck;

#define DEFAULT_PLACE_FILE    "\\public\\sdk\\lib\\placefil.txt"
#define DEFAULT_NTROOT        "\\nt"
#define DEFAULT_NTDRIVE       "c:"
#define DEFAULT_DUMP          "dump"
#define DEFAULT_LCDIR         "LcINF"
#define DEFAULT_EXCLUDE_FILE  "\\public\\tools\\symbad.txt"
#define DEFAULT_TRACEDIR      "TraceFormat"
#define DEFAULT_DELAYLOADDIR  "delayload"

typedef struct _CLASS_TABLE {
    LPSTR ClassName;
    LPSTR ClassLocation;
} CLASS_TABLE, *PCLASS_TABLE;

BOOL
PlaceTheFile();

BOOL
StripCVSymbolPath (
    LPSTR DestinationFile
    );

typedef
BOOL
(WINAPI *PCREATEHARDLINKA)(
                          LPCSTR lpFileName,
                          LPCSTR lpExistingFileName,
                          LPSECURITY_ATTRIBUTES lpSecurityAttributes
                          );

PCREATEHARDLINKA pCreateHardLinkA;

BOOL
CopyTheFile(
           LPSTR SourceFileName,
           LPSTR SourceFilePart,
           LPSTR DestinationSubdir,
           LPSTR DestinationFilePart
           );

BOOL
BinplaceCopyPdb (
                LPSTR DestinationFile,
                LPSTR SourceFileName,       // Used for redist case
                BOOL  CopyFromSourceOnly,
                BOOL StripPrivate,
                LPSTR DestinationSymbol,
                DWORD LenDestSymbolBuffer
                );

BOOL
VerifyFinalImage(
                IN  PCHAR FileName,
                IN  BOOL  fRetail,
                OUT PBOOL BinplaceLc
                );

BOOL
SourceIsNewer(
             IN LPSTR SourceFile,
             IN LPSTR TargetFile
             );

BOOL
SetupModeRetailFile(
                   IN  LPSTR FullFileName,
                   IN  LPSTR FileNamePart,
                   OUT PBOOL PutInDump
                   );

__inline BOOL
SearchOneDirectory(
                  IN  LPSTR Directory,
                  IN  LPSTR FileToFind,
                  IN  LPSTR SourceFullName,
                  IN  LPSTR SourceFilePart,
                  OUT PBOOL FoundInTree
                  )
{
    //
    // This was way too slow. Just say we didn't find the file.
    //
    *FoundInTree = FALSE;
    return(TRUE);
}

BOOL
FileExists(
          IN  LPCSTR FileName,
          OUT PWIN32_FIND_DATA FindData
          );

BOOL
SignWithIDWKey(
              IN  LPCSTR  FileName);


CLASS_TABLE CommonClassTable[] = {
    {"retail",  "."},
    {"system",  "system32"},
    {"system16","system"},
    {"windows", "."},
    {"drivers", "system32\\drivers"},
    {"drvetc",  "system32\\drivers\\etc"},
    {"config",  "system32\\config"},
    {NULL,NULL}
};

CLASS_TABLE i386SpecificClassTable[] = {
    {"hal","system32"},
    {"printer","system32\\spool\\drivers\\w32x86"},
    {"prtprocs","system32\\spool\\prtprocs\\w32x86"},
    {NULL,NULL}
};

CLASS_TABLE Amd64SpecificClassTable[] = {
    {"hal",".."},
    {"printer","system32\\spool\\drivers\\w32amd64"},
    {"prtprocs","system32\\spool\\prtprocs\\w32amd64"},
    {NULL,NULL}
};

CLASS_TABLE ia64SpecificClassTable[] = {
    {"hal",".."},
    {"printer","system32\\spool\\drivers\\w32ia64"},
    {"prtprocs","system32\\spool\\prtprocs\\w32ia64"},
    {NULL,NULL}
    };

//
// Names of sections in layout.inx
//
LPCSTR szSourceDisksFiles = "SourceDisksFiles";
LPCSTR szSourceDisksAMD64 = "SourceDisksFiles.amd64";
LPCSTR szSourceDisksX86   = "SourceDisksFiles.x86";
LPCSTR szSourceDisksIA64  = "SourceDisksFiles.ia64";

typedef struct _PLACE_FILE_RECORD {
    LPSTR FileNameEntry;
    LPSTR FileClass;
} PLACE_FILE_RECORD, *PPLACE_FILE_RECORD;

int MaxNumberOfRecords;
int NumberOfRecords;
PPLACE_FILE_RECORD PlaceFileRecords;

int __cdecl
pfcomp(
      const void *e1,
      const void *e2
      )
{
    PPLACE_FILE_RECORD p1;
    PPLACE_FILE_RECORD p2;

    p1 = (PPLACE_FILE_RECORD)e1;
    p2 = (PPLACE_FILE_RECORD)e2;

    return (strcmp(p1->FileNameEntry,p2->FileNameEntry));
}

CHAR PlaceFileDir[4096];
CHAR PlaceFileClass[4096];
CHAR PlaceFileEntry[4096];

BOOL
SortPlaceFileRecord()
{
    int cfield;
    PPLACE_FILE_RECORD NewRecords;

    NumberOfRecords = 0;
    MaxNumberOfRecords = 0;

    //
    // get space for 6k records. Grow if need to.
    //
    MaxNumberOfRecords = 7000;
    PlaceFileRecords = (PPLACE_FILE_RECORD) malloc( sizeof(*PlaceFileRecords)*MaxNumberOfRecords );
    if ( !PlaceFileRecords ) {
        return FALSE;
    }

    if (fseek(PlaceFile,0,SEEK_SET)) {
        free(PlaceFileRecords);
        PlaceFileRecords = NULL;
        return FALSE;
    }
    
    while (fgets(PlaceFileDir,sizeof(PlaceFileDir),PlaceFile)) {

        PlaceFileEntry[0] = '\0';
        PlaceFileClass[0] = '\0';

        cfield = sscanf(
                       PlaceFileDir,
//                       "%s %[A-Za-z0-9.,_!@#\\$+=%^&()~ -]s",
                       "%s %s",
                       PlaceFileEntry,
                       PlaceFileClass
                       );

        if (cfield <= 0 || PlaceFileEntry[0] == ';') {
            continue;
        }

        PlaceFileRecords[NumberOfRecords].FileNameEntry = (LPSTR) malloc( strlen(PlaceFileEntry)+1 );
        PlaceFileRecords[NumberOfRecords].FileClass = (LPSTR) malloc( strlen(PlaceFileClass)+1 );
        if (!PlaceFileRecords[NumberOfRecords].FileClass || !PlaceFileRecords[NumberOfRecords].FileNameEntry) {
            if (PlaceFileRecords[NumberOfRecords].FileClass)
                free(PlaceFileRecords[NumberOfRecords].FileClass);
            if (PlaceFileRecords[NumberOfRecords].FileNameEntry)
                free(PlaceFileRecords[NumberOfRecords].FileNameEntry);
            free(PlaceFileRecords);
            PlaceFileRecords = NULL;
            return FALSE;
        }
        strcpy(PlaceFileRecords[NumberOfRecords].FileNameEntry,PlaceFileEntry);
        strcpy(PlaceFileRecords[NumberOfRecords].FileClass,PlaceFileClass);
        NumberOfRecords++;
        if ( NumberOfRecords >= MaxNumberOfRecords ) {
            MaxNumberOfRecords += 200;
            NewRecords = (PPLACE_FILE_RECORD) realloc(
                                                     PlaceFileRecords,
                                                     sizeof(*PlaceFileRecords)*MaxNumberOfRecords
                                                     );
            if ( !NewRecords ) {
                PlaceFileRecords = NULL;
                return FALSE;
            }
            PlaceFileRecords = NewRecords;
        }
    }
    qsort((void *)PlaceFileRecords,(size_t)NumberOfRecords,(size_t)sizeof(*PlaceFileRecords),pfcomp);
    return TRUE;
}

PPLACE_FILE_RECORD
LookupPlaceFileRecord(
                     LPSTR FileName
                     )
{
    LONG High;
    LONG Low;
    LONG Middle;
    LONG Result;

    //
    // Lookup the name using a binary search.
    //

    if ( !PlaceFileRecords ) {
        return NULL;
    }

    Low = 0;
    High = NumberOfRecords - 1;
    while (High >= Low) {

        //
        // Compute the next probe index and compare the import name
        // with the export name entry.
        //

        Middle = (Low + High) >> 1;
        Result = _stricmp(FileName, PlaceFileRecords[Middle].FileNameEntry);

        if (Result < 0) {
            High = Middle - 1;

        } else if (Result > 0) {
            Low = Middle + 1;

        } else {
            break;
        }
    }

    if (High < Low) {
        return NULL;
    } else {
        return &PlaceFileRecords[Middle];
    }
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *p, *OverrideFlags, *s, **newargv;
    LPSTR LogFileName = NULL;
    LPSTR LcFileName  = NULL;
    int len = 0;
    int i, n;
    BOOL NoPrivateSplit = FALSE;
    OSVERSIONINFO VersionInformation;
    LPTSTR platform;
    HANDLE hLogSync;

    // Grab the shared log event right away to increase the chances of collisions
    // (we would rather not have to create the event object every time)
    hLogSync = CreateMutex( NULL, FALSE, BINPLACE_LOG_SYNC_OBJECT );
    if (NULL == hLogSync) {
        fprintf(stderr, "BINPLACE : error BNP0000: unable to synchronize log access (%lu)\n", GetLastError() );
    }

    //
    // Win 95 can't compare file times very well, this hack neuters the SourceIsNewer function
    // on Win 95
    //
    VersionInformation.dwOSVersionInfoSize = sizeof( VersionInformation );
    if (GetVersionEx( &VersionInformation ) && VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_NT) {
        fPatheticOS = TRUE;
    }

    envp;
    fUpDriver = FALSE;
    fUsage = FALSE;
    fVerbose = FALSE;
    fSymChecking = FALSE;
    fTestMode = FALSE;
    fSplitSymbols = FALSE;
    fSetupMode = FALSE;
    fSetupModeAllFiles = FALSE;
    fSetupModeScriptFile = FALSE;
    fLiveSystem = FALSE;
    fKeepAttributes = FALSE;
    fDigitalSign = FALSE;
    fHardLinks = FALSE;
    fIgnoreHardLinks = FALSE;
    fDontExit = FALSE;
    fForcePlace = FALSE;
    fSignCode = FALSE;
    fVerifyLc = FALSE;
    fWppFmt = FALSE ;
    fSrcControl = FALSE;
    fDbgControl = FALSE;
    NormalPlaceSubdir = NULL;
    pVerifyLocConstraintA = NULL;
    gPublicSymbol[0] = '\0';
    gPrivateSymbol[0] = '\0';

    if (argc < 2) {
        goto showUsage;
    }

    szRSDSDllToLoad = (LPSTR) malloc(MAX_PATH+1);
    strcpy( szRSDSDllToLoad, "mspdb70.dll");

    LayoutInfName = NULL;

    setvbuf(stderr, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    if (!(PlaceFileName = getenv( "BINPLACE_PLACEFILE" ))) {
        if ((PlaceFileName = getenv("_NTDRIVE")) == NULL) {
            PlaceFileName = DEFAULT_NTDRIVE;
        }
        strcpy((PCHAR) PlaceFilePath, PlaceFileName);
        if ((PlaceFileName = getenv("_NTROOT")) == NULL) {
            PlaceFileName = DEFAULT_NTROOT;
        }
        strcat((PCHAR) PlaceFilePath, PlaceFileName);
        strcat((PCHAR) PlaceFilePath, DEFAULT_PLACE_FILE);
        PlaceFileName = (PCHAR) PlaceFilePath;
    }

    if (!(ExcludeFileName = getenv( "BINPLACE_EXCLUDE_FILE" ))) {
        if ((ExcludeFileName = getenv("_NTDRIVE")) == NULL) {
            ExcludeFileName = DEFAULT_NTDRIVE;
        }
        strcpy((PCHAR) ExcludeFilePath, ExcludeFileName);
        if ((ExcludeFileName = getenv("_NTROOT")) == NULL) {
            ExcludeFileName = DEFAULT_NTROOT;
        }
        strcat((PCHAR) ExcludeFilePath, ExcludeFileName);
        strcat((PCHAR) ExcludeFilePath, DEFAULT_EXCLUDE_FILE);
        ExcludeFileName = (PCHAR) ExcludeFilePath;
    }

    if (!(BinplaceLcDir = getenv( "BINPLACE_LCDIR" ))) {
        BinplaceLcDir = DEFAULT_LCDIR;
    }

    if ( getenv("NT_SIGNCODE") != NULL ) {
        fSignCode=TRUE;
    }

    //
    // Support Cross compile as well
    //

#if defined(_AMD64_)
    ImageCheck.Machine = IMAGE_FILE_MACHINE_AMD64;
    PlaceRootName = getenv( "_NTAMD64TREE" );
#elif defined(_IA64_)
    ImageCheck.Machine = IMAGE_FILE_MACHINE_IA64;
    PlaceRootName = getenv( "_NTIA64TREE" );
#else // defined(_X86_)
    if ((platform = getenv("AMD64")) != NULL) {
        ImageCheck.Machine = IMAGE_FILE_MACHINE_AMD64;
        PlaceRootName = getenv( "_NTAMD64TREE" );
    } else if ((platform = getenv("IA64")) != NULL) {
        ImageCheck.Machine = IMAGE_FILE_MACHINE_IA64;
        PlaceRootName = getenv( "_NTIA64TREE" );
    } else {
        ImageCheck.Machine = IMAGE_FILE_MACHINE_I386;
        PlaceRootName = getenv( "_NT386TREE" );
        if (!PlaceRootName)
            PlaceRootName = getenv( "_NTx86TREE" );
    }
#endif


    CurrentImageName = NULL;

    OverrideFlags = getenv( "BINPLACE_OVERRIDE_FLAGS" );
    if (OverrideFlags != NULL) {
        s = OverrideFlags;
        n = 0;
        while (*s) {
            while (*s && *s <= ' ')
                s += 1;
            if (*s) {
                n += 1;
                while (*s > ' ')
                    s += 1;

                if (*s)
                    *s++ = '\0';
            }
        }

        if (n) {
            newargv = malloc( (argc + n + 1) * sizeof( char * ) );
            memcpy( &newargv[n], argv, argc * sizeof( char * ) );
            argv = newargv;
            argv[ 0 ] = argv[ n ];
            argc += n;
            s = OverrideFlags;
            for (i=1; i<=n; i++) {
                while (*s && *s <= ' ')
                    s += 1;
                argv[ i ] = s;
                while (*s++)
                    ;
            }
        }
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            if (_stricmp(p + 1, "ChangeAsmsToRetailForSymbols") == 0) {
                fChangeAsmsToRetailForSymbols = TRUE;
            } else {
              while (c = *++p)
                switch (toupper( c )) {
                    case '?':
                        fUsage = TRUE;
                        break;

                    case 'A':
                        SplitFlags |= SPLITSYM_EXTRACT_ALL;
                        break;

                    case 'B':
                        argc--, argv++;
                        NormalPlaceSubdir = *argv;
                        break;

                    case 'C':
                        if (*(p+1) == 'I' || *(p+1) == 'i') {
                            char *q;

                            argc--, argv++;
                            p = *argv;
                            ImageCheck.RC = atoi(p);
                            if (!ImageCheck.RC) {
                                fprintf( stderr, "BINPLACE : error BNP0000: Invalid return code for -CI option\n");
                                fUsage = TRUE;
                            }
                            while (*p++ != ',');
                            q = p;
                            ImageCheck.Argc = 0;
                            while (*p != '\0')
                                if (*p++ == ',') ImageCheck.Argc++;
                            // last option plus extra args for Image file and Argv NULL
                            ImageCheck.Argc += 3;
                            ImageCheck.Argv = malloc( ImageCheck.Argc * sizeof( void * ) );
                            for ( i = 0; i <= ImageCheck.Argc - 3; i++) {
                                ImageCheck.Argv[i] = q;
                                while (*q != ',' && *q != '\0') q++;
                                *q++ = '\0';
                            }
                            p--;
                            ImageCheck.Argv[ImageCheck.Argc-1] = NULL;
                        } else {
                            fDigitalSign = TRUE;
                        }
                        break;

                    case 'D':
                        if (*(p+1) == 'L' || *(p+1) == 'l')
                        {
                            argc--, argv++;
                            p = *argv;
                            gDelayLoadModule = p;

                            while (*p != ',')
                            {
                                p++;
                            }
                            *p = '\0';
                            p++;
                            gDelayLoadHandler = p;

                            while (*p != '\0')
                            {
                                p++;
                            }
                            p--;

                            if (gDelayLoadModule[0] == '\0' ||
                                gDelayLoadHandler[0] == '\0')
                            {
                                fprintf(stderr, "BINPLACE : error BNP0000: Invalid switch for -dl option\n");
                                fUsage = TRUE;
                            }
                            else
                            {
                                fCheckDelayload = TRUE;
                            }
                        }
                        else
                        {
                            argc--, argv++;
                            DumpOverride = *argv;
                        }
                        break;

                    case 'E':
                        fDontExit = TRUE;
                        break;

                    case 'F':
                        fForcePlace = TRUE;
                        break;

                    case 'G':
                        argc--, argv++;
                        LcFileName = *argv;
                        break;

                    case 'H':
                        if ((VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
                            (VersionInformation.dwMajorVersion < 5) ||
                            (pCreateHardLinkA = (PCREATEHARDLINKA)GetProcAddress( GetModuleHandle( "KERNEL32" ),
                                                                                  "CreateHardLinkA"
                                                                                )
                            ) == NULL
                           ) {
                            fprintf( stderr, "BINPLACE: Hard links not supported.  Defaulting to CopyFile\n" );
                            fHardLinks = FALSE;
                        } else {
                            fHardLinks = TRUE;
                        }

                        break;

                    case 'I':
                        argc--, argv++;
                        LayoutInfName = *argv;
                        break;

                    case 'J':
                        fSymChecking = TRUE;
                        break;

                    case 'K':
                        fKeepAttributes = TRUE;
                        break;

                    case 'L':
                        fLiveSystem++;
                        break;

                    case 'M':
                        fMakeErrorOnDumpCopy = TRUE;
                        break;

                    case 'N':
                        argc--, argv++;
                        PrivateSymbolFilePath = *argv;
                        break;

                    case 'O':
                        argc--, argv++;
                        if (PlaceRootName != NULL) {
                            strcpy(szAltPlaceRoot,PlaceRootName);
                            strcat(szAltPlaceRoot,"\\");
                            strcat(szAltPlaceRoot,*argv);
                            PlaceRootName = szAltPlaceRoot;
                        }
                        break;

                    case 'P':
                        argc--, argv++;
                        PlaceFileName = *argv;
                        break;

                    case 'Q':
                        fDontLog = TRUE;
                        break;

                    case 'R':
                        argc--, argv++;
                        PlaceRootName = *argv;
                        break;

                    case 'S':
                        argc--, argv++;
                        SymbolFilePath = *argv;
                        fSplitSymbols = TRUE;
                        fIgnoreHardLinks = TRUE;
                        break;

                    case 'T':
                        fTestMode = TRUE;
                        break;

                    case 'U':
                        fUpDriver = TRUE;
                        break;

                    case 'V':
                        fVerbose = TRUE;
                        break;

                    case 'W':
                        fPlaceWin95SymFile = TRUE;
                        break;

                    case 'X':
                        SplitFlags |= SPLITSYM_REMOVE_PRIVATE;
                        break;

                    case 'Y':
                        fNoClassInSymbolsDir = TRUE;
                        break;

                    case 'Z':
                        NoPrivateSplit = TRUE;
                        break;

                    case '!':
                        hSetupApi = LoadLibrary("setupapi.dll");
                        if (hSetupApi) {
                            (VOID *) pSetupGetIntField     = GetProcAddress(hSetupApi, "SetupGetIntField");
                            (VOID *) pSetupFindFirstLineA  = GetProcAddress(hSetupApi, "SetupFindFirstLineA");
                            (VOID *) pSetupGetStringFieldA = GetProcAddress(hSetupApi, "SetupGetStringFieldA");
                            (VOID *) pSetupOpenInfFileA    = GetProcAddress(hSetupApi, "SetupOpenInfFileA");
                            (VOID *) pSetupOpenMasterInf   = GetProcAddress(hSetupApi, "SetupOpenMasterInf");

                            if (pSetupGetIntField     &&
                                pSetupFindFirstLineA  &&
                                pSetupGetStringFieldA &&
                                pSetupOpenInfFileA    &&
                                pSetupOpenMasterInf) {
                                fSetupMode = TRUE;
                            } else {
                                printf("Unable to bind to the necessary SETUPAPI.DLL functions... Ignoring setup mode switch\n");
                            }
                        }

                        if (*(p+1) == '!') {
                            p++;
                            if (fSetupMode)
                                fSetupModeAllFiles = TRUE;

                            if (*(p+1) == '!') {
                                p++;
                                argc--, argv++;
                                CommandScriptName = *argv;
                                if (fSetupMode) {
                                    fSetupModeScriptFile = TRUE;
                                    CommandScriptFile = fopen(CommandScriptName, "a");
                                    if (!CommandScriptFile) {
                                        fprintf(stderr,"BINPLACE : fatal error BNP0000: fopen of script file %s failed %d\n",CommandScriptName,GetLastError());
                                        exit(BINPLACE_ERR);
                                    }
                                }
                            } else {
                                fIgnoreHardLinks = TRUE;
                            }
                        } else {
                            fIgnoreHardLinks = TRUE;
                        }
                        break;

                    case ':':   // Simple (== crude) escape mechanism as all the letters are used
                                // -:XXX can add extra options if need be
                                // For now just handle TMF, Trace Message Format processing of PDB's
                        if ((strlen(p) >= 3) && ((toupper(*(p+1)) == 'T') && (toupper(*(p+2)) == 'M') && (toupper(*(p+3))) == 'F')) {
                            LPSTR tfile ;
                            // If the RUNWPP operation ran this option will be automatically added
                            p += 3 ; // Gobble up the TMF
                            fWppFmt = TRUE ;      // Need to package up the Software Tracing Formats
                            strncpy(TraceDir,DEFAULT_TRACEDIR,MAX_PATH) ;  //Append to PrivateSymbolsPath
                                                                           //If no default override.
                            tfile = getenv("TRACE_FORMAT_PATH");           //Has Path been overriden?
                            if (tfile != NULL) {
                                _snprintf(TraceFormatFilePath, MAX_PATH, "%s", tfile);
                                if (fVerbose) {
                                    fprintf( stdout, "BINPLACE : warning BNP0000: Trace Formats file path set to %s\n", TraceFormatFilePath ) ;
                                }
                            } else {
                                TraceFormatFilePath[0] = '\0' ;
                            }
            
                        } else if ((strlen(p) >= 3) && ((toupper(*(p+1)) == 'S') && (toupper(*(p+2)) == 'R') && (toupper(*(p+3))) == 'C')) {
                            // This is the option for turning on creating a cvdump for the pdb for
                            // source control.
                            p += 3;
                            fSrcControl=TRUE;

                        } else if ((strlen(p) >= 3) && ((toupper(*(p+1)) == 'D') && (toupper(*(p+2)) == 'B') && (toupper(*(p+3))) == 'G')) {
                            // This is the option for turning on creating a cvdump for the pdb for
                            // source control.
                            p += 3;
                            fDbgControl=TRUE;
                        }
                        break;


                    default:
                        fprintf( stderr, "BINPLACE : error BNP0000: Invalid switch - /%c\n", c );
                        fUsage = TRUE;
                        break;
                }
            }

            if ( fUsage ) {
                showUsage:
                fputs(
                     "usage: binplace [switches] image-names... \n"
                     "where: [-?] display this message\n"
                     "       [-a] Used with -s, extract all symbols\n"
                     "       [-b subdir] put file in subdirectory of normal place\n"
                     "       [-c] digitally sign image with IDW key\n"
                     "       [-d dump-override]\n"
                     "       [-:DBG] Don't binplace DBG files.  If -j is present, don't binplace \n"
                     "               binaries that point to DBG files.\n"
                     "       [-e] don't exit if a file in list could not be binplaced\n"
                     "       [-f] force placement by disregarding file timestamps\n"
                     "       [-g lc-file] verify image with localization constraint file\n"
                     "       [-h] modifies behavior to use hard links instead of CopyFile.\n"
                     "            (ignored if -s, -! or -!! is present)\n"
                     "       [-i layout-inf] Used with -!, -!! or -!!!, override master inf location\n"
                     "       [-j] verify proper symbols exist before copying\n"
                     "       [-k] keep attributes (don't turn off archive)\n"
                     "       [-l] operate over a live system\n"
                     "       [-n <Path>] Used with -x - Private pdb symbol path\n"
                     "       [-o place-root-subdir] alternate project subdirectory\n"
                     "       [-p place-file]\n"
                     "       [-q] suppress writing to log file %BINPLACE_LOG%\n"
                     "       [-r place-root]\n"
                     "       [-s Symbol file path] split symbols from image files\n"
                     "       [-:SRC] Process the PDB for source indexing\n"
                     "       [-t] test mode\n"
                     "       [-:TMF] Process the PDB for Trace Format files\n"
                     "       [-u] UP driver\n"
                     "       [-v] verbose output\n"
                     "       [-w] copy the Win95 Sym file to the symbols tree\n"
                     "       [-x] Used with -s, delete private symbolic when splitting\n"
                     "       [-y] Used with -s, don't create class subdirs in the symbols tree\n"
                     "       [-z] ignore -x if present\n"
                     "       [-!] setup mode (ignore optional files)\n"
                     "       [-!!] setup mode (copy optional files)\n"
                     "       [-!!! script-file] setup mode with command script\n"
                     "       [-ci <rc,app,-arg0,-argv1,-argn>]\n"
                     "            rc=application error return code,\n"
                     "            app=application used to check images,\n"
                     "            -arg0..-argn=application options\n"
                     "       [-dl <modulename,delay-load handler>] (run dlcheck on this file)\n"
                     "\n"
                     "BINPLACE looks for the following environment variable names:\n"
                     "   BINPLACE_EXCLUDE_FILE - full path name to symbad.txt\n"
                     "   BINPLACE_OVERRIDE_FLAGS - may contain additional switches\n"
                     "   BINPLACE_PLACEFILE - default value for -p flag\n"
                     "   _NT386TREE - default value for -r flag on x86 platform\n"
                     "   _NTAMD64TREE - default value for -r flag on AMD64 platform\n"
                     "   _NTIA64TREE - default value for -r flag on IA64 platform\n"
                     "   TRACE_FORMAT_PATH - set the path for Trace Format Files\n" 
                     "\n"
                     ,stderr
                     );

                exit(BINPLACE_ERR);
            }
        } else {
            WIN32_FIND_DATA FindData;
            HANDLE h;

            if (!PlaceRootName) {
                // If there's no root, just exit.
                exit(BINPLACE_OK);
            }

            //
            // Workaround for bogus setargv: ignore directories
            //
            if (NoPrivateSplit) {
                SplitFlags &= ~SPLITSYM_REMOVE_PRIVATE;
            }

            h = FindFirstFile(p,&FindData);
            if (h != INVALID_HANDLE_VALUE) {
                FindClose(h);
                if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    if ( fVerbose ) {
                        fprintf(stdout,"BINPLACE : warning BNP0000: ignoring directory %s\n",p);
                    }
                    continue;
                }
            }

            CurrentImageName = p;

            // If this is a dbg, don't binplace it
            if ( fDbgControl && (strlen(p) > 4)  && 
                 (strcmp(p+strlen(p)-4, ".dbg")== 0 ) ) {
               fprintf(stderr, "BINPLACE : warning BNP0000: Dbg files not allowed. Use dbgtopdb.exe to remove %s.\n",p);
               fprintf(stderr, "BINPLACE : warning BNP0000: This will be an error after May 18, 2001 - problems, contact BarbKess.\n");
               // exit(BINPLACE_ERR); 
            }

            //
            // If the master place file has not been opened, open
            // it up.
            //

            if ( !PlaceFile ) {
                PlaceFile = fopen(PlaceFileName, "rt");
                if (!PlaceFile) {
                    fprintf(stderr,"BINPLACE : fatal error BNP0000: fopen of placefile %s failed %d\n",PlaceFileName,GetLastError());
                    exit(BINPLACE_ERR);
                }
                if (fSetupMode && !fSetupModeScriptFile) {
                    SortPlaceFileRecord();
                }
            }

            //
            // Check for bogus -g lc-file switch
            //
            if ( LcFileName != NULL ) {
                h = FindFirstFile(LcFileName, &FindData);
                if (h == INVALID_HANDLE_VALUE ||
                    (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    if (fVerbose ) {
                        fprintf(stdout,"BINPLACE : warning BNP0000: invalid file %s. Ignoring -G switch.\n", LcFileName);
                    }
                    LcFileName = NULL;
                }
                if (h != INVALID_HANDLE_VALUE) {
                    FindClose(h);
                }
            }
            if ( LcFileName != NULL ) {
                DWORD cb = GetFullPathName(LcFileName,MAX_PATH+1,LcFullFileName,&LcFilePart);
                if (!cb || cb > MAX_PATH+1) {
                    fprintf(stderr,"BINPLACE : fatal error BNP0000: GetFullPathName %s failed %d\n",LcFileName, GetLastError());
                    exit(BINPLACE_ERR);
                }

                hLcManager = LoadLibraryA("lcman.DLL");
                if (hLcManager != NULL) {
                    (VOID *) pVerifyLocConstraintA = GetProcAddress(hLcManager, "VerifyLocConstraintA");
                }
                if (pVerifyLocConstraintA != NULL) {
                    fVerifyLc = TRUE;
                } else {
                    fprintf(stdout,"BINPLACE : warning BNP0000: Unable to bind to the necessary LCMAN.DLL functions... Ignoring -G switch\n");
                }
            }

            // Get the Exclude List

            ExcludeList = GetExcludeList( ExcludeFileName );

            if (PlaceRootName == NULL) {
                fprintf(stderr,"BINPLACE : fatal error BNP0000: Place Root not defined - exiting.\n");
                exit(BINPLACE_ERR);
            }

            // If the SymbolFilePath has not been set, make a default value.
            if (!SymbolFilePath) {
                strcpy(DefaultSymbolFilePath, PlaceRootName);
                strcat(DefaultSymbolFilePath, "\\symbols");
                SymbolFilePath = DefaultSymbolFilePath;
            }

            if ( !PlaceTheFile() ) {
                if (fDontExit) {
                    fprintf(stderr,"BINPLACE : error BNP0000: Unable to place file %s.\n",CurrentImageName);
                } else {
                    fprintf(stderr,"BINPLACE : fatal error BNP0000: Unable to place file %s - exiting.\n",CurrentImageName);
                    exit(BINPLACE_ERR);
                }
            }

            if ( !fDontLog) {
                if (hLogSync) {
                    WaitForSingleObject(hLogSync, INFINITE);
                }
                if ((LogFileName = getenv("BINPLACE_LOG")) != NULL) {
                    UINT cRetries = 25;
                    if (!MakeSureDirectoryPathExists(LogFileName)) {
                        fprintf(stderr,"BINPLACE : error BNP0000: Unable to make directory to \"%s\"\n", LogFileName);
                    }
                    do
                    {
                        LogFile = _fsopen(LogFileName, "a", _SH_DENYWR);
                        Sleep(0L); // give up time-slice
                    } while (!LogFile && --cRetries > 0);

                    if ( !LogFile ) {
                        fprintf(stderr,"BINPLACE : error BNP0000: fopen of log file %s failed %d\n", LogFileName,GetLastError());
                    } else {
                        time_t Time;
                        FILE *fSlmIni;
                        UCHAR szProject[MAX_PATH];
                        UCHAR szSlmServer[MAX_PATH];
                        UCHAR szEnlistment[MAX_PATH];
                        UCHAR szSlmDir[MAX_PATH];
                        UCHAR *szTime="";
                        char szPublicSymbol[MAX_PATH+1],
                             szPrivateSymbol[MAX_PATH+1],
                             *pFile;
                        // Get some other interesting info.
                        fSlmIni = fopen("slm.ini", "r");
                        if (fSlmIni) {
                            fgets(szProject, sizeof(szProject), fSlmIni);
                            fgets(szSlmServer, sizeof(szSlmServer), fSlmIni);
                            fgets(szEnlistment, sizeof(szEnlistment), fSlmIni);
                            fgets(szSlmDir, sizeof(szSlmDir), fSlmIni);
                            // Get rid of the trailing newlines
                            szProject[strlen(szProject)-1] = '\0';
                            szSlmServer[strlen(szSlmServer)-1] = '\0';
                            szSlmDir[strlen(szSlmDir)-1] = '\0';
                            fclose(fSlmIni);
                        } else {
                            szSlmServer[0] = '\0';
                            szProject[0] = '\0';
                            szSlmDir[0] = '\0';
                        }
                        Time = time(NULL);
                        szTime = ctime(&Time);
                        if ( *szTime ) szTime[ strlen(szTime) - 1] = '\0'; // strip off newline
                        sprintf(szExtraInfo,
                                "%s\t%s\t%s\t%s",
                                szSlmServer,
                                szProject,
                                szSlmDir,
                                szTime);

        
                        if ('\0' != *gPublicSymbol)
                        {
                            GetFullPathName( gPublicSymbol,
                                             MAX_PATH + 1,
                                             szPublicSymbol,
                                             &pFile );
                        }
                        else
                        {
                            szPublicSymbol[0] = '\0';
                        }
                        if ('\0' != *gPrivateSymbol)
                        {
                            GetFullPathName( gPrivateSymbol,
                                             MAX_PATH + 1,
                                             szPrivateSymbol,
                                             &pFile );
                        }
                        else
                        {
                            szPrivateSymbol[0] = '\0';
                        }
                        len = fprintf(LogFile,"%s\t%s\t%s\t%s\t%s\n",
                                              gFullFileName,
                                              szExtraInfo,
                                              gFullDestName,
                                              szPublicSymbol,
                                              szPrivateSymbol);
                        if ( len < 0 ) {
                            fprintf(stderr,"BINPLACE : error BNP0000: write to log file %s failed %d\n", LogFileName, GetLastError());
                        }

                        fclose(LogFile);
                    }
                }
                if (hLogSync) {
                    ReleaseMutex(hLogSync);
                }
            }
        }
    }
    exit(BINPLACE_OK);
    return BINPLACE_OK;
}

BOOL
PlaceTheFile()
{
    CHAR FullFileName[MAX_PATH+1];
    LPSTR PlaceFileNewName;
    LPSTR FilePart;
    LPSTR Separator;
    LPSTR PlaceFileClassPart;
    DWORD cb;
    int cfield;
    PCLASS_TABLE ClassTablePointer;
    BOOLEAN ClassMatch;
    BOOL    fCopyResult;
    LPSTR Extension;
    BOOL PutInDump;
    BOOL PutInDebug = FALSE;
    BOOL PutInLcDir = FALSE;

    cb = GetFullPathName(CurrentImageName,MAX_PATH+1,FullFileName,&FilePart);

    if (!cb || cb > MAX_PATH+1) {
        fprintf(stderr,"BINPLACE : fatal error BNP0000: GetFullPathName failed %d\n",GetLastError());
        return FALSE;
    }

    strcpy(gFullFileName,FullFileName);

    if (fVerbose) {
        fprintf(stdout,"BINPLACE : warning BNP0000: Looking at file %s\n",FilePart);
    }

    Extension = strrchr(FilePart,'.');
    if (Extension) {
        if (!_stricmp(Extension,".DBG")) {
            PutInDebug = TRUE;
        }
        else if (!_stricmp(Extension,".LC")) {
            PutInLcDir = TRUE;
        }
    }

    if (!DumpOverride) {

        if (fSetupMode && !fSetupModeScriptFile) {
            PPLACE_FILE_RECORD PfRec;

            PfRec = LookupPlaceFileRecord(FilePart);

            if ( PfRec ) {
                strncpy(PlaceFileEntry,PfRec->FileNameEntry, sizeof(PlaceFileEntry));
                strncpy(PlaceFileClass,PfRec->FileClass, sizeof(PlaceFileClass));
                PlaceFileNewName = NULL;
                goto fastfound;
            }
        }
        if (fseek(PlaceFile,0,SEEK_SET)) {
            fprintf(stderr,"BINPLACE : fatal error BNP0000: fseek(PlaceFile,0,SEEK_SET) failed %d\n",GetLastError());
            return FALSE;
        }
        while (fgets(PlaceFileDir,sizeof(PlaceFileDir),PlaceFile)) {

            PlaceFileEntry[0] = '\0';
            PlaceFileClass[0] = '\0';

            cfield = sscanf(
                           PlaceFileDir,
//                           "%s %[A-Za-z0-9.,_!@#\\$+=%^&()~ -]s",
                           "%s %s",
                           PlaceFileEntry,
                           PlaceFileClass
                           );

            if (cfield <= 0 || PlaceFileEntry[0] == ';') {
                continue;
            }

            if (PlaceFileNewName = strchr(PlaceFileEntry,'!')) {
                *PlaceFileNewName++ = '\0';
            }

            if (!_stricmp(FilePart,PlaceFileEntry)) {
                fastfound:
                //
                // now that we have the file and class, search the
                // class tables for the directory.
                //
                Separator = PlaceFileClass - 1;
                while (Separator) {

                    PlaceFileClassPart = Separator+1;
                    Separator = strchr(PlaceFileClassPart,':');
                    if (Separator) {
                        *Separator = '\0';
                    }

                    //
                    // If the class is "retail" and we're in Setup mode,
                    // handle this file specially. Setup mode is used to
                    // incrementally binplace files into an existing installation.
                    //
                    SetupFilePath[0] = '\0';
                    if (fSetupMode && !_stricmp(PlaceFileClassPart,"retail")) {
                        if (SetupModeRetailFile(FullFileName,FilePart,&PutInDump)) {
                            //
                            // No error. Either the file was handled or we need to
                            // put it in the dump directory.
                            //
                            if (PutInDump) {
                                fCopyResult = CopyTheFile(
                                                         FullFileName,
                                                         FilePart,
                                                         (DumpOverride ? DumpOverride : DEFAULT_DUMP),
                                                         NULL
                                                         );
                            } else {
                                fCopyResult = TRUE;
                            }
                        } else {
                            //
                            // Got an error, return error status.
                            //
                            fCopyResult = FALSE;
                        }

                        if (!fSetupModeScriptFile) {
                            return(fCopyResult);
                        }
                    }

                    PlaceFileDir[0]='\0';
                    ClassMatch = FALSE;
                    ClassTablePointer = &CommonClassTable[0];
                    while (ClassTablePointer->ClassName) {
                        if (!_stricmp(ClassTablePointer->ClassName,PlaceFileClassPart)) {
                            strcpy(PlaceFileDir,ClassTablePointer->ClassLocation);
                            ClassMatch = TRUE;

                            //
                            // If the class is a driver and a UP driver is
                            // specified, then put the driver in the UP
                            // subdirectory.
                            //
                            // Do the same for retail. We assume the -u switch is passed
                            // only when actually needed.
                            //
                            if (fUpDriver
                                && (   !_stricmp(PlaceFileClass,"drivers")
                                       || !_stricmp(PlaceFileClass,"retail"))) {
                                strcat(PlaceFileDir,"\\up");
                            }
                            break;
                        }

                        ClassTablePointer++;
                    }

                    if (!ClassMatch) {
                        //
                        // Search Specific classes
                        //
                        // We need to support cross compiling here.
                        LPTSTR platform;

#if   defined(_AMD64_)
                        ClassTablePointer = &Amd64SpecificClassTable[0];
#elif defined(_IA64_)
                        ClassTablePointer = &ia64SpecificClassTable[0];
#else // defined(_X86_)
                        ClassTablePointer = &i386SpecificClassTable[0];
                        if ((platform = getenv("AMD64")) != NULL) {
                            ClassTablePointer = &Amd64SpecificClassTable[0];
                        } else if ((platform = getenv("IA64")) != NULL) {
                            ClassTablePointer = &ia64SpecificClassTable[0];
                        }
#endif
                        while (ClassTablePointer->ClassName) {

                            if (!_stricmp(ClassTablePointer->ClassName,PlaceFileClassPart)) {
                                strcpy(PlaceFileDir,ClassTablePointer->ClassLocation);
                                ClassMatch = TRUE;
                                break;
                            }

                            ClassTablePointer++;
                        }
                    }

                    if (!ClassMatch) {

                        char * asterisk;

                        //
                        // Still not found in class table. Use the class as the
                        // directory
                        //

                        if ( fVerbose ) {
                            fprintf(stderr,"BINPLACE : warning BNP0000: Class %s Not found in Class Tables\n",PlaceFileClassPart);
                        }
                        if ( asterisk = strchr( PlaceFileClassPart, '*')) {
                            //
                            // Expand * to platform
                            //
                            LPTSTR platform;
                            ULONG PlatformSize;
                            LPTSTR PlatformPath;

#if   defined(_AMD64_)
                            PlatformSize = 5;
                            PlatformPath = TEXT("amd64");
#elif defined(_IA64_)
                            PlatformSize = 4;
                            PlatformPath = TEXT("ia64");
#else // defined(_X86_)
                            PlatformSize = 4;
                            PlatformPath = TEXT("i386");
                            if ((platform = getenv("IA64")) != NULL) {
                                PlatformPath = TEXT("ia64");
                            } else if ((platform = getenv("AMD64")) != NULL) {
                                PlatformSize = 5;
                                PlatformPath = TEXT("amd64");
                            }
#endif

                            strncpy(PlaceFileDir,PlaceFileClassPart, (int)(asterisk - PlaceFileClassPart));
                            strcpy(PlaceFileDir + (asterisk - PlaceFileClassPart), PlatformPath);
                            strcpy(PlaceFileDir + (asterisk - PlaceFileClassPart) + PlatformSize, asterisk + 1);

                        } else {
                            strcpy(PlaceFileDir,PlaceFileClassPart);
                        }
                    }

                    if (SetupFilePath[0] == '\0') {
                        lstrcpy(SetupFilePath, PlaceFileDir);
                        lstrcat(SetupFilePath, "\\");
                        lstrcat(SetupFilePath, FilePart);
                    }

                    if (NormalPlaceSubdir) {
                        strcat(PlaceFileDir,"\\");
                        strcat(PlaceFileDir,NormalPlaceSubdir);
                    }

                    fCopyResult = CopyTheFile(FullFileName,FilePart,PlaceFileDir,PlaceFileNewName);
                    if (!fCopyResult) {
                        break;
                    }
                }

                return(fCopyResult);
            }
        }
    }

    if (fMakeErrorOnDumpCopy) {
        fprintf(stderr, "BINPLACE : error BNP0000: File '%s' is not listed in '%s'. Copying to dump.\n", FullFileName, PlaceFileName);
    }

    return CopyTheFile(
               FullFileName,
               FilePart,
               PutInDebug ? "Symbols" : (PutInLcDir ? BinplaceLcDir : (DumpOverride ? DumpOverride : DEFAULT_DUMP)),
               NULL
               );

}

BOOL
CopyTheFile(
           LPSTR SourceFileName,
           LPSTR SourceFilePart,
           LPSTR DestinationSubdir,
           LPSTR DestinationFilePart
           )
{
    CHAR DestinationFile[MAX_PATH+1];
    CHAR TmpDestinationFile[MAX_PATH];
    CHAR TmpDestinationDir[MAX_PATH];
    CHAR DestinationLcFile[MAX_PATH+1];
    char Drive[_MAX_DRIVE];
    char Dir[_MAX_DIR];
    char Ext[_MAX_EXT];
    char Name[_MAX_FNAME];
    char TmpName[_MAX_FNAME];
    char TmpPath[_MAX_PATH];
    char FileSystemType[8];
    char DriveRoot[4];
    CHAR *TmpSymbolFilePath;
    CHAR *pFile;
    DWORD dwFileSystemFlags;
    DWORD dwMaxCompLength;
    CHAR ErrMsg[MAX_SYM_ERR];
    BOOL fBinplaceLc;

    if ( !PlaceRootName ) {
        fprintf(stderr,"BINPLACE : warning BNP0000: PlaceRoot is not specified\n");
        return FALSE;
    }

    if (fCheckDelayload && !_stricmp(SourceFilePart, gDelayLoadModule))
    {
        strcpy(TmpDestinationFile, PlaceRootName);
        strcat(TmpDestinationFile, "\\");
        strcat(TmpDestinationFile, DEFAULT_DELAYLOADDIR);
        strcat(TmpDestinationFile, "\\");
        strcat(TmpDestinationFile, SourceFilePart);
        strcat(TmpDestinationFile, ".ini");

        if (!MakeSureDirectoryPathExists(TmpDestinationFile))
        {
            fprintf(stderr, "BINPLACE : error BNP0000: Unable to create directory path '%s' (%u)\n", TmpDestinationFile, GetLastError());
        }
        else
        {
            WritePrivateProfileString("Default", "DelayLoadHandler", gDelayLoadHandler, TmpDestinationFile);

            strcpy(TmpDestinationDir,".\\"); //default to "retail"
     
            if ((*DestinationSubdir != '.') && (*(DestinationSubdir+1) != '\0'))
            {
                strcpy(TmpDestinationDir,DestinationSubdir);
                strcat(TmpDestinationDir,"\\");
            }
            WritePrivateProfileString("Default", "DestinationDir", TmpDestinationDir, TmpDestinationFile);
        }
    }   

    //
    // We also neuter SourceIsNewer on FAT partitions since they have a 2 second
    // file time granularity
    //
    _splitpath(SourceFileName, DriveRoot, Dir, NULL, NULL);
    lstrcat(DriveRoot, "\\");
    GetVolumeInformation(DriveRoot, NULL, 0, NULL, &dwMaxCompLength, &dwFileSystemFlags, FileSystemType, 7);
    if (lstrcmpi(FileSystemType, "FAT") == 0 || lstrcmpi(FileSystemType, "FAT32") == 0)
        fPatheticOS = TRUE;

    strcpy(DestinationFile,PlaceRootName);
    strcat(DestinationFile,"\\");
    strcat(DestinationFile,DestinationSubdir);
    strcat(DestinationFile,"\\");

    strcpy (TmpDestinationDir, DestinationFile);


    if (!MakeSureDirectoryPathExists(DestinationFile)) {
        fprintf(stderr, "BINPLACE : error BNP0000: Unable to create directory path '%s' (%u)\n",
                DestinationFile, GetLastError()
               );
    }

    if (DestinationFilePart) {
        strcat(DestinationFile,DestinationFilePart);
    } else {
        strcat(DestinationFile,SourceFilePart);
    }

    GetFullPathName(DestinationFile, MAX_PATH+1, gFullDestName, &pFile);

    if (!fSetupMode && (fVerbose || fTestMode)) {
        fprintf(stdout,"BINPLACE : warning BNP0000: place %s in %s\n",SourceFileName,DestinationFile);
    }

    if (!fSetupMode) {
        ULONG SymbolFlag = IGNORE_IF_SPLIT;
        BOOL fRetail = (*DestinationSubdir == '.') && (*(DestinationSubdir+1) == '\0');
        if (SourceIsNewer(SourceFileName,DestinationFile)) {
            fprintf(stdout, "binplace %s\n", SourceFileName);
            if (!VerifyFinalImage(SourceFileName, fRetail, &fBinplaceLc))
                return FALSE;

            // Verify Symbols
            if (fRetail && fSymChecking && !fSignCode) {
                _splitpath(SourceFileName,Drive, Dir, Name, Ext );
                strcpy(TmpName,Name);
                strcat(TmpName,Ext);
                strcpy(TmpPath,Drive);
                strcat(TmpPath,Dir);

                if ( fDbgControl ) {
                    SymbolFlag=ERROR_IF_SPLIT | ERROR_IF_NOT_SPLIT;
                } 
                if (!CheckSymbols(ErrMsg, TmpPath,SourceFileName, NULL,
                                  SymbolFlag,FALSE,
                                  (LPTSTR) szRSDSDllToLoad ) ) {
                    if ( !InExcludeList(TmpName,ExcludeList) ) {
                        fprintf(stderr,"BINPLACE : error BNP0000: %s",ErrMsg);
                        return FALSE;
                    }
                }
            }
        }
    }

    if (!fTestMode) {
        //
        // In Setup mode, copy the file only if it's newer than
        // the one that's already there.
        //
        if (!fSetupModeScriptFile) {
            if (SourceIsNewer(SourceFileName,DestinationFile)) {
                if (fVerbose) {
                    fprintf(stdout,"BINPLACE : warning BNP0000: copy %s to %s\n",SourceFileName,DestinationFile);
                }
            } else {
                return(TRUE);
            }
        }

        SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);

        if (fSetupModeScriptFile) {
            fprintf( CommandScriptFile, "%s %s\n", DestinationFile, SetupFilePath );
        }

        if (!fIgnoreHardLinks && fHardLinks) {
            if ((*pCreateHardLinkA)(SourceFileName, DestinationFile, NULL)) {
                if (!fKeepAttributes)
                    SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);
                return(TRUE);
            }
        }

        if ( !CopyFile(SourceFileName,DestinationFile, FALSE)) {
            fprintf(stderr,"BINPLACE : warning BNP0000: CopyFile(%s,%s) failed %d\n",SourceFileName,DestinationFile,GetLastError());

            if (!fLiveSystem) {
                return FALSE;
            }

            //  If CopyFile failed and we are instructed to do this over a live
            //  system, attempt to do a safe copy

            if (GetTempFileName (TmpDestinationDir, "bin", 0, TmpDestinationFile) == 0) {
                fprintf (stderr, "BINPLACE : error BNP0000: GetTempFileName (%s, %s) failed - %d\n",
                         DestinationSubdir, TmpDestinationFile, GetLastError ());
                return FALSE;
            }

            if (fVerbose) {
                fprintf (stdout, "BINPLACE : warning BNP0000: temp file name is %s\n", TmpDestinationFile);
            }

            //  rename target file to temp file
            if (!MoveFileEx (DestinationFile, TmpDestinationFile, MOVEFILE_REPLACE_EXISTING)) {
                //  Move failed, get rid of temp file
                ULONG error = GetLastError ();
                if (fVerbose) {
                    fprintf (stdout, "BINPLACE : error BNP0000: MoveFileEx (%s, %s) failed %d",
                             DestinationFile, TmpDestinationFile, error);
                }
                DeleteFile (TmpDestinationFile);
                SetLastError (error);
                return FALSE;
            }

            //  copy again
            if (!CopyFile (SourceFileName, DestinationFile, TRUE)) {
                //  Copy failed.  Delete the destination (perhaps due to out of space
                //  and replace original destination)
                ULONG error = GetLastError ();
                if (fVerbose) {
                    fprintf (stdout, "BINPLACE : error BNP0000: CopyFile (%s, %s) failed %d",
                             SourceFileName, DestinationFile, error);
                }
                DeleteFile (DestinationFile);
                MoveFile (TmpDestinationFile, DestinationFile);
                SetLastError (error);
                return FALSE;
            }

            //  mark temp for delete
            if (!MoveFileEx (TmpDestinationFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
                //  Could not make old file for deletion.  Delete destination
                //  and replace original destination)
                ULONG error = GetLastError ();
                if (fVerbose) {
                    fprintf (stdout, "BINPLACE : error BNP0000: MoveFileEx (%s, NULL) failed %d",
                             TmpDestinationFile, error);
                }
                DeleteFile (DestinationFile);
                MoveFile (TmpDestinationFile, DestinationFile);
                return FALSE;
            }
        }
        if (fSetupMode && !fSetupModeScriptFile) {
            fprintf(stdout,"%s ==> %s\n",SourceFileName,DestinationFile);
        }

        if (!fKeepAttributes)
            SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);

        if (!fNoClassInSymbolsDir) {
            strcpy(TmpDestinationDir, SymbolFilePath);
            if ((DestinationSubdir[0] == '.') && (DestinationSubdir[1] == '\0')) {
                strcat(TmpDestinationDir, "\\retail");
            } else {
                char * pSubdir;
                char * pTmp;
                strcat(TmpDestinationDir, "\\");

                pSubdir = DestinationSubdir;
                if (pSubdir[0] == '.' && pSubdir[1] == '\\')
                {
                    pSubdir += 2;
                }
                //
                // Put the root dir only on the path
                // Optionally change asms to retail.
                //
                pTmp = strchr(pSubdir, '\\');
                if (pTmp) {
                    const static char asms[] = "asms\\";
                    if (fChangeAsmsToRetailForSymbols
                        && _strnicmp(pSubdir, asms, sizeof(asms) - 1) ==0) {
                        //
                        strcpy(TmpDestinationFile, "retail");
                        strcat(TmpDestinationDir, TmpDestinationFile);
                    } else {
                        strcpy(TmpDestinationFile, pSubdir);
                        TmpDestinationFile[pTmp - pSubdir] = '\0';
                        strcat(TmpDestinationDir, TmpDestinationFile);
                    }
                } else {
                    strcat(TmpDestinationDir, pSubdir);
                }
            }
            TmpSymbolFilePath = TmpDestinationDir;
        } else {
            TmpSymbolFilePath = SymbolFilePath;
        }

        if (fSplitSymbols && !fUpDriver) {
            _splitpath(SourceFileName, Drive, Dir, NULL, Ext);
            _makepath(DebugFilePath, Drive, Dir, NULL, NULL);
            SplitFlags |= SPLITSYM_SYMBOLPATH_IS_SRC;
            if (SplitSymbolsX( DestinationFile, TmpSymbolFilePath, (PCHAR) DebugFilePath, 
                               SplitFlags, szRSDSDllToLoad, gPublicSymbol, MAX_PATH )) {
                if (fVerbose)
                    fprintf( stdout, "BINPLACE : warning BNP0000: Symbols stripped from %s into %s\n", DestinationFile, DebugFilePath );
            } else {
                if (fVerbose)
                    fprintf( stdout, "BINPLACE : warning BNP0000: No symbols to strip from %s\n", DestinationFile );
                strcpy(DebugFilePath, TmpSymbolFilePath);
                strcat(DebugFilePath, "\\");
                strcat(DebugFilePath, &Ext[1]);
                strcat(DebugFilePath, "\\");
                BinplaceCopyPdb(DebugFilePath, SourceFileName, TRUE, SplitFlags & SPLITSYM_REMOVE_PRIVATE, gPublicSymbol, MAX_PATH);
            }

            if ((SplitFlags & SPLITSYM_REMOVE_PRIVATE) && (PrivateSymbolFilePath != NULL)) {
                CHAR Dir1[_MAX_PATH];
                CHAR Dir2[_MAX_PATH];
                _splitpath(DebugFilePath, Drive, Dir, NULL, NULL);
                _makepath(Dir1, Drive, Dir, NULL, NULL);
                strcpy(Dir2, PrivateSymbolFilePath);
                strcat(Dir2, Dir1+strlen(SymbolFilePath));
                MakeSureDirectoryPathExists(Dir2);
                BinplaceCopyPdb(Dir2, SourceFileName, TRUE, FALSE, gPrivateSymbol, MAX_PATH);
            }

        } else {
            BinplaceCopyPdb(DestinationFile, SourceFileName, FALSE, (fSplitSymbols ? (SplitFlags & SPLITSYM_REMOVE_PRIVATE) : FALSE), gPublicSymbol, MAX_PATH);
        }

        StripCVSymbolPath(DestinationFile);

        if (fPlaceWin95SymFile) {
            char DestSymPath[_MAX_PATH];
            char DestSymDir[_MAX_PATH];
            char SrcSymPath[_MAX_PATH];

            _splitpath(CurrentImageName, Drive, Dir, Name, Ext);
            _makepath(SrcSymPath, Drive, Dir, Name, ".sym");

            if (!_access(SrcSymPath, 0)) {
                if (fSplitSymbols) {
                    strcpy(DestSymPath, TmpSymbolFilePath);
                    strcat(DestSymPath, "\\");
                    strcat(DestSymPath, Ext[0] == '.' ? &Ext[1] : Ext);
                    strcat(DestSymPath, "\\");
                    strcat(DestSymPath, Name);
                    strcat(DestSymPath, ".sym");
                } else {
                    _splitpath(DestinationFile, Drive, Dir, NULL, NULL);
                    _makepath(DestSymPath, Drive, Dir, Name, ".sym");
                }

                SetFileAttributes(DestSymPath, FILE_ATTRIBUTE_NORMAL);

                if (SourceIsNewer(SrcSymPath, SourceFileName)) {
                    // Only binplace the .sym file if it was built AFTER the image itself.

                    // Make sure to create the destination path in case it is not there already.
                    strcpy(DestSymDir, TmpSymbolFilePath);
                    strcat(DestSymDir, "\\");
                    strcat(DestSymDir, Ext[0] == '.' ? &Ext[1] : Ext);
                    strcat(DestSymDir, "\\");
                    MakeSureDirectoryPathExists(DestSymDir);

                    if (!CopyFile(SrcSymPath, DestSymPath, FALSE)) {
                        fprintf(stderr,"BINPLACE : warning BNP0000: CopyFile(%s,%s) failed %d\n", SrcSymPath, DestSymPath ,GetLastError());
                    }
                }

                if (!fKeepAttributes)
                    SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);
            } else {
                if (fVerbose) {
                    fprintf( stdout, "BINPLACE : warning BNP0000: Unable to locate \"%s\" for \"%s\"\n", SrcSymPath, CurrentImageName );
                }
            }

        }

        if (fDigitalSign) {
            SignWithIDWKey( DestinationFile );
        }

        if (!fSetupMode && fBinplaceLc) {
            strcpy(DestinationLcFile,PlaceRootName);
            strcat(DestinationLcFile,"\\");
            strcat(DestinationLcFile,BinplaceLcDir);
            strcat(DestinationLcFile,"\\");
            strcat(DestinationLcFile,DestinationSubdir);
            strcat(DestinationLcFile,"\\");

            if (!MakeSureDirectoryPathExists(DestinationLcFile)) {
                fprintf(stderr, "BINPLACE : error BNP0000: Unable to create directory path '%s' (%u)\n",
                        DestinationLcFile, GetLastError()
                       );
            }

            strcat(DestinationLcFile, LcFilePart);

            if (!CopyFile(LcFullFileName, DestinationLcFile, FALSE)) {
               fprintf(stderr,"BINPLACE : warning BNP0000: CopyFile(%s,%s) failed %d\n",
                       LcFullFileName,DestinationLcFile,GetLastError());
            }
        }

    } else {
        if (fSetupMode) {
            if (SourceIsNewer(SourceFileName,DestinationFile)) {
                if (fVerbose) {
                    fprintf(stdout,"BINPLACE : warning BNP0000: copy %s to %s\n",SourceFileName,DestinationFile);
                }
            } else {
                return(TRUE);
            }
        }

        if ( fSetupMode ) {
            fprintf(stdout,"%s ==> %s\n",SourceFileName,DestinationFile);
        }
    }

    return TRUE;
}


BOOL VerifyLc(
             PCHAR FileName,
             BOOL  fRetail
             )
{
    HRESULT hr = (*pVerifyLocConstraintA)(FileName, LcFullFileName);

    if (FAILED(hr)) {
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MATCH)) {
            fprintf(stderr,
                "BINPLACE : %s BNP0000: resource conflicts with localization constraint \"%s\"\n",
                fRetail ? "error" : "warning",
                FileName);
        }
        else {
            fprintf(stderr,
                "BINPLACE : %s BNP0000: VerifyLc %s failed 0x%lX\n",
                fRetail ? "error" : "warning", FileName, hr);
        }
        return FALSE;
    }

    return TRUE;
}


typedef DWORD (WINAPI *PFNGVS)(LPSTR, LPDWORD);

BOOL
VerifyFinalImage(
                IN  PCHAR FileName,
                IN  BOOL  fRetail,
                OUT PBOOL BinplaceLc
                )
{


    HINSTANCE hVersion;
    PFNGVS pfnGetFileVersionInfoSize;
    DWORD dwSize;
    DWORD dwReturn;
    BOOL  fRC = TRUE, rc=TRUE, tlb=FALSE;
    LOADED_IMAGE LoadedImage;
    OSVERSIONINFO VersionInfo;

    LoadedImage.hFile = INVALID_HANDLE_VALUE;

    *BinplaceLc = FALSE;

    if (fVerifyLc) {
        if (!VerifyLc(FileName, fRetail)) {
            fRC = fRetail ? FALSE : TRUE;
            goto End1;
        }
        *BinplaceLc = TRUE;
    }

    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx ( &VersionInfo );
    if ( VersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT )
        return( TRUE );     // Not NT - can't load Win64 binaries
    if ( VersionInfo.dwMajorVersion < 5  )
        return ( TRUE );    // Prior to Win2K - can't load Win64 binaries

    rc = MapAndLoad(FileName, NULL, &LoadedImage, FALSE, TRUE);

    if (!rc) {
        // Not a binary.  See if it's one of the other types we care about (like typelibs)

        CHAR szExt[_MAX_EXT];

        _splitpath(FileName, NULL, NULL, NULL, szExt);

        // The only non-binary images that need version resources are .tlb's

        if (_stricmp(szExt, ".tlb")) {
            return(TRUE);
        }

        tlb=TRUE;
    }

    hVersion = LoadLibraryA("VERSION.DLL");
    if (hVersion == NULL) {
        goto End1;
    }

    pfnGetFileVersionInfoSize = (PFNGVS) GetProcAddress(hVersion, "GetFileVersionInfoSizeA");
    if (pfnGetFileVersionInfoSize == NULL) {
        goto End2;
    }

    if ((dwReturn = pfnGetFileVersionInfoSize(FileName, &dwSize)) == 0) {

        if ( !tlb && (LoadedImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) &&
             (LoadedImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64) &&
             (LoadedImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_IA64) ) {
             goto End2;
        }

        if (fRetail) {
            fprintf(stderr,
                "BINPLACE : %s BNP0000: no version resource detected for \"%s\"\n",
                "error",
                FileName);
            fRC = FALSE;
        } else {
            fRC = TRUE;
        }
    }

End2:
    FreeLibrary(hVersion);
End1:

    if (ImageCheck.Argv != NULL &&
        (LoadedImage.hFile != INVALID_HANDLE_VALUE ||
        MapAndLoad(FileName, NULL, &LoadedImage, FALSE, TRUE) == TRUE)) {
        if ((LoadedImage.FileHeader->FileHeader.Machine == ImageCheck.Machine)) {
             int RC;

             ImageCheck.Argv[ImageCheck.Argc-2] = FileName;
             RC = (int)_spawnvp(P_WAIT, ImageCheck.Argv[0], (const char * const *) ImageCheck.Argv);
             if (RC == -1 || RC == 128) {
                 fprintf(stderr,
                 "BINPLACE : error BNP0000: Cannot execute (%s). Make sure it (or it's DLL's) exists or verify binplace /CI option.\n", ImageCheck.Argv[0]);
                 fRC = FALSE;
             } else if (RC == 1) {
                 fprintf(stderr,
                 "BINPLACE : error BNP0000: ImageCheck (%s) failed.\n", ImageCheck.Argv[0]);
                 fRC = FALSE;
             } else if (RC == ImageCheck.RC) {
                 fprintf(stderr,
                 "BINPLACE : error BNP0000: Image checker (%s) detected errors in %s.\n", ImageCheck.Argv[0], FileName);
                 fRC = FALSE;
             }
        }
    }

    if (LoadedImage.hFile != INVALID_HANDLE_VALUE)
        UnMapAndLoad(&LoadedImage);

    return fRC;
}


BOOL
SourceIsNewer(
             IN LPSTR SourceFile,
             IN LPSTR TargetFile
             )
{
    BOOL Newer;
    WIN32_FIND_DATA TargetInfo;
    WIN32_FIND_DATA SourceInfo;

    //
    // If force placement (-f option) was specified, just return TRUE
    // If the target file doesn't exist, then the source is newer.
    // If the source file doesn't exist, just return TRUE and hope
    // the caller will catch it.
    if ((fForcePlace == FALSE) && (FileExists(TargetFile,&TargetInfo) && FileExists(SourceFile,&SourceInfo))) {

        Newer = (fLiveSystem || !fPatheticOS)
                ? (CompareFileTime(&SourceInfo.ftLastWriteTime,&TargetInfo.ftLastWriteTime) > 0)
                : (CompareFileTime(&SourceInfo.ftLastWriteTime,&TargetInfo.ftLastWriteTime) >= 0);

    } else {

        Newer = TRUE;
    }

    return(Newer);
}


BOOL
SetupModeRetailFile(
                   IN  LPSTR FullFileName,
                   IN  LPSTR FileNamePart,
                   OUT PBOOL PutInDump
                   )
{
    BOOL FoundInTree;
    INFCONTEXT InfContext;
    DWORD DontCare;
    INT IntVal;
    CHAR DirSpec[24];
    CHAR Directory[MAX_PATH];
    CHAR Rename[MAX_PATH];
    LPSTR p;

    //
    // Find and update all instances of the file in the target tree.
    //
    *PutInDump = FALSE;
    FoundInTree = FALSE;
    if (!SearchOneDirectory(PlaceRootName,FileNamePart,FullFileName,FileNamePart,&FoundInTree)) {
        return(FALSE);
    }

    if (!FoundInTree) {
        //
        // OK, now things get tricky. Load master layout inf if
        // not already loaded.
        //
        if (!LayoutInf) {
            if (LayoutInfName) {
                //
                // Use GetFullPathName(). Otherwise a name without a dir spec
                // will be assumed to be in %sysroot%\inf, which is probably not
                // what people would expect.
                //
                GetFullPathName(LayoutInfName,MAX_PATH,Directory,&p);
                LayoutInf = (*pSetupOpenInfFileA)(Directory,NULL,INF_STYLE_WIN4,NULL);
            } else {
                LayoutInf = (*pSetupOpenMasterInf)();
            }
            if (LayoutInf == INVALID_HANDLE_VALUE) {

                LayoutInf = NULL;

                fprintf(
                       stderr,
                       "BINPLACE : error BNP0000: Unable to load %s\n",
                       LayoutInfName ? LayoutInfName : "%%sysroot%%\\inf\\layout.inf"
                       );

                return(FALSE);
            }
        }

        //
        // Look up the file in the master inf.
        //
        if (!(*pSetupFindFirstLineA)(LayoutInf,szSourceDisksFiles,FileNamePart,&InfContext)) {

            LPTSTR platform;
            LPCTSTR szSourceDisksFPlat;

#if   defined(_AMD64_)

            szSourceDisksFPlat = &szSourceDisksAMD64[0];

#elif defined(_IA64_)

            szSourceDisksFPlat = &szSourceDisksIA64[0];

#else // defined(_X86_)

            szSourceDisksFPlat = &szSourceDisksX86[0];
            if ((platform = getenv("AMD64")) != NULL) {
                szSourceDisksFPlat = &szSourceDisksAMD64[0];
            } else if ((platform = getenv("IA64")) != NULL) {
                szSourceDisksFPlat = &szSourceDisksIA64[0];
            }
#endif

            if (!(*pSetupFindFirstLineA)(LayoutInf,szSourceDisksFPlat,FileNamePart,&InfContext)) {

                if ( fVerbose ) {
                    fprintf(stderr,"BINPLACE : warning BNP0000: warning: unknown retail file %s\n",FileNamePart);
                }
                *PutInDump = TRUE;
                return(TRUE);
            }
        }

        //
        // See if the file gets renamed in the target tree.
        // If so, try to find the renamed version in the target.
        //
        if ((*pSetupGetStringFieldA)(&InfContext,11,Rename,MAX_PATH,&DontCare)
            && lstrcmpi(Rename,FileNamePart)) {
            FoundInTree = FALSE;
            if (!SearchOneDirectory(PlaceRootName,Rename,FullFileName,FileNamePart,&FoundInTree)) {
                return(FALSE);
            }

            //
            // If we found the renamed file in the target tree, we're done.
            //
            if (FoundInTree) {
                return(TRUE);
            }
        } else {
            //
            // Assume name in target is same as name in source.
            //
            strcpy(Rename,FileNamePart);
        }

        //
        // We couldn't find the file in the target tree.
        // The file might be new. Check the copy disposition for
        // non-upgrades -- if the file is marked "copy always" then we want
        // to copy it. Otherwise ignore the file. This way someone who
        // uses this tool to 'upgrade' a build doesn't get a pile of files
        // they don't need placed into their nt tree.
        //
        // This behavior is overrideable by using -!! instead of -!.
        //
        if (!fSetupModeAllFiles && (!(*pSetupGetIntField)(&InfContext,10,&IntVal) || IntVal)) {
            //
            // File is not marked "copy always" so ignore it, assuming it's
            // configuration-specific and the user doesn't need it.
            //
            return(TRUE);
        }

        //
        // File needs to be copied into the target tree.
        // Get the directory spec.
        //
        DirSpec[0] = 0;
        (*pSetupGetStringFieldA)(&InfContext,8,DirSpec,sizeof(DirSpec),&DontCare);

        if (!(*pSetupFindFirstLineA)(LayoutInf,"WinntDirectories",DirSpec,&InfContext)
            || !(*pSetupGetStringFieldA)(&InfContext,1,Directory,MAX_PATH,&DontCare)) {
            if (strlen(DirSpec)) {
                fprintf(stderr,"BINPLACE : error BNP0000: unknown directory spec %s in layout.inf for file %s\n",DirSpec,FileNamePart);
                return(FALSE);
            } else {
                return(TRUE);
            }
        }

        //
        // If the spec begins with a slash, then for root dir, replace with .
        // otherwise, skip over leading slash in the non-root case.
        //
        if ((Directory[0] == '\\')) {
            if (!Directory[1]) {
                Directory[0] = '.';
            } else {
                lstrcpy(Directory, Directory+1);
            }
        }

        if (fSetupModeScriptFile) {
            lstrcpy(SetupFilePath, Directory);
            lstrcat(SetupFilePath, "\\");
            lstrcat(SetupFilePath, Rename);
            return FALSE;
        }

        //
        // Got what we need -- copy the file.
        //
        return CopyTheFile(
                          FullFileName,
                          FileNamePart,
                          Directory,
                          Rename
                          );
    }

    return(TRUE);
}


BOOL
BinplaceCopyPdb (
                LPSTR DestinationFile,
                LPSTR SourceFileName,
                BOOL CopyFromSourceOnly,
                BOOL StripPrivate,
                LPSTR DestinationSymbol,
                DWORD LenDestSymbolBuffer
                )
{
    LOADED_IMAGE LoadedImage;
    DWORD DirCnt;
    IMAGE_DEBUG_DIRECTORY UNALIGNED *DebugDirs, *CvDebugDir;

    if (MapAndLoad(
                   CopyFromSourceOnly ? SourceFileName : DestinationFile,
                   NULL,
                   &LoadedImage,
                   FALSE,
                   CopyFromSourceOnly ? TRUE : FALSE) == FALSE) {
        return (FALSE);
    }

    DebugDirs = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData(
                                                                  LoadedImage.MappedAddress,
                                                                  FALSE,
                                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                                  &DirCnt
                                                                  );

    if (!DebugDirectoryIsUseful(DebugDirs, DirCnt)) {
        UnMapAndLoad(&LoadedImage);
        return(FALSE);
    }

    DirCnt /= sizeof(IMAGE_DEBUG_DIRECTORY);
    CvDebugDir = NULL;

    while (DirCnt) {
        DirCnt--;
        if (DebugDirs[DirCnt].Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
            CvDebugDir = &DebugDirs[DirCnt];
            break;
        }
    }

    if (!CvDebugDir) {
        // Didn't find any CV debug dir.  Bail.
        UnMapAndLoad(&LoadedImage);
        return(FALSE);
    }

    if (CvDebugDir->PointerToRawData != 0) {

        PCVDD pDebugDir;
        ULONG mysize;

        pDebugDir = (PCVDD) (CvDebugDir->PointerToRawData + (PCHAR)LoadedImage.MappedAddress);

        if (pDebugDir->dwSig == '01BN' ) {
            mysize=sizeof(NB10IH);
        } else {
            mysize=sizeof(RSDSIH);
        }        

        if (pDebugDir->dwSig == '01BN' || pDebugDir->dwSig == 'SDSR' ) {
            // Got a PDB.  The name immediately follows the signature.
            LPSTR szMyDllToLoad;
            CHAR PdbName[sizeof(((PRSDSI)(0))->szPdb)];
            CHAR NewPdbName[sizeof(((PRSDSI)(0))->szPdb)];
            CHAR Drive[_MAX_DRIVE];
            CHAR Dir[_MAX_DIR];
            CHAR Filename[_MAX_FNAME];
            CHAR FileExt[_MAX_EXT];

            if (pDebugDir->dwSig == '01BN') {
                szMyDllToLoad=NULL;
            } else {
                szMyDllToLoad=szRSDSDllToLoad;
            }

            ZeroMemory(PdbName, sizeof(PdbName));
            memcpy(PdbName, ((PCHAR)pDebugDir) + mysize, __min(CvDebugDir->SizeOfData - mysize, sizeof(PdbName)));

            _splitpath(PdbName, NULL, NULL, Filename, FileExt);
            _splitpath(DestinationFile, Drive, Dir, NULL, NULL);
            _makepath(NewPdbName, Drive, Dir, Filename, FileExt);

            if (!fSetupMode && (fVerbose || fTestMode)) {
                fprintf(stdout,"BINPLACE : warning BNP0000: place %s in %s\n", PdbName, NewPdbName);
            }

            if (!MakeSureDirectoryPathExists(NewPdbName)) {
                fprintf(stderr, "BINPLACE : error BNP0000: Unable to create directory path '%s' (%u)\n",
                        NewPdbName, GetLastError());
            }

            SetFileAttributes(NewPdbName,FILE_ATTRIBUTE_NORMAL);

            if (DestinationSymbol)
            {
                strncpy(DestinationSymbol, NewPdbName, LenDestSymbolBuffer);
                DestinationSymbol[LenDestSymbolBuffer-1] = '\0'; // ensure termination
            }
            if ( !CopyPdbX(PdbName, NewPdbName, StripPrivate, szMyDllToLoad)) {
                if (!fSetupMode && (fVerbose || fTestMode)) {
                    fprintf(stderr,"BINPLACE : warning BNP0000: Unable to copy (%s,%s) %d\n", PdbName, NewPdbName, GetLastError());
                }
                // It's possible the name in the pdb isn't in the same location as it was when built.  See if we can
                //  find it in the same dir as the image...
                _splitpath(SourceFileName, Drive, Dir, NULL, NULL);
                _makepath(PdbName, Drive, Dir, Filename, FileExt);
                if (!fSetupMode && (fVerbose || fTestMode)) {
                    fprintf(stdout,"BINPLACE : warning BNP0000: place %s in %s\n", PdbName, NewPdbName);
                }

                if ( !CopyPdbX(PdbName, NewPdbName, StripPrivate, szMyDllToLoad)) {
                    // fprintf(stderr,"BINPLACE : warning BNP0000: CopyPdb(%s,%s) failed %d\n", PdbName, NewPdbName, GetLastError());
                }
            }

            if (!fKeepAttributes)
                SetFileAttributes(NewPdbName, FILE_ATTRIBUTE_NORMAL);
            
            if (fWppFmt && !StripPrivate) {
                // We want to do the trace format pass on the target PDB, but there is no point in doing
                // that if it is stripped.
                if (strcmp(PdbName,LastPdbName) != 0) { // Have we just processed this PDB?
                    if (fVerbose) {
                        fprintf( stdout, "BINPLACE : warning BNP0000: Trace Formats being built from %s\n", NewPdbName );
                    }
                    if (TraceFormatFilePath[0] == '\0') {
                        if (PrivateSymbolFilePath != NULL) {
                            _snprintf(TraceFormatFilePath,MAX_PATH,"%s\\%s",PrivateSymbolFilePath,TraceDir);
                        } else {
                            strncpy(TraceFormatFilePath, TraceDir, MAX_PATH) ;
                        }
                        if (fVerbose) {
                            fprintf( stdout, "BINPLACE : warning BNP0000: Trace Formats file path set to %s\n", TraceFormatFilePath );
                        }
                    }
                    BinplaceWppFmt(NewPdbName,TraceFormatFilePath,szRSDSDllToLoad,fVerbose);
                    // because files are frequently copied to multiple places, the PDB is also placed 
                    // several times, there is no point in us processing it more than once.
                    strncpy(LastPdbName,PdbName,MAX_PATH);
                } else {
                    if (fVerbose) {
                        fprintf( stdout, "BINPLACE : warning BNP0000: Trace Formats skipping %s (same as last)\n", NewPdbName );
                    }
                }
            }
            if (fSrcControl && !StripPrivate) {
                CHAR CvdumpName[_MAX_PATH + _MAX_FNAME];
                UINT i;
                LONG pos;
                CHAR buf[_MAX_PATH*3];

                // Find the start of "symbols.pri" in NewPdbName
                pos=-1;
                i=0;
                while ( (i < strlen(NewPdbName) - strlen("symbols.pri"))  && pos== -1) {
                    if (_strnicmp( NewPdbName+i, "symbols.pri", strlen("symbols.pri") ) == 0 ) {
                        pos=i;
                    } else {
                        i++;
                    }
                }
            
                if ( pos >= 0 ) { 
                    strcpy(CvdumpName, NewPdbName);
                    CvdumpName[i]='\0';
                    strcat(CvdumpName, "cvdump.pri" ); 
                    strcat(CvdumpName, NewPdbName + pos + strlen("symbols.pri") );
                    strcat(CvdumpName, ".dmp");

                    // Get the Directory name and create it
                    if ( MakeSureDirectoryPathExists(CvdumpName) ) {
                        sprintf(buf, "cvdump -l %s > %s", NewPdbName, CvdumpName);
                        system(buf);
                    } else {
                        fprintf( stdout, "BINPLACE : error BNP0000: Cannot create directory for the file %s\n", CvdumpName);
                    }
                }
            }

            if (!CopyFromSourceOnly) {
                PVOID pCertificates = ImageDirectoryEntryToData(LoadedImage.MappedAddress,
                                                      FALSE,
                                                      IMAGE_DIRECTORY_ENTRY_SECURITY,
                                                      &DirCnt
                                                      );

                if (!pCertificates && !DirCnt) {
                    // Only change the data in the image if it hasn't been signed (otherwise the sig is invalidated).
                    strcpy(((char *)pDebugDir) + mysize, Filename);
                    strcat(((char *)pDebugDir) + mysize, FileExt);
                    CvDebugDir->SizeOfData = mysize + strlen(Filename) + strlen(FileExt) + 1;
                }
            }
        }
        UnMapAndLoad(&LoadedImage);
        return(TRUE);
    }

    UnMapAndLoad(&LoadedImage);
    return(FALSE);
}


BOOL
FileExists(
          IN  LPCSTR FileName,
          OUT PWIN32_FIND_DATA FindData
          )
{
    UINT OldMode;
    BOOL Found;
    HANDLE FindHandle;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,FindData);
    if (FindHandle == INVALID_HANDLE_VALUE) {
        Found = FALSE;
    } else {
        FindClose(FindHandle);
        Found = TRUE;
    }

    SetErrorMode(OldMode);
    return(Found);
}


//////////////////////////////////////////////////////////////////////
//                                                                  //
//  Digital Signature Stuff                                         //
//                                                                  //
//////////////////////////////////////////////////////////////////////

LPBSAFE_PUB_KEY         PUB;
LPBSAFE_PRV_KEY         PRV;

unsigned char pubmodulus[] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x3d, 0x3a, 0x5e, 0xbd, 0x72, 0x43, 0x3e, 0xc9,
    0x4d, 0xbb, 0xc1, 0x1e, 0x4a, 0xba, 0x5f, 0xcb,
    0x3e, 0x88, 0x20, 0x87, 0xef, 0xf5, 0xc1, 0xe2,
    0xd7, 0xb7, 0x6b, 0x9a, 0xf2, 0x52, 0x45, 0x95,
    0xce, 0x63, 0x65, 0x6b, 0x58, 0x3a, 0xfe, 0xef,
    0x7c, 0xe7, 0xbf, 0xfe, 0x3d, 0xf6, 0x5c, 0x7d,
    0x6c, 0x5e, 0x06, 0x09, 0x1a, 0xf5, 0x61, 0xbb,
    0x20, 0x93, 0x09, 0x5f, 0x05, 0x6d, 0xea, 0x87,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char prvmodulus[] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x3d, 0x3a, 0x5e, 0xbd,
    0x72, 0x43, 0x3e, 0xc9, 0x4d, 0xbb, 0xc1, 0x1e,
    0x4a, 0xba, 0x5f, 0xcb, 0x3e, 0x88, 0x20, 0x87,
    0xef, 0xf5, 0xc1, 0xe2, 0xd7, 0xb7, 0x6b, 0x9a,
    0xf2, 0x52, 0x45, 0x95, 0xce, 0x63, 0x65, 0x6b,
    0x58, 0x3a, 0xfe, 0xef, 0x7c, 0xe7, 0xbf, 0xfe,
    0x3d, 0xf6, 0x5c, 0x7d, 0x6c, 0x5e, 0x06, 0x09,
    0x1a, 0xf5, 0x61, 0xbb, 0x20, 0x93, 0x09, 0x5f,
    0x05, 0x6d, 0xea, 0x87, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0xbd, 0x29, 0x20,
    0x57, 0xd2, 0x3b, 0xf1, 0x07, 0xfa, 0xdf, 0xc1,
    0x16, 0x31, 0xe4, 0x95, 0xea, 0xc1, 0x2a, 0x46,
    0x2b, 0xad, 0x88, 0x57, 0x55, 0xf0, 0x57, 0x58,
    0xc6, 0x6f, 0x95, 0xeb, 0x00, 0x00, 0x00, 0x00,
    0x83, 0xdd, 0x9d, 0xd0, 0x03, 0xb1, 0x5a, 0x9b,
    0x9e, 0xb4, 0x63, 0x02, 0x43, 0x3e, 0xdf, 0xb0,
    0x52, 0x83, 0x5f, 0x6a, 0x03, 0xe7, 0xd6, 0x78,
    0x45, 0x83, 0x6a, 0x5b, 0xc4, 0xcb, 0xb1, 0x93,
    0x00, 0x00, 0x00, 0x00, 0x65, 0x9d, 0x43, 0xe8,
    0x48, 0x17, 0xcd, 0x29, 0x7e, 0xb9, 0x26, 0x5c,
    0x79, 0x66, 0x58, 0x61, 0x72, 0x86, 0x6a, 0xa3,
    0x63, 0xad, 0x63, 0xb8, 0xe1, 0x80, 0x4c, 0x0f,
    0x36, 0x7d, 0xd9, 0xa6, 0x00, 0x00, 0x00, 0x00,
    0x75, 0x3f, 0xef, 0x5a, 0x01, 0x5f, 0xf6, 0x0e,
    0xd7, 0xcd, 0x59, 0x1c, 0xc6, 0xec, 0xde, 0xf3,
    0x5a, 0x03, 0x09, 0xff, 0xf5, 0x23, 0xcc, 0x90,
    0x27, 0x1d, 0xaa, 0x29, 0x60, 0xde, 0x05, 0x6e,
    0x00, 0x00, 0x00, 0x00, 0xc0, 0x17, 0x0e, 0x57,
    0xf8, 0x9e, 0xd9, 0x5c, 0xf5, 0xb9, 0x3a, 0xfc,
    0x0e, 0xe2, 0x33, 0x27, 0x59, 0x1d, 0xd0, 0x97,
    0x4a, 0xb1, 0xb1, 0x1f, 0xc3, 0x37, 0xd1, 0xd6,
    0xe6, 0x9b, 0x35, 0xab, 0x00, 0x00, 0x00, 0x00,
    0x87, 0xa7, 0x19, 0x32, 0xda, 0x11, 0x87, 0x55,
    0x58, 0x00, 0x16, 0x16, 0x25, 0x65, 0x68, 0xf8,
    0x24, 0x3e, 0xe6, 0xfa, 0xe9, 0x67, 0x49, 0x94,
    0xcf, 0x92, 0xcc, 0x33, 0x99, 0xe8, 0x08, 0x60,
    0x17, 0x9a, 0x12, 0x9f, 0x24, 0xdd, 0xb1, 0x24,
    0x99, 0xc7, 0x3a, 0xb8, 0x0a, 0x7b, 0x0d, 0xdd,
    0x35, 0x07, 0x79, 0x17, 0x0b, 0x51, 0x9b, 0xb3,
    0xc7, 0x10, 0x01, 0x13, 0xe7, 0x3f, 0xf3, 0x5f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00
};

BOOL initkey(void)
{
    DWORD       bits;

    PUB = (LPBSAFE_PUB_KEY)pubmodulus;

    PUB->magic = RSA1;
    PUB->keylen = 0x48;
    PUB->bitlen = 0x0200;
    PUB->datalen = 0x3f;
    PUB->pubexp = 0xc0887b5b;

    PRV = (LPBSAFE_PRV_KEY)prvmodulus;
    PRV->magic = RSA2;
    PRV->keylen = 0x48;
    PRV->bitlen = 0x0200;
    PRV->datalen = 0x3f;
    PRV->pubexp = 0xc0887b5b;

    bits = PRV->bitlen;

    return TRUE;
}


BOOL
SignWithIDWKey(
              IN  LPCSTR  FileName)
{

    HANDLE  hFile;
    HANDLE  hMapping;
    PUCHAR  pMap;
    HANDLE  hSigFile;
    DWORD   Size;
    MD5_CTX HashState;
    BYTE    SigHash[ 0x48 ];
    BYTE    Signature[ 0x48 ];
    CHAR    SigFilePath[ MAX_PATH ];
    PSTR    pszDot;

    BOOL    Return = FALSE;

    if (!initkey()) {
        return( FALSE );
    }

    hFile = CreateFile( FileName, GENERIC_READ,
                        FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, 0, NULL );

    if (hFile != INVALID_HANDLE_VALUE) {
        hMapping = CreateFileMapping(   hFile,
                                        NULL,
                                        PAGE_READONLY,
                                        0, 0, NULL );

        if (hMapping) {
            pMap = MapViewOfFileEx( hMapping,
                                    FILE_MAP_READ,
                                    0, 0, 0, NULL );

            if (pMap) {
                Size = GetFileSize( hFile, NULL );

                MD5Init( &HashState );

                MD5Update( &HashState, pMap, Size );

                MD5Final( &HashState );

                memset(SigHash, 0xff, 0x40);

                SigHash[0x40-1] = 0;
                SigHash[0x40-2] = 1;
                SigHash[16] = 0;

                memcpy(SigHash, HashState.digest, 16);

                //
                // Encrypt the signature data
                //

                BSafeDecPrivate(PRV, SigHash, Signature );;

                //
                // Create and store it in a .sig file
                //

                strcpy( SigFilePath, FileName );

                pszDot = strrchr( SigFilePath, '.' );

                if (!pszDot) {
                    pszDot = SigFilePath + strlen( SigFilePath );
                }

                strcpy( pszDot, ".sig");

                hSigFile = CreateFile( SigFilePath, GENERIC_WRITE,
                                       0, NULL,
                                       CREATE_ALWAYS, 0, NULL );

                if (hSigFile != INVALID_HANDLE_VALUE) {
                    WriteFile(  hSigFile,
                                Signature,
                                sizeof( Signature ),
                                &Size, NULL );

                    CloseHandle( hSigFile );

                    Return = TRUE ;

                    if (fVerbose)
                        fprintf( stdout, "BINPLACE : warning BNP0000: Signature file generated in %s\n", SigFilePath);

                } else {
                    fprintf( stderr, "BINPLACE : error BNP0000: Unable to create file %s, %d\n",
                             SigFilePath, GetLastError() );
                }

                UnmapViewOfFile( pMap );

            } else {
                fprintf(stderr, "BINPLACE : error BNP0000: unable to map view, %d\n", GetLastError());
            }

            CloseHandle( hMapping );

        } else {
            fprintf(stderr, "BINPLACE : error BNP0000: CreateFileMapping of %s failed, %d\n",
                    FileName, GetLastError() );

        }

        CloseHandle( hFile );
    } else {
        fprintf( stderr, "BINPLACE : error BNP0000: could not open %s, %d\n",
                 FileName, GetLastError() );
    }

    return( Return );
}

BOOL                            // Keep as BOOL for the future (used by rsa code)
GenRandom (ULONG huid, BYTE *pbBuffer, size_t dwLength)
{
    return( FALSE );
}


BOOL
StripCVSymbolPath (
                LPSTR DestinationFile
                )
{
    LOADED_IMAGE LoadedImage;
    DWORD DirCnt;
    IMAGE_DEBUG_DIRECTORY UNALIGNED *DebugDirs, *CvDebugDir;
    PVOID pCertificates;

    if (MapAndLoad(
                   DestinationFile,
                   NULL,
                   &LoadedImage,
                   FALSE,
                   FALSE) == FALSE) {
        return (FALSE);
    }

    DebugDirs = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData(
                                                                  LoadedImage.MappedAddress,
                                                                  FALSE,
                                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                                  &DirCnt
                                                                  );

    if (!DebugDirectoryIsUseful(DebugDirs, DirCnt)) {
        UnMapAndLoad(&LoadedImage);
        return(FALSE);
    }

    DirCnt /= sizeof(IMAGE_DEBUG_DIRECTORY);
    CvDebugDir = NULL;

    while (DirCnt) {
        DirCnt--;
        if (DebugDirs[DirCnt].Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
            CvDebugDir = &DebugDirs[DirCnt];
            break;
        }
    }

    if (!CvDebugDir) {
        // Didn't find any CV debug dir.  Bail.
        UnMapAndLoad(&LoadedImage);
        return(FALSE);
    }

    if (CvDebugDir->PointerToRawData != 0) {

        PCVDD pDebugDir;
        ULONG mysize;

        pDebugDir = (PCVDD) (CvDebugDir->PointerToRawData + (PCHAR)LoadedImage.MappedAddress);

        if (pDebugDir->dwSig == '01BN' ) {
            mysize=sizeof(NB10IH);
        } else {
            mysize=sizeof(RSDSIH);
        }        

        if (pDebugDir->dwSig == '01BN' || pDebugDir->dwSig == 'SDSR' ) {
            // Got a PDB.  The name immediately follows the signature.
            LPSTR szMyDllToLoad;
            CHAR PdbName[sizeof(((PRSDSI)(0))->szPdb)];
            CHAR Filename[_MAX_FNAME];
            CHAR FileExt[_MAX_EXT];

            if (pDebugDir->dwSig == '01BN') {
                szMyDllToLoad=NULL;
            } else {
                szMyDllToLoad=szRSDSDllToLoad;
            }

            ZeroMemory(PdbName, sizeof(PdbName));
            memcpy(PdbName, ((PCHAR)pDebugDir) + mysize, __min(CvDebugDir->SizeOfData - mysize, sizeof(PdbName)));

            _splitpath(PdbName, NULL, NULL, Filename, FileExt);

            pCertificates=NULL;
            pCertificates = ImageDirectoryEntryToData(LoadedImage.MappedAddress,
                                                      FALSE,
                                                      IMAGE_DIRECTORY_ENTRY_SECURITY,
                                                      &DirCnt
                                                      );

            if (!pCertificates && !DirCnt) {
                // Only change the data in the image if it hasn't been signed (otherwise the sig is invalidated).
                strcpy(((char *)pDebugDir) + mysize, Filename);
                strcat(((char *)pDebugDir) + mysize, FileExt);
                CvDebugDir->SizeOfData = mysize + strlen(Filename) + strlen(FileExt) + 1;
            }
        }
        UnMapAndLoad(&LoadedImage);
        return(TRUE);
    }

    UnMapAndLoad(&LoadedImage);
    return(FALSE);
}


//#include <wppfmt.c>    // just include this source for  now (like copypdb)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\include\em_tools.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef _EM_TOOLS_H
#define _EM_TOOLS_H

typedef struct EM_version_s
{
	int      major;
	int      minor;
} EM_version_t;

typedef struct EM_library_version_s
{
	EM_version_t   xversion;
	EM_version_t   api;
	EM_version_t   emdb;
    char           date[12];
    char           time[9];
} EM_library_version_t;

#endif /* _EM_TOOLS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\include\em_perl.h ===
##
## Copyright (c) 2000, Intel Corporation
## All rights reserved.
##
## WARRANTY DISCLAIMER
##
## THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
## A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
## PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
## OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
## NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
## MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##
## Intel Corporation is the author of the Materials, and requests that all
## problem reports or change requests be submitted to it directly at
## http://developer.intel.com/opensource.
##

### Perl scripts header file

### EMDB flags (emdb_types.h) ###

$EM_FLAG_PRED                       = 0x1;
$EM_FLAG_PRIVILEGED                 = 0x2;
$EM_FLAG_LMEM                       = 0x4;
$EM_FLAG_SMEM                       = 0x8;
$EM_FLAG_CHECK_BASE_EQ_DST          = 0x10;
$EM_FLAG_FIRST_IN_INSTRUCTION_GROUP = 0x20;
$EM_FLAG_LAST_IN_INSTRUCTION_GROUP  = 0x40;
$EM_FLAG_CHECK_SAME_DSTS            = 0x80;
$EM_FLAG_SLOT2_ONLY                 = 0x100;
$EM_FLAG_TWO_SLOT                   = 0x200;
$EM_FLAG_OK_IN_MLX                  = 0x400;
$EM_FLAG_CHECK_EVEN_ODD_FREGS       = 0x800;
$EM_FLAG_CTYPE_UNC                  = 0x1000;
$EM_FLAG_UNUSED_HINT_ALIAS          = 0x02000;
$EM_FLAG_ILLEGAL_OP                 = 0x04000;
$EM_FLAG_IGNORED_OP                 = 0x08000;
$EM_FLAG_ENDS_INSTRUCTION_GROUP     = 0x10000;
$EMDB_LAST_FLAG                     = $EM_FLAG_ENDS_INSTRUCTION_GROUP;
$EMDB_MAX_FLAG                      = 17;


$MAX_EXTENSION = 8;
$MAX_OPERAND   = 6;

### EM flags (EM.h) ###

$EM_BUNDLE_SIZE       = 16;
$EM_SYLLABLE_BITS     = 41;
$EM_DISPERSAL_POS     = 0;
$EM_DISPERSAL_BITS    = 5;
$EM_SBIT_POS          = 0;
$EM_TEMPLATE_POS      = 1;
$EM_TEMPLATE_BITS     = 4;
$EM_NUM_OF_TEMPLATES  = (1<<$EM_TEMPLATE_BITS);

$EM_MAJOR_OPCODE_POS     = 37;
$EM_MAJOR_OPCODE_BITS    = 4;
$EM_NUM_OF_MAJOR_OPCODES = (1<<$EM_MAJOR_OPCODE_BITS);
$EM_PREDICATE_POS        = 0;
$EM_PREDICATE_BITS       = 6;


### Templates ###

$EM_template_mii   = 0;
$EM_template_mi_i  = 1;
$EM_template_mlx   = 2;
# 3  reserved
$EM_template_mmi   = 4;
$EM_template_m_mi  = 5;
$EM_template_mfi   = 6;
$EM_template_mmf   = 7;
$EM_template_mib   = 8;
$EM_template_mbb   = 9;
# 10 reserved
$EM_template_bbb   = 11;
$EM_template_mmb   = 12;
# 13 reserved
$EM_template_mfb   = 14;
# 15 reserved
$EM_template_last  = 15;


### Template roles ###

$EM_TROLE_NONE  = 0;
$EM_TROLE_ALU   = 1;
$EM_TROLE_BR    = 2;
$EM_TROLE_FP    = 3;
$EM_TROLE_INT   = 4;
$EM_TROLE_LONG  = 5;
$EM_TROLE_MEM   = 6;
$EM_TROLE_MIBF  = 7;
$EM_TROLE_LAST  = 8;

$EM_NUM_OF_TROLES = $EM_TROLE_LAST;

### number of registers ###

$EM_NUM_OF_KREGS  = 8; #kernel registers are AREGS


1; ### Return value

### application registers ###
%EM_AR_NAMES =
(
  AR_KR0 ,0,
  AR_KR1 ,1,
  AR_KR2 ,2,
  AR_KR3 ,3,
  AR_KR4 ,4,
  AR_KR5 ,5,
  AR_KR6 ,6,
  AR_KR7 ,7,
  ### ar8-15 reserved ###
  AR_RSC ,16,
  AR_BSP ,17,
  AR_BSPSTORE,18,
  AR_RNAT,19,
  ### ar20 reserved ###
  AR_FCR ,21,
  ### ar22-23 reserved ###
  AR_EFLAG ,24,
  AR_CSD   ,25,
  AR_SSD   ,26,
  AR_CFLG  ,27,
  AR_FSR   ,28,
  AR_FIR   ,29,
  AR_FDR   ,30,
  ### ar31 reserved ###
  AR_CCV   ,32,
  ### ar33-35 reserved ###
  AR_UNAT,36,
  ### ar37-39 reserved ###
  AR_FPSR,40,
  ### ar41-43 reserved ###
  AR_ITC ,44,
  ### ar45-47 reserved ###
  ### ar48-63 ignored ###
  AR_PFS ,64,
  AR_LC  ,65,
  AR_EC  ,66,
  ### ar67-111 reserved ###
  ### ar112-128 ignored ###
 );

%EM_CR_NAMES =
(
  CR_DCR ,0,
  CR_ITM ,1,
  CR_IVA ,2,
  ### 3-7 reserved ###
  CR_PTA ,8,
  CR_GPTA,9,
  ### 10-15 reserved ###
  CR_IPSR,16,
  CR_ISR ,17,
  ### 18 reserved ###
  CR_IIP ,19,
  CR_IFA ,20,
  CR_ITIR,21,
  CR_IIPA,22,
  CR_IFS ,23,
  CR_IIM ,24,
  CR_IHA ,25,
  ### 25-63 reserved ###
  ### SAPIC registers ###
  CR_LID ,64,
  CR_IVR ,65,
  CR_TPR ,66,
  CR_EOI ,67,
  CR_IRR0,68,
  CR_IRR1,69,
  CR_IRR2,70,
  CR_IRR3,71,
  CR_ITV ,72,
  CR_PMV ,73,
  CR_CMCV,74,
  ### 75-79 reserved  ###
  CR_LRR0,80,
  CR_LRR1,81,
  ### 82-127 reserved ###
 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\include\iel.h ===
/*
 * Copyright (c) 2000, Intel Corporation
 * All rights reserved.
 *
 * WARRANTY DISCLAIMER
 *
 * THESE MATERIALS ARE PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THESE
 * MATERIALS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Intel Corporation is the author of the Materials, and requests that all
 * problem reports or change requests be submitted to it directly at
 * http://developer.intel.com/opensource.
 */


#ifndef IEL_H
#define IEL_H

#if defined(BIG_ENDIAN) && defined(BYTE_ORDER)
#if BYTE_ORDER != BIG_ENDIAN
#undef BIG_ENDIAN
#endif
#endif


typedef char  S1byte;
typedef short S2byte;
typedef int   S4byte;

typedef unsigned char  U1byte;
typedef unsigned short U2byte;
typedef unsigned int   U4byte;

typedef unsigned short U16;
typedef unsigned char  U8;


/*---------
         IEL types declarations
                              ------------*/


#ifdef  LP64

#ifdef WINNT
typedef unsigned __int64 Ulong64;
typedef __int64 Slong64;
#else
typedef unsigned long Ulong64;
typedef long Slong64;
#endif

extern  Ulong64         IEL_temp64;

typedef union
{
    U4byte dw[1];
    U4byte qw[1];
}U32, S32;

typedef union
{
    Ulong64 qw[1];
    unsigned int dw[2];
} U64,S64;

typedef union
{
    Ulong64   qw[2];
    unsigned int dw[4];
} U128, S128;

#else /* LP32 */
      
typedef struct
{
    U4byte dw[1];
}U32, S32;

typedef struct
{
    U4byte   dw[2];
} U64, S64;

typedef struct
{
    U4byte   dw[4];
} U128,S128;

#endif /* end of LP32 */

/*---------
         IEL temporary variables
                              ------------*/

#ifdef __cplusplus
extern "C" {
#endif

extern  unsigned int    IEL_t1, IEL_t2, IEL_t3, IEL_t4;
extern  U32             IEL_tempc;
extern  U64             IEL_et1, IEL_et2;
extern  U128            IEL_ext1, IEL_ext2, IEL_ext3, IEL_ext4, IEL_ext5;
extern  U128            IEL_POSINF, IEL_NEGINF, IEL_MINUS1;
extern  S128            IEL_ts1, IEL_ts2;

#ifdef __cplusplus
}
#endif

/*---------
         IEL constants
                    ------------*/
#define IEL_MAX32 ((U4byte) (0xFFFFFFFF))
#define IEL_UMAX32 ((U4byte) (0xFFFFFFFF))
#define IEL_SMAX32 ((U4byte) (0x7FFFFFFF))

#define IEL_UMAX64  0xffffffffffffffff
#define IEL_SMAX64  0x7fffffffffffffff

#define IEL128(x) (*(U128*)(&(x)))
#define IEL64(x)  (*(U64*)(&(x)))
#define IEL32(x)  (*(U32*)(&(x)))



#define IEL_FALSE 0
#define IEL_TRUE  1

#ifdef __cplusplus

#define IEL_OK 0
#define IEL_OVFL 1

typedef unsigned int IEL_Err;

#else

typedef enum
{
    IEL_OK = 0,
    IEL_OVFL
} IEL_Err;
#endif

typedef enum
{
    IEL_BIN = 2,
    IEL_OCT = 8,
    IEL_DEC = 10,
    IEL_SDEC = 100,
    IEL_HEX = 16,
    IEL_UHEX = 116
} IEL_Base;

/*----------
         IEL structure elements
                         ---------*/

#   ifdef   BIG_ENDIAN

#       define  qw0_64 qw[0]
#       define  qw0_128 qw[1]
#       define  qw1_128 qw[0]
#       define  dw0_32  dw[0]
#       define  dw0_64  dw[1]
#       define  dw1_64  dw[0]
#       define  dw0_128 dw[3]
#       define  dw1_128 dw[2]
#       define  dw2_128 dw[1]
#       define  dw3_128 dw[0]

#   else  /*** BIG_ENDIAN ***/

#       define  qw0_64 qw[0]
#       define  qw0_128 qw[0]
#       define  qw1_128 qw[1]
#       define  dw0_32  dw[0]
#       define  dw0_64  dw[0]
#       define  dw1_64  dw[1]
#       define  dw0_128 dw[0]
#       define  dw1_128 dw[1]
#       define  dw2_128 dw[2]
#       define  dw3_128 dw[3]

#   endif /*** BIG_ENDIAN ***/


#define DW0(x)          ((sizeof((x))==4)?((x).dw0_32):\
                         (sizeof((x))==8)?((x).dw0_64):\
                         (sizeof((x))==16)?((x).dw0_128):0)
#define DW1(x)          ((sizeof((x))==8)?((x).dw1_64):\
                         (sizeof((x))==16)?((x).dw1_128):0)
#define DW2(x)          ((sizeof((x))==16)?((x).dw2_128):0)
#define DW3(x)          ((sizeof((x))==16)?((x).dw3_128):0)

#define IEL_GETDW0(x) DW0(x) 
#define IEL_GETDW1(x) DW1(x)
#define IEL_GETDW2(x) DW2(x)
#define IEL_GETDW3(x) DW3(x)

#ifdef  LP64

#define IEL_CONST32(x)      {(U4byte )(x)}
#define IEL_CONST(x)        IEL_CONST32(x)
#define IEL_CONST64L(x)     {(Ulong64 )(x)}

#ifdef BIG_ENDIAN

#define IEL_CONST64(x0, x1)             {((Ulong64)x0<<32)|x1}
#define IEL_CONST128(x0, x1, x2, x3)    {{((Ulong64)x2<<32)|x3, ((Ulong64)x0<<32)|x1}}
#define IEL_CONST128L(x0, x1)           {{(Ulong64 )x1, (Ulong64 )x0}}

#else /* BIG_ENDIAN */

#define IEL_CONST64(x0, x1)             {((Ulong64)x1<<32)|x0}
#define IEL_CONST128(x0, x1, x2, x3)    {{((Ulong64)x1<<32)|x0, ((Ulong64)x3<<32)|x2}}
#define IEL_CONST128L(x0, x1)           {{(Ulong64 )x0, (Ulong64 )x1}}

#endif /* BIG_ENDIAN */

#define IEL_GETQW0(x)    ((sizeof(x)==4) ? (Ulong64)((x).dw0_32) : \
                         ((sizeof(x)==8) ?  (x).qw0_64 : \
                         ((sizeof(x)==16) ? (x).qw0_128 : 0)))

#define IEL_GETQW1(x)   ((sizeof(x)==sizeof (U128)) ? ((x).qw1_128) : (0))

#define QW0(x) IEL_GETQW0(x)
#define QW1(x) IEL_GETQW1(x)

#define SQW0(x)     ((sizeof(x)==4)? (((x).dw0_32 & 0x80000000)? \
                     (((Ulong64)(-1)<<32) | (Ulong64)(x).dw0_32) : (Ulong64)(x).dw0_32) : \
                     (sizeof(x)==8)?((x).qw0_64):\
                     (sizeof(x)==16)?((x).qw0_128):0)

#define SQW1(x)    ((sizeof(x)==4)? (((x).dw0_32 & 0x80000000)? (Ulong64)(-1):0) :\
                    (sizeof(x)==8)?((x).qw0_64 & 0x8000000000000000)?(Ulong64)(-1):0 :\
                    (sizeof(x)==16)?((x).qw1_128):0)

#define IEL_INCU(x)      ((sizeof(x) == sizeof(U32)) ? \
                            ((x).dw0_32++,((x).dw0_32==0)) :\
                         (sizeof(x) == sizeof(U64)) ? \
                            ((x).qw0_64++,((x).qw0_64==0)) : \
                         (sizeof(x) == sizeof(U128)) ? \
                            ((x).qw0_128++,(!(x).qw0_128) ? \
                             ((x).qw1_128++, ((x).qw1_128==0)) : \
                             IEL_OK) : IEL_OVFL)

#define IEL_INCS(x)     ((sizeof(x) == sizeof(U32)) ? \
                          (((x).dw0_32++),(((x).dw0_32==0x80000000)||((x).dw0_32==0))) : \
						(sizeof(x) == sizeof(U64)) ? \
                         (((x).qw0_64++),(((x).qw0_64==0x8000000000000000)||((x).qw0_64==0))) : \
                           (sizeof(x) == sizeof(U128)) ? \
                          ((x).qw0_128++, !(x).qw0_128? ((x).qw0_128=0, (x).qw1_128++, \
                             (((x).qw1_128==0)||((x).qw1_128==0x8000000000000000))) : IEL_OK): \
                           IEL_OVFL)
                             

#define IEL_DECU(x)     ((sizeof(x) == sizeof(U32)) ? \
                            (((x).dw0_32--),((x).dw0_32==IEL_MAX32)) : \
                         (sizeof(x) == sizeof(U64)) ? \
                            ((x).qw0_64--,((x).qw0_64==IEL_UMAX64)) : \
                         (sizeof(x) == sizeof(U128)) ? \
                            ((x).qw0_128--,((x).qw0_128==IEL_UMAX64) ? \
                             ((x).qw1_128--, ((x).qw1_128==IEL_UMAX64)) : \
                             IEL_OK) : IEL_OVFL)

#define IEL_DECS(x)     ((sizeof(x) == sizeof(U32)) ? \
                            (((x).dw0_32--),((x).dw0_32==IEL_UMAX32) || \
                             (x).dw0_32==IEL_SMAX32) : \
                         (sizeof(x) == sizeof(U64)) ? \
                            (((x).qw0_64--),(((x).qw0_64==IEL_UMAX64))||((x).qw0_64==IEL_SMAX64)) : \
                         (sizeof(x) == sizeof(U128)) ? \
                            ((x).qw0_128--,((x).qw0_128==IEL_UMAX64) ? \
                             ((x).qw1_128--, ((x).qw1_128==IEL_UMAX64)|| \
                             ((x).qw1_128==IEL_SMAX64)): \
                             IEL_OK) : IEL_OVFL)

#define IEL_AND(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) & DW0(z), \
                                  ((DW1(y) & DW1(z)) || (QW1(y) & QW1(z)))) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).qw0_64 = QW0(y) & QW0(z)), \
                                 ((QW1(y) & QW1(z)) != 0)) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = QW0(y) & QW0(z), \
                                 (x).qw1_128 = QW1(y) & QW1(z),IEL_OK) : \
                                 IEL_OVFL)

#define IEL_OR(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) | DW0(z), \
                                 (((DW1(y) | DW1(z)) ||(QW1(y) | QW1(z))))) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).qw0_64 = QW0(y) | QW0(z)), \
                                 ((QW1(y) | QW1(z)) != 0)) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = QW0(y) | QW0(z), \
                                 (x).qw1_128 = QW1(y) | QW1(z),IEL_OK) : \
                                 IEL_OVFL)

#define IEL_XOR(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) ^ DW0(z), \
                                 (((DW1(y) ^ DW1(z))||(QW1(y) ^ QW1(z))))) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).qw0_64 = QW0(y) ^ QW0(z)), \
                                 ((QW1(y) ^ QW1(z)) != 0)) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = QW0(y) ^ QW0(z), \
                                 (x).qw1_128 = QW1(y) ^ QW1(z),IEL_OK) : \
                                 IEL_OVFL)

#define IEL_ANDNOT(x, y, z)  ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) & ~DW0(z), \
                                 (((DW1(y) & ~DW1(z))||(QW1(y) & ~QW1(z))))) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).qw0_64 = QW0(y) & (~QW0(z))), \
                                 ((QW1(y) & (~QW1(z))) != 0)) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = QW0(y) & (~QW0(z)), \
                                 (x).qw1_128 = QW1(y) & (~QW1(z)),IEL_OK) : \
                                 IEL_OVFL)


#define IEL_ASSIGNU(x, y)   	((sizeof(x) == sizeof(U32)) ?\
                                ((x).dw0_32 = (y).dw0_32, (DW1(y) || QW1(y))):\
								(sizeof(x) == sizeof (U64)) ? \
                                ((x).qw0_64 = QW0(y), (QW1(y)!=0)) : \
                                (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = QW0(y), (x).qw1_128 = QW1(y), \
                                 IEL_OK) : IEL_OVFL)

#define IEL_ASSIGNS(x, y)   (IEL_ext1.qw0_128 = SQW0(y), \
                             IEL_ext1.qw1_128 = SQW1(y), \
                             (sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = IEL_ext1.dw0_128, \
                                 ((x).dw0_32 & 0x80000000) ? \
                                 (~IEL_ext1.dw1_128||~IEL_ext1.qw1_128) : \
                                 (IEL_ext1.dw1_128 || IEL_ext1.qw1_128)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                              ((x).qw0_64 = IEL_ext1.qw0_128,\
                               ((x).qw0_64 & 0x8000000000000000)?\
                               (~IEL_ext1.qw1_128 !=0): (IEL_ext1.qw1_128!=0)):\
                              (sizeof(x) == sizeof (U128)) ? \
                               ((x).qw0_128 = IEL_ext1.qw0_128,\
                                (x).qw1_128 = IEL_ext1.qw1_128, IEL_OK):\
                               IEL_OVFL)
                             
#define IEL_NOT(x, y)       ((sizeof(x )== sizeof(U32)) ? \
                                ((x).dw0_32 = (~DW0(y)), \
                                 ((~DW1(y))|| (~QW1(y)))): \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).qw0_64 = (~QW0(y)), \
                                 ((~QW1(y)) != 0)) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = (~QW0(y)),\
                                 (x).qw1_128 = (~QW1(y)), \
                                 IEL_OK) : IEL_OVFL)

#define IEL_ZERO(x)         ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = 0) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).qw0_64 = 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).qw0_128 = 0, (x).qw1_128 = 0, IEL_OK): \
                                IEL_OVFL)
                            

#define QW1_1(x)    ((sizeof(x)==16)? ((x).qw1_128):1)

#define IEL_C0(x) (QW0(x) < QW0(IEL_ext1))
/*#define IEL_C1(x) ((QW1(x)-IEL_C0(x)) < QW1(IEL_ext1))*/

#define IEL_C1(x) (IEL_C0(x) ? (QW1_1(x)<=QW1(IEL_ext1)) : (QW1(x)<QW1(IEL_ext1)))


#define IEL_ADDU(x, y, z)   ((sizeof(x)==sizeof(U32))?\
                                (IEL_t1=DW0(y),(x).dw0_32=DW0(y)+DW0(z),\
                                 ((IEL_t1>DW0(x))||(DW1(y))||(QW1(y)) ||\
                                (DW1(z))||(QW1(z)))):\
                             (sizeof(x)==sizeof(U64))?\
                                (IEL_temp64 = QW0(y),(x).qw0_64=QW0(y)+QW0(z),\
                                 ((IEL_temp64 > QW0(x))||(QW1(y))||(QW1(z)))):\
                             (sizeof(x)==sizeof(U128))?\
                                (IEL_ASSIGNU(IEL_ext1, y),\
                                 (x).qw0_128=QW0(y)+QW0(z),\
                                 (x).qw1_128=QW1(y)+QW1(z)+IEL_C0(x),\
                                 IEL_C1(x)) : IEL_OVFL)

#define IEL_EQU(x, y)       (((Ulong64)QW0(x)==(Ulong64)QW0(y)) && \
                             ((Ulong64)QW1(x)==(Ulong64)QW1(y)))

#define IEL_ISZERO(x)       ((QW0(x)==0) && (QW1(x)==0))

#define IEL_CMPGU(x, y)     ((QW1(x)>QW1(y)) || \
                             ((QW1(x)==QW1(y)) && (QW0(x)>QW0(y))))

#define IEL_CMPGEU(x, y)        ((QW1(x)>QW1(y)) || \
                             ((QW1(x)==QW1(y)) && (QW0(x)>=QW0(y))))

#define IEL_SHL(x, y, n)    ((((n) <=0) || ((n) >= (sizeof(x) << 3)))? \
                                 ((IEL_ISZERO(y)||(!(n)))? \
                                  (IEL_ASSIGNU(x,y),IEL_OK) : \
                                   (IEL_ZERO(x), IEL_OVFL)) : \
                             ((sizeof(x) == sizeof (U32)) ? \
                                (IEL_t1 = (DW1(y) || DW2(y) || DW3(y) \
                                 || (DW0(y)>= (U4byte)1<<(32-(n)))), \
                                 (x).dw0_32 = DW0(y) << (n), (IEL_t1)) : \
                              (sizeof(x) == sizeof (U64)) ? \
                              (IEL_t1 = QW1(y)||(QW0(y) >= (Ulong64)1<<(64-(n))), \
                              (x).qw0_64= QW0(y)<<(n),IEL_t1): \
                               ((sizeof(x) == sizeof(U128)) ? \
                              ((n)==64)? \
                               (IEL_t1=(QW1(y)>0),(x).qw1_128=QW0(y),\
                                (x).qw0_128=0,IEL_t1) : \
                               ((n)<64)? \
                               (IEL_t1 = (QW1(y) >= (Ulong64)1<<(64-(n))),\
                                (x).qw1_128 = (QW1(y)<<(n))|\
                                QW0(y)>>(64-(n)),\
                                (x).qw0_128 = QW0(y) << (n), IEL_t1) :\
                                /* n > 64 */\
                               (IEL_t1 = (QW1(y))||\
                                          (QW0(y) >= (Ulong64)1<<(128-(n))),\
                                 (x).qw1_128 = QW0(y) << ((n)-64),(x).qw0_128 = 0,\
                                 IEL_t1):IEL_OVFL)))

#define IEL_SHL128(x, y, n)   (((n)==64)? \
                               (IEL_t1=(QW1(y)>0),(x).qw1_128=QW0(y),\
                                (x).qw0_128=0,IEL_t1) : \
                               ((n)<64)? \
                               (IEL_t1 = (QW1(y) >= (Ulong64)1<<(64-(n))),\
                                (x).qw1_128 = (QW1(y)<<(n))|\
                                QW0(y)>>(64-(n)),\
                                (x).qw0_128 = QW0(y) << (n), IEL_t1) :\
                                /* n > 64 */\
                               (IEL_t1 = QW1(y)||\
                                          (QW0(y) >= (Ulong64)1<<(128-(n))),\
                                (x).qw1_128 = QW0(y) << ((n)-64),(x).qw0_128 = 0,\
                                 IEL_t1))



#define IEL_ISNEG(x)        ((sizeof(x) == sizeof(U32)) ? \
                                ((DW0(x) & 0x80000000)!=0) : \
                             (sizeof(x) == sizeof(U64)) ? \
                                ((QW0(x) & 0x8000000000000000)!=0) : \
                             (sizeof(x) == sizeof(U128)) ? \
                                ((QW1(x) & 0x8000000000000000)!=0) : IEL_FALSE)

#define IEL_ISNINF(x)        ((sizeof(x) == sizeof(U32)) ? \
                                (DW0(x)==0x80000000) : \
                             (sizeof(x) == sizeof(U64)) ? \
                                (QW0(x)==0x8000000000000000) : \
                             (sizeof(x) == sizeof(U128)) ? \
                                (QW1(x)==0x8000000000000000 && QW0(x)==0) : \
                                (IEL_OVFL))




#define IEL_INL(x, n)       (((((Ulong64)1<<n)-1) & x))
#define IEL_INH(x, n)       (x>>n)

#define IEL_SHR(x, y, n)  \
(((n) <=0)?  ((IEL_ISZERO(y)||(!n)) \
              ?  (IEL_ASSIGNU(x,y),IEL_OK)\
              :  (IEL_ZERO(x), IEL_OVFL))\
          : \
         ((sizeof(x) == sizeof (U32)) ? \
        ((n)==64) ?  \
                  ((x).dw0_32 = (U4byte)QW1(y), (DW3(y)!=0)) : \
        ((n)>64) ? \
             ((x).dw0_32 = (U4byte)(QW1(y)>>((n)-64)),\
             ((QW1(y)>>((n)-64))> QW0(x))) : \
        /* n < 64 */  \
             (IEL_temp64 = (QW0(y)>>(n))|(QW1(y)<<(64-(n))),\
			 (x).dw0_32 = (U4byte)IEL_temp64, \
             ((QW1(y)>>(n))> 0) || (IEL_temp64 > QW0(x))) : \
       (sizeof(x) == sizeof (U64)) \
   ? (((n)==64)?  ((x).qw0_64=QW1(y),IEL_OK)\
               :(((n) < 64)?  ((x).qw0_64 = (QW0(y)>>(n))|(QW1(y)<<(64-(n))),\
                              (QW1(y)>>(n)!=0))\
                /* n > 64 */  :  ((x).qw0_64 = QW1(y)>>((n)-64), IEL_OK)))\
   :(sizeof(x) == sizeof(U128)) \
     ?  (((n)==64)?  ((x).qw0_128=QW1(y),(x).qw1_128=0,IEL_OK) \
                  : (((n)<64)?  ((x).qw0_128 = (QW0(y)>>(n))|(QW1(y)<<(64-(n))),\
                                 (x).qw1_128 = QW1(y)>>(n),\
                                 IEL_OK)\
                   /* n>64 */:  ((x).qw0_128=QW1(y)>>((n)-64),(x).qw1_128=0,\
                                 IEL_OK)))\
     : IEL_OVFL))


#define IEL_SHR128(x, y, n) (((n) <=0) ? \
                             ((IEL_ISZERO(y)||!(n)) ? \
                              (IEL_ASSIGNU(x, y), IEL_OK) :\
                              (IEL_ZERO(x), IEL_OVFL)): \
                               (sizeof(x) == sizeof (U128)) ? \
                       (n==64) ?  \
                                ((x).qw0_128 = QW1(y), \
                                (x).qw1_128 = 0, (IEL_OK)) : \
                       (((n)<64)?  ((x).qw0_128 = (QW0(y)>>(n))|(QW1(y)<<(64-(n))),\
                                 (x).qw1_128 = QW1(y)>>(n),IEL_OK)\
                   /* n>64 */:  ((x).qw0_128=QW1(y)>>((n)-64),(x).qw1_128=0,\
                                 IEL_OK)): IEL_OVFL)

#define IEL_SEXT(x, y)      (IEL_ASSIGNU(x,y),\
                             ((!IEL_ISNEG(y)) || (sizeof(x)==sizeof(y))) ? \
                             (IEL_OK) : \
                            ((sizeof(x) == sizeof(U64)) ? \
                                ((sizeof(y) == sizeof(U32)) ? \
                                    ((x).dw1_64=IEL_MAX32,IEL_OK):(IEL_OVFL)): \
                            ((sizeof(x) == sizeof(U128)) ? \
                                ((sizeof(y) == sizeof(U32)) ? \
                                    ((x).dw1_128 = IEL_MAX32, \
                                     (x).dw2_128 = IEL_MAX32, \
                                     (x).dw3_128 = IEL_MAX32, IEL_OK) : \
                                (sizeof(y) == sizeof (U64)) ? \
                                    ((x).dw2_128 = IEL_MAX32, \
                                    (x).dw3_128 = IEL_MAX32, IEL_OK):IEL_OVFL):\
                                (IEL_OVFL))))


#define IEL_ISNEG128(x)      (((x).qw1_128 & 0x8000000000000000)!=0)


#define IEL_ADDU128(x, y, z) (IEL_ASSIGNU(IEL_ext1, y),\
                                (x).qw0_128=(y).qw0_128 + (z).qw0_128,\
                                 (x).qw1_128=(y).qw1_128+(z).qw1_128+ IEL_C0(x),\
                                 IEL_C1(x))

#define iel_check_result_sign(addend1, addend2, res)\
   ((((addend1.qw1_128 ^ addend2.qw1_128) & 0x8000000000000000) == 0) && \
    (((addend1.qw1_128 ^ res.qw1_128) & 0x8000000000000000) != 0))

#define IEL_ADDS(x, y, z)   (IEL_ASSIGNS(IEL_ext4, y), \
                             IEL_ASSIGNS(IEL_ext2, z), \
                             IEL_ADDU128(IEL_ext3, IEL_ext4, IEL_ext2), \
                             IEL_ASSIGNS(x, IEL_ext3)||\
                             iel_check_result_sign(IEL_ext4, IEL_ext2, IEL_ext3))

#define IEL_SUBU(x, y, z) (IEL_ISZERO(z) ? IEL_ASSIGNU(x, y) : \
                           (IEL_COMP(IEL_ext2 ,z), \
                           (!(IEL_ADDU(x, y,IEL_ext2)))))

#define IEL_CONVERT4L(x, y0, y1) \
                             ((sizeof(x) == sizeof(U64)) ? \
                                ((x).qw0_64 = y0, y1):\
                             (sizeof(x) == sizeof(U128)) ? \
                                ((x).qw0_128 = y0, \
                                 (x).qw1_128 = y1, \
                                 IEL_OK) : IEL_OVFL)

#define IEL_CONVERT2L(x,y0) IEL_CONVERT4L(x,y0,0)

#define IEL128(x) (*(U128*)(&(x)))

#else /* not LP64 */

#define IEL_CONST32(x)      {(U4byte )(x)}
#define IEL_CONST(x)        IEL_CONST32(x)

#ifdef BIG_ENDIAN

#define IEL_CONST64(x0, x1)         {{(U4byte )(x1),(U4byte )(x0)}}
#define IEL_CONST128(x0, x1, x2, x3)    {{x3, x2, x1, x0}}

#else /* BIG_ENDIAN */

#define IEL_CONST64(x0, x1)         {{(U4byte )(x0), (U4byte )(x1)}}
#define IEL_CONST128(x0, x1, x2, x3)    {{x0, x1, x2, x3}}

#endif /* BIG_ENDIAN */

/* DWn_1(x) macros return 1 (instead of 0) in order to  prevent warnings */
/* This does not affect the produced code since the 1 can appear only in */
/* a "dead portion of code" derived by preprocessor */

#define DW1_1(x)    ((sizeof((x))==8)?((x).dw1_64):\
                         (sizeof((x))==16)?((x).dw1_128):1)
#define DW2_1(x)    ((sizeof((x))==16)?((x).dw2_128):1)
#define DW3_1(x)    ((sizeof((x))==16)?((x).dw3_128):1)





#define SDW0(x)         ((sizeof((x))==4)?((x).dw0_32):\
                         (sizeof((x))==8)?((x).dw0_64):\
                         (sizeof((x))==16)?((x).dw0_128):0)
#define SDW1(x)         ((sizeof((x))==4)?((x).dw0_32 & 0x80000000) ? -1 : 0 : \
                         (sizeof((x))==8)?((x).dw1_64): \
                         (sizeof((x))==16)?((x).dw1_128):0)
#define SDW2(x)         ((sizeof((x))==4)?((x).dw0_32 & 0x80000000) ? -1 : 0 :\
                         (sizeof((x))==8)?((x).dw1_64 & 0x80000000) ? -1 : 0 :\
                         (sizeof((x))==16)?((x).dw2_128):0)
#define SDW3(x)         ((sizeof((x))==4)?((x).dw0_32 & 0x80000000) ? -1 : 0 :\
                         (sizeof((x))==8)?((x).dw1_64 & 0x80000000) ? -1 : 0 :\
                         (sizeof((x))==16)?((x).dw3_128):0)



#define IEL_INCU(x)     ((sizeof(x)==4) ? \
                            (((x).dw0_32++),((x).dw0_32==0)) : \
                         (sizeof(x)==8) ? \
                            (((x).dw0_64++),!((x).dw0_64) ? \
                             ((x).dw1_64++, ((x).dw1_64==0)) : IEL_OK) : \
                         (sizeof(x)==16) ? \
                            (((x).dw0_128++),!((x).dw0_128) ? \
                            (((x).dw1_128++),!((x).dw1_128) ? \
                            (((x).dw2_128++),!((x).dw2_128) ? \
                            (((x).dw3_128++),((x).dw3_128==0)) : \
                             (IEL_OK)) : (IEL_OK)) : (IEL_OK)) : IEL_OVFL)

#define IEL_INCS(x)     ((sizeof(x) == sizeof(U32)) ? \
                            (((x).dw0_32++),(((x).dw0_32==0)) || \
                             (x).dw0_32==0x80000000): \
                         (sizeof(x) == sizeof(U64)) ? \
                            (((x).dw0_64++),!((x).dw0_64) ? \
                             ((x).dw1_64++, ((x).dw1_64==0) || \
                              (x).dw1_64==0x80000000) : IEL_OK) : \
                         (sizeof(x) == sizeof(U128)) ? \
                            (((x).dw0_128++),!((x).dw0_128) ? \
                            (((x).dw1_128++),!((x).dw1_128) ? \
                            (((x).dw2_128++),!((x).dw2_128) ? \
                            (((x).dw3_128++),((x).dw3_128==0) || \
                            (x).dw3_128==0x80000000) : \
                             (IEL_OK)) : (IEL_OK)) : (IEL_OK)) : IEL_OVFL)

#define IEL_DECU(x)     ((sizeof(x) == sizeof(U32)) ? \
                            (((x).dw0_32--),((x).dw0_32==IEL_MAX32)) : \
                         (sizeof(x) == sizeof(U64)) ? \
                            (((x).dw0_64--),((x).dw0_64==IEL_MAX32) ? \
                             ((x).dw1_64--, ((x).dw1_64==IEL_MAX32)) : IEL_OK):\
                         (sizeof(x) == sizeof(U128)) ? \
                            (((x).dw0_128--),((x).dw0_128==IEL_MAX32) ? \
                            (((x).dw1_128--),((x).dw1_128==IEL_MAX32) ? \
                            (((x).dw2_128--),((x).dw2_128==IEL_MAX32) ? \
                            (((x).dw3_128--),((x).dw3_128==IEL_MAX32)) : \
                             (IEL_OK)) : (IEL_OK)) : (IEL_OK)) : IEL_OVFL)


#define IEL_DECS(x)     ((sizeof(x) == sizeof(U32)) ? \
                            (((x).dw0_32--),((x).dw0_32==IEL_MAX32) || \
                             (x).dw0_32==0x7fffffff) : \
                         (sizeof(x) == sizeof(U64)) ? \
                            (((x).dw0_64--),((x).dw0_64==IEL_MAX32) ? \
                             ((x).dw1_64--, ((x).dw1_64==IEL_MAX32) || \
                             (x).dw1_64==0x7fffffff) : IEL_OK) : \
                         (sizeof(x) == sizeof(U128)) ? \
                            (((x).dw0_128--),((x).dw0_128==IEL_MAX32) ? \
                            (((x).dw1_128--),((x).dw1_128==IEL_MAX32) ? \
                            (((x).dw2_128--),((x).dw2_128==IEL_MAX32) ? \
                            (((x).dw3_128--),((x).dw3_128==IEL_MAX32) || \
                             (x).dw3_128==0x7fffffff) : \
                             (IEL_OK)) : (IEL_OK)) : (IEL_OK)) : IEL_OVFL)

#define IEL_AND(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) & DW0(z), \
                                 (((DW1(y) & DW1(z)) | (DW2(y) & DW2(z)) |\
                                   (DW3(y) & DW3(z))) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).dw0_64 = DW0(y) & DW0(z), \
                                 ((x).dw1_64 = DW1(y) & DW1(z))), \
                                 ((DW2(y) & DW2(z)) | \
                                  (DW3(y) & DW3(z))) != 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                (((x).dw0_128 = DW0(y) & DW0(z)),  \
                                 ((x).dw1_128 = DW1(y) & DW1(z)),  \
                                 ((x).dw2_128 = DW2(y) & DW2(z)),  \
                                 ((x).dw3_128 = DW3(y) & DW3(z)), \
                                 IEL_OK) : IEL_OVFL) 

#define IEL_OR(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) | DW0(z), \
                                 (((DW1(y) | DW1(z)) | (DW2(y) | DW2(z)) |\
                                   (DW3(y) | DW3(z))) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).dw0_64 = DW0(y) | DW0(z), \
                                 ((x).dw1_64 = DW1(y) | DW1(z))), \
                                 ((DW2(y) | DW2(z)) | \
                                  (DW3(y) | DW3(z))) != 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                (((x).dw0_128 = DW0(y) | DW0(z)),  \
                                 ((x).dw1_128 = DW1(y) | DW1(z)),  \
                                 ((x).dw2_128 = DW2(y) | DW2(z)),  \
                                 ((x).dw3_128 = DW3(y) | DW3(z)),  \
                                 IEL_OK) : IEL_OVFL) 

#define IEL_XOR(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) ^ DW0(z), \
                                 (((DW1(y) ^ DW1(z)) | (DW2(y) ^ DW2(z)) |\
                                   (DW3(y) ^ DW3(z))) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).dw0_64 = DW0(y) ^ DW0(z), \
                                 ((x).dw1_64 = DW1(y) ^ DW1(z))), \
                                 ((DW2(y) ^ DW2(z)) | \
                                  (DW3(y) ^ DW3(z))) != 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                (((x).dw0_128 = DW0(y) ^ DW0(z)),  \
                                 ((x).dw1_128 = DW1(y) ^ DW1(z)),  \
                                 ((x).dw2_128 = DW2(y) ^ DW2(z)),  \
                                 ((x).dw3_128 = DW3(y) ^ DW3(z)),  \
                                 IEL_OK) : IEL_OVFL)

#define IEL_ANDNOT(x, y, z)    ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y) & (~DW0(z)), \
                                 (((DW1(y) & (~DW1(z))) | (DW2(y)&(~DW2(z)))\
                                   | (DW3(y) & (~DW3(z)))) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                (((x).dw0_64 = DW0(y) & (~DW0(z)), \
                                 ((x).dw1_64 = DW1(y) & (~DW1(z)))), \
                                 ((DW2(y) & (~DW2(z))) | \
                                  (DW3(y) & (~DW3(z)))) != 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                (((x).dw0_128 = DW0(y) & (~DW0(z))),  \
                                 ((x).dw1_128 = DW1(y) & (~DW1(z))),  \
                                 ((x).dw2_128 = DW2(y) & (~DW2(z))),  \
                                 ((x).dw3_128 = DW3(y) & (~DW3(z))),  \
                                 IEL_OK) : IEL_OVFL) 
 
#define IEL_ASSIGNU(x, y)   ((sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = DW0(y), \
                                 ((DW1(y) | DW2(y) | DW3(y)) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).dw0_64 = DW0(y), (x).dw1_64 = DW1(y), \
                                 ((DW2(y) | DW3(y)) != 0)) : \
                             (sizeof(x) == sizeof(U128)) ? \
                                ((x).dw0_128 = DW0(y), (x).dw1_128 = DW1(y),\
                                 (x).dw2_128 = DW2(y), (x).dw3_128 = DW3(y),\
                                 IEL_OK) : IEL_OVFL)

#define IEL_ASSIGNS(x, y)   (IEL_ext1.dw0_128 = SDW0(y), \
                             IEL_ext1.dw1_128 = SDW1(y), \
                             IEL_ext1.dw2_128 = SDW2(y), \
                             IEL_ext1.dw3_128 = SDW3(y), \
                             (sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = IEL_ext1.dw0_128, \
                                 ((x).dw0_32 & 0x80000000) ? \
                                 ((~IEL_ext1.dw1_128||~IEL_ext1.dw2_128||\
                                   ~IEL_ext1.dw3_128)) : \
                                 ((IEL_ext1.dw1_128 || IEL_ext1.dw2_128||\
                                   IEL_ext1.dw3_128) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).dw0_64 = IEL_ext1.dw0_128, \
                                 (x).dw1_64 = IEL_ext1.dw1_128, \
                                 ((x).dw1_64 & 0x80000000) ? \
                                 (~IEL_ext1.dw2_128||~IEL_ext1.dw3_128):\
                                 (IEL_ext1.dw2_128|| IEL_ext1.dw3_128)):\
                             (sizeof(x) == sizeof(U128)) ? \
                                ((x).dw0_128 = IEL_ext1.dw0_128,\
                                 (x).dw1_128 = IEL_ext1.dw1_128,\
                                 (x).dw2_128 = IEL_ext1.dw2_128,\
                                 (x).dw3_128 = IEL_ext1.dw3_128,\
                                 IEL_OK) : IEL_OVFL)

/* Duplicate IEL_ASSIGNS for macro-->function transform */

#define IEL_REAL_ASSIGNS(x, y)  (IEL_ext1.dw0_128 = SDW0(y), \
                             IEL_ext1.dw1_128 = SDW1(y), \
                             IEL_ext1.dw2_128 = SDW2(y), \
                             IEL_ext1.dw3_128 = SDW3(y), \
                             (sizeof(x) == sizeof (U32)) ? \
                                ((x).dw0_32 = IEL_ext1.dw0_128, \
                                 ((x).dw0_32 & 0x80000000) ? \
                                 ((~IEL_ext1.dw1_128||~IEL_ext1.dw2_128||\
                                   ~IEL_ext1.dw3_128)) : \
                                 ((IEL_ext1.dw1_128 || IEL_ext1.dw2_128||\
                                   IEL_ext1.dw3_128) != 0)) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).dw0_64 = IEL_ext1.dw0_128, \
                                 (x).dw1_64 = IEL_ext1.dw1_128, \
                                 ((x).dw1_64 & 0x80000000) ? \
                                 (~IEL_ext1.dw2_128||~IEL_ext1.dw3_128):\
                                 (IEL_ext1.dw2_128|| IEL_ext1.dw3_128)):\
                             (sizeof(x) == sizeof(U128)) ? \
                                ((x).dw0_128 = IEL_ext1.dw0_128,\
                                 (x).dw1_128 = IEL_ext1.dw1_128,\
                                 (x).dw2_128 = IEL_ext1.dw2_128,\
                                 (x).dw3_128 = IEL_ext1.dw3_128,\
                                 IEL_OK) : IEL_OVFL)



#define IEL_NOT(x, y)       ((sizeof(x)==4) ? \
                                ((x).dw0_32 = (~DW0(y)), \
                                 (((~DW1(y))|(~DW2(y)) | (~DW3(y))) != 0)): \
                             (sizeof(x)==8) ? \
                                ((x).dw0_64=(~DW0(y)), (x).dw1_64=(~DW1(y)),\
                                 (((~DW2(y)) | (~DW3(y))) != 0)) : \
                             (sizeof(x)==16) ? \
                                ((x).dw0_128=(~DW0(y)), \
                                 (x).dw1_128=(~DW1(y)), \
                                 (x).dw2_128 = (~DW2(y)), \
                                 (x).dw3_128 = (~DW3(y)), \
                                 IEL_OK) : IEL_OVFL)

#define IEL_ZERO(x)         ((sizeof(x) == sizeof(U32)) ? \
                                ((x).dw0_32 = 0) : \
                             (sizeof(x) == sizeof (U64)) ? \
                                ((x).dw0_64 = 0, (x).dw1_64 = 0) : \
                             (sizeof(x) == sizeof (U128)) ? \
                                ((x).dw0_128 = 0, (x).dw1_128 = 0, \
                                 (x).dw2_128 = 0, (x).dw3_128 = 0, IEL_OK) :\
                                IEL_OVFL)


#define IEL_C1_1(x) (IEL_C0(x) ? (DW1_1(x)<=DW1(IEL_ext1)) : \
                               (DW1(x)<DW1(IEL_ext1)))
#define IEL_C2_1(x) (IEL_C1_1(x) ? (DW2_1(x)<=DW2(IEL_ext1)) : \
                               (DW2(x)<DW2(IEL_ext1)))
#define IEL_C3_1(x) (IEL_C2_1(x) ? (DW3_1(x)<=DW3(IEL_ext1)) : \
                               (DW3(x)<DW3(IEL_ext1)))


#define IEL_C0(x) (DW0(x) < DW0(IEL_ext1))
#define IEL_C1(x) (IEL_C0(x) ? (DW1(x)<=DW1(IEL_ext1)) : \
                               (DW1(x)<DW1(IEL_ext1)))
#define IEL_C2(x) (IEL_C1(x) ? (DW2(x)<=DW2(IEL_ext1)) : \
                               (DW2(x)<DW2(IEL_ext1)))
#define IEL_C3(x) (IEL_C2(x) ? (DW3(x)<=DW3(IEL_ext1)) : \
                               (DW3(x)<DW3(IEL_ext1)))


#define IEL_R_C0(x) (DW0(x) < DW0(IEL_ext1))
#define IEL_R_C1(x) (IEL_R_C0(x) ? (DW1(x)<=DW1(IEL_ext1)) : \
                               (DW1(x)<DW1(IEL_ext1)))
#define IEL_R_C2(x) (IEL_R_C1(x) ? ((sizeof(x) == sizeof(U128)) ? \
                                   (DW2_1(x)<=DW2(IEL_ext1)) : 1) : \
                               (DW2(x)<DW2(IEL_ext1)))
#define IEL_R_C3(x) (IEL_R_C2(x) ? ((sizeof(x) == sizeof(U128)) ? \
                                   (DW3_1(x)<=DW3(IEL_ext1)) : 1) : \
                               (DW3(x)<DW3(IEL_ext1)))


#define IEL_ADDU(x, y, z)   ((sizeof(x)==4)?\
                                (IEL_t1=DW0(y),(x).dw0_32=DW0(y)+DW0(z),\
                                 ((IEL_t1>DW0(x))||(DW1(y))||(DW2(y)) ||\
                                (DW3(y))||(DW1(z))||(DW2(z))||(DW3(z)))):\
                             (sizeof(x)==8)?\
                                (IEL_ASSIGNU(IEL_ext1, y),\
                                 (x).dw0_64=DW0(y)+DW0(z),\
                                 (x).dw1_64=DW1(y)+DW1(z)+IEL_C0(x),\
                                 (IEL_C1_1(x)||(DW2(y))||(DW3(y))||\
                                  (DW2(z))||(DW3(z)))):\
                             (sizeof(x)==16)?\
                                (IEL_ASSIGNU(IEL_ext1, y),\
                                 (x).dw0_128=DW0(y)+DW0(z),\
                                 (x).dw1_128=DW1(y)+DW1(z)+IEL_C0(x),\
                                 (x).dw2_128=DW2(y)+DW2(z)+IEL_C1_1(x),\
                                 (x).dw3_128=DW3(y)+DW3(z)+IEL_C2_1(x),\
                                 (IEL_C3_1(x))): IEL_OVFL)


#define IEL_EQU(x, y)       ((DW0(x)==DW0(y)) && (DW1(x)==DW1(y)) && \
                             (DW2(x)==DW2(y)) && (DW3(x)==DW3(y)))
#define IEL_ISZERO(x)       ((DW0(x)==0) && (DW1(x)==0) && (DW2(x)==0) && \
                             (DW3(x)==0))

#define IEL_ISNEG(x)         ((sizeof(x)==4)?\
                                ((DW0(x)&0x80000000)!=0) : \
                             (sizeof(x)==8)?\
                                ((DW1(x) & 0x80000000)!=0) : \
                             (sizeof(x)==16)?\
                                ((DW3(x)&0x80000000)!=0) : IEL_FALSE)

#define IEL_ISNINF(x)        ((sizeof(x) == sizeof(U32)) ? \
                                (DW0(x)==0x80000000) : \
                             (sizeof(x) == sizeof(U64)) ? \
                                (DW1(x)==0x80000000 && DW0(x)==0) : \
                             (sizeof(x) == sizeof(U128)) ? \
                                (DW3(x)==0x80000000 && DW2(x)==0 && \
                                  DW1(x)==0 && DW0(x)==0) : IEL_FALSE)


#define IEL_SEXT(x, y)      (IEL_ASSIGNU(x,y),\
                             ((!IEL_ISNEG(y)) || (sizeof(x)==sizeof(y))) ? \
                             (IEL_OK) : \
                            ((sizeof(x) == sizeof(U64)) ? \
                                ((sizeof(y) == sizeof(U32)) ? \
                                    ((x).dw1_64=IEL_MAX32,IEL_OK):(IEL_OVFL)): \
                            ((sizeof(x) == sizeof(U128)) ? \
                                ((sizeof(y) == sizeof(U32)) ? \
                                    ((x).dw1_128 = IEL_MAX32, \
                                     (x).dw2_128 = IEL_MAX32, \
                                     (x).dw3_128 = IEL_MAX32, IEL_OK) : \
                                (sizeof(y) == sizeof (U64)) ? \
                                    ((x).dw2_128 = IEL_MAX32, \
                                    (x).dw3_128 = IEL_MAX32, IEL_OK):IEL_OVFL):\
                                (IEL_OVFL))))



#define IEL_CMPGU(x, y)     ((sizeof(x) == sizeof(U128)) ? \
                               ((DW3_1(x)>DW3(y)) || \
                               ((DW3(x)==DW3(y)) && (DW2_1(x)>DW2(y))) || \
                               ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                               (DW1_1(x)>DW1(y))) || \
                               ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                               (DW1(x)==DW1(y)) && (DW0(x)>DW0(y)))) : \
                             (sizeof(x) == sizeof(U64)) ? \
                               (((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                               (DW1_1(x)>DW1(y))) || \
                               ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                               (DW1(x)==DW1(y)) && (DW0(x)>DW0(y)))) : \
                         /*  (sizeof(x) == sizeof(U32)) */ \
                               (((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                               (DW1(x)==DW1(y)) && (DW0(x)>DW0(y)))))

#define IEL_CMPGEU(x, y)  ((sizeof(x) == sizeof(U128)) ? \
                              ((DW3_1(x)>DW3(y)) || \
                             ((DW3(x)==DW3(y)) && (DW2_1(x)>DW2(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1_1(x)>DW1(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)==DW1(y)) && (DW0(x)>=DW0(y)))) : \
                           (sizeof(x) == sizeof(U64)) ? \
                              (((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1_1(x)>DW1(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)==DW1(y)) && (DW0(x)>=DW0(y)))) : \
                        /* (sizeof(x) == sizeof(U32)) */  \
                             (((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)==DW1(y)) && (DW0(x)>=DW0(y)))))


/*
#define IEL_CMPGU(x, y)     ((DW3(x)>DW3(y)) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)>DW2(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)>DW1(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)==DW1(y)) && (DW0(x)>DW0(y))))

#define IEL_CMPGEU(x, y)     ((DW3(x)>DW3(y)) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)>DW2(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)>DW1(y))) || \
                             ((DW3(x)==DW3(y)) && (DW2(x)==DW2(y)) && \
                              (DW1(x)==DW1(y)) && (DW0(x)>=DW0(y))))

*/

#define IEL_SHL(x, y, n)        (IEL_t2=n, \
                                 ((n) <=0 || (n) >= (sizeof(x)<<3)) ? \
                                 ((IEL_ISZERO(y)||!(n)) ? \
                                        (IEL_ASSIGNU(x, y), IEL_OK) :\
                                        (IEL_ZERO(x), IEL_OVFL)):\
                             ((sizeof(x) == sizeof (U32)) ? \
                                (IEL_t1 = (DW1(y) || DW2(y) || DW3(y) \
                                 || (DW0(y)>= ((U4byte)1<<(32-IEL_t2)))), \
                                 (x).dw0_32 = DW0(y) << IEL_t2, (IEL_t1)) : \
                              (sizeof(x) == sizeof (U64)) ? \
                                ((n) == 32) ? ((IEL_t1 = DW3(y) || DW2(y)\
                                                 || DW1(y)), \
                                    (x).dw1_64 = DW0(y), \
                                    (x).dw0_64 = 0, \
                                    (IEL_t1)) : \
                                ((n) < 32) ? \
                                    (IEL_t1 = (DW2(y) || DW3(y) || \
                                               (DW1(y)>=((U4byte)1<<(32-IEL_t2)))), \
                                     (x).dw1_64 = DW1(y)<<IEL_t2 | \
                                                DW0(y)>>(32-IEL_t2), \
                                     (x).dw0_64 = DW0(y)<<IEL_t2,(IEL_t1)) :\
                                    (IEL_t1 = (DW1(y) || DW2(y) || DW3(y) ||\
                                             ((DW0(y)>=((U4byte)1<<(64-IEL_t2))))),\
                                     (x).dw1_64 = DW0(y)<<(IEL_t2-32), \
                                     (x).dw0_64 = 0, (IEL_t1)) : \
                               (sizeof(x) == sizeof (U128)) ? \
                                ((n)==32) ? (IEL_t1 = (DW3(y)), \
                                          (x).dw3_128 = DW2(y), \
                                          (x).dw2_128 = DW1(y), \
                                          (x).dw1_128 = DW0(y), \
                                          (x).dw0_128 = 0, (IEL_t1!=0)) : \
                                ((n)==64) ? (IEL_t1 = (DW3(y) || DW2(y)),\
                                          (x).dw3_128 = DW1(y), \
                                          (x).dw2_128 = DW0(y), \
                                          (x).dw1_128 = 0, \
                                          (x).dw0_128 = 0, (IEL_t1)) : \
                                ((n)==96) ? (IEL_t1 = (DW3(y) || DW2(y)  \
                                                    || DW1(y)), \
                                          (x).dw3_128 = DW0(y), \
                                          (x).dw2_128 = 0, \
                                          (x).dw1_128 = 0, \
                                          (x).dw0_128 = 0, (IEL_t1)) : \
                                ((n)>96) ? \
                                    (IEL_t1 = (DW1(y) || DW2(y) || DW3(y) ||\
                                       ((DW0(y)>=((U4byte)1<<(128-IEL_t2))))), \
                                     (x).dw3_128 = DW0(y)<<(IEL_t2-96), \
                                     (x).dw2_128 = 0, \
                                     (x).dw1_128 = 0, \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                ((n)>64) ? \
                                    (IEL_t1 = (DW2(y) || DW3(y) || \
                                              ((DW1(y)>=(U4byte)1<<(96-IEL_t2)))),\
                                     (x).dw3_128 = DW1(y)<<(IEL_t2-64) | \
                                                    DW0(y)>>(96-IEL_t2),\
                                     (x).dw2_128 = DW0(y)<<(IEL_t2-64), \
                                     (x).dw1_128 = 0, \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                ((n)>32) ?  \
                                    (IEL_t1 = (DW3(y) || ((IEL_t2!=32) & \
                                                 (DW2(y)>=(U4byte)1<<(64-IEL_t2)))),\
                                     (x).dw3_128 = DW2(y)<<(IEL_t2-32) | \
                                                    DW1(y)>>(64-IEL_t2),\
                                     (x).dw2_128 = DW1(y)<<(IEL_t2-32) | \
                                                    DW0(y)>>(64-IEL_t2),\
                                     (x).dw1_128 = DW0(y)<<(IEL_t2-32), \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                    (IEL_t1 = (DW3(y)>=(U4byte)1<<(32-IEL_t2)), \
                                     (x).dw3_128 = DW3(y)<<(IEL_t2) | \
                                                    DW2(y)>>(32-IEL_t2),\
                                     (x).dw2_128 = DW2(y)<<(IEL_t2) | \
                                                    DW1(y)>>(32-IEL_t2),\
                                     (x).dw1_128 = DW1(y)<<(IEL_t2) | \
                                                    DW0(y)>>(32-IEL_t2),\
                                     (x).dw0_128 = DW0(y)<<IEL_t2, \
                                     (IEL_t1)) : (IEL_OVFL)))

#define IEL_SHL128(x, y, n)     (IEL_t2=(n), \
                               (sizeof(x) == sizeof (U128)) ? \
                                ((n)==32) ? (IEL_t1 = (U4byte)(DW3(y)), \
                                          (x).dw3_128 = (U4byte)DW2(y), \
                                          (x).dw2_128 = (U4byte)DW1(y), \
                                          (x).dw1_128 = (U4byte)DW0(y), \
                                          (x).dw0_128 = 0, (IEL_t1!=0)) : \
                                ((n)==64) ? (IEL_t1 = (U4byte)(DW3(y) || DW2(y)),\
                                          (x).dw3_128 = (U4byte)DW1(y), \
                                          (x).dw2_128 = (U4byte)DW0(y), \
                                          (x).dw1_128 = 0, \
                                          (x).dw0_128 = 0, (IEL_t1)) : \
                                ((n)==96) ? (IEL_t1 = (U4byte)(DW3(y) || DW2(y)  \
                                                    || DW1(y)), \
                                          (x).dw3_128 = (U4byte)DW0(y), \
                                          (x).dw2_128 = 0, \
                                          (x).dw1_128 = 0, \
                                          (x).dw0_128 = 0, (IEL_t1)) : \
                                ((n)>96) ? \
                                    (IEL_t1 = (U4byte)(DW1(y) || DW2(y) || DW3(y) ||\
                                       ((DW0(y)>=((U4byte)1<<(128-IEL_t2))))), \
                                     (x).dw3_128 = (U4byte)DW0(y)<<(IEL_t2-96), \
                                     (x).dw2_128 = 0, \
                                     (x).dw1_128 = 0, \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                ((n)>64) ? \
                                    (IEL_t1 = (U4byte)(DW2(y) || DW3(y) || \
                                              ((DW1(y)>=(U4byte)1<<(96-IEL_t2)))),\
                                     (x).dw3_128 = (U4byte)DW1(y)<<(IEL_t2-64) | \
                                                    DW0(y)>>(96-IEL_t2),\
                                     (x).dw2_128 = (U4byte)DW0(y)<<(IEL_t2-64), \
                                     (x).dw1_128 = 0, \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                ((n)>32) ?  \
                                    (IEL_t1 = (U4byte)(DW3(y) || ((IEL_t2!=32) & \
                                                 (DW2(y)>=(U4byte)1<<(64-IEL_t2)))),\
                                     (x).dw3_128 = (U4byte)DW2(y)<<(IEL_t2-32) | \
                                                    DW1(y)>>(64-IEL_t2),\
                                     (x).dw2_128 = (U4byte)DW1(y)<<(IEL_t2-32) | \
                                                    DW0(y)>>(64-IEL_t2),\
                                     (x).dw1_128 = (U4byte)DW0(y)<<(IEL_t2-32), \
                                     (x).dw0_128 = 0, \
                                     (IEL_t1)) : \
                                    (IEL_t1 = (U4byte)(DW3(y)>=(U4byte)1<<(32-IEL_t2)), \
                                     (x).dw3_128 = (U4byte)DW3(y)<<(IEL_t2) | \
                                                    DW2(y)>>(32-IEL_t2),\
                                     (x).dw2_128 = (U4byte)DW2(y)<<(IEL_t2) | \
                                                    DW1(y)>>(32-IEL_t2),\
                                     (x).dw1_128 = (U4byte)DW1(y)<<(IEL_t2) | \
                                                    DW0(y)>>(32-IEL_t2),\
                                     (x).dw0_128 = (U4byte)DW0(y)<<IEL_t2, \
                                     (IEL_t1)) : (IEL_OVFL))


#define IEL_INL(x, n)           (((((U4byte)1<<n)-1) & x))
#define IEL_INH(x, n)       (x>>n)
#define IEL_SHR(x, y, n)    (IEL_t2=n,                              \
                                ((n) <=0) ? \
                                 ((IEL_ISZERO(y)||!(n)) ? \
                                        (IEL_ASSIGNU(x, y), IEL_OK) :\
                                        (IEL_ZERO(x), IEL_OVFL)): \
                               ((sizeof(x) == sizeof (U32)) ? \
                                ((n)==32) ? \
                                          ((x).dw0_32 = DW1(y), \
                                           (DW3(y) || DW2(y))) : \
                                ((n)==64) ?  \
                                          ((x).dw0_32 = DW2(y), \
                                           (DW3(y)!=0)) : \
                                ((n)==96) ? \
                                          ((x).dw0_32 = DW3(y), \
                                           (IEL_OK)) : \
                                ((n)>96) ? \
                                     ((x).dw0_32 = DW3(y)>>(IEL_t2-96), \
                                      (IEL_OK)) : \
                                ((n)>64) ? \
                                     ((x).dw0_32 = ((DW2(y)>>(IEL_t2-64))| \
                                                  (DW3(y)<<(96-IEL_t2))),\
                                      ((DW3(y)>>(IEL_t2-64))!=0)) : \
                                ((n)>32) ?  \
                                     ((x).dw0_32 = ((DW1(y)>>(IEL_t2-32))| \
                                                   (DW2(y)<<(64-IEL_t2))), \
                                      ((DW2(y)>>(IEL_t2-32)) || DW3(y))) :  \
                                    ((x).dw0_32 = DW0(y)>>(IEL_t2) | \
                                                    DW1(y)<<(32-IEL_t2),\
                                     (DW3(y) || DW2(y) ||DW1(y)>>(IEL_t2))) : \
                               (sizeof(x) == sizeof (U64)) ? \
                                ((n)==32) ? \
                                          ((x).dw0_64 = DW1(y), \
                                           (x).dw1_64 = DW2(y), \
                                           (DW3(y)!=0)) : \
                                ((n)==64) ?  \
                                          ((x).dw0_64 = DW2(y), \
                                           (x).dw1_64 = DW3(y), \
                                           (IEL_OK)) : \
                                ((n)==96) ? \
                                          ((x).dw0_64 = DW3(y), \
                                           (x).dw1_64 = 0, \
                                           (IEL_OK)) : \
                                ((n)>96) ? \
                                     ((x).dw0_64 = DW3(y)>>(IEL_t2-96), \
                                      (x).dw1_64 = 0, \
                                      (IEL_OK)) : \
                                ((n)>64) ? \
                                     ((x).dw0_64 = ((DW2(y)>>(IEL_t2-64))| \
                                                  (DW3(y)<<(96-IEL_t2))),\
                                      (x).dw1_64 = DW3(y)>>(IEL_t2-64), \
                                      (IEL_OK)) : \
                                ((n)>32) ?  \
                                     ((x).dw0_64 = ((DW1(y)>>(IEL_t2-32))| \
                                                   (DW2(y)<<(64-IEL_t2))), \
                                      (x).dw1_64 = ((DW2(y)>>(IEL_t2-32))| \
                                                   (DW3(y)<<(64-IEL_t2))),\
                                      (DW3(y)>>(IEL_t2-32) != 0)) :  \
                                    ((x).dw0_64 = DW0(y)>>(IEL_t2) | \
                                                    DW1(y)<<(32-IEL_t2),\
                                     (x).dw1_64 = DW1(y)>>(IEL_t2) | \
                                                    DW2(y)<<(32-IEL_t2),\
                                     (DW3(y) || DW2(y)>>(IEL_t2))) : \
                               (sizeof(x) == sizeof (U128)) ? \
                                ((n)==32) ? \
                                          ((x).dw0_128 = DW1(y), \
                                           (x).dw1_128 = DW2(y), \
                                           (x).dw2_128 = DW3(y), \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)==64) ?  \
                                          ((x).dw0_128 = DW2(y), \
                                           (x).dw1_128 = DW3(y), \
                                           (x).dw2_128 = 0, \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)==96) ? \
                                          ((x).dw0_128 = DW3(y), \
                                           (x).dw1_128 = 0, \
                                           (x).dw2_128 = 0, \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)>96) ? \
                                     ((x).dw0_128 = DW3(y)>>(IEL_t2-96), \
                                      (x).dw1_128 = 0, \
                                      (x).dw2_128 = 0, \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                ((n)>64) ? \
                                     ((x).dw0_128 = ((DW2(y)>>(IEL_t2-64))| \
                                                  (DW3(y)<<(96-IEL_t2))),\
                                      (x).dw1_128 = DW3(y)>>(IEL_t2-64), \
                                      (x).dw2_128 = 0, \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                ((n)>32) ?  \
                                     ((x).dw0_128 = ((DW1(y)>>(IEL_t2-32))| \
                                                   (DW2(y)<<(64-IEL_t2))), \
                                      (x).dw1_128 = ((DW2(y)>>(IEL_t2-32))| \
                                                   (DW3(y)<<(64-IEL_t2))),\
                                      (x).dw2_128 = DW3(y)>>(IEL_t2-32), \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                    ((x).dw0_128 = DW0(y)>>(IEL_t2) | \
                                                    DW1(y)<<(32-IEL_t2),\
                                     (x).dw1_128 = DW1(y)>>(IEL_t2) | \
                                                    DW2(y)<<(32-IEL_t2),\
                                     (x).dw2_128 = DW2(y)>>(IEL_t2) | \
                                                    DW3(y)<<(32-IEL_t2),\
                                     (x).dw3_128 = DW3(y)>>IEL_t2, \
                                     (IEL_OK)) : (IEL_OVFL)))

#define IEL_SHR128(x, y, n) (IEL_t2=n,                              \
                                ((n) <=0) ? \
                                 ((IEL_ISZERO(y)||!(n)) ? \
                                        (IEL_ASSIGNU(x, y), IEL_OK) :\
                                        (IEL_ZERO(x), IEL_OVFL)): \
                               (sizeof(x) == sizeof (U128)) ? \
                                ((n)==32) ? \
                                          ((x).dw0_128 = DW1(y), \
                                           (x).dw1_128 = DW2(y), \
                                           (x).dw2_128 = DW3(y), \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)==64) ?  \
                                          ((x).dw0_128 = DW2(y), \
                                           (x).dw1_128 = DW3(y), \
                                           (x).dw2_128 = 0, \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)==96) ? \
                                          ((x).dw0_128 = DW3(y), \
                                           (x).dw1_128 = 0, \
                                           (x).dw2_128 = 0, \
                                           (x).dw3_128 = 0, (IEL_OK)) : \
                                ((n)>96) ? \
                                     ((x).dw0_128 = DW3(y)>>(IEL_t2-96), \
                                      (x).dw1_128 = 0, \
                                      (x).dw2_128 = 0, \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                ((n)>64) ? \
                                     ((x).dw0_128 = ((DW2(y)>>(IEL_t2-64))| \
                                                  (DW3(y)<<(96-IEL_t2))),\
                                      (x).dw1_128 = DW3(y)>>(IEL_t2-64), \
                                      (x).dw2_128 = 0, \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                ((n)>32) ?  \
                                     ((x).dw0_128 = ((DW1(y)>>(IEL_t2-32))| \
                                                   (DW2(y)<<(64-IEL_t2))), \
                                      (x).dw1_128 = ((DW2(y)>>(IEL_t2-32))| \
                                                   (DW3(y)<<(64-IEL_t2))),\
                                      (x).dw2_128 = DW3(y)>>(IEL_t2-32), \
                                      (x).dw3_128 = 0, \
                                      (IEL_OK)) : \
                                    ((x).dw0_128 = DW0(y)>>(IEL_t2) | \
                                                    DW1(y)<<(32-IEL_t2),\
                                     (x).dw1_128 = DW1(y)>>(IEL_t2) | \
                                                    DW2(y)<<(32-IEL_t2),\
                                     (x).dw2_128 = DW2(y)>>(IEL_t2) | \
                                                    DW3(y)<<(32-IEL_t2),\
                                     (x).dw3_128 = DW3(y)>>IEL_t2, \
                                     (IEL_OK)) : (IEL_OVFL))




#ifndef IEL_USE_FUNCTIONS
#define IEL_ADDS(x, y, z)   (IEL_ASSIGNS(IEL_ext4, y), \
                             IEL_ASSIGNS(IEL_ext2, z), \
                             IEL_ADDU (IEL_ext3, IEL_ext4, IEL_ext2), \
                             ((IEL_ISNEG(IEL_ext4) && IEL_ISNEG(IEL_ext2) && \
                               (!(IEL_ISNEG(IEL_ext3)))) | \
                              ((!(IEL_ISNEG(IEL_ext4))) && \
                               (!(IEL_ISNEG(IEL_ext2))) && \
                               IEL_ISNEG(IEL_ext3))  | \
                              (IEL_ASSIGNS(x, IEL_ext3))))
#else

#define IEL_ADDU128(x, y, z) (IEL_ASSIGNU(IEL_ext1, y),\
                                (x).dw0_128=DW0(y)+DW0(z),\
                                 (x).dw1_128=DW1(y)+DW1(z)+IEL_C0(x),\
                                 (x).dw2_128=DW2(y)+DW2(z)+IEL_C1(x),\
                                 (x).dw3_128=DW3(y)+DW3(z)+IEL_C2(x),\
                                 (IEL_C3(x)))
#define IEL_ISNEG128(x)      ((DW3(x)&0x80000000)!=0)

#define IEL_ADDS(x, y, z)   (IEL_ASSIGNS(IEL_ext4, y), \
                             IEL_ASSIGNS(IEL_ext2, z), \
                             IEL_ADDU128 (IEL_ext3, IEL_ext4, IEL_ext2), \
                             ((IEL_ISNEG128(IEL_ext4) && \
                               IEL_ISNEG128(IEL_ext2) && \
                               (!(IEL_ISNEG128(IEL_ext3)))) | \
                              ((!(IEL_ISNEG128(IEL_ext4))) && \
                               (!(IEL_ISNEG128(IEL_ext2))) && \
                               IEL_ISNEG128(IEL_ext3))  | \
                              (IEL_ASSIGNS(x, IEL_ext3))))

#endif 

#endif /*** not LP64 ***/

#define IEL_SEXT64(x)   ((x).dw1_64 = ((x).dw0_64 & 0x80000000) ? -1 : 0)
/* common for lp32 and lp64 */
#define IEL_CONVERT4(x, y0, y1, y2, y3) \
                            ((sizeof(x) == sizeof(U32)) ? \
                                ((x).dw0_32 = y0, y1 || y2 || y3) : \
                             (sizeof(x) == sizeof(U64)) ? \
                                ((x).dw0_64 = y0, \
                                 (x).dw1_64 = y1, \
                                 y2 || y3) :\
                             (sizeof(x) == sizeof(U128)) ? \
                                ((x).dw0_128 = y0, \
                                 (x).dw1_128 = y1, \
                                 (x).dw2_128 = y2, \
                                 (x).dw3_128 = y3, \
                                 IEL_OK) : IEL_OVFL)

#define IEL_CONVERT2(x, y0, y1) IEL_CONVERT4(x, y0, y1, 0, 0)
#define IEL_CONVERT1(x, y0)     IEL_CONVERT4(x, y0, 0, 0, 0)
#define IEL_CONVERT IEL_CONVERT4

#define IEL_COMP(x, y) (IEL_NOT(x, y), IEL_INCU(x), IEL_OK)
#define IEL_COMPLEMENTS(x, y) (IEL_ASSIGNS(IEL_ts1, y), \
                              IEL_COMP(IEL_ts1, IEL_ts1), \
                              IEL_ASSIGNS(x, IEL_ts1))

#define IEL_CMPEU(x, y)  IEL_EQU(x, y)
#define IEL_CMPNEU(x, y) (!(IEL_EQU(x, y)))
#define IEL_CMPLU(x, y) IEL_CMPGU(y, x)
#define IEL_CMPLEU(x, y) IEL_CMPGEU(y, x)
#define IEL_CMPU(x, y)  (IEL_CMPGU(x, y)-IEL_CMPLU(x, y))
#define IEL_SUBU(x, y, z) (IEL_ISZERO(z) ? IEL_ASSIGNU(x, y) : \
                           (IEL_COMP(IEL_ext2 ,z), \
                           (!(IEL_ADDU(x, y,IEL_ext2)))))


#define IEL_SUBS(x, y, z)   (IEL_ISZERO(z) ? IEL_ASSIGNS(x, y) : \
                             (IEL_ASSIGNS(IEL_ext5, z), \
                             IEL_COMP(IEL_ext5,IEL_ext5),\
                             IEL_ADDS(x, y, IEL_ext5)||IEL_ISNINF(IEL_ext5)))

#define IEL_CMPES(x, y)     (IEL_ASSIGNS(IEL_ts1, x), \
                             IEL_ASSIGNS(IEL_ts2, y), \
                             IEL_CMPEU(IEL_ts1, IEL_ts2))

#define IEL_CMPNES(x, y)    (!(IEL_CMPES(x, y)))

#define IEL_CMPGS(x, y)     (((IEL_ISNEG(x)) && (!(IEL_ISNEG(y)))) ? (0) : \
                             ((!(IEL_ISNEG(x))) && (IEL_ISNEG(y))) ? (1) : \
                             (IEL_ASSIGNS(IEL_ext3, x), \
                             IEL_ASSIGNS(IEL_ext4, y), \
                             IEL_CMPGU(IEL_ext3, IEL_ext4)))

#define IEL_CMPGES(x, y)    (IEL_CMPGS(x, y) || IEL_CMPES(x, y))
#define IEL_CMPLES(x, y)    IEL_CMPGES(y, x)
#define IEL_CMPLS(x, y)     IEL_CMPGS(y, x)
#define IEL_CMPS(x, y)      (IEL_CMPGS(x, y)-IEL_CMPLS(x, y))
#define IEL_CHECKU(x, n)    (!IEL_SHL128(IEL_ext1, x, 128-(n)))
#define IEL_CHECKS(x, n)    ((IEL_ISNEG(x)) ? \
                                (IEL_ASSIGNS(IEL_ts1, x), \
                                IEL_COMP(IEL_ts1, IEL_ts1), \
                                !((IEL_SHL128(IEL_ts1, IEL_ts1, 128-(n))) || \
                                (IEL_ISNEG(IEL_ts1)&&(!IEL_ISNINF(IEL_ts1))))):\
                                (!(IEL_SHL128(IEL_ts1, x, 128-(n)) || \
                                IEL_ISNEG(IEL_ts1))))

#define IEL_SAR(x, y, n)  (IEL_ISNEG(y) ? \
                           (IEL_SEXT(IEL_ext4, y), (IEL_SHR(x, IEL_ext4, n),  \
                            IEL_SHL(IEL_ext5, IEL_MINUS1, 128-n),  \
                            IEL_OR(IEL_ext5, x, IEL_ext5) , \
                            ((IEL_ASSIGNS(x,IEL_ext5))||(n>=(sizeof(x)<<3))))) \
                            : IEL_SHR(x, y, n))

#define IEL_MULU(x, y, z)   (IEL_ASSIGNU (IEL_ext2, y), \
                             IEL_ASSIGNU (IEL_ext3, z), \
                             (IEL_t4=IEL_mul(&IEL_ext1,&IEL_ext2,&IEL_ext3),\
                              IEL_ASSIGNU (x, IEL_ext1) || IEL_t4))
#define IEL_MULS(x, y, z)    (IEL_ASSIGNS (IEL_ext2, y), \
                             IEL_ASSIGNS (IEL_ext3, z), \
                             IEL_t3 = IEL_ISNEG(y)^IEL_ISNEG(z), \
                             (IEL_ISNEG(IEL_ext2)) ? \
                                IEL_COMP(IEL_ext2, IEL_ext2) : (0),\
                             (IEL_ISNEG(IEL_ext3)) ? \
                                IEL_COMP(IEL_ext3, IEL_ext3) : (0),\
                             IEL_t2 = \
                                (IEL_mul(&IEL_ext1, &IEL_ext2, &IEL_ext3) ||\
                                 (IEL_ISNEG(IEL_ext1) && \
                                  (!IEL_ISNINF(IEL_ext1)))), \
                             IEL_t3 ? IEL_COMP(IEL_ext1,IEL_ext1):(0),\
                             (IEL_ASSIGNS(x,IEL_ext1) || IEL_t2))
#define IEL_DIVU(x, y, z)   (IEL_ISZERO(z) ? (IEL_ASSIGNU(x,IEL_POSINF), \
                                              IEL_OVFL):\
                            (IEL_ASSIGNU (IEL_ext2, y), \
                             IEL_ASSIGNU (IEL_ext3, z), \
                             (IEL_t4=IEL_div(&IEL_ext1,&IEL_ext2,&IEL_ext3),\
                              IEL_ASSIGNU (x, IEL_ext1) || IEL_t4)))
#define IEL_DIVS(x, y, z)   (IEL_ISZERO(z) ? ((IEL_ISNEG(y)) ? \
                            IEL_ASSIGNU(IEL_ext2, IEL_NEGINF): \
                            IEL_ASSIGNU(IEL_ext2, IEL_POSINF)\
                            , IEL_ASSIGNU(x, IEL_ext2), IEL_OVFL) :\
                             (IEL_ASSIGNS (IEL_ext2, y), \
                             IEL_ASSIGNS (IEL_ext3, z), \
                             IEL_t3 = IEL_ISNEG(y)^IEL_ISNEG(z), \
                             (IEL_ISNEG(IEL_ext2)) ? \
                                IEL_COMP(IEL_ext2, IEL_ext2) : (0),\
                             (IEL_ISNEG(IEL_ext3)) ? \
                                IEL_COMP(IEL_ext3, IEL_ext3) : (0),\
                             IEL_t2 = \
                                (IEL_div(&IEL_ext1, &IEL_ext2, &IEL_ext3) ||\
                                 (IEL_ISNEG(IEL_ext1) && (!IEL_t3))), \
                             IEL_t3 ? IEL_COMP(IEL_ext1,IEL_ext1):(0),\
                             (IEL_ASSIGNS(x,IEL_ext1) || IEL_t2)))

#define IEL_REMU(x, y, z)   (IEL_ASSIGNU (IEL_ext2, y), \
                             IEL_ASSIGNU (IEL_ext3, z), \
                             (IEL_t1 = IEL_rem(&IEL_ext1, &IEL_ext2, &IEL_ext3), \
                              IEL_t2 = IEL_ASSIGNU (x, IEL_ext1), IEL_t1||IEL_t2))
#define IEL_REMS(x, y, z)    (IEL_ASSIGNS (IEL_ext2, y), \
                             IEL_ASSIGNS (IEL_ext3, z), \
                             IEL_t3 = IEL_ISNEG(y), \
                             (IEL_ISNEG(IEL_ext2)) ? \
                                IEL_COMP(IEL_ext2, IEL_ext2) : (0),\
                             (IEL_ISNEG(IEL_ext3)) ? \
                                IEL_COMP(IEL_ext3, IEL_ext3) : (0),\
                             IEL_t2 = \
                                (IEL_rem(&IEL_ext1, &IEL_ext2, &IEL_ext3)|| \
                                 IEL_ISNEG(IEL_ext1)), \
                             IEL_t3 ? IEL_COMP(IEL_ext1,IEL_ext1):(0),\
                             (IEL_ASSIGNS(x,IEL_ext1) || IEL_t2))




/**** INT64.H MACROS ****/

#ifdef IEL_INT64

#define INCU64(x)           (IEL_INCU(IEL64(x)), (x))
#define DECU64(x)           (IEL_DECU(IEL64(x)), (x))
#define ADDU64(x, y, t)     (IEL_ADDU(IEL64(x), IEL64(x), IEL64(y)), (x))
#define SUBU64(x, y, t)     (IEL_SUBU(IEL64(x), IEL64(x), IEL64(y)), (x))
#define ANDNOT64(x, y)      (IEL_ANDNOT(IEL64(x), IEL64(x), IEL64(y)),(x))
#define AND64NOT32(x, y)    (IEL_ANDNOT(IEL64(x), IEL64(x), IEL32(y)),(x))
#define ANDU64(x, y)        (IEL_AND(IEL64(x), IEL64(x), IEL64(y)), (x))
#define ORU64(x, y)         (IEL_OR(IEL64(x), IEL64(x), IEL64(y)), (x))
#define NOTU64(x)           (IEL_NOT(IEL64(x), IEL64(x)), (x))
#define ZU64(x)             (IEL_ZERO(IEL64(x)), (x))
#define INIT64(x, y)        (IEL_CONVERT1(x, y), (x))
#define CONST64(x)          IEL_CONST64(x, 0)
#define SCONST64(x)         IEL_CONST64(x, x>>31)
#define CONST64_64(x, y)    IEL_CONST64(y, x)
#define ISZERO64(x)         (IEL_ISZERO(IEL64(x)))
#define EQU64(x, y)         (IEL_EQU(IEL64(x), IEL64(y)))
#define LEU64(x, y)         (IEL_CMPLEU(IEL64(x), IEL64(y)))
#define LU64(x, y)          (IEL_CMPLU(IEL64(x), IEL64(y)))
#define LSU64(x, y)         (IEL_CMPLS(IEL64(x), IEL64(y)))
#define GEU64(x, y)         (IEL_CMPGEU(IEL64(x), IEL64(y)))
#define GU64(x, y)          (IEL_CMPGU(IEL64(x), IEL64(y)))
#define CMP64(x, y, t)      (IEL_CMPU(IEL64(x), IEL64(y)))
#define SHL64(x, y)         (IEL_SHL(IEL64(x), IEL64(x), y), (x))
#define ISNEG(x)            (IEL_ISNEG(IEL64(x)))
#define SEXT64(x)           ((x).dw1_64 = ((x).dw0_64 & 0x80000000) ? -1 : 0)
#define CMP128(x, y, t)     (IEL_CMPU(IEL128(x), IEL128(y)))
#define EQU128(x, y)        (IEL_EQU(IEL128(x), IEL128(y)))
#define LU64TU32(a, b)      (IEL_CMPLU(IEL64(a), IEL32(b)))
#define LU64EU32(a,b)       (IEL_CMPLEU(IEL64(a), IEL32(b)))
#define GU64TU32(a,b)       (IEL_CMPGU(IEL64(a), IEL32(b)))
#define GU64EU32(a,b)       (IEL_CMPGEU(IEL64(a), IEL32(b)))
#define GU64_32(a,b)        (GU64TU32(a, b))
#define INITL64(x, y, z)    (IEL_CONVERT2(x, z, y), (IEL64(x)))
 
#ifdef LP64
#   define ADD2U64(x, y)    ADDU64(x, y, 0)
#   define SUB2U64(x, y)    SUBU64(x, y, 0)
#   define LOWER32(x)   (*(int*)(&x) & 0x00000000ffffffff)
#   define HIGHER32(x)  (*(int*)(&x)>>32)
#else /*** LP64 ***/
#   define ADD2U64(x, y) ((x).low+=(y), (x).high += ((x).low < (y)), (x))
#   define SUB2U64(x, y) ( (x).high -= ((x).low < (y)),(x).low-=(y), (x))
#   define LOWER32(x)           (IEL_GETDW0(IEL64(x)))
#   define HIGHER32(x)          (IEL_GETDW1(IEL64(x)))
#endif /*** LP64 ***/
#endif /*** IEL_INT64 ***/


#ifndef LP64
/* In order to decrease the macro expansion space */

#ifdef IEL_USE_FUNCTIONS 

#ifdef __cplusplus
extern "C" {
#endif

int IEL_au(void *x, void *y, int sx, int sy);
int IEL_c0(void *x, int sx);
int IEL_c1(void *x, int sx);
int IEL_c2(void *x, int sx);
int IEL_c3(void *x, int sx);
IEL_Err IEL_as(void *x, void *y, int sx, int sy);

#ifdef __cplusplus
}
#endif

#undef IEL_ASSIGNU
#undef IEL_ASSIGNS
#undef IEL_C0
#undef IEL_C1
#undef IEL_C2
#undef IEL_C3

#define IEL_ASSIGNU(x, y)   IEL_au((void *)&(x),(void *)&(y),sizeof(x),sizeof(y))
#define IEL_ASSIGNS(x, y)   IEL_as((void *)&(x),(void *)&(y),sizeof(x),sizeof(y))

#define IEL_C0(x) IEL_c0((void *)&(x),sizeof(x))
#define IEL_C1(x) IEL_c1((void *)&(x),sizeof(x))
#define IEL_C2(x) IEL_c2((void *)&(x),sizeof(x))
#define IEL_C3(x) IEL_c3((void *)&(x),sizeof(x))


#endif /* IEL_USE_FUNCTIONS */


#endif /* LP64 */
/* Prototypes */

#ifdef __cplusplus
extern "C" {
#endif

IEL_Err IEL_mul(U128 *xr, U128 *y, U128 *z);
IEL_Err IEL_rem(U128 *x, U128 *y, U128 *z);
IEL_Err IEL_div(U128 *x, U128 *y, U128 *z);
IEL_Err IEL_U128tostr(const U128 *x, char *strptr, int  base, const unsigned int  length);
IEL_Err IEL_U64tostr(const U64 *x, char *strptr, int  base, const unsigned int  length);
IEL_Err IEL_S128tostr(const S128 *x, char *strptr, int  base,const unsigned int  length);
IEL_Err IEL_S64tostr(const S64 *x, char *strptr, int  base,const unsigned int  length);
IEL_Err  IEL_strtoU128( char *str1, char **endptr, int  base, U128 *x);
IEL_Err  IEL_strtoU64(char *str1, char **endptr, int  base, U64 *x);
IEL_Err  IEL_strtoS128(char *str1, char **endptr, int  base, S128 *x);
IEL_Err  IEL_strtoS64(char *str1, char **endptr, int  base, S64 *x);

#ifdef __cplusplus
}
#endif


/* INT64, inside varibales redefinition */

#ifdef IEL_INT64

#undef low
#define low dw0_64
#undef high
#define high dw1_64
#undef b1st
#undef b2st
#undef b3st
#undef b4st
#define b1st dw0_128
#define b2st dw1_128
#define b3st dw3_128
#define b4st dw4_128

#endif

#endif /**** IEL_H ****/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\checksum.h ===
#define CHECKSUM_OPEN_FAILURE       1
#define CHECKSUM_MAP_FAILURE        2
#define CHECKSUM_MAPVIEW_FAILURE    3

ULONG CheckSum(FILE *, PUCHAR, BOOLEAN, PULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\copypdbx.c ===
#define use_CopyPdbX 1

#include <copypdb.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\checksum.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    checksum.c

Abstract:

    This module implements a function for computing the checksum of an
    image file. It will also compute the checksum of other files as well.

Author:

    David N. Cutler (davec) 21-Mar-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>

//
// Define checksum routine prototype.
//
#ifdef __cplusplus
extern "C"
#endif
USHORT
ChkSum(
    DWORD PartialSum,
    PUSHORT Source,
    DWORD Length
    );

PIMAGE_NT_HEADERS
CheckSumMappedFile (
    LPVOID BaseAddress,
    DWORD FileLength,
    LPDWORD HeaderSum,
    LPDWORD CheckSum
    )

/*++

Routine Description:

    This functions computes the checksum of a mapped file.

Arguments:

    BaseAddress - Supplies a pointer to the base of the mapped file.

    FileLength - Supplies the length of the file in bytes.

    HeaderSum - Suppllies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    None.

--*/

{

    PUSHORT AdjustSum;
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT PartialSum;
    PBYTE pbyte;

    //
    // Compute the checksum of the file and zero the header checksum value.
    //

    *HeaderSum = 0;
    PartialSum = ChkSum(0, (PUSHORT)BaseAddress, FileLength >> 1);

    //
    // If the file is an image file, then subtract the two checksum words
    // in the optional header from the computed checksum before adding
    // the file length, and set the value of the header checksum.
    //

    __try {
        NtHeaders = RtlpImageNtHeader(BaseAddress);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        NtHeaders = NULL;
    }

    if ((NtHeaders != NULL) && (NtHeaders != BaseAddress)) {
        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            *HeaderSum = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum;
            AdjustSum = (PUSHORT)(&((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum);
        } else
        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            *HeaderSum = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum;
            AdjustSum = (PUSHORT)(&((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum);
        } else {
            return(NULL);
        }
        PartialSum -= (PartialSum < AdjustSum[0]);
        PartialSum -= AdjustSum[0];
        PartialSum -= (PartialSum < AdjustSum[1]);
        PartialSum -= AdjustSum[1];
    }

    // add the last byte, if needed

    if (FileLength % 2) {
        pbyte = (PBYTE)BaseAddress + FileLength - 1;
        PartialSum += *pbyte;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xFFFF); 
    }

    //
    // Compute the final checksum value as the sum of the paritial checksum
    // and the file length.
    //

    *CheckSum = (DWORD)PartialSum + FileLength;
    return NtHeaders;
}

DWORD
MapFileAndCheckSumW(
    PWSTR Filename,
    LPDWORD HeaderSum,
    LPDWORD CheckSum
    )

/*++

Routine Description:

    This functions maps the specified file and computes the checksum of
    the file.

Arguments:

    Filename - Supplies a pointer to the name of the file whose checksum
        is computed.

    HeaderSum - Supplies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    0 if successful, else error number.

--*/

{
#ifndef UNICODE_RULES
    CHAR   FileNameA[ MAX_PATH ];

    //  Convert the file name to Ansi and call the Ansi version
    //  of this function.

    if (WideCharToMultiByte(
                    CP_ACP,
                    0,
                    Filename,
                    -1,
                    FileNameA,
                    MAX_PATH,
                    NULL,
                    NULL ) ) {

        return MapFileAndCheckSumA(FileNameA, HeaderSum, CheckSum);
    }

    return CHECKSUM_UNICODE_FAILURE;

#else  // UNICODE_RULES

    HANDLE FileHandle, MappingHandle;
    LPVOID BaseAddress;
    DWORD FileLength;

    //
    // Open the file for read access
    //

    FileHandle = CreateFileW(
                        Filename,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        return CHECKSUM_OPEN_FAILURE;
    }

    //
    //  Create a file mapping, map a view of the file into memory,
    //  and close the file mapping handle.
    //

    MappingHandle = CreateFileMapping(FileHandle,
                                      NULL,
                                      PAGE_READONLY,
                                      0,
                                      0,
                                      NULL);

    if (!MappingHandle) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAP_FAILURE;
    }

    //
    // Map a view of the file
    //

    BaseAddress = MapViewOfFile(MappingHandle, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(MappingHandle);
    if (BaseAddress == NULL) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAPVIEW_FAILURE;
    }

    //
    // Get the length of the file in bytes and compute the checksum.
    //
    FileLength = GetFileSize( FileHandle, NULL );
    CheckSumMappedFile(BaseAddress, FileLength, HeaderSum, CheckSum);

    //
    // Unmap the view of the file and close file handle.
    //

    UnmapViewOfFile(BaseAddress);
    CloseHandle( FileHandle );
    return CHECKSUM_SUCCESS;

#endif  // UNICODE_RULES
}


ULONG
MapFileAndCheckSumA (
    LPSTR Filename,
    LPDWORD HeaderSum,
    LPDWORD CheckSum
    )

/*++

Routine Description:

    This functions maps the specified file and computes the checksum of
    the file.

Arguments:

    Filename - Supplies a pointer to the name of the file whose checksum
        is computed.

    HeaderSum - Supplies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    0 if successful, else error number.

--*/

{
#ifdef UNICODE_RULES
    WCHAR   FileNameW[ MAX_PATH ];

    //
    //  Convert the file name to unicode and call the unicode version
    //  of this function.
    //

    if (MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    Filename,
                    -1,
                    FileNameW,
                    MAX_PATH ) ) {

        return MapFileAndCheckSumW(FileNameW, HeaderSum, CheckSum);

    }

    return CHECKSUM_UNICODE_FAILURE;

#else   // UNICODE_RULES

    HANDLE FileHandle, MappingHandle;
    LPVOID BaseAddress;
    DWORD FileLength;

    //
    // Open the file for read access
    //

    FileHandle = CreateFileA(
                        Filename,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        return CHECKSUM_OPEN_FAILURE;
    }

    //
    //  Create a file mapping, map a view of the file into memory,
    //  and close the file mapping handle.
    //

    MappingHandle = CreateFileMapping(FileHandle,
                                      NULL,
                                      PAGE_READONLY,
                                      0,
                                      0,
                                      NULL);

    if (!MappingHandle) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAP_FAILURE;
    }

    //
    // Map a view of the file
    //

    BaseAddress = MapViewOfFile(MappingHandle, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(MappingHandle);
    if (BaseAddress == NULL) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAPVIEW_FAILURE;
    }

    //
    // Get the length of the file in bytes and compute the checksum.
    //
    FileLength = GetFileSize( FileHandle, NULL );
    CheckSumMappedFile(BaseAddress, FileLength, HeaderSum, CheckSum);

    //
    // Unmap the view of the file and close file handle.
    //

    UnmapViewOfFile(BaseAddress);
    CloseHandle( FileHandle );
    return CHECKSUM_SUCCESS;

#endif   // UNICODE_RULES
}


BOOL
TouchFileTimes(
    HANDLE FileHandle,
    LPSYSTEMTIME lpSystemTime
    )
{
    SYSTEMTIME SystemTime;
    FILETIME SystemFileTime;

    if (lpSystemTime == NULL) {
        lpSystemTime = &SystemTime;
        GetSystemTime( lpSystemTime );
        }

    if (SystemTimeToFileTime( lpSystemTime, &SystemFileTime )) {
        return SetFileTime( FileHandle, NULL, NULL, &SystemFileTime );
        }
    else {
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\crt.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    crt.c

Abstract:

    This file implements certain crt apis that are not present in
    libcntpr.lib. This implementation is NOT multi-thread safe.

Author:

    Wesley Witt (wesw) 23-May-1994

Environment:

    User Mode

--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <time.h>
#include <stdio.h>


void * __cdecl
malloc(
    size_t sz
    )
{

    return RtlAllocateHeap( RtlProcessHeap(), 0, sz );

}

void __cdecl
free(
    void * ptr
    )
{

    RtlFreeHeap( RtlProcessHeap(), 0, ptr );

}


char * __cdecl
ctime(
    const time_t *timp
    )
{
    static char    mnames[] = { "JanFebMarAprMayJunJulAugSepOctNovDec" };
    static char    buf[32];

    LARGE_INTEGER  MyTime;
    TIME_FIELDS    TimeFields;


    RtlSecondsSince1970ToTime( (ULONG)*timp, &MyTime );
    RtlSystemTimeToLocalTime( &MyTime, &MyTime );
    RtlTimeToTimeFields( &MyTime, &TimeFields );

    strncpy( buf, &mnames[(TimeFields.Month - 1) * 3], 3 );
    sprintf( &buf[3], " %02d %02d:%02d:%02d %04d",
             TimeFields.Day, TimeFields.Hour, TimeFields.Minute,
             TimeFields.Second, TimeFields.Year );

    return buf;
}


time_t __cdecl
time(
    time_t *timp
    )
{
    time_t         tm;
    LARGE_INTEGER  MyTime;


    NtQuerySystemTime( &MyTime );
    RtlTimeToSecondsSince1970( &MyTime, (PULONG)&tm );

    if (timp) {
        *timp = tm;
    }

    return tm;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\checkfix.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    checkfix.c

Abstract:

    This module recomputes the checksum for an image file.

Author:

    Steven R. Wood (stevewo) 4-May-1993

Revision History:

--*/

#include <private.h>


void Usage()
{
    fprintf( stderr, "usage: CHECKFIX [-?] [-v] [-q] image-names...\n" );
    fprintf( stderr, "              [-?] display this message\n" );
    fprintf( stderr, "              [-v] verbose output\n" );
    fprintf( stderr, "              [-q] quiet on failure\n" );
    exit( 1 );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID BaseAddress;
    ULONG CheckSum;
    ULONG FileLength;
    ULONG HeaderSum;
    ULONG OldCheckSum;
    LPSTR ImageName;
    BOOLEAN fVerbose = FALSE;
    BOOLEAN fQuiet = FALSE;
    LPSTR s;
    UCHAR c;

    if (argc <= 1) {
        Usage();
        }

    while (--argc) {
        s = *++argv;
        if ( *s == '-' ) {
            while (c=*++s) {
                switch (c) {
                    case 'q':
                    case 'Q':
                        fQuiet = TRUE;
                        break;

                    case 'v':
                    case 'V':
                        fVerbose=TRUE;
                        break;

                    case 'h':
                    case 'H':
                    case '?':
                        Usage();

                    default:
                        fprintf( stderr, "VERFIX: illegal option /%c\n", c );
                        Usage();
                    }
                }
            }
        else {
            ImageName = s;
            FileHandle = CreateFile( ImageName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL
                                   );
            if (FileHandle == INVALID_HANDLE_VALUE) {
                if (!fQuiet) {
                    fprintf( stderr, "VERFIX: Unable to open %s (%u) - skipping\n", ImageName, GetLastError() );
                    }
                }
            else {
                }

        MappingHandle = CreateFileMapping( FileHandle,
                                           NULL,
                                           PAGE_READWRITE,
                                           0,
                                           0,
                                           NULL
                                         );
        if (MappingHandle == NULL) {
            CloseHandle( FileHandle );
            if (!fQuiet) {
                fprintf( stderr, "VERFIX: Unable to create mapping object for file %s (%u) - skipping\n", ImageName, GetLastError() );
                }
            }
        else {
            BaseAddress = MapViewOfFile( MappingHandle,
                                         FILE_MAP_READ | FILE_MAP_WRITE,
                                         0,
                                         0,
                                         0
                                       );
            CloseHandle( MappingHandle );
            if (BaseAddress == NULL) {
                CloseHandle( FileHandle );
                if (!fQuiet ) {
                    fprintf( stderr, "VERFIX: Unable to map view of file %s (%u) - skipping\n", ImageName, GetLastError() );
                    }
                }
            else {
                //
                // Get the length of the file in bytes and compute the checksum.
                //

                FileLength = GetFileSize( FileHandle, NULL );

                //
                // Obtain a pointer to the header information.
                //

                NtHeaders = ImageNtHeader( BaseAddress );
                if (NtHeaders == NULL) {
                    CloseHandle( FileHandle );
                    UnmapViewOfFile( BaseAddress );
                    if (!fQuiet) {
                        fprintf( stderr, "VERFIX: %s is not a valid image file - skipping\n", ImageName, GetLastError() );
                        }
                    }
                else {
                    //
                    // Recompute and reset the checksum of the modified file.
                    //

                    OldCheckSum = NtHeaders->OptionalHeader.CheckSum;

                    (VOID) CheckSumMappedFile( BaseAddress,
                                               FileLength,
                                               &HeaderSum,
                                               &CheckSum
                                             );

                    NtHeaders->OptionalHeader.CheckSum = CheckSum;

                    if (!FlushViewOfFile( BaseAddress, FileLength )) {
                        if (!fQuiet) {
                            fprintf( stderr,
                                     "VERFIX: Flush of %s failed (%u)\n",
                                     ImageName,
                                     GetLastError()
                                   );
                            }
                        }

                    if (NtHeaders->OptionalHeader.CheckSum != OldCheckSum) {
                        if (!TouchFileTimes( FileHandle, NULL )) {
                            if (!fQuiet) {
                                fprintf( stderr, "VERFIX: Unable to touch file %s (%u)\n", ImageName, GetLastError() );
                                }
                            }
                        else
                        if (fVerbose) {
                            printf( "%s - Old Checksum: %x", ImageName, OldCheckSum );
                            printf( "  New Checksum: %x\n", NtHeaders->OptionalHeader.CheckSum );
                            }
                        }

                    UnmapViewOfFile( BaseAddress );
                    CloseHandle( FileHandle );
                    }
                }
            }
        }
    }

    exit( 0 );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\certify.cxx ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    certify.cxx

Abstract:

    This is the command line tool to manipulate certificates on an executable image.

Author:

Revision History:

--*/

#define UNICODE 1
#define _UNICODE 1

#include <private.h>

#if 1
#define TEST 1
#else
#define TEST 0
#endif

void
PrintUsage(
    VOID)
{
    fputs("usage: CERTIFY [switches] image-names... \n"
          "            [-?] display this message\n"
          "            [-l] list the certificates in an image\n"
          "            [-a:<Filename>] add a certificate file to an image\n"
          "            [-r:<index>]    remove certificate <index> from an image\n"
          "            [-g:<Filename>] update any associated .DBG file\n"
          "            [-s:<Filename>] used with -r to save the removed certificate\n",
          stderr
         );
    exit(-1);
}

#if TEST
// Test routine
BOOL  fAllDataReturned;
PVOID pvDataRefTest;
DWORD FileSize;
DWORD DataRead;

BOOL
WINAPI
DigestRoutine (
    DIGEST_HANDLE   DataReference,
    PBYTE           pData,
    DWORD           dwLength
    )
{
    if (DataReference != pvDataRefTest) {
        return(FALSE);
    }

    // Attempt to read the range

    if (IsBadReadPtr(pData, dwLength)) {
        return(FALSE);
    }

    DataRead += dwLength;
    if (DataRead > FileSize) {
        return(FALSE);
    }

    return(TRUE);
}

#endif


int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *p;

    if (argc < 2) {
        PrintUsage();
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (toupper( c )) {
                case '?':
                    PrintUsage();
                    break;

                case 'A':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {

                        // Add a certificate file to an image.
#if TEST
                        // Test code

                        WIN_CERTIFICATE wc;
                        HANDLE  Handle;
                        DWORD   Index;

                        wc.dwLength = sizeof(WIN_CERTIFICATE);
                        wc.wCertificateType = WIN_CERT_TYPE_X509;

                        if ((Handle = CreateFile(TEXT("test.exe"),
                                    GENERIC_WRITE | GENERIC_READ,
                                    0,
                                    0,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL)) == INVALID_HANDLE_VALUE)
                        {
                            fputs("Unable to open test.exe", stderr);
                            exit(1);
                        }

                        printf("ImageAddCertificate on test.exe returned: %d\n",
                                ImageAddCertificate(Handle, &wc, &Index));

                        printf("Index #: %d\n", Index);

                        CloseHandle(Handle);

                        exit(0);
#else
                    // The real code
#endif
                    }
                    break;

                case 'L':
                    // List the certificates in an image.
#if TEST
                    // Test code
                    WIN_CERTIFICATE wc;
                    HANDLE  Handle;
                    DWORD   Index;

                    if ((Handle = CreateFile(TEXT("test.exe"),
                                GENERIC_READ,
                                0,
                                0,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL)) == INVALID_HANDLE_VALUE)
                    {
                        fputs("Unable to open test.exe", stderr);
                        exit(1);
                    }

                    ImageEnumerateCertificates(Handle, CERT_SECTION_TYPE_ANY, &Index, NULL, 0);

                    printf("Enumerate lists: %d\n", Index);

                    Index--;

                    while (ImageGetCertificateHeader(Handle, Index, &wc)) {
                        printf("Index: %d\n", Index);
                        Index--;
                    }

                    CloseHandle(Handle);

                    exit(0);

#else
                    // The real code
#endif
                    break;

                case 'R':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {
                        // Remove a specific certificate from an image.
#if TEST
                        // Test code

                        HANDLE  Handle;

                        if ((Handle = CreateFile(TEXT("test.exe"),
                                    GENERIC_WRITE | GENERIC_READ,
                                    0,
                                    0,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL)) == INVALID_HANDLE_VALUE)
                        {
                            fputs("Unable to open test.exe", stderr);
                            exit(1);
                        }

                        printf("ImageRemoveCertificate(0) on test.exe returned: %d\n",
                            ImageRemoveCertificate(Handle, 0));
                        exit(0);
#else
                        // The real code
#endif
                    }
                    break;

                case 'G':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {
                        // Generate a certificate from an image.
#if TEST
                        // Test code

                        HANDLE  Handle;

                        if ((Handle = CreateFile(TEXT("test.exe"),
                                    GENERIC_READ,
                                    0,
                                    0,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL)) == INVALID_HANDLE_VALUE)
                        {
                            fputs("Unable to open test.exe", stderr);
                            exit(1);
                        }

                        FileSize = GetFileSize(Handle, NULL);
                        DataRead = 0;

                        pvDataRefTest = (PVOID) 1;
                        printf("ImageGetDigestStream debug w/o resources on test.exe returned: %s\tGetLastError(): %d\n",
                            ImageGetDigestStream(Handle,
                                                 CERT_PE_IMAGE_DIGEST_DEBUG_INFO,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        DataRead = 0;
                        pvDataRefTest = (PVOID) 2;
                        printf("ImageGetDigestStream debug w/ resources test.exe returned: %s\tGetLastError(): %d\n",
                            ImageGetDigestStream(Handle,
                                                 CERT_PE_IMAGE_DIGEST_DEBUG_INFO | CERT_PE_IMAGE_DIGEST_RESOURCES,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        DataRead = 0;
                        pvDataRefTest = (PVOID) 3;
                        printf("ImageGetDigestStream w/o debug w/o resources on test.exe returned: %s\tGetLastError(): %d\n",
                            ImageGetDigestStream(Handle,
                                                 0,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        DataRead = 0;
                        pvDataRefTest = (PVOID) 4;
                        printf("ImageGetDigestStream w/o debug w/ resources test.exe returned: %s\tGetLastError(): %d\n",
                            ImageGetDigestStream(Handle,
                                                 CERT_PE_IMAGE_DIGEST_RESOURCES,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        exit(0);

#else
                        // Real code
#endif
                    }
                    break;

                case 'S':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {
                        // Save the certificate in some file.
                    }
                    break;

                default:
                    fprintf( stderr, "CERTIFY: Invalid switch - /%c\n", c );
                    PrintUsage();
                    break;
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\copypdb.c ===
#if defined (use_CopyPdbX)

#include "private.h"
#include "splitsymx.h"

typedef BOOL ( __cdecl *PPDBCOPYTO ) (
    PDB* ppdb,
    const char* szTargetPdb,
    DWORD dwCopyFilter,
    DWORD dwReserved
    );

typedef BOOL ( __cdecl *PPDBOPEN )(
    LNGNM_CONST char *,
    LNGNM_CONST char *,
    SIG,
    EC *,
    char [cbErrMax],
    PDB **
    );

typedef BOOL ( __cdecl *PPDBCLOSE ) (
    PDB* ppdb
    );


static PPDBCOPYTO pPDBCopyTo = NULL;
static PPDBOPEN   pPDBOpen = NULL;
static PPDBCLOSE  pPDBClose = NULL;

static BOOL RSDSLibLoaded = FALSE;

// If you call CopyPdbX with a NB10, or NB* pdb, then
// set szRSDSDllToLoad and it will use the statically
// linked in PDBCopyTo in msdbi60l.lib

BOOL
CopyPdbX(
    CHAR const * szSrcPdb,
    CHAR const * szDestPdb,
    BOOL StripPrivate,
    CHAR const * szRSDSDllToLoad
    )
#else

BOOL
CopyPdb(
    CHAR const * szSrcPdb,
    CHAR const * szDestPdb,
    BOOL StripPrivate
    )

#endif 

{
    LONG ErrorCode;
    ULONG Sig = 0;
    char ErrorString[1024];
    BOOL rc;
    PDB * pSrcPdb;
    HINSTANCE hMsPdb;

    static BOOL RSDSLibLoaded = FALSE;

    // Add a short circut.  PdbCopy fails miserably if the source and destination are the same.
    // If StripPrivate isn't set, check for this case and just return.  If StripPrivate is set,
    // bummer.

    if (!StripPrivate) {
        if (!_stricmp(szSrcPdb, szDestPdb)) {
            rc = TRUE;
        } else {
            rc = CopyFile(szSrcPdb, szDestPdb, FALSE);
        }

    } else {

#if defined ( use_CopyPdbX )

        if ( szRSDSDllToLoad != NULL ) {
            // Load the dll with PDBCopyTo
            HMODULE hDll;

            if ( !RSDSLibLoaded ) {
                hDll = LoadLibrary( szRSDSDllToLoad );
                if (hDll != NULL) {
                    RSDSLibLoaded = TRUE;
                    pPDBCopyTo = ( PPDBCOPYTO ) GetProcAddress( hDll, "PDBCopyTo" );
                    if (pPDBCopyTo == NULL ) {
                        return (FALSE);
                    }
                    pPDBOpen = ( PPDBOPEN ) GetProcAddress( hDll, "PDBOpen" );
                    if (pPDBOpen == NULL ) {
                        return (FALSE);
                    }
                    pPDBClose = ( PPDBCLOSE ) GetProcAddress( hDll, "PDBClose" );
                    if (pPDBClose == NULL ) {
                        return (FALSE);
                    }
                } else {
                    return (FALSE);
                }
            }
            __try
            {
                rc = pPDBOpen((char *)szSrcPdb, "r", Sig, &ErrorCode, ErrorString, &pSrcPdb);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                rc=FALSE;
            }
        } else {
            __try
            {
                rc = PDBOpen((char *)szSrcPdb, "r", Sig, &ErrorCode, ErrorString, &pSrcPdb);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                rc=FALSE;
            }
        }
#else
        __try
        {
            rc = PDBOpen((char *)szSrcPdb, "r", Sig, &ErrorCode, ErrorString, &pSrcPdb);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            rc=FALSE;
        }
#endif
        if (rc) {
            rc = DeleteFile(szDestPdb);
            if (rc || (GetLastError() == ERROR_FILE_NOT_FOUND)) {

#if defined ( use_CopyPdbX )
            if ( szRSDSDllToLoad != NULL ) {
                rc = pPDBCopyTo(pSrcPdb, szDestPdb, StripPrivate ? 0x00000001 : 0x0000000, 0);
            } else {
                rc = PDBCopyTo(pSrcPdb, szDestPdb, StripPrivate ? 0x00000001 : 0x0000000, 0);
            }
#else
                rc = PDBCopyTo(pSrcPdb, szDestPdb, StripPrivate ? 0x00000001 : 0x0000000, 0);
#endif
            }
            if (!rc) {
                // PdbCopyTo doesn't cleanup on failure.  Do it here.
                DeleteFile(szDestPdb);
            }
#if defined ( use_CopyPdbX )
            if ( szRSDSDllToLoad != NULL ) {
                pPDBClose(pSrcPdb);
            } else {
                PDBClose(pSrcPdb);
            }
#else
            PDBClose(pSrcPdb);
#endif
        }
    }
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\dbh.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <assert.h>
#include <imagehlp.h>
#include <dbhpriv.h>

#define MAX_STR         256
#define WILD_UNDERSCORE 1
#define SYM_BUFFER_SIZE (sizeof(IMAGEHLP_SYMBOL64) + MAX_SYM_NAME)


typedef struct {
    char    mask[MAX_STR];
    DWORD64 base;
} ENUMSYMDATA, *PENUMSYMDATA;


typedef enum
{
    cmdQuit = 0,
    cmdHelp,
    cmdVerbose,
    cmdLoad,
    cmdUnload,
    cmdEnum,
    cmdName,
    cmdAddr,
    cmdBase,
    cmdNext,
    cmdPrev,
    cmdLine,
    cmdSymInfo,
    cmdDiaVer,
    cmdUndec,
    cmdFindFile,
    cmdEnumSrcFiles,
    cmdMax
};

typedef BOOL (*CMDPROC)(char *params);

typedef struct _CMD
{
    char    token[MAX_STR + 1];
    char    shorttoken[4];
    CMDPROC fn;
} CMD, *PCMD;


BOOL fnQuit(char *);
BOOL fnHelp(char *);
BOOL fnVerbose(char *);
BOOL fnLoad(char *);
BOOL fnUnload(char *);
BOOL fnEnum(char *);
BOOL fnName(char *);
BOOL fnAddr(char *);
BOOL fnBase(char *);
BOOL fnNext(char *);
BOOL fnPrev(char *);
BOOL fnLine(char *);
BOOL fnSymInfo(char *);
BOOL fnDiaVer(char *);
BOOL fnUndec(char *);
BOOL fnFindFile(char *);
BOOL fnEnumSrcFiles(char *);


CMD gCmd[cmdMax] =
{
    {"quit",    "q", fnQuit},
    {"help",    "h", fnHelp},
    {"verbose", "v", fnVerbose},
    {"load",    "l", fnLoad},
    {"unload",  "u", fnUnload},
    {"enum",    "x", fnEnum},
    {"name",    "n", fnName},
    {"addr",    "a", fnAddr},
    {"base",    "b", fnBase},
    {"next",    "t", fnNext},
    {"prev",    "v", fnPrev},
    {"line",    "i", fnLine},
    {"sym" ,    "s", fnSymInfo},
    {"dia",     "d", fnDiaVer},
    {"undec",   "n", fnUndec},
    {"ff",      "f", fnFindFile},
    {"src",     "r", fnEnumSrcFiles}
};

char    gModName[MAX_STR];
char    gImageName[MAX_STR];
char    gSymbolSearchPath[MAX_STR];
DWORD64 gBase;
DWORD64 gDefaultBase;
DWORD64 gDefaultBaseForPDB;
DWORD   gOptions;
HANDLE  gHP;


int
WINAPIV
dprintf(
    LPSTR Format,
    ...
    )
{
    static char buf[1000] = "DBGHELP: ";
    va_list args;

    if ((gOptions & SYMOPT_DEBUG) == 0)
        return 1;

    va_start(args, Format);
    _vsnprintf(buf, sizeof(buf)-9, Format, args);
    va_end(args);
    printf(buf);
    return 1;
}


__inline int ucase(int c)
{
    return (gOptions & SYMOPT_CASE_INSENSITIVE) ? toupper(c) : c;
}


void dumpsym(
    PIMAGEHLP_SYMBOL64 sym
    )
{
    printf(" name : %s\n", sym->Name);
    printf(" addr : 0x%I64x\n", sym->Address);
    printf(" size : 0x%x\n", sym->Size);
    printf("flags : 0x%x\n", sym->Flags);
}


BOOL
MatchPattern(
    char *sz,
    char *pattern
    )
{
    char c, p, l;

    if (!*pattern)
        return TRUE;

    for (; ;) {
        p = *pattern++;
        p = (char)ucase(p);
        switch (p) {
            case 0:                             // end of pattern
                return *sz ? FALSE : TRUE;  // if end of string TRUE

            case '*':
                while (*sz) {               // match zero or more char
                    if (MatchPattern (sz++, pattern)) {
                        return TRUE;
                    }
                }
                return MatchPattern (sz, pattern);

            case '?':
                if (*sz++ == 0) {           // match any one char
                    return FALSE;                   // not end of string
                }
                break;

            case WILD_UNDERSCORE:
                while (*sz == '_') {
                    sz++;
                }
                break;

            case '[':
                if ( (c = *sz++) == 0) {    // match char set
                    return FALSE;                   // syntax
                }

                c = (CHAR)ucase(c);
                l = 0;
                while (p = *pattern++) {
                    if (p == ']') {             // if end of char set, then
                        return FALSE;           // no match found
                    }

                    if (p == '-') {             // check a range of chars?
                        p = *pattern;           // get high limit of range
                        if (p == 0  ||  p == ']') {
                            return FALSE;           // syntax
                        }

                        if (c >= l  &&  c <= p) {
                            break;              // if in range, move on
                        }
                    }

                    l = p;
                    if (c == p) {               // if char matches this element
                        break;                  // move on
                    }
                }

                while (p  &&  p != ']') {       // got a match in char set
                    p = *pattern++;             // skip to end of set
                }

                break;

            default:
                c = *sz++;
                if (ucase(c) != p) {          // check for exact char
                    return FALSE;                   // not a match
                }

                break;
        }
    }
}


BOOL
cbEnumSymbols(
    PSYMBOL_INFO  si,
    ULONG         size,
    PVOID         context
    )
{
    PENUMSYMDATA esd = (PENUMSYMDATA)context;

    printf("0x%I64x : ", si->Address, si->Name);
    if (si->Flags & SYMF_FORWARDER)
        printf("%c ", 'F');
    else if (si->Flags & SYMF_EXPORT)
        printf("%c ", 'E');
    else
        printf("  ");
    printf("%s\n", si->Name);

    return TRUE;
}


BOOL
cbEnumSym(
  PTSTR   name,
  DWORD64 address,
  ULONG   size,
  PVOID   context
  )
{
    PENUMSYMDATA esd = (PENUMSYMDATA)context;

    if (MatchPattern(name, esd->mask))
        printf("0x%I64x : %s\n", address, name);

    return TRUE;
}


BOOL
cbSrcFiles(
    PSOURCEFILE pSourceFile,
    PVOID       UserContext
    )
{
    if (!pSourceFile)
        return FALSE;

    printf("%s\n", pSourceFile->FileName);

    return TRUE;
}


BOOL
cbSymbol(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    )
{
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;
    PIMAGEHLP_CBA_READ_MEMORY        prm;
    IMAGEHLP_MODULE64                mi;
    PUCHAR                           p;
    ULONG                            i;

    idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD64) CallbackData;

    switch ( ActionCode ) {
        case CBA_DEBUG_INFO:
            dprintf("%s", (LPSTR)CallbackData);
            break;

#if 0
    case CBA_DEFERRED_SYMBOL_LOAD_CANCEL:
        if (fControlC)
        {
            fControlC = 0;
            return TRUE;
        }
        break;
#endif

        case CBA_DEFERRED_SYMBOL_LOAD_START:
            dprintf("loading symbols for %s\n", gModName);
            break;

        case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:
            if (idsl->FileName && *idsl->FileName)
                dprintf( "*** Error: could not load symbols for %s\n", idsl->FileName );
            else
                dprintf( "*** Error: could not load symbols [MODNAME UNKNOWN]\n");
            break;

        case CBA_DEFERRED_SYMBOL_LOAD_COMPLETE:
            dprintf("loaded symbols for %s\n", gModName);
            break;

        case CBA_SYMBOLS_UNLOADED:
            dprintf("unloaded symbols for %s\n", gModName);
            break;

#if 0
        case CBA_READ_MEMORY:
            prm = (PIMAGEHLP_CBA_READ_MEMORY)CallbackData;
            return g_Target->ReadVirtual(prm->addr,
                                         prm->buf,
                                         prm->bytes,
                                         prm->bytesread) == S_OK;
#endif

        default:
            return FALSE;
    }

    return FALSE;
}


PIMAGEHLP_SYMBOL64 SymbolFromName(char *param)
{
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    char               name[MAX_STR];

    assert(name & *name);

    sym = malloc(SYM_BUFFER_SIZE);
    if (!sym)
        return FALSE;
    ZeroMemory(sym, SYM_BUFFER_SIZE);
    sym->MaxNameLength = MAX_SYM_NAME;

    sprintf(name, "%s!%s", gModName, param);
    rc = SymGetSymFromName64(gHP, name, sym);
    if (!rc) {
        free(sym);
        return NULL;
    }

    return sym;
}


BOOL fnQuit(char *param)
{
    printf("goodbye\n");
    return FALSE;
}


BOOL fnHelp(char *param)
{
    printf("    dbh commands :\n");
    printf("            help : prints this message\n");
    printf("            quit : quits this program\n");
    printf("verbose <on/off> : controls debug spew\n");
    printf("  load <modname> : loads the requested module\n");
    printf("          unload : unloads the current module\n");
    printf("     enum <mask> : enumerates all matching symbols\n");
    printf("  name <symname> : finds a symbol by it's name\n");
    printf("  addr <address> : finds a symbol by it's hex address\n");
    printf("  base <address> : sets the new default base address\n");
    printf("  next <add/nam> : finds the symbol after the passed sym\n");
    printf("  prev <add/nam> : finds the symbol before the passed sym\n");
    printf("   line <file:#> : finds the matching line number\n");
    printf("             sym : displays type and location of symbols\n");
    printf("             dia : displays the DIA version\n");
    printf("ff <path> <file> : finds file in path\n");
    printf("      src <mask> : lists source files\n");

    return TRUE;
}


BOOL fnVerbose(char *param)
{
    int opts = gOptions;

    if (!param || !*param)
        printf("");
    else if (!_strcmpi(param, "on"))
        opts |= SYMOPT_DEBUG;
    else if (!_strcmpi(param, "off"))
        opts = gOptions & ~SYMOPT_DEBUG;
    else
        printf("verbose <on//off>\n");

    gOptions = SymSetOptions(opts);

    printf("verbose mode %s.\n", gOptions & SYMOPT_DEBUG ? "on" : "off");

    return TRUE;
}


BOOL fnLoad(char *param)
{
    DWORD64 addr;
    char ext[MAX_STR];
    char mod[MAX_STR];

    if (!param || !*param || !strchr(param, '.'))
    {
        printf("load <modname> must specify a file to load symbols for.\n");
        return TRUE;
    }

    _splitpath(param, NULL, NULL, mod, ext);

    addr = 0;
    if (gDefaultBase)
        addr = gDefaultBase;
    else if (!_strcmpi(ext, ".pdb"))
        addr = gDefaultBaseForPDB;

    fnUnload(NULL);

    addr = SymLoadModule64(gHP,
                           NULL,       // hFile,
                           param,      // ImageName,
                           mod,        // ModuleName,
                           addr,       // BaseOfDll,
                           0x1000000); // SizeOfDll

    if (!addr)
    {
        printf("error 0x%x loading %s\n", GetLastError(), param);
        return TRUE;
    }

    if (gBase && !SymUnloadModule64(gHP, gBase))
        printf("error unloading %s at 0x%x\n", gModName, gBase);

    strcpy(gModName, mod);
    strcpy(gImageName, param);
    gBase = addr;

    return TRUE;
}


BOOL fnUnload(char *param)
{
    if (!gBase)
        return TRUE;

    if (!SymUnloadModule64(gHP, gBase))
        printf("error unloading %s at 0x%x\n", gModName, gBase);

    gBase = 0;
    *gModName = 0;

    return TRUE;
}


BOOL fnEnum(char *param)
{
    BOOL rc;
    ENUMSYMDATA esd;

    esd.base = gBase;
    strcpy(esd.mask, param ? param : "");

    rc = SymEnumSymbols(gHP, gBase, param, cbEnumSymbols, &esd);
    if (!rc)
        printf("error 0x%0 calling SymEnumerateSymbols()\n", GetLastError());

    return TRUE;
}


BOOL fnEnumSrcFiles(char *param)
{
    BOOL rc;

    rc = SymEnumSourceFiles(gHP, gBase, param, cbSrcFiles, NULL);
    if (!rc)
        printf("error 0x%0 calling SymEnumSourceFiles()\n", GetLastError());

    return TRUE;
}


BOOL fnName(char *param)
{
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;

    if (!param || !*param)
    {
        printf("name <symbolname> - finds a symbol by it's name\n");
        return TRUE;
    }

    sym = SymbolFromName(param);
    if (!sym)
        return TRUE;

    dumpsym(sym);
    free(sym);

    return TRUE;
}


BOOL fnAddr(char *param)
{
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    DWORD64            addr;
    DWORD64            disp;
    char              *p;

    addr = 0;
    if (param && *param)
    {
        p = param;
        if (*(p + 1) == 'x' || *(p + 1) == 'X')
            p += 2;
        sscanf(p, "%I64x", &addr);
    }

    if (!addr)
    {
        printf("addr <address> : finds a symbol by it's hex address\n");
        return TRUE;
    }

    sym = malloc(SYM_BUFFER_SIZE);
    if (!sym)
        return FALSE;
    ZeroMemory(sym, SYM_BUFFER_SIZE);
    sym->MaxNameLength = MAX_SYM_NAME;

    rc = SymGetSymFromAddr64(gHP, addr, &disp, sym);
    if (rc)
    {
        printf("%s", sym->Name);
        if (disp)
            printf("+0x%I64x", disp);
        printf("\n");
        dumpsym(sym);
    }

    free(sym);

    return TRUE;
}


BOOL fnNextPrev(int direction, char *param)
{
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    DWORD64            addr;
    char               name[MAX_STR];
    char              *p;

    addr = 0;
    if (param && *param)
    {
        p = param;
        if (*(p + 1) == 'x' || *(p + 1) == 'X')
            p += 2;
        sscanf(p, "%I64x", &addr);
    }

    if (!addr)
    {
        sym = SymbolFromName(param);
        if (!sym)
            return TRUE;
        addr = sym->Address;
        if (!addr) {
            free(sym);
            return TRUE;
        }
    }
    else
    {
        sym = malloc(SYM_BUFFER_SIZE);
        if (!sym)
            return FALSE;
    }

    if (direction > 0)
        rc = SymGetSymNext64(gHP, sym);
    else
        rc = SymGetSymPrev64(gHP, sym);

    if (rc)
        dumpsym(sym);

    free(sym);

    return TRUE;
}


BOOL fnNext(char *param)
{
    return fnNextPrev(1, param);
}


BOOL fnPrev(char *param)
{
    return fnNextPrev(-1, param);
}


BOOL fnBase(char *param)
{
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    DWORD64            addr;
    DWORD64            disp;
    char              *p;

    addr = 0;
    if (param && *param)
    {
        p = param;
        if (*(p + 1) == 'x' || *(p + 1) == 'X')
            p += 2;
        sscanf(p, "%I64x", &addr);
    }

    if (!addr)
    {
        printf("base <address> : sets the base address for module loads\n");
        return TRUE;
    }

    gDefaultBase = addr;
    if (gBase)
        fnLoad(gImageName);

    return TRUE;
}


BOOL fnLine(char *param)
{
    char              *file;
    DWORD              linenum;
    BOOL               rc;
    IMAGEHLP_LINE64    line;
    LONG               disp;

    if (!param || !*param)
        return TRUE;

    file = param;

    while (*param != ':') {
        if (!*param)
            return TRUE;
        param++;
    }
    *param++ = 0;
    linenum = atoi(param);
    if (!linenum)
        return TRUE;

    memset(&line, 0, sizeof(line));
    line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);
    rc = SymGetLineFromName64(gHP,
                              gModName,
                              file,
                              linenum,
                              &disp,
                              &line);

    if (!rc) {
        printf("line: error 0x%x looking for %s#%d\n",
               GetLastError(),
               file,
               linenum);
        return TRUE;
    }

    printf("file : %s\n", line.FileName);
    printf("line : %d\n", linenum);
    printf("addr : 0x%I64x\n", line.Address);
    printf("disp : 0x%x\n", disp);

    return TRUE;
}


BOOL fnSymInfo(char *param)
{
    DBH_MODSYMINFO msi;

    if (!gBase)
        return TRUE;

    msi.function     = dbhModSymInfo;
    msi.sizeofstruct = sizeof(msi);
    msi.addr         = gBase;

    if (!dbghelp(gHP, (PVOID)&msi))
        printf("error grabbing symbol info\n");

    printf("%s: symtype=0x%x, src=%s\n", gModName, msi.type, msi.file);

    return TRUE;
}


BOOL fnDiaVer(char *param)
{
    DBH_DIAVERSION dv;

    dv.function     = dbhDiaVersion;
    dv.sizeofstruct = sizeof(dv);

    if (!dbghelp(0, (PVOID)&dv))
        printf("error grabbing dia version info\n");

    printf("DIA version 0x%x\n", dv.ver);

    return TRUE;
}

BOOL fnUndec(char *param)
{
    DWORD rc;
    char uname[MAX_SYM_NAME + 1];

    if (!param || !*param)
    {
        printf("undec <symbolname> - undecorates a C++ mangled symbol name\n");
        return TRUE;
    }

    rc = UnDecorateSymbolName(param, uname, MAX_SYM_NAME, UNDNAME_COMPLETE);
    if (!rc) {
        printf("error 0x%u undecorating %s\n", GetLastError(), param);
    } else {
        printf("%s = %s\n", param, uname);
    }

    return TRUE;
}

BOOL fnFindFile(char *param)
{
    DWORD rc;
    char  root[MAX_PATH + 1];
    char  file[MAX_PATH + 1];
    char  found[MAX_PATH + 1];

    if (!param)
    {
        printf("ff <root path> <file name> - finds file in path\n");
        return TRUE;
    }

    sscanf(param, "%s %s", root, file);

    if (!*root || !*file)
    {
        printf("ff <root path> <file name> - finds file in path\n");
        return TRUE;
    }

    *found = 0;

    rc = SearchTreeForFile(root, file, found);

    if (!rc) {
        printf("error 0x%u looking for %s\n", GetLastError(), file);
    } else {
        printf("found %s\n", found);
    }

    return TRUE;
}

char *GetParameters(char *cmd)
{
    char *p     = cmd;
    char *param = NULL;

    while (*p++)
    {
        if (isspace(*p))
        {
            *p++ = 0;
             return *p ? p : NULL;
        }
    }

    return NULL;
}


void prompt()
{
    if (!*gModName)
        printf("dbh: ");
    else
        printf("%s [0x%I64x]: ", gModName, gBase);
}


int InputLoop()
{
    char  cmd[MAX_STR + 1];
    char *params;
    int   i;
    BOOL  rc;

    printf("\n");

    do
    {

        prompt();
        gets(cmd);
        params = GetParameters(cmd);
        // printf("cmd[%s] params[%s]\n", cmd, params);

        for (i = 0; i < cmdMax; i++)
        {
            if (!_strcmpi(cmd, gCmd[i].token) ||
                !_strcmpi(cmd, gCmd[i].shorttoken))
                break;
        }

        if (i == cmdMax)
        {
            printf("[%s] is an unrecognized command.\n", cmd);
            rc = TRUE;
            continue;
        }
        else
            rc = gCmd[i].fn(params);

    } while (rc);

    return 0;
}


BOOL init()
{
    int i;
    BOOL rc;

    *gModName = 0;
    gBase = 0;;
    gDefaultBaseForPDB = 0x1000000;

    printf("dbh: initializing...\n");
    i = GetEnvironmentVariable("_NT_SYMBOL_PATH", gSymbolSearchPath, MAX_STR);
    if (i < 1)
        *gSymbolSearchPath = 0;
    printf("Symbol Path = [%s]\n", gSymbolSearchPath);

    gHP = GetCurrentProcess();
    rc = SymInitialize(gHP, gSymbolSearchPath, FALSE);
    if (!rc)
    {
        printf("error 0x%x from SymInitialize()\n", GetLastError());
        return rc;
    }

    gOptions = SymSetOptions(SYMOPT_CASE_INSENSITIVE | SYMOPT_UNDNAME | SYMOPT_NO_CPP | SYMOPT_LOAD_LINES);
    printf("SymOpts = 0x%x\n", gOptions);

    rc = SymRegisterCallback64(gHP, cbSymbol, 0);
    if (!rc)
    {
        printf("error 0x%x from SymRegisterCallback64()\n", GetLastError());
        return rc;
    }

    return rc;
}


void cleanup()
{
    fnUnload(NULL);
    SymCleanup(gHP);
}


BOOL cmdline(int argc, char *argv[])
{
    int   i;
    char *p;

    for (i = 1; i < argc; i++)
    {
        p = argv[i];
        switch (*p)
        {
        case '/':
        case '-':
            p++;
            switch (tolower(*p))
            {
            case 'v':
                fnVerbose("on");
                break;
            default:
                printf("%s is an unknown switch\n", argv[i]);
                break;
            }
            break;

        default:
            fnLoad(argv[i]);
            break;
        }
    }

    return TRUE;
}

#include <crtdbg.h>

__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD rc;
    _CrtSetDbgFlag( ( _CRTDBG_CHECK_ALWAYS_DF | _CRTDBG_LEAK_CHECK_DF ) | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG ) );

    if (!init())
        return 1;
    cmdline(argc, argv);
    rc = InputLoop();
    cleanup();

    _CrtDumpMemoryLeaks();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\dbgexts.c ===
#include "private.h"

#include <ntsdexts.h>


#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PNTSD_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )

NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

#ifdef IMAGEHLP_HEAP_DEBUG
DECLARE_API( allocs )
{
    PLIST_ENTRY                 Next;
    HEAP_BLOCK                  HeapBlock;
    ULONG                       Address;
    ULONG                       r;
    ULONG                       cb;

    LIST_ENTRY                  LocalHeapHeader;
    ULONG                       LocalTotalAllocs;
    ULONG                       LocalTotalMemory;
    HANDLE                      LocalhHeap;


    INIT_API();

    Address = GetExpression("imagehlp!TotalAllocs");
    r = ReadMemory(Address,
                   &LocalTotalAllocs,
                   sizeof(LocalTotalAllocs),
                   &cb
                   );
    if (!r || cb != sizeof(LocalTotalAllocs)) {
        dprintf("*** TotalAllocs unreadable\n");
        return;
    }

    Address = GetExpression("imagehlp!TotalMemory");
    r = ReadMemory(Address,
                   &LocalTotalMemory,
                   sizeof(LocalTotalMemory),
                   &cb
                   );
    if (!r || cb != sizeof(LocalTotalMemory)) {
        dprintf("*** TotalMemory unreadable\n");
        return;
    }

    Address = GetExpression("imagehlp!hHeap");
    r = ReadMemory(Address,
                   &LocalhHeap,
                   sizeof(LocalhHeap),
                   &cb
                   );
    if (!r || cb != sizeof(LocalhHeap)) {
        dprintf("*** hHeap unreadable\n");
        return;
    }


    Address = GetExpression("imagehlp!HeapHeader");
    r = ReadMemory(Address,
                   &LocalHeapHeader,
                   sizeof(LocalHeapHeader),
                   &cb
                   );
    if (!r || cb != sizeof(LocalHeapHeader)) {
        dprintf("*** HeapHeader unreadable\n");
        return;
    }
    Next = LocalHeapHeader.Flink;
    if (!Next) {
        return;
    }

    dprintf( "-----------------------------------------------------------------------------\n" );
    dprintf( "Memory Allocations for Heap 0x%08x, Allocs=%d, TotalMem=%d\n",
                     LocalhHeap, LocalTotalAllocs, LocalTotalMemory );
    dprintf( "-----------------------------------------------------------------------------\n" );
    dprintf( "*\n" );

    while ((ULONG)Next != Address) {
        r = ReadMemory( CONTAINING_RECORD( Next, HEAP_BLOCK, ListEntry ),
                        &HeapBlock,
                        sizeof(HeapBlock),
                        &cb
                        );
        if (!r || cb != sizeof(HeapBlock)) {
            dprintf("*** list broken\n");
            return;
        }
        Next = HeapBlock.ListEntry.Flink;
        dprintf( "%8d %16s @ %5d\n", HeapBlock.Size, HeapBlock.File, HeapBlock.Line );
    }

    return;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\dbgdump.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dbgdump.c

Abstract:

    This is the main source file for the DBGDUMP utility program.  This
    program can be used to dump out symbolic debugging information for an
    image.

Author:

    Steve Wood (stevewo) 03-May-1993

Revision History:

--*/

#include <private.h>


BOOL fVerbose;
BOOL fRemote;

UCHAR CurrentImageName[ MAX_PATH ];
UCHAR SymbolPath[ MAX_PATH ];

void
Usage( void )
{
    fputs("usage: DBGDUMP [-?] [-v] [-r] image-names...\n"
          "              [-?] display this message\n"
          "              [-v] verbose output\n"
          "              [-r symbol path] assume image names are from remote system.\n",
          stderr);
    exit( 1 );
}

void
ShowDebugInfo(
    PIMAGE_DEBUG_INFORMATION64 DebugInfo
    );

VOID
DumpSectionHeader(
    IN ULONG i,
    IN PIMAGE_SECTION_HEADER Sh
    );


int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *s;
    LPSTR FilePart;
    HANDLE FileHandle;
    PIMAGE_DEBUG_INFORMATION64 DebugInfo;

    if (argc <= 1) {
        Usage();
        }

    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            while (c = *++s)
                switch (toupper( c )) {
                case '?':
                    Usage();
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'R':
                    if (--argc) {
                        strcpy( (PCHAR) SymbolPath, *++argv );
                        fRemote = TRUE;
                        }
                    else {
                        fprintf( stderr, "DBGDUMP: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                default:
                    fprintf( stderr, "DBGDUMP: Invalid switch - /%c\n", c );
                    Usage();
                    break;
                }
            }
        else {
            DebugInfo = NULL;
            if (!fRemote) {
                if (!GetFullPathNameA( s, sizeof( CurrentImageName ), (PCHAR) CurrentImageName, &FilePart )) {
                    fprintf( stderr, "DBGDUMP: invalid file name - %s (%u)\n", s, GetLastError() );
                    }
                else {
                    FileHandle = CreateFileA( (PCHAR)CurrentImageName,
                                             GENERIC_READ,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                                             NULL,
                                             OPEN_EXISTING,
                                             0,
                                             NULL
                                           );
                    if (FileHandle == INVALID_HANDLE_VALUE) {
                        fprintf( stderr, "DBGDUMP: unable to open - %s (%u)\n", CurrentImageName, GetLastError() );
                        }
                    else {
                        DebugInfo = MapDebugInformation64( FileHandle, NULL, NULL, 0 );
                        }
                    }
                }
            else {
                strcpy( (PCHAR) CurrentImageName, s );
                DebugInfo = MapDebugInformation64( NULL, (PCHAR) CurrentImageName, (PCHAR) SymbolPath, 0 );
                }

            if (DebugInfo != NULL) {
                ShowDebugInfo( DebugInfo );
                UnmapDebugInformation64( DebugInfo );
                }
            }
        }

    exit( 0 );
    return 0;
}


VOID
DumpSectionHeader(
    IN ULONG i,
    IN PIMAGE_SECTION_HEADER Sh
    )
{
    PCHAR name;
    ULONG li, lj;
    USHORT memFlags, alignFlags;

    printf( "\nSECTION HEADER #%hX\n% 8.8s name\n", i, Sh->Name );

    printf( "% 8lX physical address\n% 8lX virtual address\n% 8lX size of raw data\n% 8lX file pointer to raw data\n% 8lX file pointer to relocation table\n",
           Sh->Misc.PhysicalAddress,
           Sh->VirtualAddress,
           Sh->SizeOfRawData,
           Sh->PointerToRawData,
           Sh->PointerToRelocations );

    printf( "% 8lX file pointer to line numbers\n% 8hX number of relocations\n% 8hX number of line numbers\n% 8lX flags\n",
           Sh->PointerToLinenumbers,
           Sh->NumberOfRelocations,
           Sh->NumberOfLinenumbers,
           Sh->Characteristics );

    memFlags = alignFlags = 0;
    for (li=Sh->Characteristics, lj=0L; li; li=li>>1, lj++) {
        if (li & 1) {
            switch((li & 1) << lj) {
                case IMAGE_SCN_TYPE_NO_PAD    : name = (PCHAR) "No Pad"; break;


                case IMAGE_SCN_CNT_CODE       : name = (PCHAR) "Code"; break;
                case IMAGE_SCN_CNT_INITIALIZED_DATA : name = (PCHAR) "Initialized Data"; break;
                case IMAGE_SCN_CNT_UNINITIALIZED_DATA : name = (PCHAR) "Uninitialized Data"; break;

                case IMAGE_SCN_LNK_OTHER      : name = (PCHAR) "Other"; break;
                case IMAGE_SCN_LNK_INFO       : name = (PCHAR) "Info"; break;
                case IMAGE_SCN_LNK_REMOVE     : name = (PCHAR) "Remove"; break;
                case IMAGE_SCN_LNK_COMDAT     : name = (PCHAR) "Communal"; break;

                case IMAGE_SCN_ALIGN_1BYTES   :
                case IMAGE_SCN_ALIGN_2BYTES   :
                case IMAGE_SCN_ALIGN_4BYTES   :
                case IMAGE_SCN_ALIGN_8BYTES   :
                case IMAGE_SCN_ALIGN_16BYTES  :
                case IMAGE_SCN_ALIGN_32BYTES  :
                case IMAGE_SCN_ALIGN_64BYTES  : name = (PCHAR) ""; break;

                case IMAGE_SCN_MEM_DISCARDABLE: name = (PCHAR) "Discardable"; break;
                case IMAGE_SCN_MEM_NOT_CACHED : name = (PCHAR) "Not Cached"; break;
                case IMAGE_SCN_MEM_NOT_PAGED  : name = (PCHAR) "Not Paged"; break;
                case IMAGE_SCN_MEM_SHARED     : name = (PCHAR) "Shared"; break;
                case IMAGE_SCN_MEM_EXECUTE    : name = (PCHAR) ""; memFlags |= 1; break;
                case IMAGE_SCN_MEM_READ       : name = (PCHAR) ""; memFlags |= 2; break;
                case IMAGE_SCN_MEM_WRITE      : name = (PCHAR) ""; memFlags |= 4; break;


                default : name = (PCHAR) "RESERVED - UNKNOWN";
            }
            if (*name) {
                printf( "         %s\n", name );
            }
        }
    }

    if (Sh->Characteristics & IMAGE_SCN_ALIGN_64BYTES) {
        switch(Sh->Characteristics & IMAGE_SCN_ALIGN_64BYTES) {
            case IMAGE_SCN_ALIGN_1BYTES  : name = (PCHAR) "Align1";  break;
            case IMAGE_SCN_ALIGN_2BYTES  : name = (PCHAR) "Align2";  break;
            case IMAGE_SCN_ALIGN_4BYTES  : name = (PCHAR) "Align4";  break;
            case IMAGE_SCN_ALIGN_8BYTES  : name = (PCHAR) "Align8";  break;
            case IMAGE_SCN_ALIGN_16BYTES : name = (PCHAR) "Align16"; break;
            case IMAGE_SCN_ALIGN_32BYTES : name = (PCHAR) "Align32"; break;
            case IMAGE_SCN_ALIGN_64BYTES : name = (PCHAR) "Align64"; break;
        }
        printf( "         %s\n", name );
    }

    if (memFlags) {
        switch(memFlags) {
            case 1 : name = (PCHAR) "Execute Only"; break;
            case 2 : name = (PCHAR) "Read Only"; break;
            case 3 : name = (PCHAR) "Execute Read"; break;
            case 4 : name = (PCHAR) "Write Only"; break;
            case 5 : name = (PCHAR) "Execute Write"; break;
            case 6 : name = (PCHAR) "Read Write"; break;
            case 7 : name = (PCHAR) "Execute Read Write"; break;
            default : name = (PCHAR) "Unknown Memory Flags"; break;
        }
        printf( "         %s\n", name );
    }
}


char *FrameType[] = {
    "FRAME_FPO",
    "FRAME_TRAP",
    "FRAME_TSS",
    "FRAME_NONFPO",
    "FRAME_UNKNOWN"
};

void
ShowDebugInfo(
    PIMAGE_DEBUG_INFORMATION64 DebugInfo
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER Section;
    PIMAGE_FUNCTION_ENTRY FunctionEntry;
    PFPO_DATA FpoEntry;
    LPSTR s;


    printf( "Debug information at % p\n", DebugInfo );
    printf( "    Size             % 8lx\n", DebugInfo->Size );
    printf( "    Mapped at        % p\n", DebugInfo->MappedBase );
    printf( "    Machine          % 8hx\n", DebugInfo->Machine );
    printf( "    Characteristics  % 8hx\n", DebugInfo->Characteristics );
    printf( "    Time/Date stamp  % 8lx",   DebugInfo->TimeDateStamp );
    if (DebugInfo->TimeDateStamp && (s = ctime( (time_t *)&DebugInfo->TimeDateStamp ))) {
        printf( " %s", s );
        }
    else {
        putchar( '\n' );
        }
    printf( "    CheckSum         % 8lx\n", DebugInfo->CheckSum );
    printf( "    ImageBase        % 8lx\n", DebugInfo->ImageBase );
    printf( "    SizeOfImage      % 8lx\n", DebugInfo->SizeOfImage );
    printf( "    NumberOfSections % 8lx\n", DebugInfo->NumberOfSections );
    printf( "    ExportedNamesSize% 8lx\n", DebugInfo->ExportedNamesSize );
    printf( "    #Function Entries% 8lx\n", DebugInfo->NumberOfFunctionTableEntries );
    printf( "    #FPO Entries     % 8lx\n", DebugInfo->NumberOfFpoTableEntries );
    printf( "    Coff Symbol Size % 8lx\n", DebugInfo->SizeOfCoffSymbols );
    printf( "    CV Symbol Size   % 8lx\n", DebugInfo->SizeOfCodeViewSymbols );
    printf( "    Image Path               %s\n", DebugInfo->ImageFilePath );
    printf( "    Image Name               %s\n", DebugInfo->ImageFileName );
    printf( "    Debug Path               %s\n", DebugInfo->DebugFilePath );
    printf( "\n" );

    if (DebugInfo->NumberOfSections != 0) {
        printf( "Section Headers:\n" );
        Section = DebugInfo->Sections;
        for (i=0; i<DebugInfo->NumberOfSections; i++) {
            DumpSectionHeader( i, Section++ );
            }
        printf( "\n" );
        }

    if (DebugInfo->ExportedNamesSize != 0) {
        printf( "Exported Names:\n" );
        s = DebugInfo->ExportedNames;
        while (*s) {
            printf( "    %s\n", s );
            while (*s++) {
                }
            }
        printf( "\n" );
        }

    if (DebugInfo->NumberOfFunctionTableEntries != 0) {
        printf( "Function Table:\n" );
        FunctionEntry = DebugInfo->FunctionTableEntries;
        for (i=0; i<DebugInfo->NumberOfFunctionTableEntries; i++) {
            printf( "    % 4x: % 8x % 8x % 8x\n",
                    i,
                    FunctionEntry->StartingAddress,
                    FunctionEntry->EndingAddress,
                    FunctionEntry->EndOfPrologue
                  );

            FunctionEntry += 1;
            }
        printf( "\n" );
        }

    if (DebugInfo->NumberOfFpoTableEntries != 0) {
        printf( "FPO Table:\n" );
        FpoEntry = DebugInfo->FpoTableEntries;
        for (i=0; i<DebugInfo->NumberOfFpoTableEntries; i++) {
            printf( "    % 4x: % 8x % 8x % 8x [%02x %1x%s%s %s]\n",
                    i,
                    FpoEntry->ulOffStart,
                    FpoEntry->cbProcSize,
                    FpoEntry->cdwParams,
                    FpoEntry->cbProlog,
                    FpoEntry->cbRegs,
                    FpoEntry->fHasSEH ? " SEH" : "",
                    FpoEntry->fUseBP ? " EBP" : "",
                    FrameType[ FpoEntry->cbFrame ]
                  );

            FpoEntry += 1;
            }

        printf( "\n" );
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\debug.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    checksum.c

Abstract:

    This module implements functions for splitting debugging information
    out of an image file and into a separate .DBG file.

Author:

    Steven R. Wood (stevewo) 4-May-1993

Revision History:

--*/

#include <private.h>
#include <symbols.h>
#include <globals.h>

#define ROUNDUP(x, y) ((x + (y-1)) & ~(y-1))

typedef BOOL
(CALLBACK *PSEARCH_TREE_FOR_FILE_EX_CALLBACK)(
    LPSTR FilePath,
    PVOID CallerData
    );

BOOL
IMAGEAPI
SearchTreeForFileEx(
    PSTR RootPath,
    PSTR InputPathName,
    PSTR OutputPathBuffer,
    PSEARCH_TREE_FOR_FILE_EX_CALLBACK Callback,
    PVOID CallbackData
    );

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#if !defined(_WIN64)

PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    HANDLE FileHandle,
    LPSTR FileName,
    LPSTR SymbolPath,
    ULONG ImageBase
    )

// Here's what we're going to try.  MapDebugInformation was only
// documented as returning COFF symbolic and every user I can find
// in the tree uses COFF exclusively.  Rather than try to make this
// api do everything possible, let's just leave it as a COFF only thing.

// The new debug info api (GetDebugData) will be internal only.

{
    PIMAGE_DEBUG_INFORMATION pIDI;
    CHAR szName[_MAX_FNAME];
    CHAR szExt[_MAX_EXT];
    PIMGHLP_DEBUG_DATA pIDD;
    PPIDI              pPIDI;
    DWORD sections;
    BOOL               SymbolsLoaded;
    HANDLE             hProcess;
    LPSTR sz;
    HANDLE hdb;
    DWORD dw;
    hProcess = GetCurrentProcess();

    pIDD = GetDebugData(NULL, FileHandle, FileName, SymbolPath, ImageBase, NULL, NO_PE64_IMAGES);
    if (!pIDD)
        return NULL;

    pPIDI = (PPIDI)MemAlloc(sizeof(PIDI));
    if (!pPIDI)
        return NULL;

    ZeroMemory(pPIDI, sizeof(PIDI));
    pIDI = &pPIDI->idi;
    pPIDI->hdr.pIDD = pIDD;

    pIDI->ReservedSize            = sizeof(IMAGE_DEBUG_INFORMATION);
    pIDI->ReservedMachine         = pIDD->Machine;
    pIDI->ReservedCharacteristics = (USHORT)pIDD->Characteristics;
    pIDI->ReservedCheckSum        = pIDD->CheckSum;
    pIDI->ReservedTimeDateStamp   = pIDD->TimeDateStamp;
    pIDI->ReservedRomImage        = pIDD->fROM;

    // read info

    InitializeListHead( &pIDI->List );
    pIDI->ImageBase = (ULONG)pIDD->ImageBaseFromImage;

    pIDI->ImageFilePath = (PSTR)MemAlloc(strlen(pIDD->ImageFilePath)+1);
    if (pIDI->ImageFilePath) {
        strcpy( pIDI->ImageFilePath, pIDD->ImageFilePath );
    }

    pIDI->ImageFileName = (PSTR)MemAlloc(strlen(pIDD->OriginalImageFileName)+1);
    if (pIDI->ImageFileName) {
        strcpy(pIDI->ImageFileName, pIDD->OriginalImageFileName);
    }

    if (pIDD->pMappedCoff) {
        pIDI->CoffSymbols = (PIMAGE_COFF_SYMBOLS_HEADER)MemAlloc(pIDD->cMappedCoff);
        if (pIDI->CoffSymbols) {
            memcpy(pIDI->CoffSymbols, pIDD->pMappedCoff, pIDD->cMappedCoff);
        }
        pIDI->SizeOfCoffSymbols = pIDD->cMappedCoff;
    }

    if (pIDD->pFpo) {
        pIDI->ReservedNumberOfFpoTableEntries = pIDD->cFpo;
        pIDI->ReservedFpoTableEntries = (PFPO_DATA)pIDD->pFpo;
    }

    pIDI->SizeOfImage = pIDD->SizeOfImage;

    if (pIDD->DbgFilePath && *pIDD->DbgFilePath) {
        pIDI->ReservedDebugFilePath = (PSTR)MemAlloc(strlen(pIDD->DbgFilePath)+1);
        if (pIDI->ReservedDebugFilePath) {
            strcpy(pIDI->ReservedDebugFilePath, pIDD->DbgFilePath);
        }
    }

    if (pIDD->pMappedCv) {
        pIDI->ReservedCodeViewSymbols       = pIDD->pMappedCv;
        pIDI->ReservedSizeOfCodeViewSymbols = pIDD->cMappedCv;
    }

    // for backwards compatibility
    if (pIDD->ImageMap) {
        sections = (DWORD)((char *)pIDD->pCurrentSections - (char *)pIDD->ImageMap);
        pIDI->ReservedMappedBase = MapItRO(pIDD->ImageFileHandle);
        if (pIDI->ReservedMappedBase) {
            pIDI->ReservedSections = (PIMAGE_SECTION_HEADER)pIDD->pCurrentSections;
            pIDI->ReservedNumberOfSections = pIDD->cCurrentSections;
            if (pIDD->ddva) {
                pIDI->ReservedDebugDirectory = (PIMAGE_DEBUG_DIRECTORY)((PCHAR)pIDI->ReservedMappedBase + pIDD->ddva);
                pIDI->ReservedNumberOfDebugDirectories = pIDD->cdd;
            }
        }
    }

    return pIDI;
}

BOOL
UnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION pIDI
    )
{
    PPIDI pPIDI;

    if (!pIDI)
        return TRUE;

    if (pIDI->ImageFileName){
        MemFree(pIDI->ImageFileName);
    }

    if (pIDI->ImageFilePath) {
        MemFree(pIDI->ImageFilePath);
    }

    if (pIDI->ReservedDebugFilePath) {
        MemFree(pIDI->ReservedDebugFilePath);
    }

    if (pIDI->CoffSymbols) {
        MemFree(pIDI->CoffSymbols);
    }

    if (pIDI->ReservedMappedBase) {
        UnmapViewOfFile(pIDI->ReservedMappedBase);
    }

    pPIDI = (PPIDI)(PCHAR)((PCHAR)pIDI - sizeof(PIDI_HEADER));
    ReleaseDebugData(pPIDI->hdr.pIDD, IMGHLP_FREE_ALL);
    MemFree(pPIDI);

    return TRUE;
}

#endif


LPSTR
ExpandPath(
    LPSTR lpPath
    )
{
    LPSTR   p, newpath, p1, p2, p3;
    CHAR    envvar[MAX_PATH];
    CHAR    envstr[MAX_PATH];
    ULONG   i, PathMax;

    if (!lpPath) {
        return(NULL);
    }

    p = lpPath;
    PathMax = strlen(lpPath) + MAX_PATH + 1;
    p2 = newpath = (LPSTR) MemAlloc( PathMax );

    if (!newpath) {
        return(NULL);
    }

    while( p && *p) {
        if (*p == '%') {
            i = 0;
            p++;
            while (p && *p && *p != '%') {
                envvar[i++] = *p++;
            }
            p++;
            envvar[i] = '\0';
            p1 = envstr;
            *p1 = 0;
            GetEnvironmentVariable( envvar, p1, MAX_PATH );
            while (p1 && *p1) {
                *p2++ = *p1++;
                if (p2 >= newpath + PathMax) {
                    PathMax += MAX_PATH;
                    p3 = (LPSTR)MemReAlloc(newpath, PathMax);
                    if (!p3) {
                        MemFree(newpath);
                        return(NULL);
                    } else {
                        p2 = p3 + (p2 - newpath);
                        newpath = p3;
                    }
                }
            }
        }
        *p2++ = *p++;
        if (p2 >= newpath + PathMax) {
            PathMax += MAX_PATH;
            p3 = (LPSTR)MemReAlloc(newpath, PathMax);
            if (!p3) {
                MemFree(newpath);
                return(NULL);
            } else {
                p2 = p3 + (p2 - newpath);
                newpath = p3;
            }
        }
    }
    *p2 = '\0';

    return newpath;
}


BOOL
IMAGEAPI
SymFindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FilePath,
    PFINDFILEINPATHCALLBACK callback,
    PVOID  context
    )
{
    PPROCESS_ENTRY  pe;
    char path[MAX_PATH];
    LPSTR emark;
    LPSTR spath;
    GUID  guid;
    GUID *pguid;
    BOOL  rc;
    LPSTR p;

    if (!FileName || !*FileName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // ignore the path...

    for (p = FileName + strlen(FileName); p >= FileName; p--) {
        if (*p == '\\') {
            FileName = p + 1;
            break;
        }
    }

    if (traceSubName(FileName)) // for setting debug breakpoints from DBGHELP_TOKEN
        dprint("debug(%s)\n", FileName);

    // prepare identifiers for symbol server

    if (flags & SSRVOPT_GUIDPTR) {
        pguid = (GUID *)id;
    } else {
        pguid = &guid;
        ZeroMemory(pguid, sizeof(GUID));
        if (!flags || (flags & SSRVOPT_DWORD))
            pguid->Data1 = PtrToUlong(id);
        else if (flags & SSRVOPT_DWORDPTR)
            pguid->Data1 = *(DWORD *)id;
    }

    // setup local copy of the symbol path

    *FilePath = 0;
    spath = NULL;
    
    if (!SearchPath || !*SearchPath) {
        if (hprocess) {
            pe = FindProcessEntry(hprocess);
            if (pe && pe->SymbolSearchPath) {
                spath = pe->SymbolSearchPath;
            }
        }
    } else {
        spath = SearchPath;
    }

    if (!spath || !*spath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // for each node in the search path, look
    // for the file, or for it's symsrv entry

    do {
        emark = strchr(spath, ';');

        if (emark) {
            memcpy(path, spath, emark - spath);
            path[emark - spath] = 0;
            emark++;
        } else {
            strcpy(path, spath);
        }

        // look for the file in this node

        if (!_strnicmp(path, "SYMSRV*", 7)) {
            GetFileFromSymbolServer(path,
                                    FileName,
                                    pguid,
                                    two,
                                    three,
                                    FilePath);
        } else {
            EnsureTrailingBackslash(path);
            strcat(path, FileName);
            if (fileexists(path)) 
                strcpy(FilePath, path);
        }

        // if we find a file, process it.

        if (*FilePath) {
            // if no callback is specified, return with the filename filled in
            if (!callback)
                break;
            // otherwise call the callback
            rc = callback(FilePath, context);
            // if it returns FALSE, quit...
            if (!rc)
                break;
            // otherwise continue
            *FilePath = 0;
        }

        // continue to the next node

        spath = emark;

    } while (emark);

    return (*FilePath) ? TRUE : FALSE;
}


BOOL
IMAGEAPI
FindFileInPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    PVOID  id,
    DWORD  two,
    DWORD  three,
    DWORD  flags,
    LPSTR  FilePath
    )
{
    return SymFindFileInPath(hprocess, SearchPath, FileName, id, two, three, flags, FilePath, NULL, NULL);
}


BOOL
IMAGEAPI
FindFileInSearchPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    DWORD  one,
    DWORD  two,
    DWORD  three,
    LPSTR  FilePath
    )
{
    return FindFileInPath(hprocess, SearchPath, FileName, UlongToPtr(one), two, three, SSRVOPT_DWORD, FilePath);
}


HANDLE
IMAGEAPI
FindExecutableImage(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR ImageFilePath
    )
{
    return FindExecutableImageEx(FileName, SymbolPath, ImageFilePath, NULL, NULL);
}


HANDLE
CheckExecutableImage(
    LPSTR Path,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData,
    DWORD flags
    )
{
    HANDLE FileHandle;
    
    SetCriticalErrorMode();

    dprint("FindExecutableImageEx-> Looking for %s... ", Path);
    FileHandle = CreateFile( Path,
                             GENERIC_READ,
                             g.OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ?
                             (FILE_SHARE_DELETE | FILE_SHARE_READ |
                              FILE_SHARE_WRITE) :
                             (FILE_SHARE_READ | FILE_SHARE_WRITE),
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                             );

    if (FileHandle != INVALID_HANDLE_VALUE) {
        if (Callback) {
            if (!Callback(FileHandle, Path, CallerData)) {
                eprint("mismatched timestamp ");
                if (!(flags & SYMOPT_LOAD_ANYTHING)) {
                    eprint("\n");
                    CloseHandle(FileHandle);
                    FileHandle = INVALID_HANDLE_VALUE;
                }
            }
        }
        if (FileHandle != INVALID_HANDLE_VALUE) {
            eprint("OK\n");
        }
    } else {
        eprint("no file\n");
    }

    ResetCriticalErrorMode();

    return FileHandle;
}

typedef struct _FEIEP_STATE
{
    PFIND_EXE_FILE_CALLBACK UserCb;
    PVOID UserCbData;
    DWORD flags;
    HANDLE Return;
} FEIEP_STATE;

BOOL
CALLBACK
FindExSearchTreeCallback(
    LPSTR FilePath,
    PVOID CallerData
    )
{
    FEIEP_STATE* State = (FEIEP_STATE*)CallerData;
    
    State->Return =
        CheckExecutableImage(FilePath, State->UserCb, State->UserCbData,
                             State->flags);
    return State->Return != INVALID_HANDLE_VALUE;
}

HANDLE
IMAGEAPI
FindExecutableImageExPass(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData,
    DWORD flags
    )
{
    LPSTR Start, End;
    HANDLE FileHandle = NULL;
    CHAR DirectoryPath[ MAX_PATH ];
    LPSTR NewSymbolPath = NULL;

    __try {
        __try {
            if (GetFullPathName( FileName, MAX_PATH, ImageFilePath, &Start )) {
                FileHandle = CheckExecutableImage(ImageFilePath, Callback, CallerData, flags);
                if (FileHandle != INVALID_HANDLE_VALUE) 
                    return FileHandle;
            }

            NewSymbolPath = ExpandPath(SymbolPath);
            Start = NewSymbolPath;
            while (Start && *Start != '\0') {
                FEIEP_STATE SearchTreeState;
                
                if (End = strchr( Start, ';' )) {
                    int Len = (int)(End - Start);
                    Len = (int)min(Len, sizeof(DirectoryPath)-1);

                    strncpy( (PCHAR) DirectoryPath, Start, Len );
                    DirectoryPath[ Len ] = '\0';
                    End += 1;
                } else {
                    strcpy( (PCHAR) DirectoryPath, Start );
                }

                if (!_strnicmp(DirectoryPath, "SYMSRV*", 7)) {
                    goto next;
                }

                dprint("FindExecutableImageEx-> Searching %s for %s... ", DirectoryPath, FileName);
                SearchTreeState.UserCb = Callback;
                SearchTreeState.UserCbData = CallerData;
                SearchTreeState.flags = flags;
                if (SearchTreeForFileEx( (PCHAR) DirectoryPath, FileName, ImageFilePath, FindExSearchTreeCallback, &SearchTreeState )) {
                    eprint("found\n");
                    MemFree( NewSymbolPath );
                    return SearchTreeState.Return;
                } else {
                    eprint("no file\n");
                }

next:
                Start = End;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(ERROR_INVALID_PARAMETER);
        }

        ImageFilePath[0] = '\0';

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    if (FileHandle) {
        CloseHandle(FileHandle);
    }

    if (NewSymbolPath) {
        MemFree( NewSymbolPath );
    }

    return NULL;
}


HANDLE
IMAGEAPI
FindExecutable(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData,
    DWORD flags
    )
{
    BOOL FullPath = FALSE;
    BOOL PathComponents = FALSE;
    HANDLE FileHandle;
    
    if (!FileName || !*FileName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // The filename may or may not contain path components.
    // Determine what kind of path it is.
    //

    if ((((FileName[0] >= 'a' && FileName[0] <= 'z') ||
          (FileName[0] >= 'A' && FileName[0] <= 'Z')) &&
         FileName[1] == ':') ||
        FileName[0] == '\\' ||
        FileName[0] == '/') {
        
        FullPath = TRUE;
        PathComponents = TRUE;
        
    } else if (strchr(FileName, '\\') ||
               strchr(FileName, '/')) {
        
        PathComponents = TRUE;
        
    }
        
    // If the filename is a full path then it can be checked
    // for existence directly; there's no need to search
    // along any paths.
    if (FullPath) {
        __try {
            FileHandle = CheckExecutableImage(FileName, Callback, CallerData, flags);
            if (FileHandle != INVALID_HANDLE_VALUE) {
                strcpy(ImageFilePath, FileName);
                return FileHandle;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return NULL;
        }
    } else {
        // If it's not a full path we need to do a first pass
        // with the filename as given.  This handles relative
        // paths and bare filenames.
        FileHandle = FindExecutableImageExPass(FileName, SymbolPath,
                                               ImageFilePath, Callback,
                                               CallerData, flags);
        if (FileHandle != NULL) {
            return FileHandle;
        }
    }

    // If we still haven't found it and the given filename
    // has path components we need to strip off the path components
    // and try again with just the base filename.
    if (PathComponents) {
        LPSTR BaseFile;

        BaseFile = strrchr(FileName, '\\');
        if (BaseFile == NULL) {
            BaseFile = strrchr(FileName, '/');
            if (BaseFile == NULL) {
                // Must be <drive>:.
                BaseFile = FileName + 1;
            }
        }

        // Skip path character to point to base file.
        BaseFile++;

        return FindExecutableImageExPass(BaseFile, SymbolPath,
                                         ImageFilePath, Callback,
                                         CallerData, flags);
    }
    
    return NULL;
}


HANDLE
IMAGEAPI
FindExecutableImageEx(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData
    )
{
    HANDLE hrc;

    hrc = FindExecutable(FileName,
                         SymbolPath,
                         ImageFilePath,
                         Callback,
                         CallerData,
                         0);
    if (hrc) 
        return hrc;

    if (g.SymOptions & SYMOPT_LOAD_ANYTHING)
        hrc = FindExecutable(FileName,
                             SymbolPath,
                             ImageFilePath,
                             Callback,
                             CallerData,
                             SYMOPT_LOAD_ANYTHING);
     return hrc;   
}


HANDLE
IMAGEAPI
FindDebugInfoFile(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath
    )
{
    return FindDebugInfoFileEx(FileName, SymbolPath, DebugFilePath, NULL, NULL);
}


HANDLE
IMAGEAPI
FindDebugInfoFileEx(
    IN  LPSTR FileName,
    IN  LPSTR SymbolPath,
    OUT LPSTR DebugFilePath,
    IN  PFIND_DEBUG_FILE_CALLBACK Callback,
    IN  PVOID CallerData
    )
{
    DWORD flag;

    if (g.SymOptions & SYMOPT_LOAD_ANYTHING)
        flag = fdifRECURSIVE;
    else
        flag = 0;
    if (flag)
        dprint("RECURSIVE %s\n", FileName);

    return fnFindDebugInfoFileEx(FileName,
                                 SymbolPath,
                                 DebugFilePath,
                                 Callback,
                                 CallerData,
                                 flag);
}


HANDLE
IMAGEAPI
fnFindDebugInfoFileEx(
    IN  LPSTR FileName,
    IN  LPSTR SymbolPath,
    OUT LPSTR DebugFilePath,
    IN  PFIND_DEBUG_FILE_CALLBACK Callback,
    IN  PVOID CallerData,
    IN  DWORD flag
    )
/*++

Routine Description:

 The rules are:
   Look for
     1. <SymbolPath>\Symbols\<ext>\<filename>.dbg
     3. <SymbolPath>\<ext>\<filename>.dbg
     5. <SymbolPath>\<filename>.dbg
     7. <FileNamePath>\<filename>.dbg

Arguments:
    FileName - Supplies a file name in one of three forms: fully qualified,
                <ext>\<filename>.dbg, or just filename.dbg
    SymbolPath - semi-colon delimited

    DebugFilePath -

    Callback - May be NULL. Callback that indicates whether the Symbol file is valid, or whether
        the function should continue searching for another Symbol file.
        The callback returns TRUE if the Symbol file is valid, or FALSE if the function should
        continue searching.

    CallerData - May be NULL. Data passed to the callback.

    Flag - indicates that PDBs shouldn't be searched for

Return Value:

  The name of the .dbg file and a handle to that file.

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    LPSTR ExpSymbolPath = NULL, SymPathStart, PathEnd;
    DWORD ShareAttributes, cnt;
    LPSTR InitialPath, Sub1, Sub2, FileExt;
    CHAR FilePath[_MAX_PATH + 1];
    CHAR Drive[_MAX_DRIVE], Dir[_MAX_DIR], SubDirPart[_MAX_DIR], FilePart[_MAX_FNAME], Ext[_MAX_EXT];
    CHAR *ExtDir;
    DWORD i;
    PIMGHLP_DEBUG_DATA pIDD;
    BOOL  found = FALSE;
    DWORD err = 0;
    GUID  guid;
    BOOL  ssrv;

    assert(DebugFilePath);
    *DebugFilePath = 0;

    ZeroMemory(&guid, sizeof(GUID));

    if (g.OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        ShareAttributes = (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE);
    } else {
        ShareAttributes = (FILE_SHARE_READ | FILE_SHARE_WRITE);
    }

    __try {
        *DebugFilePath = '\0';

        // Step 1.  What do we have?
        _splitpath(FileName, Drive, Dir, FilePart, Ext);

        if (!_stricmp(Ext, ".dbg")) {
            // We got a filename of the form: ext\filename.dbg.  Dir holds the extension already.
            ExtDir = Dir;
        } else {
            // Otherwise, skip the period and null out the Dir.
            ExtDir = CharNext(Ext);
        }

        ExpSymbolPath = ExpandPath(SymbolPath);
        if (!ExpSymbolPath)
            return NULL;

        SetCriticalErrorMode();

        SymPathStart = ExpSymbolPath;
        cnt = 0;

        do {
            if (PathEnd = strchr( SymPathStart, ';' )) {
                *PathEnd = '\0';
            }

            ssrv = FALSE;
            pIDD = (PIMGHLP_DEBUG_DATA)CallerData;

            if (!_strnicmp(SymPathStart, "SYMSRV*", 7)) {

                *DebugFilePath = 0;
                if (!cnt && CallerData) {
                    ssrv = TRUE;
                    strcpy(FilePath, FilePart);
                    strcat(FilePath, ".dbg");
                    guid.Data1 = pIDD->TimeDateStamp;
                    GetFileFromSymbolServer(SymPathStart,
                                            FilePath,
                                            &guid,
                                            pIDD->SizeOfImage,
                                            0,
                                            DebugFilePath);
                }

            } else {

                switch (cnt) {

                case 0: // <SymbolPath>\symbols\<ext>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = "symbols";
                    Sub2 = ExtDir;
                    break;

                case 1: // <SymbolPath>\<ext>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = "";
                    Sub2 = ExtDir;
                    break;

                case 2: // <SymbolPath>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = "";
                    Sub2 = "";
                    break;

                case 3: // <FileNamePath>\<filename>.ext - A.K.A. what was passed to us
                    InitialPath = Drive;
                    Sub1 = "";
                    Sub2 = Dir;
                    // this stops us from checking out everything in the sympath
                    cnt++;
                    break;
                }

               // build fully-qualified filepath to look for

                strcpy(FilePath, InitialPath);
                EnsureTrailingBackslash(FilePath);
                strcat(FilePath, Sub1);
                EnsureTrailingBackslash(FilePath);
                strcat(FilePath, Sub2);
                EnsureTrailingBackslash(FilePath);
                strcat(FilePath, FilePart);

                strcpy(DebugFilePath, FilePath);
                strcat(DebugFilePath, ".dbg");
            }

            // try to open the file

            if (*DebugFilePath) {
                dprint("FindDebugInfoFileEx-> Looking for %s... ", DebugFilePath);
                FileHandle = CreateFile(DebugFilePath,
                                        GENERIC_READ,
                                        ShareAttributes,
                                        NULL,
                                        OPEN_EXISTING,
                                        0,
                                        NULL);

                // if the file opens, bail from this loop

                if (FileHandle != INVALID_HANDLE_VALUE) {
                    found = TRUE;
                    if (pIDD) {
                        pIDD->ImageSrc = (ssrv) ? srcSymSrv : srcSearchPath;
                    }
                    if (!Callback) {
                        break;
                    } else if (Callback(FileHandle, DebugFilePath, CallerData)) {
                        break;
                    } else {
                        eprint("mismatched timestamp\n");
                        CloseHandle(FileHandle);
                        FileHandle = INVALID_HANDLE_VALUE;
                    }
                } else {
                    err = GetLastError();
                    switch (err)
                    {
                    case ERROR_FILE_NOT_FOUND:
                        eprint("file not found\n");
                        break;
                    case ERROR_PATH_NOT_FOUND:
                        eprint("path not found\n");
                        break;
                    default:
                        eprint("file error 0x%x\n", err);
                        break;
                    }
                }
                // if file is open, bail from this loop too - else continue

                if (FileHandle != INVALID_HANDLE_VALUE)
                    break;
            }

            // go to next item in the sympath

            if (PathEnd) {
                *PathEnd = ';';
                SymPathStart = PathEnd + 1;
            } else {
                SymPathStart = ExpSymbolPath;
                cnt++;
            }
        } while (cnt < 4);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(FileHandle);
        }
        FileHandle = INVALID_HANDLE_VALUE;
    }

    if (ExpSymbolPath) {
        MemFree(ExpSymbolPath);
    }

    if (FileHandle == INVALID_HANDLE_VALUE) {
        FileHandle = NULL;
        DebugFilePath[0] = '\0';
    } else {
        eprint("OK\n");
    }

    if (!FileHandle                 // if we didn't get the right file...
        && found                    // but we found some file...
        && (flag & fdifRECURSIVE))  // and we were told to run recursively...
    {
        // try again without timestamp checking
        FileHandle = fnFindDebugInfoFileEx(FileName,
                                           SymbolPath,
                                           FilePath,
                                           NULL,
                                           0,
                                           flag);
        if (FileHandle && FileHandle != INVALID_HANDLE_VALUE)
            strcpy(DebugFilePath, FilePath);
    }

    ResetCriticalErrorMode();

    return FileHandle;
}


BOOL
GetImageNameFromMiscDebugData(
    IN  HANDLE FileHandle,
    IN  PVOID MappedBase,
    IN  PIMAGE_NT_HEADERS32 NtHeaders,
    IN  PIMAGE_DEBUG_DIRECTORY DebugDirectories,
    IN  ULONG NumberOfDebugDirectories,
    OUT LPSTR ImageFilePath
    )
{
    IMAGE_DEBUG_MISC TempMiscData;
    PIMAGE_DEBUG_MISC DebugMiscData;
    ULONG BytesToRead, BytesRead;
    BOOLEAN FoundImageName;
    LPSTR ImageName;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;

    while (NumberOfDebugDirectories) {
        if (DebugDirectories->Type == IMAGE_DEBUG_TYPE_MISC) {
            break;
        } else {
            DebugDirectories += 1;
            NumberOfDebugDirectories -= 1;
        }
    }

    if (NumberOfDebugDirectories == 0) {
        return FALSE;
    }

    OptionalHeadersFromNtHeaders(NtHeaders, &OptionalHeader32, &OptionalHeader64);

    if ((OPTIONALHEADER(MajorLinkerVersion) < 3) &&
        (OPTIONALHEADER(MinorLinkerVersion) < 36) ) {
        BytesToRead = FIELD_OFFSET( IMAGE_DEBUG_MISC, Reserved );
    } else {
        BytesToRead = FIELD_OFFSET( IMAGE_DEBUG_MISC, Data );
    }

    DebugMiscData = NULL;
    FoundImageName = FALSE;
    if (MappedBase == 0) {
        if (SetFilePointer( FileHandle,
                            DebugDirectories->PointerToRawData,
                            NULL,
                            FILE_BEGIN
                          ) == DebugDirectories->PointerToRawData
           ) {
            if (ReadFile( FileHandle,
                          &TempMiscData,
                          BytesToRead,
                          &BytesRead,
                          NULL
                        ) &&
                BytesRead == BytesToRead
               ) {
                DebugMiscData = &TempMiscData;
                if (DebugMiscData->DataType == IMAGE_DEBUG_MISC_EXENAME) {
                    BytesToRead = DebugMiscData->Length - BytesToRead;
                    BytesToRead = BytesToRead > MAX_PATH ? MAX_PATH : BytesToRead;
                    if (ReadFile( FileHandle,
                                  ImageFilePath,
                                  BytesToRead,
                                  &BytesRead,
                                  NULL
                                ) &&
                        BytesRead == BytesToRead
                       ) {
                            FoundImageName = TRUE;
                    }
                }
            }
        }
    } else {
        DebugMiscData = (PIMAGE_DEBUG_MISC)((PCHAR)MappedBase +
                                            DebugDirectories->PointerToRawData );
        if (DebugMiscData->DataType == IMAGE_DEBUG_MISC_EXENAME) {
            ImageName = (PCHAR)DebugMiscData + BytesToRead;
            BytesToRead = DebugMiscData->Length - BytesToRead;
            BytesToRead = BytesToRead > MAX_PATH ? MAX_PATH : BytesToRead;
            if (*ImageName != '\0' ) {
                memcpy( ImageFilePath, ImageName, BytesToRead );
                FoundImageName = TRUE;
            }
        }
    }

    return FoundImageName;
}



#define MAX_DEPTH 32

BOOL
IMAGEAPI
SearchTreeForFileEx(
    LPSTR RootPath,
    LPSTR InputPathName,
    LPSTR OutputPathBuffer,
    PSEARCH_TREE_FOR_FILE_EX_CALLBACK Callback,
    PVOID CallbackData
    )
{
    // UnSafe...

    PCHAR FileName;
    PUCHAR Prefix = (PUCHAR) "";
    CHAR PathBuffer[ MAX_PATH ];
    ULONG Depth;
    PCHAR PathTail[ MAX_DEPTH ];
    PCHAR FindHandle[ MAX_DEPTH ];
    LPWIN32_FIND_DATA FindFileData;
    UCHAR FindFileBuffer[ MAX_PATH + sizeof( WIN32_FIND_DATA ) ];
    BOOL Result;

    SetCriticalErrorMode();;

    strcpy( PathBuffer, RootPath );
    FileName = InputPathName;
    while (*InputPathName) {
        if (*InputPathName == ':' || *InputPathName == '\\' || *InputPathName == '/') {
            FileName = ++InputPathName;
        } else {
            InputPathName = CharNext(InputPathName);
        }
    }
    FindFileData = (LPWIN32_FIND_DATA)FindFileBuffer;
    Depth = 0;
    Result = FALSE;
    while (TRUE) {
startDirectorySearch:
        PathTail[ Depth ] = strchr( PathBuffer, '\0' );
        if (PathTail[ Depth ] > PathBuffer
            && *CharPrev(PathBuffer, PathTail[ Depth ]) != '\\') {
            *(PathTail[ Depth ])++ = '\\';
        }

        strcpy( PathTail[ Depth ], "*.*" );
        FindHandle[ Depth ] = (PCHAR) FindFirstFile( PathBuffer, FindFileData );

        if (FindHandle[ Depth ] == INVALID_HANDLE_VALUE) {
            goto nextDirectory;
        }

        do {
            if (FindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (strcmp( FindFileData->cFileName, "." ) &&
                    strcmp( FindFileData->cFileName, ".." ) &&
                    Depth < MAX_DEPTH
                   ) {
                        strcpy(PathTail[ Depth ], FindFileData->cFileName);
                        strcat(PathTail[ Depth ], "\\");

                        Depth++;
                        goto startDirectorySearch;
                }
            } else
            if (!_stricmp( FindFileData->cFileName, FileName )) {
                strcpy( PathTail[ Depth ], FindFileData->cFileName );
                strcpy( OutputPathBuffer, PathBuffer );
                if (Callback != NULL) {
                    Result = Callback(OutputPathBuffer, CallbackData);
                } else {
                    Result = TRUE;
                }
            }

restartDirectorySearch:
            if (Result) {
                break;
            }
        }
        while (FindNextFile( FindHandle[ Depth ], FindFileData ));
        FindClose( FindHandle[ Depth ] );

nextDirectory:
        if (Depth == 0) {
            break;
        }

        Depth--;
        goto restartDirectorySearch;
    }

    ResetCriticalErrorMode();

    return Result;
}

BOOL
IMAGEAPI
SearchTreeForFile(
    LPSTR RootPath,
    LPSTR InputPathName,
    LPSTR OutputPathBuffer
    )
{
    return SearchTreeForFileEx(RootPath, InputPathName, OutputPathBuffer,
                               NULL, NULL);
}


BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    LPCSTR DirPath
    )
{
    LPSTR p, DirCopy;
    DWORD dw;

    // Make a copy of the string for editing.

    __try {
        DirCopy = (LPSTR) MemAlloc(strlen(DirPath) + 1);

        if (!DirCopy) {
            return FALSE;
        }

        strcpy(DirCopy, DirPath);

        p = DirCopy;

        //  If the second character in the path is "\", then this is a UNC
        //  path, and we should skip forward until we reach the 2nd \ in the path.

        if ((*p == '\\') && (*(p+1) == '\\')) {
            p++;            // Skip over the first \ in the name.
            p++;            // Skip over the second \ in the name.

            //  Skip until we hit the first "\" (\\Server\).

            while (*p && *p != '\\') {
                p = CharNext(p);
            }

            // Advance over it.

            if (*p) {
                p++;
            }

            //  Skip until we hit the second "\" (\\Server\Share\).

            while (*p && *p != '\\') {
                p = CharNext(p);
            }

            // Advance over it also.

            if (*p) {
                p++;
            }

        } else
        // Not a UNC.  See if it's <drive>:
        if (*(p+1) == ':' ) {

            p++;
            p++;

            // If it exists, skip over the root specifier

            if (*p && (*p == '\\')) {
                p++;
            }
        }

        while( *p ) {
            if ( *p == '\\' ) {
                *p = '\0';
                dw = fnGetFileAttributes(DirCopy);
                // Nothing exists with this name.  Try to make the directory name and error if unable to.
                if ( dw == 0xffffffff ) {
                    if ( !CreateDirectory(DirCopy,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            MemFree(DirCopy);
                            return FALSE;
                        }
                    }
                } else {
                    if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                        // Something exists with this name, but it's not a directory... Error
                        MemFree(DirCopy);
                        return FALSE;
                    }
                }

                *p = '\\';
            }
            p = CharNext(p);
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        MemFree(DirCopy);
        return(FALSE);
    }

    MemFree(DirCopy);
    return TRUE;
}

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
    )
{
    //
    // don't tell old apps about the new version.  It will
    // just scare them.
    //
    return &g.AppVersion;
}

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    LPAPI_VERSION av
    )
{
    LPAPI_VERSION ver;

    __try {
        ver = av;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ver = &g.AppVersion;
    }

    if (ver->Revision < 6) {
        //
        // For older debuggers, just tell them what they want to hear.
        //
        return ver;
    }
    return &g.ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\dia.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dia.c

Abstract:

    These routines call VC's new DIA symbol handler.

Author:

    Pat Styles (patst) 26-May-2000

Environment:

    User Mode

--*/
#define DIA_LIBRARY 1

#include "private.h"
#include "symbols.h"
#include "globals.h"
#include "dia2.h"
#include "diacreate_int.h"
#include <atlbase.h>

typedef struct {
    CComPtr<IDiaDataSource>    source;
    CComPtr<IDiaSession>       session;
    CComPtr<IDiaSymbol>        scope;
    CComPtr<IDiaSourceFile>    srcfile;
    CComPtr<IDiaEnumFrameData> framedata;
#ifdef BBTFIX
    CComPtr<IDiaAddressMap> addrmap;
#endif
} DIA, *PDIA;

extern HRESULT STDMETHODCALLTYPE DiaCoCreate(
                        REFCLSID   rclsid,
                        REFIID     riid,
                        void     **ppv);

extern HRESULT STDMETHODCALLTYPE NoOleCoCreate(REFCLSID   rclsid,
                                               REFIID     riid,
                                               void     **ppv);

#define freeString LocalFree

// used by diaLocatePdb

enum {
    ipNone = 0,
    ipFirst,
    ipLast
};


BOOL
diaInit(
    VOID
    )
{
        return TRUE;
}


BOOL
ValidGUID(
    GUID *guid
    )
{
    int i;

    if (!guid)
        return FALSE;

    if (guid->Data1)
        return TRUE;
    if (guid->Data2)
        return TRUE;
    if (guid->Data3)
        return TRUE;
    for (i = 0; i < 8; i++) {
        if (guid->Data4[i])
            return TRUE;
    }

    return FALSE;
}


__inline
HRESULT
SetDiaError(
    HRESULT ccode,
    HRESULT ncode
    )
{
    if (ncode == EC_OK)
        return ncode;

    if (ccode != EC_NOT_FOUND)
        return ccode;

    return ncode;
}


__inline
BOOL
ValidSig(
    DWORD sig,
    GUID *guid
    )
{
    if (ValidGUID(guid))
        return TRUE;

    if (sig)
        return TRUE;

    return FALSE;
}


typedef struct _DIAERROR {
    HRESULT  hr;
    char    *text;
} DIAERROR, *PDIAERROR;


char *
diaErrorText(
    HRESULT hr
    )
{
    #define ERROR_MAX 24

    static const DIAERROR error[ERROR_MAX] =
    {
        {E_PDB_OK, "OK"},
        {E_PDB_USAGE, "invalid parameters"},
        {E_PDB_OUT_OF_MEMORY, "out of memory"},
        {E_PDB_FILE_SYSTEM, "disk error"},
        {E_PDB_NOT_FOUND,   "file not found"},
        {E_PDB_INVALID_SIG, "unmatched pdb"},
        {E_PDB_INVALID_AGE, "unmatched pdb"},
        {E_PDB_PRECOMP_REQUIRED, "E_PDB_PRECOMP_REQUIRED"},
        {E_PDB_OUT_OF_TI, "E_PDB_OUT_OF_TI"},
        {E_PDB_NOT_IMPLEMENTED, "E_PDB_NOT_IMPLEMENTED"},
        {E_PDB_V1_PDB, "E_PDB_V1_PDB"},
        {E_PDB_FORMAT, "file system or network error reading pdb"},
        {E_PDB_LIMIT, "E_PDB_LIMIT"},
        {E_PDB_CORRUPT, "E_PDB_CORRUPT"},
        {E_PDB_TI16, "E_PDB_TI16"},
        {E_PDB_ACCESS_DENIED, "E_PDB_ACCESS_DENIED"},
        {E_PDB_ILLEGAL_TYPE_EDIT, "E_PDB_ILLEGAL_TYPE_EDIT"},
        {E_PDB_INVALID_EXECUTABLE, "invalid executable image"},
        {E_PDB_DBG_NOT_FOUND, "dbg file not found"},
        {E_PDB_NO_DEBUG_INFO, "pdb is stripped of cv info"},
        {E_PDB_INVALID_EXE_TIMESTAMP, "image has invalid timestamp"},
        {E_PDB_RESERVED, "E_PDB_RESERVED"},
        {E_PDB_DEBUG_INFO_NOT_IN_PDB, "pdb has no symbols"},
        {E_PDB_MAX, "pdb error 0x%x"}
    };

    static char sz[50];

    DWORD i;

    for (i = 0; i < ERROR_MAX; i++) {
        if (hr == error[i].hr)
            return error[i].text;
    }

    sprintf(sz, "dia error 0x%x", hr);
    return sz;
}


extern DWORD DIA_VERSION;

DWORD
diaVersion(
    VOID
    )
{
    return DIA_VERSION;
}


HRESULT
diaLocatePdb(
    PIMGHLP_DEBUG_DATA pIDD,
    PSTR  szPDB,
    GUID *PdbGUID,
    DWORD PdbSignature,
    DWORD PdbAge,
    char *SymbolPath,
    char *szImageExt,
    int   ip
    )
{
    char  szError[cbErrMax] = "";
    char  szPDBSansPath[_MAX_FNAME];
    char  szPDBExt[_MAX_EXT];
    char  szPDBLocal[_MAX_PATH];
    char  szDbgPath[PDB_MAX_PATH];
    char *SemiColon;
    DWORD pass;
    EC    hrcode = E_PDB_NOT_FOUND;
    BOOL  symsrv = TRUE;
    char  szPDBName[_MAX_PATH];
    char *SavedSymbolPath = SymbolPath;
    GUID  guid;
    WCHAR wszPDB[_MAX_PATH + 1];
    WCHAR wszError[cbErrMax];
    WCHAR wszPDBLocal[_MAX_PATH + 1];
    PDIA  pdia;
    HRESULT hr;
    BOOL  ssfile;
    BOOL  refpath;
    BOOL  first;

//  if (traceSubName(szPDB)) // for setting debug breakpoints from DBGHELP_TOKEN
//      dprint("diaLocatePdb(%s)\n", szPDB);

    ZeroMemory(&guid, sizeof(GUID));

    if (!PdbSignature
        && !ValidGUID(PdbGUID)
        && (g.SymOptions & SYMOPT_EXACT_SYMBOLS))
    {
        g.LastSymLoadError = SYMLOAD_PDBUNMATCHED;
        return E_PDB_INVALID_SIG;
    }

    // SymbolPath is a semicolon delimited path (reference path first)

    strcpy (szPDBLocal, szPDB);
    _splitpath(szPDBLocal, NULL, NULL, szPDBSansPath, szPDBExt);

    pdia = (PDIA)pIDD->dia;
    if (!pdia)
        return !S_OK;

    first = TRUE;
    do {
        SemiColon = strchr(SymbolPath, ';');

        if (SemiColon) {
            *SemiColon = '\0';
        }

        if (first) {
            refpath = (ip == ipFirst);
            first = FALSE;
        } else if (!SemiColon) {
            refpath = (ip == ipLast);
        } else {
            refpath = FALSE;
        }
        if (refpath) {
            pass = 2;
            ip = ipNone;;
        } else {
            pass = 0;
        }

        if (SymbolPath) {
do_again:
            ssfile = FALSE;
            if (!_strnicmp(SymbolPath, "SYMSRV*", 7)) {

                *szPDBLocal = 0;
                sprintf(szPDBName, "%s%s", szPDBSansPath, ".pdb");
                if (symsrv) {
                    ssfile = TRUE;
                    if (PdbSignature)
                        guid.Data1 = PdbSignature;
                    else if (PdbGUID)
                        memcpy(&guid, PdbGUID, sizeof(GUID));
                    GetFileFromSymbolServer(SymbolPath,
                                            szPDBName,
                                            &guid,
                                            PdbAge,
                                            0,
                                            szPDBLocal);
                    symsrv = FALSE;
                }

            } else {

                strcpy(szPDBLocal, SymbolPath);
                EnsureTrailingBackslash(szPDBLocal);

                // search order is ...
                //
                //   %dir%\symbols\%ext%\%file%
                //   %dir%\%ext%\%file%
                //   %dir%\%file%

                switch (pass)
                {
                case 0:
                    strcat(szPDBLocal, "symbols");
                    EnsureTrailingBackslash(szPDBLocal);
                    // pass through
                case 1:
                    strcat(szPDBLocal, szImageExt);
                    // pass through
                default:
                    EnsureTrailingBackslash(szPDBLocal);
                    break;
                }

                strcat(szPDBLocal, szPDBSansPath);
                strcat(szPDBLocal, szPDBExt);
            }

            if (*szPDBLocal) {

                ansi2wcs(szPDBLocal, wszPDBLocal, lengthof(wszPDBLocal));
                dprint("diaLocatePDB-> Looking for %s... ", szPDBLocal);
                if (!ValidSig(PdbSignature, PdbGUID)) {
                    hr = pdia->source->loadDataFromPdb(wszPDBLocal);
                } else {
                    hr = pdia->source->loadAndValidateDataFromPdb(wszPDBLocal,
                                                                  ValidGUID(PdbGUID) ? PdbGUID : NULL,
                                                                  PdbSignature,
                                                                  PdbAge);
                }

                hrcode = SetDiaError(hrcode, hr);
                if (hr == S_OK) {
                    if (ssfile)
                        pIDD->PdbSrc = srcSymSrv;
                    else if (refpath)
                        pIDD->PdbSrc = pIDD->PdbSrc;
                    else
                        pIDD->PdbSrc = srcSearchPath;
                    if (!PdbSignature && !ValidGUID(PdbGUID))
                        eprint("unknown pdb sig ");
                    break;
                } else {
                    if (hr == E_PDB_INVALID_SIG || hr == E_PDB_INVALID_AGE) {
                        eprint("%s ", diaErrorText(hr));
                        if (!ValidSig(PdbSignature, PdbGUID)) {
                            hr = pdia->source->loadDataFromPdb(wszPDBLocal);
                            if (hr == S_OK)
                                break;
                        }
                        eprint("\n");
                    } else if (hr == E_PDB_NOT_FOUND) {
                        eprint("%s\n", diaErrorText(hr));
                        if (!(g.LastSymLoadError & SYMLOAD_PDBERRORMASK)) {
                            g.LastSymLoadError = SYMLOAD_PDBNOTFOUND;
                        }
                    } else {
                        eprint("%s\n", diaErrorText(hr));
                        g.LastSymLoadError = (hr << 8) & SYMLOAD_PDBERRORMASK;
                    }

                    if (pass < 2) {
                        pass++;
                        goto do_again;
                    }
                }
                refpath = FALSE;
            }
        }

        if (SemiColon) {
            *SemiColon = ';';
             SemiColon++;
             symsrv = TRUE;
        }

        SymbolPath = SemiColon;
    } while (SemiColon);

    if (hr != S_OK) {
        strcpy(szPDBLocal, szPDB);
        ansi2wcs(szPDBLocal, wszPDBLocal, lengthof(wszPDB));
        dprint("diaLocatePDB-> Looking for %s... ", szPDBLocal);
        hr = pdia->source->loadAndValidateDataFromPdb(wszPDBLocal,
                                                      ValidGUID(PdbGUID) ? PdbGUID : NULL,
                                                      PdbSignature,
                                                      PdbAge);
        if (hr != S_OK) {
            if (hr == E_PDB_INVALID_SIG || hr == E_PDB_INVALID_AGE) {
                eprint("%s ", diaErrorText(hr));
                if (!ValidSig(PdbSignature, PdbGUID)) {
                    hr = pdia->source->loadDataFromPdb(wszPDBLocal);
                }
                if (hr != S_OK)
                    eprint("\n");
            } else if (hr == E_PDB_NOT_FOUND) {
                eprint("%s\n", diaErrorText(hr));
                if (!(g.LastSymLoadError & SYMLOAD_PDBERRORMASK)) {
                    g.LastSymLoadError = SYMLOAD_PDBNOTFOUND;
                }
            } else {
                eprint("%s\n", diaErrorText(hr));
                g.LastSymLoadError = (hr << 8) & SYMLOAD_PDBERRORMASK;
            }
        } else {
            pIDD->PdbSrc = srcCVRec;
        }
    }

    if (hr == S_OK) {
        eprint("OK\n");
        // Store the name of the PDB we actually opened for later reference.
        strcpy(szPDB, szPDBLocal);
        SetLastError(NO_ERROR);
        g.LastSymLoadError = SYMLOAD_OK;
    }

    if (hr != S_OK && (PdbSignature || ValidGUID(PdbGUID)) && (g.SymOptions & SYMOPT_LOAD_ANYTHING))
        return diaLocatePdb(pIDD, szPDB, NULL, 0, 0, SavedSymbolPath, szImageExt, ipNone);

    return hr;
}


BOOL
diaGetFPOTable(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    DWORD   celt;
    LONG    count;
    DWORD   cb;
    PBYTE   buf;
    HRESULT hr;
    PDIA    pdia;
    VARIANT var;

    CComPtr< IDiaEnumDebugStreams > idiaStreams;
    CComPtr< IDiaEnumDebugStreamData > idiaStream;

    assert (pIDD && pIDD->dia);

    pdia = (PDIA)pIDD->dia;

    hr = pdia->session->getEnumDebugStreams(&idiaStreams);
    if (hr != S_OK)
        return FALSE;

    var.vt = VT_BSTR;
    var.bstrVal = L"FPO";
    hr = idiaStreams->Item(var, &idiaStream);
    if (hr != S_OK)
        return FALSE;

    hr = idiaStream->get_Count(&count);
    if (hr != S_OK)
        return FALSE;
    if (count < 1)
        return TRUE;

    hr = idiaStream->Next(count, 0, &cb, NULL, &celt);
    if (hr != S_OK)
        return FALSE;
    if (cb < 1)
        return TRUE;

    buf = (PBYTE)MemAlloc(cb);
    if (!buf)
        return FALSE;

    hr = idiaStream->Next(count, cb, &cb, buf, &celt);
    if (hr != S_OK) {
        MemFree(buf);
        return FALSE;
    }

    pIDD->cFpo = count;
    pIDD->pFpo = buf;


    return TRUE;
}


BOOL
diaGetPData(
    PMODULE_ENTRY    mi
    )
{
    DWORD   celt;
    LONG    count;
    DWORD   cb;
    PBYTE   buf;
    HRESULT hr;
    PDIA    pdia;
    VARIANT var;

    CComPtr< IDiaEnumDebugStreams > idiaStreams;
    CComPtr< IDiaEnumDebugStreamData > idiaStream;

    assert (mi && mi->dia);

    pdia = (PDIA)mi->dia;

    hr = pdia->session->getEnumDebugStreams(&idiaStreams);
    if (hr != S_OK)
        return FALSE;

    var.vt = VT_BSTR;
    var.bstrVal = L"PDATA";
    hr = idiaStreams->Item(var, &idiaStream);
    if (hr != S_OK)
        return FALSE;

    hr = idiaStream->get_Count(&count);
    if (hr != S_OK)
        return FALSE;
    if (count < 1)
        return TRUE;

    hr = idiaStream->Next(count, 0, &cb, NULL, &celt);
    if (hr != S_OK)
        return FALSE;
    if (cb < 1)
        return TRUE;

    buf = (PBYTE)MemAlloc(cb);
    if (!buf)
        return FALSE;

    hr = idiaStream->Next(count, cb, &cb, buf, &celt);
    if (hr != S_OK) {
        MemFree(buf);
        return FALSE;
    }

    mi->dsExceptions = dsDia;
    mi->cPData  = count;
    mi->cbPData = cb;
    mi->pPData  = buf;

    return TRUE;
}


BOOL
diaGetXData(
    PMODULE_ENTRY    mi
    )
{
    DWORD   celt;
    LONG    count;
    DWORD   cb;
    PBYTE   buf;
    HRESULT hr;
    PDIA    pdia;
    VARIANT var;

    CComPtr< IDiaEnumDebugStreams > idiaStreams;
    CComPtr< IDiaEnumDebugStreamData > idiaStream;

    assert (mi && mi->dia);

    pdia = (PDIA)mi->dia;
    if (!pdia)
        return FALSE;

    hr = pdia->session->getEnumDebugStreams(&idiaStreams);
    if (hr != S_OK)
        return FALSE;

    var.vt = VT_BSTR;
    var.bstrVal = L"XDATA";
    hr = idiaStreams->Item(var, &idiaStream);
    if (hr != S_OK)
        return FALSE;

    hr = idiaStream->get_Count(&count);
    if (hr != S_OK)
        return FALSE;
    if (count < 1)
        return TRUE;

    hr = idiaStream->Next(count, 0, &cb, NULL, &celt);
    if (hr != S_OK)
        return FALSE;
    if (cb < 1)
        return TRUE;

    CComQIPtr< IDiaImageData, &IID_IDiaImageData > idiaXDataHdr(idiaStream);
    if (!idiaXDataHdr.p)
        return FALSE;

    DWORD relativeVirtualAddress;
    if (FAILED(hr = idiaXDataHdr->get_relativeVirtualAddress(&relativeVirtualAddress)))
        return FALSE;

    buf = (PBYTE)MemAlloc(cb + sizeof(DWORD));
    if (!buf)
        return FALSE;

    memcpy(buf, &relativeVirtualAddress, sizeof(relativeVirtualAddress));

    hr = idiaStream->Next(count, cb, &cb, buf + sizeof(DWORD), &celt);
    if (hr != S_OK) {
        MemFree(buf);
        return FALSE;
    }

    mi->dsExceptions = dsDia;
    mi->cXData  = count;
    mi->cbXData = cb;
    mi->pXData  = buf;

    return TRUE;
}


BOOL
diaGetOmaps(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    DWORD   celt;
    LONG    count;
    DWORD   cb;
    PBYTE   tbuf = NULL;
    PBYTE   fbuf = NULL;
    HRESULT hr;
    PDIA    pdia;
    VARIANT var;

    CComPtr< IDiaEnumDebugStreams > idiaStreams;
    CComPtr< IDiaEnumDebugStreamData > idiaStream;

    assert (pIDD && pIDD->dia);

    pdia = (PDIA)pIDD->dia;

    hr = pdia->session->getEnumDebugStreams(&idiaStreams);
    if (hr != S_OK)
        return FALSE;

    var.vt = VT_BSTR;
    var.bstrVal = L"OMAPTO";
    hr = idiaStreams->Item(var, &idiaStream);
    if (hr != S_OK)
        return FALSE;

    hr = idiaStream->get_Count(&count);
    if (hr != S_OK)
        return FALSE;
    if (count < 1)
        return TRUE;

    hr = idiaStream->Next(count, 0, &cb, NULL, &celt);
    if (hr != S_OK)
        return FALSE;
    if (cb < 1)
        return TRUE;

    tbuf = (PBYTE)MemAlloc(cb);
    if (!tbuf)
        return FALSE;

    hr = idiaStream->Next(count, cb, &cb, tbuf, &celt);
    if (hr != S_OK)
        goto CleanReturnFalse;

    pIDD->cOmapTo = count;
    pIDD->pOmapTo = (POMAP)tbuf;

    idiaStream = NULL;

    var.vt = VT_BSTR;
    var.bstrVal = L"OMAPFROM";
    hr = idiaStreams->Item(var, &idiaStream);
    if (hr != S_OK)
        return FALSE;

    hr = idiaStream->get_Count(&count);
    if (hr != S_OK)
        return FALSE;
    if (count < 1)
        return TRUE;

    hr = idiaStream->Next(count, 0, &cb, NULL, &celt);
    if (hr != S_OK)
        return FALSE;
    if (cb < 1)
        return TRUE;

    fbuf = (PBYTE)MemAlloc(cb);
    if (!fbuf)
        return FALSE;

    hr = idiaStream->Next(count, cb, &cb, fbuf, &celt);
    if (hr != S_OK)
        goto CleanReturnFalse;

    pIDD->cOmapFrom = count;
    pIDD->pOmapFrom = (POMAP)fbuf;

    return TRUE;

CleanReturnFalse:
    MemFree(tbuf);
    MemFree(fbuf);
    return FALSE;
}


void
diaRelease(
    PVOID dia
    )
{
    PDIA pdia = (PDIA)dia;
    delete pdia;
}


BOOL
diaOpenPdb(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    HRESULT hr;
    PDIA    pdia;
    PCHAR   szLocalSymbolPath = NULL;
    DWORD   cpathlen = 0;
    CHAR    szExt[_MAX_EXT] = {0};
    int     ip;

    if (pIDD->SymbolPath)
        cpathlen = strlen(pIDD->SymbolPath);
    szLocalSymbolPath = (PCHAR)MemAlloc(cpathlen + strlen(pIDD->PdbReferencePath) + 2);
    if (!szLocalSymbolPath) {
        return FALSE;
    }
    *szLocalSymbolPath = 0;

    ip = ipNone;
    if (pIDD->ImageSrc != srcSymSrv)
        strcpy(szLocalSymbolPath, pIDD->PdbReferencePath);
    if (*szLocalSymbolPath) {
        if (pIDD->SymbolPath)
            strcat(szLocalSymbolPath, ";");
        ip = ipFirst;
    }
    if (pIDD->SymbolPath)
        strcat(szLocalSymbolPath, pIDD->SymbolPath);
    if (pIDD->ImageSrc == srcSymSrv) {
        if (pIDD->PdbReferencePath) {
            if (*szLocalSymbolPath)
                strcat(szLocalSymbolPath, ";");
            strcat(szLocalSymbolPath, pIDD->PdbReferencePath);
            ip = ipLast;
        }
    }

    if (*pIDD->ImageFilePath) {
        _splitpath(pIDD->ImageFilePath, NULL, NULL, NULL, szExt);
    } else if (*pIDD->ImageName) {
        _splitpath(pIDD->ImageName, NULL, NULL, NULL, szExt);
    }

    // if we have no valid filename, then this must be an executable

    if (!*szExt)
        strcpy(szExt, ".exe");

    // get interface to dia

    pdia = new DIA;
    if (!pdia) {
        hr = E_PDB_OUT_OF_MEMORY;
        goto error;
    }
    pIDD->dia = pdia;

    pdia->source = NULL;
    hr = DiaCoCreate(CLSID_DiaSourceAlt, IID_IDiaDataSource, (void **)&pdia->source);
    if (hr != S_OK)
        goto error;

    // go ahead and get pdb

    SetCriticalErrorMode();

    hr = diaLocatePdb(pIDD,
                      pIDD->PdbFileName,
                      &pIDD->PdbGUID,
                      pIDD->PdbSignature,
                      pIDD->PdbAge,
                      szLocalSymbolPath,
                      &szExt[1],
                      ip);

    ResetCriticalErrorMode();

    MemFree(szLocalSymbolPath);
    szLocalSymbolPath = NULL;

    if (hr != S_OK) {
        hr = S_OK;  // error was already handled by diaLocatePdb()
        goto error;
    }

    // open the session on the pdb

    pdia->session = NULL;
    hr = pdia->source->openSession(&pdia->session);
    if (hr != S_OK)
        goto error;

    // Set the module load address so we can use VAs.
    hr = pdia->session->put_loadAddress(pIDD->InProcImageBase);
    if (hr != S_OK)
        goto error;
    
    // fixup the address map so that we can translate rva to full addresses

    hr = pdia->session->QueryInterface(IID_IDiaAddressMap, (void**)&pdia->addrmap);
    if (hr != S_OK)
        goto error;

    if (pIDD->pCurrentSections) {
        hr = pdia->addrmap->set_imageHeaders(pIDD->cCurrentSections * sizeof(IMAGE_SECTION_HEADER),
                                             (BYTE *)pIDD->pCurrentSections,
                                             FALSE);
        if (hr != S_OK)
            goto error;
    }

    // this hack is to fix a problem with v7 pdbs not storing the original image alignment

    if (pIDD->ImageAlign) {
        hr = pdia->addrmap->put_imageAlign(pIDD->ImageAlign);
        if (hr != S_OK)
            goto error;
    }

    // pass in the omap information and setup the proper image alignment to the original

    if (pIDD->cOmapFrom && pIDD->pOmapFrom) {
        hr = pdia->addrmap->put_imageAlign(pIDD->ImageAlign);
        if (hr != S_OK)
            goto error;
        hr = pdia->addrmap->set_addressMap(pIDD->cOmapTo, (DiaAddressMapEntry *)pIDD->pOmapTo, TRUE);
        if (hr != S_OK)
            goto error;
        hr = pdia->addrmap->set_addressMap(pIDD->cOmapFrom, (DiaAddressMapEntry *)pIDD->pOmapFrom, FALSE);
        if (hr != S_OK)
            goto error;
        hr = pdia->addrmap->put_addressMapEnabled(TRUE);
        if (hr != S_OK)
            goto error;
    }

    hr = pdia->addrmap->put_relativeVirtualAddressEnabled(TRUE);
    if (hr != S_OK)
        goto error;

    diaGetFPOTable(pIDD);
    diaGetOmaps(pIDD);

    return TRUE;

error:
    if (hr)
        dprint("%s\n", pIDD->PdbFileName, diaErrorText(hr));

    MemFree(szLocalSymbolPath);

    if (pdia) {
        diaRelease(pdia);
        pIDD->dia = NULL;
    }
    return FALSE;
}


DWORD64
GetAddressFromRva(
    PMODULE_ENTRY mi,
    DWORD         rva
    )
{
    DWORD64 addr;

    assert(mi);
    addr = rva ? mi->BaseOfDll + rva : 0;
    return addr;
}


BOOL
diaFillSymbolInfo(
    PSYMBOL_INFO   si,
    PMODULE_ENTRY  mi,
    IDiaSymbol    *idiaSymbol
    )
{
    HRESULT hr;
    BSTR    wname=NULL;
    CHAR    name[MAX_SYM_NAME + 1];
    VARIANT var;
//  DWORD   tag;
    DWORD   dw;
    ULONG64 size;
    BOOL    rc;

    rc = TRUE;

    dw = si->MaxNameLen;
    ZeroMemory(si, sizeof(SYMBOL_INFO));
    si->MaxNameLen = dw;

    // si->SizeOfStruct = IGNORED;

    // si->TypeIndex = NYI;

    // si->Reserved = IGNORED;

    si->ModBase = mi->BaseOfDll;

    hr = idiaSymbol->get_symTag(&si->Tag);
    if (hr != S_OK)
        return FALSE;

    switch (si->Tag)
    {
    case SymTagData:
        hr = idiaSymbol->get_locationType(&dw);
        if (hr != S_OK)
            return FALSE;
        switch(dw)
        {
        case LocIsStatic:
        case LocIsTLS:
            hr = idiaSymbol->get_relativeVirtualAddress(&dw);
            si->Address = GetAddressFromRva(mi, dw);
            if (!si->Address)
                rc = FALSE;
            break;

        case LocIsEnregistered:
            hr = idiaSymbol->get_registerId(&si->Register);
            si->Flags = IMAGEHLP_SYMBOL_INFO_REGISTER;
            LookupRegID(si->Register, mi->MachineType,&si->Register) ;
            break;

        case LocIsRegRel:
            si->Flags = IMAGEHLP_SYMBOL_INFO_REGRELATIVE;
            hr = idiaSymbol->get_registerId(&si->Register);
            if (hr != S_OK)
                return FALSE;
            hr = idiaSymbol->get_offset((PLONG)&dw);
            LookupRegID(si->Register, mi->MachineType,&si->Register) ;
            si->Address = (ULONG64) (LONG64) (LONG) dw;
            break;

        case LocIsThisRel:
        // struct members - get_Offset
        default:
            si->Flags |= 0;
            break;
        }
        break;

    case SymTagFunction:
    case SymTagPublicSymbol:
    case SymTagThunk:
        hr = idiaSymbol->get_relativeVirtualAddress(&dw);
        si->Address = GetAddressFromRva(mi, dw);
        if (!si->Address)
            rc = FALSE;
        break;

    default:
        break;
    }

    if (hr != S_OK)
        return FALSE;

    hr = idiaSymbol->get_dataKind(&dw);
    if (hr == S_OK) {
        if (dw == DataIsParam)
            si->Flags |= IMAGEHLP_SYMBOL_INFO_PARAMETER;
        else if (dw == DataIsConstant)
            si->Flags = IMAGEHLP_SYMBOL_INFO_CONSTANT;
    }

    hr = idiaSymbol->get_typeId(&dw);
    if (hr == S_OK)
        si->TypeIndex = dw;

    hr = idiaSymbol->get_name(&wname);
    if (hr != S_OK || !wname)
        return FALSE;
    if (!wname[0]) {
        rc = FALSE;
    } else {
        wcs2ansi(wname, name, MAX_SYM_NAME);
        if (*name == '.')
            si->Flags = IMAGEHLP_SYMBOL_FUNCTION;
//      if (traceSubName(name)) // for setting debug breakpoints from DBGHELP_TOKEN
//          dprint("debug(%s)\n", name);
        if (g.SymOptions & SYMOPT_UNDNAME)
            SymUnDNameInternal(si->Name,
                               si->MaxNameLen,
                               name,
                               strlen(name),
                               mi->MachineType,
                               si->Tag == SymTagPublicSymbol);
        else
            strcpy(si->Name, name);

        // let the caller know this is a $$$XXXAA style symbol
        if (strlen(si->Name) == 8 && !strncmp(si->Name, "$$$",3) &&
            isxdigit(si->Name[5]) && isxdigit(si->Name[6]) && isxdigit(si->Name[7]) )
        {
            rc = FALSE;
        }
    }
    if (wname)
        LocalFree (wname);

//  if (traceSubName(name)) // for setting debug breakpoints from DBGHELP_TOKEN
//      dprint("debug(%s)\n", name);

    hr = idiaSymbol->get_length(&size);
    if (hr == S_OK)
        si->Size = (ULONG)size;
    else {
        CComPtr <IDiaSymbol> pType;
        if ((hr = idiaSymbol->get_type(&pType)) == S_OK){
            hr = pType->get_length(&size);
            if (hr == S_OK)
                si->Size = (ULONG)size;
        }
        pType = NULL;
    }

    return rc;
}


BOOL
diaSetModFromIP(
    PPROCESS_ENTRY pe
    )
{
    HRESULT hr;
    DWORD64 ip;
    DWORD   rva;
    PDIA    pdia;

    // get the current IP

    ip = GetIP(pe);
    if (!ip) {
        pprint(pe, "IP not set!\n");
        return FALSE;
    }

    // find and load symbols for the module that matches the IP

    pe->ipmi = GetModFromAddr(pe, ip);

    if (!pe->ipmi)
        return FALSE;

    if (!pe->ipmi->dia)
        return FALSE;

    pdia = (PDIA)pe->ipmi->dia;
    rva = (DWORD)(ip - pe->ipmi->BaseOfDll);
    pdia->scope = NULL; // delete previous scope

    CComPtr< IDiaSymbol > idiaScope;
    hr = pdia->session->findSymbolByRVA(rva, SymTagNull, &idiaScope);
    if (hr != S_OK)
        return FALSE;

    hr = pdia->session->symsAreEquiv(idiaScope, pdia->scope);
    if (hr != S_OK) {
//      pprint(pe, "Scope changed [0x%x]\n", rva);
        pdia->scope = idiaScope;
        return TRUE;
    }

    return FALSE;
}


PWCHAR
ConvertNameForDia(
    LPSTR  name,
    PWCHAR wname
    )
{
    assert (name && wname);
    if (!name || !*name)
        return NULL;

    ansi2wcs(name, wname, MAX_SYM_NAME);

    return wname;
}


VOID
MakeEmbeddedREStr(
    PCHAR out,
    PCHAR in
    )
{
    if (*in != '*') 
        *out++ = '*';

    for (; *in; in++, out++)
        *out = *in;

    if (*(in - 1) != '*')
        *out++ = '*';

    *out = 0;
}


BOOL
PrepareForCPPMatch(
    LPSTR in,
    LPSTR out
    )
{
    LPSTR p;

    assert(in && out);

    if (strlen(in) > MAX_SYM_NAME)
        return FALSE;

    for (; *in; in++, out++) {
        if (*in == '_' && *(in + 1) == '_') {
            strcpy(out, "[_:][_:]");
            out += 7;
            in++;
        } else {
            *out = *in;
        }
    }
    *out = 0;

    return TRUE;
}


BOOL
diaGetLocals(
    PPROCESS_ENTRY pe,
    LPSTR          name,
    PROC           callback,
    PVOID          context,
    BOOL           use64,
    BOOL           unicode
    )
{
    PMODULE_ENTRY     mi;
    DWORD64           ip;
    DWORD             rva;
    PDIA              pdia;
    HRESULT           hr;
    DWORD             rc;
    DWORD             tag;
    DWORD             scope;
    DWORD             celt;
    DWORD             opt;
    CHAR              symname[MAX_SYM_NAME + 1];
    WCHAR             wbuf[MAX_SYM_NAME + 1];
    PWCHAR            wname;

    assert(pe);

    CComPtr< IDiaSymbol > idiaSymbols;

    opt = (g.SymOptions & SYMOPT_CASE_INSENSITIVE) ? nsCaseInRegularExpression : nsRegularExpression;

    // get the current scope

    mi = pe->ipmi;
    if (!mi)
        return FALSE;
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return FALSE;

    idiaSymbols = pdia->scope;

    if (!PrepareForCPPMatch(name, symname))
        return FALSE;
    wname = ConvertNameForDia(symname, wbuf);

    // loop through all symbols

    for ( ; idiaSymbols != NULL; ) {

        CComPtr< IDiaEnumSymbols > idiaEnum;
        // local data search
        hr = idiaSymbols->findChildren(SymTagNull, wname, opt, &idiaEnum);
        if (hr != S_OK)
            return FALSE;

        idiaSymbols->get_symTag(&scope);
        if (hr != S_OK)
            return FALSE;

        if (scope == SymTagExe) { // sanity check, never enumerate all exe's symbols
            break;
        }
        // this walks the local symbol list for the loaded enumeration

        CComPtr< IDiaSymbol > idiaSymbol;

        for (;
             SUCCEEDED(hr = idiaEnum->Next( 1, &idiaSymbol, &celt)) && celt == 1;
             idiaSymbol = NULL)
        {
                ULONG DataKind;
            idiaSymbol->get_symTag(&tag);
            switch (tag)
            {
            case SymTagData:
            case SymTagFunction:
                if (!diaFillSymbolInfo(&mi->si, mi, idiaSymbol))
                    continue;
                if (!strcmp(mi->si.Name, "`string'"))
                    continue;
                mi->si.Scope = scope;
                mi->si.Flags |= IMAGEHLP_SYMBOL_INFO_LOCAL;
                if (!callback)
                    return TRUE;
                if (mi->si.Flags & IMAGEHLP_SYMBOL_INFO_CONSTANT)
                    continue;
                rc = DoEnumCallback(pe, &mi->si, mi->si.Size, callback, context, use64, unicode);
                if (!rc) {
                    mi->code = ERROR_CANCELLED;
                    return rc;
                }
                break;
            default:
                break;
            }
        }


    if (callback && scope == SymTagFunction)    // stop when at function scope
            break;

        // move to lexical parent

        CComPtr< IDiaSymbol > idiaParent;
        hr = idiaSymbols->get_lexicalParent(&idiaParent);
        if (hr != S_OK || !idiaParent)
            return FALSE;

        idiaSymbols = idiaParent;
    }

    // We reached the end.  If we enumerating (I.E. callback != NULL)
    // then return true.  If we are searching for a single match, 
    // we have failed and should return FALSE;

    if (callback)
        return TRUE;
    return FALSE;
}


int __cdecl
CompareAddrs(
    const void *addr1,
    const void *addr2
    )
{
    LONGLONG Diff = *(DWORD64 *)addr1 - *(DWORD64 *)addr2;

    if (Diff < 0) {
        return -1;
    } else if (Diff > 0) {
        return 1;
    } else {
        return 0;
    }
}


PDWORD64
FindAddr(
    PDWORD64 pAddrs,
    ULONG cAddrs,
    DWORD64  addr
    )
{
    LONG high;
    LONG low;
    LONG i;
    LONG  rc;

    low = 0;
    high = ((LONG)cAddrs) - 1;

    while (high >= low) {
        i = (low + high) >> 1;
        rc = CompareAddrs(&addr, &pAddrs[i]);

        if (rc < 0)
            high = i - 1;
        else if (rc > 0)
            low = i + 1;
        else
            return &pAddrs[i];
    }

    return NULL;
}


BOOL
diaGetGlobals(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi,
    LPSTR          name,
    PROC           callback,
    PVOID          context,
    BOOL           use64,
    BOOL           unicode
    )
{
    PDIA              pdia;
    HRESULT           hr;
    DWORD             tag;
    DWORD             celt;
    DWORD             rc;
    LONG              cFuncs;
    LONG              cGlobals = 0;
    enum SymTagEnum   SearchTag;
    PDWORD64          pGlobals = NULL;
    PDWORD64          pg       = NULL;
    PWCHAR            wname;
    DWORD             opt;
    WCHAR             wbuf[MAX_SYM_NAME + 1];
    CHAR              symname[MAX_SYM_NAME + 1];
    CHAR              pname[MAX_SYM_NAME + 1];
    BOOL              fCase;

    CComPtr<IDiaSymbol>        idiaSymbol;
    CComPtr< IDiaSymbol >      idiaGlobals;
    CComPtr< IDiaEnumSymbols > idiaSymbols;

    // check parameters

    assert(pe && mi && name);

    if (!callback && !name)
        return FALSE;

    if (!PrepareForCPPMatch(name, symname))
        return FALSE;
    wname = ConvertNameForDia(symname, wbuf);

    if (g.SymOptions & SYMOPT_CASE_INSENSITIVE) {
        opt = nsCaseInRegularExpression;
        fCase = FALSE;
    } else {
        opt = nsRegularExpression;
        fCase = TRUE;
    };

    // get a session

    pdia = (PDIA)mi->dia;
    if (!pdia)
        return FALSE;

    hr = pdia->session->get_globalScope(&idiaGlobals);
    if (hr != S_OK)
        return FALSE;

    // if this is an enumeration, we will have to store a list of the addresses
    // of all the symbols we found in the global scope.  Later we will compare
    // this to the publics so as to eliminate doubles.

    if (callback) {
        hr = idiaGlobals->findChildren(SymTagData, wname, opt, &idiaSymbols);
        if (hr != S_OK)
            return FALSE;
        hr = idiaSymbols->get_Count(&cGlobals);
        if (hr != S_OK)
            return FALSE;
        idiaSymbols = NULL;

        hr = idiaGlobals->findChildren(SymTagFunction, wname, opt, &idiaSymbols);
        if (hr != S_OK)
            return FALSE;
        hr = idiaSymbols->get_Count(&cFuncs);
        if (hr != S_OK)
            return FALSE;
        idiaSymbols = NULL;

        cGlobals += cFuncs;
        pGlobals = (PDWORD64)MemAlloc(cGlobals * sizeof(DWORD64));
    }

    if (callback && (!cGlobals || !pGlobals))
        goto publics;

    if (pGlobals) ZeroMemory(pGlobals, cGlobals * sizeof(DWORD64));

    // First search for data
    SearchTag = SymTagData;
    hr = idiaGlobals->findChildren(SearchTag, wname, opt, &idiaSymbols);
    if (hr != S_OK)
        goto publics;

    for (pg = pGlobals;
         (SUCCEEDED(hr = idiaSymbols->Next( 1, &idiaSymbol, &celt)) && celt == 1) || (SearchTag == SymTagData);
         idiaSymbol = NULL)
    {
        ULONG DataKind;

        if ((SearchTag == SymTagData) && (FAILED(hr) || celt != 1)) {
            // Now search for functions
            SearchTag = SymTagFunction;
            idiaSymbols = NULL;
            hr = idiaGlobals->findChildren(SearchTag, wname, opt, &idiaSymbols);
            if (hr != S_OK)
                goto publics;
            continue;
        }

        idiaSymbol->get_symTag(&tag);
        switch (tag)
        {
        case SymTagData:
        case SymTagFunction:
            assert(!callback || ((LONG)(pg - pGlobals) < cGlobals));
            if (!diaFillSymbolInfo(&mi->si, mi, idiaSymbol))
                continue;
            if (!strcmp(mi->si.Name, "`string'"))
                continue;
            mi->si.Scope = SymTagExe;
            if (!callback) 
                return TRUE;
            if (mi->si.Flags & IMAGEHLP_SYMBOL_INFO_CONSTANT)
                continue;
            if (pg)
                *pg++ = mi->si.Address;
            rc = DoEnumCallback(pe, &mi->si, mi->si.Size, callback, context, use64, unicode);
            if (!rc) {
                mi->code = ERROR_CANCELLED;
                goto exit;
            }
            break;
        default:
            break;
        }
    }

    qsort(pGlobals, cGlobals, sizeof(DWORD64), CompareAddrs);

publics:
    // now check out the publics table

    if (wname) {
        sprintf(pname, "*%s*", symname);
        MakeEmbeddedREStr(pname, symname);
        wname = ConvertNameForDia(pname, wbuf);
    }

    idiaSymbols = NULL;

    opt |= nsfUndecoratedName;

    hr = idiaGlobals->findChildren(SymTagPublicSymbol, wname, opt, &idiaSymbols);
    if (hr != S_OK)
        goto exit;

    for (;
         SUCCEEDED(hr = idiaSymbols->Next( 1, &idiaSymbol, &celt)) && celt == 1;
         idiaSymbol = NULL)
    {
        if (!diaFillSymbolInfo(&mi->si, mi, idiaSymbol))
            continue;
        mi->si.Scope = SymTagPublicSymbol;
        if (!strcmp(mi->si.Name, "`string'"))
            continue;
        // publics names are mangled: this tests the undecorated name against the mask
        if (*name && strcmpre(mi->si.Name, name, fCase))
            continue;
        if (!callback) 
            return TRUE;
        if (FindAddr(pGlobals, cGlobals, mi->si.Address))
            continue;
        rc = DoEnumCallback(pe, &mi->si, mi->si.Size, callback, context, use64, unicode);
        if (!rc) {
            mi->code = ERROR_CANCELLED;
            goto exit;
        }
    }

    // We reached the end.  If we are not enumerating (I.E. callback == NULL)
    // then return the result of the last call to the callback.  If we are
    // searching for a single match, we have failed and should return FALSE;

exit:
    MemFree(pGlobals);
    if (!callback)
        return FALSE;
    return rc;
}




BOOL
diaGetSymbols(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi,
    LPSTR          name,
    PROC           callback,
    PVOID          context,
    BOOL           use64,
    BOOL           unicode
    )
{
    // ENUMFIX:
    LPSTR pname = (name) ? name : "";

    if (mi) {
        return diaGetGlobals(pe, mi, pname, callback, context, use64, unicode);
    } else {
        return diaGetLocals(pe, pname, callback, context, use64, unicode);
    }
}


PSYMBOL_ENTRY
diaFindSymbolByName(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    )
{
    SYMPTR sym;
    char   sz[MAX_SYM_NAME + 1];

    if (!diaGetSymbols(pe, mi, SymName, NULL, NULL, 0, 0))
        return NULL;

    if (!mi)
        mi = pe->ipmi;

    CopySymbolEntryFromSymbolInfo(&mi->TmpSym, &mi->si);

    return &mi->TmpSym;
}


BOOL
diaEnumerateSymbols(
    IN PPROCESS_ENTRY pe,
    IN PMODULE_ENTRY  mi,
    IN LPSTR          mask,
    IN PROC           callback,
    IN PVOID          context,
    IN BOOL           use64,
    IN BOOL           unicode
    )
{
    return diaGetSymbols(pe, mi, mask, callback, context, use64, unicode);
}


PSYMBOL_ENTRY
diaGetSymFromAddr(
    DWORD64         addr,
    PMODULE_ENTRY   mi,
    PDWORD64        disp
    )
{
    HRESULT hr;
    PDIA    pdia;
    DWORD   rva;
    DWORD   tag;
    LONG    omapadj;
    BOOL    fHitBlock;

    // simple sanity check

    if (!addr)
        return NULL;

    assert (mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

//  if (traceAddr(addr))   // for debug breakpoints ...
//      dprint("found 0x%I64x\n", addr);

    rva = (DWORD)(addr - mi->BaseOfDll);

    // get the symbol

    CComPtr< IDiaSymbol > idiaSymbol;
    hr = pdia->session->findSymbolByRVAEx(rva, SymTagNull, &idiaSymbol, &omapadj);
    if (hr != S_OK)
        return NULL;

    // if the symbol is a block, keep grabbing the parent
    // until we get a function...

    fHitBlock = FALSE;
    idiaSymbol->get_symTag(&tag);
    while (tag == SymTagBlock) {       // SymTagLabel as well?
        CComPtr< IDiaSymbol > idiaParent;
        fHitBlock = TRUE;
        hr = idiaSymbol->get_lexicalParent(&idiaParent);
        if (hr != S_OK || !idiaParent)
            return NULL;
        idiaSymbol = idiaParent;
        idiaSymbol->get_symTag(&tag);
    }

    if (!diaFillSymbolInfo(&mi->si, mi, idiaSymbol)) {
        // return a public symbol
        idiaSymbol = NULL;
        hr = pdia->session->findSymbolByRVAEx(rva, SymTagPublicSymbol, &idiaSymbol, &omapadj);
        if (hr == S_OK) 
            diaFillSymbolInfo(&mi->si, mi, idiaSymbol);
        else
            eprint(" couldn't match name! disp=0x%x rva=0x%x addr=0x%I64x\n", omapadj, rva, addr);
    }

    CopySymbolEntryFromSymbolInfo(&mi->TmpSym, &mi->si);

    if (disp) 
        *disp = (fHitBlock) ? addr - mi->si.Address : omapadj;

    return &mi->TmpSym;
}

BOOL
diaGetLineFromAddr(
    PMODULE_ENTRY    mi,
    DWORD64          addr,
    PDWORD           displacement,
    PIMAGEHLP_LINE64 line
    )
{
    HRESULT hr;
    PDIA    pdia;
    DWORD   rva;
    DWORD   celt;
    BSTR    bstr;
    DWORD   dw;
    BOOL    rc;

    assert(mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    if (line->SizeOfStruct != sizeof(IMAGEHLP_LINE64))
        return FALSE;

    rva = (DWORD)(addr - mi->BaseOfDll);

    CComPtr< IDiaEnumLineNumbers > idiaLines = NULL;
    hr = pdia->session->findLinesByRVA(rva, 1, &idiaLines);
    if (hr != S_OK)
        return FALSE;

    CComPtr< IDiaLineNumber > idiaLine = NULL;
    hr = idiaLines->Next(1, &idiaLine, &celt);
    if (hr != S_OK || !idiaLine)
        return FALSE;

   //  line->Key = 0;
    hr = idiaLine->get_lineNumber(&dw);
    if (hr != S_OK)
        return FALSE;

    line->LineNumber = dw;

    pdia->srcfile = NULL;
    hr = idiaLine->get_sourceFile(&pdia->srcfile);
    if (hr != S_OK)
        return FALSE;

    hr = pdia->srcfile->get_fileName(&bstr);
    if (hr != S_OK)
        return FALSE;

    *mi->SrcFile = 0;
    rc = wcs2ansi(bstr, mi->SrcFile, lengthof(mi->SrcFile));
    if (!rc || !*mi->SrcFile) {
        LocalFree(bstr);
        return FALSE;
    }

    LocalFree(bstr);

    line->FileName = mi->SrcFile;

    hr = idiaLine->get_relativeVirtualAddress(&dw);
    if (hr != S_OK)
        return FALSE;

    line->Address = dw + mi->BaseOfDll;
    *displacement = rva - dw;

    return TRUE;
}


BOOL
diaGetLineNextPrev(
    PMODULE_ENTRY    mi,
    PIMAGEHLP_LINE64 line,
    DWORD            direction
    )
{
    HRESULT hr;
    PDIA    pdia;
    DWORD   rva;
    DWORD   celt;
    WCHAR   wbuf[MAX_PATH + 1];
    BSTR    wfname = NULL;
    DWORD   lineno;
    DWORD   dw;

    // simple sanity checks

    assert(mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    assert(direction == NP_NEXT || direction == NP_PREV);

    if (line->SizeOfStruct != sizeof(IMAGEHLP_LINE64))
        return FALSE;

    // convert file name for DIA

    if (!*line->FileName)
        return FALSE;

    ansi2wcs(line->FileName, wbuf, MAX_PATH);
    wfname = wbuf;

    // all source files in the module  that match the 'wfname'

    CComPtr< IDiaEnumSourceFiles > idiaFiles = NULL;
    hr = pdia->session->findFile(NULL, wfname,  nsCaseInsensitive, &idiaFiles);
    if (hr != S_OK)
        return FALSE;

    // the first such file in the list, since we don't use wildcards

    CComPtr< IDiaSourceFile > idiaFile = NULL;
    hr = idiaFiles->Next(1, &idiaFile, &dw);
    if (hr != S_OK)
        return FALSE;

    // all objs that use this source file

    CComPtr< IDiaEnumSymbols > idiaObjs = NULL;
    hr = idiaFile->get_compilands(&idiaObjs);
    if (hr != S_OK)
        return FALSE;

    // LOOP THROUGH ALL THE OBJS! AND STORE THE CLOSEST!

    lineno = 0;
    rva = 0;

    // grab the first obj, since we don't care

    CComPtr< IDiaSymbol > idiaObj = NULL;
    CComPtr< IDiaLineNumber > idiaLine = NULL;
    CComPtr< IDiaEnumLineNumbers > idiaLines = NULL;

    hr = idiaObjs->Next(1, &idiaObj, &celt);
    if (hr != S_OK)
        return FALSE;

    while (celt) {
        // get the line for starting with
        hr = pdia->session->findLinesByLinenum(idiaObj, idiaFile, line->LineNumber + direction, 0, &idiaLines);
        if (hr == S_OK) {
            hr = idiaLines->Next(1, &idiaLine, &dw);
            if (hr == S_OK) {
                hr = idiaLine->get_lineNumber(&dw);
                if (hr == S_OK) {
                    if (!lineno) {
                        lineno = dw;
                        hr = idiaLine->get_relativeVirtualAddress(&rva);
                    } else if (direction == NP_NEXT) {
                        if (dw < lineno)
                            lineno = dw;
                            hr = idiaLine->get_relativeVirtualAddress(&rva);
                    } else if (dw > lineno) {
                        lineno = dw;
                        hr = idiaLine->get_relativeVirtualAddress(&rva);
                    }
                }
            }
        }
        idiaObj = NULL;
        idiaObjs->Next(1, &idiaObj, &celt);
    }

    if (!lineno)
        return FALSE;

    // Line->Key = SrcLine;
    line->LineNumber = lineno;
    line->Address = GetAddressFromRva(mi, rva);

    return TRUE;
}


#if 0
#define DBG_DIA_LINE 1
#endif
// #define DIA_LINE_NAME 1

BOOL
diaGetLineFromName(
    PMODULE_ENTRY    mi,
    LPSTR            filename,
    DWORD            linenumber,
    PLONG            displacement,
    PIMAGEHLP_LINE64 line
    )
{
    HRESULT hr;
    WCHAR   wsz[_MAX_PATH + 1];
    PDIA    pdia;
    DWORD   celt;
    BSTR    bstr;
    DWORD   addr;
    DWORD   num;
    BOOL    rc;

#if DIA_LINE_NAME
    assert(mi && mi->dia && filename);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    if (line->SizeOfStruct != sizeof(IMAGEHLP_LINE64))
        return FALSE;

    if (!*filename)
        return FALSE;

    if (!ansi2wcs(filename, wsz, lengthof(wsz)))
        return FALSE;
    if (!*wsz)
        return FALSE;

    CComPtr<IDiaEnumSourceFiles> idiaSrcFiles;
    hr = pdia->session->findFile(NULL, wsz, nsFNameExt, &idiaSrcFiles);
    if (hr != S_OK)
        return FALSE;

    CComPtr<IDiaSourceFile> idiaSrcFile;
    hr = idiaSrcFiles->Next(1, &idiaSrcFile, &celt);
    if (hr != S_OK)
        return FALSE;

    hr = idiaSrcFile->get_fileName(&bstr);
    if (hr != S_OK)
        return FALSE;

    rc = wcs2ansi(bstr, mi->SrcFile, lengthof(mi->SrcFile));
    if (!rc || !*mi->SrcFile) {
        LocalFree(bstr);
        return FALSE;
    }

    LocalFree(bstr);

    line->FileName = mi->SrcFile;

    // this gives us a list of every .obj that uses this source file
    CComPtr<IDiaEnumSymbols> idiaEnum;
    hr = idiaSrcFile->get_compilands(&idiaEnum);
    if (hr != S_OK)
        return FALSE;

    CComPtr<IDiaSymbol> idiaSymbol;
    CComPtr<IDiaEnumLineNumbers> idiaLineNumbers;
    CComPtr<IDiaLineNumber> idiaLineNumber;

    // walk through the .obj's
    hr = idiaEnum->Next(1, &idiaSymbol, &celt);
    while (hr == S_OK) {
        // This gets a list of all code items that were created from this source line.
        // If we want to fully support inlines and the like, we need to loop all of these
        hr = pdia->session->findLinesByLinenum(idiaSymbol, idiaSrcFile, linenumber, 0, &idiaLineNumbers);
        if (hr != S_OK)
            break;

        idiaLineNumber = NULL;
        hr  = idiaLineNumbers->Next(1, &idiaLineNumber, &celt);
        if (hr != S_OK)
            break;
        hr  = idiaLineNumber->get_lineNumber(&num);
        if (hr != S_OK)
            break;
        line->LineNumber = num;
        hr = idiaLineNumber->get_relativeVirtualAddress(&addr);
        if (hr != S_OK)
            break;
        if (addr) {
            line->Address = mi->BaseOfDll + addr;
            *displacement = linenumber - num;
            return TRUE;
        }
        idiaSymbol = NULL;
        hr = idiaEnum->Next(1, &idiaSymbol, &celt);
    }
#endif
    return FALSE;
}


HRESULT
diaAddLinesForSourceFile(
    PMODULE_ENTRY mi,
    IDiaSourceFile     *idiaSource,
    IDiaSymbol         *pComp
    )
{
    HRESULT hr;
    LPSTR   SrcFileName = NULL;
    BSTR    wfname = NULL;
    ULONG   SrcFileNameLen = 0;
    PSOURCE_ENTRY Src;
    PSOURCE_ENTRY Seg0Src;
    PSOURCE_LINE SrcLine;
    PDIA    pdia;
    ULONG   celt;
    LONG    LineNums;
    ULONG   CompId;
    CHAR    fname[MAX_PATH + 1];
    DWORD   rva;
    ULONG   Line;

    if (!idiaSource) {
        return E_INVALIDARG;
    }

    assert((mi != NULL) && (mi->dia));

    pdia = (PDIA)mi->dia;

    if (pComp->get_symIndexId(&CompId) == S_OK) {
    }

    CComPtr <IDiaEnumLineNumbers> idiaEnumLines;

    if (hr = pdia->session->findLines(pComp, idiaSource, &idiaEnumLines) != S_OK) {

        return hr;
    }

    if (hr = idiaEnumLines->get_Count(&LineNums) != S_OK) {
        return hr;
    }

    CComPtr <IDiaLineNumber> idiaLine;

    if (idiaSource->get_fileName(&wfname) == S_OK && wfname) {
        wcs2ansi(wfname, fname, MAX_PATH);
        LocalFree(wfname);
        SrcFileNameLen = strlen(fname);
    }

    Src = (PSOURCE_ENTRY)MemAlloc(sizeof(SOURCE_ENTRY)+
                              sizeof(SOURCE_LINE)*LineNums+
                              SrcFileNameLen + 1);

    if (!Src) {
        return E_OUTOFMEMORY;
    }

#ifdef DBG_DIA_LINE
    dprint("diaAddLinesForSourceFile : source : %s\n", fname);
#endif

    // Retrieve line numbers and offsets from raw data and
    // process them into current pointers.

    SrcLine = (SOURCE_LINE *)(Src+1);
    Src->LineInfo = SrcLine;
    Src->ModuleId = CompId;
    Src->MaxAddr  = 0;
    Src->MinAddr  = -1;

    Src->Lines = 0;
    idiaLine = NULL;
    for (; (hr = idiaEnumLines->Next(1, &idiaLine, &celt)) == S_OK && (celt == 1); ) {
        hr = idiaLine->get_lineNumber(&Line);
        if (hr != S_OK)
            break;
        hr = idiaLine->get_relativeVirtualAddress(&rva);
        if (hr != S_OK)
            break;


        SrcLine->Line = Line;
        SrcLine->Addr = mi->BaseOfDll + rva;

        // Line symbol information names the IA64 bundle
        // syllables with 0,1,2 whereas the debugger expects
        // 0,4,8.  Convert.
        if (mi->MachineType == IMAGE_FILE_MACHINE_IA64 &&
            (SrcLine->Addr & 3)) {
            SrcLine->Addr = (SrcLine->Addr & ~3) |
                ((SrcLine->Addr & 3) << 2);
        }

        if (SrcLine->Addr > Src->MaxAddr) {
            Src->MaxAddr = SrcLine->Addr;
        }
        if (SrcLine->Addr < Src->MinAddr) {
            Src->MinAddr = SrcLine->Addr;
        }
#ifdef DBG_DIA_LINE
        dprint("Add line %lx, Addr %I64lx\n", SrcLine->Line, SrcLine->Addr);
#endif

        Src->Lines++;
        SrcLine++;
        idiaLine = NULL;
    }

    // Stick file name at the very end of the data block so
    // it doesn't interfere with alignment.
    Src->File = (LPSTR)SrcLine;
    if (*fname) {
        memcpy(Src->File, fname, SrcFileNameLen);
    }
    Src->File[SrcFileNameLen] = 0;

    AddSourceEntry(mi, Src);
    return S_OK;
}


BOOL
diaAddLinesForMod(
    PMODULE_ENTRY mi,
    IDiaSymbol   *diaModule
    )
{
    LONG Size;
    BOOL Ret;
    PSOURCE_ENTRY Src;
    ULONG ModId;
    HRESULT Hr;

    if (diaModule->get_symIndexId(&ModId) != S_OK) {
        return FALSE;
    }
#ifdef DBG_DIA_LINE
        dprint("diaAddLinesForMod : ModId %lx\n", ModId);
#endif

    // Check and see if we've loaded this information already.
    for (Src = mi->SourceFiles; Src != NULL; Src = Src->Next) {
        // Check module index instead of pointer since there's
        // no guarantee the pointer would be the same for different
        // lookups.
        if (Src->ModuleId == ModId) {
            return TRUE;
        }
    }

    PDIA    pdia;
    pdia = (PDIA)mi->dia;

    CComPtr< IDiaEnumSourceFiles > idiaEnumFiles;
    Hr = pdia->session->findFile(diaModule, NULL, nsNone, &idiaEnumFiles);
    if (Hr != S_OK) {
        return FALSE;
    }

    ULONG celt;
    CComPtr <IDiaSourceFile> idiaSource;
    for (;SUCCEEDED(idiaEnumFiles->Next(1,&idiaSource, &celt)) && (celt == 1);) {
        diaAddLinesForSourceFile(mi, idiaSource, diaModule);
        idiaSource = NULL;
    }

    return TRUE;
}

BOOL 
MatchSourceFile(
    PCHAR filename,
    PCHAR mask
    )
{
    PCHAR p;

    if (!mask || !*mask)
        return TRUE;

    if (!*filename)
        return FALSE;

    for (p = filename + strlen(filename); p >= filename; p--) {
        if (*p == '\\' || *p == '/') {
            p++;
            break;
        }
    }

    if (!strcmpre(p, mask, FALSE))
        return TRUE;

    return FALSE;
}

BOOL
diaEnumSourceFiles(
    IN PMODULE_ENTRY mi,
    IN PCHAR         mask,
    IN PSYM_ENUMSOURCFILES_CALLBACK cbSrcFiles,
    IN PVOID         context
    )
{
    HRESULT hr;
    BSTR    wname=NULL;
    char    name[_MAX_PATH + 1];
    SOURCEFILE sf;

    assert(mi && cbSrcFiles);

    PDIA    pdia;
    pdia = (PDIA)mi->dia;

    sf.ModBase = mi->BaseOfDll  ;
    sf.FileName = name;

    CComPtr< IDiaEnumSourceFiles > idiaEnumFiles;
    hr = pdia->session->findFile(NULL, NULL, nsNone, &idiaEnumFiles);
    if (hr != S_OK) 
        return FALSE;

    ULONG celt;
    CComPtr <IDiaSourceFile> idiaSource;
    for (;SUCCEEDED(idiaEnumFiles->Next(1, &idiaSource, &celt)) && (celt == 1);) {
        hr = idiaSource->get_fileName(&wname);
        if (hr == S_OK && wname) {
            wcs2ansi(wname, name, _MAX_PATH);
            LocalFree (wname);
            if (MatchSourceFile(name, mask)) {
                if (!cbSrcFiles(&sf, context)) {
                    mi->code = ERROR_CANCELLED;
                    return FALSE;
                }
            }
        }
        idiaSource = NULL;
    }

    return TRUE;
}

BOOL
diaAddLinesForModAtAddr(
    PMODULE_ENTRY mi,
    DWORD64 Addr
    )
{
    BOOL Ret;
    DWORD Bias;
    HRESULT hr;
    PDIA    pdia;
    DWORD   rva;

    assert(mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    rva = (DWORD)(Addr - mi->BaseOfDll);

    CComPtr < IDiaSymbol > pComp;
    hr = pdia->session->findSymbolByRVA(rva, SymTagCompiland, &pComp);
    if (hr != S_OK)
        return FALSE;

    Ret = diaAddLinesForMod(mi, pComp);

    return Ret;
}

BOOL
diaAddLinesForAllMod(
    PMODULE_ENTRY mi
    )
{
    HRESULT hr;
    PDIA    pdia;
    ULONG   celt = 1;
    BOOL Ret;

    Ret = FALSE;
#ifdef DBG_DIA_LINE
        dprint("diaAddLinesForAllMod : Adding lines for all mods in %s\n", mi->ImageName);
#endif

    assert(mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    CComPtr <IDiaSymbol> idiaSymbols;

    hr = pdia->session->get_globalScope(&idiaSymbols);
    if (hr != S_OK)
        return NULL;

    CComPtr< IDiaEnumSymbols > idiaMods;
    hr = pdia->session->findChildren(idiaSymbols,SymTagCompiland, NULL, nsNone, &idiaMods);
    if (FAILED(hr))
        return FALSE;

    CComPtr< IDiaSymbol > idiaSymbol;

    while (SUCCEEDED(idiaMods->Next( 1, &idiaSymbol, &celt)) && celt == 1) {
        Ret = diaAddLinesForMod(mi, idiaSymbol);
        idiaSymbol = NULL;
        if (!Ret) {
            break;
        }
    }

    return Ret;
}

PSYMBOL_ENTRY
diaGetSymNextPrev(
    PMODULE_ENTRY mi,
    DWORD64       addr,
    int           direction
    )
{
    HRESULT hr;
    PDIA    pdia;
    DWORD   rva;
    DWORD   celt;

    assert(mi && mi->dia);
    pdia = (PDIA)mi->dia;
    if (!pdia)
        return NULL;

    CComPtr<IDiaEnumSymbolsByAddr> idiaSymbols;
    hr = pdia->session->getSymbolsByAddr(&idiaSymbols);
    if (hr != S_OK)
        return NULL;

    rva = addr ? (DWORD)(addr - mi->BaseOfDll) : 0;

    CComPtr<IDiaSymbol> idiaSymbol;
    hr = idiaSymbols->symbolByRVA(rva, &idiaSymbol);
    if (hr != S_OK)
        return NULL;

findsymbol:
    if (addr) {
        if (direction < 0) {
            idiaSymbol = NULL;
            hr = idiaSymbols->Prev(1, &idiaSymbol, &celt);
        } else {
            idiaSymbol = NULL;
            hr = idiaSymbols->Next(1, &idiaSymbol, &celt);
        }
        if (hr != S_OK)
            return NULL;
        if (celt != 1)
            return NULL;
    }

    diaFillSymbolInfo(&mi->si, mi, idiaSymbol);
    if (!*mi->si.Name) {
        rva = (DWORD)(mi->si.Address - mi->BaseOfDll);
        goto findsymbol;
    }

    CopySymbolEntryFromSymbolInfo(&mi->TmpSym, &mi->si);

    return &mi->TmpSym;
}


HRESULT
diaGetSymTag(IDiaSymbol *pType, PULONG pTag)
{
    return pType->get_symTag(pTag);
}

HRESULT
diaGetSymIndexId(IDiaSymbol *pType, PULONG pIndex)
{
    return pType->get_symIndexId(pIndex);
}

HRESULT
diaGetLexicalParentId(IDiaSymbol *pType, PULONG pIndex)
{
    return pType->get_lexicalParentId(pIndex);
}

HRESULT
diaGetDataKind(IDiaSymbol *pType, PULONG pKind)
{
    return pType->get_dataKind(pKind);
}

HRESULT
diaGetSymName(IDiaSymbol *pType, BSTR *pname)
{
    return pType->get_name(pname);
}


HRESULT
diaGetLength(IDiaSymbol *pType, PULONGLONG pLength)
{
    return pType->get_length(pLength);
}

HRESULT
diaGetType(IDiaSymbol *pType, IDiaSymbol ** pSymbol)
{
    return pType->get_type(pSymbol);
}

HRESULT
diaGetBaseType(IDiaSymbol *pType, PULONG pBase)
{
    return pType->get_baseType(pBase);
}

HRESULT
diaGetArrayIndexTypeId(IDiaSymbol *pType, PULONG pSymbol)
{
    return pType->get_arrayIndexTypeId(pSymbol);
}

HRESULT
diaGetTypeId(IDiaSymbol *pType, PULONG pTypeId)
{
    return pType->get_typeId(pTypeId);
}

HRESULT
diaGetChildrenCount(IDiaSymbol *pType, LONG *pCount)
{
    CComPtr <IDiaEnumSymbols> pEnum;
    HRESULT          hr;
    ULONG            index;
    CComPtr <IDiaSymbol>      pSym;
    ULONG            Count;

    if ((hr = pType->findChildren(SymTagNull, NULL, nsNone, &pEnum)) != S_OK) {
        return hr;
    }
    return pEnum->get_Count(pCount);
}

HRESULT
diaFindChildren(IDiaSymbol *pType, TI_FINDCHILDREN_PARAMS *Params)
{
    CComPtr <IDiaEnumSymbols> pEnum;
    HRESULT          hr;
    ULONG            index;
    CComPtr <IDiaSymbol>      pSym;
    ULONG            Count;

    if ((hr = pType->findChildren(SymTagNull, NULL, nsNone, &pEnum)) != S_OK) {
        return hr;
    }

    VARIANT var;

    pEnum->Skip(Params->Start);
    for (Count = Params->Count, index = Params->Start; Count > 0; Count--, index++) {
        ULONG celt;
        pSym = NULL;
        if ((hr = pEnum->Next(1, &pSym, &celt)) != S_OK) {
            return hr;
        }

        if ((hr = pSym->get_symIndexId(&Params->ChildId[index])) != S_OK) {
            return hr;
        }
    }
    return S_OK;
}

HRESULT
diaGetAddressOffset(IDiaSymbol *pType, ULONG *pOff)
{
    return pType->get_addressOffset(pOff);
}

HRESULT
diaGetOffset(IDiaSymbol *pType, LONG *pOff)
{
    return pType->get_offset(pOff);
}

HRESULT
diaGetValue(IDiaSymbol *pType, VARIANT *pVar)
{
    return pType->get_value(pVar);
}

HRESULT
diaGetCount(IDiaSymbol *pType, ULONG *pCount)
{
    return pType->get_count(pCount);
}

HRESULT
diaGetBitPosition(IDiaSymbol *pType, ULONG *pPos)
{
    return pType->get_bitPosition(pPos);
}

HRESULT
diaGetVirtualBaseClass(IDiaSymbol *pType, BOOL *pBase)
{
    return pType->get_virtualBaseClass(pBase);
}

HRESULT
diaGetVirtualTableShapeId(IDiaSymbol *pType, PULONG pShape)
{
    return pType->get_virtualTableShapeId(pShape);
}

HRESULT
diaGetVirtualBasePointerOffset(IDiaSymbol *pType, LONG *pOff)
{
    return pType->get_virtualBasePointerOffset(pOff);
}

HRESULT
diaGetClassParentId(IDiaSymbol *pType, ULONG *pCid)
{
    return pType->get_classParentId(pCid);
}

HRESULT
diaGetNested(IDiaSymbol *pType, BOOL *pNested)
{
    return pType->get_nested(pNested);
}

HRESULT
diaGetSymAddress(IDiaSymbol *pType, ULONG64 ModBase, PULONG64 pAddr)
{
    ULONG rva;
    HRESULT Hr;

    Hr = pType->get_relativeVirtualAddress(&rva);
    if (Hr == S_OK) *pAddr = ModBase + rva;
    return Hr;
}

HRESULT
diaGetThisAdjust(IDiaSymbol *pType, LONG *pThisAdjust)
{
    return pType->get_thisAdjust(pThisAdjust);
}

BOOL
diaFindTypeSym(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    OUT IDiaSymbol    **pType
    )
{
    PPROCESS_ENTRY ProcessEntry;
    PDIA          pdia;
    PMODULE_ENTRY mi;

    ProcessEntry = FindProcessEntry( hProcess );
    if (!ProcessEntry || !(mi = GetModFromAddr(ProcessEntry, ModBase))) {
        return FALSE;
    }

    pdia = (PDIA)mi->dia;
    if (!pdia) {
        return FALSE;
    }
    return pdia->session->symbolById(TypeId, pType) == S_OK;
}

#ifdef USE_CACHE

ULONG gHits=0, gLook=0;

void
diaInsertInCache(
    PDIA_CACHE_ENTRY pCache,
    PDIA_LARGE_DATA plVals,
    ULONGLONG Module,
    ULONG TypeId,
    IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    PVOID pInfo
    )
{
    int start = CACHE_BLOCK * (TypeId % CACHE_BLOCK);
    int i, found;
    ULONG len,age;
    PDIA_LARGE_DATA pLargeVal=NULL;

    if (GetType == TI_FINDCHILDREN || GetType == TI_GET_SYMNAME) {
        for (pLargeVal = plVals, found=i=0, age=0; i<2*CACHE_BLOCK; i++) {
            if (!plVals[i].Used) {
                pLargeVal = &plVals[i];
                break;
            } else if (pCache[plVals[i].Index].Age > age) {
                pLargeVal = &plVals[i];
                age = pCache[plVals[i].Index].Age;
                assert(DIACH_PLVAL == pCache[pLargeVal->Index].Data.type);
                assert(pLargeVal == pCache[pLargeVal->Index].Data.plVal);
            }
        }
//    } else {
//      return;
    }
//    if (!(gLook % 200)) {
//      if (GetType == TI_FINDCHILDREN || GetType == TI_GET_SYMNAME) {
//          printf("Index   \tUsed\tBy\t\tfound %lx\n", pLargeVal);
//          for (found=i=0, age=0; i<2*CACHE_BLOCK; i++) {
//              printf("%08lx \t%lx\t%lx\n",
//                     &plVals[i], plVals[i].Used, plVals[i].Index);
//          }
//      }
//    }

    for (i=found=start, age=0; i<(start+CACHE_BLOCK); i++) {
        if (++pCache[i].Age > age) {
            age = pCache[i].Age; found = i;
        }
    }
    i=found;
    if (pCache[i].Data.type == DIACH_PLVAL) {
        assert(pCache[i].Data.plVal->Index == (ULONG) i);
        pCache[i].Data.plVal->Index = 0;
        pCache[i].Data.plVal->Used = 0;
        pCache[i].Data.type = 0;
        pCache[i].Data.ullVal = 0;
    }
    pCache[i].Age        = 0;
    pCache[i].s.DataType = GetType;
    pCache[i].s.TypeId   = TypeId;
    pCache[i].Module     = Module;

    switch (GetType) {
    case TI_GET_SYMTAG:
    case TI_GET_COUNT:
    case TI_GET_CHILDRENCOUNT:
    case TI_GET_BITPOSITION:
    case TI_GET_VIRTUALBASECLASS:
    case TI_GET_VIRTUALTABLESHAPEID:
    case TI_GET_VIRTUALBASEPOINTEROFFSET:
    case TI_GET_CLASSPARENTID:
    case TI_GET_TYPEID:
    case TI_GET_BASETYPE:
    case TI_GET_ARRAYINDEXTYPEID:
    case TI_GET_DATAKIND:
    case TI_GET_ADDRESSOFFSET:
    case TI_GET_OFFSET:
    case TI_GET_NESTED:
    case TI_GET_THISADJUST:
        pCache[i].Data.type = DIACH_ULVAL;
        pCache[i].Data.ulVal = *((PULONG) pInfo);
        break;

    case TI_GET_LENGTH:
    case TI_GET_ADDRESS:
        pCache[i].Data.type = DIACH_ULLVAL;
        pCache[i].Data.ullVal = *((PULONGLONG) pInfo);
        break;

    case TI_GET_SYMNAME: {
        len = 2*(1+wcslen(*((BSTR *) pInfo)));

        if (pLargeVal &&
            len < sizeof(pLargeVal->Bytes)) {
//            dprint("Ins name  %08lx %s had %3lx name %ws\n",
//                  pLargeVal, pLargeVal->Used ? "used" : "free",
//              pLargeVal->Index, &pLargeVal->Bytes[0]);
            memcpy(&pLargeVal->Bytes[0], *((BSTR *) pInfo), len);
            pLargeVal->LengthUsed = len;

            if (pLargeVal->Used) {
                pCache[pLargeVal->Index].Data.type = 0;
                pCache[pLargeVal->Index].Data.ullVal = 0;
                pCache[pLargeVal->Index].SearchId = 0;
            }
            pCache[i].Data.type = DIACH_PLVAL;
            pCache[i].Data.plVal = pLargeVal;
            pLargeVal->Index = i;
            pLargeVal->Used = TRUE;
//          dprint(Ins %9I64lx ch %3lx lch %08lx name %ws\n",
//                  pCache[i].SearchId,  i,  pLargeVal,  &pLargeVal->Bytes[0]);
        } else {
            pCache[i].SearchId = 0;
        }
        break;
    }
    case TI_FINDCHILDREN: {
        TI_FINDCHILDREN_PARAMS *pChild = (TI_FINDCHILDREN_PARAMS *) pInfo;

        len = sizeof(TI_FINDCHILDREN_PARAMS) + pChild->Count*sizeof(pChild->ChildId[0]) - sizeof(pChild->ChildId);

        if (pLargeVal &&
            len < sizeof(pLargeVal->Bytes)) {
//            dprint("Ins child %08lx %s had %3lx name %ws\n",
//                  pLargeVal, pLargeVal->Used ? "used" : "free",
//              pLargeVal->Index, &pLargeVal->Bytes[0]);
            memcpy(&pLargeVal->Bytes[0], pChild, len);
            pLargeVal->LengthUsed = len;
            if (pLargeVal->Used) {
                pCache[pLargeVal->Index].Data.type = 0;
                pCache[pLargeVal->Index].Data.ullVal = 0;
                pCache[pLargeVal->Index].SearchId = 0;
            }
            pCache[i].Data.type = DIACH_PLVAL;
            pCache[i].Data.plVal = pLargeVal;
            pLargeVal->Index = i;
            pLargeVal->Used = TRUE;
        } else {
            pCache[i].SearchId = 0;
        }
        break;
    }
    case TI_GET_VALUE:
    default:
        pCache[i].Data.type = 0;
        pCache[i].SearchId = 0;
        return ;
    }


}

BOOL
diaLookupCache(
    PDIA_CACHE_ENTRY pCache,
    ULONG64 Module,
    ULONG TypeId,
    IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    PVOID pInfo
    )
{
    int start = CACHE_BLOCK * (TypeId % CACHE_BLOCK);
    int i, found;
    ULONGLONG Search = ((ULONGLONG) GetType << 32) + TypeId;

    ++gLook;

    for (i=start,found=-1; i<(start+CACHE_BLOCK); i++) {
        if (pCache[i].SearchId == Search &&
            pCache[i].Module == Module) {
            found = i;
            break;
        }
    }
    if (found == -1) {
        return FALSE;
    }

    i=found;
    pCache[i].Age = 0;
    switch (pCache[i].Data.type) {
    case DIACH_ULVAL:
        *((PULONG) pInfo) = pCache[i].Data.ulVal;
        break;

    case DIACH_ULLVAL:
         *((PULONGLONG) pInfo) = pCache[i].Data.ullVal;
         break;

    case DIACH_PLVAL:
        if (GetType == TI_GET_SYMNAME) {

            *((BSTR *) pInfo) = (BSTR) LocalAlloc(0, pCache[i].Data.plVal->LengthUsed);

            if (*((BSTR *) pInfo)) {
                memcpy(*((BSTR *) pInfo), &pCache[i].Data.plVal->Bytes[0],pCache[i].Data.plVal->LengthUsed);
//              dprint(Lok %9I64lx ch %3lx lch %08lx name %ws\n",
//                      pCache[i].SearchId,
//                      i,
//                      pCache[i].Data.plVal,
//                      &pCache[i].Data.plVal->Bytes[0]);
            }
        } else if (GetType == TI_FINDCHILDREN) {
            TI_FINDCHILDREN_PARAMS *pChild = (TI_FINDCHILDREN_PARAMS *) pInfo;
            TI_FINDCHILDREN_PARAMS *pStored = (TI_FINDCHILDREN_PARAMS *) &pCache[i].Data.plVal->Bytes[0];
//          dprint(Lok %9I64lx ch %3lx lch %08lx child %lx\n",
//                  pCache[i].SearchId,
//                  i,
//                  pCache[i].Data.plVal,
//                  pStored->Count);

            if (pChild->Count == pStored->Count &&
                pChild->Start == pStored->Start) {
                memcpy(pChild, pStored, pCache[i].Data.plVal->LengthUsed);
            }
        }
        break;
    default:
        assert(FALSE);
        return FALSE;
    }
    if (!(++gHits%50)) {
//        dprint("%ld %% Hits\n", (gHits * 100) / gLook);
    }
    return TRUE;
}

#endif // USE_CACHE

HRESULT
#ifdef USE_CACHE
diaGetSymbolInfoEx(
#else
diaGetSymbolInfo(
#endif // USE_CACHE
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    )
{
    assert(pInfo);
    CComPtr <IDiaSymbol> pTypeSym;
    if (!diaFindTypeSym(hProcess, ModBase, TypeId, &pTypeSym)) {
        return E_INVALIDARG;
    }

    switch (GetType) {
    case TI_GET_SYMTAG:
        return diaGetSymTag(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_SYMNAME:
        return diaGetSymName(pTypeSym, (BSTR *) pInfo);
        break;
    case TI_GET_LENGTH:
        return diaGetLength(pTypeSym, (PULONGLONG) pInfo);
        break;
    case TI_GET_TYPE:
    case TI_GET_TYPEID:
        return diaGetTypeId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_BASETYPE:
        return diaGetBaseType(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_ARRAYINDEXTYPEID:
        return diaGetArrayIndexTypeId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_FINDCHILDREN:
        return diaFindChildren(pTypeSym, (TI_FINDCHILDREN_PARAMS *) pInfo);
    case TI_GET_DATAKIND:
        return diaGetDataKind(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_ADDRESSOFFSET:
        return diaGetAddressOffset(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_OFFSET:
        return diaGetOffset(pTypeSym, (PLONG) pInfo);
        break;
    case TI_GET_VALUE:
        return diaGetValue(pTypeSym, (VARIANT *) pInfo);
        break;
    case TI_GET_COUNT:
        return diaGetCount(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_CHILDRENCOUNT:
        return diaGetChildrenCount(pTypeSym, (PLONG) pInfo);
        break;
    case TI_GET_BITPOSITION:
        return diaGetBitPosition(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_VIRTUALBASECLASS:
        return diaGetVirtualBaseClass(pTypeSym, (BOOL *) pInfo);
        break;
    case TI_GET_VIRTUALTABLESHAPEID:
        return diaGetVirtualTableShapeId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_VIRTUALBASEPOINTEROFFSET:
        return diaGetVirtualBasePointerOffset(pTypeSym, (PLONG) pInfo);
        break;
    case TI_GET_CLASSPARENTID:
        return diaGetClassParentId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_NESTED:
        return diaGetNested(pTypeSym, (PBOOL) pInfo);
        break;
    case TI_GET_SYMINDEX:
        return diaGetSymIndexId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_LEXICALPARENT:
        return diaGetLexicalParentId(pTypeSym, (PULONG) pInfo);
        break;
    case TI_GET_ADDRESS:
        return diaGetSymAddress(pTypeSym, ModBase, (PULONG64) pInfo);
    case TI_GET_THISADJUST:
        return diaGetThisAdjust(pTypeSym, (PLONG) pInfo);
    default:
        return E_INVALIDARG;
    }
}

#ifdef USE_CACHE
HRESULT
diaGetSymbolInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    )
{
    PPROCESS_ENTRY ProcessEntry;

    ProcessEntry = FindProcessEntry( hProcess );

    if (!ProcessEntry) {
        return E_INVALIDARG;
    }
    if (!diaLookupCache(ProcessEntry->DiaCache, ModBase, TypeId, GetType, pInfo)) {
        HRESULT hr = diaGetSymbolInfoEx(hProcess, ModBase, TypeId, GetType, pInfo);
        if (!hr) {
            diaInsertInCache(ProcessEntry->DiaCache, ProcessEntry->DiaLargeData,
                             ModBase, TypeId, GetType, pInfo);
        }
        return hr;
    }
    return S_OK;
}
#endif // USE_CACHE

BOOL
diaGetTiForUDT(
    PMODULE_ENTRY ModuleEntry,
    LPSTR         name,
    PSYMBOL_INFO  psi
    )
{
    BSTR    wname=NULL;
    PDIA    pdia;
    HRESULT hr;
    ULONG   celt;

    if (!ModuleEntry) {
        return FALSE;
    }

    pdia = (PDIA)ModuleEntry->dia;
    if (!pdia)
        return FALSE;


    CComPtr< IDiaSymbol > idiaSymbols;
    hr = pdia->session->get_globalScope(&idiaSymbols);

    if (hr != S_OK)
        return FALSE;

    if (name) {
        wname = AnsiToUnicode(name);
    }

    CComPtr< IDiaEnumSymbols > idiaEnum;

    hr = idiaSymbols->findChildren(SymTagNull, wname, nsCaseSensitive, &idiaEnum);
    if (hr == S_OK) {

        CComPtr< IDiaSymbol > idiaSymbol;

        if ((hr = idiaEnum->Next( 1, &idiaSymbol, &celt)) == S_OK && celt == 1) {
            diaFillSymbolInfo(psi, ModuleEntry, idiaSymbol);
            idiaSymbol->get_symIndexId(&psi->TypeIndex);
            idiaSymbol = NULL;
        }
    }

    MemFree(wname);

    return hr == S_OK;
}

BOOL
diaEnumUDT(
    PMODULE_ENTRY ModuleEntry,
    LPSTR         name,
    PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    PVOID         context
    )
{
    BSTR    wname=NULL;
    PDIA    pdia;
    HRESULT hr;
    ULONG   celt;
    CHAR    buff[MAX_SYM_NAME + sizeof(SYMBOL_INFO)];
    PSYMBOL_INFO  psi=(PSYMBOL_INFO)  &buff;
    BOOL rc;

    psi->MaxNameLen = MAX_SYM_NAME;

    if (!ModuleEntry) {
        return FALSE;
    }

    pdia = (PDIA)ModuleEntry->dia;
    if (!pdia)
        return FALSE;


    CComPtr< IDiaSymbol > idiaSymbols;
    hr = pdia->session->get_globalScope(&idiaSymbols);

    if (hr != S_OK)
        return FALSE;

    if (name && *name) {
        wname = AnsiToUnicode(name);
    }

    CComPtr< IDiaEnumSymbols > idiaEnum;

    hr = idiaSymbols->findChildren(SymTagNull, wname, nsCaseSensitive, &idiaEnum);
    if (hr == S_OK) {

        CComPtr< IDiaSymbol > idiaSymbol;

        while (SUCCEEDED(idiaEnum->Next( 1, &idiaSymbol, &celt)) && celt == 1) {
            ULONG tag;
            idiaSymbol->get_symTag(&tag);
            switch (tag)
            {
            case SymTagEnum:
            case SymTagTypedef:
            case SymTagUDT:
                if (EnumSymbolsCallback) {
                    diaFillSymbolInfo(psi, ModuleEntry, idiaSymbol);
                    idiaSymbol->get_symIndexId(&psi->TypeIndex);
                    rc = EnumSymbolsCallback(psi, 0, context);
                    if (!rc)
                        return S_OK;
                }
                break;
            default:
                break;
            }
            idiaSymbol = NULL;
        }
    }

    MemFree(wname);
    
    return hr == S_OK;
}

BOOL
diaGetFrameData(
    IN HANDLE Process,
    IN ULONGLONG Offset,
    OUT IDiaFrameData** FrameData
    )
{
    PPROCESS_ENTRY ProcessEntry;
    PDIA Dia;
    PMODULE_ENTRY Mod;

    ProcessEntry = FindProcessEntry(Process);
    if (!ProcessEntry ||
        !(Mod = GetModFromAddr(ProcessEntry, Offset)) ||
        !(Dia = (PDIA)Mod->dia)) {
        return FALSE;
    }

    if (Dia->framedata == NULL) {

        CComPtr<IDiaEnumTables> EnumTables;
        CComPtr<IDiaTable> FdTable;
        VARIANT FdVar;
        
        FdVar.vt = VT_BSTR;
        FdVar.bstrVal = DiaTable_FrameData;
        
        if (Dia->session->getEnumTables(&EnumTables) != S_OK ||
            EnumTables->Item(FdVar, &FdTable) != S_OK ||
            FdTable->QueryInterface(IID_IDiaEnumFrameData,
                                    (void**)&Dia->framedata) != S_OK) {
            return FALSE;
        }
    }

    return Dia->framedata->frameByVA(Offset, FrameData) == S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\dice.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dice.cxx

Abstract:

    This file implements the Image Integrity API's.

Author:

    Bryan Tuttle (bryant) 7-Dec-1995

Environment:

    User Mode

--*/

#include <private.h>

BOOL
FindCertificate(
    IN PLOADED_IMAGE    LoadedImage,
    IN DWORD            Index,
    LPWIN_CERTIFICATE * Certificate
    )
{
    PIMAGE_DATA_DIRECTORY pDataDir;
    DWORD_PTR CurrentCert;
    BOOL rc;

    if (LoadedImage->fDOSImage) {
        // No way this could have a certificate;
        return(FALSE);
    }

    rc = FALSE;

    __try {
        if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;     // Not an interesting file type.
        }

        // Check if the cert pointer is at least reasonable.
        if (!pDataDir->VirtualAddress ||
            !pDataDir->Size ||
            (pDataDir->VirtualAddress + pDataDir->Size > LoadedImage->SizeOfImage))
        {
            __leave;
        }

        // We're not looking at an empty security slot or an invalid (past the image boundary) value.
        // Let's see if we can find it.

        DWORD CurrentIdx = 0;
        DWORD_PTR LastCert;

        CurrentCert = (DWORD_PTR)(LoadedImage->MappedAddress) + pDataDir->VirtualAddress;
        LastCert = CurrentCert + pDataDir->Size;

        while (CurrentCert < LastCert ) {
            if (CurrentIdx == Index) {
                rc = TRUE;
                __leave;
            }
            CurrentIdx++;
            CurrentCert += ((LPWIN_CERTIFICATE)CurrentCert)->dwLength;
            CurrentCert = (CurrentCert + 7) & ~7;   // align it.
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (rc == TRUE) {
        *Certificate = (LPWIN_CERTIFICATE)CurrentCert;
    }

    return(rc);
}

typedef struct _EXCLUDE_RANGE {
    PBYTE Offset;
    DWORD Size;
    struct _EXCLUDE_RANGE *Next;
} EXCLUDE_RANGE;

typedef enum {
    Raw,
    Virtual
} ADDRTYPE;

class EXCLUDE_LIST
{
    public:
        EXCLUDE_LIST() {
            m_Image = NULL;
            m_ExRange = (EXCLUDE_RANGE *)MemAlloc(sizeof(EXCLUDE_RANGE));
        }

        ~EXCLUDE_LIST() {
            EXCLUDE_RANGE *pTmp;
            pTmp = m_ExRange->Next;
            while (pTmp) {
                MemFree(m_ExRange);
                m_ExRange = pTmp;
                pTmp = m_ExRange->Next;
            }
            MemFree(m_ExRange);
        }

        void Init(LOADED_IMAGE * Image, DIGEST_FUNCTION pFunc, DIGEST_HANDLE dh) {
            m_Image = Image;
            m_ExRange->Offset = NULL;
            m_ExRange->Size = 0;
            m_pFunc = pFunc;
            m_dh = dh;
            return;
        }

        void Add(DWORD_PTR Offset, DWORD Size, ADDRTYPE AddrType);

        BOOL Emit(PBYTE Offset, DWORD Size);

    private:
        LOADED_IMAGE  * m_Image;
        EXCLUDE_RANGE * m_ExRange;
        DIGEST_FUNCTION m_pFunc;
        DIGEST_HANDLE m_dh;
};

void
EXCLUDE_LIST::Add(
    DWORD_PTR Offset,
    DWORD Size,
    ADDRTYPE AddrType
    )
{
    if (AddrType == Virtual) {
        // Always save raw offsets
        DWORD_PTR RawOffset;

        // Note: it's O.K. to cast down to a dword here.  Offset is really a Rva from the start
        // of the image (always limited to 4G).

        RawOffset = (DWORD_PTR)ImageRvaToVa((PIMAGE_NT_HEADERS)m_Image->FileHeader, m_Image->MappedAddress, (DWORD)Offset, NULL);
        Offset = RawOffset;
    }

    EXCLUDE_RANGE *pTmp, *pExRange;

    pExRange = m_ExRange;

    while (pExRange->Next && (pExRange->Next->Offset < (PBYTE)Offset)) {
        pExRange = pExRange->Next;
    }

    pTmp = (EXCLUDE_RANGE *) MemAlloc(sizeof(EXCLUDE_RANGE));
    pTmp->Next = pExRange->Next;
    pTmp->Offset = (PBYTE)Offset;
    pTmp->Size = Size;
    pExRange->Next = pTmp;

    return;
}


BOOL
EXCLUDE_LIST::Emit(
    PBYTE Offset,
    DWORD Size
    )
{
    BOOL rc;

    EXCLUDE_RANGE *pExRange;
    DWORD EmitSize, ExcludeSize;

    pExRange = m_ExRange->Next;

    while (pExRange && (Size > 0)) {
        if (pExRange->Offset >= Offset) {
            // Emit what's before the exclude list.
            EmitSize = __min((DWORD)(pExRange->Offset - Offset), Size);
            if (EmitSize) {
                rc = (*m_pFunc)(m_dh, Offset, EmitSize);
                Size -= EmitSize;
                Offset += EmitSize;
            }
        }

        if (Size) {
            if (pExRange->Offset + pExRange->Size >= Offset) {
                // Skip over what's in the exclude list.
                ExcludeSize = __min(Size, (DWORD)(pExRange->Offset + pExRange->Size - Offset));
                Size -= ExcludeSize;
                Offset += ExcludeSize;
            }
        }

        pExRange = pExRange->Next;
    }

    // Emit what's left.
    if (Size) {
        rc = (*m_pFunc)(m_dh, Offset, Size);
    }
    return rc;
}


BOOL
IMAGEAPI
ImageGetDigestStream(
    IN HANDLE           FileHandle,
    IN DWORD            DigestLevel,
    IN DIGEST_FUNCTION  DigestFunction,
    IN DIGEST_HANDLE    DigestHandle
    )

/*++

Routine Description:

    Given an image, return the bytes necessary to construct a certificate.
    Only PE images are supported at this time.

Arguments:

    FileHandle  -   Handle to the file in question.  The file should be opened
                    with at least GENERIC_READ access.

    DigestLevel -   Indicates what data will be included in the returned buffer.
                    Valid values are:

                        CERT_PE_IMAGE_DIGEST_DEBUG_INFO - Include Debug symbolic (if mapped)
                        CERT_PE_IMAGE_DIGEST_RESOURCES  - Include Resource info
                        CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO - Include ALL the import information

                    By default, neither Debug Symbolic, Resources, nor import information affected
                    by binding are returned.

    DigestFunction - User supplied routine that will process the data.

    DigestHandle -  User supplied handle to identify the digest.  Passed as the first
                    argument to the DigestFunction.

Return Value:

    TRUE         - Success.

    FALSE        - There was some error.  Call GetLastError for more information.  Possible
                   values are ERROR_INVALID_PARAMETER or ERROR_OPERATION_ABORTED.

--*/

{
    LOADED_IMAGE    LoadedImage;
    BOOL            rc, fAddThisSection, fDebugAdded;
    DWORD           i;
    EXCLUDE_LIST    ExList;
    PIMAGE_SECTION_HEADER SectionHeaders;
    ULONG ResourceOffset, ResourceSize, DebugOffset, DebugSize, RelocOffset, RelocSize, SectionHeaderSize;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_DATA_DIRECTORY pDataDir;
    INT RelocHdr;
    union {
        IMAGE_NT_HEADERS32 PE32;
        IMAGE_NT_HEADERS64 PE64;
    }Hdr;
    BOOL f32;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;

    __try {

        if (LoadedImage.fDOSImage) {
            __leave;
        }

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            f32 = TRUE;
        } else if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            f32 = FALSE;
        } else {
            __leave;
        }

        ExList.Init(&LoadedImage, DigestFunction, DigestHandle);

        // Return all the interesting stuff from the image.  First, the common stuff.

        // 1. Add the DOS stub (if it exists).

        if ((ULONG_PTR)LoadedImage.FileHeader - (ULONG_PTR) LoadedImage.MappedAddress) {
            if (!ExList.Emit((PBYTE) LoadedImage.MappedAddress,
                             (DWORD)((ULONG_PTR) LoadedImage.FileHeader - (ULONG_PTR) LoadedImage.MappedAddress)))
            {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        }

        // Add the headers, but not the checksum and not the security Data directory entry.

        if (f32) {
            Hdr.PE32 = *((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader);
            pDataDir = &Hdr.PE32.OptionalHeader.DataDirectory[0];
            Hdr.PE32.OptionalHeader.CheckSum = 0;
        } else {
            Hdr.PE64 = *((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader);
            pDataDir = &Hdr.PE64.OptionalHeader.DataDirectory[0];
            Hdr.PE64.OptionalHeader.CheckSum = 0;
        }

        pDataDir[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = 0;
        pDataDir[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;

        SectionHeaderSize = sizeof(IMAGE_SECTION_HEADER) * LoadedImage.NumberOfSections;
        SectionHeaders = (PIMAGE_SECTION_HEADER) MemAlloc(SectionHeaderSize);
        if (SectionHeaders == NULL)
        {
            rc = ERROR_OPERATION_ABORTED;
            __leave;
        }
        ResourceOffset = pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
        ResourceSize = pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
        RelocOffset = pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
        RelocSize = pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

        fDebugAdded = TRUE;
        DebugOffset = 0xFFFFFFFF;
        RelocHdr = -1;

        for (i = 0; i < LoadedImage.NumberOfSections; i++) {
            SectionHeaders[i] = LoadedImage.Sections[i];

            // Keep track of the reloc section header.  We may need to adjust it later.

            if (RelocSize &&
                ((LoadedImage.Sections[i].VirtualAddress <= RelocOffset) &&
                 (LoadedImage.Sections[i].VirtualAddress +
                    LoadedImage.Sections[i].Misc.VirtualSize >= RelocOffset + RelocSize))
                )
            {
                RelocHdr = i;
            }

            // If resources aren't in the digest, we need to clear the resource section header

            if (ResourceSize && !(DigestLevel & CERT_PE_IMAGE_DIGEST_RESOURCES)) {

                if (((LoadedImage.Sections[i].VirtualAddress <= ResourceOffset) &&
                     (LoadedImage.Sections[i].VirtualAddress +
                        LoadedImage.Sections[i].Misc.VirtualSize >= ResourceOffset + ResourceSize))
                    )
                {
                    // Found the resource section header.  Zero it out.
                    SectionHeaders[i].Misc.VirtualSize = 0;
                    SectionHeaders[i].VirtualAddress = 0;
                    SectionHeaders[i].SizeOfRawData = 0;
                    SectionHeaders[i].PointerToRawData = 0;
                }
            }

            if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_DEBUG_INFO)) {
                // Same with mapped debug info.
                if (!strncmp((char *)LoadedImage.Sections[i].Name, ".debug", sizeof(".debug"))) {

                    DebugOffset = SectionHeaders[i].VirtualAddress;
                    DebugSize = SectionHeaders[i].SizeOfRawData;
                    ExList.Add(SectionHeaders[i].PointerToRawData + (DWORD_PTR) LoadedImage.MappedAddress, DebugSize, Raw);

                    SectionHeaders[i].Misc.VirtualSize = 0;
                    SectionHeaders[i].VirtualAddress = 0;
                    SectionHeaders[i].SizeOfRawData = 0;
                    SectionHeaders[i].PointerToRawData = 0;
                    fDebugAdded = FALSE;
                }
            }
        }

        // The first pass on the section headers is finished.  See it we need to adjust the
        // reloc dir or the image headers.

        if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_RESOURCES)) {
            // If the resources aren't in the digest, don't add the base reloc address or the
            // resource address/size to the digest.  This allows subsequent tools to add/subtract
            // resource info w/o effecting the digest.

            if ((ResourceOffset < RelocOffset) && (RelocHdr != -1))
            {
                pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;
                SectionHeaders[RelocHdr].PointerToRawData = 0;
                SectionHeaders[RelocHdr].VirtualAddress = 0;
            }
            pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = 0;
            pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = 0;
            if (f32) {
                Hdr.PE32.OptionalHeader.SizeOfImage = 0;
                Hdr.PE32.OptionalHeader.SizeOfInitializedData = 0;
            } else {
                Hdr.PE64.OptionalHeader.SizeOfImage = 0;
                Hdr.PE64.OptionalHeader.SizeOfInitializedData = 0;
            }
            ExList.Add(ResourceOffset, ResourceSize, Virtual);
        }

        if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_DEBUG_INFO) &&
            (fDebugAdded == FALSE))
        {
            // Debug wasn't added to the image and IS mapped in.  Allow these to grow also.
            if (f32) {
                Hdr.PE32.OptionalHeader.SizeOfImage = 0;
                Hdr.PE32.OptionalHeader.SizeOfInitializedData = 0;
            } else {
                Hdr.PE64.OptionalHeader.SizeOfImage = 0;
                Hdr.PE64.OptionalHeader.SizeOfInitializedData = 0;
            }
            if ((DebugOffset < RelocOffset) && (RelocHdr != -1))
            {
                pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;
                SectionHeaders[RelocHdr].PointerToRawData = 0;
                SectionHeaders[RelocHdr].VirtualAddress = 0;
            }
        }

        // Looks good.  Send the headers to the digest function.

        if (f32) {
            if (!ExList.Emit((PBYTE) &Hdr.PE32, sizeof(Hdr.PE32))) {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        } else {
            if (!ExList.Emit((PBYTE) &Hdr.PE64, sizeof(Hdr.PE64))) {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        }

        // Then the section headers.

        if (!ExList.Emit((PBYTE) SectionHeaders, SectionHeaderSize)) {
            rc = ERROR_OPERATION_ABORTED;
            __leave;
        }

        MemFree(SectionHeaders);

        // The headers are done.  Now let's see what we need to do with the import information.

        if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO)) {
            // The user didn't explicitly ask for all import info.
            // Add the info modified by bind to the exclude list.

            PIMAGE_IMPORT_DESCRIPTOR ImportDesc;
            DWORD ImportDescSize, IATSize;
            PVOID IAT;

            ImportDesc = (PIMAGE_IMPORT_DESCRIPTOR) ImageDirectoryEntryToData(
                                LoadedImage.MappedAddress,
                                FALSE,
                                IMAGE_DIRECTORY_ENTRY_IMPORT,
                                &ImportDescSize);
            if (ImportDescSize) {

                IAT = ImageDirectoryEntryToData(LoadedImage.MappedAddress,
                                                FALSE,
                                                IMAGE_DIRECTORY_ENTRY_IAT,
                                                &IATSize);

                if (IAT) {
                    // Easy case.  All the IATs are grouped together.
                    ExList.Add((DWORD_PTR) IAT, IATSize, Raw);

                    // Add the TimeDateStamp and ForwarderChain fields in the Import Descriptors

                    while (ImportDesc->Characteristics) {
                        ExList.Add((DWORD_PTR) &ImportDesc->TimeDateStamp, 8, Raw);
                        ImportDesc++;
                    }

                } else {
                    // Not so easy.  Need to walk each Import descriptor to find the bounds of the IAT
                    //  (note, there's no requirement that all the IAT's for all descriptors be contiguous).


                    while (ImportDesc->Characteristics) {
                        PIMAGE_THUNK_DATA ThunkStart;
                        ExList.Add((DWORD_PTR)&ImportDesc->TimeDateStamp, 8, Raw);
                        ThunkStart = (PIMAGE_THUNK_DATA) ImageRvaToVa((PIMAGE_NT_HEADERS)LoadedImage.FileHeader,
                                                                      LoadedImage.MappedAddress,
                                                                      (ULONG) ImportDesc->OriginalFirstThunk,
                                                                      NULL);
                        if (f32) {
                            PIMAGE_THUNK_DATA32 Thunk = (PIMAGE_THUNK_DATA32)ThunkStart;
                            while (Thunk->u1.AddressOfData) {
                                Thunk++;
                            }
                            ExList.Add( (DWORD)ImportDesc->FirstThunk,
                                        (DWORD)((DWORD_PTR)Thunk - (DWORD_PTR) ThunkStart + sizeof(IMAGE_THUNK_DATA32)), Virtual);
                        } else {
                            PIMAGE_THUNK_DATA64 Thunk = (PIMAGE_THUNK_DATA64)ThunkStart;
                            while (Thunk->u1.AddressOfData) {
                                Thunk++;
                            }
                            ExList.Add( (DWORD)ImportDesc->FirstThunk,
                                        (DWORD)((DWORD_PTR)Thunk - (DWORD_PTR) ThunkStart + sizeof(IMAGE_THUNK_DATA64)), Virtual);
                        }
                        ImportDesc++;
                    }
                }
            }
        }

        // Add each section header followed by the data from that section.

        for (i = 0; i < LoadedImage.NumberOfSections; i++) {
            if (!ExList.Emit((PBYTE) (LoadedImage.MappedAddress + LoadedImage.Sections[i].PointerToRawData),
                             LoadedImage.Sections[i].SizeOfRawData))
            {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        }
        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}



BOOL
IMAGEAPI
ImageAddCertificate(
    IN HANDLE               FileHandle,
    IN LPWIN_CERTIFICATE    Certificate,
    OUT PDWORD              Index
    )

/*++

Routine Description:
    Add a certificate to the image.  There is no checking to ensure there are no
    duplicate types.

Arguments:

    FileHandle      -   Handle to the file in question.  The file should be opened
                        with at least GENERIC_WRITE access.

    Certificate     -   Pointer to a WIN_CERTIFICATE structure.

    Index           -   After adding the Certificate to the image, this is the index
                        you can use for later references to that certificate.

Return Value:

    TRUE    - Success
    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE        LoadedImage;
    DWORD               rc;
    LPWIN_CERTIFICATE   pCert;
    DWORD               OnDiskCertLength;
    DWORD_PTR           NewCertLocation;
    DWORD               OriginalImageSize;
    PIMAGE_DATA_DIRECTORY  pDataDir;
    BOOL                f32, fSkipUnMap;

    if (MapIt(FileHandle, &LoadedImage, MAP_READWRITE) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;
    fSkipUnMap = FALSE;

    __try {

        if (LoadedImage.fDOSImage) {
            __leave;
        }

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            f32 = TRUE;
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            f32 = FALSE;
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;
        }

        pCert = (LPWIN_CERTIFICATE) Certificate;

        // Test the output parameter and the the cert.

        *Index = (DWORD) -1;
        OnDiskCertLength = pCert->dwLength;
        OnDiskCertLength = (OnDiskCertLength + 7) & ~7;        // Round the size of cert.

        // Grow the image.

        OriginalImageSize = LoadedImage.SizeOfImage;
        OriginalImageSize = (OriginalImageSize + 7) & ~7;      // Round the size of Image.

        // Check if the cert pointer is at least reasonable.
        if (pDataDir->VirtualAddress &&
            (pDataDir->VirtualAddress + pDataDir->Size) > LoadedImage.SizeOfImage)
        {
            __leave;
        }

        // Looks good now.

        *Index = 0;
        if (pDataDir->VirtualAddress == 0) {
            pDataDir->VirtualAddress = OriginalImageSize;
            pDataDir->Size = 0;
            NewCertLocation = OriginalImageSize;
        } else {
            LPWIN_CERTIFICATE CurrentCert;

            NewCertLocation = pDataDir->VirtualAddress + pDataDir->Size + (DWORD_PTR) LoadedImage.MappedAddress;
            CurrentCert = (LPWIN_CERTIFICATE) (LoadedImage.MappedAddress + pDataDir->VirtualAddress);
            while (((DWORD_PTR)CurrentCert) < NewCertLocation) {
                if (CurrentCert->dwLength == 0) {
                    __leave;
                }
                CurrentCert = (LPWIN_CERTIFICATE)(((DWORD_PTR)CurrentCert + CurrentCert->dwLength + 7) & ~7);
                (*Index)++;
            }
            NewCertLocation -= (DWORD_PTR) LoadedImage.MappedAddress;
        }

        if (!GrowMap (&LoadedImage, OnDiskCertLength + (OriginalImageSize - LoadedImage.SizeOfImage))) {
            fSkipUnMap = TRUE;
            __leave;
        }

        if (NewCertLocation < OriginalImageSize) {
            // There's data after the current security data.  Move it down.
            memmove(LoadedImage.MappedAddress + NewCertLocation + pCert->dwLength,
                    LoadedImage.MappedAddress + NewCertLocation,
                    (unsigned) (OriginalImageSize - NewCertLocation));
        }

        memmove(LoadedImage.MappedAddress + NewCertLocation,
                pCert,
                pCert->dwLength);

        // GrowMap may have moved the dirs.
        if (f32) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        }

        pDataDir->Size += OnDiskCertLength;
        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (!fSkipUnMap)
        UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}


BOOL
IMAGEAPI
ImageRemoveCertificate(
    IN HANDLE       FileHandle,
    IN DWORD        Index
    )

/*++

Routine Description:

    Remove a certificate from an image.

Arguments:

    FileHandle  -   Handle to the file in question.  The file should be opened
                    with at least GENERIC_WRITE access.

    Index       -   The index to remove from the image.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE    LoadedImage;
    LPWIN_CERTIFICATE CurrentCert;
    DWORD           rc;
    DWORD           OldCertLength;

    if (MapIt(FileHandle, &LoadedImage, MAP_READWRITE) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;

    __try {

        if (FindCertificate(&LoadedImage, Index, &CurrentCert) == FALSE) {
            __leave;
        }

        OldCertLength = CurrentCert->dwLength;
        OldCertLength = (OldCertLength + 7) & ~7;           // The disk size is actually a multiple of 8

        memmove(CurrentCert,
                ((PCHAR)CurrentCert) + OldCertLength,
                (size_t)(LoadedImage.SizeOfImage - (((DWORD_PTR)CurrentCert) - (DWORD_PTR)LoadedImage.MappedAddress) - OldCertLength));

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            ((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size -= OldCertLength;
            if (!((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size) {
                // Last one removed.  Clear the pointer
                ((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;
            }
        } else {
            ((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size -= OldCertLength;
            if (!((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size) {
                // Last one removed.  Clear the pointer
                ((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;
            }
        }

        LoadedImage.SizeOfImage -= OldCertLength;

        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}


BOOL
IMAGEAPI
ImageEnumerateCertificates(
    IN  HANDLE      FileHandle,
    IN  WORD        TypeFilter,
    OUT PDWORD      CertificateCount,
    IN OUT PDWORD   Indices OPTIONAL,
    IN  DWORD       IndexCount  OPTIONAL
    )

/*++

Routine Description:

    Enumerate the certificates in an image.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    TypeFilter          -   The filter to apply when enumertating the certificates.
                            Valid values are:

                                CERT_SECTION_TYPE_ANY - Enumerate all certificate types
                                                        in the image.

    CertificateCount    -   How many certificates are in the image.

    Indices             -   An array of indexes that match the filter type.

    IndexCount          -   The number of indexes in the indices array.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    BOOL    rc;
    PIMAGE_DATA_DIRECTORY pDataDir;
    LPWIN_CERTIFICATE CurrentCert, LastCert;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;
    __try {
        if (LoadedImage.fDOSImage) {
            __leave;
        }

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;
        }

        if ((pDataDir->VirtualAddress + pDataDir->Size) > LoadedImage.SizeOfImage) {
            *CertificateCount = 0;
            __leave;
        }

        if (!pDataDir->VirtualAddress || !pDataDir->Size) {
            *CertificateCount = 0;
        } else {

            DWORD MatchedIndex = 0;
            DWORD ActualIndex = 0;

            CurrentCert = (LPWIN_CERTIFICATE)((DWORD_PTR)LoadedImage.MappedAddress + pDataDir->VirtualAddress);
            LastCert = (LPWIN_CERTIFICATE)((DWORD_PTR)CurrentCert + pDataDir->Size);

            while (CurrentCert < LastCert ) {
                if ((TypeFilter == CERT_SECTION_TYPE_ANY) || (TypeFilter == CurrentCert->wCertificateType)) {
                    if (Indices && (MatchedIndex < IndexCount)) {
                        Indices[MatchedIndex] = ActualIndex;
                    }
                    MatchedIndex++;
                }

                ActualIndex++;
                CurrentCert = (LPWIN_CERTIFICATE)((((DWORD_PTR)CurrentCert + CurrentCert->dwLength) +7) & ~7);
            }

            *CertificateCount = MatchedIndex;
        }

        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}


BOOL
IMAGEAPI
ImageGetCertificateData(
    IN  HANDLE              FileHandle,
    IN  DWORD               CertificateIndex,
    OUT LPWIN_CERTIFICATE   Certificate,
    IN OUT PDWORD           RequiredLength
    )

/*++

Routine Description:

    Given a specific certificate index, retrieve the certificate data.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    CertificateIndex    -   Index to retrieve

    Certificate         -   Output buffer where the certificate is to be stored.

    RequiredLength      -   Size of the certificate buffer (input).  On return, is
                            set to the actual certificate length.  NULL can be used
                            to determine the size of a certificate.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    DWORD   ErrorCode;

    LPWIN_CERTIFICATE ImageCert;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    ErrorCode = ERROR_INVALID_PARAMETER;
    __try {
        if (FindCertificate(&LoadedImage, CertificateIndex, &ImageCert) == FALSE) {
            __leave;
        }

        if (*RequiredLength < ImageCert->dwLength) {
            *RequiredLength = ImageCert->dwLength;
            ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        } else {
            memcpy(Certificate, (PUCHAR)ImageCert, ImageCert->dwLength);
            ErrorCode = ERROR_SUCCESS;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(ErrorCode);
    return(ErrorCode == ERROR_SUCCESS ? TRUE: FALSE);
}


BOOL
IMAGEAPI
ImageGetCertificateHeader(
    IN      HANDLE              FileHandle,
    IN      DWORD               CertificateIndex,
    IN OUT  LPWIN_CERTIFICATE   CertificateHeader
    )

/*++

Routine Description:

    Given a specific certificate index, retrieve the certificate data.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    CertificateIndex    -   Index to retrieve.

    CertificateHeader   -   Pointer to a WIN_CERTIFICATE to fill in.

Return Value:

    TRUE    - Success

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    LPWIN_CERTIFICATE ImageCert;
    BOOL    rc;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (FindCertificate(&LoadedImage, CertificateIndex, &ImageCert) == FALSE) {
        rc = FALSE;
        goto Exit;
    }

    __try {
        memcpy(CertificateHeader, ImageCert, sizeof(WIN_CERTIFICATE));
        rc = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        rc = FALSE;
    }
Exit:

    UnMapIt(&LoadedImage);

    if (rc == FALSE) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\dload.c ===
#include <private.h>
#include <globals.h>
#include <delayimp.h>

#ifdef BUILD_DBGHELP

BOOL
GetDllVersionInfo(
    HINSTANCE hinst,
    LPVOID *lpVersionInfo
    );

#define FreeLib(hDll)   \
    {if (hDll && hDll != INVALID_HANDLE_VALUE) FreeLibrary(hDll);}

#endif // #ifdef BUILD_DBGHELP

typedef struct
{
    PCHAR Name;
    FARPROC Function;
} FUNCPTRS;

#if DBG
void
OutputDBString(
    CHAR *text
    );
#endif

#ifdef BUILD_IMAGEHLP

BOOL  IMAGEAPI FailEnumerateLoadedModules(
    IN HANDLE                         hProcess,
    IN PENUMLOADED_MODULES_CALLBACK   EnumLoadedModulesCallback,
    IN PVOID                          UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailEnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    )
{ return FALSE; }

HANDLE IMAGEAPI FailFindDebugInfoFile (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath
    )
{return NULL;}

HANDLE IMAGEAPI FailFindDebugInfoFileEx (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath,
    PFIND_DEBUG_FILE_CALLBACK Callback,
    PVOID CallerData
    )
{ return NULL; }

HANDLE IMAGEAPI FailFindExecutableImage(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath
    )
{ return NULL; }

LPAPI_VERSION IMAGEAPI FailImagehlpApiVersion(
    VOID
    )
{ return NULL; }

LPAPI_VERSION IMAGEAPI FailImagehlpApiVersionEx(
    LPAPI_VERSION AppVersion
    )
{ return NULL; }

BOOL IMAGEAPI FailMakeSureDirectoryPathExists(
    PCSTR DirPath
    )
{ return FALSE; }

#ifndef _WIN64
PIMAGE_DEBUG_INFORMATION IMAGEAPI FailMapDebugInformation(
    HANDLE FileHandle,
    PSTR FileName,
    PSTR SymbolPath,
    DWORD ImageBase
    )
{ return NULL; }
#endif

BOOL IMAGEAPI FailSearchTreeForFile(
    PSTR RootPath,
    PSTR InputPathName,
    PSTR OutputPathBuffer
    )
{ return FALSE; }

BOOL IMAGEAPI FailStackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    )
{ return FALSE; }

BOOL IMAGEAPI FailStackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymCleanup(
    IN HANDLE hProcess
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateModules(
    IN HANDLE                     hProcess,
    IN PSYM_ENUMMODULES_CALLBACK  EnumModulesCallback,
    IN PVOID                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateModules64(
    IN HANDLE                       hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64  EnumModulesCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbols(
    IN HANDLE                     hProcess,
    IN DWORD                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK  EnumSymbolsCallback,
    IN PVOID                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN DWORD                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

PVOID IMAGEAPI FailSymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    )
{ return NULL; }

PVOID IMAGEAPI FailSymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{ return NULL; }

BOOL IMAGEAPI FailSymGetLineFromAddr(
    IN  HANDLE                hProcess,
    IN  DWORD                 dwAddr,
    OUT PDWORD                pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineFromName(
    IN     HANDLE             hProcess,
    IN     PSTR               ModuleName,
    IN     PSTR               FileName,
    IN     DWORD              dwLineNumber,
       OUT PLONG              plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     PSTR                 ModuleName,
    IN     PSTR                 FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineNext(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLinePrev(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )
{ return FALSE; }

DWORD IMAGEAPI FailSymGetModuleBase(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr
    )
{ return 0; }

DWORD64 IMAGEAPI FailSymGetModuleBase64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr
    )
{ return 0; }

BOOL IMAGEAPI FailSymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE  ModuleInfo
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW  ModuleInfo
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetModuleInfo64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULE64      ModuleInfo
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetModuleInfoW64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULEW64     ModuleInfo
    )
{ return FALSE; }

DWORD IMAGEAPI FailSymGetOptions(
    VOID
    )
{ return 0; }

BOOL IMAGEAPI FailSymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT PSTR            SearchPath,
    IN  DWORD           SearchPathLength
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromAddr(
    IN  HANDLE            hProcess,
    IN  DWORD             dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr,
    OUT PDWORD64            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromName(
    IN  HANDLE            hProcess,
    IN  PSTR              Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  PSTR                Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymNext(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymPrev(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL
IMAGEAPI
FailSymGetTypeInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    )
{ return FALSE; }

BOOL
IMAGEAPI
FailSymGetTypeFromName(
    IN  HANDLE              hProcess,
    IN  ULONG64             BaseOfDll,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    )
{ return FALSE; }

BOOL
IMAGEAPI
FailSymEnumTypes(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymInitialize(
    IN HANDLE   hProcess,
    IN PSTR     UserSearchPath,
    IN BOOL     fInvadeProcess
    )
{ return FALSE; }

DWORD IMAGEAPI FailSymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    )
{ return 0; }

DWORD64 IMAGEAPI FailSymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           SizeOfDll
    )
{ return 0; }

BOOL IMAGEAPI FailSymMatchFileName(
    IN  PSTR  FileName,
    IN  PSTR  Match,
    OUT PSTR *FileNameStop,
    OUT PSTR *MatchStop
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterCallback(
    IN HANDLE                      hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    IN PVOID                       UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymSetContext(
    HANDLE hProcess,
    PIMAGEHLP_STACK_FRAME StackFrame,
    PIMAGEHLP_CONTEXT Context
    ) 
{ return FALSE;}

DWORD IMAGEAPI FailSymSetOptions(
    IN DWORD   SymOptions
    )
{ return 0; }

BOOL IMAGEAPI FailSymSetSearchPath(
    IN HANDLE           hProcess,
    IN PSTR             SearchPath
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnDName(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT PSTR             UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnDName64(
    IN  PIMAGEHLP_SYMBOL64 sym,               // Symbol to undecorate
    OUT PSTR               UnDecName,         // Buffer to store undecorated name in
    IN  DWORD              UnDecNameLength    // Size of the buffer
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnloadModule(
    IN  HANDLE          hProcess,
    IN  DWORD           BaseOfDll
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnloadModule64(
    IN  HANDLE          hProcess,
    IN  DWORD64         BaseOfDll
    )
{ return FALSE; }

#ifndef _WIN64
BOOL IMAGEAPI FailUnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION DebugInfo
    )
{ return FALSE; }
#endif

BOOL IMAGEAPI FailSymEnumSym(
    IN HANDLE                     hProcess,
    IN DWORD64                    BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK  EnumSymbolsCallback,
    IN PVOID                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymFromAddr(
    IN  HANDLE            hProcess,
    IN  DWORD64           dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PSYMBOL_INFO      Symbol
    )
{ return FALSE; }


BOOL IMAGEAPI FailSymFromName(
    IN  HANDLE            hProcess,
    IN  PSTR              Name,
    OUT PSYMBOL_INFO      Symbol
    )
{ return FALSE; }


FUNCPTRS DbgHelpFailPtrs[] = {
    {"EnumerateLoadedModules",       (FARPROC)FailEnumerateLoadedModules},
    {"EnumerateLoadedModules64",     (FARPROC)FailEnumerateLoadedModules64},
    {"FindDebugInfoFile",            (FARPROC)FailFindDebugInfoFile},
    {"FindDebugInfoFileEx",          (FARPROC)FailFindDebugInfoFileEx},
    {"FindExecutableImage",          (FARPROC)FailFindExecutableImage},
    {"ImagehlpApiVersion",           (FARPROC)FailImagehlpApiVersion},
    {"ImagehlpApiVersionEx",         (FARPROC)FailImagehlpApiVersionEx},
    {"MakeSureDirectoryPathExists",  (FARPROC)FailMakeSureDirectoryPathExists},
#ifndef _WIN64
    {"MapDebugInformation",          (FARPROC)FailMapDebugInformation},
#endif
    {"SearchTreeForFile",            (FARPROC)FailSearchTreeForFile},
    {"StackWalk",                    (FARPROC)FailStackWalk},
    {"StackWalk64",                  (FARPROC)FailStackWalk64},
    {"SymCleanup",                   (FARPROC)FailSymCleanup},
    {"SymEnumerateModules",          (FARPROC)FailSymEnumerateModules},
    {"SymEnumerateModules64",        (FARPROC)FailSymEnumerateModules64},
    {"SymEnumerateSymbols",          (FARPROC)FailSymEnumerateSymbols},
    {"SymEnumerateSymbols64",        (FARPROC)FailSymEnumerateSymbols64},
    {"SymEnumerateSymbolsW",         (FARPROC)FailSymEnumerateSymbolsW},
    {"SymEnumerateSymbolsW64",       (FARPROC)FailSymEnumerateSymbolsW64},
    {"SymEnumSym",                   (FARPROC)FailSymEnumSym},
    {"SymEnumTypes",                 (FARPROC)FailSymEnumTypes},
    {"SymFromAddr",                  (FARPROC)FailSymFromAddr},
    {"SymFromName",                  (FARPROC)FailSymFromName},
    {"SymFunctionTableAccess",       (FARPROC)FailSymFunctionTableAccess},
    {"SymFunctionTableAccess64",     (FARPROC)FailSymFunctionTableAccess64},
    {"SymGetLineFromAddr",           (FARPROC)FailSymGetLineFromAddr},
    {"SymGetLineFromAddr64",         (FARPROC)FailSymGetLineFromAddr64},
    {"SymGetLineFromName",           (FARPROC)FailSymGetLineFromName},
    {"SymGetLineFromName64",         (FARPROC)FailSymGetLineFromName64},
    {"SymGetLineNext",               (FARPROC)FailSymGetLineNext},
    {"SymGetLineNext64",             (FARPROC)FailSymGetLineNext64},
    {"SymGetLinePrev",               (FARPROC)FailSymGetLinePrev},
    {"SymGetLinePrev64",             (FARPROC)FailSymGetLinePrev64},
    {"SymGetModuleBase",             (FARPROC)FailSymGetModuleBase},
    {"SymGetModuleBase64",           (FARPROC)FailSymGetModuleBase64},
    {"SymGetModuleInfo",             (FARPROC)FailSymGetModuleInfo},
    {"SymGetModuleInfo64",           (FARPROC)FailSymGetModuleInfo64},
    {"SymGetModuleInfoW",            (FARPROC)FailSymGetModuleInfoW},
    {"SymGetModuleInfoW64",          (FARPROC)FailSymGetModuleInfoW64},
    {"SymGetOptions",                (FARPROC)FailSymGetOptions},
    {"SymGetSearchPath",             (FARPROC)FailSymGetSearchPath},
    {"SymGetSymFromAddr",            (FARPROC)FailSymGetSymFromAddr},
    {"SymGetSymFromAddr64",          (FARPROC)FailSymGetSymFromAddr64},
    {"SymGetSymFromName",            (FARPROC)FailSymGetSymFromName},
    {"SymGetSymFromName64",          (FARPROC)FailSymGetSymFromName64},
    {"SymGetSymNext",                (FARPROC)FailSymGetSymNext},
    {"SymGetSymNext64",              (FARPROC)FailSymGetSymNext64},
    {"SymGetSymPrev",                (FARPROC)FailSymGetSymPrev},
    {"SymGetSymPrev64",              (FARPROC)FailSymGetSymPrev64},
    {"SymGetTypeFromName",           (FARPROC)FailSymGetTypeFromName},
    {"SymGetTypeInfo",               (FARPROC)FailSymGetTypeInfo},
    {"SymInitialize",                (FARPROC)FailSymInitialize},
    {"SymLoadModule",                (FARPROC)FailSymLoadModule},
    {"SymLoadModule64",              (FARPROC)FailSymLoadModule64},
    {"SymMatchFileName",             (FARPROC)FailSymMatchFileName},
    {"SymRegisterCallback",          (FARPROC)FailSymRegisterCallback},
    {"SymRegisterCallback64",        (FARPROC)FailSymRegisterCallback64},
    {"SymRegisterFunctionEntryCallback",   (FARPROC)FailSymRegisterFunctionEntryCallback},
    {"SymRegisterFunctionEntryCallback64", (FARPROC)FailSymRegisterFunctionEntryCallback64},
    {"SymSetContext",                (FARPROC)FailSymSetContext},
    {"SymSetOptions",                (FARPROC)FailSymSetOptions},
    {"SymSetSearchPath",             (FARPROC)FailSymSetSearchPath},
    {"SymUnDName",                   (FARPROC)FailSymUnDName},
    {"SymUnDName64",                 (FARPROC)FailSymUnDName64},
    {"SymUnloadModule",              (FARPROC)FailSymUnloadModule},
    {"SymUnloadModule64",            (FARPROC)FailSymUnloadModule64},
#ifndef _WIN64
    {"UnmapDebugInformation",        (FARPROC)FailUnmapDebugInformation},
#endif
    {NULL, NULL}
};

#endif      // BUILD_IMAGEHLP

#ifdef BUILD_IMAGEHLP
FUNCPTRS *FailFunctions[2] = {NULL, DbgHelpFailPtrs}; // {MsDbiFailPtrs, DbgHelpFailPtrs};
HINSTANCE hDelayLoadDll[2];
#else
FUNCPTRS *FailFunctions[1] = {MsDbiFailPtrs};
HINSTANCE hDelayLoadDll[1];
#endif

FARPROC
FindFailureProc(
                UINT Index,
                const char *szProcName
                )
{
    FUNCPTRS *fp = FailFunctions[Index];
    UINT x = 0;

    while (fp[x].Name) {
        if (!lstrcmpi(fp[x].Name, szProcName)) {
            return fp[x].Function;
        }
        x++;
    }
    return NULL;
}

/*
 * this function exists to prevent us from calling msvcrt!splitpath
 */

VOID
ParsePath(
    CHAR *fullpath,
    CHAR *path,
    CHAR *file
    )
{
    CHAR *c;
    CHAR sz[_MAX_PATH];

    assert(fullpath);

    if (path)
        *path = 0;
    if (file)
        *file = 0;

    lstrcpy(sz, fullpath);
    for (c = sz + lstrlen(sz); c > sz; c--) {
        if (*c == '\\') {
            c++;
            if (file)
                lstrcpy(file, c);
            *c = 0;
            if (path)
                lstrcpy(path, sz);
            return;
        }
    }

    if (file)
        lstrcpy(file, fullpath);
}

FARPROC
WINAPI
ImagehlpDelayLoadHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    )
{
    FARPROC ReturnValue = NULL;

    if (dliStartProcessing == unReason)
    {
        DWORD iDll = 0;
#ifdef BUILD_IMAGEHLP
        if (!lstrcmpi(pDelayInfo->szDll, "dbghelp.dll")) {
            iDll = 2;
        }
#endif

        if (iDll) {

            iDll--;

            // If the dll isn't loaded and isn't inproc already, attempt to load
            // from the same dir as imagehlp lives...

            if (!hDelayLoadDll[iDll] &&
                !(hDelayLoadDll[iDll] = GetModuleHandle(pDelayInfo->szDll)) &&
                g.hinst)
            {
                CHAR szImageName[_MAX_PATH];
                CHAR szPath[_MAX_DIR];
                CHAR szDll[_MAX_PATH];

                // Only load if dbghelp/msdbi are in the same dir as imagehlp

                GetModuleFileName(g.hinst, szImageName, sizeof(szImageName));
                ParsePath(szImageName, szPath, szDll);
                lstrcpy(szImageName, szPath);
                lstrcat(szImageName, pDelayInfo->szDll);
                hDelayLoadDll[iDll] = LoadLibrary(szImageName);
                if (!hDelayLoadDll[iDll]) {
                    hDelayLoadDll[iDll] = (HINSTANCE)INVALID_HANDLE_VALUE;
                }
            }

            if (INVALID_HANDLE_VALUE != hDelayLoadDll[iDll] && g.hinst) {
                ReturnValue = GetProcAddress(hDelayLoadDll[iDll], pDelayInfo->dlp.szProcName);
            }

            if (!ReturnValue) {
                ReturnValue = FindFailureProc(iDll, pDelayInfo->dlp.szProcName);
            }
#if DBG
            if (!ReturnValue) {
                OutputDBString("BogusDelayLoad function encountered...\n");
            }
        } else {
            OutputDBString("BogusDelayLoad function encountered...\n");
#endif
        }
    }

    if (ReturnValue && g.hinst) {
        *pDelayInfo->ppfn = ReturnValue;
    }
    return ReturnValue;
}


#ifdef BUILD_DBGHELP

typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;


BOOL
GetDllVersionInfo(
    HINSTANCE hinst,
    LPVOID *lpVersionInfo
    )
{
    VS_FIXEDFILEINFO  *pvsFFI = NULL;
    HRSRC             hVerRes;
    VERHEAD           *pVerHead;
    BOOL              rc = FALSE;

    assert(lpVersionInfo && hinst);

    *lpVersionInfo = NULL;

    hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);
    if (hVerRes == NULL)
        goto Cleanup;

    pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
    if (pVerHead == NULL)
        goto Cleanup;

    *lpVersionInfo = MemAlloc(pVerHead->wTotLen + pVerHead->wTotLen/2);
    if (*lpVersionInfo == NULL)
        goto Cleanup;

    memcpy(*lpVersionInfo, (PVOID)pVerHead, pVerHead->wTotLen);
    rc = TRUE;

Cleanup:
    if (*lpVersionInfo && rc == FALSE)
        MemFree(*lpVersionInfo);

    return rc;
}

#endif // #ifdef BUILD_DBGHELP


PfnDliHook __pfnDliNotifyHook = ImagehlpDelayLoadHook;
PfnDliHook __pfnDliFailureHook = NULL;


#if DBG

void
OutputDBString(
    CHAR *text
    )
{
    CHAR sz[256];

    sprintf(sz, "%s: %s", MOD_FILENAME, text);
    OutputDebugString(sz);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\dumpsym.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dumpsym.cxx

Abstract:

    This is the command line tool to dump symbols from an image.

Author:

    David Fields - Feb 23, 2000
    Silviu Calinoiu - Feb 28, 2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <tchar.h>
#include <windows.h>
#include <imagehlp.h>
#include <common.ver>

//
// Section information
//
                                  
typedef struct {

    CHAR Name [9];
    DWORD64 Start;
    ULONG Size;

} IMG_SECTION_INFO, * PIMG_SECTION_INFO;

#define MAX_NUMBER_OF_SECTIONS 1024
IMG_SECTION_INFO Section [MAX_NUMBER_OF_SECTIONS];
ULONG SectionWriteIndex = 0;


typedef struct {

    HANDLE File;
    HANDLE Section;
    LPBYTE ImageBase;

    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER SectionHeader;

    DWORD FileSignature;

    PIMAGE_DATA_DIRECTORY ImportDirectory;
    PIMAGE_SECTION_HEADER ImportSection;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    DWORD_PTR AddressCorrection;

} IMAGE_BROWSE_INFO, *PIMAGE_BROWSE_INFO;


BOOL 
ImgInitializeBrowseInfo (

    LPCTSTR FilePath,
    PIMAGE_BROWSE_INFO Info);


BOOL 
ImgDeleteBrowseInfo (

    PIMAGE_BROWSE_INFO Info);

PCHAR
ImgSearchSectionForAddress (
    DWORD64 Address
    );

BOOL
ShouldExcludeSymbol (
    LPSTR Name
    );

BOOL
OpenExcludeFile (
    LPSTR FilePath
    );

//
// Symbol information
//

typedef struct {

   LPSTR Name;
   DWORD64 Address;
   ULONG Size;
   BOOL Exclude;

} SYMBOL, *PSYMBOL;

PSYMBOL Symbols;
DWORD SymbolCount;
DWORD TotalNumberOfSymbols;

VOID 
DumpSymbols(
    char *, 
    BOOL All, 
    BOOL SortBySize);

VOID
PrintUsage(
    );

VOID
Error (
    char * Fmt,
    ...
    );

int __cdecl
SymbolCompareBySize(
    const void * Arg1,
    const void * Arg2
    );

int __cdecl
SymbolCompareByAddress(
    const void * Arg1,
    const void * Arg2
    );

BOOL
CALLBACK
SymbolEnumerationCallback(
           LPSTR SymbolName,
           DWORD64 SymbolAddress,
           ULONG SymbolSize,
           PVOID UserContext
           );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID 
Help (
    )
{
    printf("dumpsym BINARY-PATH [OPTIONS]                                   \n");
    printf("%s \n", VER_LEGALCOPYRIGHT_STR);                   
    printf("                                                                \n");
    printf("OPTIONS:                                                        \n");
    printf("/notpaged      Print all symbols that are not pageable          \n");
    printf("/all           Print all symbols (default)                      \n");
    printf("/address       Sort by address in increasing order              \n");
    printf("/size          Sort by size in decreasing order (default)       \n");
    printf("/exclude PATH  File with symbols that should be ignored         \n");
    printf("/symbols PATH  Symbols path. If not specified symbols must be   \n");
    printf("               in the directory containing the binary.          \n");
    printf("                                                                \n");
    printf("Ex. dumpsym c:\\binaries.x86fre\\ntoskrnl.exe                   \n");
    printf("            /symbols c:\\binaries.x86fre\\Symbols.pri\\retail   \n");
    printf("                                                                \n");
    printf("This tool can be used to determine what symbols are not paged         \n");
    printf("and then manually analyze if any of the functions or variables        \n");
    printf("can be moved into a PAGEXXXX section (become pageable). When          \n");
    printf("analyzing this data please take into account that the size for        \n");
    printf("some symbols includes padding/alignment zones and therefore           \n");
    printf("appears to be bigger than it really is.                               \n");
    printf("                                                                      \n");
    printf("Ex. dumpsym \\\\robsvbl1\\latest\\ntfs.sys                            \n");
    printf("            /symbols \\\\robsvbl1\\latest\\Symbols.pri\\retail        \n");
    printf("            /notpaged /size                                     \n");
    printf("                                                                \n");
    printf("                                                                \n");
    exit(-1);
}


VOID
Error (
    char * Fmt,
    ...
    )
{
    va_list Prms;

    va_start (Prms, Fmt);
    fprintf (stderr, "Dumpsym error: ");
    vfprintf (stderr, Fmt, Prms);
    fprintf (stderr, "\n");
    fflush (stderr);
    exit (1);
}

PCHAR *
SearchOption (
    PCHAR * Args,
    PCHAR Option
    )
{
    for ( ; Args && *Args; Args++) {
        if (_stricmp (*Args, Option) == 0) {
            return Args;
        }
    }

    return NULL;
}


//
// main
//

VOID __cdecl
main (
    int argc,
    char *argv[]
    )
{
    IMAGE_BROWSE_INFO Info;
    PCHAR ExeName;
    PCHAR LongName;
    BOOL OptionAll;
    BOOL OptionSortBySize;
    PCHAR * OptionString;

    if (argc == 1 || SearchOption (argv, "/?")) {
        Help ();
    }

    SymInitialize(GetCurrentProcess(), NULL, FALSE);
    SymSetOptions(SYMOPT_UNDNAME);

    //
    // /exclude EXCLUDE-FILE-PATH
    //

    if ((OptionString = SearchOption (argv, "/exclude"))) {
        OpenExcludeFile (*(OptionString + 1));
    }
    
    //
    // dumpsym PATH-TO-BINARY
    //

    if ((OptionString = SearchOption (argv, argv[0]))) {
        
        ImgInitializeBrowseInfo (*(OptionString + 1), &Info);
        LongName = *(OptionString + 1);
    }
    else {
        Help ();
    }
    
    //
    // /symbols SYMBOL-PATH
    //

    if ((OptionString = SearchOption (argv, "/symbols"))) {
        SetCurrentDirectory (*(OptionString + 1));
    }
    
    //
    // Dump options.
    //

    OptionAll = TRUE;
    OptionSortBySize = TRUE;

    if (SearchOption (argv, "/notpaged")) {
        OptionAll = FALSE;
    }
    
    if (SearchOption (argv, "/all")) {
        OptionAll = TRUE;
    }
    
    if (SearchOption (argv, "/address")) {
        OptionSortBySize = FALSE;
    }
    
    if (SearchOption (argv, "/size")) {
        OptionSortBySize = TRUE;
    }
    
    //
    // Dump stuff.
    //

    DumpSymbols (LongName, OptionAll, OptionSortBySize);
}

LPSTR
CopyString (
    LPSTR Source
    )
{
    LPSTR Target;

    Target = (LPSTR) malloc (strlen(Source) + 1);

    if (Target) {
        strcpy (Target, Source);
    }

    return Target;
}


BOOL
CALLBACK
SymbolEnumerationCallback(
           LPSTR SymbolName,
           DWORD64 SymbolAddress,
           ULONG SymbolSize,
           PVOID UserContext
           )
{
    if (PtrToUlong(UserContext) == 1) {
        
        if (SymbolName == NULL) {
            Error ("Ooops");
        }

        if (SymbolCount >= TotalNumberOfSymbols) {
            Error ("enumerated more symbols on second pass");
        }

        Symbols[SymbolCount].Name = CopyString (SymbolName);
        Symbols[SymbolCount].Address = SymbolAddress;
        Symbols[SymbolCount].Size = SymbolSize;

        if (Symbols[SymbolCount].Name == NULL) {
             Symbols[SymbolCount].Name = "*error*";
        }
    }

    SymbolCount += 1;
    return TRUE;
}


int __cdecl
SymbolCompareBySize(
    const void * Arg1,
    const void * Arg2
    )
{
    PSYMBOL Sym1 = (PSYMBOL) Arg1;
    PSYMBOL Sym2 = (PSYMBOL) Arg2;

    // decreasing order by size
    return (Sym2->Size - Sym1->Size);
}


int __cdecl
SymbolCompareByAddress(
    const void * Arg1,
    const void * Arg2
    )
{
    PSYMBOL Sym1 = (PSYMBOL) Arg1;
    PSYMBOL Sym2 = (PSYMBOL) Arg2;
    INT64 Delta;

    // increasing order by address
    Delta = (INT64)(Sym1->Address - Sym2->Address);

    if (Delta > 0) {
        return 1;
    }
    else if (Delta == 0) {
        return 0;
    }
    else {
        return -1;
    }
}


VOID
DumpSymbols(
    LPTSTR ImageName, 
    BOOL All,
    BOOL SortBySize)
{
    DWORD64 BaseOfDll;
    PCHAR SectionName;
    DWORD I, J;
    BOOL FoundOne;

    //
    // Load symbols
    //

    BaseOfDll = SymLoadModule64(
        GetCurrentProcess (), 
        NULL,
        ImageName, 
        NULL,
        0, 
        0);

    if (BaseOfDll == 0) {
        Error ("cannot load symbols for %s \n", ImageName);
    }

    //
    // Number the symbols
    //

    SymbolCount = 0;

    SymEnumerateSymbols64(
        GetCurrentProcess(), 
        BaseOfDll, 
        SymbolEnumerationCallback, 
        0); // Count them

    TotalNumberOfSymbols = SymbolCount;
    printf("Detected %u symbols in %s \n\n", TotalNumberOfSymbols, ImageName);

    //
    // Read all symbols.
    //

    SymbolCount = 0;
    Symbols = malloc(TotalNumberOfSymbols * sizeof(SYMBOL));

    if (Symbols == NULL) {
        Error ("out of memory (failed to allocate %u bytes)", TotalNumberOfSymbols * sizeof(SYMBOL));
    }

    SymEnumerateSymbols64(
        GetCurrentProcess(), 
        BaseOfDll, 
        SymbolEnumerationCallback, 
        (PVOID)1);

    //
    // Sort symbols
    //

    qsort(
        Symbols, 
        TotalNumberOfSymbols, 
        sizeof(SYMBOL), 
        (SortBySize ? SymbolCompareBySize : SymbolCompareByAddress));

    //
    // Figure out symbols that should not be printed.
    //

    for (J = 0; J < TotalNumberOfSymbols; J++) {

        if (ShouldExcludeSymbol (Symbols[J].Name)) {
            Symbols[J].Exclude = TRUE;
        }
        else {
            Symbols[J].Exclude = FALSE;
        }
    }

    //
    // Print symbols
    //

    printf("%-8s %-16s %-8s %s \n", "Section", "Address", "Size", "Symbol");
    printf("-------------------------------------------------------------\n");

    for (I = 0; I < SectionWriteIndex; I++) {

        for (J = 0, FoundOne = FALSE; J < TotalNumberOfSymbols; J++) {

            if (Symbols[J].Exclude) {
                continue;
            }

            SectionName = ImgSearchSectionForAddress (
                Symbols[J].Address - BaseOfDll);

            if (strcmp (SectionName, Section[I].Name) == 0) {
                if (All || strstr (SectionName,"PAGE") == NULL) {

                    if (Symbols[J].Name == NULL) {
                        printf(".\n");
                        continue;
                    }
                    printf("%-8s %016I64X %08X %s \n", 
                        SectionName,
                        Symbols[J].Address - BaseOfDll, 
                        Symbols[J].Size,
                        Symbols[J].Name); 

                    FoundOne = TRUE;
                }
            }
        }
    
        if (FoundOne) {
            printf("\n");
        }
    }

    //
    // Unload symbols
    //

    if (SymUnloadModule64(GetCurrentProcess(),  BaseOfDll) == FALSE) {
        Error ("cannot unload symbols");
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////// Section manipulation routines
/////////////////////////////////////////////////////////////////////

//
// Function:
//
//     ImgInitializeBrowseInfo
//
// Description:
//
//     This functions fills oout the `Info' structure with
//     various pointers to PE data from the mapped image file.
//
//     Note. Even if the function returned false the destructor
//     `ImgDeleteBrowseInfo' should be called because it does some
//     cleanup.
//
// Return:
//
//     True if all the PE data pointers have been obtained.
//

BOOL
ImgInitializeBrowseInfo (

    LPCTSTR FilePath,
    PIMAGE_BROWSE_INFO Info)
{
    DWORD Index, I;

    if (Info == NULL) {
        return FALSE;
    }

    ZeroMemory (Info, sizeof *Info);

    Info->File = CreateFile (

        FilePath,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (Info->File == INVALID_HANDLE_VALUE) {

      Error ("create file %s (error %u)", FilePath, GetLastError());
      return FALSE;
    }

    Info->Section = CreateFileMapping (

        Info->File,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL);

    if (Info->Section == NULL) {

      return FALSE;
    }

    Info->ImageBase = (LPBYTE) MapViewOfFile (

        Info->Section,
        FILE_MAP_READ,
        0,
        0,
        0);

    if (Info->ImageBase == NULL) {

      return FALSE;
    }

    //
    // Check the signature
    //

    Info->DosHeader = (PIMAGE_DOS_HEADER)Info->ImageBase;

    if (Info->DosHeader->e_magic != 'ZM') {

      return FALSE;
    }

    Info->FileHeader = (PIMAGE_FILE_HEADER)
        (Info->ImageBase + Info->DosHeader->e_lfanew + sizeof(DWORD));

    Info->FileSignature = *((DWORD *)Info->FileHeader - 1);

    if (Info->FileSignature != IMAGE_NT_SIGNATURE) {

      return FALSE;
    }


    Info->OptionalHeader = (PIMAGE_OPTIONAL_HEADER)(Info->FileHeader + 1);
    Info->ImportDirectory = & (Info->OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
    Info->SectionHeader = (PIMAGE_SECTION_HEADER)(Info->OptionalHeader + 1);
    Info->ImportSection = NULL;

    //
    // Find the section containing the import table
    //

    printf("Sections in %s \n\n", FilePath);

    for (Index = 0; Index < Info->FileHeader->NumberOfSections; Index++) {

        //
        // SilviuC: I wonder if there is a way to get a 64 bit value for VirtualAddress.
        // Apparently it is stored as a ULONG in PE format.
        //

        Section[SectionWriteIndex].Start = (DWORD64)((Info->SectionHeader + Index)->VirtualAddress);
        Section[SectionWriteIndex].Size = (Info->SectionHeader + Index)->SizeOfRawData;

        for (I = 0; I < 8; I++) {
            Section[SectionWriteIndex].Name[I] = ((Info->SectionHeader + Index)->Name)[I];
        }

        Section[SectionWriteIndex].Name[I] = 0;

        printf("%-8s %08X %08X \n", 
               Section[SectionWriteIndex].Name, 
               Section[SectionWriteIndex].Start, 
               Section[SectionWriteIndex].Size);
        
        SectionWriteIndex += 1;
    }
    
    printf("\n");

    //
    // Find the address of import data in the section body.
    //

#if 0
    Info->AddressCorrection = (DWORD_PTR)Info->ImageBase 
        + Info->ImportSection->PointerToRawData
        - Info->ImportSection->VirtualAddress;

    Info->ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(Info->AddressCorrection
         + Info->ImportDirectory->VirtualAddress);
#endif

    //
    // Finish
    //

    return TRUE;
}


//
// Function:
//
//     ImgDeleteBrowseInfo
//
// Description:
//
//     This function cleans up the `Info' structure, unmaps views, 
//     closes handles, etc.
//

BOOL
ImgDeleteBrowseInfo (

    PIMAGE_BROWSE_INFO Info)
{
    if (Info == NULL)
        return FALSE;

    UnmapViewOfFile (Info->ImageBase);
    CloseHandle (Info->Section);
    CloseHandle (Info->File);

    ZeroMemory (Info, sizeof *Info);

    return TRUE;
}

PCHAR
ImgSearchSectionForAddress (
    DWORD64 Address
    )
{
    DWORD I;

    for (I = 0; I < SectionWriteIndex; I++) {
        if (Section[I].Start <= Address && Address < Section[I].Start + Section[I].Size) {
            return Section[I].Name;
        }
    }

    return "unknown";
}

//
// Exclude file logic
//

PCHAR *ExcludeStrings;
DWORD NumberOfExcludeStrings;

BOOL
ShouldExcludeSymbol (
    LPSTR Name
    )
{
    DWORD I;

    if (ExcludeStrings == NULL) {
        return FALSE;
    }
    for (I = 0; I <NumberOfExcludeStrings; I += 1) {

        if (_stricmp (Name, ExcludeStrings[I]) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
OpenExcludeFile (
    LPSTR FilePath
    )
{
    FILE * File;
    CHAR String[1024];
    DWORD StringCount = 0;

    File = fopen (FilePath, "r");

    if (File == NULL) {
        Error ("cannot open exclude file %s", FilePath);
    }

    while (fgets (String, 1024, File)) {
        StringCount += 1;
    }

    fclose (File);

    ExcludeStrings = (PCHAR *)malloc (StringCount * sizeof(PVOID));

    if (ExcludeStrings == NULL) {
        Error ("cannot allocate exclude strings buffer");
    }

    NumberOfExcludeStrings = StringCount;

    printf("Excluding %u symbols from %s \n", 
           NumberOfExcludeStrings,
           FilePath);

    File = fopen (FilePath, "r");
    if (!File) {
        Error ("cannot open file");
    }

    StringCount = 0;

    while (fgets (String, 1024, File)) {
        
        PCHAR Start, Current;

        Current = String;

        while (*Current == ' ' || *Current == '\t') {
            Current += 1;
        }

        Start = Current;

        while (*Current && *Current != ' ' && *Current != '\t' && *Current != '\n') {
            Current += 1;
        }

        *Current = '\0';

        if (StringCount < NumberOfExcludeStrings) {
            ExcludeStrings[StringCount] = CopyString (Start);

            // printf("Exclude %s \n", ExcludeStrings[StringCount]);
        }

        StringCount += 1;
    }

    fclose (File);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\ext.h ===
/**************************************************************************88
   ext.h
   dbghelp extensions include file

******************************************************************************/
    
// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <private.h>
#include <symbols.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PAGE_ALIGN64(Va) ((ULONG64)((Va) & ~((ULONG64) (PAGE_SIZE - 1))))

#include <ntverp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\ext.c ===
#include "ext.h"
#include "globals.h"

// globals

EXT_API_VERSION         ExtApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

typedef struct {
    DWORD64 base;
    DWORD64 end;
    char    name[64];
} LMINFO, *PLMINFO;

typedef struct {
    CHAR    name[4098];
    DWORD64 addr;
    CHAR    image[4098];
    DWORD   machine;
    USHORT  HdrType;
    ULONG   DebugType;
    ULONG64 DebugDataVA;
    ULONG   nDebugDirs;
    ULONG   SymType;
    time_t  TimeDateStamp;
    ULONG   CheckSum;
    ULONG   SizeOfImage;
    ULONG   Characteristics;
    ULONG   SymLoadError;
    BOOL    omap;
    CHAR    PdbFileName[_MAX_PATH + 1];
    ULONG   PdbSrc;
    CHAR    ImageFileName[_MAX_PATH + 1];
    ULONG   ImageType;
    ULONG   ImageSrc;
} MODULE_INFO, *PMODULE_INFO, *PMODULE_INFOx;

typedef struct _MACHINE_TYPE {
    ULONG   MachineId;
    PCHAR   MachineName;
} MACHINE_TYPE;

typedef struct _ERROR_TYPE {
    ULONG ErrorVal;
    PCHAR Desc;
} ERROR_TYPE;

const ERROR_TYPE SymLoadErrorDesc[] = {
    {SYMLOAD_OK,              "Symbols loaded successfully"},
    {SYMLOAD_PDBUNMATCHED,    "Unmatched PDB"},
    {SYMLOAD_PDBNOTFOUND,     "PDB not found"},
    {SYMLOAD_DBGNOTFOUND,     "DBG not found"},
    {SYMLOAD_OTHERERROR,      "Error in load symbols"},
    {SYMLOAD_OUTOFMEMORY,     "DBGHELP Out of memory"},
    {SYMLOAD_HEADERPAGEDOUT,  "Image header paged out"},
    {(EC_FORMAT << 8),        "Unrecognized pdb format"},
    {(EC_CORRUPT << 8),       "Cvinfo is corrupt"},
    {(EC_ACCESS_DENIED << 8), "Pdb read access denied"},
    {SYMLOAD_DEFERRED,        "No error - symbol load deferred"},
};


MACHINE_TYPE Machines[] = {
{IMAGE_FILE_MACHINE_UNKNOWN,            "UNKNOWN"},
{IMAGE_FILE_MACHINE_I386,               "I386"},
{IMAGE_FILE_MACHINE_R3000,              "R3000"},
{IMAGE_FILE_MACHINE_R4000,              "R4000"},
{IMAGE_FILE_MACHINE_R10000,             "R10000"},
{IMAGE_FILE_MACHINE_WCEMIPSV2,          "WCEMIPSV2"},
{IMAGE_FILE_MACHINE_ALPHA,              "ALPHA"},
{IMAGE_FILE_MACHINE_POWERPC,            "POWERPC"},
{IMAGE_FILE_MACHINE_POWERPCFP,          "POWERPCFP"},
{IMAGE_FILE_MACHINE_SH3,                "SH3"},
{IMAGE_FILE_MACHINE_SH3DSP,             "SH3DSP"},
{IMAGE_FILE_MACHINE_SH3E,               "SH3E"},
{IMAGE_FILE_MACHINE_SH4,                "SH4"},
{IMAGE_FILE_MACHINE_SH5,                "SH5"},
{IMAGE_FILE_MACHINE_ARM,                "ARM"},
{IMAGE_FILE_MACHINE_AM33,               "AM33"},
{IMAGE_FILE_MACHINE_THUMB,              "THUMB"},
{IMAGE_FILE_MACHINE_IA64,               "IA64"},
{IMAGE_FILE_MACHINE_MIPS16,             "MIPS16"},
{IMAGE_FILE_MACHINE_MIPSFPU,            "MIPSFPU"},
{IMAGE_FILE_MACHINE_MIPSFPU16,          "MIPSFPU16"},
{IMAGE_FILE_MACHINE_ALPHA64,            "ALPHA64"},
{IMAGE_FILE_MACHINE_TRICORE,            "TRICORE"},
{IMAGE_FILE_MACHINE_CEF,                "CEF"},
{IMAGE_FILE_MACHINE_CEE,                "CEE"},
{IMAGE_FILE_MACHINE_AMD64,              "AMD X86-64"},
};

char *ImageDebugType[] = {
 "UNKNOWN",
 "COFF",
 "CODEVIEW",
 "FPO",
 "MISC",
 "EXCEPTION",
 "FIXUP",
 "OMAP TO SRC",
 "OMAP FROM SRC"
 "BORLAND",
 "RESERVED10",
 "CLSID",
};

char *gSymTypeLabel[NumSymTypes] = {
    "NONE", "COFF", "CV", "PDB", "EXPORT", "DEFERRED", "SYM16", "DIA PDB"
};

char *gSrcLabel[] = {       
    "",                   // srcNone
    "symbol search path", // srcSearchPath
    "image path",         // srcImagePath
    "dbg file path",      // srcDbgPath
    "symbol server",      // srcSymSrv
    "image header",       // srcCVRec
    "debugger",           // srcHandle
    "loaded memory"       // srcMemory
};

char *gImageTypeLabel[] = {
    "DEFERRED", // dsNone,
    "MEMORY",   // dsInProc,
    "FILE",     // dsImage,
    "DBG",      // dsDbg,
    "PDB"       // dsPdb
};

void TruncateArgs(LPSTR args);
void DumpModuleInfo(HANDLE hp,PMODULE_INFO mdi);
BOOL GetModuleDumpInfo(HANDLE hp, PMODULE_ENTRY me, PMODULE_INFO mdi);

#ifdef __cplusplus
extern "C" {
#endif

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ExtApiVersion;
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
}

#ifdef __cplusplus
}
#endif  


DECLARE_API(vc7fpo)
{
    g_vc7fpo = !g_vc7fpo;
    dprintf((g_vc7fpo) ? "VC7FPO - Enabled\n" : "VC7FPO - Disabled\n");
}

DECLARE_API(sym)
{
    if (strstr(args, "noisy")) {
        SymSetOptions(g.SymOptions | SYMOPT_DEBUG);
        SetSymbolServerCallback(TRUE);
    } else if (strstr(args, "quiet")) {
        SymSetOptions(g.SymOptions & ~SYMOPT_DEBUG);
        SetSymbolServerCallback(FALSE);
    } else {
        dprintf("!sym <noisy//quiet> - ");
    }

    dprintf((g.SymOptions & SYMOPT_DEBUG) ? "Noisy mode on.\n" : "Quiet mode on.\n");

}


int __cdecl
CompareBase(
    const void *e1,
    const void *e2
    )
{
    PLMINFO mod1 = (PLMINFO)e1;
    PLMINFO mod2 = (PLMINFO)e2;

    LONGLONG diff = mod1->base - mod2->base;

    if (diff < 0) 
        return -1;
    else if (diff > 0) 
        return 1;
    else 
        return 0;
}


#define MAX_FORMAT_STRINGS 8
LPSTR
FormatAddr64(
    ULONG64 addr,
    BOOL    format64
    )
{
    static CHAR strings[MAX_FORMAT_STRINGS][18];
    static int next = 0;
    LPSTR string;

    string = strings[next];
    ++next;
    if (next >= MAX_FORMAT_STRINGS) 
        next = 0;
    if (format64) 
        sprintf(string, "%08x`%08x", (ULONG)(addr>>32), (ULONG)addr);
    else 
        sprintf(string, "%08x", (ULONG)addr);
    return string;
}


int __cdecl
CompareNames(
    const void *e1,
    const void *e2
    )
{
    PLMINFO mod1 = (PLMINFO)e1;
    PLMINFO mod2 = (PLMINFO)e2;

    return strcmp( mod1->name, mod2->name );
}


DECLARE_API(lm)
{
    PPROCESS_ENTRY pe;
    HANDLE         hp;
    PLIST_ENTRY    next;
    PMODULE_ENTRY  mi;
    PLMINFO        mods;
    PLMINFO        mod;
    DWORD          count;
    BOOL           format64;

    GetCurrentProcessHandle (&hp);
    if (!hp) {
        dprintf("Couldn't get process handle.\n");
        return;
    }

    pe = FindProcessEntry(hp);
    if (!pe) {
        dprintf("Couldn't find process 0x%x\n", hp);
        SetLastError(ERROR_INVALID_HANDLE);
        return;
    }

    next = pe->ModuleList.Flink;
    if (!next)
        return;

    for (count = 0; (PVOID)next != (PVOID)&pe->ModuleList; count++) {
        mi = CONTAINING_RECORD( next, MODULE_ENTRY, ListEntry );
        next = mi->ListEntry.Flink;
    }

    mods = (PLMINFO)MemAlloc(count * sizeof(LMINFO));
    if (!mods)
        return;

    ZeroMemory(mods, count * sizeof(LMINFO));

    format64 = FALSE;
    next = pe->ModuleList.Flink;
    for (mod = mods; (PVOID)next != (PVOID)&pe->ModuleList; mod++) {
        mi = CONTAINING_RECORD( next, MODULE_ENTRY, ListEntry );
        mod->base = mi->BaseOfDll;
        mod->end  = mod->base + mi->DllSize;
        strncpy(mod->name, mi->ModuleName, 63);

        format64 = IsImageMachineType64(mi->MachineType);

        next = mi->ListEntry.Flink;
    }

    qsort(mods, count, sizeof(LMINFO), CompareBase);
    
    dprintf("%d loaded modules...\n", count);
    if (format64)
        dprintf("               base -                 end   name\n", mod->base, mod->end, mod->name);
    else
        dprintf("      base -        end   name\n", mod->base, mod->end, mod->name);
    
    for (mod = mods; count > 0; mod++, count--) {
        dprintf("0x%s - ", FormatAddr64(mod->base, format64));
        dprintf("0x%s   ", FormatAddr64(mod->end, format64));
        dprintf("%s\n", mod->name);
    }

    MemFree(mods);
}



DECLARE_API(lmi)
{
    PPROCESS_ENTRY pe;
    PMODULE_ENTRY me = NULL;
    MODULE_INFO mdi;
    DWORD64 addr;
    HANDLE hp = 0;
    char argstr[1024];
    char *pc;

    lstrcpy(argstr, args);
    _strlwr(argstr);
    TruncateArgs(argstr);

    dprintf("Loaded Module Info: [%s] ", argstr);

    GetCurrentProcessHandle (&hp);
    if (!hp) {
        dprintf("couldn't get process handle.\n");
        return;
    }

    pe = FindProcessEntry(hp);
    if (!pe) {
        dprintf("Couldn't find process 0x%x while looking for %s\n", hp, argstr);
        SetLastError(ERROR_INVALID_HANDLE);
        return;
    }

    dprintf("\n");

    if (me = FindModule(hp, pe, argstr, FALSE)) {
        if (GetModuleDumpInfo(hp, me, &mdi)) {
            DumpModuleInfo(hp, &mdi);
        } else {
//          dprintf("Cannot get module info for %s\n", argstr);
        }
        return;
    }

    GetExpressionEx(args, &addr, NULL);

    me = GetModuleForPC( pe, addr, FALSE );
    if (!me) {
        dprintf("%I64lx is not a valid address.\n", addr);
        return;
    }
    if (GetModuleDumpInfo(hp, me, &mdi)) {
        DumpModuleInfo(hp, &mdi);
    }
}


DECLARE_API(omap)
{
    PPROCESS_ENTRY pe;
    PMODULE_ENTRY mi = NULL;
    HANDLE hp = 0;
    char argstr[1024];
    POMAP pomap;
    DWORD i;

    lstrcpy(argstr, args);
    _strlwr(argstr);
    TruncateArgs(argstr);

    dprintf("Dump OMAP: [%s] ", argstr);

    GetCurrentProcessHandle (&hp);
    if (!hp) {
        dprintf("couldn't get process handle.\n");
        return;
    }

    pe = FindProcessEntry(hp);
    if (!pe) {
        dprintf("Couldn't find process 0x%x while looking for %s\n", hp, argstr);
        SetLastError(ERROR_INVALID_HANDLE);
        return;
    }

    dprintf("\n");

    mi = FindModule(hp, pe, argstr, FALSE);
    if (!mi)
        return;

    i = sizeof(DWORD);

    if (!mi->pOmapFrom) 
        return;

    dprintf("\nOMAP FROM:\n");
    for(i = 0, pomap = mi->pOmapFrom;
        i < 100; // mi->cOmapFrom;
        i++, pomap++)
    {
        dprintf("%8x <-%8x\n", pomap->rva, pomap->rvaTo);
    }
    
    if (!mi->pOmapTo) 
        return;

    dprintf("\nOMAP TO:\n");
    for(i = 0, pomap = mi->pOmapTo;
        i < 100; // mi->cOmapTo;
        i++, pomap++)
    {
        dprintf("%8x ->%8x\n", pomap->rva, pomap->rvaTo);
    }
}


BOOL
cbSrcFiles(
    PSOURCEFILE pSourceFile,
    PVOID       UserContext
    )
{
    PMODULE_ENTRY mi;
    PCHAR mname;

    if (!pSourceFile)
        return FALSE;

    mi = GetModFromAddr((PPROCESS_ENTRY)UserContext, pSourceFile->ModBase);
    if (!mi)
        return TRUE;

    dprintf(" %s!%s\n", (*mi->AliasName) ? mi->AliasName : mi->ModuleName, pSourceFile->FileName);

    return TRUE;
}


DECLARE_API(srcfiles)
{
    HANDLE hp = 0;
    char argstr[1024];
    BOOL rc;
    PPROCESS_ENTRY pe;

    lstrcpy(argstr, args);
    _strlwr(argstr);
    TruncateArgs(argstr);

    dprintf("Source Files: [%s]\n", argstr);

    GetCurrentProcessHandle (&hp);
    if (!hp) {
        dprintf("couldn't get process handle.\n");
        return;
    }

    pe = FindProcessEntry(hp);
    if (!pe) {
        dprintf("Couldn't find process 0x%x while looking for %s\n", hp, argstr);
        SetLastError(ERROR_INVALID_HANDLE);
        return;
    }

    rc = SymEnumSourceFiles(hp, 0, argstr, cbSrcFiles, pe);
}

BOOL
GetModuleDumpInfo(
    HANDLE hp,
    PMODULE_ENTRY me,
    PMODULE_INFOx mdi)
{
    BOOL                        rc;
    DWORD                       cb;
    ULONG                       nDebugDirs;
    ULONG64                     ddva;
    IMAGE_SEPARATE_DEBUG_HEADER sdh;
    IMAGE_DOS_HEADER            DosHeader;
    IMAGE_NT_HEADERS32          NtHeader32;
    IMAGE_NT_HEADERS64          NtHeader64;
    PIMAGE_FILE_HEADER          FileHeader;
//    PIMAGE_OPTIONAL_HEADER      OptionalHeader;
    PIMAGE_ROM_OPTIONAL_HEADER  rom;
    PIMAGE_DATA_DIRECTORY       datadir;
    ULONG64 cvAddr;
    ULONG   cvSize;
    PCHAR   pCV;

    ZeroMemory(mdi, sizeof(MODULE_INFO));

    strcpy(mdi->name, me->ModuleName);
    mdi->addr = me->BaseOfDll;
    strcpy(mdi->image, me->ImageName);

    if (!mdi->addr) {
        dprintf("Module does not have base address.\n");
        return FALSE;
    }

    mdi->SymType = me->SymType;
    mdi->SymLoadError = me->SymLoadError;
    if (me->SymType == SymDeferred) {
        mdi->SymLoadError = SYMLOAD_DEFERRED;
    }
    rc = ReadMemory(mdi->addr, &DosHeader, sizeof(DosHeader), &cb);
    if (!rc || cb != sizeof(DosHeader)) {
        dprintf("Cannot read Image header @ %p\n", mdi->addr);
        return FALSE;
    }

    mdi->HdrType = DosHeader.e_magic;

    mdi->omap = me->cOmapFrom ? TRUE : FALSE;

    mdi->PdbSrc = me->PdbSrc;
    if (me->LoadedPdbName)
        strcpy(mdi->PdbFileName, me->LoadedPdbName);
    mdi->ImageSrc = me->ImageSrc;
    if (me->LoadedImageName)
        strcpy(mdi->ImageFileName, me->LoadedImageName);
    mdi->ImageType = me->ImageType;

    if (DosHeader.e_magic == IMAGE_DOS_SIGNATURE) {
        rc = ReadMemory(mdi->addr + DosHeader.e_lfanew, &NtHeader32, sizeof(NtHeader32), &cb);
        if (!rc || cb != sizeof(NtHeader32)) {
            dprintf("Cannot read Image NT header @ %p\n", mdi->addr + DosHeader.e_lfanew);
            return FALSE;
        }

        mdi->machine       = NtHeader32.FileHeader.Machine;
        mdi->TimeDateStamp = NtHeader32.FileHeader.TimeDateStamp;
        if (NtHeader32.Signature != IMAGE_NT_SIGNATURE) {

            // if header is not NT sig, this is a ROM image

            rom = (PIMAGE_ROM_OPTIONAL_HEADER)&NtHeader32.OptionalHeader;
            if (rom->Magic == IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
                FileHeader = &NtHeader32.FileHeader;

                mdi->SizeOfImage = rom->SizeOfCode;
                mdi->CheckSum = 0;

                nDebugDirs = 0;
                if (!(FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {
                    // Get the debug dir VA
                }
            } else {
                dprintf("Unknown NT Image signature\n");
                return FALSE;
            }

        } else {

            // otherwise, get info from appropriate header type for 32 or 64 bit
            if (IsImageMachineType64(NtHeader32.FileHeader.Machine)) {

                // Reread the header as a 64bit header.
                rc = ReadMemory(mdi->addr + DosHeader.e_lfanew, &NtHeader64, sizeof(NtHeader64), &cb);
                if (!rc || cb != sizeof(NtHeader64)) {
                    dprintf("Cannot read Image NT header @ %p\n", mdi->addr + DosHeader.e_lfanew);
                    return FALSE;
                }

                FileHeader = &NtHeader64.FileHeader;
                mdi->CheckSum = NtHeader64.OptionalHeader.CheckSum;
                mdi->SizeOfImage = NtHeader64.OptionalHeader.SizeOfImage;
                datadir = NtHeader64.OptionalHeader.DataDirectory;

            } else {
                FileHeader = &NtHeader32.FileHeader;
                datadir = NtHeader32.OptionalHeader.DataDirectory;
                mdi->SizeOfImage = NtHeader32.OptionalHeader.SizeOfImage;
                mdi->CheckSum = NtHeader32.OptionalHeader.CheckSum;
            }

            mdi->DebugDataVA = mdi->addr + datadir[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
            mdi->nDebugDirs = datadir[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof(IMAGE_DEBUG_DIRECTORY);
        }

        // read the section headers

        mdi->Characteristics = FileHeader->Characteristics;

    } else if (DosHeader.e_magic == IMAGE_SEPARATE_DEBUG_SIGNATURE) {
        rc = ReadMemory(mdi->addr, &sdh, sizeof(sdh), &cb);
        if (!rc || cb != sizeof(sdh)) {
            dprintf("Cannot read Image Debug header @ %p\n", mdi->addr);
            return FALSE;
        }
        mdi->machine         = sdh.Machine;
        mdi->TimeDateStamp   = sdh.TimeDateStamp;
        mdi->CheckSum        = sdh.CheckSum;
        mdi->SizeOfImage     = sdh.SizeOfImage;
        mdi->Characteristics = sdh.Characteristics;

        if (sdh.DebugDirectorySize) {
            mdi->nDebugDirs = (int)(sdh.DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY));
            mdi->DebugDataVA = sizeof(IMAGE_SEPARATE_DEBUG_HEADER)
                      + (sdh.NumberOfSections * sizeof(IMAGE_SECTION_HEADER))
                      + sdh.ExportedNamesSize;
        }
    } else {
        dprintf("Unknown image.\n");
        return FALSE;
    }

    return TRUE;
}

BOOL
DumpDbgDirectories(
    HANDLE hp,
    PMODULE_INFOx mdi
    )
{
    ULONG                       rc, cb;
    IMAGE_DEBUG_DIRECTORY       dd;
    IMAGE_DEBUG_MISC            md;
    ULONG64                     ddva;
    ULONG                       nDebugDirs;
    PCVDD                       pcv;
    ULONG64 cvAddr;
    ULONG   cvSize;
    PCHAR   pCV;
    CHAR    ImgData[MAX_PATH];
    IMAGE_COFF_SYMBOLS_HEADER CoffHdr;


    nDebugDirs = mdi->nDebugDirs;
    ddva = mdi->DebugDataVA;

    dprintf("Debug Data Dirs: Type Size     VA  Pointer\n");
    for (;nDebugDirs; dprintf("\n"), nDebugDirs--) {

        rc = ReadMemory(ddva, &dd, sizeof(dd), &cb);
        if (!rc || cb != sizeof(dd))
            return FALSE;
        if (dd.Type) {
            dprintf("%21s ", // dd.Type,
                    (dd.Type < sizeof (ImageDebugType) / sizeof(char *)) ? ImageDebugType[dd.Type] : "??");

            dprintf(
                "%4lx, %5lx, %7lx ",
                dd.SizeOfData,
                dd.AddressOfRawData,
                dd.PointerToRawData);

            switch(dd.Type)
            {
            case IMAGE_DEBUG_TYPE_MISC:
                if (!dd.PointerToRawData) {
                    dprintf("[Data not mapped]");
                    break;
                }
                rc = ReadMemory(mdi->addr + dd.PointerToRawData, &md, sizeof(md), &cb);
                if (!rc || cb != sizeof(md) || md.DataType != IMAGE_DEBUG_MISC_EXENAME) {
                    dprintf("[Data not mapped]");
                    goto nextDebugDir;
                }

                rc = ReadMemory(mdi->addr + dd.PointerToRawData + FIELD_OFFSET(IMAGE_DEBUG_MISC, Data),
                                ImgData, MAX_PATH, &cb);

                if (rc && cb)
                    dprintf(" %s", ImgData);
                break;

            case IMAGE_DEBUG_TYPE_CODEVIEW:
                if (dd.AddressOfRawData) {
                    cvAddr = mdi->addr + dd.AddressOfRawData;
                } else if (dd.PointerToRawData) {
                    cvAddr = mdi->addr + dd.PointerToRawData;
                } else {
                    break;
                }
                cvSize = dd.SizeOfData;

                if (!(pCV = (PCHAR)MemAlloc(dd.SizeOfData + 1)))
                    break;

                pcv = (PCVDD)pCV;

                rc = ReadMemory(cvAddr,pCV, cvSize, &cb);

                if (rc && cb == cvSize) {
                    char *c = (char *)&pcv->dwSig;
                    dprintf("%c%c%c%c - ", *c, *(c + 1), *(c + 2), *(c + 3));
                } else {
                    pcv->dwSig = 0;
                }

                switch (pcv->dwSig) 
                {
                case 0:
                    dprintf("[Data not mapped] - can't validate symbols, if present.");
                    break;
                case '01BN':
                    pCV[cvSize] = 0;
                    dprintf("Sig: %lx, Age: %lx,%sPdb: %s",
                            pcv->nb10i.sig,
                            pcv->nb10i.age,
                            (strlen(pCV) > 14 ? "\n               " : " "),
                            pcv->nb10i.szPdb);
                    break;
                case 'SDSR':
                pCV[cvSize] = 0;
                    dprintf("GUID: (0x%8x, 0x%4x, 0x%4x, 0x%2x, 0x%2x, 0x%2x, 0x%2x, 0x%2x, 0x%2x, 0x%2x, 0x%2x)\n",
                            pcv->rsdsi.guidSig.Data1,
                            pcv->rsdsi.guidSig.Data2,
                            pcv->rsdsi.guidSig.Data3,
                            pcv->rsdsi.guidSig.Data4[0],
                            pcv->rsdsi.guidSig.Data4[1],
                            pcv->rsdsi.guidSig.Data4[2],
                            pcv->rsdsi.guidSig.Data4[3],
                            pcv->rsdsi.guidSig.Data4[4],
                            pcv->rsdsi.guidSig.Data4[5],
                            pcv->rsdsi.guidSig.Data4[6],
                            pcv->rsdsi.guidSig.Data4[7]);
                    dprintf("               Age: %lx, Pdb: %s",
                            pcv->rsdsi.age,
                            pcv->rsdsi.szPdb);
                    break;   
                case '80BN':
                case '90BN':
                case '11BN':
                    break;
                default:
                    dprintf("unrecognized symbol format ID");
                    break;
                }

                MemFree(pCV);
                break;

            case IMAGE_DEBUG_TYPE_COFF:
                if (!dd.PointerToRawData) {
                    dprintf("[Data paged out] - unable to load COFF info.");
                    break;
                }
                rc = ReadMemory(mdi->addr + dd.PointerToRawData, &CoffHdr, sizeof(CoffHdr), &cb);
                if (!rc || cb != sizeof(CoffHdr)) {
                    dprintf("[Data paged out] - unable to load COFF info.");
                    break;
                }
                dprintf("NumSyms %#lx, Numlines %#lx",
                        CoffHdr.NumberOfSymbols,
                        CoffHdr.NumberOfLinenumbers);
                break;

            case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                dprintf("BBT Optimized");
                break;

            default:
                dprintf("[Data not mapped]");
                break;

            }
        }
nextDebugDir:
        ddva += sizeof (dd);
    }

    return TRUE;
}

void DumpModuleInfo(
    HANDLE hp,
    PMODULE_INFO mdi
    )
{
    ULONG i;
    const char *time;

    dprintf("         Module: %s\n", mdi->name);
    dprintf("   Base Address: %p%s", mdi->addr, mdi->addr ? "\n" : " is INVALID\n");
    dprintf("     Image Name: %s\n", mdi->image);
    dprintf("   Machine Type: %d",   mdi->machine);
    for (i=0;i<sizeof(Machines)/sizeof(MACHINE_TYPE);i++) {
        if (mdi->machine == Machines[i].MachineId) {
            dprintf(" (%s)", Machines[i].MachineName);
            break;
        }
    }

    dprintf("\n     Time Stamp: %lx", mdi->TimeDateStamp);
    if ((time = ctime((time_t *) &mdi->TimeDateStamp)) != NULL) {
        dprintf( " %s", time);
    } else
        dprintf("\n");

    dprintf("       CheckSum: %lx\n", mdi->CheckSum);
    dprintf("Characteristics: %lx %s %s\n",
            mdi->Characteristics,
            ((mdi->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) ? "stripped":""),
            (mdi->omap ? "perf" : "")
            );
    if (mdi->nDebugDirs) {
        DumpDbgDirectories(hp, mdi);
    } else {
        dprintf("Debug Directories not present\n");
    }

    switch (mdi->ImageType)
    {
    case dsInProc:
    case dsImage:
        if (mdi->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)
            break;
    case dsDbg:
    case dsPdb:
        dprintf("     Image Type: %-9s", gImageTypeLabel[mdi->ImageType]);
        dprintf("- Image read successfully from %s.", gSrcLabel[mdi->ImageSrc]);
        if (mdi->ImageSrc != srcNone && mdi->ImageSrc != srcMemory)
            dprintf("\n                 %s", mdi->ImageFileName);   
        dprintf("\n");
        break;
    case dsNone:
    default:
        break;
    }

    dprintf("    Symbol Type: %-9s", gSymTypeLabel[mdi->SymType]);
    for (i=0;i< sizeof(SymLoadErrorDesc) / sizeof (ERROR_TYPE); i++) {
        if (mdi->SymLoadError == SymLoadErrorDesc[i].ErrorVal) {
            dprintf("- %s", SymLoadErrorDesc[i].Desc);
            break;
        }
    }
    if (mdi->PdbSrc != srcNone) {
        dprintf(" from %s.", gSrcLabel[mdi->PdbSrc]);
        dprintf("\n                 %s\n", mdi->PdbFileName);
    } else {
        dprintf(".\n");
    }
}

void TruncateArgs(
    LPSTR sz
    )
{
    PSTR p;

    for (p = sz; !isspace(*p); p++) {
        if (!*p)
            break;
    }
    *p = 0;
}

// STYP_ flags values for MIPS ROM images

#define STYP_REG      0x00000000
#define STYP_TEXT     0x00000020
#define STYP_INIT     0x80000000
#define STYP_RDATA    0x00000100
#define STYP_DATA     0x00000040
#define STYP_LIT8     0x08000000
#define STYP_LIT4     0x10000000
#define STYP_SDATA    0x00000200
#define STYP_SBSS     0x00000080
#define STYP_BSS      0x00000400
#define STYP_LIB      0x40000000
#define STYP_UCODE    0x00000800
#define S_NRELOC_OVFL 0x20000000

#define IMAGE_SCN_MEM_SYSHEAP       0x00010000  // Obsolete
#define IMAGE_SCN_MEM_PROTECTED     0x00004000  // Obsolete


const static char * const MachineName[] = {
    "Unknown",
    "i386",
    "Alpha AXP",
    "Alpha AXP64",
    "Intel IA64",
    "AMD X86-64",
};

const static char * const SubsystemName[] = {
    "Unknown",
    "Native",
    "Windows GUI",
    "Windows CUI",
    "Posix CUI",
};

const static char * const DirectoryEntryName[] = {
    "Export",
    "Import",
    "Resource",
    "Exception",
    "Security",
    "Base Relocation",
    "Debug",
    "Description",
    "Special",
    "Thread Storage",
    "Load Configuration",
    "Bound Import",
    "Import Address Table",
    "Reserved",
    "Reserved",
    "Reserved",
    0
};

typedef enum DFT
{
   dftUnknown,
   dftObject,
   dftPE,
   dftROM,
   dftDBG,
   dftPEF,
} DFT;

IMAGE_NT_HEADERS64 ImageNtHeaders;
PIMAGE_FILE_HEADER ImageFileHdr;
PIMAGE_OPTIONAL_HEADER64 ImageOptionalHdr;
PIMAGE_SECTION_HEADER SectionHdrs;
ULONG64 Base;
ULONG64 ImageNtHeadersAddr, SectionHdrsAddr;// , ImageFileHdrAddr, ImageOptionalHdrAddr,
DFT dft;


VOID
DumpHeaders (
    VOID
    );

VOID
DumpSections(
    VOID
    );

BOOL
TranslateFilePointerToVirtualAddress(
    IN ULONG FilePointer,
    OUT PULONG VirtualAddress
    );

VOID
DumpImage(
    ULONG64 xBase,
    BOOL DoHeaders,
    BOOL DoSections
    );

VOID
ImageExtension(
    IN PSTR lpArgs
    );

DECLARE_API( dh )
{
    ImageExtension( (PSTR)args );
}

VOID
ImageExtension(
    IN PSTR lpArgs
    )
{
    BOOL DoAll;
    BOOL DoSections;
    BOOL DoHeaders;
    CHAR c;
    PCHAR p;
    ULONG64 xBase;

    //
    // Evaluate the argument string to get the address of the
    // image to dump.
    //

    DoAll = TRUE;
    DoHeaders = FALSE;
    DoSections = FALSE;

    xBase = 0;

    while (*lpArgs) {

        while (isspace(*lpArgs)) {
            lpArgs++;
        }

        if (*lpArgs == '/' || *lpArgs == '-') {

            // process switch

            switch (*++lpArgs) {

                case 'a':   // dump everything we can
                case 'A':
                    ++lpArgs;
                    DoAll = TRUE;
                    break;

                default: // invalid switch

                case 'h':   // help
                case 'H':
                case '?':

                    dprintf("Usage: dh [options] address\n");
                    dprintf("\n");
                    dprintf("Dumps headers from an image based at address.\n");
                    dprintf("\n");
                    dprintf("Options:\n");
                    dprintf("\n");
                    dprintf("   -a      Dump everything\n");
                    dprintf("   -f      Dump file headers\n");
                    dprintf("   -s      Dump section headers\n");
                    dprintf("\n");

                    return;

                case 'f':
                case 'F':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoHeaders = TRUE;
                    break;

                case 's':
                case 'S':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoSections = TRUE;
                    break;

            }

        } else if (*lpArgs) {

            if (xBase != 0) {
                dprintf("Invalid extra argument\n");
                return;
            }

            p = lpArgs;
            while (*p && !isspace(*p)) {
                p++;
            }
            c = *p;
            *p = 0;

            xBase = GetExpression(lpArgs);

            *p = c;
            lpArgs=p;

        }

    }

    if ( !xBase ) {
        return;
    }

    DumpImage(xBase, DoAll || DoHeaders, DoAll || DoSections);
}

VOID
ImageNtHdr32to64(
    PIMAGE_NT_HEADERS32 nthdr32,
    PIMAGE_NT_HEADERS64 nthdr64
    )
{
#define CP(x) nthdr64->x = nthdr32->x
#define CP64(x) nthdr64->x = (ULONG64) (LONG64) (LONG) nthdr32->x
    int i;

    CP(Signature);
    CP(FileHeader);
    CP(OptionalHeader.Magic);
    CP(OptionalHeader.MajorLinkerVersion);
    CP(OptionalHeader.MinorLinkerVersion);
    CP(OptionalHeader.SizeOfCode);
    CP(OptionalHeader.SizeOfInitializedData);
    CP(OptionalHeader.SizeOfUninitializedData);
    CP(OptionalHeader.AddressOfEntryPoint);
    CP(OptionalHeader.BaseOfCode);
    //    What about BaseOfData?
    //    nthdr64->OptionalHeader.ImageBase = (ULONG64)(nthdr32->OptionalHeader.ImageBase << 32) + nthdr32->OptionalHeader.BaseOfData;
    CP64(OptionalHeader.ImageBase);
    CP(OptionalHeader.SectionAlignment);
    CP(OptionalHeader.FileAlignment);
    CP(OptionalHeader.MajorOperatingSystemVersion);
    CP(OptionalHeader.MinorOperatingSystemVersion);
    CP(OptionalHeader.MajorImageVersion);
    CP(OptionalHeader.MinorImageVersion);
    CP(OptionalHeader.MajorSubsystemVersion);
    CP(OptionalHeader.MinorSubsystemVersion);
    CP(OptionalHeader.Win32VersionValue);
    CP(OptionalHeader.SizeOfImage);
    CP(OptionalHeader.SizeOfHeaders);
    CP(OptionalHeader.CheckSum);
    CP(OptionalHeader.Subsystem);
    CP(OptionalHeader.DllCharacteristics);
    CP64(OptionalHeader.SizeOfStackReserve);
    CP64(OptionalHeader.SizeOfStackCommit);
    CP64(OptionalHeader.SizeOfHeapReserve);
    CP64(OptionalHeader.SizeOfHeapCommit);
    CP(OptionalHeader.LoaderFlags);
    CP(OptionalHeader.NumberOfRvaAndSizes);
    for (i=0;i<sizeof(nthdr32->OptionalHeader.DataDirectory)/sizeof(IMAGE_DATA_DIRECTORY);i++) { 
        CP(OptionalHeader.DataDirectory[i]);
    }
#undef CP
#undef CP64
}
BOOL
ReadNtHeader(
    ULONG64 Address,
    PIMAGE_NT_HEADERS64 pNtHdrs
    )
{
    ULONG cb;
    BOOL  Ok;

    Ok = ReadMemory(Address, pNtHdrs, sizeof(*pNtHdrs), &cb);

    if (IsImageMachineType64(pNtHdrs->FileHeader.Machine))
    {
        Ok = Ok && (cb == sizeof(*pNtHdrs));
    }
    else
    {
        IMAGE_NT_HEADERS32 nthdr32;
        Ok = ReadMemory(Address, &nthdr32, sizeof(nthdr32), &cb);
        Ok = Ok && (cb == sizeof(nthdr32));
        ImageNtHdr32to64(&nthdr32, pNtHdrs);
    }
    return Ok;
}

VOID
DumpImage(
    ULONG64 xBase,
    BOOL DoHeaders,
    BOOL DoSections
    )
{
    IMAGE_DOS_HEADER DosHeader;
    ULONG cb;
    ULONG64 Offset;
    BOOL Ok;

    Base = xBase;

    Ok = ReadMemory(Base, &DosHeader, sizeof(DosHeader), &cb);

    if (!Ok) {
        dprintf("Can't read file header: error == %d\n", GetLastError());
        return;
    }

    if (cb != sizeof(DosHeader) || DosHeader.e_magic != IMAGE_DOS_SIGNATURE) {
        dprintf("No file header.\n");
        return;
    }

    Offset = Base + DosHeader.e_lfanew;

    if (!ReadNtHeader(ImageNtHeadersAddr=Offset, &ImageNtHeaders)) {
        dprintf("Bad file header.\n");
        return;
    }

    ImageFileHdr = &ImageNtHeaders.FileHeader;
    ImageOptionalHdr = &ImageNtHeaders.OptionalHeader;


    if (ImageFileHdr->SizeOfOptionalHeader == sizeof(IMAGE_ROM_OPTIONAL_HEADER)) {
        dft = dftROM;
    } else if (ImageFileHdr->Characteristics & IMAGE_FILE_DLL) {
        dft = dftPE;
    } else if (ImageFileHdr->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) {
        dft = dftPE;
    } else if (ImageFileHdr->SizeOfOptionalHeader == 0) {
        dft = dftObject;
    } else {
        dft = dftUnknown;
    }

    if (DoHeaders) {
        DumpHeaders();
    }

    if (DoSections) {
        ULONG NumSections;


        SectionHdrs = (PIMAGE_SECTION_HEADER) malloc((NumSections = ImageFileHdr->NumberOfSections)* 
                                                     sizeof(IMAGE_SECTION_HEADER));
        if (!SectionHdrs) {
            dprintf("Cannot allocate memory for dumping sections.\n");
            return;
        }
        __try {

            BOOL b64 = IsImageMachineType64(ImageFileHdr->Machine);
            SectionHdrsAddr = Offset + (b64 ? sizeof(IMAGE_NT_HEADERS64) : sizeof(IMAGE_NT_HEADERS32)) +
                ImageFileHdr->SizeOfOptionalHeader - (b64 ? sizeof(IMAGE_OPTIONAL_HEADER64) : sizeof(IMAGE_OPTIONAL_HEADER32));
            Ok = ReadMemory(
                            SectionHdrsAddr,
                            SectionHdrs,
                            (NumSections) * sizeof(IMAGE_SECTION_HEADER),
                            &cb);

            if (!Ok) {
                dprintf("Can't read section headers.\n");
            } else {

                if (cb != NumSections * sizeof(IMAGE_SECTION_HEADER)) {
                    dprintf("\n***\n*** Some section headers may be missing ***\n***\n\n");
                    NumSections = (USHORT)(cb / sizeof(IMAGE_SECTION_HEADER));
                }

                DumpSections( );

            }

        }
        __finally {

            if (SectionHdrs) {
                free(SectionHdrs);
                SectionHdrs = 0;
            }

        }

    }

}


VOID
DumpHeaders (
    VOID
    )

/*++

Routine Description:

    Formats the file header and optional header.

Arguments:

    None.

Return Value:

    None.

--*/

{
    int i, j;
    const char *time;
    const char *name;
    DWORD dw;

    // Print out file type

    switch (dft) {
        case dftObject :
            dprintf("\nFile Type: COFF OBJECT\n");
            break;

        case dftPE :
            if (ImageFileHdr->Characteristics & IMAGE_FILE_DLL) {
                dprintf("\nFile Type: DLL\n");
            } else {
                dprintf("\nFile Type: EXECUTABLE IMAGE\n");
            }
            break;

        case dftROM :
            dprintf("\nFile Type: ROM IMAGE\n");
            break;

        default :
            dprintf("\nFile Type: UNKNOWN\n");
            break;

    }

    switch (ImageFileHdr->Machine) {
        case IMAGE_FILE_MACHINE_I386     : i = 1; break;
        case IMAGE_FILE_MACHINE_ALPHA    : i = 2; break;
        case IMAGE_FILE_MACHINE_ALPHA64  : i = 3; break;
        case IMAGE_FILE_MACHINE_IA64     : i = 4; break;
        case IMAGE_FILE_MACHINE_AMD64    : i = 5; break;
        default : i = 0;
    }

    dprintf(
           "FILE HEADER VALUES\n"
           "%8hX machine (%s)\n"
           "%8hX number of sections\n"
           "%8lX time date stamp",
           ImageFileHdr->Machine,
           MachineName[i],
           ImageFileHdr->NumberOfSections,
           ImageFileHdr->TimeDateStamp);

    if ((time = ctime((time_t *) &ImageFileHdr->TimeDateStamp)) != NULL) {
        dprintf( " %s", time);
    }
    dprintf("\n");

    dprintf(
           "%8lX file pointer to symbol table\n"
           "%8lX number of symbols\n"
           "%8hX size of optional header\n"
           "%8hX characteristics\n",
           ImageFileHdr->PointerToSymbolTable,
           ImageFileHdr->NumberOfSymbols,
           ImageFileHdr->SizeOfOptionalHeader,
           ImageFileHdr->Characteristics);

    for (dw = ImageFileHdr->Characteristics, j = 0; dw; dw >>= 1, j++) {
        if (dw & 1) {
            switch (1 << j) {
                case IMAGE_FILE_RELOCS_STRIPPED     : name = "Relocations stripped"; break;
                case IMAGE_FILE_EXECUTABLE_IMAGE    : name = "Executable"; break;
                case IMAGE_FILE_LINE_NUMS_STRIPPED  : name = "Line numbers stripped"; break;
                case IMAGE_FILE_LOCAL_SYMS_STRIPPED : name = "Symbols stripped"; break;
                case IMAGE_FILE_LARGE_ADDRESS_AWARE : name = "App can handle >2gb addresses"; break;
                case IMAGE_FILE_BYTES_REVERSED_LO   : name = "Bytes reversed"; break;
                case IMAGE_FILE_32BIT_MACHINE       : name = "32 bit word machine"; break;
                case IMAGE_FILE_DEBUG_STRIPPED      : name = "Debug information stripped"; break;
                case IMAGE_FILE_SYSTEM              : name = "System"; break;
                case IMAGE_FILE_DLL                 : name = "DLL"; break;
                case IMAGE_FILE_BYTES_REVERSED_HI   : name = ""; break;
                default : name = "RESERVED - UNKNOWN";
            }

            if (*name) {
                dprintf( "            %s\n", name);
            }
        }
    }

    if (ImageFileHdr->SizeOfOptionalHeader != 0) {
        char szLinkerVersion[30];

        sprintf(szLinkerVersion,
                "%u.%02u",
                ImageOptionalHdr->MajorLinkerVersion,
                ImageOptionalHdr->MinorLinkerVersion);

        dprintf(
                "\n"
                "OPTIONAL HEADER VALUES\n"
                "%8hX magic #\n"
                "%8s linker version\n"
                "%8lX size of code\n"
                "%8lX size of initialized data\n"
                "%8lX size of uninitialized data\n"
                "%8lX address of entry point\n"
                "%8lX base of code\n"
                ,
                ImageOptionalHdr->Magic,
                szLinkerVersion,
                ImageOptionalHdr->SizeOfCode,
                ImageOptionalHdr->SizeOfInitializedData,
                ImageOptionalHdr->SizeOfUninitializedData,
                ImageOptionalHdr->AddressOfEntryPoint,
                ImageOptionalHdr->BaseOfCode
                );
//        dprintf("%p base of image\n",
//                ImageOptionalHdr->ImageBase
//                );
    }

    if (dft == dftROM) {
        PIMAGE_ROM_OPTIONAL_HEADER romOptionalHdr;

        romOptionalHdr = (PIMAGE_ROM_OPTIONAL_HEADER) &ImageOptionalHdr;
        dprintf(
               "         ----- rom -----\n"
               "%8lX base of bss\n"
               "%8lX gpr mask\n"
               "         cpr mask\n"
               "         %08lX %08lX %08lX %08lX\n"
               "%8hX gp value\n",
               romOptionalHdr->BaseOfBss,
               romOptionalHdr->GprMask,
               romOptionalHdr->CprMask[0],
               romOptionalHdr->CprMask[1],
               romOptionalHdr->CprMask[2],
               romOptionalHdr->CprMask[3],
               romOptionalHdr->GpValue);
    }

    if ((ImageFileHdr->SizeOfOptionalHeader == sizeof(IMAGE_OPTIONAL_HEADER32)) ||
        (ImageFileHdr->SizeOfOptionalHeader == sizeof(IMAGE_OPTIONAL_HEADER64)))
    {
        char szOSVersion[30];
        char szImageVersion[30];
        char szSubsystemVersion[30];

        switch (ImageOptionalHdr->Subsystem) {
            case IMAGE_SUBSYSTEM_POSIX_CUI   : i = 4; break;
            case IMAGE_SUBSYSTEM_WINDOWS_CUI : i = 3; break;
            case IMAGE_SUBSYSTEM_WINDOWS_GUI : i = 2; break;
            case IMAGE_SUBSYSTEM_NATIVE      : i = 1; break;
            default : i = 0;
        }

        sprintf(szOSVersion,
                "%hu.%02hu",
                ImageOptionalHdr->MajorOperatingSystemVersion,
                ImageOptionalHdr->MinorOperatingSystemVersion);

        sprintf(szImageVersion,
                "%hu.%02hu",
                ImageOptionalHdr->MajorImageVersion,
                ImageOptionalHdr->MinorImageVersion);

        sprintf(szSubsystemVersion,
                "%hu.%02hu",
                ImageOptionalHdr->MajorSubsystemVersion,
                ImageOptionalHdr->MinorSubsystemVersion);

        dprintf(
                "         ----- new -----\n"
                "%p image base\n"
                "%8lX section alignment\n"
                "%8lX file alignment\n"
                "%8hX subsystem (%s)\n"
                "%8s operating system version\n"
                "%8s image version\n"
                "%8s subsystem version\n"
                "%8lX size of image\n"
                "%8lX size of headers\n"
                "%8lX checksum\n",
                ImageOptionalHdr->ImageBase,
                ImageOptionalHdr->SectionAlignment,
                ImageOptionalHdr->FileAlignment,
                ImageOptionalHdr->Subsystem,
                SubsystemName[i],
                szOSVersion,
                szImageVersion,
                szSubsystemVersion,
                ImageOptionalHdr->SizeOfImage,
                ImageOptionalHdr->SizeOfHeaders,
                ImageOptionalHdr->CheckSum);

        dprintf(
                "%p size of stack reserve\n"
                "%p size of stack commit\n"
                "%p size of heap reserve\n"
                "%p size of heap commit\n",
                ImageOptionalHdr->SizeOfStackReserve,
                ImageOptionalHdr->SizeOfStackCommit,
                ImageOptionalHdr->SizeOfHeapReserve,
                ImageOptionalHdr->SizeOfHeapCommit);

        for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++) {
            if (!DirectoryEntryName[i]) {
                break;
            }

            dprintf( "%8lX [%8lX] address [size] of %s Directory\n",
                     ImageOptionalHdr->DataDirectory[i].VirtualAddress,
                     ImageOptionalHdr->DataDirectory[i].Size,
                     DirectoryEntryName[i]
                     );
        }

        dprintf( "\n" );
    }
}



VOID
DumpSectionHeader (
    IN DWORD i,
    IN PIMAGE_SECTION_HEADER Sh
    )
{
    const char *name;
    char *szUnDName;
    DWORD li, lj;
    WORD memFlags;

    dprintf("\nSECTION HEADER #%hX\n%8.8s name", i, Sh->Name);

#if 0
    if (Sh->Name[0] == '/') {
        name = SzObjSectionName((char *) Sh->Name, (char *) DumpStringTable);

        dprintf(" (%s)", name);
    }
#endif
    dprintf( "\n");

    dprintf( "%8lX %s\n"
             "%8lX virtual address\n"
             "%8lX size of raw data\n"
             "%8lX file pointer to raw data\n"
             "%8lX file pointer to relocation table\n",
           Sh->Misc.PhysicalAddress,
           (dft == dftObject) ? "physical address" : "virtual size",
           Sh->VirtualAddress,
           Sh->SizeOfRawData,
           Sh->PointerToRawData,
           Sh->PointerToRelocations);

    dprintf( "%8lX file pointer to line numbers\n"
                        "%8hX number of relocations\n"
                        "%8hX number of line numbers\n"
                        "%8lX flags\n",
           Sh->PointerToLinenumbers,
           Sh->NumberOfRelocations,
           Sh->NumberOfLinenumbers,
           Sh->Characteristics);

    memFlags = 0;

    li = Sh->Characteristics;

    if (dft == dftROM) {
       for (lj = 0L; li; li = li >> 1, lj++) {
            if (li & 1) {
                switch ((li & 1) << lj) {
                    case STYP_REG   : name = "Regular"; break;
                    case STYP_TEXT  : name = "Text"; memFlags = 1; break;
                    case STYP_INIT  : name = "Init Code"; memFlags = 1; break;
                    case STYP_RDATA : name = "Data"; memFlags = 2; break;
                    case STYP_DATA  : name = "Data"; memFlags = 6; break;
                    case STYP_LIT8  : name = "Literal 8"; break;
                    case STYP_LIT4  : name = "Literal 4"; break;
                    case STYP_SDATA : name = "GP Init Data"; memFlags = 6; break;
                    case STYP_SBSS  : name = "GP Uninit Data"; memFlags = 6; break;
                    case STYP_BSS   : name = "Uninit Data"; memFlags = 6; break;
                    case STYP_LIB   : name = "Library"; break;
                    case STYP_UCODE : name = "UCode"; break;
                    case S_NRELOC_OVFL : name = "Non-Relocatable overlay"; memFlags = 1; break;
                    default : name = "RESERVED - UNKNOWN";
                }

                dprintf( "         %s\n", name);
            }
        }
    } else {
        // Clear the padding bits

        li &= ~0x00700000;

        for (lj = 0L; li; li = li >> 1, lj++) {
            if (li & 1) {
                switch ((li & 1) << lj) {
                    case IMAGE_SCN_TYPE_NO_PAD  : name = "No Pad"; break;

                    case IMAGE_SCN_CNT_CODE     : name = "Code"; break;
                    case IMAGE_SCN_CNT_INITIALIZED_DATA : name = "Initialized Data"; break;
                    case IMAGE_SCN_CNT_UNINITIALIZED_DATA : name = "Uninitialized Data"; break;

                    case IMAGE_SCN_LNK_OTHER    : name = "Other"; break;
                    case IMAGE_SCN_LNK_INFO     : name = "Info"; break;
                    case IMAGE_SCN_LNK_REMOVE   : name = "Remove"; break;
                    case IMAGE_SCN_LNK_COMDAT   : name = "Communal"; break;

                    case IMAGE_SCN_MEM_DISCARDABLE: name = "Discardable"; break;
                    case IMAGE_SCN_MEM_NOT_CACHED: name = "Not Cached"; break;
                    case IMAGE_SCN_MEM_NOT_PAGED: name = "Not Paged"; break;
                    case IMAGE_SCN_MEM_SHARED   : name = "Shared"; break;
                    case IMAGE_SCN_MEM_EXECUTE  : name = ""; memFlags |= 1; break;
                    case IMAGE_SCN_MEM_READ     : name = ""; memFlags |= 2; break;
                    case IMAGE_SCN_MEM_WRITE    : name = ""; memFlags |= 4; break;

                    case IMAGE_SCN_MEM_FARDATA  : name = "Far Data"; break;
                    case IMAGE_SCN_MEM_SYSHEAP  : name = "Sys Heap"; break;
                    case IMAGE_SCN_MEM_PURGEABLE: name = "Purgeable or 16-Bit"; break;
                    case IMAGE_SCN_MEM_LOCKED   : name = "Locked"; break;
                    case IMAGE_SCN_MEM_PRELOAD  : name = "Preload"; break;
                    case IMAGE_SCN_MEM_PROTECTED: name = "Protected"; break;

                    default : name = "RESERVED - UNKNOWN";
                }

                if (*name) {
                    dprintf( "         %s\n", name);
                }
            }
        }

        // print alignment

        switch (Sh->Characteristics & 0x00700000) {
            default:                      name = "(no align specified)"; break;
            case IMAGE_SCN_ALIGN_1BYTES:  name = "1 byte align";  break;
            case IMAGE_SCN_ALIGN_2BYTES:  name = "2 byte align";  break;
            case IMAGE_SCN_ALIGN_4BYTES:  name = "4 byte align";  break;
            case IMAGE_SCN_ALIGN_8BYTES:  name = "8 byte align";  break;
            case IMAGE_SCN_ALIGN_16BYTES: name = "16 byte align"; break;
            case IMAGE_SCN_ALIGN_32BYTES: name = "32 byte align"; break;
            case IMAGE_SCN_ALIGN_64BYTES: name = "64 byte align"; break;
        }

        dprintf( "         %s\n", name);
    }

    if (memFlags) {
        switch(memFlags) {
            case 1 : name = "Execute Only"; break;
            case 2 : name = "Read Only"; break;
            case 3 : name = "Execute Read"; break;
            case 4 : name = "Write Only"; break;
            case 5 : name = "Execute Write"; break;
            case 6 : name = "Read Write"; break;
            case 7 : name = "Execute Read Write"; break;
            default : name = "Unknown Memory Flags"; break;
        }
        dprintf( "         %s\n", name);
    }
}

VOID
DumpDebugDirectory (
    IN PIMAGE_DEBUG_DIRECTORY DebugDir
    )
{
    BOOL Ok;
    DWORD cb;
    CVDD cv;
    PIMAGE_DEBUG_MISC miscData;
    PIMAGE_DEBUG_MISC miscDataCur;
    ULONG VirtualAddress;
    DWORD len;

    switch (DebugDir->Type){
        case IMAGE_DEBUG_TYPE_COFF:
            dprintf( "\tcoff   ");
            break;
        case IMAGE_DEBUG_TYPE_CODEVIEW:
            dprintf( "\tcv     ");
            break;
        case IMAGE_DEBUG_TYPE_FPO:
            dprintf( "\tfpo    ");
            break;
        case IMAGE_DEBUG_TYPE_MISC:
            dprintf( "\tmisc   ");
            break;
        case IMAGE_DEBUG_TYPE_FIXUP:
            dprintf( "\tfixup  ");
            break;
        case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
            dprintf( "\t-> src ");
            break;
        case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
            dprintf( "\tsrc -> ");
            break;
        case IMAGE_DEBUG_TYPE_EXCEPTION:
            dprintf( "\tpdata  ");
            break;
        default:
            dprintf( "\t(%6lu)", DebugDir->Type);
            break;
    }
    dprintf( "%8x    %8x %8x",
                DebugDir->SizeOfData,
                DebugDir->AddressOfRawData,
                DebugDir->PointerToRawData);

    if (DebugDir->PointerToRawData &&
        DebugDir->Type == IMAGE_DEBUG_TYPE_MISC)
    {

        if (!TranslateFilePointerToVirtualAddress(DebugDir->PointerToRawData, &VirtualAddress)) {
            dprintf(" [Debug data not mapped]\n");
        } else {

            len = DebugDir->SizeOfData;
            miscData = (PIMAGE_DEBUG_MISC) malloc(len);
            if (!miscData) {
                goto DebugTypeCodeView;
            }
            __try {
                Ok = ReadMemory(Base + VirtualAddress, miscData, len, &cb);

                if (!Ok || cb != len) {
                    dprintf("Can't read debug data\n");
                } else {

                    miscDataCur = miscData;
                    do {
                        if (miscDataCur->DataType == IMAGE_DEBUG_MISC_EXENAME) {
                            if (ImageOptionalHdr->MajorLinkerVersion == 2 &&
                                ImageOptionalHdr->MinorLinkerVersion < 37) {
                                dprintf( "\tImage Name: %s", miscDataCur->Reserved);
                            } else {
                                dprintf( "\tImage Name: %s", miscDataCur->Data);
                            }
                            break;
                        }
                        len -= miscDataCur->Length;
                        miscDataCur = (PIMAGE_DEBUG_MISC) ((PCHAR) miscDataCur + miscData->Length);
                    } while (len > 0);

                }

            }
            __finally {
                if (miscData) {
                    free(miscData);
                }
            }
        }
    }
DebugTypeCodeView:
    if (DebugDir->PointerToRawData &&
        DebugDir->Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
        if (DebugDir->AddressOfRawData) {
            VirtualAddress = DebugDir->AddressOfRawData;
        }
        if (!DebugDir->AddressOfRawData &&
            !TranslateFilePointerToVirtualAddress(DebugDir->PointerToRawData, &VirtualAddress)) {
            dprintf(" [Debug data not mapped]\n");
        } else {

            len = DebugDir->SizeOfData;

            Ok = ReadMemory(Base + VirtualAddress, &cv, len, &cb);

            if (!Ok || cb != len) {
                dprintf("\tCan't read debug data cb=%lx\n", cb);
            } else {
                if (cv.dwSig == '01BN') {
                    dprintf( "\tFormat: NB10, %x, %x, %s", cv.nb10i.sig, cv.nb10i.age, cv.nb10i.szPdb);
                } else if (cv.dwSig == 'SDSR') {
                    dprintf( "\tFormat: RSDS, guid, %x, %s", cv.nb10i.age, cv.nb10i.szPdb);
                } else {
                    dprintf( "\tFormat: UNKNOWN");
                }
            }
        }

    }

    dprintf( "\n");
}



VOID
DumpDebugDirectories (
    PIMAGE_SECTION_HEADER sh
    )

/*++

Routine Description:

    Print out the contents of all debug directories

Arguments:

    sh - Section header for section that contains debug dirs

Return Value:

    None.

--*/
{
    int                numDebugDirs;
    IMAGE_DEBUG_DIRECTORY      debugDir;
    ULONG64            DebugDirAddr;
    ULONG64            pc;
    DWORD              cb;
    BOOL               Ok;

    if (dft == dftROM) {
        DebugDirAddr = (Base + sh->VirtualAddress);
        pc = DebugDirAddr;
        Ok = ReadMemory(pc, &debugDir, sizeof(IMAGE_DEBUG_DIRECTORY), &cb);

        if (!Ok || cb != sizeof(IMAGE_DEBUG_DIRECTORY)) {
            dprintf("Can't read debug dir\n");
            return;
        }

        numDebugDirs = 0;
        while (debugDir.Type != 0) {
            numDebugDirs++;
            pc += sizeof(IMAGE_DEBUG_DIRECTORY);
            Ok = ReadMemory(pc, &debugDir, sizeof(IMAGE_DEBUG_DIRECTORY), &cb);
            if (!Ok || cb != sizeof(IMAGE_DEBUG_DIRECTORY)) {
                break;
            }
        }
    } else {
        DebugDirAddr = (Base + ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress);
        numDebugDirs = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof(IMAGE_DEBUG_DIRECTORY);
    }

    dprintf("\n\nDebug Directories(%d)\n",numDebugDirs);
    dprintf("\tType       Size     Address  Pointer\n\n");
    pc = DebugDirAddr;
    while (numDebugDirs) {
        Ok = ReadMemory(pc, &debugDir, sizeof(IMAGE_DEBUG_DIRECTORY), &cb);
        if (!Ok || cb != sizeof(IMAGE_DEBUG_DIRECTORY)) {
            dprintf("Can't read debug dir\n");
            break;
        }
        pc += sizeof(IMAGE_DEBUG_DIRECTORY);
        DumpDebugDirectory(&debugDir);
        numDebugDirs--;
    }
}



VOID
DumpSections(
    VOID
    )
{
    IMAGE_SECTION_HEADER sh;
    const char *p;
    DWORD li;
    DWORD cb;
    BOOL Ok;
    int i, j;
    CHAR szName[IMAGE_SIZEOF_SHORT_NAME + 1];


    for (i = 1; i <= ImageFileHdr->NumberOfSections; i++) {

        sh = SectionHdrs[i-1];

        //szName = SzObjSectionName((char *) sh.Name, (char *) DumpStringTable);
        strncpy(szName, (char *) sh.Name, IMAGE_SIZEOF_SHORT_NAME);
        szName[IMAGE_SIZEOF_SHORT_NAME] = 0;

        DumpSectionHeader(i, &sh);

        if (dft == dftROM) {

            if (!(ImageFileHdr->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {

                // If we're looking at the .rdata section and the symbols
                // aren't stripped, the debug directory must be here.

                if (!strcmp(szName, ".rdata")) {

                    DumpDebugDirectories(&sh);

                    //DumpDebugData(&sh);
                }
            }

        } else if (dft == dftPE) {

            if ((li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress) != 0) {
                if (li >= sh.VirtualAddress && li < sh.VirtualAddress+sh.SizeOfRawData) {
                    DumpDebugDirectories(&sh);

                    //DumpDebugData(&sh);
                }
            }


#if 0
            if (Switch.Dump.PData) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    DumpFunctionTable(pimage, rgsym, (char *) DumpStringTable, &sh);
                }
            }

            if (Switch.Dump.Imports) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    DumpImports(&sh);
                }
            }

            if (Switch.Dump.Exports) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    // UNDONE: Is this check really necessary?

                    if (ImageFileHdr->Machine != IMAGE_FILE_MACHINE_MPPC_601) {
                        DumpExports(&sh);
                    }
                }
            }

#endif

        }

    }
}

BOOL
TranslateFilePointerToVirtualAddress(
    IN ULONG FilePointer,
    OUT PULONG VirtualAddress
    )
{
    int i;
    PIMAGE_SECTION_HEADER sh;

    for (i = 1; i <= ImageFileHdr->NumberOfSections; i++) {
        sh = &SectionHdrs[i-1];

        if (sh->PointerToRawData <= FilePointer &&
            FilePointer < sh->PointerToRawData + sh->SizeOfRawData) {
            *VirtualAddress = FilePointer - sh->PointerToRawData + sh->VirtualAddress;
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\findreg.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    findreg.c

Abstract:
    Maps CV register values to debugger's values

Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma) 3/6/2000

--*/

#include "private.h"
#include "cvinfo.h"
#include "..\ntsd64\i386_reg.h"
#include "..\ntsd64\ia64_reg.h"
#include "..\ntsd64\alpha_reg.h"

typedef struct _REGISTER_LOOKUP {
    ULONG  CVReg;
    ULONG  DbgReg;
} REGISTER_LOOKUP, *PREGISTER_LOOKUP;

REGISTER_LOOKUP gRegLookupX86[] = {
    { CV_REG_AL, X86_AL},
    { CV_REG_CL, X86_CL},
    { CV_REG_DL, X86_DL},
    { CV_REG_BL, X86_BL},
    { CV_REG_AH, X86_AH},
    { CV_REG_CH, X86_CH},
    { CV_REG_DH, X86_DH},
    { CV_REG_BH, X86_BH},
    { CV_REG_AX, X86_AX},
    { CV_REG_CX, X86_CX},
    { CV_REG_DX, X86_DX},
    { CV_REG_BX, X86_BX},
    { CV_REG_SP, X86_SP},
    { CV_REG_BP, X86_BP},
    { CV_REG_SI, X86_SI},
    { CV_REG_DI, X86_DI},
    { CV_REG_EAX, X86_EAX},
    { CV_REG_ECX, X86_ECX},
    { CV_REG_EDX, X86_EDX},
    { CV_REG_EBX, X86_EBX},
    { CV_REG_ESP, X86_ESP},
    { CV_REG_EBP, X86_EBP},
    { CV_REG_ESI, X86_ESI},
    { CV_REG_EDI, X86_EDI},
    { CV_REG_ES, X86_ES},
    { CV_REG_CS, X86_CS},
    { CV_REG_SS, X86_SS},
    { CV_REG_DS, X86_DS},
    { CV_REG_FS, X86_FS},
    { CV_REG_GS, X86_GS},
    { CV_REG_IP, X86_IP},
    { CV_REG_FLAGS, X86_FL},
    { CV_REG_EIP, X86_EIP},
    { CV_REG_EFLAGS, X86_EFL},
//    { CV_REG_TEMP, REGTEMP},
//    { CV_REG_TEMPH, REGTEMPH},
//    { CV_REG_QUOTE, REGQUOTE},
//    { CV_REG_PCDR3, REGPCDR3},
//    { CV_REG_PCDR4, REGPCDR4},
//    { CV_REG_PCDR5, REGPCDR5},
//    { CV_REG_PCDR6, REGPCDR6},
//    { CV_REG_PCDR7, REGPCDR7},
    { CV_REG_CR0, X86_CR0},
//    { CV_REG_CR1, REGCR1},
    { CV_REG_CR2, X86_CR2},
    { CV_REG_CR3, X86_CR3},
    { CV_REG_CR4, X86_CR4},
    { CV_REG_DR0, X86_DR0},
    { CV_REG_DR1, X86_DR1},
    { CV_REG_DR2, X86_DR2},
    { CV_REG_DR3, X86_DR3},
//    { CV_REG_DR4, REGDR4},
//    { CV_REG_DR5, REGDR5},
    { CV_REG_DR6, X86_DR6},
    { CV_REG_DR7, X86_DR7},
    { CV_REG_GDTR, X86_GDTR},
    { CV_REG_GDTL, X86_GDTL},
    { CV_REG_IDTR, X86_IDTR},
    { CV_REG_IDTL, X86_IDTL},
    { CV_REG_LDTR, X86_LDTR},
    { CV_REG_TR, X86_TR},

//    { CV_REG_PSEUDO1, REGPSEUDO1},
//    { CV_REG_PSEUDO2, REGPSEUDO2},
//    { CV_REG_PSEUDO3, REGPSEUDO3},
//    { CV_REG_PSEUDO4, REGPSEUDO4},
//    { CV_REG_PSEUDO5, REGPSEUDO5},
//    { CV_REG_PSEUDO6, REGPSEUDO6},
//    { CV_REG_PSEUDO7, REGPSEUDO7},
//    { CV_REG_PSEUDO8, REGPSEUDO8},
//    { CV_REG_PSEUDO9, REGPSEUDO9},

    { CV_REG_ST0, X86_ST0},
    { CV_REG_ST1, X86_ST1},
    { CV_REG_ST2, X86_ST2},
    { CV_REG_ST3, X86_ST3},
    { CV_REG_ST4, X86_ST4},
    { CV_REG_ST5, X86_ST5},
    { CV_REG_ST6, X86_ST6},
    { CV_REG_ST7, X86_ST7},
    { CV_REG_CTRL, X86_FPCW},
    { CV_REG_STAT, X86_FPSW},
    { CV_REG_TAG, X86_FPTW},
//    { CV_REG_FPIP, REGFPIP},
//    { CV_REG_FPCS, REGFPCS},
//    { CV_REG_FPDO, REGFPDO},
//    { CV_REG_FPDS, REGFPDS},
//    { CV_REG_ISEM, REGISEM},
//    { CV_REG_FPEIP, REGFPEIP},
//    { CV_REG_FPEDO, REGFPEDO},

    { CV_REG_MM0, X86_MM0},
    { CV_REG_MM1, X86_MM1},
    { CV_REG_MM2, X86_MM2},
    { CV_REG_MM3, X86_MM3},
    { CV_REG_MM4, X86_MM4},
    { CV_REG_MM5, X86_MM5},
    { CV_REG_MM6, X86_MM6},
    { CV_REG_MM7, X86_MM7},

};

REGISTER_LOOKUP gRegLookupIa64[] = {

    // Branch Registers

    { CV_IA64_Br0, BRRP},
    { CV_IA64_Br1, BRS0},
    { CV_IA64_Br2, BRS1},
    { CV_IA64_Br3, BRS2},
    { CV_IA64_Br4, BRS3},
    { CV_IA64_Br5, BRS4},
    { CV_IA64_Br6, BRT0},
    { CV_IA64_Br7, BRT1},

    // Predicate Registers

    { CV_IA64_Preds, PREDS},

    // Banked General Registers
/*
    { CV_IA64_IntH0, IntH0},
    { CV_IA64_IntH1, IntH1},
    { CV_IA64_IntH2, IntH2},
    { CV_IA64_IntH3, IntH3},
    { CV_IA64_IntH4, IntH4},
    { CV_IA64_IntH5, IntH5},
    { CV_IA64_IntH6, IntH6},
    { CV_IA64_IntH7, IntH7},
    { CV_IA64_IntH8, IntH8},
    { CV_IA64_IntH9, IntH9},
    { CV_IA64_IntH10, IntH10},
    { CV_IA64_IntH11, IntH11},
    { CV_IA64_IntH12, IntH12},
    { CV_IA64_IntH13, IntH13},
    { CV_IA64_IntH14, IntH14},
    { CV_IA64_IntH15, IntH15},

    // Special Registers

    { CV_IA64_Ip, Ip},
    { CV_IA64_Umask, Umask},
    { CV_IA64_Cfm, Cfm},
    { CV_IA64_Psr, Psr},

    // Banked General Registers

    { CV_IA64_Nats, Nats},
    { CV_IA64_Nats2, Nats2},
    { CV_IA64_Nats3, Nats3},
*/
    // General-Purpose Registers

    // INTEGER REGISTER
  //  { CV_IA64_IntR0, IntZero},
    { CV_IA64_IntR1, INTGP},
    { CV_IA64_IntR2, INTT0},
    { CV_IA64_IntR3, INTT1},
    { CV_IA64_IntR4, INTS0},
    { CV_IA64_IntR5, INTS1},
    { CV_IA64_IntR6, INTS2},
    { CV_IA64_IntR7, INTS3},
    { CV_IA64_IntR8, INTV0},
//    { CV_IA64_IntR9, INTAP},
    { CV_IA64_IntR10, INTT2},
    { CV_IA64_IntR11, INTT3},
    { CV_IA64_IntR12, INTSP},
    { CV_IA64_IntR13, INTT4},
    { CV_IA64_IntR14, INTT5},
    { CV_IA64_IntR15, INTT6},
    { CV_IA64_IntR16, INTT7},
    { CV_IA64_IntR17, INTT8},
    { CV_IA64_IntR18, INTT9},
    { CV_IA64_IntR19, INTT10},
    { CV_IA64_IntR20, INTT11},
    { CV_IA64_IntR21, INTT12},
    { CV_IA64_IntR22, INTT13},
    { CV_IA64_IntR23, INTT14},
    { CV_IA64_IntR24, INTT15},
    { CV_IA64_IntR25, INTT16},
    { CV_IA64_IntR26, INTT17},
    { CV_IA64_IntR27, INTT18},
    { CV_IA64_IntR28, INTT19},
    { CV_IA64_IntR29, INTT20},
    { CV_IA64_IntR30, INTT21},
    { CV_IA64_IntR31, INTT22},

    // Register Stack
    { CV_IA64_IntR32, INTR32},
    { CV_IA64_IntR33, INTR33},
    { CV_IA64_IntR34, INTR34},
    { CV_IA64_IntR35, INTR35},
    { CV_IA64_IntR36, INTR36},
    { CV_IA64_IntR37, INTR37},
    { CV_IA64_IntR38, INTR38},
    { CV_IA64_IntR39, INTR39},
    { CV_IA64_IntR40, INTR40},
    { CV_IA64_IntR41, INTR41},
    { CV_IA64_IntR42, INTR42},
    { CV_IA64_IntR43, INTR43},
    { CV_IA64_IntR44, INTR44},
    { CV_IA64_IntR45, INTR45},
    { CV_IA64_IntR46, INTR46},
    { CV_IA64_IntR47, INTR47},
    { CV_IA64_IntR48, INTR48},
    { CV_IA64_IntR49, INTR49},
    { CV_IA64_IntR50, INTR50},
    { CV_IA64_IntR51, INTR51},
    { CV_IA64_IntR52, INTR52},
    { CV_IA64_IntR53, INTR53},
    { CV_IA64_IntR54, INTR54},
    { CV_IA64_IntR55, INTR55},
    { CV_IA64_IntR56, INTR56},
    { CV_IA64_IntR57, INTR57},
    { CV_IA64_IntR58, INTR58},
    { CV_IA64_IntR59, INTR59},
    { CV_IA64_IntR60, INTR60},
    { CV_IA64_IntR61, INTR61},
    { CV_IA64_IntR62, INTR62},
    { CV_IA64_IntR63, INTR63},
    { CV_IA64_IntR64, INTR64},
    { CV_IA64_IntR65, INTR65},
    { CV_IA64_IntR66, INTR66},
    { CV_IA64_IntR67, INTR67},
    { CV_IA64_IntR68, INTR68},
    { CV_IA64_IntR69, INTR69},
    { CV_IA64_IntR70, INTR70},
    { CV_IA64_IntR71, INTR71},
    { CV_IA64_IntR72, INTR72},
    { CV_IA64_IntR73, INTR73},
    { CV_IA64_IntR74, INTR74},
    { CV_IA64_IntR75, INTR75},
    { CV_IA64_IntR76, INTR76},
    { CV_IA64_IntR77, INTR77},
    { CV_IA64_IntR78, INTR78},
    { CV_IA64_IntR79, INTR79},
    { CV_IA64_IntR80, INTR80},
    { CV_IA64_IntR81, INTR81},
    { CV_IA64_IntR82, INTR82},
    { CV_IA64_IntR83, INTR83},
    { CV_IA64_IntR84, INTR84},
    { CV_IA64_IntR85, INTR85},
    { CV_IA64_IntR86, INTR86},
    { CV_IA64_IntR87, INTR87},
    { CV_IA64_IntR88, INTR88},
    { CV_IA64_IntR89, INTR89},
    { CV_IA64_IntR90, INTR90},
    { CV_IA64_IntR91, INTR91},
    { CV_IA64_IntR92, INTR92},
    { CV_IA64_IntR93, INTR93},
    { CV_IA64_IntR94, INTR94},
    { CV_IA64_IntR95, INTR95},
    { CV_IA64_IntR96, INTR96},
    { CV_IA64_IntR97, INTR97},
    { CV_IA64_IntR98, INTR98},
    { CV_IA64_IntR99, INTR99},
    { CV_IA64_IntR100, INTR100},
    { CV_IA64_IntR101, INTR101},
    { CV_IA64_IntR102, INTR102},
    { CV_IA64_IntR103, INTR103},
    { CV_IA64_IntR104, INTR104},
    { CV_IA64_IntR105, INTR105},
    { CV_IA64_IntR106, INTR106},
    { CV_IA64_IntR107, INTR107},
    { CV_IA64_IntR108, INTR108},
    { CV_IA64_IntR109, INTR109},
    { CV_IA64_IntR110, INTR110},
    { CV_IA64_IntR111, INTR111},
    { CV_IA64_IntR112, INTR112},
    { CV_IA64_IntR113, INTR113},
    { CV_IA64_IntR114, INTR114},
    { CV_IA64_IntR115, INTR115},
    { CV_IA64_IntR116, INTR116},
    { CV_IA64_IntR117, INTR117},
    { CV_IA64_IntR118, INTR118},
    { CV_IA64_IntR119, INTR119},
    { CV_IA64_IntR120, INTR120},
    { CV_IA64_IntR121, INTR121},
    { CV_IA64_IntR122, INTR122},
    { CV_IA64_IntR123, INTR123},
    { CV_IA64_IntR124, INTR124},
    { CV_IA64_IntR125, INTR125},
    { CV_IA64_IntR126, INTR126},
    { CV_IA64_IntR127, INTR127},

    // Floating-Point Registers

    // Low Floating Point Registers
//    { CV_IA64_FltF0, FltZero},
//    { CV_IA64_FltF1, FltOne},
    { CV_IA64_FltF2, FLTS0},
    { CV_IA64_FltF3, FLTS1},
    { CV_IA64_FltF4, FLTS2},
    { CV_IA64_FltF5, FLTS3},
    { CV_IA64_FltF6, FLTT0},
    { CV_IA64_FltF7, FLTT1},
    { CV_IA64_FltF8, FLTT2},
    { CV_IA64_FltF9, FLTT3},
    { CV_IA64_FltF10, FLTT4},
    { CV_IA64_FltF11, FLTT5},
    { CV_IA64_FltF12, FLTT6},
    { CV_IA64_FltF13, FLTT7},
    { CV_IA64_FltF14, FLTT8},
    { CV_IA64_FltF15, FLTT9},
    { CV_IA64_FltF16, FLTS4},
    { CV_IA64_FltF17, FLTS5},
    { CV_IA64_FltF18, FLTS6},
    { CV_IA64_FltF19, FLTS7},
    { CV_IA64_FltF20, FLTS8},
    { CV_IA64_FltF21, FLTS9},
    { CV_IA64_FltF22, FLTS10},
    { CV_IA64_FltF23, FLTS11},
    { CV_IA64_FltF24, FLTS12},
    { CV_IA64_FltF25, FLTS13},
    { CV_IA64_FltF26, FLTS14},
    { CV_IA64_FltF27, FLTS15},
    { CV_IA64_FltF28, FLTS16},
    { CV_IA64_FltF29, FLTS17},
    { CV_IA64_FltF30, FLTS18},
    { CV_IA64_FltF31, FLTS19},

    // High Floating POINT REGISters
    { CV_IA64_FltF32, FLTF32},
    { CV_IA64_FltF33, FLTF33},
    { CV_IA64_FltF34, FLTF34},
    { CV_IA64_FltF35, FLTF35},
    { CV_IA64_FltF36, FLTF36},
    { CV_IA64_FltF37, FLTF37},
    { CV_IA64_FltF38, FLTF38},
    { CV_IA64_FltF39, FLTF39},
    { CV_IA64_FltF40, FLTF40},
    { CV_IA64_FltF41, FLTF41},
    { CV_IA64_FltF42, FLTF42},
    { CV_IA64_FltF43, FLTF43},
    { CV_IA64_FltF44, FLTF44},
    { CV_IA64_FltF45, FLTF45},
    { CV_IA64_FltF46, FLTF46},
    { CV_IA64_FltF47, FLTF47},
    { CV_IA64_FltF48, FLTF48},
    { CV_IA64_FltF49, FLTF49},
    { CV_IA64_FltF50, FLTF50},
    { CV_IA64_FltF51, FLTF51},
    { CV_IA64_FltF52, FLTF52},
    { CV_IA64_FltF53, FLTF53},
    { CV_IA64_FltF54, FLTF54},
    { CV_IA64_FltF55, FLTF55},
    { CV_IA64_FltF56, FLTF56},
    { CV_IA64_FltF57, FLTF57},
    { CV_IA64_FltF58, FLTF58},
    { CV_IA64_FltF59, FLTF59},
    { CV_IA64_FltF60, FLTF60},
    { CV_IA64_FltF61, FLTF61},
    { CV_IA64_FltF62, FLTF62},
    { CV_IA64_FltF63, FLTF63},
    { CV_IA64_FltF64, FLTF64},
    { CV_IA64_FltF65, FLTF65},
    { CV_IA64_FltF66, FLTF66},
    { CV_IA64_FltF67, FLTF67},
    { CV_IA64_FltF68, FLTF68},
    { CV_IA64_FltF69, FLTF69},
    { CV_IA64_FltF70, FLTF70},
    { CV_IA64_FltF71, FLTF71},
    { CV_IA64_FltF72, FLTF72},
    { CV_IA64_FltF73, FLTF73},
    { CV_IA64_FltF74, FLTF74},
    { CV_IA64_FltF75, FLTF75},
    { CV_IA64_FltF76, FLTF76},
    { CV_IA64_FltF77, FLTF77},
    { CV_IA64_FltF78, FLTF78},
    { CV_IA64_FltF79, FLTF79},
    { CV_IA64_FltF80, FLTF80},
    { CV_IA64_FltF81, FLTF81},
    { CV_IA64_FltF82, FLTF82},
    { CV_IA64_FltF83, FLTF83},
    { CV_IA64_FltF84, FLTF84},
    { CV_IA64_FltF85, FLTF85},
    { CV_IA64_FltF86, FLTF86},
    { CV_IA64_FltF87, FLTF87},
    { CV_IA64_FltF88, FLTF88},
    { CV_IA64_FltF89, FLTF89},
    { CV_IA64_FltF90, FLTF90},
    { CV_IA64_FltF91, FLTF91},
    { CV_IA64_FltF92, FLTF92},
    { CV_IA64_FltF93, FLTF93},
    { CV_IA64_FltF94, FLTF94},
    { CV_IA64_FltF95, FLTF95},
    { CV_IA64_FltF96, FLTF96},
    { CV_IA64_FltF97, FLTF97},
    { CV_IA64_FltF98, FLTF98},
    { CV_IA64_FltF99, FLTF99},
    { CV_IA64_FltF100, FLTF100},
    { CV_IA64_FltF101, FLTF101},
    { CV_IA64_FltF102, FLTF102},
    { CV_IA64_FltF103, FLTF103},
    { CV_IA64_FltF104, FLTF104},
    { CV_IA64_FltF105, FLTF105},
    { CV_IA64_FltF106, FLTF106},
    { CV_IA64_FltF107, FLTF107},
    { CV_IA64_FltF108, FLTF108},
    { CV_IA64_FltF109, FLTF109},
    { CV_IA64_FltF110, FLTF110},
    { CV_IA64_FltF111, FLTF111},
    { CV_IA64_FltF112, FLTF112},
    { CV_IA64_FltF113, FLTF113},
    { CV_IA64_FltF114, FLTF114},
    { CV_IA64_FltF115, FLTF115},
    { CV_IA64_FltF116, FLTF116},
    { CV_IA64_FltF117, FLTF117},
    { CV_IA64_FltF118, FLTF118},
    { CV_IA64_FltF119, FLTF119},
    { CV_IA64_FltF120, FLTF120},
    { CV_IA64_FltF121, FLTF121},
    { CV_IA64_FltF122, FLTF122},
    { CV_IA64_FltF123, FLTF123},
    { CV_IA64_FltF124, FLTF124},
    { CV_IA64_FltF125, FLTF125},
    { CV_IA64_FltF126, FLTF126},
    { CV_IA64_FltF127, FLTF127},

    // Application Registers

    { CV_IA64_ApKR0, APKR0},
    { CV_IA64_ApKR1, APKR1},
    { CV_IA64_ApKR2, APKR2},
    { CV_IA64_ApKR3, APKR3},
    { CV_IA64_ApKR4, APKR4},
    { CV_IA64_ApKR5, APKR5},
    { CV_IA64_ApKR6, APKR6},
    { CV_IA64_ApKR7, APKR7},
/*    { CV_IA64_AR8, AR8},
    { CV_IA64_AR9, AR9},
    { CV_IA64_AR10, AR10},
    { CV_IA64_AR11, AR11},
    { CV_IA64_AR12, AR12},
    { CV_IA64_AR13, AR13},
    { CV_IA64_AR14, AR14},
    { CV_IA64_AR15, AR15},*/
    { CV_IA64_RsRSC, RSRSC},
    { CV_IA64_RsBSP, RSBSP},
    { CV_IA64_RsBSPSTORE, RSBSPSTORE},
    { CV_IA64_RsRNAT, RSRNAT},
//    { CV_IA64_AR20, AR20},
    { CV_IA64_StFCR, StFCR},
//    { CV_IA64_AR22, AR22},
//    { CV_IA64_AR23, AR23},
    { CV_IA64_EFLAG, Eflag},
    { CV_IA64_CSD, SegCSD},
    { CV_IA64_SSD, SegSSD},
    { CV_IA64_CFLG, Cflag},
    { CV_IA64_StFSR, STFSR},
    { CV_IA64_StFIR, STFIR},
    { CV_IA64_StFDR, STFDR},
//    { CV_IA64_AR31, AR31},
    { CV_IA64_ApCCV, APCCV},
//    { CV_IA64_AR33, AR33},
//    { CV_IA64_AR34, AR34},
//    { CV_IA64_AR35, AR35},
    { CV_IA64_ApUNAT, APUNAT},
//    { CV_IA64_AR37, AR37},
//    { CV_IA64_AR38, AR38},
//    { CV_IA64_AR39, AR39},
    { CV_IA64_StFPSR, STFPSR},
//    { CV_IA64_AR41, AR41},
//    { CV_IA64_AR42, AR42},
//    { CV_IA64_AR43, AR43},
    { CV_IA64_ApITC, APITC},
/*    { CV_IA64_AR45, AR45},
    { CV_IA64_AR46, AR46},
    { CV_IA64_AR47, AR47},
    { CV_IA64_AR48, AR48},
    { CV_IA64_AR49, AR49},
    { CV_IA64_AR50, AR50},
    { CV_IA64_AR51, AR51},
    { CV_IA64_AR52, AR52},
    { CV_IA64_AR53, AR53},
    { CV_IA64_AR54, AR54},
    { CV_IA64_AR55, AR55},
    { CV_IA64_AR56, AR56},
    { CV_IA64_AR57, AR57},
    { CV_IA64_AR58, AR58},
    { CV_IA64_AR59, AR59},
    { CV_IA64_AR60, AR60},
    { CV_IA64_AR61, AR61},
    { CV_IA64_AR62, AR62},
    { CV_IA64_AR63, AR63},*/
    { CV_IA64_RsPFS, RSPFS},
    { CV_IA64_ApLC, APLC},
    { CV_IA64_ApEC, APEC},
/*    { CV_IA64_AR67, AR67},
    { CV_IA64_AR68, AR68},
    { CV_IA64_AR69, AR69},
    { CV_IA64_AR70, AR70},
    { CV_IA64_AR71, AR71},
    { CV_IA64_AR72, AR72},
    { CV_IA64_AR73, AR73},
    { CV_IA64_AR74, AR74},
    { CV_IA64_AR75, AR75},
    { CV_IA64_AR76, AR76},
    { CV_IA64_AR77, AR77},
    { CV_IA64_AR78, AR78},
    { CV_IA64_AR79, AR79},
    { CV_IA64_AR80, AR80},
    { CV_IA64_AR81, AR81},
    { CV_IA64_AR82, AR82},
    { CV_IA64_AR83, AR83},
    { CV_IA64_AR84, AR84},
    { CV_IA64_AR85, AR85},
    { CV_IA64_AR86, AR86},
    { CV_IA64_AR87, AR87},
    { CV_IA64_AR88, AR88},
    { CV_IA64_AR89, AR89},
    { CV_IA64_AR90, AR90},
    { CV_IA64_AR91, AR91},
    { CV_IA64_AR92, AR92},
    { CV_IA64_AR93, AR93},
    { CV_IA64_AR94, AR94},
    { CV_IA64_AR95, AR95},
    { CV_IA64_AR96, AR96},
    { CV_IA64_AR97, AR97},
    { CV_IA64_AR98, AR98},
    { CV_IA64_AR99, AR99},
    { CV_IA64_AR100, AR100},
    { CV_IA64_AR101, AR101},
    { CV_IA64_AR102, AR102},
    { CV_IA64_AR103, AR103},
    { CV_IA64_AR104, AR104},
    { CV_IA64_AR105, AR105},
    { CV_IA64_AR106, AR106},
    { CV_IA64_AR107, AR107},
    { CV_IA64_AR108, AR108},
    { CV_IA64_AR109, AR109},
    { CV_IA64_AR110, AR110},
    { CV_IA64_AR111, AR111},
    { CV_IA64_AR112, AR112},
    { CV_IA64_AR113, AR113},
    { CV_IA64_AR114, AR114},
    { CV_IA64_AR115, AR115},
    { CV_IA64_AR116, AR116},
    { CV_IA64_AR117, AR117},
    { CV_IA64_AR118, AR118},
    { CV_IA64_AR119, AR119},
    { CV_IA64_AR120, AR120},
    { CV_IA64_AR121, AR121},
    { CV_IA64_AR122, AR122},
    { CV_IA64_AR123, AR123},
    { CV_IA64_AR124, AR124},
    { CV_IA64_AR125, AR125},
    { CV_IA64_AR126, AR126},
    { CV_IA64_AR127, AR127},
*/
    // Control RegisteRS

    { CV_IA64_ApDCR, APDCR},
    { CV_IA64_ApITM, APITM},
    { CV_IA64_ApIVA, APIVA},
//    { CV_IA64_CR3, CR3},
//    { CV_IA64_CR4, CR4},
//    { CV_IA64_CR5, CR5},
//    { CV_IA64_CR6, CR6},
//    { CV_IA64_CR7, CR7},
    { CV_IA64_ApPTA, APPTA},
//    { CV_IA64_CR9, CR9},
//    { CV_IA64_CR10, CR10},
//    { CV_IA64_CR11, CR11},
//    { CV_IA64_CR12, CR12},
//    { CV_IA64_CR13, CR13},
//    { CV_IA64_CR14, CR14},
//    { CV_IA64_CR15, CR15},
    { CV_IA64_StIPSR, STIPSR},
    { CV_IA64_StISR, STISR},
    { CV_IA64_CR18,  STIDA},
    { CV_IA64_StIIP, STIIP},
//    { CV_IA64_StIDTR, STIDTR},
    { CV_IA64_StIFA, STIITR},
    { CV_IA64_StIIPA, STIIPA},
    { CV_IA64_StIFS, STIFS},
    { CV_IA64_StIIM, STIIM},
    { CV_IA64_StIHA, STIHA},
/*    { CV_IA64_CR26, CR26},
    { CV_IA64_CR27, CR27},
    { CV_IA64_CR28, CR28},
    { CV_IA64_CR29, CR29},
    { CV_IA64_CR30, CR30},
    { CV_IA64_CR31, CR31},
    { CV_IA64_CR32, CR32},
    { CV_IA64_CR33, CR33},
    { CV_IA64_CR34, CR34},
    { CV_IA64_CR35, CR35},
    { CV_IA64_CR36, CR36},
    { CV_IA64_CR37, CR37},
    { CV_IA64_CR38, CR38},
    { CV_IA64_CR39, CR39},
    { CV_IA64_CR40, CR40},
    { CV_IA64_CR41, CR41},
    { CV_IA64_CR42, CR42},
    { CV_IA64_CR43, CR43},
    { CV_IA64_CR44, CR44},
    { CV_IA64_CR45, CR45},
    { CV_IA64_CR46, CR46},
    { CV_IA64_CR47, CR47},
    { CV_IA64_CR48, CR48},
    { CV_IA64_CR49, CR49},
    { CV_IA64_CR50, CR50},
    { CV_IA64_CR51, CR51},
    { CV_IA64_CR52, CR52},
    { CV_IA64_CR53, CR53},
    { CV_IA64_CR54, CR54},
    { CV_IA64_CR55, CR55},
    { CV_IA64_CR56, CR56},
    { CV_IA64_CR57, CR57},
    { CV_IA64_CR58, CR58},
    { CV_IA64_CR59, CR59},
    { CV_IA64_CR60, CR60},
    { CV_IA64_CR61, CR61},
    { CV_IA64_CR62, CR62},
    { CV_IA64_CR63, CR63},
    { CV_IA64_CR64, CR64},
    { CV_IA64_CR65, CR65},*/
    { CV_IA64_SaLID, SALID},
//    { CV_IA64_CR67, CR67},
//    { CV_IA64_CR68, CR68},
//    { CV_IA64_CR69, CR69},
//    { CV_IA64_CR70, CR70},
    { CV_IA64_SaIVR, SAIVR},
    { CV_IA64_SaTPR, SATPR},
//    { CV_IA64_CR73, CR73},
//    { CV_IA64_CR74, CR74},
    { CV_IA64_SaEOI, SAEOI},
/*    { CV_IA64_CR76, CR76},
    { CV_IA64_CR77, CR77},
    { CV_IA64_CR78, CR78},
    { CV_IA64_CR79, CR79},
    { CV_IA64_CR80, CR80},
    { CV_IA64_CR81, CR81},
    { CV_IA64_CR82, CR82},
    { CV_IA64_CR83, CR83},
    { CV_IA64_CR84, CR84},
    { CV_IA64_CR85, CR85},
    { CV_IA64_CR86, CR86},
    { CV_IA64_CR87, CR87},
    { CV_IA64_CR88, CR88},
    { CV_IA64_CR89, CR89},
    { CV_IA64_CR90, CR90},
    { CV_IA64_CR91, CR91},
    { CV_IA64_CR92, CR92},
    { CV_IA64_CR93, CR93},
    { CV_IA64_CR94, CR94},
    { CV_IA64_CR95, CR95},*/
    { CV_IA64_SaIRR0, SAIRR0},
//    { CV_IA64_CR97, CR97},
    { CV_IA64_SaIRR1, SAIRR1},
//    { CV_IA64_CR99, CR99},
    { CV_IA64_SaIRR2, SAIRR2},
//    { CV_IA64_CR101, CR101},
    { CV_IA64_SaIRR3, SAIRR3},
/*    { CV_IA64_CR103, CR103},
    { CV_IA64_CR104, CR104},
    { CV_IA64_CR105, CR105},
    { CV_IA64_CR106, CR106},
    { CV_IA64_CR107, CR107},
    { CV_IA64_CR108, CR108},
    { CV_IA64_CR109, CR109},
    { CV_IA64_CR110, CR110},
    { CV_IA64_CR111, CR111},
    { CV_IA64_CR112, CR112},
    { CV_IA64_CR113, CR113},*/
    { CV_IA64_SaITV, SAITV},
//    { CV_IA64_CR115, CR115},
    { CV_IA64_SaPMV, SAPMV},
    { CV_IA64_SaLRR0, SALRR0},
    { CV_IA64_SaLRR1, SALRR1},
    { CV_IA64_SaCMCV, SACMCV},
//    { CV_IA64_CR120, CR120},
//    { CV_IA64_CR121, CR121},
//    { CV_IA64_CR122, CR122},
//    { CV_IA64_CR123, CR123},
//    { CV_IA64_CR124, CR124},
//    { CV_IA64_CR125, CR125},
//    { CV_IA64_CR126, CR126},
//    { CV_IA64_CR127, CR127},

    // Protection Key Registers

    { CV_IA64_Pkr0, SRPKR0},
    { CV_IA64_Pkr1, SRPKR1},
    { CV_IA64_Pkr2, SRPKR2},
    { CV_IA64_Pkr3, SRPKR3},
    { CV_IA64_Pkr4, SRPKR4},
    { CV_IA64_Pkr5, SRPKR5},
    { CV_IA64_Pkr6, SRPKR6},
    { CV_IA64_Pkr7, SRPKR7},
    { CV_IA64_Pkr8, SRPKR8},
    { CV_IA64_Pkr9, SRPKR9},
    { CV_IA64_Pkr10, SRPKR10},
    { CV_IA64_Pkr11, SRPKR11},
    { CV_IA64_Pkr12, SRPKR12},
    { CV_IA64_Pkr13, SRPKR13},
    { CV_IA64_Pkr14, SRPKR14},
    { CV_IA64_Pkr15, SRPKR15},

    // REGION REGISTERS

    { CV_IA64_Rr0, SRRR0},
    { CV_IA64_Rr1, SRRR1},
    { CV_IA64_Rr2, SRRR2},
    { CV_IA64_Rr3, SRRR3},
    { CV_IA64_Rr4, SRRR4},
    { CV_IA64_Rr5, SRRR5},
    { CV_IA64_Rr6, SRRR6},
    { CV_IA64_Rr7, SRRR7},

    // PERFORMANCE MONITOR DATA REGISTERS

    { CV_IA64_PFD0, KRPFD0},
    { CV_IA64_PFD1, KRPFD1},
    { CV_IA64_PFD2, KRPFD2},
    { CV_IA64_PFD3, KRPFD3},
    { CV_IA64_PFD4, KRPFD4},
    { CV_IA64_PFD5, KRPFD5},
    { CV_IA64_PFD6, KRPFD6},
    { CV_IA64_PFD7, KRPFD7},

    // PERFORMANCE MONITOR CONFIG REGISTERS

    { CV_IA64_PFC0, KRPFC0},
    { CV_IA64_PFC1, KRPFC1},
    { CV_IA64_PFC2, KRPFC2},
    { CV_IA64_PFC3, KRPFC3},
    { CV_IA64_PFC4, KRPFC4},
    { CV_IA64_PFC5, KRPFC5},
    { CV_IA64_PFC6, KRPFC6},
    { CV_IA64_PFC7, KRPFC7},

    // INSTRUCTION TRANSLATION REGISTERS

    { CV_IA64_TrI0, SRTRI0},
    { CV_IA64_TrI1, SRTRI1},
    { CV_IA64_TrI2, SRTRI2},
    { CV_IA64_TrI3, SRTRI3},
    { CV_IA64_TrI4, SRTRI4},
    { CV_IA64_TrI5, SRTRI5},
    { CV_IA64_TrI6, SRTRI6},
    { CV_IA64_TrI7, SRTRI7},

    // DATA TRANSLATION REGISTERS

    { CV_IA64_TrD0, SRTRD0},
    { CV_IA64_TrD1, SRTRD1},
    { CV_IA64_TrD2, SRTRD2},
    { CV_IA64_TrD3, SRTRD3},
    { CV_IA64_TrD4, SRTRD4},
    { CV_IA64_TrD5, SRTRD5},
    { CV_IA64_TrD6, SRTRD6},
    { CV_IA64_TrD7, SRTRD7},

    // INSTRUCTION BREAKPOINT REGISTERS

    { CV_IA64_DbI0, KRDBI0},
    { CV_IA64_DbI1, KRDBI1},
    { CV_IA64_DbI2, KRDBI2},
    { CV_IA64_DbI3, KRDBI3},
    { CV_IA64_DbI4, KRDBI4},
    { CV_IA64_DbI5, KRDBI5},
    { CV_IA64_DbI6, KRDBI6},
    { CV_IA64_DbI7, KRDBI7},

    // DATA BREAKPOINT REGISTERS

    { CV_IA64_DbD0, KRDBD0},
    { CV_IA64_DbD1, KRDBD1},
    { CV_IA64_DbD2, KRDBD2},
    { CV_IA64_DbD3, KRDBD3},
    { CV_IA64_DbD4, KRDBD4},
    { CV_IA64_DbD5, KRDBD5},
    { CV_IA64_DbD6, KRDBD6},
    { CV_IA64_DbD7, KRDBD7},
};

REGISTER_LOOKUP gRegLookupAlpha[] = {

    {CV_ALPHA_FltF0, ALPHA_F0},
    {CV_ALPHA_FltF1, ALPHA_F1},
    {CV_ALPHA_FltF2, ALPHA_F2},
    {CV_ALPHA_FltF3, ALPHA_F3},
    {CV_ALPHA_FltF4, ALPHA_F4},
    {CV_ALPHA_FltF5, ALPHA_F5},
    {CV_ALPHA_FltF6, ALPHA_F6},
    {CV_ALPHA_FltF7, ALPHA_F7},
    {CV_ALPHA_FltF8, ALPHA_F8},
    {CV_ALPHA_FltF9, ALPHA_F9},
    {CV_ALPHA_FltF10, ALPHA_F10},
    {CV_ALPHA_FltF11, ALPHA_F11},
    {CV_ALPHA_FltF12, ALPHA_F12},
    {CV_ALPHA_FltF13, ALPHA_F13},
    {CV_ALPHA_FltF14, ALPHA_F14},
    {CV_ALPHA_FltF15, ALPHA_F15},
    {CV_ALPHA_FltF16, ALPHA_F16},
    {CV_ALPHA_FltF17, ALPHA_F17},
    {CV_ALPHA_FltF18, ALPHA_F18},
    {CV_ALPHA_FltF19, ALPHA_F19},
    {CV_ALPHA_FltF20, ALPHA_F20},
    {CV_ALPHA_FltF21, ALPHA_F21},
    {CV_ALPHA_FltF22, ALPHA_F22},
    {CV_ALPHA_FltF23, ALPHA_F23},
    {CV_ALPHA_FltF24, ALPHA_F24},
    {CV_ALPHA_FltF25, ALPHA_F25},
    {CV_ALPHA_FltF26, ALPHA_F26},
    {CV_ALPHA_FltF27, ALPHA_F27},
    {CV_ALPHA_FltF28, ALPHA_F28},
    {CV_ALPHA_FltF29, ALPHA_F29},
    {CV_ALPHA_FltF30, ALPHA_F30},
    {CV_ALPHA_FltF31, ALPHA_F31},

    {CV_ALPHA_IntV0, ALPHA_V0},
    {CV_ALPHA_IntT0, ALPHA_T0},
    {CV_ALPHA_IntT1, ALPHA_T1},
    {CV_ALPHA_IntT2, ALPHA_T2},
    {CV_ALPHA_IntT3, ALPHA_T3},
    {CV_ALPHA_IntT4, ALPHA_T4},
    {CV_ALPHA_IntT5, ALPHA_T5},
    {CV_ALPHA_IntT6, ALPHA_T6},
    {CV_ALPHA_IntT7, ALPHA_T7},
    {CV_ALPHA_IntS0, ALPHA_S0},
    {CV_ALPHA_IntS1, ALPHA_S1},
    {CV_ALPHA_IntS2, ALPHA_S2},
    {CV_ALPHA_IntS3, ALPHA_S3},
    {CV_ALPHA_IntS4, ALPHA_S4},
    {CV_ALPHA_IntS5, ALPHA_S5},
    {CV_ALPHA_IntFP, ALPHA_FP},
    {CV_ALPHA_IntA0, ALPHA_A0},
    {CV_ALPHA_IntA1, ALPHA_A1},
    {CV_ALPHA_IntA2, ALPHA_A2},
    {CV_ALPHA_IntA3, ALPHA_A3},
    {CV_ALPHA_IntA4, ALPHA_A4},
    {CV_ALPHA_IntA5, ALPHA_A5},
    {CV_ALPHA_IntT8, ALPHA_T8},
    {CV_ALPHA_IntT9, ALPHA_T9},
    {CV_ALPHA_IntT10, ALPHA_T10},
    {CV_ALPHA_IntT11, ALPHA_T11},
    {CV_ALPHA_IntRA, ALPHA_RA},
    {CV_ALPHA_IntT12, ALPHA_T12},
    {CV_ALPHA_IntAT, ALPHA_AT},
    {CV_ALPHA_IntGP, ALPHA_GP},
    {CV_ALPHA_IntSP, ALPHA_SP},
    {CV_ALPHA_IntZERO, ALPHA_ZERO},


    {CV_ALPHA_Fpcr, ALPHA_FPCR},
    {CV_ALPHA_Fir, ALPHA_FIR},
    {CV_ALPHA_Psr, ALPHA_PSR},
//    {CV_ALPHA_FltFsr, REGFSR},
    {CV_ALPHA_SoftFpcr, ALPHA_SFTFPCR},
};




BOOL
LookupRegID (
    IN ULONG CVReg, 
    IN ULONG MachineType,
    OUT PULONG pDbgReg)
{
    ULONG low, high, mid, Max;
    BOOL Found=FALSE;
    PREGISTER_LOOKUP ToLookup=&gRegLookupX86[0];

    if (MachineType == IMAGE_FILE_MACHINE_I386) {
        Max = sizeof (gRegLookupX86) / sizeof(REGISTER_LOOKUP);
        ToLookup = &gRegLookupX86[0];
    } else if (MachineType == IMAGE_FILE_MACHINE_IA64) {
        Max = sizeof (gRegLookupIa64) / sizeof(REGISTER_LOOKUP);
        ToLookup = &gRegLookupIa64[0];
    } else if (MachineType == IMAGE_FILE_MACHINE_AXP64 ||
               MachineType == IMAGE_FILE_MACHINE_ALPHA) {
        Max = sizeof (gRegLookupAlpha) / sizeof(REGISTER_LOOKUP);
        ToLookup = &gRegLookupAlpha[0];
    } else {
        return FALSE;
    }

    low = 0; high=Max;
    while (low <= high && !Found) { 
        mid = (low + high)/2;
        if (ToLookup[mid].CVReg == CVReg) {
            *pDbgReg = ToLookup[mid].DbgReg;
            Found = TRUE;
        } else if (ToLookup[mid].CVReg < CVReg) {
            low = mid+1;
        } else {
            high = mid-1;
        }
    }
    return Found;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\editsym.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    editsym.c

Abstract:

    This is the main source file for the EDITSYM utility program.  This
    program can be used to extract the debugging information contained in
    a separate .DBG file and put it back to the original image file.

Author:

    HonWah Chan 21-March-1994

Revision History:

--*/

#include <private.h>


BOOL fVerbose;

LPSTR FilePart;

UCHAR CurrentImageName[ MAX_PATH ];

UCHAR DbgFileName[ MAX_PATH ];


void
Usage( void )
{
    fputs( "Function: Extract debugging information contained in .dbg file\n"
           "\tand put it back in the original image file\n\n"
           "Usage: EDITSYM [-?] [-s symbol-filename] image-name\n"
           "\t\t[-?] display this message\n"
           "\t\t[-s symbol-filename] - name of the .DBG file.  Default is the same\n"
           "\t\t                        name and location as the image file.\n\n"
           "\tE.G.  EditSym -s Perfmon.dbg Perfmon.exe\n", stderr );
    exit( 1 );
}

BOOL EditSymbols(
    LPSTR pImageName,
    LPSTR pDbgFileName
    )
{
    PIMAGE_NT_HEADERS NtHeaders;
    HANDLE FileHandle, SymbolFileHandle;
    HANDLE hMappedFile;
    LPVOID ImageBase;
    PIMAGE_DEBUG_DIRECTORY DebugDirectories;
    PIMAGE_DEBUG_DIRECTORY DebugDirectoriesSave;
    DWORD DebugDirectorySize, NumberOfDebugDirectories;
    DWORD SavedErrorCode;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    DWORD i;
    DWORD NewFileSize, HeaderSum, CheckSum;
    DWORD DebugDataSize;
    LPBYTE DebugData;
    IMAGE_SEPARATE_DEBUG_HEADER DbgFileHeader;

    ImageBase = NULL;
    hMappedFile = 0;
    FileHandle = SymbolFileHandle = 0;
    DebugDirectoriesSave = NULL;

    //
    // open and map the file.
    //
    FileHandle = CreateFile( pImageName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
        }


    hMappedFile = CreateFileMapping( FileHandle,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     0,
                                     NULL
                                   );
    if (!hMappedFile) {
        CloseHandle( FileHandle );
        return FALSE;
        }

    ImageBase = MapViewOfFile( hMappedFile,
                               FILE_MAP_WRITE,
                               0,
                               0,
                               0
                             );
    if (!ImageBase) {
        CloseHandle( hMappedFile );
        CloseHandle( FileHandle );
        return FALSE;
        }

    //
    // Everything is mapped. Now check the image and find nt image headers
    //

    NtHeaders = ImageNtHeader( ImageBase );
    if (NtHeaders == NULL) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }

    if ((NtHeaders->OptionalHeader.MajorLinkerVersion < 3) &&
        (NtHeaders->OptionalHeader.MinorLinkerVersion < 5)
       ) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }

    if (!(NtHeaders->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {
        SetLastError( ERROR_ALREADY_ASSIGNED );
        goto nosyms;
        }

    DebugDirectories = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData( ImageBase,
                                                  FALSE,
                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                  &DebugDirectorySize
                                                );
    if (!DebugDirectoryIsUseful(DebugDirectories, DebugDirectorySize)) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
    }

    NumberOfDebugDirectories = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

    SymbolFileHandle = CreateFile( pDbgFileName,
                                   GENERIC_READ | GENERIC_WRITE,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL
                                 );
    if (SymbolFileHandle == INVALID_HANDLE_VALUE)
        goto nosyms;

    if (!ReadFile( SymbolFileHandle,
            &DbgFileHeader,
            sizeof(DbgFileHeader),
            &DebugDataSize,
            NULL) ||
        DebugDataSize != sizeof(DbgFileHeader)) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }

    if (DbgFileHeader.Signature != IMAGE_SEPARATE_DEBUG_SIGNATURE ||
        (DbgFileHeader.Flags & ~IMAGE_SEPARATE_DEBUG_FLAGS_MASK) != 0 ||
        DbgFileHeader.Machine != NtHeaders->FileHeader.Machine ||
        DbgFileHeader.Characteristics != NtHeaders->FileHeader.Characteristics ||
        DbgFileHeader.TimeDateStamp != NtHeaders->FileHeader.TimeDateStamp ||
        DbgFileHeader.CheckSum != NtHeaders->OptionalHeader.CheckSum ||
        DbgFileHeader.ImageBase != NtHeaders->OptionalHeader.ImageBase ||
        DbgFileHeader.SizeOfImage != NtHeaders->OptionalHeader.SizeOfImage) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }

    if (DbgFileHeader.Flags & IMAGE_SEPARATE_DEBUG_MISMATCH) {
        fprintf(stderr, "Warning: %s updated unsafely; symbols may be wrong\n",
                pDbgFileName);
    }


    // check if this is the right dbg file

    // save the DebugDirectory and get ready to write the
    // debug data to the image file.
    DebugDirectoriesSave = (PIMAGE_DEBUG_DIRECTORY) malloc( DebugDirectorySize );
    if (DebugDirectoriesSave == NULL)
        goto nosyms;

    RtlMoveMemory( DebugDirectoriesSave,
                   DebugDirectories,
                   DebugDirectorySize);

    DebugDirectory = DebugDirectoriesSave;
    NewFileSize = SetFilePointer( FileHandle, 0, NULL, FILE_END );
    NewFileSize = (NewFileSize + 3) & ~3;

    for (i=0; i<NumberOfDebugDirectories; i++) {
        // Is it one of the debug sections we need to special case?
        if (DebugDirectory->Type == IMAGE_DEBUG_TYPE_MISC) {
            // fix the mage name

            RtlCopyMemory(((PCHAR) ImageBase +
                                DebugDirectory->PointerToRawData +
                                FIELD_OFFSET( IMAGE_DEBUG_MISC, Data )),
                          FilePart,
                          strlen(FilePart) + 1);

        }
        else if (DebugDirectory->Type != IMAGE_DEBUG_TYPE_FPO) {
            DebugData = (LPBYTE) malloc( DebugDirectory->SizeOfData );
            if (SetFilePointer( SymbolFileHandle,
                    DebugDirectory->PointerToRawData,
                    NULL,
                    FILE_BEGIN ) != DebugDirectory->PointerToRawData) {
                SetLastError( ERROR_BAD_EXE_FORMAT );
                goto nosyms;
                }

            if (ReadFile( SymbolFileHandle,
                          DebugData,
                          DebugDirectory->SizeOfData,
                          &DebugDataSize,
                          NULL) &&
                DebugDataSize == DebugDirectory->SizeOfData) {
                if (WriteFile( FileHandle,
                               DebugData,
                               DebugDirectory->SizeOfData,
                               &DebugDataSize,
                               NULL) &&
                    DebugDataSize == DebugDirectory->SizeOfData) {
                    DebugDirectory->PointerToRawData = NewFileSize;
                    NewFileSize += DebugDataSize;
                    NewFileSize = (NewFileSize + 3) & ~3;
                }
                else {
                    SetLastError( ERROR_WRITE_FAULT );
                    free( DebugData );
                    goto nosyms;
                }
            }
            else {
                SetLastError( ERROR_BAD_EXE_FORMAT );
                free( DebugData );
                goto nosyms;
            }
            free( DebugData );
        }
        DebugDirectory += 1;
    }


    // somehow I needed to close the file and re-open it again.
    // otherwise it would AV inside CheckSumMappedFile.
    UnmapViewOfFile( ImageBase );
    CloseHandle( hMappedFile );
    ImageBase = NULL;
    hMappedFile = 0;

    SetFilePointer( FileHandle, NewFileSize, NULL, FILE_BEGIN );
    SetEndOfFile( FileHandle );
    CloseHandle( FileHandle );


    //
    // re-open and map the file.
    //
    FileHandle = CreateFile( pImageName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );


    hMappedFile = CreateFileMapping( FileHandle,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     0,
                                     NULL
                                   );
    if (!hMappedFile) {
        goto nosyms;
        }

    ImageBase = MapViewOfFile( hMappedFile,
                               FILE_MAP_WRITE,
                               0,
                               0,
                               0
                             );
    if (!ImageBase) {
        goto nosyms;
        }

    NtHeaders = ImageNtHeader( ImageBase );
    if (NtHeaders == NULL) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }

    DebugDirectories = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData( ImageBase,
                                                  FALSE,
                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                  &DebugDirectorySize
                                                );

    if (DebugDirectories == NULL || DebugDirectorySize == 0) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }


    RtlMoveMemory( DebugDirectories,
                   DebugDirectoriesSave,
                   DebugDirectorySize);

    free( DebugDirectoriesSave );

    NtHeaders->FileHeader.Characteristics &= ~IMAGE_FILE_DEBUG_STRIPPED;

    CheckSumMappedFile( ImageBase,
                        NewFileSize,
                        &HeaderSum,
                        &CheckSum
                      );

    NtHeaders->OptionalHeader.CheckSum = CheckSum;


    CloseHandle( SymbolFileHandle );

    UnmapViewOfFile( ImageBase );
    CloseHandle( hMappedFile );
    CloseHandle( FileHandle );

    return TRUE;

nosyms:
    SavedErrorCode = GetLastError();

    if (DebugDirectoriesSave)
        free( DebugDirectoriesSave );

    if (SymbolFileHandle && SymbolFileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle( SymbolFileHandle );
    }

    if (ImageBase)
        UnmapViewOfFile( ImageBase );

    if (hMappedFile)
        CloseHandle( hMappedFile );

    if (FileHandle && FileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle( FileHandle );
    }

    SetLastError( SavedErrorCode );
    return FALSE;
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *s;
    LPSTR DbgFilePart;

    if (argc <= 1) {
        Usage();
        }

    DbgFileName[ 0 ] = '\0';
    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            while (c = *++s)
                switch (toupper( c )) {
                case '?':
                    Usage();
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'S':
                    if (--argc) {
                        strcpy( (PCHAR) DbgFileName, *++argv );
                        }
                    else {
                        fprintf( stderr, "EDITSYM: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                default:
                    fprintf( stderr, "EDITSYM: Invalid switch - /%c\n", c );
                    Usage();
                    break;
                }
            }
        else {
            FilePart = (PCHAR) CurrentImageName;
            if (!GetFullPathNameA( s, sizeof( CurrentImageName ), (PCHAR) CurrentImageName, &FilePart )) {
                fprintf( stderr, "EDITSYM: invalid file name - %s (%u)\n", s, GetLastError() );
                }
            else {
                if (DbgFileName[0] == '\0') {
                    PCHAR  pDbgName;

                    RtlCopyMemory(DbgFileName,
                          CurrentImageName,
                          strlen((PCHAR) CurrentImageName) + 1);
                    pDbgName = (PCHAR) DbgFileName + strlen ((PCHAR) DbgFileName);
                    while (pDbgName > (PCHAR) DbgFileName) {
                        if (*pDbgName == '.') {
                            break;
                        }
                        pDbgName --;
                    }
                    if (*pDbgName != '.') {
                        fprintf( stderr, "EDITSYM: invalid exe file name - %s\n", CurrentImageName );
                    }
                    strcpy (pDbgName, ".DBG");
                }
                else if (!GetFullPathNameA( (PCHAR) DbgFileName, sizeof( DbgFileName ), (PCHAR) DbgFileName, &DbgFilePart )) {
                    fprintf( stderr, "EDITSYM: invalid Dbg file name - %s (%u)\n", s, GetLastError() );
                }

                if (EditSymbols( (PCHAR) CurrentImageName, (PCHAR) DbgFileName )) {
                    if (fVerbose) {
                        fprintf( stdout,
                                 "EDITSYM: %s symbols restored into %s\n",
                                 DbgFileName,
                                 FilePart
                               );
                        }
                    }
                else
                    fprintf( stderr, "EDITSYM: Unable to restore symbols from '%s' into '%s' (%u)\n",
                             CurrentImageName,
                             DbgFileName,
                             GetLastError()
                           );
                }
            }
        }

    exit( 0 );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\fecache.hpp ===
//----------------------------------------------------------------------------
//
// Function entry cache.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __FECACHE_HPP__
#define __FECACHE_HPP__

union FeCacheData
{
    // 32-bit Alpha entry is only temporary storage;
    // cache entries are always converted to 64-bit
    // to allow common code.
    IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY   Axp32;
    IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY Axp64;
    IMAGE_IA64_RUNTIME_FUNCTION_ENTRY    Ia64;
    _IMAGE_RUNTIME_FUNCTION_ENTRY        Amd64;
    UCHAR                                Data[1];
};

struct FeCacheEntry
{
    FeCacheData Data;
    // Generic values translated from the raw data.
    ULONG RelBegin;
    ULONG RelEnd;
    
    ULONG64 Address;
    HANDLE  Process;
    ULONG64 ModuleBase;
#if DBG
    PSTR    Description;
#endif
};

#if DBG

#define FE_DEBUG(x) if (tlsvar(DebugFunctionEntries)) dbPrint##x
#define FE_ShowRuntimeFunctionIa64(x) ShowRuntimeFunctionIa64##x
#define FE_ShowRuntimeFunctionAxp64(x) ShowRuntimeFunctionAxp64##x
#define FE_SET_DESC(Ent, Desc) ((Ent)->Description = (Desc))

void
ShowRuntimeFunctionEntryIa64(
    FeCacheEntry* FunctionEntry,
    PSTR Label
    );
void
ShowRuntimeFunctionAxp64(
    FeCacheEntry* FunctionEntry,
    PSTR Label
    );

#else

#define FE_DEBUG(x)
#define FE_ShowRuntimeFunctionIa64(x)
#define FE_ShowRuntimeFunctionAxp64(x)
#define FE_SET_DESC(Ent, Desc)

#endif // #if DBG

//----------------------------------------------------------------------------
//
// FunctionEntryCache.
//
//----------------------------------------------------------------------------

class FunctionEntryCache
{
public:
    FunctionEntryCache(ULONG ImageDataSize, ULONG CacheDataSize,
                       ULONG Machine);
    ~FunctionEntryCache(void);

    BOOL Initialize(ULONG MaxEntries, ULONG ReplaceAt);
    
    FeCacheEntry* Find(
        HANDLE                           Process,
        ULONG64                          CodeOffset,
        PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
        PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
        PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
        );
    FeCacheEntry* FindDirect(
        HANDLE                           Process,
        ULONG64                          CodeOffset,
        PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
        PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
        PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
        );
    FeCacheEntry* ReadImage(
        HANDLE                         Process,
        ULONG64                        Address,
        PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
        PGET_MODULE_BASE_ROUTINE64     GetModuleBase
        );

    void InvalidateProcessOrModule(HANDLE Process, ULONG64 Base);
    
protected:
    // Total number of entries to store.
    ULONG m_MaxEntries;
    // When the cache is full entries are overwritten starting
    // at the replacement point.  Cache hits are moved up
    // prior to the replacement point so frequently used
    // entries stay unmodified in the front of the cache
    // and other entries are stored temporarily at the end.
    ULONG m_ReplaceAt;
    // Size of raw function entry data in the image.
    ULONG m_ImageDataSize;
    // Size of raw function entry data in the cache.
    // This may be different from the image data size if
    // the image data is translated into a different form,
    // such as Axp32 keeping cache entries in Axp64 form.
    ULONG m_CacheDataSize;
    // Machine type.
    ULONG m_Machine;

    FeCacheEntry* m_Entries;
    // Number of entries currently used.
    ULONG m_Used;
    // Index of next slot to fill.
    ULONG m_Next;
    // Temporary data area for callback-filled data.
    FeCacheEntry m_Temporary;

    FeCacheEntry* FillTemporary(HANDLE Process, PVOID RawEntry)
    {
        // No need to translate as this entry is not part of
        // the cache that will be searched.
        ZeroMemory(&m_Temporary, sizeof(m_Temporary));
        memcpy(&m_Temporary.Data, RawEntry, m_CacheDataSize);
        m_Temporary.Process = Process;
        return &m_Temporary;
    }
    
    virtual void TranslateRawData(FeCacheEntry* Entry) = 0;
    virtual void TranslateRvaDataToRawData(PIMGHLP_RVA_FUNCTION_DATA RvaData,
                                           ULONG64 ModuleBase,
                                           FeCacheData* Data) = 0;
    // Base implementation just returns the given entry.
    virtual FeCacheEntry* SearchForPrimaryEntry(
        FeCacheEntry* CacheEntry,
        HANDLE Process,
        PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
        PGET_MODULE_BASE_ROUTINE64 GetModuleBase,
        PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
        );
    
    FeCacheEntry* FindStatic(
        HANDLE                           Process,
        ULONG64                          CodeOffset,
        PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
        PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
        PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry,
        PULONG64                         ModuleBase
        );
    FeCacheEntry* Promote(FeCacheEntry* Entry);
    
    ULONG64 FunctionTableBase(
        HANDLE                         Process,
        PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
        ULONG64                        Base,
        PULONG                         Size
        );
};

//----------------------------------------------------------------------------
//
// Ia64FunctionEntryCache.
//
//----------------------------------------------------------------------------

class Ia64FunctionEntryCache : public FunctionEntryCache
{
public:
    Ia64FunctionEntryCache(void) :
        FunctionEntryCache(sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY),
                           sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY),
                           IMAGE_FILE_MACHINE_IA64)
    {
    }

protected:
    virtual void TranslateRawData(FeCacheEntry* Entry);
    virtual void TranslateRvaDataToRawData(PIMGHLP_RVA_FUNCTION_DATA RvaData,
                                           ULONG64 ModuleBase,
                                           FeCacheData* Data);
};

//----------------------------------------------------------------------------
//
// Amd64FunctionEntryCache.
//
//----------------------------------------------------------------------------

class Amd64FunctionEntryCache : public FunctionEntryCache
{
public:
    Amd64FunctionEntryCache(void) :
        FunctionEntryCache(sizeof(_IMAGE_RUNTIME_FUNCTION_ENTRY),
                           sizeof(_IMAGE_RUNTIME_FUNCTION_ENTRY),
                           IMAGE_FILE_MACHINE_AMD64)
    {
    }

protected:
    virtual void TranslateRawData(FeCacheEntry* Entry);
    virtual void TranslateRvaDataToRawData(PIMGHLP_RVA_FUNCTION_DATA RvaData,
                                           ULONG64 ModuleBase,
                                           FeCacheData* Data);
};

//----------------------------------------------------------------------------
//
// AlphaFunctionEntryCache.
//
//----------------------------------------------------------------------------

class AlphaFunctionEntryCache : public FunctionEntryCache
{
public:
    AlphaFunctionEntryCache(ULONG ImageDataSize, ULONG CacheDataSize,
                            ULONG Machine) :
        FunctionEntryCache(ImageDataSize, CacheDataSize, Machine)
    {
    }

protected:
    virtual void TranslateRvaDataToRawData(PIMGHLP_RVA_FUNCTION_DATA RvaData,
                                           ULONG64 ModuleBase,
                                           FeCacheData* Data);
    virtual FeCacheEntry* SearchForPrimaryEntry(
        FeCacheEntry* CacheEntry,
        HANDLE Process,
        PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
        PGET_MODULE_BASE_ROUTINE64 GetModuleBase,
        PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
        );
};

//----------------------------------------------------------------------------
//
// Axp32FunctionEntryCache.
//
//----------------------------------------------------------------------------

class Axp32FunctionEntryCache : public AlphaFunctionEntryCache
{
public:
    Axp32FunctionEntryCache(void) :
        AlphaFunctionEntryCache(sizeof(IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY),
                                sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY),
                                IMAGE_FILE_MACHINE_ALPHA)
    {
    }

protected:
    virtual void TranslateRawData(FeCacheEntry* Entry);
};

//----------------------------------------------------------------------------
//
// Axp64FunctionEntryCache.
//
//----------------------------------------------------------------------------

class Axp64FunctionEntryCache : public AlphaFunctionEntryCache
{
public:
    Axp64FunctionEntryCache(void) :
        AlphaFunctionEntryCache(sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY),
                                sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY),
                                IMAGE_FILE_MACHINE_ALPHA64)
    {
    }

protected:
    virtual void TranslateRawData(FeCacheEntry* Entry);
};

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

FunctionEntryCache* GetFeCache(ULONG Machine, BOOL Create);
void ClearFeCaches(void);

#endif // #ifndef __FECACHE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\imagecfg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    imagecfg.c

Abstract:

    This function change the image loader configuration information in an image file.

Author:

    Steve Wood (stevewo)   8-Nov-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>

//
// Applications should include the following declaration in their
// global data to create an IMAGE_LOAD_CONFIG_DIRECTORY entry for
// their image.  Non-zero entries override defaults.
//

#if 0

IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    0,              // Characteristics;
    0,              // TimeDateStamp;
    4,              // MajorVersion;
    0,              // MinorVersion;
    0,              // GlobalFlagsClear;
    0,              // GlobalFlagsSet;
    0,              // CriticalSectionDefaultTimeout;
    0,              // DeCommitFreeBlockThreshold;
    0,              // DeCommitTotalFreeThreshold;
    0,              // LockPrefixTable;
    0,              // MaximumAllocationSize;
    0,              // VirtualMemoryThreshold;
    0,              // ProcessHeapFlags;
    0,              // ProcessAffinityMask;
    0, 0, 0         // Reserved[ 3 ];
};

#endif


struct {
    DWORD Flag;
    LPSTR ClearPrefix;
    LPSTR SetPrefix;
    LPSTR Description;
} NtGlobalFlagNames[] = {
    {FLG_STOP_ON_EXCEPTION,             "Don't ", "", "Stop on exception"},
    {FLG_SHOW_LDR_SNAPS,                "Don't ", "", "Show Loader Debugging Information"},
    {FLG_DEBUG_INITIAL_COMMAND,         "Don't ", "", "Debug Initial Command (WINLOGON)"},
    {FLG_STOP_ON_HUNG_GUI,              "Don't ", "", "Stop on Hung GUI"},
    {FLG_HEAP_ENABLE_TAIL_CHECK,        "Disable", "Enable", " Heap Tail Checking"},
    {FLG_HEAP_ENABLE_FREE_CHECK,        "Disable", "Enable", " Heap Free Checking"},
    {FLG_HEAP_VALIDATE_PARAMETERS,      "Disable", "Enable", " Heap Parameter Validation"},
    {FLG_HEAP_VALIDATE_ALL,             "Disable", "Enable", " Heap Validate on Call"},
    {FLG_POOL_ENABLE_TAGGING,           "Disable", "Enable", " Pool Tagging"},
    {FLG_HEAP_ENABLE_TAGGING,           "Disable", "Enable", " Heap Tagging"},
    {FLG_USER_STACK_TRACE_DB,           "Disable", "Enable", " User Mode Stack Backtrace DB (x86 checked only)"},
    {FLG_KERNEL_STACK_TRACE_DB,         "Disable", "Enable", " Kernel Mode Stack Backtrace DB (x86 checked only)"},
    {FLG_MAINTAIN_OBJECT_TYPELIST,      "Don't ", "", "Maintain list of kernel mode objects by type"},
    {FLG_HEAP_ENABLE_TAG_BY_DLL,        "Disable", "Enable", " Heap DLL Tagging"},
    {FLG_ENABLE_CSRDEBUG,               "Disable", "Enable", " Debugging of CSRSS"},
    {FLG_ENABLE_KDEBUG_SYMBOL_LOAD,     "Disable", "Enable", " Kernel Debugger Symbol load"},
    {FLG_DISABLE_PAGE_KERNEL_STACKS,    "Enable", "Disable", " Paging of Kernel Stacks"},
    {FLG_HEAP_DISABLE_COALESCING,       "Enable", "Disable", " Heap Coalescing on Free"},
    {FLG_ENABLE_CLOSE_EXCEPTIONS,       "Disable", "Enable", " Close Exceptions"},
    {FLG_ENABLE_EXCEPTION_LOGGING,      "Disable", "Enable", " Exception Logging"},
    {FLG_ENABLE_HANDLE_TYPE_TAGGING,    "Disable", "Enable", " Handle type tagging"},
    {FLG_HEAP_PAGE_ALLOCS,              "Disable", "Enable", " Heap page allocs"},
    {FLG_DEBUG_INITIAL_COMMAND_EX,      "Disable", "Enable", " Extended debug initial command"},
    {FLG_DISABLE_DBGPRINT,              "Enable",  "Disable"," DbgPrint to debugger"},
    {0, NULL}
};

void
DisplayGlobalFlags(
    LPSTR IndentString,
    DWORD NtGlobalFlags,
    BOOLEAN Set
    )
{
    ULONG i;

    for (i=0; NtGlobalFlagNames[i].Description; i++) {
        if (NtGlobalFlagNames[i].Flag & NtGlobalFlags) {
            printf( "%s%s%s\n",
                    IndentString,
                    Set ? NtGlobalFlagNames[i].SetPrefix :
                    NtGlobalFlagNames[i].ClearPrefix,
                    NtGlobalFlagNames[i].Description
                  );
        }
    }

    return;
}

BOOL fVerbose;
BOOL fUsage;

BOOL fConfigInfoChanged;
BOOL fImageHasConfigInfo;
BOOL fImageHeaderChanged;

LPSTR CurrentImageName;
PIMAGE_OPTIONAL_HEADER32 OptionalHeader32;
PIMAGE_OPTIONAL_HEADER64 OptionalHeader64;
PIMAGE_FILE_HEADER FileHeader;
LOADED_IMAGE CurrentImage;
IMAGE_LOAD_CONFIG_DIRECTORY ConfigInfo;
CHAR DebugFilePath[_MAX_PATH];
LPSTR SymbolPath;
ULONG GlobalFlagsClear;
ULONG GlobalFlagsSet;
ULONG CriticalSectionDefaultTimeout;
ULONG DeCommitFreeBlockThreshold;
ULONG DeCommitTotalFreeThreshold;
ULONG MaximumAllocationSize;
ULONG VirtualMemoryThreshold;
ULONG ProcessHeapFlags;
ULONG MajorSubsystemVersion;
ULONG MinorSubsystemVersion;
ULONG BuildNumber;
ULONG SizeOfStackReserve;
ULONG SizeOfStackCommit;
PULONG pBuildNumber;
ULONG Win32VersionValue;
ULONG Win32CSDVerValue;
BOOLEAN fUniprocessorOnly;
BOOLEAN fRestrictedWorkingSet;
BOOLEAN fEnableLargeAddresses;
BOOLEAN fNoBind;
BOOLEAN fEnableTerminalServerAware;
BOOLEAN fDisableTerminalServerAware;
BOOLEAN fSwapRunNet;
BOOLEAN fSwapRunCD;
BOOLEAN fQuiet;
DWORD ImageProcessAffinityMask;

VOID
DisplayImageInfo(
                BOOL HasConfigInfo
                );

PVOID
GetAddressOfExportedData(
                        PLOADED_IMAGE Dll,
                        LPSTR ExportedName
                        );

ULONG
ConvertNum(
          char *s
          )
{
    ULONG n, Result;

    if (!_strnicmp( s, "0x", 2 )) {
        n = sscanf( s+2, "%x", &Result );
    } else {
        n = sscanf( s, "%u", &Result );
    }

    if (n != 1) {
        return 0;
    } else {
        return Result;
    }
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    UCHAR c;
    LPSTR p, sMajor, sMinor, sReserve, sCommit;
    ULONG HeaderSum;
    SYSTEMTIME SystemTime;
    FILETIME LastWriteTime;
    DWORD OldChecksum;

    fUsage = FALSE;
    fVerbose = FALSE;

    _tzset();

    if (argc <= 1) {
        goto showUsage;
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
                switch (toupper( c )) {
                    case '?':
                        fUsage = TRUE;
                        break;

                    case 'A':
                        if (--argc) {
                            ImageProcessAffinityMask = ConvertNum( *++argv );
                            if (ImageProcessAffinityMask == 0) {
                                fprintf( stderr, "IMAGECFG: invalid affinity mask specified to /a switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /a switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'B':
                        if (--argc) {
                            BuildNumber = ConvertNum( *++argv );
                            if (BuildNumber == 0) {
                                fprintf( stderr, "IMAGECFG: invalid build number specified to /b switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /b switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'C':
                        if (--argc) {
                            if (sscanf( *++argv, "%x", &Win32CSDVerValue ) != 1) {
                                fprintf( stderr, "IMAGECFG: invalid version string specified to /c switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /c switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'D':
                        if (argc >= 2) {
                            argc -= 2;
                            DeCommitFreeBlockThreshold = ConvertNum( *++argv );
                            DeCommitTotalFreeThreshold = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /d switch missing arguments.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'G':
                        if (argc >= 2) {
                            argc -= 2;
                            GlobalFlagsClear = ConvertNum( *++argv );
                            GlobalFlagsSet = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /g switch missing arguments.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'H':
                        if (argc > 2) {

                            INT flag = -1;

                            if (sscanf( *++argv, "%d", &flag ) != 1) {
                                fprintf( stderr, "IMAGECFG: invalid option string specified to /h switch.\n" );
                                fUsage = TRUE;
                            } else {

                                --argc;

                                if (flag == 0) {
                                    fDisableTerminalServerAware = TRUE;
                                } else if (flag == 1) {
                                    fEnableTerminalServerAware = TRUE;
                                } else {
                                    fprintf( stderr, "IMAGECFG: /h switch invalid argument.\n" );
                                    fUsage = TRUE;
                                }

                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /h switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'K':
                        if (--argc) {
                            sReserve = *++argv;
                            sCommit = strchr( sReserve, '.' );
                            if (sCommit != NULL) {
                                *sCommit++ = '\0';
                                SizeOfStackCommit = ConvertNum( sCommit );
                                SizeOfStackCommit = ((SizeOfStackCommit + 0xFFF) & ~0xFFF);
                                if (SizeOfStackCommit == 0) {
                                    fprintf( stderr, "IMAGECFG: invalid stack commit size specified to /k switch.\n" );
                                    fUsage = TRUE;
                                }
                            }

                            SizeOfStackReserve = ConvertNum( sReserve );
                            SizeOfStackReserve = ((SizeOfStackReserve + 0xFFFF) & ~0xFFFF);
                            if (SizeOfStackReserve == 0) {
                                fprintf( stderr, "IMAGECFG: invalid stack reserve size specified to /k switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /w switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'L':
                        fEnableLargeAddresses = TRUE;
                        break;

                    case 'M':
                        if (--argc) {
                            MaximumAllocationSize = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /m switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'N':
                        fNoBind = TRUE;
                        break;

                    case 'O':
                        if (--argc) {
                            CriticalSectionDefaultTimeout = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /o switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'P':
                        if (--argc) {
                            ProcessHeapFlags = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /p switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'Q':
                        fQuiet = TRUE;
                        break;

                    case 'R':
                        fRestrictedWorkingSet = TRUE;
                        break;

                    case 'S':
                        if (--argc) {
                            SymbolPath = *++argv;
                        } else {
                            fprintf( stderr, "IMAGECFG: /s switch missing path argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'T':
                        if (--argc) {
                            VirtualMemoryThreshold = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /t switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'U':
                        fUniprocessorOnly = TRUE;
                        break;

                    case 'V':
                        if (--argc) {
                            sMajor = *++argv;
                            sMinor = strchr( sMajor, '.' );
                            if (sMinor != NULL) {
                                *sMinor++ = '\0';
                                MinorSubsystemVersion = ConvertNum( sMinor );
                            }
                            MajorSubsystemVersion = ConvertNum( sMajor );

                            if (MajorSubsystemVersion == 0) {
                                fprintf( stderr, "IMAGECFG: invalid version string specified to /v switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /v switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'W':
                        if (--argc) {
                            if (sscanf( *++argv, "%x", &Win32VersionValue ) != 1) {
                                fprintf( stderr, "IMAGECFG: invalid version string specified to /w switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /w switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'X':
                        fSwapRunNet = TRUE;
                        break;

                    case 'Y':
                        fSwapRunCD = TRUE;
                        break;

                    default:
                        fprintf( stderr, "IMAGECFG: Invalid switch - /%c\n", c );
                        fUsage = TRUE;
                        break;
                }

            if ( fUsage ) {
                showUsage:
                fprintf( stderr,
                         "usage: IMAGECFG [switches] image-names... \n"
                         "              [-?] display this message\n"
                         "              [-a Process Affinity mask value in hex]\n"
                         "              [-b BuildNumber]\n"
                         "              [-c Win32 GetVersionEx Service Pack return value in hex]\n"
                         "              [-d decommit thresholds]\n"
                         "              [-g bitsToClear bitsToSet]\n"
                         "              [-h 1|0 (Enable/Disable Terminal Server Compatible bit)\n"
                         "              [-k StackReserve[.StackCommit]\n"
                         "              [-l enable large (>2GB) addresses\n"
                         "              [-m maximum allocation size]\n"
                         "              [-n bind no longer allowed on this image\n"
                         "              [-o default critical section timeout\n"
                         "              [-p process heap flags]\n"
                         "              [-q only print config info if changed\n"
                         "              [-r run with restricted working set]\n"
                         "              [-s path to symbol files]\n"
                         "              [-t VirtualAlloc threshold]\n"
                         "              [-u Marks image as uniprocessor only]\n"
                         "              [-v MajorVersion.MinorVersion]\n"
                         "              [-w Win32 GetVersion return value in hex]\n"
                         "              [-x Mark image as Net - Run From Swapfile\n"
                         "              [-y Mark image as Removable - Run From Swapfile\n"
                       );
                exit( 1 );
            }
        } else {
            //
            // Map and load the current image
            //

            OptionalHeader32 = NULL;
            OptionalHeader64 = NULL;
            FileHeader = NULL;
            CurrentImageName = p;
            if (MapAndLoad( CurrentImageName,
                            NULL,
                            &CurrentImage,
                            FALSE,
                            TRUE
                          )
               ) {
                if (BuildNumber != 0) {
                    pBuildNumber = (PULONG) GetAddressOfExportedData( &CurrentImage, "NtBuildNumber" );
                    if (pBuildNumber == NULL) {
                        fprintf( stderr,
                                 "IMAGECFG: Unable to find exported NtBuildNumber image %s\n",
                                 CurrentImageName
                               );
                    }
                }

                FileHeader = &((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->FileHeader;
                OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader,
                                             &OptionalHeader32,
                                             &OptionalHeader64);

                //
                // make sure the image has correct configuration information,
                // and that the LockPrefixTable is set up properly
                //

                fConfigInfoChanged = FALSE;
                fImageHeaderChanged = FALSE;
                ZeroMemory(&ConfigInfo, sizeof(ConfigInfo));
                fImageHasConfigInfo = GetImageConfigInformation( &CurrentImage, &ConfigInfo );
                if (!fQuiet) {
                    DisplayImageInfo( fImageHasConfigInfo );
                }
                UnMapAndLoad( &CurrentImage );
                OptionalHeader32 = NULL;
                OptionalHeader64 = NULL;
                FileHeader = NULL;
                if (fConfigInfoChanged || fImageHeaderChanged) {
                    if (!MapAndLoad( CurrentImageName,
                                     NULL,
                                     &CurrentImage,
                                     FALSE,
                                     FALSE
                                   )
                       ) {
                        if (!CurrentImage.fDOSImage) {
                            fprintf( stderr, "IMAGECFG: unable to map and load %s\n", CurrentImageName );
                        } else {
                            fprintf( stderr,
                                     "IMAGECFG: unable to modify DOS or Windows image file - %s\n",
                                     CurrentImageName
                                   );
                        }
                    } else {
                        FileHeader = &((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->FileHeader;

                        OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader,
                                                     &OptionalHeader32,
                                                     &OptionalHeader64);

                        if (GlobalFlagsClear) {
                            ConfigInfo.GlobalFlagsClear = GlobalFlagsClear;
                        }

                        if (GlobalFlagsSet) {
                            ConfigInfo.GlobalFlagsSet = GlobalFlagsSet;
                        }

                        if (CriticalSectionDefaultTimeout) {
                            ConfigInfo.CriticalSectionDefaultTimeout = CriticalSectionDefaultTimeout;
                        }

                        if (ProcessHeapFlags) {
                            ConfigInfo.ProcessHeapFlags = ProcessHeapFlags;
                        }

                        if (DeCommitFreeBlockThreshold) {
                            ConfigInfo.DeCommitFreeBlockThreshold = DeCommitFreeBlockThreshold;
                        }

                        if (DeCommitTotalFreeThreshold) {
                            ConfigInfo.DeCommitTotalFreeThreshold = DeCommitTotalFreeThreshold;
                        }

                        if (MaximumAllocationSize) {
                            ConfigInfo.MaximumAllocationSize = MaximumAllocationSize;
                        }

                        if (VirtualMemoryThreshold) {
                            ConfigInfo.VirtualMemoryThreshold = VirtualMemoryThreshold;
                        }

                        if (ImageProcessAffinityMask) {
                            ConfigInfo.ProcessAffinityMask = ImageProcessAffinityMask;
                        }

                        if (fEnableLargeAddresses) {
                            FileHeader->Characteristics |= IMAGE_FILE_LARGE_ADDRESS_AWARE;
                        }

                        if (fNoBind) {
                            OPTIONALHEADER_SET_FLAG(DllCharacteristics,IMAGE_DLLCHARACTERISTICS_NO_BIND);
                        }

                        if (fEnableTerminalServerAware) {
                            OPTIONALHEADER_SET_FLAG(DllCharacteristics,IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE);
                        }

                        if (fDisableTerminalServerAware) {
                            OPTIONALHEADER_CLEAR_FLAG(DllCharacteristics,IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE);
                        }

                        if (fSwapRunNet) {
                            FileHeader->Characteristics |= IMAGE_FILE_NET_RUN_FROM_SWAP;
                        }

                        if (fSwapRunCD) {
                            FileHeader->Characteristics |= IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP;
                        }

                        if (fUniprocessorOnly) {
                            FileHeader->Characteristics |= IMAGE_FILE_UP_SYSTEM_ONLY;
                        }

                        if (fRestrictedWorkingSet) {
                            FileHeader->Characteristics |= IMAGE_FILE_AGGRESIVE_WS_TRIM;
                        }

                        if (MajorSubsystemVersion != 0) {
                            OPTIONALHEADER_ASSIGN(MajorSubsystemVersion, (USHORT)MajorSubsystemVersion);
                            OPTIONALHEADER_ASSIGN(MinorSubsystemVersion, (USHORT)MinorSubsystemVersion);
                        }

                        if (Win32VersionValue != 0) {
                            OPTIONALHEADER_ASSIGN(Win32VersionValue, Win32VersionValue);
                        }

                        if (Win32CSDVerValue != 0) {
                            ConfigInfo.CSDVersion = (USHORT)Win32CSDVerValue;
                        }

                        if (SizeOfStackReserve) {
                            OPTIONALHEADER_ASSIGN(SizeOfStackReserve, SizeOfStackReserve);
                        }

                        if (SizeOfStackCommit) {
                            OPTIONALHEADER_ASSIGN(SizeOfStackCommit, SizeOfStackCommit);
                        }

                        if (BuildNumber != 0) {
                            pBuildNumber = (PULONG) GetAddressOfExportedData( &CurrentImage, "NtBuildNumber" );
                            if (pBuildNumber == NULL) {
                                fprintf( stderr,
                                         "IMAGECFG: Unable to find exported NtBuildNumber image %s\n",
                                         CurrentImageName
                                       );
                            } else {
                                if (BuildNumber & 0xFFFF0000) {
                                    *pBuildNumber = BuildNumber;
                                } else {
                                    *(PUSHORT)pBuildNumber = (USHORT)BuildNumber;
                                }
                            }
                        }

                        if (fConfigInfoChanged) {
                            if (SetImageConfigInformation( &CurrentImage, &ConfigInfo )) {
                                if (!fQuiet) {
                                    printf( "%s updated with the following configuration information:\n", CurrentImageName );
                                    DisplayImageInfo( fImageHasConfigInfo );
                                }
                            } else {
                                fprintf( stderr, "IMAGECFG: Unable to update configuration information in image.\n" );

                            }
                        }

                        //
                        // recompute the checksum.
                        //

                        OldChecksum = OPTIONALHEADER(CheckSum);
                        OPTIONALHEADER_LV(CheckSum) = 0;
                        CheckSumMappedFile(
                                          (PVOID)CurrentImage.MappedAddress,
                                          CurrentImage.SizeOfImage,
                                          &HeaderSum,
                                          &OPTIONALHEADER_LV(CheckSum)
                                          );

                        // And update the .dbg file (if requested)
                        if (SymbolPath &&
                            FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
                            if (UpdateDebugInfoFileEx( CurrentImageName,
                                                       SymbolPath,
                                                       DebugFilePath,
                                                       (PIMAGE_NT_HEADERS32)CurrentImage.FileHeader,
                                                       OldChecksum
                                                     )
                               ) {
                                if (GetLastError() == ERROR_INVALID_DATA) {
                                    printf( "Warning: Old checksum did not match for %s\n", DebugFilePath);
                                }
                                printf( "Updated symbols for %s\n", DebugFilePath );
                            } else {
                                printf( "Unable to update symbols: %s\n", DebugFilePath );
                            }
                        }

                        GetSystemTime( &SystemTime );
                        if (SystemTimeToFileTime( &SystemTime, &LastWriteTime )) {
                            SetFileTime( CurrentImage.hFile, NULL, NULL, &LastWriteTime );
                        }

                        UnMapAndLoad( &CurrentImage );
                    }
                }
            } else
                if (!CurrentImage.fDOSImage) {
                fprintf( stderr, "IMAGECFG: unable to map and load %s  GetLastError= %d\n", CurrentImageName, GetLastError() );

            } else {
                fprintf( stderr,
                         "IMAGECFG: unable to modify DOS or Windows image file - %s\n",
                         CurrentImageName
                       );
            }
        }
    }

    exit( 1 );
    return 1;
}

__inline PVOID
GetVaForRva(
           PLOADED_IMAGE Image,
           ULONG Rva
           )
{
    PVOID Va;

    Va = ImageRvaToVa( Image->FileHeader,
                       Image->MappedAddress,
                       Rva,
                       &Image->LastRvaSection
                     );
    return Va;
}


PVOID
GetAddressOfExportedData(
                        PLOADED_IMAGE Dll,
                        LPSTR ExportedName
                        )
{
    PIMAGE_EXPORT_DIRECTORY Exports;
    ULONG ExportSize;
    USHORT HintIndex;
    USHORT OrdinalNumber;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG FunctionTableBase;
    LPSTR NameTableName;

    Exports = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData( (PVOID)Dll->MappedAddress,
                                                                  FALSE,
                                                                  IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                                  &ExportSize
                                                                );
    if (Exports) {
        NameTableBase = (PULONG)GetVaForRva( Dll, Exports->AddressOfNames );
        NameOrdinalTableBase = (PUSHORT)GetVaForRva( Dll, Exports->AddressOfNameOrdinals );
        FunctionTableBase = (PULONG)GetVaForRva( Dll, Exports->AddressOfFunctions );
        if (NameTableBase != NULL &&
            NameOrdinalTableBase != NULL &&
            FunctionTableBase != NULL
           ) {
            for (HintIndex = 0; HintIndex < Exports->NumberOfNames; HintIndex++) {
                NameTableName = (LPSTR)GetVaForRva( Dll, NameTableBase[ HintIndex ] );
                if (NameTableName) {
                    if (!strcmp( ExportedName, NameTableName )) {
                        OrdinalNumber = NameOrdinalTableBase[ HintIndex ];
                        return FunctionTableBase[ OrdinalNumber ] + Dll->MappedAddress;
                    }
                }
            }
        }
    }

    return NULL;
}


VOID
DisplayImageInfo(
                BOOL HasConfigInfo
                )
{
    printf( "%s contains the following configuration information:\n", CurrentImageName );
//    if (HasConfigInfo) {
        if (ConfigInfo.GlobalFlagsClear != 0) {
            printf( "    NtGlobalFlags to clear: %08x\n",
                    ConfigInfo.GlobalFlagsClear
                  );
            DisplayGlobalFlags( "        ", ConfigInfo.GlobalFlagsClear, FALSE );
        }
        if (GlobalFlagsClear && ConfigInfo.GlobalFlagsClear != GlobalFlagsClear) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.GlobalFlagsSet != 0) {
            printf( "    NtGlobalFlags to set:   %08x\n",
                    ConfigInfo.GlobalFlagsSet
                  );
            DisplayGlobalFlags( "        ", ConfigInfo.GlobalFlagsSet, TRUE );
        }
        if (GlobalFlagsSet && ConfigInfo.GlobalFlagsSet != GlobalFlagsSet) {
            fConfigInfoChanged = TRUE;
        }


        if (ConfigInfo.CriticalSectionDefaultTimeout != 0) {
            printf( "    Default Critical Section Timeout: %u milliseconds\n",
                    ConfigInfo.CriticalSectionDefaultTimeout
                  );
        }
        if (CriticalSectionDefaultTimeout &&
            ConfigInfo.CriticalSectionDefaultTimeout != CriticalSectionDefaultTimeout
           ) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.ProcessHeapFlags != 0) {
            printf( "    Process Heap Flags: %08x\n",
                    ConfigInfo.ProcessHeapFlags
                  );
        }
        if (ProcessHeapFlags && ConfigInfo.ProcessHeapFlags != ProcessHeapFlags) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.DeCommitFreeBlockThreshold != 0) {
            printf( "    Process Heap DeCommit Free Block threshold: %08x\n",
                    ConfigInfo.DeCommitFreeBlockThreshold
                  );
        }
        if (DeCommitFreeBlockThreshold &&
            ConfigInfo.DeCommitFreeBlockThreshold != DeCommitFreeBlockThreshold
           ) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.DeCommitTotalFreeThreshold != 0) {
            printf( "    Process Heap DeCommit Total Free threshold: %08x\n",
                    ConfigInfo.DeCommitTotalFreeThreshold
                  );
        }
        if (DeCommitTotalFreeThreshold &&
            ConfigInfo.DeCommitTotalFreeThreshold != DeCommitTotalFreeThreshold
           ) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.MaximumAllocationSize != 0) {
            printf( "    Process Heap Maximum Allocation Size: %08x\n",
                    ConfigInfo.MaximumAllocationSize
                  );
        }
        if (MaximumAllocationSize && ConfigInfo.MaximumAllocationSize != MaximumAllocationSize) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.VirtualMemoryThreshold != 0) {
            printf( "    Process Heap VirtualAlloc Threshold: %08x\n",
                    ConfigInfo.VirtualMemoryThreshold
                  );
        }
        if (VirtualMemoryThreshold &&
            ConfigInfo.VirtualMemoryThreshold != VirtualMemoryThreshold
           ) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.ProcessAffinityMask != 0) {
            printf( "    Process Affinity Mask: %08x\n",
                    ConfigInfo.ProcessAffinityMask
                  );
        }
        if (ImageProcessAffinityMask &&
            ConfigInfo.ProcessAffinityMask != ImageProcessAffinityMask
           ) {
            fConfigInfoChanged = TRUE;
        }
//    } else {
//        memset( &ConfigInfo, 0, sizeof( ConfigInfo ) );
//    }

    printf( "    Subsystem Version of %u.%u\n",
            OPTIONALHEADER(MajorSubsystemVersion),
            OPTIONALHEADER(MinorSubsystemVersion)
          );
    if (MajorSubsystemVersion != 0) {
        if (OPTIONALHEADER(MajorSubsystemVersion) != (USHORT)MajorSubsystemVersion ||
            OPTIONALHEADER(MinorSubsystemVersion) != (USHORT)MinorSubsystemVersion
           ) {
            fImageHeaderChanged = TRUE;
        }
    }

    if (pBuildNumber != NULL) {
        printf( "    Build Number of %08x\n", *pBuildNumber );
        if (BuildNumber != 0) {
            if (BuildNumber & 0xFFFF0000) {
                if (*pBuildNumber != BuildNumber) {
                    fImageHeaderChanged = TRUE;
                }
            } else {
                if (*(PUSHORT)pBuildNumber != (USHORT)BuildNumber) {
                    fImageHeaderChanged = TRUE;
                }
            }
        }
    }

    if (OPTIONALHEADER(Win32VersionValue) != 0) {
        printf( "    Win32 GetVersion return value: %08x\n",
                OPTIONALHEADER(Win32VersionValue)
              );
    }
    if (Win32VersionValue != 0 &&
        OPTIONALHEADER(Win32VersionValue) != Win32VersionValue
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (FileHeader->Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE) {
        printf( "    Image can handle large (>2GB) addresses\n" );
    }

    if (OPTIONALHEADER(DllCharacteristics) & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE) {
        printf( "    Image is Terminal Server aware\n" );
    }

    if (fEnableLargeAddresses &&
        !(FileHeader->Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE)
       ) {
        fImageHeaderChanged = TRUE;
        printf( "    Image is Large Address aware\n" );
    }

    if (fNoBind) {
        fImageHeaderChanged = TRUE;
        printf( "    Image will no longer support binding\n" );
    }

    if (fEnableTerminalServerAware || fDisableTerminalServerAware) {
        printf( "    Image %s Terminal Server Aware\n", fEnableTerminalServerAware ? "is" : "is not");
        fImageHeaderChanged = TRUE;
    }

    if (FileHeader->Characteristics & IMAGE_FILE_NET_RUN_FROM_SWAP) {
        printf( "    Image will run from swapfile if located on net\n" );
    }
    if (fSwapRunNet &&
        !(FileHeader->Characteristics & IMAGE_FILE_NET_RUN_FROM_SWAP)
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (FileHeader->Characteristics & IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP) {
        printf( "    Image will run from swapfile if located on removable media\n" );
    }
    if (fSwapRunCD &&
        !(FileHeader->Characteristics & IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP)
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (FileHeader->Characteristics & IMAGE_FILE_UP_SYSTEM_ONLY) {
        printf( "    Image can only run in uni-processor mode on multi-processor systems\n" );
    }
    if (fUniprocessorOnly &&
        !(FileHeader->Characteristics & IMAGE_FILE_UP_SYSTEM_ONLY)
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (FileHeader->Characteristics & IMAGE_FILE_AGGRESIVE_WS_TRIM) {
        printf( "    Image working set trimmed aggressively on small memory systems\n" );
    }
    if (fRestrictedWorkingSet &&
        !(FileHeader->Characteristics & IMAGE_FILE_AGGRESIVE_WS_TRIM)
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (OPTIONALHEADER(SizeOfStackReserve)) {
        printf( "    Stack Reserve Size: 0x%x\n", OPTIONALHEADER(SizeOfStackReserve) );
    }
    if (SizeOfStackReserve &&
        OPTIONALHEADER(SizeOfStackReserve) != SizeOfStackReserve
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (OPTIONALHEADER(SizeOfStackCommit)) {
        printf( "    Stack Commit Size: 0x%x\n", OPTIONALHEADER(SizeOfStackCommit) );
    }
    if (SizeOfStackCommit &&
        OPTIONALHEADER(SizeOfStackCommit) != SizeOfStackCommit
       ) {
        fImageHeaderChanged = TRUE;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\fecache.c ===
//----------------------------------------------------------------------------
//
// Function entry cache.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntimage.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>
#include "private.h"
#include "symbols.h"
#include "globals.h"

#include "fecache.hpp"

//----------------------------------------------------------------------------
//
// FunctionEntryCache.
//
//----------------------------------------------------------------------------

FunctionEntryCache::FunctionEntryCache(ULONG ImageDataSize,
                                       ULONG CacheDataSize,
                                       ULONG Machine)
{
    m_ImageDataSize = ImageDataSize;
    m_CacheDataSize = CacheDataSize;
    m_Machine = Machine;

    m_Entries = NULL;
}

FunctionEntryCache::~FunctionEntryCache(void)
{
    if (m_Entries != NULL)
    {
        MemFree(m_Entries);
    }
}

BOOL
FunctionEntryCache::Initialize(ULONG MaxEntries, ULONG ReplaceAt)
{
    // Already initialized.
    if (m_Entries != NULL) {
        return TRUE;
    }
    
    m_Entries = (FeCacheEntry*)MemAlloc(sizeof(FeCacheEntry) * MaxEntries);
    if (m_Entries == NULL) {
        return FALSE;
    }

    m_MaxEntries = MaxEntries;
    m_ReplaceAt = ReplaceAt;

    m_Used = 0;
    m_Next = 0;

    return TRUE;
}

FeCacheEntry*
FunctionEntryCache::Find(
    HANDLE                           Process,
    ULONG64                          CodeOffset,
    PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
    PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
    )
{
    FeCacheEntry* FunctionEntry;

    FE_DEBUG(("\nFunctionEntryCache::Find(ControlPc=%.8I64x, Machine=%X)\n",
              CodeOffset, m_Machine));

    // Look for a static or dynamic function entry.
    FunctionEntry = FindDirect( Process, CodeOffset, ReadMemory,
                                GetModuleBase, GetFunctionEntry );
    if (FunctionEntry == NULL) {
        return NULL;
    }

    //
    // The capability exists for more than one function entry
    // to map to the same function. This permits a function to
    // have discontiguous code segments described by separate
    // function table entries. If the ending prologue address
    // is not within the limits of the begining and ending
    // address of the function table entry, then the prologue
    // ending address is the address of the primary function
    // table entry that accurately describes the ending prologue
    // address.
    //

    FunctionEntry = SearchForPrimaryEntry(FunctionEntry, Process, ReadMemory,
                                          GetModuleBase, GetFunctionEntry);

#if DBG
    if (tlsvar(DebugFunctionEntries)) {
        if (FunctionEntry == NULL) {
            dbPrint("FunctionEntryCache::Find returning NULL\n");
        } else {
            if (FunctionEntry->Address) {
                dbPrint("FunctionEntryCache::Find returning "
                        "FunctionEntry=%.8I64x %s\n",
                        FunctionEntry->Address,
                        FunctionEntry->Description);
            } else {
                dbPrint("FunctionEntryCache::Find returning "
                        "FunctionEntry=%.8I64x %s\n",
                        (ULONG64)(LONG64)(LONG_PTR)FunctionEntry,
                        FunctionEntry->Description);
            }
        }
    }
#endif

    return FunctionEntry;
}

FeCacheEntry*
FunctionEntryCache::FindDirect(
    HANDLE                           Process,
    ULONG64                          CodeOffset,
    PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
    PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
    )
{
    FeCacheEntry* FunctionEntry;
    ULONG64 ModuleBase;

    //
    // Look for function entry in static function tables.
    //

    FunctionEntry = FindStatic( Process, CodeOffset, ReadMemory,
                                GetModuleBase, GetFunctionEntry,
                                &ModuleBase );

    FE_DEBUG(("  FindDirect: ControlPc=0x%I64x functionEntry=0x%p\n"
              "  FindStatic  %s\n", CodeOffset, FunctionEntry, 
              FunctionEntry != NULL ? "succeeded" : "FAILED"));

    if (FunctionEntry != NULL) {
        return FunctionEntry;
    }

    //
    // If not in static image range and no static function entry
    // found use FunctionEntryCallback routine (if present) for
    // dynamic function entry or some other source of pdata (e.g.
    // saved pdata information for ROM images).
    //

    PPROCESS_ENTRY ProcessEntry = FindProcessEntry( Process );
    if (ProcessEntry == NULL) {
        return NULL;
    }

    PVOID RawEntry;
    
    if (!ModuleBase) {
        if (!IsImageMachineType64(m_Machine) &&
            ProcessEntry->pFunctionEntryCallback32) {
            RawEntry = ProcessEntry->pFunctionEntryCallback32
                (Process, (ULONG)CodeOffset,
                 (PVOID)ProcessEntry->FunctionEntryUserContext);
            if (RawEntry) {
                IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY Ent64;
                
                // This currently only happens for Axp32 so
                // upconvert.
                ConvertAlphaRf32To64
                    ((PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)RawEntry, &Ent64);
                FunctionEntry = FillTemporary(Process, &Ent64);
                FE_SET_DESC(FunctionEntry, "from FunctionEntryCallback32");
            }
        } else if (ProcessEntry->pFunctionEntryCallback64) {
            RawEntry = ProcessEntry->pFunctionEntryCallback64
                (Process, CodeOffset, ProcessEntry->FunctionEntryUserContext);
            if (RawEntry != NULL) {
                FunctionEntry = FillTemporary(Process, RawEntry);
                FE_SET_DESC(FunctionEntry, "from FunctionEntryCallback64");
            }
        }

        if (FunctionEntry != NULL) {
            FE_DEBUG(("  FindDirect: got dynamic entry\n"));
        } else if (GetFunctionEntry != NULL) {
                
            // VC 6 didn't supply a GetModuleBase callback so this code is
            // to make stack walking backward compatible.
            //
            // If we don't have a function by now, use the old-style function
            // entry callback and let VC give it to us. Note that MSDN
            // documentation indicates that this callback should return
            // a 3-field IMAGE_FUNCTION_ENTRY structure, but VC 6 actually
            // returns the 5-field IMAGE_RUNTIME_FUNCTION_ENTRY. Since
            // the purpose of this hack is to make VC 6 work just go with the
            // way VC 6 does it rather than what MSDN says.

            RawEntry = GetFunctionEntry(Process, CodeOffset);
            if (RawEntry != NULL) {
                FunctionEntry = FillTemporary(Process, RawEntry);
                FE_SET_DESC(FunctionEntry, "from GetFunctionEntry");
                FE_DEBUG(("  FindDirect: got user entry\n"));
            }
        }
    } else {

        // Nothing has turned up a function entry but we do have a
        // module base address. One possibility is that this is the
        // kernel debugger and the pdata section is not paged in.
        // The last ditch attempt for a function entry will be an
        // internal dbghelp call to get the pdata entry from the
        // debug info. This is not great because the data in the debug
        // section is incomplete and potentially out of date, but in
        // most cases it works and makes it possible to get user-mode
        // stack traces in the kernel debugger.

        PIMGHLP_RVA_FUNCTION_DATA RvaEntry =
            GetFunctionEntryFromDebugInfo( ProcessEntry, CodeOffset );
        if (RvaEntry != NULL) {
            FeCacheData Data;

            TranslateRvaDataToRawData(RvaEntry, ModuleBase, &Data);
            FunctionEntry = FillTemporary(Process, &Data);
            FE_SET_DESC(FunctionEntry, "from GetFunctionEntryFromDebugInfo");
            FE_DEBUG(("  FindDirect: got debug info entry\n"));
        }
    }

    return FunctionEntry;
}

FeCacheEntry*
FunctionEntryCache::FindStatic(
    HANDLE                           Process,
    ULONG64                          CodeOffset,
    PREAD_PROCESS_MEMORY_ROUTINE64   ReadMemory,
    PGET_MODULE_BASE_ROUTINE64       GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry,
    PULONG64                         ModuleBase
    )
{
    ULONG RelCodeOffset;

    *ModuleBase = GetModuleBase( Process, CodeOffset );
    if (CodeOffset - *ModuleBase > 0xffffffff) {
        return NULL;
    }

    RelCodeOffset = (ULONG)(CodeOffset - *ModuleBase);
    
    FE_DEBUG(("  FindStatic: ControlPc=0x%I64x ImageBase=0x%I64x\n"
              "              biasedControlPc=0x%lx\n", 
              CodeOffset, *ModuleBase, RelCodeOffset));

    FeCacheEntry* FunctionEntry;
    ULONG Index;

    //
    // Check the array of recently fetched function entries
    //

    FunctionEntry = m_Entries;
    for (Index = 0; Index < m_Used; Index++) {
        
        if (FunctionEntry->Process == Process &&
            FunctionEntry->ModuleBase == *ModuleBase &&
            RelCodeOffset >= FunctionEntry->RelBegin &&
            RelCodeOffset <  FunctionEntry->RelEnd) {

            FE_DEBUG(("  FindStatic: cache hit - index=%ld\n", Index));
            return FunctionEntry;
        }

        FunctionEntry++;
    }

    //
    // If an image was found that included the specified code, then locate the
    // function table for the image.
    //

    if (*ModuleBase == 0) {
        return NULL;
    }
    
    ULONG64 FunctionTable;
    ULONG SizeOfFunctionTable;
    
    FunctionTable = FunctionTableBase( Process, ReadMemory, *ModuleBase,
                                       &SizeOfFunctionTable );
    if (FunctionTable == NULL) {
        return NULL;
    }

    FE_DEBUG(("  FindStatic: functionTable=0x%I64x "
              "sizeOfFunctionTable=%ld count:%ld\n", 
              FunctionTable, SizeOfFunctionTable,
              SizeOfFunctionTable / m_ImageDataSize));

    LONG High;
    LONG Low;
    LONG Middle;

    //
    // If a function table is located, then search the function table
    // for a function table entry for the specified code offset.
    //

    Low = 0;
    High = (SizeOfFunctionTable / m_ImageDataSize) - 1;

    //
    // Perform binary search on the function table for a function table
    // entry that subsumes the specified code offset.
    //

    while (High >= Low) {

        //
        // Compute next probe index and test entry. If the specified PC
        // is greater than of equal to the beginning address and less
        // than the ending address of the function table entry, then
        // return the address of the function table entry. Otherwise,
        // continue the search.
        //

        Middle = (Low + High) >> 1;

        ULONG64 NextFunctionTableEntry = FunctionTable +
            Middle * m_ImageDataSize;

        //
        // Fetch the function entry and bail if there is an error reading it
        //

        FunctionEntry = ReadImage( Process, NextFunctionTableEntry,
                                   ReadMemory, GetModuleBase );
        if (FunctionEntry == NULL) {
            FE_DEBUG(("  FindStatic: ReadImage "
                      "functionEntryAddress=0x%I64x FAILED\n",
                      NextFunctionTableEntry));
            return NULL;
        }

        if (RelCodeOffset < FunctionEntry->RelBegin) {
            High = Middle - 1;
        } else if (RelCodeOffset >= FunctionEntry->RelEnd) {
            Low = Middle + 1;
        } else {
            return Promote( FunctionEntry );
        }
    }

    return NULL;
}

FeCacheEntry*
FunctionEntryCache::ReadImage(
    HANDLE                         Process,
    ULONG64                        Address,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    PGET_MODULE_BASE_ROUTINE64     GetModuleBase
    )
{
    FeCacheEntry* FunctionEntry;
    ULONG Index;

    // Check the array of recently fetched function entries.

    FunctionEntry = m_Entries;
    for (Index = 0; Index < m_Used; Index++) {
        
        if (FunctionEntry->Process == Process &&
            FunctionEntry->Address == Address ) {
            
            return FunctionEntry;
        }

        FunctionEntry++;
    }

    FeCacheData Data;
    DWORD Done;

    if (!ReadMemory(Process, Address, &Data, m_ImageDataSize, &Done) ||
        Done != m_ImageDataSize) {
        return NULL;
    }
    
    // If not in the cache, replace the entry that m_Next
    // points to. m_Next cycles through the last part of the
    // table and function entries we want to keep are promoted to the first
    // part of the table so they don't get overwritten by new ones being read
    // as part of the binary search through function entry tables.

    if (m_Used < m_MaxEntries) {
        m_Used++;
        m_Next = m_Used;
    } else {
        m_Next++;
        if (m_Next >= m_MaxEntries) {
            m_Next = m_ReplaceAt + 1;
        }
    }

    FunctionEntry = m_Entries + (m_Next - 1);

    FunctionEntry->Data = Data;
    FunctionEntry->Address = Address;
    FunctionEntry->Process = Process;
    FunctionEntry->ModuleBase = GetModuleBase(Process, Address);
    FE_SET_DESC(FunctionEntry, "from target process");

    // Translate after all other information is filled in so
    // the translation routine can use it.
    TranslateRawData(FunctionEntry);

    return FunctionEntry;
}

void
FunctionEntryCache::InvalidateProcessOrModule(HANDLE Process, ULONG64 Base)
{
    FeCacheEntry* FunctionEntry;
    ULONG Index;

    FunctionEntry = m_Entries;
    Index = 0;
    while (Index < m_Used) {
        
        if (FunctionEntry->Process == Process &&
            (Base == 0 || FunctionEntry->ModuleBase == Base)) {

            // Pull the last entry down into this slot
            // to keep things packed.  There's no need
            // to update m_Next as this will open a
            // new slot for use and m_Next will be reset
            // when it is used.
            *FunctionEntry = m_Entries[--m_Used];
        } else {
            Index++;
            FunctionEntry++;
        }
    }
}

FeCacheEntry*
FunctionEntryCache::Promote(FeCacheEntry* Entry)
{
    ULONG Index;
    ULONG Move;

    Index = (ULONG)(Entry - m_Entries);

    // Make sure it's promoted out of the temporary area.
    if (Index >= m_ReplaceAt) {
        Move = Index - (m_ReplaceAt - 3);
    } else {
        Move = ( Index >= 3 ) ? 3 : 1;
    }

    if (Index > Move) {
        FeCacheEntry Temp = *Entry;
        *Entry = m_Entries[Index - Move];
        m_Entries[Index - Move] = Temp;
        Index -= Move;
    }

    return m_Entries + Index;
}

ULONG64
FunctionEntryCache::FunctionTableBase(
    HANDLE                         Process,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    ULONG64                        Base,
    PULONG                         Size
    )
{
    ULONG64 NtHeaders;
    ULONG64 ExceptionDirectoryEntryAddress;
    IMAGE_DATA_DIRECTORY ExceptionData;
    IMAGE_DOS_HEADER DosHeaderData;
    DWORD Done;

    // Read DOS header to calculate the address of the NT header.

    if (!ReadMemory( Process, Base, &DosHeaderData, sizeof(DosHeaderData),
                     &Done ) ||
        Done != sizeof(DosHeaderData)) {
        return 0;
    }
    if (DosHeaderData.e_magic != IMAGE_DOS_SIGNATURE) {
        return 0;
    }

    NtHeaders = Base + DosHeaderData.e_lfanew;

    if (IsImageMachineType64(m_Machine)) {
        ExceptionDirectoryEntryAddress = NtHeaders +
            FIELD_OFFSET(IMAGE_NT_HEADERS64,OptionalHeader) +
            FIELD_OFFSET(IMAGE_OPTIONAL_HEADER64,DataDirectory) +
            IMAGE_DIRECTORY_ENTRY_EXCEPTION * sizeof(IMAGE_DATA_DIRECTORY);
    } else {
        ExceptionDirectoryEntryAddress = NtHeaders +
            FIELD_OFFSET(IMAGE_NT_HEADERS32,OptionalHeader) +
            FIELD_OFFSET(IMAGE_OPTIONAL_HEADER32,DataDirectory) +
            IMAGE_DIRECTORY_ENTRY_EXCEPTION * sizeof(IMAGE_DATA_DIRECTORY);
    }

    // Read NT header to get the image data directory.

    if (!ReadMemory( Process, ExceptionDirectoryEntryAddress, &ExceptionData,
                     sizeof(IMAGE_DATA_DIRECTORY), &Done ) ||
        Done != sizeof(IMAGE_DATA_DIRECTORY)) {
        return 0;
    }

    *Size = ExceptionData.Size;
    return Base + ExceptionData.VirtualAddress;

}

FeCacheEntry*
FunctionEntryCache::SearchForPrimaryEntry(
    FeCacheEntry* CacheEntry,
    HANDLE Process,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    PGET_MODULE_BASE_ROUTINE64 GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
    )
{
    // Assume all entries are primary.
    return CacheEntry;
}

//----------------------------------------------------------------------------
//
// Ia64FunctionEntryCache.
//
//----------------------------------------------------------------------------

void
Ia64FunctionEntryCache::TranslateRawData(FeCacheEntry* Entry)
{
    Entry->RelBegin = Entry->Data.Ia64.BeginAddress & ~15;
    Entry->RelEnd = (Entry->Data.Ia64.EndAddress + 15) & ~15;
}

void
Ia64FunctionEntryCache::TranslateRvaDataToRawData
    (PIMGHLP_RVA_FUNCTION_DATA RvaData, ULONG64 ModuleBase,
     FeCacheData* Data)
{
    Data->Ia64.BeginAddress = RvaData->rvaBeginAddress;
    Data->Ia64.EndAddress = RvaData->rvaEndAddress;
    Data->Ia64.UnwindInfoAddress = RvaData->rvaPrologEndAddress;
}

#if DBG

void
ShowRuntimeFunctionIa64(
    FeCacheEntry* FunctionEntry,
    PSTR Label
    )
{
    if (!tlsvar(DebugFunctionEntries)) {
        return;
    }
    
    if ( FunctionEntry ) {
        if (FunctionEntry->Address) {
            dbPrint("    0x%I64x: %s\n", FunctionEntry->Address,
                    Label ? Label : "" );
        } 
        else {
            dbPrint("    %s\n", Label ? Label : "" );
        }
        dbPrint("    BeginAddress      = 0x%x\n"
                "    EndAddress        = 0x%x\n"
                "    UnwindInfoAddress = 0x%x\n",
                FunctionEntry->Data.Ia64.BeginAddress,
                FunctionEntry->Data.Ia64.EndAddress,
                FunctionEntry->Data.Ia64.UnwindInfoAddress );    
    }
    else {
        dbPrint("   FunctionEntry NULL: %s\n", Label ? Label : "" );
    }
}

#endif // #if DBG

//----------------------------------------------------------------------------
//
// Amd64FunctionEntryCache.
//
//----------------------------------------------------------------------------

void
Amd64FunctionEntryCache::TranslateRawData(FeCacheEntry* Entry)
{
    Entry->RelBegin = Entry->Data.Amd64.BeginAddress;
    Entry->RelEnd = Entry->Data.Amd64.EndAddress;
}

void
Amd64FunctionEntryCache::TranslateRvaDataToRawData
    (PIMGHLP_RVA_FUNCTION_DATA RvaData, ULONG64 ModuleBase,
     FeCacheData* Data)
{
    Data->Amd64.BeginAddress = RvaData->rvaBeginAddress;
    Data->Amd64.EndAddress = RvaData->rvaEndAddress;
    Data->Amd64.UnwindInfoAddress = RvaData->rvaPrologEndAddress;
}

//----------------------------------------------------------------------------
//
// AlphaFunctionEntryCache.
//
//----------------------------------------------------------------------------

void
AlphaFunctionEntryCache::TranslateRvaDataToRawData
    (PIMGHLP_RVA_FUNCTION_DATA RvaData, ULONG64 ModuleBase,
     FeCacheData* Data)
{
    Data->Axp64.BeginAddress = ModuleBase + RvaData->rvaBeginAddress;
    Data->Axp64.EndAddress = ModuleBase + RvaData->rvaEndAddress;
    Data->Axp64.ExceptionHandler = 0;
    Data->Axp64.HandlerData = 0;
    Data->Axp64.PrologEndAddress = ModuleBase + RvaData->rvaPrologEndAddress;
}

FeCacheEntry*
AlphaFunctionEntryCache::SearchForPrimaryEntry(
    FeCacheEntry* CacheEntry,
    HANDLE Process,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    PGET_MODULE_BASE_ROUTINE64 GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64 GetFunctionEntry
    )
{
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY FunctionEntry =
        &CacheEntry->Data.Axp64;
    
    if ((ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) <
         ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
        (ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) >=
         ALPHA_RF_END_ADDRESS(FunctionEntry))) {
        
        FE_ShowRuntimeFunctionAxp64
            ((CacheEntry, "SearchForPrimaryEntry: secondary entry"));
        
        // Officially the PrologEndAddress field in secondary function entries
        // doesn't have the exception mode bits there have been some versions
        // of alpha tools that put them there. Strip them off to be safe.
        
        CacheEntry = ReadImage( Process,
                                ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry),
                                ReadMemory, GetModuleBase );
        if (!CacheEntry) {
            return NULL;
        }

        CacheEntry = Promote( CacheEntry );

    } else if (ALPHA_RF_IS_FIXED_RETURN(FunctionEntry)) {
        ULONG64 FixedReturn = ALPHA_RF_FIXED_RETURN64(FunctionEntry);

        FE_ShowRuntimeFunctionAxp64
            ((CacheEntry, "SearchForPrimaryEntry: fixed return entry"));
        
        // Recursively call Find to ensure we get a
        // primary function entry here.
        // Check for incorrectly formed function entry where the fixed
        // return points to itself.
        
        if ((FixedReturn <  ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
            (FixedReturn >= ALPHA_RF_END_ADDRESS(FunctionEntry))) {
            CacheEntry = Find( Process, ALPHA_RF_FIXED_RETURN64(FunctionEntry),
                               ReadMemory, GetModuleBase, GetFunctionEntry );
        }
    }
    
    FE_ShowRuntimeFunctionAxp64
        ((CacheEntry, "SearchForPrimaryEntry: primary entry"));

    return CacheEntry;
}

void
ConvertAlphaRf32To64(
    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY rf32,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY rf64
    )
{
    rf64->BeginAddress     = (ULONG64)(LONG64)(LONG)rf32->BeginAddress;
    rf64->EndAddress       = (ULONG64)(LONG64)(LONG)rf32->EndAddress;
    rf64->ExceptionHandler = (ULONG64)(LONG64)(LONG)rf32->ExceptionHandler;
    rf64->HandlerData      = (ULONG64)(LONG64)(LONG)rf32->HandlerData;
    rf64->PrologEndAddress = (ULONG64)(LONG64)(LONG)rf32->PrologEndAddress;
}

#if DBG

#define MAXENTRYTYPE 2
const char *EntryTypeName[] = {
    "ALPHA_RF_NOT_CONTIGUOUS", // 0
    "ALPHA_RF_ALT_ENT_PROLOG", // 1
    "ALPHA_RF_NULL_CONTEXT",   // 2
    "***INVALID***"
};

void
ShowRuntimeFunctionAxp64(
    FeCacheEntry* FunctionEntry,
    PSTR Label
    )
{
    BOOL Secondary = FALSE;
    BOOL FixedReturn = FALSE;
    ULONG EntryType = 0;
    ULONG NullCount = 0;

    if (tlsvar(DebugFunctionEntries)) {
        if (FunctionEntry != NULL && FunctionEntry->Address) {
            dbPrint("    %.8I64x: ", FunctionEntry->Address );
        } else {
            dbPrint("    ");
        }
        if (Label) {
            dbPrint(Label);
        }
        dbPrint("\n");
        if (FunctionEntry) {
            PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY Axp64 =
                &FunctionEntry->Data.Axp64;
            if ((ALPHA_RF_PROLOG_END_ADDRESS(Axp64) <
                 ALPHA_RF_BEGIN_ADDRESS(Axp64)) ||
                (ALPHA_RF_PROLOG_END_ADDRESS(Axp64) >
                 ALPHA_RF_END_ADDRESS(Axp64))) {
                Secondary = TRUE;
                EntryType = ALPHA_RF_ENTRY_TYPE(Axp64);
                if (EntryType > MAXENTRYTYPE) {
                    EntryType = MAXENTRYTYPE;
                }
            } else if (ALPHA_RF_IS_FIXED_RETURN(Axp64)) {
                FixedReturn = TRUE;
            }
            NullCount = ALPHA_RF_NULL_CONTEXT_COUNT(Axp64);

            dbPrint("    BeginAddress     = %16.8I64x\n", Axp64->BeginAddress);
            dbPrint("    EndAddress       = %16.8I64x", Axp64->EndAddress);
            if (NullCount) {
                dbPrint(" %d null-context instructions", NullCount);
            }
            dbPrint("\n");
            dbPrint("    ExceptionHandler = %16.8I64x",
                    Axp64->ExceptionHandler);
            if (Axp64->ExceptionHandler != 0) {
                if (Secondary) {
                    ULONG64 AlternateProlog = ALPHA_RF_ALT_PROLOG64(Axp64);

                    switch( EntryType ) {
                    case ALPHA_RF_NOT_CONTIGUOUS:
                    case ALPHA_RF_ALT_ENT_PROLOG:

                        if ((AlternateProlog >=
                             ALPHA_RF_BEGIN_ADDRESS(Axp64)) &&
                            (AlternateProlog <= Axp64->EndAddress)) {
                                dbPrint(" alternate PrologEndAddress");
                        }
                        break;
                    case ALPHA_RF_NULL_CONTEXT:
                        dbPrint(" stack adjustment");
                    }
                } else if (FixedReturn) {
                    dbPrint(" fixed return address");
                }
            }
            dbPrint("\n");
            dbPrint("    HandlerData      = %16.8I64x", Axp64->HandlerData);
            if (Secondary) {
                dbPrint(" type %d: %s", EntryType, EntryTypeName[EntryType] );
            }
            dbPrint("\n");
            dbPrint("    PrologEndAddress = %16.8I64x\n",
                    Axp64->PrologEndAddress );
        }
    }
}

#endif // #if DBG

//----------------------------------------------------------------------------
//
// Axp32FunctionEntryCache.
//
//----------------------------------------------------------------------------

void
Axp32FunctionEntryCache::TranslateRawData(FeCacheEntry* Entry)
{
    IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY Ent64;
    
    // Convert to 64-bit so that Alpha function entries are
    // always stored as 64-bit for code commonality.
    ConvertAlphaRf32To64(&Entry->Data.Axp32, &Ent64);
    Entry->Data.Axp64 = Ent64;
    
    Entry->RelBegin = (ULONG)
        (Entry->Data.Axp64.BeginAddress - Entry->ModuleBase);
    Entry->RelEnd = (ULONG)
        (Entry->Data.Axp64.EndAddress - Entry->ModuleBase);
}

//----------------------------------------------------------------------------
//
// Axp64FunctionEntryCache.
//
//----------------------------------------------------------------------------

void
Axp64FunctionEntryCache::TranslateRawData(FeCacheEntry* Entry)
{
    Entry->RelBegin = (ULONG)
        (Entry->Data.Axp64.BeginAddress - Entry->ModuleBase);
    Entry->RelEnd = (ULONG)
        (Entry->Data.Axp64.EndAddress - Entry->ModuleBase);
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

FunctionEntryCache*
GetFeCache(ULONG Machine, BOOL Create)
{
    FunctionEntryCache* Cache;
    
    switch(Machine) {
    case IMAGE_FILE_MACHINE_ALPHA:
        if (tlsvar(Axp32FunctionEntries) == NULL && Create) {
            tlsvar(Axp32FunctionEntries) = new Axp32FunctionEntryCache;
            if (tlsvar(Axp32FunctionEntries) == NULL) {
                return NULL;
            }
        }
        Cache = tlsvar(Axp32FunctionEntries);
        break;
    case IMAGE_FILE_MACHINE_ALPHA64:
        if (tlsvar(Axp64FunctionEntries) == NULL && Create) {
            tlsvar(Axp64FunctionEntries) = new Axp64FunctionEntryCache;
            if (tlsvar(Axp64FunctionEntries) == NULL) {
                return NULL;
            }
        }
        Cache = tlsvar(Axp64FunctionEntries);
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        if (tlsvar(Amd64FunctionEntries) == NULL && Create) {
            tlsvar(Amd64FunctionEntries) = new Amd64FunctionEntryCache;
            if (tlsvar(Amd64FunctionEntries) == NULL) {
                return NULL;
            }
        }
        Cache = tlsvar(Amd64FunctionEntries);
        break;
    case IMAGE_FILE_MACHINE_IA64:
        if (tlsvar(Ia64FunctionEntries) == NULL && Create) {
            tlsvar(Ia64FunctionEntries) = new Ia64FunctionEntryCache;
            if (tlsvar(Ia64FunctionEntries) == NULL) {
                return NULL;
            }
        }
        Cache = tlsvar(Ia64FunctionEntries);
        break;
    default:
        return NULL;
    }

    if (Cache && !Cache->Initialize(60, 40)) {
        return NULL;
    }

    return Cache;
}

void
ClearFeCaches(void)
{
    if (tlsvar(Axp32FunctionEntries)) {
        delete (Axp32FunctionEntryCache*)tlsvar(Axp32FunctionEntries);
        tlsvar(Axp32FunctionEntries) = NULL;
    }
    if (tlsvar(Axp64FunctionEntries)) {
        delete (Axp64FunctionEntryCache*)tlsvar(Axp64FunctionEntries);
        tlsvar(Axp64FunctionEntries) = NULL;
    }
    if (tlsvar(Ia64FunctionEntries)) {
        delete (Ia64FunctionEntryCache*)tlsvar(Ia64FunctionEntries);
        tlsvar(Ia64FunctionEntries) = NULL;
    }
    if (tlsvar(Amd64FunctionEntries)) {
        delete (Amd64FunctionEntryCache*)tlsvar(Amd64FunctionEntries);
        tlsvar(Amd64FunctionEntries) = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\globals.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    globals.c

Abstract:

    This module implements all global variables used in dbghelp.dll

Author:

    Pat Styles (patst) 14-July-2000

Revision History:

--*/

#include <private.h>
#include <symbols.h>
#include <globals.h>

GLOBALS g = 
{
    // HANDLE hinst
    // initialized in DllMain

    0,

    // HANDLE hHeap

    0,

    // DWORD tlsIndex

    (DWORD)-1, 

#ifdef IMAGEHLP_HEAP_DEBUG
    
    // LIST_ENTRY HeapHeader

    {NULL, NULL},

    // ULONG TotalMemory

    0,

    // ULONG TotalAllocs

    0,

#endif

    // OSVERSIONINFO OSVerInfo
    // initialized in DllMain

    {0, 0, 0, 0, 0, ""},

    // API_VERSION ApiVersion

    {
        (VER_PRODUCTVERSION_W >> 8), 
        (VER_PRODUCTVERSION_W & 0xff), 
        API_VERSION_NUMBER, 
        0 
    },           
    
    // API_VERSION AppVersion

    // DON'T UPDATE THE FOLLOWING VERSION NUMBER!!!!
    //
    // If the app does not call ImagehlpApiVersionEx, always assume
    // that it is for NT 4.0.
    
    {4, 0, 5, 0}, 

    // ULONG   MachineType;

    0,

#ifdef BUILD_DBGHELP
    // HINSTANCE hSrv
    
    0,

    // CHAR szSrvName
        
    "", 

    // LPSTR szSrvParams
        
    NULL,

    // PSYMBOLSERVERPROC fnSymbolServer
        
    NULL,

    // PSYMBOLSERVERCLOSEPROC fnSymbolServerClose
    
    NULL,

    // PSYMBOLSERVERSETOPTIONSPROC fnSymbolServerSetOptions
    
    NULL,

    // DWORD cProcessList

    0,
    
    // LIST_ENTRY ProcessList

    {NULL, NULL},

    // BOOL SymInitialized

    FALSE,

    // DWORD SymOptions
         
    SYMOPT_UNDNAME,

    // ULONG LastSymLoadError

    0,

    // char DebugModule[MAX_SYM_NAME + 1];

    "",

    // PREAD_PROCESS_MEMORY_ROUTINE ImagepUserReadMemory32

    NULL,

    // PFUNCTION_TABLE_ACCESS_ROUTINE ImagepUserFunctionTableAccess32

    NULL,

    // PGET_MODULE_BASE_ROUTINE ImagepUserGetModuleBase32

    NULL,

    // PTRANSLATE_ADDRESS_ROUTINE ImagepUserTranslateAddress32
    

    NULL,

#endif
};

#ifdef BUILD_DBGHELP

void 
tlsInit(PTLS ptls)
{
    ZeroMemory(ptls, sizeof(TLS));
}

PTLS 
GetTlsPtr(void)
{
    PTLS ptls = (PTLS)TlsGetValue(g.tlsIndex);
    if (!ptls) {
        ptls = (PTLS)MemAlloc(sizeof(TLS));
        if (ptls) {
            TlsSetValue(g.tlsIndex, ptls); 
            tlsInit(ptls);
        }
    }
    
    assert(ptls);

    if (!ptls) {
        static TLS sos_tls;
        ptls = &sos_tls;
    }  

    return ptls;
}

#endif // #ifdef BUILD_DBGHELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\imagedir.c ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    imagedir.c

Abstract:

    The module contains the code to translate an image directory type to
    the address of the data for that entry.

Environment:

    User Mode or Kernel Mode

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>

PVOID
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

PIMAGE_NT_HEADERS
ImageNtHeader (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

{
    return RtlpImageNtHeader( Base );
}


PVOID
ImageDirectoryEntryToDataRom (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL,
    IN PIMAGE_FILE_HEADER FileHeader,
    IN PIMAGE_ROM_OPTIONAL_HEADER OptionalHeader
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    //
    // There's not much we can get from ROM images.  See if the info requested
    // is one of the known ones (debug/exception data)
    //

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                      FileHeader->SizeOfOptionalHeader);

    for (i = 0; i < FileHeader->NumberOfSections; i++, NtSection++) {

        if ( DirectoryEntry == IMAGE_DIRECTORY_ENTRY_DEBUG ) {
            if (!_stricmp((char *)NtSection->Name, ".rdata")) {
                PIMAGE_DEBUG_DIRECTORY DebugDirectory;
                *Size = 0;
                DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)((ULONG_PTR)NtSection->PointerToRawData + (ULONG_PTR)Base);
                while (DebugDirectory->Type != 0) {
                    *Size += sizeof(IMAGE_DEBUG_DIRECTORY);
                    DebugDirectory++;
                }
                if (FoundSection) {
                    *FoundSection = NtSection;
                }
                return (PVOID)((ULONG_PTR)NtSection->PointerToRawData + (ULONG_PTR)Base);
            }
        } else
        if ( DirectoryEntry == IMAGE_DIRECTORY_ENTRY_EXCEPTION ) {
            if (!_stricmp((char *)NtSection->Name, ".pdata")) {
                if (FoundSection) {
                    *FoundSection = NtSection;
                }
                return (PVOID)((ULONG_PTR)NtSection->PointerToRawData + (ULONG_PTR)Base);
            }
        }
    }
    // Not one of the known sections.  Return error.
    *Size = 0;
    return( NULL );
}

PVOID
ImageDirectoryEntryToData64 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL,
    IN PIMAGE_FILE_HEADER FileHeader,
    IN PIMAGE_OPTIONAL_HEADER64 OptionalHeader
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;
    ULONG DirectoryAddress;

    if (DirectoryEntry >= OptionalHeader->NumberOfRvaAndSizes) {
        *Size = 0;
        return( NULL );
    }

    if (!(DirectoryAddress = OptionalHeader->DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        *Size = 0;
        return( NULL );
    }
    *Size = OptionalHeader->DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < OptionalHeader->SizeOfHeaders) {
        if (FoundSection) {
            *FoundSection = NULL;
        }
        return( (PVOID)((ULONG_PTR)Base + DirectoryAddress) );
    }

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                        FileHeader->SizeOfOptionalHeader);

    for (i=0; i<FileHeader->NumberOfSections; i++) {
        if (DirectoryAddress >= NtSection->VirtualAddress &&
           DirectoryAddress < NtSection->VirtualAddress + NtSection->SizeOfRawData) {
            if (FoundSection) {
                *FoundSection = NtSection;
            }
            return( (PVOID)((ULONG_PTR)Base + (DirectoryAddress - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
        ++NtSection;
    }
    return( NULL );
}

PVOID
ImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL,
    IN PIMAGE_FILE_HEADER FileHeader,
    IN PIMAGE_OPTIONAL_HEADER32 OptionalHeader
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;
    ULONG DirectoryAddress;

    if (DirectoryEntry >= OptionalHeader->NumberOfRvaAndSizes) {
        *Size = 0;
        return( NULL );
    }

    if (!(DirectoryAddress = OptionalHeader->DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        *Size = 0;
        return( NULL );
    }
    *Size = OptionalHeader->DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < OptionalHeader->SizeOfHeaders) {
        if (FoundSection) {
            *FoundSection = NULL;
        }
        return( (PVOID)((ULONG_PTR)Base + DirectoryAddress) );
    }

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                        FileHeader->SizeOfOptionalHeader);

    for (i=0; i<FileHeader->NumberOfSections; i++) {
        if (DirectoryAddress >= NtSection->VirtualAddress &&
           DirectoryAddress < NtSection->VirtualAddress + NtSection->SizeOfRawData) {
            if (FoundSection) {
                *FoundSection = NtSection;
            }
            return( (PVOID)((ULONG_PTR)Base + (DirectoryAddress - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
        ++NtSection;
    }
    return( NULL );
}

PVOID
ImageDirectoryEntryToDataEx (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.  It may optionally return the
    section header, if any, for the found data.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

    FoundSection - Returns the section header, if any, for the data

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;

    if ((ULONG_PTR)Base & 0x00000001) {
        Base = (PVOID)((ULONG_PTR)Base & ~0x1);
        MappedAsImage = FALSE;
        }

    NtHeader = ImageNtHeader(Base);

    if (NtHeader) {
        FileHeader = &NtHeader->FileHeader;
        OptionalHeader = &NtHeader->OptionalHeader;
    } else {
        // Handle case where Image passed in doesn't have a dos stub (ROM images for instance);
        FileHeader = (PIMAGE_FILE_HEADER)Base;
        OptionalHeader = (PIMAGE_OPTIONAL_HEADER) ((ULONG_PTR)Base + IMAGE_SIZEOF_FILE_HEADER);
    }

    if (OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        return (ImageDirectoryEntryToData32 ( Base,
                                              MappedAsImage,
                                              DirectoryEntry,
                                              Size,
                                              FoundSection,
                                              FileHeader,
                                              (PIMAGE_OPTIONAL_HEADER32)OptionalHeader));
    } else if (OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        return (ImageDirectoryEntryToData64 ( Base,
                                               MappedAsImage,
                                               DirectoryEntry,
                                               Size,
                                               FoundSection,
                                               FileHeader,
                                               (PIMAGE_OPTIONAL_HEADER64)OptionalHeader));
    } else if (OptionalHeader->Magic == IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
        return (ImageDirectoryEntryToDataRom ( Base,
                                               MappedAsImage,
                                               DirectoryEntry,
                                               Size,
                                               FoundSection,
                                               FileHeader,
                                               (PIMAGE_ROM_OPTIONAL_HEADER)OptionalHeader));
    } else {

        *Size = 0;
        return NULL;
    }
}


PVOID
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.

    This just calls ImageDirectoryToDataEx without a FoundSection arg.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    return ImageDirectoryEntryToDataEx(Base, MappedAsImage, DirectoryEntry, Size, NULL);
}


PIMAGE_SECTION_HEADER
ImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file
    that is mapped as a file and returns a pointer to the section
    table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the pointer of the section entry containing the data.

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}


PVOID
ImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file that
    is mapped as a file and returns the virtual addrees of the
    corresponding byte in the file.


Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

    LastRvaSection - Optional parameter that if specified, points
        to a variable that contains the last section value used for
        the specified image to translate and RVA to a VA.

Return Value:

    NULL - The file does not contain the specified RVA

    NON-NULL - Returns the virtual addrees in the mapped file.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    if (LastRvaSection == NULL ||
        (NtSection = *LastRvaSection) == NULL ||
        NtSection == NULL ||
        Rva < NtSection->VirtualAddress ||
        Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData
       ) {
        NtSection = ImageRvaToSection( NtHeaders,
                                       Base,
                                       Rva
                                     );
        }

    if (NtSection != NULL) {
        if (LastRvaSection != NULL) {
            *LastRvaSection = NtSection;
            }

        return (PVOID)((ULONG_PTR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData
                      );
        }
    else {
        return NULL;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\imagechk.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    imagechk.c

Abstract:

    this module implements a sanity check of certain image characteristics

Author:

    NT Base

Revision History:


Notes:


--*/

#ifdef __cplusplus
extern "C" {
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include <errno.h>
#include <direct.h>
#include <cvinfo.h>
#include <private.h>

typedef struct _SYMMODLIST{
    char *ModName;
    void *ModBase;
    struct _SYMMODLIST *Next;
} SYMMODLIST, *PSYMMODLIST;

typedef struct List {
    char            Name[40];
    unsigned long   Attributes;
} List, *pList;

typedef struct _LogListItem {
    char *LogLine;
    struct _LogListItem *Next;
} LogListItem, *pLogListItem;

//
// decarations
//

VOID
FindFiles();

VOID
Imagechk(
    List *rgpList,
    TCHAR *szDirectory
    );

VOID
ParseArgs(
    int *pargc,
    char **argv
    );

int
__cdecl
CompFileAndDir(
    const void *elem1,
    const void *elem2
    );

int
__cdecl
CompName(
    const void *elem1,
    const void *elem2
    );

VOID
Usage(
    VOID
    );

int
_cdecl
_cwild(
    VOID
    );

PSYMMODLIST
MakeModList(
    HANDLE
    );

void
FreeModList(
    PSYMMODLIST
    );

BOOL
CALLBACK
SymEnumerateModulesCallback(
    LPSTR,
    ULONG64,
    PVOID
    );

void *
GetModAddrFromName(
    PSYMMODLIST,
    char *
    );

BOOL
VerifyVersionResource(
    PCHAR FileName,
    BOOL fSelfRegister
    );

BOOL
ValidatePdata(
    PIMAGE_DOS_HEADER DosHeader
    );

BOOL
ImageNeedsOleSelfRegister(
    PIMAGE_DOS_HEADER DosHeader
    );

NTSTATUS
MiVerifyImageHeader (
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PIMAGE_DOS_HEADER DosHeader,
    IN DWORD NtHeaderSize
    );

pLogListItem
LogAppend(
    char *,
    pLogListItem
    );

void
LogOutAndClean(
    BOOL
    );

void
__cdecl
LogPrintf(
    const char *format,
    ...
    );

#define X64K (64*1024)

#define MM_SIZE_OF_LARGEST_IMAGE ((ULONG)0x10000000)

#define MM_MAXIMUM_IMAGE_HEADER (2 * PageSize)

#define MM_MAXIMUM_IMAGE_SECTIONS                       \
     ((MM_MAXIMUM_IMAGE_HEADER - (4096 + sizeof(IMAGE_NT_HEADERS))) /  \
            sizeof(IMAGE_SECTION_HEADER))

#define MMSECTOR_SHIFT 9  //MUST BE LESS THAN OR EQUAL TO PageShift

#define MMSECTOR_MASK 0x1ff

#define MI_ROUND_TO_SIZE(LENGTH,ALIGNMENT)     \
                    (((ULONG)LENGTH + ALIGNMENT - 1) & ~(ALIGNMENT - 1))

#define BYTES_TO_PAGES(Size)  (((ULONG)(Size) >> PageShift) + \
                               (((ULONG)(Size) & (PageSize - 1)) != 0))

#define ArgFlag_OK      1
#define ArgFlag_CKMZ    2
#define ArgFlag_SymCK   4
#define ArgFlag_OLESelf 8
#define ArgFlag_CKBase  16

//
// file global data
//

BOOL fRecurse;
BOOL fFileOut;
BOOL fNotCurrent;
BOOL fPattern;
BOOL fSingleFile;
BOOL fPathOverride;
BOOL fSingleSlash;
BOOL fDebugMapped;
FILE* fout;
CHAR *szFileName = {"*.*"};
CHAR *pszRootDir;
CHAR *pszFileOut;
CHAR szDirectory[MAX_PATH] = {"."};
CHAR szSympath[MAX_PATH] = {0};
CHAR *szPattern;
int endpath, DirNum=1, ProcessedFiles;
ULONG PageSize;
ULONG PageShift;
PVOID HighestUserAddress;
USHORT ValidMachineIDMin;
USHORT ValidMachineIDMax;
DWORD ArgFlag;

//
// logging support
//

pLogListItem pLogList = NULL;
pLogListItem pLogListTmp = NULL;

typedef
NTSTATUS
(NTAPI *LPLDRVERIFYIMAGECHKSUM)(
    IN HANDLE ImageFileHandle
    );

LPLDRVERIFYIMAGECHKSUM lpOldLdrVerifyImageMatchesChecksum;

typedef
NTSTATUS
(NTAPI *LPLDRVERIFYIMAGEMATCHESCHECKSUM) (
    IN HANDLE ImageFileHandle,
    IN PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine OPTIONAL,
    IN PVOID ImportCallbackParameter,
    OUT PUSHORT ImageCharacteristics OPTIONAL
    );

LPLDRVERIFYIMAGEMATCHESCHECKSUM lpNewLdrVerifyImageMatchesChecksum;

typedef
NTSTATUS
(NTAPI *LPNTQUERYSYSTEMINFORMATION) (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

LPNTQUERYSYSTEMINFORMATION lpNtQuerySystemInformation;


OSVERSIONINFO VersionInformation;

//
// function definitions
//

VOID __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
/*++

Routine Description:

    program entry

Arguments:

    int     argc,
    char    *argv[]
    char    *envp[]

Return Value:

    none

Notes:


--*/
{
    TCHAR CWD[MAX_PATH];
    int dirlen=0;

    if (argc < 2) {
        Usage();
    }

    ParseArgs(&argc, argv);

    GetCurrentDirectory(MAX_PATH, CWD);

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {
        fprintf(stderr, "Unable to detect OS version.  Terminating.\n" );
        exit(1);
    }
    if ((VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
        (VersionInformation.dwBuildNumber < 1230))
    {
        lpOldLdrVerifyImageMatchesChecksum = (LPLDRVERIFYIMAGECHKSUM)
            GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), TEXT("LdrVerifyImageMatchesChecksum"));
        if (lpOldLdrVerifyImageMatchesChecksum == NULL) {
            fprintf(stderr, "Incorrect operating system version.\n" );
            exit(1);
        }
    } else {
        lpOldLdrVerifyImageMatchesChecksum = NULL;
        if ((VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (VersionInformation.dwBuildNumber >= 1230))
        {
            lpNewLdrVerifyImageMatchesChecksum = (LPLDRVERIFYIMAGEMATCHESCHECKSUM)
                GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), TEXT("LdrVerifyImageMatchesChecksum"));
            if (lpNewLdrVerifyImageMatchesChecksum == NULL) {
                fprintf(stderr, "OS is screwed up.  NTDLL doesn't export LdrVerifyImageMatchesChecksum.\n" );
                exit(1);
            }
        }
    }

    if (VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        SYSTEM_BASIC_INFORMATION SystemInformation;

        if (VersionInformation.dwBuildNumber <= 1465) {
            goto UseWin9x;
        }

        ValidMachineIDMin = USER_SHARED_DATA->ImageNumberLow;
        ValidMachineIDMax = USER_SHARED_DATA->ImageNumberHigh;
        lpNtQuerySystemInformation = (LPNTQUERYSYSTEMINFORMATION)
            GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), TEXT("NtQuerySystemInformation"));
        if (!lpNtQuerySystemInformation) {
            fprintf(stderr, "Incorrect operation system version.\n");
            exit(1);
        }
        if (!NT_SUCCESS((*lpNtQuerySystemInformation)(SystemBasicInformation,
                                                     &SystemInformation,
                                                     sizeof(SystemInformation),
                                                     NULL))) {
            fprintf(stderr, "OS is screwed up.  NtQuerySystemInformation failed.\n");
            exit(1);
        }
        HighestUserAddress = (PVOID)SystemInformation.MaximumUserModeAddress;
    } else {
UseWin9x:
        HighestUserAddress = (PVOID) 0x7FFE0000;
#ifdef _M_IX86
        ValidMachineIDMin = IMAGE_FILE_MACHINE_I386;
        ValidMachineIDMax = IMAGE_FILE_MACHINE_I386;
#elif defined(_M_AMD64)
        ValidMachineIDMin = IMAGE_FILE_MACHINE_AMD64;
        ValidMachineIDMax = IMAGE_FILE_MACHINE_AMD64;
#elif defined(_M_IA64)
        ValidMachineIDMin = IMAGE_FILE_MACHINE_IA64;
        ValidMachineIDMax = IMAGE_FILE_MACHINE_IA64;
#else
#error("Unknown machine type")
#endif
    }

    if (fPathOverride) {
        if (_chdir(szDirectory) == -1){   // cd to dir
            fprintf(stderr, "Path not found: %s\n", szDirectory);
            Usage();
        }
    }
    // remove trailing '\' needed only for above chdir, not for output formatting
    if (fSingleSlash) {
        dirlen = strlen(szDirectory);
        szDirectory[dirlen-1] = '\0';
    }

    FindFiles();

    fprintf(stdout, "%d files processed in %d directories\n", ProcessedFiles, DirNum);
}

VOID
FindFiles()
/*++

Routine Description:

    make list of files to check, then check them

Arguments:

    none

Return Value:

    none

Notes:


--*/
{

    HANDLE fh;
    TCHAR CWD[MAX_PATH];
    char *q;
    WIN32_FIND_DATA *pfdata;
    BOOL fFilesInDir=FALSE;
    BOOL fDirsFound=FALSE;
    int dnCounter=0, cNumDir=0, i=0, Length=0, NameSize=0, total=0, cNumFiles=0;

    pList rgpList[5000];

    pfdata = (WIN32_FIND_DATA*)malloc(sizeof(WIN32_FIND_DATA));
    if (!pfdata) {
        fprintf(stderr, "Not enough memory.\n");
        return;
    }

    if (!fRecurse) {
        fh = FindFirstFile(szFileName, pfdata);  // find only filename (pattern) if not recursive
    } else {
        fh = FindFirstFile("*.*", pfdata);       // find all if recursive in order to determine subdirectory names
    }

    if (fh == INVALID_HANDLE_VALUE) {
        fprintf(fout==NULL? stderr : fout , "File not found: %s\n", szFileName);
        return;
    }

    // loop to find all files and directories in current directory
    // and copy pertinent data to individual List structures.
    do {
        if (strcmp(pfdata->cFileName, ".") && strcmp(pfdata->cFileName, "..")) {  // skip . and ..
            rgpList[dnCounter] = (pList)malloc(sizeof(List));  // allocate the memory
            if (!rgpList[dnCounter]) {
                fprintf(stderr, "Not enough memory.\n");
                return;
            }

            if (!(pfdata->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {   // if file

                fFilesInDir=TRUE;

                // see if given pattern wildcard extension matches pfdata->cFileName extension
                if (fPattern) {
                    q = strchr(pfdata->cFileName, '.');    // find first instance of "." in filename
                    if (q == NULL) goto blah;             // "." not found
                    _strlwr(q);                            // lowercase before compare
                    if (strcmp(q, szPattern)) goto blah;  // if pattern and name doesn't match goto
                }                                        // OK, I used a goto, get over it.

                if (fSingleFile) {
                    _strlwr(pfdata->cFileName);
                    _strlwr(szFileName);
                    if (strcmp(pfdata->cFileName, szFileName)) goto blah;
                }

                // if pattern && match || no pattern
                strcpy(rgpList[dnCounter]->Name, pfdata->cFileName);
                _strlwr(rgpList[dnCounter]->Name);  // all lowercase for strcmp in CompName

                memcpy(&(rgpList[dnCounter]->Attributes), &pfdata->dwFileAttributes, 4);
                dnCounter++;
                cNumFiles++;
            } else {
                if (pfdata->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {   // if dir

                    fDirsFound=TRUE;
                    //cNumDir++;

                    if (fRecurse) {
                        strcpy(rgpList[dnCounter]->Name, pfdata->cFileName);
                        _strlwr(rgpList[dnCounter]->Name);  // all lowercase for strcmp in CompName
                        memcpy(&(rgpList[dnCounter]->Attributes), &pfdata->dwFileAttributes, 4);
                        cNumDir++;
                        dnCounter++;
                    }
                }
            }
        }
blah: ;

    } while (FindNextFile(fh, pfdata));

    FindClose(fh); // close the file handle

    // Sort Array arranging FILE entries at top
    qsort( (void *)rgpList, dnCounter, sizeof(List *), CompFileAndDir);

    // Sort Array alphabetizing only FILE names
    qsort( (void *)rgpList, dnCounter-cNumDir, sizeof(List *), CompName);

    // Sort Array alphabetizing only DIRectory names
    if (fRecurse) {
        qsort( (void *)&rgpList[dnCounter-cNumDir], cNumDir, sizeof(List *), CompName);
    }

    // Process newly sorted structures.
    for (i=0; i < dnCounter; ++i) {

        if (rgpList[i]->Attributes & FILE_ATTRIBUTE_DIRECTORY) {  // if Dir
            if (fRecurse) {

                if (_chdir(rgpList[i]->Name) == -1){   // cd into subdir and check for error
                    fprintf(stderr, "Unable to change directory: %s\n", rgpList[i]->Name);

                } else {

                    NameSize = strlen(rgpList[i]->Name);
                    strcat(szDirectory, "\\");
                    strcat(szDirectory, rgpList[i]->Name); //append name to directory path
                    total = strlen(szDirectory);
                    DirNum++;      // directory counter

                    // start another iteration of FindFiles
                    FindFiles();

                    // get back to previous directory when above iteration returns
                    _chdir("..");

                    // cut off previously appended directory name - for output only
                    szDirectory[total-(NameSize+1)]='\0';
                }
            }
        } else {
            if (!(rgpList[i]->Attributes & FILE_ATTRIBUTE_DIRECTORY))   // check image if not dir
                Imagechk(rgpList[i], szDirectory);
        }
    }
} // end FindFiles

VOID
Imagechk(
    List *rgpList,
    TCHAR *szDirectory
    )
/*++

Routine Description:

    check various things, including:
        image type, header alignment, image size, machine type
        alignment, some properties of various sections, checksum integrity
        symbol / image file checksum agreement, existence of symbols, etc

Arguments:

    List *  rgpList,
    TCHAR * szDirectory

Return Value:

    none

Notes:


--*/
{

    HANDLE File;
    HANDLE MemMap;
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeader;
    NTSTATUS Status;
    BY_HANDLE_FILE_INFORMATION FileInfo;
    ULONG NumberOfPtes;
    ULONG SectionVirtualSize = 0;
    ULONG i;
    PIMAGE_SECTION_HEADER SectionTableEntry;
    ULONG NumberOfSubsections;
    PCHAR ExtendedHeader = NULL;
    ULONG_PTR PreferredImageBase;
    ULONG_PTR NextVa;
    ULONG ImageFileSize;
    ULONG OffsetToSectionTable;
    ULONG ImageAlignment;
    ULONG PtesInSubsection;
    ULONG StartingSector;
    ULONG EndingSector;
    LPSTR ImageName;
    LPSTR MachineType = "Unknown";
    BOOL MachineTypeMismatch;
    BOOL ImageOk;
    BOOL fHasPdata;
    OSVERSIONINFO OSVerInfo;

    ImageName = rgpList->Name;
    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OSVerInfo);

    LogPrintf("ImageChk: %s\\%s \n", szDirectory, ImageName);

    ProcessedFiles++;

    DosHeader = NULL;
    ImageOk = TRUE;
    File = CreateFile (ImageName,
                        GENERIC_READ | FILE_EXECUTE,
                        OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_READ | FILE_SHARE_DELETE) : FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (File == INVALID_HANDLE_VALUE) {
        LogPrintf("Error, CreateFile() %d\n", GetLastError());
        ImageOk = FALSE;
        goto NextImage;
    }

    MemMap = CreateFileMapping (File,
                        NULL,           // default security.
                        PAGE_READONLY,  // file protection.
                        0,              // high-order file size.
                        0,
                        NULL);

    if (!GetFileInformationByHandle(File, &FileInfo)) {
        fprintf(stderr,"Error, GetFileInfo() %d\n", GetLastError());
        CloseHandle(File);
        ImageOk = FALSE; goto NextImage;
    }

    DosHeader = (PIMAGE_DOS_HEADER) MapViewOfFile(MemMap,
                              FILE_MAP_READ,
                              0,  // high
                              0,  // low
                              0   // whole file
                              );

    CloseHandle(MemMap);
    if (!DosHeader) {
        fprintf(stderr,"Error, MapViewOfFile() %d\n", GetLastError());
        ImageOk = FALSE; goto NextImage;
    }

    //
    // Check to determine if this is an NT image (PE format) or
    // a DOS image, Win-16 image, or OS/2 image.  If the image is
    // not NT format, return an error indicating which image it
    // appears to be.
    //

    if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE) {

        if (ArgFlag & ArgFlag_CKMZ) {
            LogPrintf("MZ header not found\n");
            ImageOk = FALSE;
        }
        goto NeImage;
    }


    if (((ULONG)DosHeader->e_lfanew & 3) != 0) {

        //
        // The image header is not aligned on a long boundary.
        // Report this as an invalid protect mode image.
        //

        LogPrintf("Image header not on Long boundary\n");
        ImageOk = FALSE;
        goto NeImage;
    }


    if ((ULONG)DosHeader->e_lfanew > FileInfo.nFileSizeLow) {
        LogPrintf("Image size bigger than size of file\n");
        ImageOk = FALSE;
        goto NeImage;
    }

    NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)DosHeader + (ULONG)DosHeader->e_lfanew);

    if (NtHeader->Signature != IMAGE_NT_SIGNATURE) { //if not PE image

        LogPrintf("Non 32-bit image");
        ImageOk = TRUE;
        goto NeImage;
    }

    //
    // Check to see if this is an NT image or a DOS or OS/2 image.
    //

    Status = MiVerifyImageHeader (NtHeader, DosHeader, 50000);
    if (Status != STATUS_SUCCESS) {
        ImageOk = FALSE;            //continue checking the image but don't print "OK"
    }

    //
    // Verify machine type.
    //

    fHasPdata = TRUE;       // Most do

    switch (NtHeader->FileHeader.Machine) {
        case IMAGE_FILE_MACHINE_I386:
            MachineType = "x86";
            PageSize = 4096;
            PageShift = 12;
            fHasPdata = FALSE;
            break;

        case IMAGE_FILE_MACHINE_ALPHA:
            MachineType = "Alpha";
            PageSize = 8192;
            PageShift = 13;
            break;

        case IMAGE_FILE_MACHINE_IA64:
            MachineType = "Intel64";
            PageSize = 8192;
            PageShift = 13;
            break;

        case IMAGE_FILE_MACHINE_ALPHA64:
            MachineType = "Alpha64";
            PageSize = 8192;
            PageShift = 13;
            break;

        default:
            LogPrintf("Unrecognized machine type x%lx\n",
                NtHeader->FileHeader.Machine);
            ImageOk = FALSE;
            break;
        }

    if ((NtHeader->FileHeader.Machine < ValidMachineIDMin) ||
        (NtHeader->FileHeader.Machine > ValidMachineIDMax)) {
        MachineTypeMismatch = TRUE;
    } else {
        MachineTypeMismatch = FALSE;
    }

    ImageAlignment = NtHeader->OptionalHeader.SectionAlignment;

    NumberOfPtes = BYTES_TO_PAGES (NtHeader->OptionalHeader.SizeOfImage);

    NextVa = NtHeader->OptionalHeader.ImageBase;

    if ((NextVa & (X64K - 1)) != 0) {

        //
        // Image header is not aligned on a 64k boundary.
        //

        LogPrintf("image base not on 64k boundary %lx\n",NextVa);

        ImageOk = FALSE;
        goto BadPeImageSegment;
    }

    //BasedAddress = (PVOID)NextVa;
    PtesInSubsection = MI_ROUND_TO_SIZE (
                                       NtHeader->OptionalHeader.SizeOfHeaders,
                                       ImageAlignment
                                   ) >> PageShift;

    if (ImageAlignment >= PageSize) {

        //
        // Aligmment is PageSize of greater.
        //

        if (PtesInSubsection > NumberOfPtes) {

            //
            // Inconsistent image, size does not agree with header.
            //

            LogPrintf("Image size in header (%ld.) not consistent with sections (%ld.)\n",
                    NumberOfPtes, PtesInSubsection);
            ImageOk = FALSE;
            goto BadPeImageSegment;
        }

        NumberOfPtes -= PtesInSubsection;

        EndingSector = NtHeader->OptionalHeader.SizeOfHeaders >> MMSECTOR_SHIFT;

        for (i = 0; i < PtesInSubsection; i++) {

            NextVa += PageSize;
        }
    }

    //
    // Build the next subsections.
    //

    NumberOfSubsections = NtHeader->FileHeader.NumberOfSections;
    PreferredImageBase = NtHeader->OptionalHeader.ImageBase;

    //
    // At this point the object table is read in (if it was not
    // already read in) and may displace the image header.
    //

    OffsetToSectionTable = sizeof(ULONG) +
                              sizeof(IMAGE_FILE_HEADER) +
                              NtHeader->FileHeader.SizeOfOptionalHeader;

    SectionTableEntry = (PIMAGE_SECTION_HEADER)((PCHAR)NtHeader + OffsetToSectionTable);

    if (ImageAlignment < PageSize) {

        // The image header is no longer valid, TempPte is
        // used to indicate that this image alignment is
        // less than a PageSize.

        //
        // Loop through all sections and make sure there is no
        // unitialized data.
        //

        while (NumberOfSubsections > 0) {
            if (SectionTableEntry->Misc.VirtualSize == 0) {
                SectionVirtualSize = SectionTableEntry->SizeOfRawData;
            } else {
                SectionVirtualSize = SectionTableEntry->Misc.VirtualSize;
            }

            //
            // If the pointer to raw data is zero and the virtual size
            // is zero, OR, the section goes past the end of file, OR
            // the virtual size does not match the size of raw data, then
            // return an error.
            //

            if (((SectionTableEntry->PointerToRawData !=
                  SectionTableEntry->VirtualAddress))
                        ||
                ((SectionTableEntry->SizeOfRawData +
                        SectionTableEntry->PointerToRawData) >
                     FileInfo.nFileSizeLow)
                        ||
               (SectionVirtualSize > SectionTableEntry->SizeOfRawData)) {

                LogPrintf("invalid BSS/Trailingzero section/file size\n");

                ImageOk = FALSE;
                goto NeImage;
            }
            SectionTableEntry += 1;
            NumberOfSubsections -= 1;
        }
        goto PeReturnSuccess;
    }

    while (NumberOfSubsections > 0) {

        //
        // Handle case where virtual size is 0.
        //

        if (SectionTableEntry->Misc.VirtualSize == 0) {
            SectionVirtualSize = SectionTableEntry->SizeOfRawData;
        } else {
            SectionVirtualSize = SectionTableEntry->Misc.VirtualSize;
        }

        if (!strcmp(SectionTableEntry->Name, ".debug")) {
            fDebugMapped = TRUE;
        }

        if (SectionVirtualSize == 0) {
            //
            // The specified virtual address does not align
            // with the next prototype PTE.
            //

            LogPrintf("Section virtual size is 0, NextVa for section %lx %lx\n",
                    SectionTableEntry->VirtualAddress, NextVa);
            ImageOk = FALSE;
            goto BadPeImageSegment;
        }

        if (NextVa !=
                (PreferredImageBase + SectionTableEntry->VirtualAddress)) {

            //
            // The specified virtual address does not align
            // with the next prototype PTE.
            //

            LogPrintf("Section Va not set to alignment, NextVa for section %lx %lx\n",
                    SectionTableEntry->VirtualAddress, NextVa);
            ImageOk = FALSE;
            goto BadPeImageSegment;
        }

        PtesInSubsection =
            MI_ROUND_TO_SIZE (SectionVirtualSize, ImageAlignment) >> PageShift;

        if (PtesInSubsection > NumberOfPtes) {

            //
            // Inconsistent image, size does not agree with object tables.
            //
            LogPrintf("Image size in header not consistent with sections, needs %ld. pages\n",
                PtesInSubsection - NumberOfPtes);
            LogPrintf("va of bad section %lx\n",SectionTableEntry->VirtualAddress);

            ImageOk = FALSE;
            goto BadPeImageSegment;
        }
        NumberOfPtes -= PtesInSubsection;

        StartingSector = SectionTableEntry->PointerToRawData >> MMSECTOR_SHIFT;
        EndingSector =
                         (SectionTableEntry->PointerToRawData +
                                     SectionVirtualSize);
        EndingSector = EndingSector >> MMSECTOR_SHIFT;

        ImageFileSize = SectionTableEntry->PointerToRawData +
                                    SectionTableEntry->SizeOfRawData;

        for (i = 0; i < PtesInSubsection; i++) {

            //
            // Set all the prototype PTEs to refer to the control section.
            //

            NextVa += PageSize;
        }

        SectionTableEntry += 1;
        NumberOfSubsections -= 1;
    }

    //
    // If the file size is not as big as the image claimed to be,
    // return an error.
    //

    if (ImageFileSize > FileInfo.nFileSizeLow) {

        //
        // Invalid image size.
        //

        LogPrintf("invalid image size - file size %lx - image size %lx\n",
            FileInfo.nFileSizeLow, ImageFileSize);
        ImageOk = FALSE;
        goto BadPeImageSegment;
    }

    {
        // Validate the debug information (as much as we can).
        PVOID ImageBase;
        ULONG DebugDirectorySize, NumberOfDebugDirectories, i;
        PIMAGE_DEBUG_DIRECTORY DebugDirectory;

        ImageBase = (PVOID) DosHeader;

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
            ImageDirectoryEntryToData(
                ImageBase,
                FALSE,
                IMAGE_DIRECTORY_ENTRY_DEBUG,
                &DebugDirectorySize );

        if (!DebugDirectoryIsUseful(DebugDirectory, DebugDirectorySize)) {

            // Not useful.  Are they valid? (both s/b zero)

            if (DebugDirectory || DebugDirectorySize) {
                LogPrintf("Debug directory values [%x, %x] are invalid\n",
                        DebugDirectory,
                        DebugDirectorySize);
                ImageOk = FALSE;
            }

            goto DebugDirsDone;
        }

        NumberOfDebugDirectories = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

        for (i=0; i < NumberOfDebugDirectories; i++) {
            if (DebugDirectory->PointerToRawData > FileInfo.nFileSizeLow) {
                LogPrintf("Invalid debug directory entry[%d] - File Offset %x is beyond the end of the file\n",
                        i,
                        DebugDirectory->PointerToRawData
                       );
                ImageOk = FALSE;
                goto BadPeImageSegment;
            }

            if ((DebugDirectory->PointerToRawData + DebugDirectory->SizeOfData) > FileInfo.nFileSizeLow) {
                LogPrintf("Invalid debug directory entry[%d] - File Offset (%X) + Size (%X) is beyond the end of the file (filesize: %X)\n",
                        i,
                        DebugDirectory->PointerToRawData,
                        DebugDirectory->SizeOfData,
                        FileInfo.nFileSizeLow
                       );
                ImageOk = FALSE;
                goto BadPeImageSegment;
            }
#if 0
            if (DebugDirectory->AddressOfRawData != 0) {
                if (DebugDirectory->AddressOfRawData > ImageFileSize){
                    LogPrintf("Invalid debug directory entry[%d] - VA (%X) is beyond the end of the image VA (%X)\n",
                            i,
                            DebugDirectory->AddressOfRawData,
                            ImageFileSize);
                    ImageOk = FALSE;
                    goto BadPeImageSegment;
                }

                if ((DebugDirectory->AddressOfRawData + DebugDirectory->SizeOfData )> ImageFileSize){
                    LogPrintf("Invalid debug directory entry[%d] - VA (%X) + size (%X) is beyond the end of the image VA (%X)\n",
                            i,
                            DebugDirectory->AddressOfRawData,
                            DebugDirectory->SizeOfData,
                            ImageFileSize);
                    ImageOk = FALSE;
                    goto BadPeImageSegment;
                }
            }
#endif

            if (DebugDirectory->Type <= 0x7fffffff) {
                switch (DebugDirectory->Type) {
                    case IMAGE_DEBUG_TYPE_MISC:
                        {
                            PIMAGE_DEBUG_MISC pDebugMisc;
                            // MISC should point to an IMAGE_DEBUG_MISC structure
                            pDebugMisc = (PIMAGE_DEBUG_MISC)((PCHAR)ImageBase + DebugDirectory->PointerToRawData);
                            if (pDebugMisc->DataType != IMAGE_DEBUG_MISC_EXENAME) {
                                LogPrintf("MISC Debug has an invalid DataType\n");
                                ImageOk = FALSE;
                                goto BadPeImageSegment;
                            }
                            if (pDebugMisc->Length != DebugDirectory->SizeOfData) {
                                LogPrintf("MISC Debug has an invalid size.\n");
                                ImageOk = FALSE;
                                goto BadPeImageSegment;
                            }

                            if (!pDebugMisc->Unicode) {
                                i= 0;
                                while (i < pDebugMisc->Length - sizeof(IMAGE_DEBUG_MISC)) {
                                    if (!isprint(pDebugMisc->Data[i]) &&
                                        (pDebugMisc->Data[i] != '\0') )
                                    {
                                        LogPrintf("MISC Debug has unprintable characters... Possibly corrupt\n");
                                        ImageOk = FALSE;
                                        goto BadPeImageSegment;
                                    }
                                    i++;
                                }

                                // The data must be a null terminated string.
                                if (strlen(pDebugMisc->Data) > (pDebugMisc->Length - sizeof(IMAGE_DEBUG_MISC))) {
                                    LogPrintf("MISC Debug has invalid data... Possibly corrupt\n");
                                    ImageOk = FALSE;
                                    goto BadPeImageSegment;
                                }
                            }
                        }
                        break;

                    case IMAGE_DEBUG_TYPE_CODEVIEW:
                        // CV will point to either a NB09 or an NB10 signature.  Make sure it does.
                        {
                            OMFSignature * CVDebug;
                            CVDebug = (OMFSignature *)((PCHAR)ImageBase + DebugDirectory->PointerToRawData);
                            if (((*(PULONG)(CVDebug->Signature)) != '90BN') &&
                                ((*(PULONG)(CVDebug->Signature)) != '01BN') &&
                                ((*(PULONG)(CVDebug->Signature)) != 'SDSR'))
                            {
                                LogPrintf("CV Debug has an invalid signature\n");
                                ImageOk = FALSE;
                                goto BadPeImageSegment;
                            }
                        }
                        break;

                    case IMAGE_DEBUG_TYPE_COFF:
                    case IMAGE_DEBUG_TYPE_FPO:
                    case IMAGE_DEBUG_TYPE_EXCEPTION:
                    case IMAGE_DEBUG_TYPE_FIXUP:
                    case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                    case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                        // Not much we can do about these now.
                        break;

                    default:
                        LogPrintf("Invalid debug directory type: %d\n", DebugDirectory->Type);
                        ImageOk = FALSE;
                        goto BadPeImageSegment;
                        break;
                }
            }
        }

    }

DebugDirsDone:

    //
    // The total number of PTEs was decremented as sections were built,
    // make sure that there are less than 64ks worth at this point.
    //

    if (NumberOfPtes >= (ImageAlignment >> PageShift)) {

        //
        // Inconsistent image, size does not agree with object tables.
        //

        LogPrintf("invalid image - PTEs left %lx\n",
            NumberOfPtes);

        ImageOk = FALSE;
        goto BadPeImageSegment;
    }

    //
    // check checksum.
    //

PeReturnSuccess:
    if (NtHeader->OptionalHeader.CheckSum == 0) {
        LogPrintf("(checksum is zero)\n");
    } else {
        __try {
            if (lpOldLdrVerifyImageMatchesChecksum == NULL) {
                if (lpNewLdrVerifyImageMatchesChecksum == NULL) {
                    Status = STATUS_SUCCESS;
                    LogPrintf("Unable to validate checksum\n");
                } else {
                    Status = (*lpNewLdrVerifyImageMatchesChecksum)(File, NULL, NULL, NULL);
                }
            } else {
                Status = (*lpOldLdrVerifyImageMatchesChecksum)(File);
            }

            if (NT_ERROR(Status)) {
                LogPrintf("checksum mismatch\n");
                ImageOk = FALSE;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            ImageOk = FALSE;
            LogPrintf("checksum mismatch\n");
        }
    }

    if (fHasPdata && ImageOk) {
        ImageOk = ValidatePdata(DosHeader);
    }

    if (ImageOk) {
        ImageOk = VerifyVersionResource(ImageName, ImageNeedsOleSelfRegister(DosHeader));
    }

    //
    // sanity test for symbols
    // basically : if this does not work, debugging probably will not either
    // these high-level debugging api's will also call a pdb validation routine
    //

    if(ArgFlag & ArgFlag_SymCK)
    {
        HANDLE hProcess = 0;
        char Target[MAX_PATH] = {0};
        char drive[_MAX_DRIVE];
        char dir[_MAX_DIR];
        char fname[_MAX_FNAME];
        char ext[_MAX_EXT];
        IMAGEHLP_MODULE64 ModuleInfo = {0};
        PSYMMODLIST ModList = 0;
        void *vpAddr;
        PLOADED_IMAGE pLImage = NULL;
        DWORD64 symLMflag;

        strcpy(Target, szDirectory);
        strcat(Target, "\\");
        strcat(Target, ImageName);

        //
        // set up for debugging
        //

        hProcess = GetCurrentProcess();

        if(!SymInitialize(hProcess, szSympath, FALSE))
        {
            LogPrintf("ERROR:SymInitialize failed!\n");
            hProcess = 0;
            goto symckend;
        }

        //
        // attempt to use symbols
        //

        _splitpath(Target, drive, dir, fname, ext );

        symLMflag = SymLoadModule64(hProcess, NULL, Target, fname, 0, 0);
        if(!symLMflag)
        {
            LogPrintf("ERROR:SymLoadModule failed! last error:0x%x\n", GetLastError());
            goto symckend;
        }

        //
        // identify module type
        // find module, symgetmoduleinfo, check dbg type
        //

        ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);
        ModList = MakeModList(hProcess);
        vpAddr = GetModAddrFromName(ModList, fname);

        if(!SymGetModuleInfo64(hProcess, (DWORD64)vpAddr, &ModuleInfo))
        {
            LogPrintf("ERROR:SymGetModuleInfo failed! last error:0x%x\n", GetLastError());
            goto symckend;
        }

        if(ModuleInfo.SymType != SymPdb)
        {
            LogPrintf("WARNING: No pdb info for file!\n");
            switch(ModuleInfo.SymType){
                case SymNone:
                    LogPrintf("symtype: SymNone\n");
                    break;
                case SymCoff:
                    LogPrintf("symtype: SymCoff\n");
                    break;
                case SymCv:
                    LogPrintf("symtype: SymCv\n");
                    break;
                case SymPdb:
                    LogPrintf("symtype: SymPdb\n");
                    break;
                case SymExport:
                    LogPrintf("symtype: SymExport\n");
                    break;
                case SymDeferred:
                    LogPrintf("symtype: SymDeferred\n");
                    break;
                case SymSym:
                    LogPrintf("symtype: SymSym\n");
                    break;
            }
        }

        //
        // get image, symbol checksum, compare
        //

        pLImage = ImageLoad(Target, NULL);

        {
            CHAR szDbgPath[_MAX_PATH];
            HANDLE DbgFileHandle;

            DbgFileHandle = FindDebugInfoFile(Target, szSympath, szDbgPath);
            if (DbgFileHandle != INVALID_HANDLE_VALUE) {
                IMAGE_SEPARATE_DEBUG_HEADER DbgHeader;
                DWORD BytesRead;
                BOOL ReadSuccess;

                SetFilePointer(DbgFileHandle, 0, 0, FILE_BEGIN);
                ReadSuccess = ReadFile(DbgFileHandle, &DbgHeader, sizeof(DbgHeader), &BytesRead, NULL);

                if (ReadSuccess && (BytesRead == sizeof(DbgHeader))) {
                    // Got enough to check if it's a valid dbg file.
                    if(((PIMAGE_NT_HEADERS)pLImage->FileHeader)->OptionalHeader.CheckSum != DbgHeader.CheckSum) {
                        LogPrintf("ERROR! image / debug file checksum not equal\n");
                        ImageOk = FALSE;
                    }
                }
                CloseHandle(DbgFileHandle);
            }
        }

        //
        // cleanup
        //

symckend:
        if(ModList)
        {
            FreeModList(ModList);
        }
        if(pLImage)
        {
            ImageUnload(pLImage);
        }
        if(symLMflag)
        {
            SymUnloadModule64(hProcess, (DWORD)symLMflag);
        }
        if(hProcess)
        {
            SymCleanup(hProcess);
        }
    }

NextImage:
BadPeImageSegment:
NeImage:
    if ( ImageOk && (ArgFlag & ArgFlag_OK)) {
        if (MachineTypeMismatch) {
            LogPrintf(" OK [%s]\n", MachineType);
        } else {
            LogPrintf(" OK\n");
        }
    }

    //
    // print out results
    //

    if (ImageOk)
    {
        LogOutAndClean((ArgFlag & ArgFlag_OK) ? TRUE : FALSE);
    } else {
        LogOutAndClean(TRUE);
    }

    if ( File != INVALID_HANDLE_VALUE ) {
        CloseHandle(File);
    }
    if ( DosHeader ) {
        UnmapViewOfFile(DosHeader);
    }
}

NTSTATUS
MiVerifyImageHeader (
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PIMAGE_DOS_HEADER DosHeader,
    IN ULONG NtHeaderSize
    )
/*++

Routine Description:

    Checks image header for consistency.

Arguments:

    IN PIMAGE_NT_HEADERS    NtHeader
    IN PIMAGE_DOS_HEADER    DosHeader
    IN ULONG                NtHeaderSize

Return Value:

    Returns the status value.

    TBS

--*/
{

    if ((NtHeader->FileHeader.Machine == 0) &&
        (NtHeader->FileHeader.SizeOfOptionalHeader == 0)) {

        //
        // This is a bogus DOS app which has a 32-bit portion
        // mascarading as a PE image.
        //

        LogPrintf("Image machine type and size of optional header bad\n");
        return STATUS_INVALID_IMAGE_PROTECT;
    }

    if (!(NtHeader->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)) {
        LogPrintf("Characteristics not image file executable\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

#ifdef i386

    //
    // Make sure the image header is aligned on a Long word boundary.
    //

    if (((ULONG)NtHeader & 3) != 0) {
        LogPrintf("NtHeader is not aligned on longword boundary\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }
#endif

    // Non-driver code must have file alignment set to a multiple of 512

    if (((NtHeader->OptionalHeader.FileAlignment & 511) != 0) &&
        (NtHeader->OptionalHeader.FileAlignment !=
         NtHeader->OptionalHeader.SectionAlignment)) {
        LogPrintf("file alignment is not multiple of 512 and power of 2\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    //
    // File aligment must be power of 2.
    //

    if ((((NtHeader->OptionalHeader.FileAlignment << 1) - 1) &
        NtHeader->OptionalHeader.FileAlignment) !=
        NtHeader->OptionalHeader.FileAlignment) {
        LogPrintf("file alignment not power of 2\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (NtHeader->OptionalHeader.SectionAlignment < NtHeader->OptionalHeader.FileAlignment) {
        LogPrintf("SectionAlignment < FileAlignment\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (NtHeader->OptionalHeader.SizeOfImage > MM_SIZE_OF_LARGEST_IMAGE) {
        LogPrintf("Image too big %lx\n",NtHeader->OptionalHeader.SizeOfImage);
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (NtHeader->FileHeader.NumberOfSections > MM_MAXIMUM_IMAGE_SECTIONS) {
        LogPrintf("Too many image sections %ld.\n",
                NtHeader->FileHeader.NumberOfSections);
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (ArgFlag & ArgFlag_CKBase) {
       if ((PVOID)NtHeader->OptionalHeader.ImageBase >= HighestUserAddress) {
          LogPrintf("Image base (%lx) is invalid on this machine\n",
                NtHeader->OptionalHeader.ImageBase);
          return STATUS_SUCCESS;
       }
    }

    return STATUS_SUCCESS;
}


VOID
ParseArgs(
    int *pargc,
    char **argv
    )
/*++

Routine Description:

    parse arguments to this program

Arguments:

    int *pargc
    char **argv

Return Value:

    none

Notes:

    command line args:
    (original)
    case '?': call usage and exit
    case 'b': check whether base address of image is in user space for this machine
    case 's': /s <sympath> check symbols
    case 'p': PE Errors only
    case 'r': recurse subdirectories
    (new)
    case 'v': verbose - output "OK"
    case 'o': output "OleSelfRegister not set"

--*/
{
    CHAR cswitch, c, *p;
    CHAR sztmp[MAX_PATH];
    int argnum = 1, i=0, len=0, count=0;
    BOOL fslashfound = FALSE;

    //
    // set default flags here
    //

    ArgFlag |= ArgFlag_CKBase;

    while ( argnum < *pargc ) {
        _strlwr(argv[argnum]);
        cswitch = *(argv[argnum]);
        if (cswitch == '/' || cswitch == '-') {
            c = *(argv[argnum]+1);

            switch (c) {
                case 'o':
                    ArgFlag |= ArgFlag_OLESelf;
                    break;

                case 'v':
                    ArgFlag |= ArgFlag_OK | ArgFlag_CKMZ | ArgFlag_OLESelf;
                    break;

                case '?':
                    Usage();
                    break;

                case 'b':
                    ArgFlag ^= ArgFlag_CKBase;
                    break;

                case 's':
                    if (argv[argnum+1]) {
                        strcpy(szSympath, (argv[argnum+1]));
                        ArgFlag |= ArgFlag_SymCK;
                        argnum++;
                    }
                    break;

                case 'p':
                    ArgFlag |= ArgFlag_CKMZ;
                    break;

                case 'r':
                    fRecurse = TRUE;
                    if (argv[argnum+1]) {
                        fPathOverride=TRUE;
                        strcpy(szDirectory, (argv[argnum+1]));
                        if (!(strcmp(szDirectory, "\\"))) {  // if just '\'
                            fSingleSlash=TRUE;
                        }
                        //LogPrintf("dir %s\n", szDirectory);
                        argnum++;
                    }

                    break;

                default:
                    fprintf(stderr, "Invalid argument.\n");
                    Usage();
            }
        } else {
            // Check for path\filename or wildcards

            // Search for '\' in string
            strcpy(sztmp, (argv[argnum]));
            len = strlen(sztmp);
            for (i=0; i < len; i++) {
                if (sztmp[i]=='\\') {
                    count++;
                    endpath=i;         // mark last '\' char found
                    fslashfound=TRUE;  // found backslash, so must be a path\filename combination
                }
            }

            if (fslashfound && !fRecurse) { // if backslash found and not a recursive operation
                                            // seperate the directory and filename into two strings
                fPathOverride=TRUE;
                strcpy(szDirectory, sztmp);

                if (!(strcmp(szDirectory, "\\"))) {
                    Usage();
                }

                szFileName = _strdup(&(sztmp[endpath+1]));


                if (count == 1) { //&& szDirectory[1] == ':') { // if only one '\' char and drive letter indicated
                    fSingleSlash=TRUE;
                    szDirectory[endpath+1]='\0';  // keep trailing '\' in order to chdir properly
                }  else {
                    szDirectory[endpath]='\0';
                }

                if (szFileName[0] == '*' && szFileName[1] == '.' && szFileName[2] != '*') {
                    _strlwr(szFileName);
                    szPattern = strchr(szFileName, '.'); //search for '.'
                    fPattern = TRUE;
                }
            } else {  // no backslash found, assume filename without preceeding path

                szFileName = _strdup(argv[argnum]);
                if (!szFileName) {
                    // drastic error, just bail
                    szFileName = "";
                    return;
                }
                //
                // filename or wildcard
                //
                if ( (*(argv[argnum]) == '*') && (*(argv[argnum]+1) == '.') && (*(argv[argnum]+2) != '*') ){
                    // *.xxx
                    _strlwr(szFileName);
                    szPattern = strchr(szFileName, '.'); //search for '.'
                    fPattern = TRUE;
                } else if ( (*(argv[argnum]) == '*') && (*(argv[argnum]+1) == '.') && (*(argv[argnum]+2) == '*') ) {
                    // *.*
                } else {
                    // probably a single filename
                    _strlwr(szFileName);
                    fSingleFile = TRUE;
                }

                if (fRecurse && strchr(szFileName, '\\') ) { // don't want path\filename when recursing
                    Usage();
                }

            }
            //fprintf(stdout, "dir %s\nfile %s\n", szDirectory, szFileName);
        }
        ++argnum;
    }
    if (szFileName[0] == '\0') {
        Usage();
    }
} // parseargs


int
__cdecl
CompFileAndDir(
    const void *elem1,
    const void *elem2
    )
/*++

Routine Description:

    Purpose: a comparision routine passed to QSort.  It compares elem1 and elem2
    based upon their attribute, i.e., is it a file or directory.

Arguments:

    const void *elem1,
    const void *elem2

Return Value:

    result of comparison function

Notes:


--*/
{
    pList p1, p2;
    // qsort passes a void universal pointer.  Use a typecast (List**)
    // so the compiler recognizes the data as a List structure.
    // Typecast pointer-to-pointer-to-List and dereference ONCE
    // leaving a pList.  I don't dereference the remaining pointer
    // in the p1 and p2 definitions to avoid copying the structure.

    p1 = (*(List**)elem1);
    p2 = (*(List**)elem2);

    if ( (p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&  (p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return 0;
    //both dirs
    if (!(p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) && !(p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return 0;
    //both files
    if ( (p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) && !(p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return 1;
    // elem1 is dir and elem2 is file
    if (!(p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&  (p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return -1;
    // elem1 is file and elem2 is dir

    return 0; // if none of the above
}

int
__cdecl
CompName(
    const void *elem1,
    const void *elem2
    )
/*++

Routine Description:

    another compare routine passed to QSort that compares the two Name strings

Arguments:

    const void *elem1,
    const void *elem2

Return Value:

    result of comparison function

Notes:

    this uses a noignore-case strcmp

--*/
{
   return strcmp( (*(List**)elem1)->Name, (*(List**)elem2)->Name );
}


VOID
Usage(
    VOID
    )
/*++

Routine Description:


Arguments:


Return Value:


Notes:


--*/
{
   fputs("Usage: imagechk  [/?] displays this message\n"
         "                 [/r dir] recurse from directory dir\n"
         "                 [/b] don't check image base address\n"
         "                 [/v] verbose - output everything\n"
         "                 [/o] output \"OleSelfRegister not set\" warning\n"
         "                 [/p] output \"MZ header not found\"\n"
         "                 [/s <sympath>] check pdb symbols\n"
         "                 [filename] file to check\n"
         " Accepts wildcard extensions such as *.exe\n"
         " imagechk /r . \"*.exe\"   check all *.exe recursing on current directory\n"
         " imagechk /r \\ \"*.exe\"  check all *.exe recursing from root of current drive\n"
         " imagechk \"*.exe\"        check all *.exe in current directory\n"
         " imagechk c:\\bar.exe      check c:\\bar.exe only\n",
         stderr);
   exit(1);
}

int
__cdecl
_cwild()
/*++

Routine Description:


Arguments:


Return Value:


Notes:


--*/
{
   return(0);
}

typedef DWORD (WINAPI *PFNGVS)(LPSTR, LPDWORD);
typedef BOOL (WINAPI *PFNGVI)(LPTSTR, DWORD, DWORD, LPVOID);
typedef BOOL (WINAPI *PFNVQV)(const LPVOID, LPTSTR, LPVOID *, PUINT);

BOOL
VerifyVersionResource(
    PCHAR FileName,
    BOOL fSelfRegister
    )
/*++

Routine Description:

    validate the version resource in a file

Arguments:

    PCHAR FileName
    BOOL fSelfRegister

Return Value:

    TRUE    if: no version.dll found
    FALSE   if: version resource missing


Notes:


--*/
{
    static HINSTANCE hVersion = NULL;
    static PFNGVS pfnGetFileVersionInfoSize = NULL;
    static PFNGVI pfnGetFileVersionInfo = NULL;
    static PFNVQV pfnVerQueryValue = NULL;
    DWORD dwSize;
    DWORD lpInfoSize;
    LPVOID lpData = NULL, lpInfo;
    BOOL rc = FALSE;
    DWORD dwDefLang = 0x00000409;
    DWORD *pdwTranslation, uLen;
    CHAR buf[60];

    CHAR szVersionDll[_MAX_PATH];

    if (GetSystemDirectory(szVersionDll, sizeof(szVersionDll))) {
        strcat(szVersionDll, "\\version.dll");
    } else {
        strcpy(szVersionDll, "version.dll");
    }

    if (!hVersion) {
        hVersion = LoadLibraryA(szVersionDll);
        if (hVersion == NULL) {
            return TRUE;
        }

        pfnGetFileVersionInfoSize = (PFNGVS) GetProcAddress(hVersion, "GetFileVersionInfoSizeA");
        pfnGetFileVersionInfo = (PFNGVI) GetProcAddress(hVersion, "GetFileVersionInfoA");
        pfnVerQueryValue = (PFNVQV) GetProcAddress(hVersion, "VerQueryValueA");
    }

    if (!pfnGetFileVersionInfoSize || !pfnGetFileVersionInfo || !pfnVerQueryValue) {
        rc = TRUE;
        goto cleanup;
    }

    if ((dwSize = (*pfnGetFileVersionInfoSize)(FileName, &dwSize)) == 0){
        LogPrintf("No version resource detected\n");
        goto cleanup;
    }

    if (!fSelfRegister) {
        // All we need to do is see if the version resource exists.  Ole Self Register not necessary.
        rc = TRUE;
        goto cleanup;
    }

    if ((lpData = malloc(dwSize)) == NULL) {
        LogPrintf("Out of memory\n");
        goto cleanup;
    }

    if (!(*pfnGetFileVersionInfo)(FileName, 0, dwSize, lpData)) {
        LogPrintf("Unable to read version info\n - %d", GetLastError());
        goto cleanup;
    }

    if(!pfnVerQueryValue(lpData, "\\VarFileInfo\\Translation", &pdwTranslation, &uLen)) {
        pdwTranslation = &dwDefLang;
        uLen = sizeof(DWORD);
    }

    sprintf(buf, "\\StringFileInfo\\%04x%04x\\OleSelfRegister", LOWORD(*pdwTranslation), HIWORD(*pdwTranslation));

    if (!pfnVerQueryValue(lpData, buf, &lpInfo, &lpInfoSize) && (ArgFlag & ArgFlag_OLESelf )) {
        LogPrintf("OleSelfRegister not set\n");
    } else {
        rc = TRUE;
    }

cleanup:
    if (lpData) {
        free(lpData);
    }

    // No need to free the hVersion
    return(rc);
}

BOOL
ValidatePdata(
    PIMAGE_DOS_HEADER DosHeader
    )
/*++

Routine Description:

    validates the PIMAGE_RUNTIME_FUNCTION_ENTRY in the executable

Arguments:

    PIMAGE_DOS_HEADER   DosHeader

Return Value:

    TRUE    if:
    FALSE   if: no exception data
                exception table size incorrect
                exception table corrupt

Notes:


--*/
{
    // The machine type indicates this image should have pdata (an exception table).
    // Ensure it looks reasonable.

    // Todo: Add a range check for exception handler and data

    PIMAGE_RUNTIME_FUNCTION_ENTRY ExceptionTable;
    DWORD ExceptionTableSize, i;
    DWORD_PTR LastEnd;
    BOOL fRc;
    PIMAGE_NT_HEADERS NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)DosHeader + (ULONG)DosHeader->e_lfanew);
    ULONG_PTR ImageBase = NtHeader->OptionalHeader.ImageBase;
    DWORD PDataStart = NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
    DWORD PDataSize = NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;


    ExceptionTable = (PIMAGE_RUNTIME_FUNCTION_ENTRY)
        ImageDirectoryEntryToData(
            DosHeader,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_EXCEPTION,
            &ExceptionTableSize );

    if (!ExceptionTable ||
        (ExceptionTable && (ExceptionTableSize == 0)))
    {
        // No Exception table.
        return(TRUE);
    }

    if (ExceptionTableSize % sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) {
        // The size isn't an even multiple.
        LogPrintf("exception table size is not correct\n");
        return(FALSE);
    }

    LastEnd = 0;
    fRc = TRUE;
    for (i=0; i < (ExceptionTableSize / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)); i++) {

        if (!ExceptionTable[i].BeginAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for BeginAddress\n",
                    i);
            fRc = FALSE;
        }
        if (!ExceptionTable[i].EndAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for EndAddress\n",
                    i);
            fRc = FALSE;
        }
#if defined(_IA64_)
        if (!ExceptionTable[i].UnwindInfoAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for UnwindInfoAddress\n",
                    i);
            fRc = FALSE;
        }
#elif defined(_ALPHA_) || defined(_AXP64_)
        if (!ExceptionTable[i].PrologEndAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for PrologEndAddress\n",
                    i);
            fRc = FALSE;
        }

#endif // defined(_IA64_)

        if (ExceptionTable[i].BeginAddress < LastEnd) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: the begin address [%8.8x] is out of sequence.  Prior end was [%8.8x]\n",
                    i,
                    ExceptionTable[i].BeginAddress,
                    LastEnd);
            fRc = FALSE;
        }

        if (ExceptionTable[i].EndAddress < ExceptionTable[i].BeginAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: the end address [%8.8x] is before the begin address[%8.8X]\n",
                    i,
                    ExceptionTable[i].EndAddress,
                    ExceptionTable[i].BeginAddress);
            fRc = FALSE;
        }

#if defined(_ALPHA_) || defined(_AXP64_)
        if (!((ExceptionTable[i].PrologEndAddress >= ExceptionTable[i].BeginAddress) &&
              (ExceptionTable[i].PrologEndAddress <= ExceptionTable[i].EndAddress)))
        {
            if (NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA) {
                // Change this test.  On Alpha, the PrologEndAddress is allowed to be
                // outside the Function Start/End range.  If this is true, the PrologEnd
                // - ImageBase - pdata section VA s/b divisible by sizeof IMAGE_RUNTIME_FUNCTION_ENTRY
                // AND within the bounds of the PdataSize.  It's supposed to be an index into the
                // pdata data that descibes the real scoping function.

                LONG PrologAddress;
                PrologAddress = (LONG) (ExceptionTable[i].PrologEndAddress - ImageBase - PDataStart);
                if (PrologAddress % sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) {
                    if (fRc != FALSE) {
                        LogPrintf("exception table is corrupt.\n");
                    }
                    LogPrintf("PDATA Entry[%d]: the secondary prolog end address[%8.8x] does not evenly index into the exception table.\n",
                            i,
                            ExceptionTable[i].PrologEndAddress,
                            ExceptionTable[i].BeginAddress,
                            ExceptionTable[i].EndAddress
                            );
                    fRc = FALSE;
                } else {
                    if ((PrologAddress < 0) || (PrologAddress > (LONG)(PDataStart - sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)))) {
                        if (fRc != FALSE) {
                            LogPrintf("exception table is corrupt.\n");
                        }
                        LogPrintf("PDATA Entry[%d]: the secondary prolog end address[%8.8x] does not index into the exception table.\n",
                                i,
                                ExceptionTable[i].PrologEndAddress,
                                ExceptionTable[i].BeginAddress,
                                ExceptionTable[i].EndAddress
                                );
                        fRc = FALSE;
                    }
                }
            } else {
                if (fRc != FALSE) {
                    LogPrintf("exception table is corrupt.\n");
                }
                LogPrintf("PDATA Entry[%d]: the prolog end address[%8.8x] is not within the bounds of the frame [%8.8X] - [%8.8X]\n",
                        i,
                        ExceptionTable[i].PrologEndAddress,
                        ExceptionTable[i].BeginAddress,
                        ExceptionTable[i].EndAddress
                        );
                fRc = FALSE;
            }
        }
#endif // !defined(_IA64_)

        LastEnd = ExceptionTable[i].EndAddress;
    }

    return(fRc);
}

BOOL
ImageNeedsOleSelfRegister(
    PIMAGE_DOS_HEADER DosHeader
    )
/*++

Routine Description:


Arguments:

    PIMAGE_DOS_HEADER   DosHeader

Return Value:

    TRUE if DllRegisterServer or DllUnRegisterServer is exported

--*/
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    DWORD ExportDirectorySize, i;
    USHORT x;
    PCHAR  rvaDelta;
    PULONG NameTable;

    ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
        ImageDirectoryEntryToData(
            DosHeader,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_EXPORT,
            &ExportDirectorySize );

    if (!ExportDirectory ||
        !ExportDirectorySize ||
        !ExportDirectory->NumberOfNames)
    {
        // No exports (no directory, no size, or no names).
        return(FALSE);
    }

    // Walk the section headers and find the va/raw offsets.

    NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)DosHeader + (ULONG)DosHeader->e_lfanew);
    SectionHeader = IMAGE_FIRST_SECTION(NtHeader);

    for (x = 0; x < NtHeader->FileHeader.NumberOfSections; x++) {
        if (((ULONG)((PCHAR)ExportDirectory - (PCHAR)DosHeader) >= SectionHeader->PointerToRawData) &&
            ((ULONG)((PCHAR)ExportDirectory - (PCHAR)DosHeader) <
                   (SectionHeader->PointerToRawData + SectionHeader->SizeOfRawData))) {
            break;
        } else {
            SectionHeader++;
        }
    }

    if (x == NtHeader->FileHeader.NumberOfSections) {
        // We didn't find the section that contained the export table.  Assume it's not there.
        return(FALSE);
    }

    rvaDelta = (PCHAR)DosHeader + SectionHeader->PointerToRawData - SectionHeader->VirtualAddress;

    NameTable = (PULONG)(rvaDelta + ExportDirectory->AddressOfNames);

    for (i = 0; i < ExportDirectory->NumberOfNames; i++) {
        if (!strcmp("DllRegisterServer", rvaDelta + NameTable[i]) ||
            !strcmp("DllUnRegisterServer", rvaDelta + NameTable[i]))
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

//
// support routines for symbol checker - could all
// be done without this using lower-level internal api's
//

PSYMMODLIST
MakeModList(
    HANDLE hProcess
    )
/*++

Routine Description:

    build a list of loaded symbol modules and addresses

Arguments:

    HANDLE hProcess

Return Value:

    PSYMMODLIST

Notes:


--*/
{
    PSYMMODLIST ModList;

    ModList = (PSYMMODLIST)calloc(1, sizeof(SYMMODLIST));
    SymEnumerateModules64(hProcess, SymEnumerateModulesCallback, ModList);

    return(ModList);
}

BOOL
CALLBACK
SymEnumerateModulesCallback(
    LPSTR ModuleName,
    ULONG64 BaseOfDll,
    PVOID UserContext
    )
/*++

Routine Description:

    callback routine for SymEnumerateModules
    in this case, UserContext is a pointer to a head of a _SYMMODLIST struct
    that will have a new item appended
    We are avoiding global state for these lists so we can use several at once,
    they will be short, so we will find the end each time we want to add
    runs slower, simpler to maintain

Arguments:

    LPSTR   ModuleName
    ULONG64 BaseOfDll
    PVOID   UserContext

Return Value:

    TRUE

Notes:


--*/
{
    PSYMMODLIST pSymModList;

    //
    // find end of list, key on pSymModList->ModBase
    //

    pSymModList = (PSYMMODLIST)UserContext;
    while (pSymModList->ModBase)
    {
        pSymModList = pSymModList->Next;
    }

    //
    // append entry
    //

    pSymModList->ModName = malloc(strlen(ModuleName) + 1);
    if (!pSymModList->ModName)
        return FALSE;
    strcpy(pSymModList->ModName, ModuleName);
    pSymModList->ModBase = (void *)BaseOfDll;
    pSymModList->Next = (PSYMMODLIST)calloc(1, sizeof(SYMMODLIST));

    return(TRUE);
}

void *
GetModAddrFromName(
    PSYMMODLIST ModList,
    char *ModName
    )
/*++

Routine Description:

    gets module address from a SYMMODLIST given module base name

Arguments:

    PSYMMODLIST ModList
    char *      ModName

Return Value:

    module address

--*/
{
    while (ModList->Next != 0)
    {
        if (strcmp(ModList->ModName, ModName) == 0)
        {
            break;
        }
        ModList = ModList->Next;
    }

    return(ModList->ModBase);
}

void
FreeModList(
    PSYMMODLIST ModList
    )
/*++

Routine Description:

    free a list of loaded symbol modules and addresses

Arguments:

    PSYMMODLIST ModList

Return Value:

    none

--*/
{
    PSYMMODLIST ModListNext;

    while (ModList)
    {
        if(ModList->ModName)
        {
            free(ModList->ModName);
        }
        ModListNext = ModList->Next;
        free(ModList);
        ModList = ModListNext;
    }
}

pLogListItem LogAppend(
    char *logitem,
    pLogListItem plog
    )
/*++

Routine Description:

    add a log line to the linked list of log lines

Arguments:

    char *  logitem     - a formatted line of text to be logged
    pLogListItem plog   - pointer to LogListItem

Return Value:

    a pointer to the LogListItem allocated
    the first call to this function should save this pointer and use
    it for the head of the list, and it should be used when calling
    LogOutAndClean() to print the list and free all the memory

    you can call this with plog == head of list, or == to last item
    if plog == 0, this means that the item being allocated is the head
    of the list.
    If plog == head of list, search for end of list
    if plog == last item allocated, then the search is much faster

--*/
{
    pLogListItem ptemp;

    ptemp = plog;
    if(plog)
    {
        while(ptemp->Next)
        {
            ptemp = ptemp->Next;
        }
    }

    if(!ptemp)
    {
        ptemp = (pLogListItem)calloc(sizeof(LogListItem), 1);
        if (!ptemp)
            return NULL;
    } else {
        ptemp->Next = (pLogListItem)calloc(sizeof(LogListItem), 1);
        if (!ptemp->Next)
            return NULL;
        ptemp = ptemp->Next;
    }

    ptemp->LogLine = (char *)malloc(strlen(logitem) + 1);
    if (!ptemp->LogLine)
        return NULL;
    strcpy(ptemp->LogLine, logitem);
    return (ptemp);
}

void LogOutAndClean(
    BOOL print
    )
/*++

Routine Description:

    output the log output, and free all the items in the list

Arguments:

    none

Return Value:

    none

--*/
{
    pLogListItem ptemp;
    pLogListItem plog = pLogList;

    while(plog)
    {
        ptemp = plog;
        if(print)
        {
            fprintf(stderr, plog->LogLine);
        }
        plog = plog->Next;
        free(ptemp->LogLine);
        free(ptemp);
    }
    if(print)
    {
        fprintf(stderr, "\n");
    }

    pLogListTmp = pLogList = NULL;

}

void
__cdecl
LogPrintf(
    const char *format,
    ...
    )
/*++

Routine Description:

    logging wrapper for fprintf

Arguments:

    none

Return Value:

    none

--*/
{
    va_list arglist;
    char LogStr[1024];

    va_start(arglist, format);
    vsprintf(LogStr, format, arglist);

    if(pLogList == NULL)
    {
        //
        // initialize log
        //

        pLogListTmp = pLogList = LogAppend(LogStr, NULL);

    } else {

        //
        // append to log
        //

        pLogListTmp = LogAppend(LogStr, pLogListTmp);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\imagehlp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    imagehlp.c

Abstract:

    This function implements a generic simple symbol handler.

Author:

    Wesley Witt (wesw) 1-Sep-1994

Environment:

    User Mode

--*/
#ifdef __cplusplus
extern "C" {
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include "private.h"
#include <globals.h>

#ifdef IMAGEHLP_BUILD
 
 #define HEAP_SIZE 0

 __inline BOOL tlsAlloc()
 {
     return TRUE;
 }

 __inline void tlsFree()
 {
 }

 __inline void tlsMemFree()
 {
 }

#else
 
 #define HEAP_SIZE 0x100000
 
 __inline BOOL tlsAlloc()
 {
     g.tlsIndex = TlsAlloc();
     return (g.tlsIndex == (DWORD)-1) ? FALSE : TRUE;
 }

 __inline void tlsFree()
 {
     if (g.tlsIndex != (DWORD)-1) 
         TlsFree(g.tlsIndex);
 }

 __inline void tlsMemFree()
 {
     PVOID ptls;

     ptls = TlsGetValue(g.tlsIndex);
     MemFree(ptls);
 }

#endif


DWORD
DllMain(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:
        g.hinst = hInstance;
        g.OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&g.OSVerInfo);
        DisableThreadLibraryCalls( hInstance );
        HeapInitList(&g.HeapHeader);
        g.hHeap = HeapCreate(0, HEAP_SIZE, 0);
        if (!tlsAlloc())
            return FALSE;
        return (g.hHeap != NULL); 

    case DLL_PROCESS_DETACH:
        tlsFree();
        HeapDump("DLL_PROCESS_DETACH\n");
        // If this is a process shutdown, don't bother to
        // kill the heap.  The OS will do it for us.  This
        // allows us to be called from other DLLs' DLLMain
        // DLL_PROCESS_DETACH handler.               
        if ( !Context && g.hHeap ) 
            HeapDestroy( g.hHeap );
        break;

    case DLL_THREAD_DETACH:
        tlsMemFree();
        break;
    }

    return TRUE;
}


#ifdef IMAGEHLP_HEAP_DEBUG
BOOL
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    )
{
    CHAR buf[256];
    CHAR ext[4];

    if (!HeapValidate( g.hHeap, 0, MemPtr )) {
        sprintf( buf, "IMAGEHLP: heap corruption - " );
        _splitpath( File, NULL, NULL, &buf[strlen(buf)], ext );
        strcat( buf, ext );
        sprintf( &buf[strlen(buf)], " @ %d\n", Line );
        OutputDebugString( buf );
        PrintAllocations();
        DebugBreak();
        return FALSE;
    }

    return TRUE;
}


BOOL
pHeapDump(
    LPSTR sz,
    ULONG line,
    LPSTR file
    )
{
    BOOL rc;

    if (sz && *sz)
        OutputDebugString(sz);
    rc = CheckHeap(NULL);
    if (rc)
        PrintAllocations();

    return rc;
}
#endif
    

PVOID
pMemReAlloc(
    PVOID OldAlloc,
    ULONG_PTR AllocSize
#ifdef IMAGEHLP_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef IMAGEHLP_HEAP_DEBUG
    PVOID NewAlloc;
    PHEAP_BLOCK hb;
    if (!OldAlloc) {
        return NULL;
    }
    hb = (PHEAP_BLOCK) ((PUCHAR)OldAlloc - sizeof(HEAP_BLOCK));
    if (hb->Signature != HEAP_SIG) {
        OutputDebugString( "IMAGEHLP: Corrupt heap block\n" );
        DebugBreak();
    }
    NewAlloc = pMemAlloc(AllocSize, Line, File);
    if (!NewAlloc)
        return NULL;
    memcpy(NewAlloc, OldAlloc, min(hb->Size, AllocSize));
    RemoveEntryList( &hb->ListEntry );
    g.TotalMemory -= hb->Size;
    g.TotalAllocs -= 1;
    HeapFree( g.hHeap, 0, (PVOID) hb );
    return NewAlloc;
#else
    return(HeapReAlloc(g.hHeap, HEAP_ZERO_MEMORY, OldAlloc, AllocSize));
#endif
}

PVOID
pMemAlloc(
    ULONG_PTR AllocSize
#ifdef IMAGEHLP_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef IMAGEHLP_HEAP_DEBUG
    PHEAP_BLOCK hb;
    CHAR ext[4];
    hb = (PHEAP_BLOCK) HeapAlloc( g.hHeap, HEAP_ZERO_MEMORY, AllocSize + sizeof(HEAP_BLOCK) );
    if (hb) {
        g.TotalMemory += AllocSize;
        g.TotalAllocs += 1;
        InsertTailList( &g.HeapHeader, &hb->ListEntry );
        hb->Signature = HEAP_SIG;
        hb->Size = AllocSize;
        hb->Line = Line;
        _splitpath( File, NULL, NULL, hb->File, ext );
        strcat( hb->File, ext );
        return (PVOID) ((PUCHAR)hb + sizeof(HEAP_BLOCK));
    }
    return NULL;
#else
    return HeapAlloc( g.hHeap, HEAP_ZERO_MEMORY, AllocSize );
#endif
}

VOID
pMemFree(
    PVOID MemPtr
#ifdef IMAGEHLP_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef IMAGEHLP_HEAP_DEBUG
    PHEAP_BLOCK hb;
    if (!MemPtr) {
        return;
    }
    pCheckHeap(NULL, Line, File);
    hb = (PHEAP_BLOCK) ((PUCHAR)MemPtr - sizeof(HEAP_BLOCK));
    if (hb->Signature != HEAP_SIG) {
        OutputDebugString( "IMAGEHLP: Corrupt heap block\n" );
        DebugBreak();
    }
    RemoveEntryList( &hb->ListEntry );
    g.TotalMemory -= hb->Size;
    g.TotalAllocs -= 1;
    HeapFree( g.hHeap, 0, (PVOID) hb );
#else
    if (!MemPtr) {
        return;
    }
    HeapFree( g.hHeap, 0, MemPtr );
#endif
}

ULONG_PTR
pMemSize(
    PVOID MemPtr
    )
{
    return HeapSize(g.hHeap, 0, MemPtr);
}


#ifdef IMAGEHLP_HEAP_DEBUG
VOID
PrintAllocations(
    VOID
    )
{
    PLIST_ENTRY                 Next;
    PHEAP_BLOCK                 hb;
    CHAR                        buf[256];
    LARGE_INTEGER               PerfFreq;


    Next = g.HeapHeader.Flink;
    if (!Next) {
        return;
    }

    OutputDebugString( "-----------------------------------------------------------------------------\n" );
    sprintf( buf, "Memory Allocations for Heap 0x%08x, Allocs=%d, TotalMem=%I64d\n", (ULONG_PTR)g.hHeap, g.TotalAllocs, g.TotalMemory );
    OutputDebugString( buf );
    OutputDebugString( "-----------------------------------------------------------------------------\n" );
    OutputDebugString( "*\n" );

    while ((ULONG_PTR)Next != (ULONG_PTR)&g.HeapHeader) {
        hb = CONTAINING_RECORD( Next, HEAP_BLOCK, ListEntry );
        Next = hb->ListEntry.Flink;
        sprintf( buf, "%8d %16s @ %5d\n", hb->Size, hb->File, hb->Line );
        OutputDebugString( buf );
    }

    OutputDebugString( "*\n" );

    return;
}
#endif

DWORD
ImagepSetLastErrorFromStatus(
    IN DWORD Status
    )
{
    DWORD dwErrorCode;

//    dwErrorCode = RtlNtStatusToDosError( Status );
    dwErrorCode =  Status;
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


/////////////////////////////////////////////////////////////////////////////
/*
******************************************************************************
On a Hydra System, we don't want imaghlp.dll to load user32.dll since it
prevents CSRSS from exiting when running a under a debugger.
The following two functions have been copied from user32.dll so that we don't
link to user32.dll.
******************************************************************************
*/
////////////////////////////////////////////////////////////////////////////


LPSTR CharNext(
    LPCSTR lpCurrentChar)
{
    if (IsDBCSLeadByte(*lpCurrentChar)) {
        lpCurrentChar++;
    }
    /*
     * if we have only DBCS LeadingByte, we will point string-terminaler.
     */

    if (*lpCurrentChar) {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;
}

LPSTR CharPrev(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar)
{
    if (lpCurrentChar > lpStart) {
        LPCSTR lpChar;
        BOOL bDBC = FALSE;

        for (lpChar = --lpCurrentChar - 1 ; lpChar >= lpStart ; lpChar--) {
            if (!IsDBCSLeadByte(*lpChar))
                break;
            bDBC = !bDBC;
        }

        if (bDBC)
            lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
}


void * __cdecl AllocIt(unsigned int cb)
{
    return (MemAlloc(cb));
}

void __cdecl FreeIt(void * p)
{
    MemFree(p);
}

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    LPCSTR name,
    LPSTR outputString,
    DWORD maxStringLength,
    DWORD flags
    )
{
    static HMODULE hMsvcrt = 0;
    static BOOL fLoadMsvcrtDLL = FALSE;
    static PUNDNAME pfUnDname = NULL;
    DWORD rc;

    // this prevents an AV in __unDName

    if (!name) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    //
    // can't undecorate into a zero length buffer
    //
    if (maxStringLength < 2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!fLoadMsvcrtDLL) {
        // The first time we run, see if we can find the system undname.  Use
        // GetModuleHandle to avoid any additionally overhead.

        hMsvcrt = GetModuleHandle("msvcrt.dll");

        if (hMsvcrt) {
            pfUnDname = (PUNDNAME) GetProcAddress(hMsvcrt, "__unDName");
        }
        fLoadMsvcrtDLL = TRUE;
    }

    rc = 0;     // Assume failure

    __try {
        if (pfUnDname) {
            if (flags & UNDNAME_NO_ARGUMENTS) {
                flags |= UNDNAME_NAME_ONLY;
                flags &= ~UNDNAME_NO_ARGUMENTS;
            }

            if (flags & UNDNAME_NO_SPECIAL_SYMS) {
                flags &= ~UNDNAME_NO_SPECIAL_SYMS;
            }
            if (pfUnDname(outputString, name, maxStringLength-1, AllocIt, FreeIt, (USHORT)flags)) {
                rc = strlen(outputString);
            }
        } else {
            rc = strlen(strncpy(outputString, "Unable to load msvcrt!__unDName", maxStringLength));
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (!rc) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return rc;
}

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    HMODULE Module
    )
{
    PIMAGE_DOS_HEADER DosHdr;
    DWORD dwTimeStamp;

    __try {
        DosHdr = (PIMAGE_DOS_HEADER) Module;
        if (DosHdr->e_magic == IMAGE_DOS_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) ((LPBYTE)Module + DosHdr->e_lfanew))->FileHeader.TimeDateStamp;
        } else if (DosHdr->e_magic == IMAGE_NT_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) DosHdr)->FileHeader.TimeDateStamp;
        } else {
            dwTimeStamp = 0;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwTimeStamp = 0;
    }

    return dwTimeStamp;
}


VOID
EnsureTrailingBackslash(
    LPSTR sz
    )
{
    int i;

    assert(sz);

    i = lstrlen(sz);
    if (!i)
        return;

    if (sz[i - 1] == '\\')
        return;

    sz[i] = '\\';
    sz[i + 1] = '\0';
}


#if DBG

VOID
__cdecl
dbPrint(
    LPCSTR fmt,
    ...
    )

/*++

    This function replaces ntdll!DbgPrint().  We need this to keep from linking to
    ntdll so that this library will run on Windows.

--*/

{
    CHAR  text[_MAX_PATH];

    va_list vaList;

    assert(fmt);

    va_start(vaList, fmt);
    vsprintf(text, fmt, vaList);
    va_end(vaList);

    OutputDebugString(text);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\imhlptst.c ===
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>

void __cdecl main(void);
void foo (void);
void foo1(void);
void foo2(void);
void foo3(void);
void WalkTheStack(void);

void TestFindExecutableImage( void );

void __cdecl
main(void)
{
    puts("Entering main");
    foo();

    TestFindExecutableImage();

    puts("Ending main");
}

void
TestFindExecutableImage(
    void
    )
{
    HANDLE Handle;
    CHAR szCorrectName[MAX_PATH];
    CHAR szActualName [MAX_PATH];
    CHAR szTestPath[MAX_PATH];
    CHAR szDrive[_MAX_DRIVE];
    CHAR szDir[_MAX_DIR];
    CHAR *FilePart;
    DWORD ErrorCount = 0;

    _splitpath(_pgmptr, szDrive, szDir, NULL, NULL);

    strcpy(szTestPath, szDrive);
    strcat(szTestPath, szDir);

    GetFullPathName(_pgmptr, MAX_PATH, szCorrectName, &FilePart);

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 1);
        ErrorCount++;
    }

    if (Handle == NULL) {
        printf("ERROR: FindExecutableImage (test %d) failed\n", 1);
        ErrorCount++;
    } else {
        CloseHandle(Handle);
        if (strcmp(szCorrectName, szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) found wrong image.\nExpected: %s\nFound: %s\n", 1, szCorrectName, szActualName);
            ErrorCount++;
        }
    }

    // Test long paths to ExpandPath()
    strcat(szTestPath, ";%path%;%path%;%path%;%path%;%path%;%path%;%path%;%path%");

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 2);
        ErrorCount++;
    }

    if (Handle == NULL) {
        printf("ERROR: FindExecutableImage (test %d) failed\n", 2);
        ErrorCount++;
    } else {
        CloseHandle(Handle);
        if (strcmp(szCorrectName, szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) found wrong image.\nExpected: %s\nFound: %s\n", 2, szCorrectName, szActualName);
            ErrorCount++;
        }
    }

    // Test invalid paths (should return failure)
    szTestPath[0] = '\0';

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 3);
        ErrorCount++;
    }

    if (Handle != NULL) {
        CloseHandle(Handle);
        printf("ERROR: FindExecutableImage (test %d) failed - Expected: <nothing>\nFound: %s\n", 3, szActualName);
        ErrorCount++;
    } else {
        if (strlen(szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) failed to clear ImageName on failure\n", 3);
            ErrorCount++;
        }
    }

    // Test NULL name (should return failure)

    __try {
        Handle = FindExecutableImage(NULL, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 4);
        ErrorCount++;
    }

    if (Handle != NULL) {
        CloseHandle(Handle);
        printf("ERROR: FindExecutableImage (test %d) failed - Expected: <nothing>\nFound: %s\n", 4, szActualName);
        ErrorCount++;
    } else {
        if (strlen(szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) failed to clear ImageName on failure\n", 4);
            ErrorCount++;
        }
    }

    // Valid name and path, invalid end result.

    strcpy(szTestPath, szDrive);
    strcat(szTestPath, szDir);

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 5);
        ErrorCount++;
    }

    if (Handle != NULL) {
        CloseHandle(Handle);
        printf("ERROR: FindExecutableImage (test %d) failed - Supposed to fail if filepath is invalid\n", 5);
        ErrorCount++;
    }

    printf("FindExecutableImage - %s\n", ErrorCount ? "Failed" : "Passed");

    return;
}


void foo(void) {
    puts("Entering foo");
    foo1();
    puts("Ending foo");
}

void foo1(void) {
    puts("Entering foo1");
    foo2();
    puts("Ending foo1");
}

void foo2(void) {
    puts("Entering foo2");
    foo3();
    puts("Ending foo2");
}

void foo3(void) {
    puts("Entering foo3");
    WalkTheStack();
    puts("Ending foo2");
}

void
WalkTheStack(){

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\globals.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This module implements all global variables used in dbghelp.dll

Author:

    Pat Styles (patst) 14-July-2000

Revision History:

--*/

#ifdef GLOBALS
#include <private.h>
#include <symbols.h>
#endif

typedef struct {
    HINSTANCE                       hinst;
    HANDLE                          hHeap;
    DWORD                           tlsIndex;
#ifdef IMAGEHLP_HEAP_DEBUG
    LIST_ENTRY                      HeapHeader;
    ULONG_PTR                       TotalMemory;
    ULONG                           TotalAllocs;
#endif
    OSVERSIONINFO                   OSVerInfo;
    API_VERSION                     ApiVersion;
    API_VERSION                     AppVersion;
    ULONG                           MachineType;
#ifdef BUILD_DBGHELP
    HINSTANCE                       hSrv;
    CHAR                            szSrvName[_MAX_PATH * 2];
    LPSTR                           szSrvParams;
    PSYMBOLSERVERPROC               fnSymbolServer;
    PSYMBOLSERVERCLOSEPROC          fnSymbolServerClose;
    PSYMBOLSERVERSETOPTIONSPROC     fnSymbolServerSetOptions;
    DWORD                           cProcessList;
    LIST_ENTRY                      ProcessList;
    BOOL                            SymInitialized;
    DWORD                           SymOptions;
    ULONG                           LastSymLoadError;
    char                            DebugToken[MAX_SYM_NAME + 1];
    PREAD_PROCESS_MEMORY_ROUTINE    ImagepUserReadMemory32;
    PFUNCTION_TABLE_ACCESS_ROUTINE  ImagepUserFunctionTableAccess32;
    PGET_MODULE_BASE_ROUTINE        ImagepUserGetModuleBase32;
    PTRANSLATE_ADDRESS_ROUTINE      ImagepUserTranslateAddress32;
#endif
} GLOBALS, *PGLOBALS;

typedef struct {
    DWORD                           tid;
#ifdef BUILD_DBGHELP
    PREAD_PROCESS_MEMORY_ROUTINE    ImagepUserReadMemory32;
    PFUNCTION_TABLE_ACCESS_ROUTINE  ImagepUserFunctionTableAccess32;
    PGET_MODULE_BASE_ROUTINE        ImagepUserGetModuleBase32;
    PTRANSLATE_ADDRESS_ROUTINE      ImagepUserTranslateAddress32;
    IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY AlphaFunctionEntry64;
    BOOL                            DebugFunctionEntries;
    class Ia64FunctionEntryCache*   Ia64FunctionEntries;
    class Amd64FunctionEntryCache*  Amd64FunctionEntries;
    class Axp32FunctionEntryCache*  Axp32FunctionEntries;
    class Axp64FunctionEntryCache*  Axp64FunctionEntries;
    IMAGE_IA64_RUNTIME_FUNCTION_ENTRY Ia64FunctionEntry;
    _IMAGE_RUNTIME_FUNCTION_ENTRY   Amd64FunctionEntry;
    IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY Axp64FunctionEntry;
    IMAGE_FUNCTION_ENTRY            FunctionEntry32;
    IMAGE_FUNCTION_ENTRY64          FunctionEntry64;
    VWNDIA64_UNWIND_CONTEXT         UnwindContext[VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE];
    UINT                            UnwindContextNew;
#endif
} TLS, *PTLS;


extern GLOBALS g;

extern PTLS GetTlsPtr(void);
#define tlsvar(a) (GetTlsPtr()->a)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\impchk.cxx ===
#include <windows.h>
#include <winnt.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>

LOADED_IMAGE Image;

int __cdecl CompareNames (const void *pv1, const void *pv2)
{
    return(strcmp((const char *)pv1, *(const char **)pv2));
}

char *rgszBetaAPIs[] = {
    "ABProviderInit",
    "AddInksetInterval",
    "AddPenDataHRC",
    "AddPenInputHRC",
    "AddPointsPenData",
    "AddPropertySheet",
    "AddWordsHWL",
    "AnimateProc",
    "AssociateProperties",
    "AtomicVirtualEvent",
    "BeginEnumStrokes",
    "BoundingRectFromPoints",
    "BroadcastSystemMessage",
    "BrowseCallbackProc",
    "BuildDisplayTable",
    "CallWndRetProc",
    "CascadeWindows",
    "ChangeIdleRoutine",
    "CharacterToSymbol",
    "CheckColorsInGamut",
    "CheckMenuRadioItem",
    "CheckParameters",
    "CloseIMsgSession",
    "CloseProperties",
    "ColorMatchToTarget",
    "CommConfigDialog",
    "CompactPenData",
    "CompressPenData",
    "ConfigHREC",
    "ConfigRecognizer",
    "CopyImage",
    "CorrectWriting",
    "CorrectWritingEx",
    "CreateColorSpace",
    "CreateCompatibleHRC",
    "CreateHWL",
    "CreateIProp",
    "CreateIconFromResourceEx",
    "CreateInkset",
    "CreateInksetHRCRESULT",
    "CreatePenData",
    "CreatePenDataEx",
    "CreatePenDataHRC",
    "CreatePenDataRegion",
    "CreateTable",
    "CreateToolhelp32Snapshot",
    "DPtoTP",
    "DeleteColorSpace",
    "DeregisterIdleRoutine",
    "DestroyHRC",
    "DestroyHRCRESULT",
    "DestroyHWL",
    "DestroyInkset",
    "DestroyPenData",
    "DictionarySearch",
    "DisplayGuesses",
    "DoDefaultPenInput",
    "DrawAnimatedRects",
    "DrawArrow",
    "DrawCaption",
    "DrawMirrorImage",
    "DrawPenData",
    "DrawPenDataEx",
    "DrawPenDataFmt",
    "DrawState",
    "DrawStateProc",
    "DrawTextEx",
    "DuplicatePenData",
    "EditProperties",
    "EmulatePen",
    "EnableGestureSetHRC",
    "EnableIdleRoutine",
    "EnableSystemDictionaryHRC",
    "EndEnumStrokes",
    "EndPenInputHRC",
    "EnumFontFamExProc",
    "EnumFontFamiliesEx",
    "EnumICMProfiles",
    "EnumICMProfilesProc",
    "EnumProperties",
    "EnumPropertyLibs",
    "EnumPropertySheets",
    "EnumRegisterWordProc",
    "EnumSymbols",
    "EnumSymbolsCallback",
    "ExtractPenDataPoints",
    "ExtractPenDataStrokes",
    "FAbsTimeInInterval",
    "FBadColumnSet",
    "FBadEntryList",
    "FBadProp",
    "FBadPropTag",
    "FBadRestriction",
    "FBadRglpNameID",
    "FBadRglpszW",
    "FBadRow",
    "FBadRowSet",
    "FBadSortOrderSet",
    "FBinFromHex",
    "FEQAbsTime",
    "FEqualNames",
    "FIntervalInInterval",
    "FIntervalXInterval",
    "FLEAbsTime",
    "FLTAbsTime",
    "FPropCompareProp",
    "FPropContainsProp",
    "FPropExists",
    "FindWindowEx",
    "FirstSymbolFromGraph",
    "FlushProperties",
    "FreeImageColorMatcher",
    "FreePadrlist",
    "FreePropertyLib",
    "FreePropertySheets",
    "FreeProws",
    "FtAddFt",
    "FtMulDw",
    "FtMulDwDw",
    "FtNegFt",
    "FtSubFt",
    "FtgRegisterIdleRoutine",
    "GetAlphabetHRC",
    "GetAlphabetPriorityHRC",
    "GetAlternateWordsHRCRESULT",
    "GetAttribIMsgOnIStg",
    "GetBoxMappingHRCRESULT",
    "GetBoxResultsHRC",
    "GetCharacterPlacement",
    "GetClassInfoEx",
    "GetColorSpace",
    "GetCommConfig",
    "GetDefaultCommConfig",
    "GetDeviceGammaRamp",
    "GetFontLanguageInfo",
    "GetGlobalRC",
    "GetGuideHRC",
    "GetHRECFromHRC",
    "GetHotspotsHRCRESULT",
    "GetICMProfile",
    "GetInksetInterval",
    "GetInksetIntervalCount",
    "GetInstance",
    "GetInternationalHRC",
    "GetKeyboardLayout",
    "GetKeyboardLayoutList",
    "GetLogColorSpace",
    "GetMaxResultsHRC",
    "GetMenuDefaultItem",
    "GetMenuItemInfo",
    "GetMenuItemRect",
    "GetPenAppFlags",
    "GetPenAsyncState",
    "GetPenDataAttributes",
    "GetPenDataInfo",
    "GetPenDataStroke",
    "GetPenHwEventData",
    "GetPenInput",
    "GetPenMiscInfo",
    "GetPenResource",
    "GetPointsFromPenData",
    "GetProperties",
    "GetResultsHRC",
    "GetStrokeAttributes",
    "GetStrokeTableAttributes",
    "GetSymbolCount",
    "GetSymbolCountHRCRESULT",
    "GetSymbolMaxLength",
    "GetSymbolsHRCRESULT",
    "GetSysColorBrush",
    "GetSystemPowerStatus",
    "GetTextCharsetInfo",
    "GetVersionPenWin",
    "GetWordlistCoercionHRC",
    "GetWordlistHRC",
    "HPProviderInit",
    "Heap32First",
    "Heap32ListFirst",
    "Heap32ListNext",
    "Heap32Next",
    "HexFromBin",
    "HitTestPenData",
    "HrAddColumnsEx",
    "HrAllocAdviseSink",
    "HrComposeEID",
    "HrComposeMsgID",
    "HrDecomposeEID",
    "HrDecomposeMsgID",
    "HrEntryIDFromSz",
    "HrGetOneProp",
    "HrIStorageFromStream",
    "HrQueryAllRows",
    "HrSetOneProp",
    "HrSzFromEntryID",
    "HrThisThreadAdviseSink",
    "HrValidateIPMSubtree",
    "ImmAssociateContext",
    "ImmConfigureIME",
    "ImmCreateContext",
    "ImmDestroyContext",
    "ImmEnumRegisterWord",
    "ImmEscape",
    "ImmGetCandidateList",
    "ImmGetCandidateListCount",
    "ImmGetCandidateWindow",
    "ImmGetCompositionFont",
    "ImmGetCompositionString",
    "ImmGetCompositionWindow",
    "ImmGetContext",
    "ImmGetConversionList",
    "ImmGetConversionStatus",
    "ImmGetDefaultIMEWnd",
    "ImmGetDescription",
    "ImmGetGuideLine",
    "ImmGetIMEFileName",
    "ImmGetOpenStatus",
    "ImmGetProperty",
    "ImmGetRegisterWordStyle",
    "ImmGetStatusWindowPos",
    "ImmGetVirtualKey",
    "ImmInstallIME",
    "ImmIsIME",
    "ImmIsUIMessage",
    "ImmNotifyIME",
    "ImmRegisterWord",
    "ImmReleaseContext",
    "ImmSetCandidateWindow",
    "ImmSetCompositionFont",
    "ImmSetCompositionString",
    "ImmSetCompositionWindow",
    "ImmSetConversionStatus",
    "ImmSetOpenStatus",
    "ImmSetStatusWindowPos",
    "ImmSimulateHotKey",
    "ImmUnregisterWord",
    "InfoWndProc",
    "InitRC",
    "InputWndProc",
    "InsertMenuItem",
    "InsertPenData",
    "InsertPenDataPoints",
    "InsertPenDataStroke",
    "InstallRecognizer",
    "IsPenAware",
    "IsPenEvent",
    "KKConvert",
    "LPropCompareProp",
    "LaunchWizard",
    "LoadImage",
    "LoadImageColorMatcher",
    "LoadPropertyLib",
    "LoadPropertySheets",
    "LookupIconIdFromDirectoryEx",
    "MAPIAddress",
    "MAPIAdminProfiles",
    "MAPIAllocateBuffer",
    "MAPIAllocateMore",
    "MAPIDeInitIdle",
    "MAPIDeleteMail",
    "MAPIDetails",
    "MAPIFindNext",
    "MAPIFreeBuffer",
    "MAPIGetDefaultMalloc",
    "MAPIInitIdle",
    "MAPIInitialize",
    "MAPILogoff",
    "MAPILogon",
    "MAPILogonEx",
    "MAPIMessage",
    "MAPIOpenFormMgr",
    "MAPIOpenLocalFormContainer",
    "MAPIReadMail",
    "MAPIRecip",
    "MAPIResolveName",
    "MAPISaveMail",
    "MAPISendDocuments",
    "MAPISendMail",
    "MAPIUnintialize",
    "MSProviderInit",
    "MakeAbsTime",
    "MapStorageSCode",
    "MapVirtualKeyEx",
    "MapiFile",
    "MapiFileDesc",
    "MapiFileTagExt",
    "MapiMessage",
    "MapiRecipDesc",
    "MenuItemFromPoint",
    "MessageBoxIndirect",
    "MetricScalePenData",
    "Module32First",
    "Module32Next",
    "OffsetPenData",
    "OpenIMsgOnIStg",
    "OpenIMsgOnIStorage",
    "OpenIMsgSession",
    "OpenProperties",
    "OpenStreamOnFile",
    "OpenTnefStream",
    "OpenTnefStreamEx",
    "PPChangePassword",
    "PPGetPasswordStatus",
    "PaintDesktop",
    "PeekPenInput",
    "PenDataFromBuffer",
    "PenDataToBuffer",
    "PostVirtualKeyEvent",
    "PostVirtualMouseEvent",
    "PpropFindProp",
    "PreprocessMessage",
    "Process32First",
    "Process32Next",
    "ProcessHRC",
    "ProcessWriting",
    "PropCopyMore",
    "PwdChangePassword",
    "PwdGetPasswordStatus",
    "PwdSetPasswordStatus",
    "RTFSync",
    "RawWndProc",
    "ReadHWL",
    "Recognize",
    "RecognizeData",
    "RedisplayPenData",
    "RegisterClassEx",
    "RegisterPenApp",
    "RemovePenDataStrokes",
    "RemovePreprocessInfo",
    "RemovePropertySheet",
    "ResizePenData",
    "ResultsHookHREC",
    "SAVEOPTS",
    "SAndRestriction",
    "SAppTimeArray",
    "SBinary",
    "SBinaryArray",
    "SBitMaskRestriction",
    "SCommentRestriction",
    "SComparePropsRestriction",
    "SContentRestriction",
    "SCurrencyArray",
    "SDateTimeArray",
    "SDoubleArray",
    "SExistRestriction",
    "SGuidArray",
    "SHAddToRecentDocs",
    "SHAppBarMessage",
    "SHBrowseForFolder",
    "SHChangeNotify",
    "SHFileOperation",
    "SHFreeNameMappings",
    "SHGetDesktopFolder",
    "SHGetFileInfo",
    "SHGetInstanceExplorer",
    "SHGetMalloc",
    "SHGetNameMappingCount",
    "SHGetNameMappingPtr",
    "SHGetPathFromIDList",
    "SHGetSpecialFolderLocation",
    "SHLoadInProc",
    "SLPSTRArray",
    "SLargeIntegerArray",
    "SLongArray",
    "SMAPIFormInfoArray",
    "SMAPIFormProp",
    "SMAPIFormPropArray",
    "SMAPIFormPropEnumVal",
    "SMAPIVerb",
    "SMAPIVerbArray",
    "SMessageClassArray",
    "SNotRestriction",
    "SOBailOut",
    "SOBeginTable",
    "SOEndColumnInfo",
    "SOEndFieldInfo",
    "SOEndFontTable",
    "SOEndPalette",
    "SOEndTabStops",
    "SOEndTable",
    "SOGetInfo",
    "SOGetScanLineBuffer",
    "SOPutBitmapHeader",
    "SOPutBreak",
    "SOPutChar",
    "SOPutCharAttr",
    "SOPutCharFontById",
    "SOPutCharFontByName",
    "SOPutCharHeight",
    "SOPutCharX",
    "SOPutColumnInfo",
    "SOPutDataCell",
    "SOPutEmbeddedObject",
    "SOPutField",
    "SOPutFieldInfo",
    "SOPutFontTableEntry",
    "SOPutHdrEntry",
    "SOPutMoreText",
    "SOPutMoreVarField",
    "SOPutPaletteEntry",
    "SOPutParaAlign",
    "SOPutParaIndents",
    "SOPutParaMargins",
    "SOPutParaSpacing",
    "SOPutScanLineData",
    "SOPutSectionName",
    "SOPutSectionType",
    "SOPutSpecialCharX",
    "SOPutSubdocInfo",
    "SOPutTabStop",
    "SOPutTableCellInfo",
    "SOPutTableRowFormat",
    "SOPutTextCell",
    "SOPutVarField",
    "SOPutVectorHeader",
    "SOSetDateBase",
    "SOStartColumnInfo",
    "SOStartFieldInfo",
    "SOStartFontTable",
    "SOStartPalette",
    "SOStartTabStops",
    "SOVectorAttr",
    "SOVectorObject",
    "SOrRestriction",
    "SPropAttrArray",
    "SPropProblem",
    "SPropProblemArray",
    "SPropTagArray",
    "SPropValue",
    "SPropertyRestriction",
    "SRealArray",
    "SRestriction",
    "SRow",
    "SRowSet",
    "SShortArray",
    "SSizeRestriction",
    "SSortOrder",
    "SSortOrderSet",
    "SSubRestriction",
    "STnefProblem",
    "STnefProblemArray",
    "SUUserPopData",
    "SUUserPushData",
    "SUUserRetrieveData",
    "SUUserSaveData",
    "SWStringArray",
    "ScBinFromHexBounded",
    "ScCopyNotifications",
    "ScCopyProps",
    "ScCountNotifications",
    "ScCountProps",
    "ScDupPropset",
    "ScLocalPathFromUNC",
    "ScRelocNotifications",
    "ScRelocProps",
    "ScUNCFromLocalPath",
    "SetAlphabetHRC",
    "SetAlphabetPriorityHRC",
    "SetAttribIMsgOnIStg",
    "SetBoxAlphabetHRC",
    "SetColorSpace",
    "SetCommConfig",
    "SetDefaultCommConfig",
    "SetDeviceGammaRamp",
    "SetGlobalRC",
    "SetGuideHRC",
    "SetICMMode",
    "SetICMProfile",
    "SetInternationalHRC",
    "SetMaxResultsHRC",
    "SetMenuDefaultItem",
    "SetMenuItemInfo",
    "SetMessageExtraInfo",
    "SetPenAppFlags",
    "SetPenHook",
    "SetPenHookCallback",
    "SetPenMiscInfo",
    "SetProperties",
    "SetRecogHook",
    "SetResultsHookHREC",
    "SetStrokeAttributes",
    "SetStrokeTableAttributes",
    "SetSystemPowerState",
    "SetWordlistCoercionHRC",
    "SetWordlistHRC",
    "Shell_NotifyIcon",
    "ShowKeyboard",
    "ShowWindowAsync",
    "StartInking",
    "StartPenInput",
    "StopInking",
    "StopPenInput",
    "SymbolToCharacter",
    "TPtoDP",
    "TargetPoints",
    "Thread32First",
    "Thread32Next",
    "TileWindows",
    "ToAsciiEx",
    "Toolhelp32ReadProcessMemory",
    "TrackPopupMenuEx",
    "TrainContext",
    "TrainHREC",
    "TrainInk",
    "TranslateCharsetInfo",
    "TrimPenData",
    "UnhookResultsHookHREC",
    "UninstallRecognizer",
    "UpdatePenInfo",
    "ValidateParameters",
    "VkKeyScanEx",
    "VwStreamCloseFunc",
    "VwStreamOpenFunc",
    "VwStreamReadFunc",
    "VwStreamReadRecordFunc",
    "VwStreamSectionFunc",
    "VwStreamSeekFunc",
    "VwStreamTellFunc",
    "WrapCompressedRTFStream",
    "WrapStoreEntryID",
    "WriteHWL",
    "XPProviderInit",
    "attAttachRenddata",
    "attConversationID",
    "attFrom",
    "attMAPIProps",
    "attMessageStatus",
    "attOriginalMessageClass",
    "attOwner",
    "attParentID",
    "attPriority",
    "attRecipTable",
    "attSentFor",
    "dwDiffAT",
    "dwDurInterval",
    "lineAccept",
    "lineAddProvider",
    "lineAddToConference",
    "lineAnswer",
    "lineBlindTransfer",
    "lineCallbackFunc",
    "lineClose",
    "lineCompleteCall",
    "lineCompleteTransfer",
    "lineConfigDialog",
    "lineConfigDialogEdit",
    "lineConfigProvider",
    "lineDeallocateCall",
    "lineDevSpecific",
    "lineDevSpecificFeature",
    "lineDial",
    "lineDrop",
    "lineForward",
    "lineGatherDigits",
    "lineGenerateDigits",
    "lineGenerateTone",
    "lineGetAddressCaps",
    "lineGetAddressID",
    "lineGetAddressStatus",
    "lineGetAppPriority",
    "lineGetCallInfo",
    "lineGetCallStatus",
    "lineGetConfRelatedCalls",
    "lineGetCountry",
    "lineGetDevCaps",
    "lineGetDevConfig",
    "lineGetID",
    "lineGetIcon",
    "lineGetLineDevStatus",
    "lineGetNewCalls",
    "lineGetNumRings",
    "lineGetProviderList",
    "lineGetRequest",
    "lineGetStatusMessages",
    "lineGetTranslateCaps",
    "lineHandoff",
    "lineHold",
    "lineInitialize",
    "lineMakeCall",
    "lineMonitorDigits",
    "lineMonitorMedia",
    "lineMonitorTones",
    "lineNegotiateAPIVersion",
    "lineNegotiateExtVersion",
    "lineOpen",
    "linePark",
    "linePickup",
    "linePrepareAddToConference",
    "lineRedirect",
    "lineRegisterRequestRecipient",
    "lineReleaseUserUserInfo",
    "lineRemoveFromConference",
    "lineRemoveProvider",
    "lineSecureCall",
    "lineSendUserUserInfo",
    "lineSetAppPriority",
    "lineSetAppSpecific",
    "lineSetCallParams",
    "lineSetCallPrivilege",
    "lineSetCurrentLocation",
    "lineSetDevConfig",
    "lineSetMediaControl",
    "lineSetMediaMode",
    "lineSetNumRings",
    "lineSetStatusMessages",
    "lineSetTerminal",
    "lineSetTollList",
    "lineSetupConference",
    "lineSetupTransfer",
    "lineShutdown",
    "lineSwapHold",
    "lineTranslateAddress",
    "lineTranslateDialog",
    "lineUncompleteCall",
    "lineUnhold",
    "lineUnpark",
    "phoneCallbackFunc",
    "phoneClose",
    "phoneConfigDialog",
    "phoneDevSpecific",
    "phoneGetButtonInfo",
    "phoneGetData",
    "phoneGetDevCaps",
    "phoneGetDisplay",
    "phoneGetGain",
    "phoneGetHookSwitch",
    "phoneGetID",
    "phoneGetIcon",
    "phoneGetLamp",
    "phoneGetRing",
    "phoneGetStatus",
    "phoneGetStatusMessages",
    "phoneGetVolume",
    "phoneInitialize",
    "phoneNegotiateAPIVersion",
    "phoneNegotiateExtVersion",
    "phoneOpen",
    "phoneSetButtonInfo",
    "phoneSetData",
    "phoneSetDisplay",
    "phoneSetGain",
    "phoneSetHookSwitch",
    "phoneSetLamp",
    "phoneSetRing",
    "phoneSetStatusMessages",
    "phoneSetVolume",
    "phoneShutdown",
    "tapiGetLocationInfo",
    "tapiRequestDrop",
    "tapiRequestMakeCall",
    "tapiRequestMediaCall",
    "ulValidateParameters"
};

BOOL
VerifyImageImports(
    char *ImageName
    );

void __cdecl
main(
    int argc,
    char *argv[]
    )
{
    int i;
    if (argc < 2 ||
        (((argv[1][0] == '/') || (argv[1][0] == '-')) &&
         (argv[1][1] == '?'))) {
        puts("Usage: impchk <imagename>\n"
             "   where <imagename> is the image you want to check for beta API's");
    } else {
        i = 0;
        while (argc > 1) {
            argc--;
            i++;
            printf("Image: \"%s\" should %s marked as Beta\n",
                    argv[i],
                    VerifyImageImports(argv[i]) ? "be" : "not be");
        }
    }
}

BOOL
VerifyImageImports(
    char *ImageName
    )
{
    PIMAGE_IMPORT_DESCRIPTOR Imports;
    PIMAGE_THUNK_DATA tname;
    PIMAGE_THUNK_DATA ThunkNames;
    PIMAGE_IMPORT_BY_NAME ImportName;
    ULONG NumberOfThunks;
    ULONG i, cb;
    UCHAR NameBuffer[ 32 ];
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG ImportSize;
    LPSTR ImportModule;
    BOOL rc = FALSE;

    if (MapAndLoad(ImageName, ".", &Image, TRUE, TRUE)) {
        Image.ModuleName = ImageName;

        //
        // Now locate and walk through and process the images imports
        //

        NtHeaders = ImageNtHeader( (PVOID)Image.MappedAddress );
        if (NtHeaders != NULL) {

            Imports = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
                                                    (PVOID)Image.MappedAddress,
                                                    FALSE,
                                                    IMAGE_DIRECTORY_ENTRY_IMPORT,
                                                    &ImportSize
                                                    );
            for(;Imports;Imports++) {
                if (!Imports->Name) {
                    break;
                }

                ImportModule = (LPSTR) ImageRvaToVa( (PIMAGE_NT_HEADERS) Image.FileHeader,
                                            Image.MappedAddress,
                                            (ULONG) Imports->Name,
                                            &Image.LastRvaSection);

                if (ImportModule) {

                    ThunkNames = (PIMAGE_THUNK_DATA) ImageRvaToVa(
                                    (PIMAGE_NT_HEADERS)Image.FileHeader,
                                    Image.MappedAddress,
                                    (ULONG) Imports->OriginalFirstThunk,
                                    &Image.LastRvaSection);

                    if (!ThunkNames || ThunkNames->u1.Function == 0) {
                        //
                        // Skip this one if no thunks or first thunk is the terminating null thunk
                        //
                        continue;
                    }

                    //
                    NumberOfThunks = 0;
                    tname = ThunkNames;
                    while (tname->u1.AddressOfData) {
                        NumberOfThunks++;
                        tname++;
                    }

                    tname = ThunkNames;
                    for(i=0;i<NumberOfThunks;i++) {
                        if (!(BOOL)IMAGE_SNAP_BY_ORDINAL(tname->u1.Ordinal)) {
                            ImportName = (PIMAGE_IMPORT_BY_NAME)
                                    ImageRvaToVa((PIMAGE_NT_HEADERS)Image.FileHeader,
                                                 Image.MappedAddress,
                                                 (ULONG)(ULONG_PTR) tname->u1.AddressOfData,
                                                 &Image.LastRvaSection);
                            if (bsearch(ImportName->Name,
                                        rgszBetaAPIs,
                                        sizeof(rgszBetaAPIs) / sizeof(char *),
                                        sizeof(char *),
                                        CompareNames
                                       )) {
                                printf("%s: Imports \"%s\" from \"%s\"\n",
                                        ImageName,
                                        ImportName->Name,
                                        ImportModule);
                                rc = TRUE;
                            }
                        }

                        tname++;
                    }
                }
            }
        }

        UnMapAndLoad(&Image);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\map.c ===
/*++

Copyright (c) 1994-96  Microsoft Corporation

Module Name:

    map.c

Abstract:
    Implementation for the MapAndLoad API

Author:

Revision History:

--*/

#include <private.h>
#include <globals.h>

BOOL
MapAndLoad(
    LPSTR ImageName,
    LPSTR DllPath,
    PLOADED_IMAGE LoadedImage,
    BOOL DotDll,
    BOOL ReadOnly
    )
{
    HANDLE hFile;
    HANDLE hMappedFile;
    CHAR SearchBuffer[MAX_PATH];
    DWORD dw;
    LPSTR FilePart;
    LPSTR OpenName;

    // open and map the file.
    // then fill in the loaded image descriptor

    LoadedImage->hFile = INVALID_HANDLE_VALUE;

    OpenName = ImageName;
    dw = 0;
retry:
    hFile = CreateFile(
                OpenName,
                ReadOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
                g.OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE) : (FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );


    if ( hFile == INVALID_HANDLE_VALUE ) {
        if ( !dw ) {
            //
            // open failed try to find the file on the search path
            //

            dw =   SearchPath(
                    DllPath,
                    ImageName,
                    DotDll ? ".dll" : ".exe",
                    MAX_PATH,
                    SearchBuffer,
                    &FilePart
                    );
            if ( dw && dw < MAX_PATH ) {
                OpenName = SearchBuffer;
                goto retry;
            }
        }
        return FALSE;
    }

    if (MapIt(hFile, LoadedImage, ReadOnly) == FALSE) {
        CloseHandle(hFile);
        return FALSE;
    } else {
        LoadedImage->ModuleName = (LPSTR) MemAlloc( strlen(OpenName)+16 );
        if (!LoadedImage->ModuleName) {
            return FALSE;
        }
        strcpy( LoadedImage->ModuleName, OpenName );

        // If readonly, no need to keep the file open..

        if (ReadOnly) {
            CloseHandle(hFile);
        }

        return TRUE;
    }
}


BOOL
MapIt(
    HANDLE hFile,
    PLOADED_IMAGE LoadedImage,
    BOOL   ReadOnly
    )
{
    HANDLE hMappedFile;

    hMappedFile = CreateFileMapping(
                    hFile,
                    NULL,
                    ReadOnly ? PAGE_READONLY : PAGE_READWRITE,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        return FALSE;
    }

    LoadedImage->MappedAddress = (PUCHAR) MapViewOfFile(
                                    hMappedFile,
                                    ReadOnly ? FILE_MAP_READ : FILE_MAP_WRITE,
                                    0,
                                    0,
                                    0
                                    );

    CloseHandle(hMappedFile);

    LoadedImage->SizeOfImage = GetFileSize(hFile, NULL);

    if (!LoadedImage->MappedAddress ||
        !CalculateImagePtrs(LoadedImage)) {
        return(FALSE);
    }

    if (ReadOnly) {
        LoadedImage->hFile = INVALID_HANDLE_VALUE;
    } else {
        LoadedImage->hFile = hFile;
    }

    return(TRUE);
}


BOOL
CalculateImagePtrs(
    PLOADED_IMAGE LoadedImage
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_FILE_HEADER FileHeader;
    BOOL fRC;

    // Everything is mapped. Now check the image and find nt image headers

    fRC = TRUE;  // Assume the best

    __try {
        DosHeader = (PIMAGE_DOS_HEADER)LoadedImage->MappedAddress;

        if ((DosHeader->e_magic != IMAGE_DOS_SIGNATURE) &&
            (DosHeader->e_magic != IMAGE_NT_SIGNATURE)) {
            fRC = FALSE;
            goto tryout;
        }

        if (DosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
            if (DosHeader->e_lfanew == 0) {
                LoadedImage->fDOSImage = TRUE;
                fRC = FALSE;
                goto tryout;
            }
            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

            if (
                // If IMAGE_NT_HEADERS would extend past the end of file...
                (PBYTE)LoadedImage->FileHeader + sizeof(IMAGE_NT_HEADERS) >
                    (PBYTE)LoadedImage->MappedAddress + LoadedImage->SizeOfImage ||

                 // ..or if it would begin in, or before the IMAGE_DOS_HEADER...
                     (PBYTE)LoadedImage->FileHeader <
                      (PBYTE)LoadedImage->MappedAddress + sizeof(IMAGE_DOS_HEADER)  )
            {
                // ...then e_lfanew is not as expected.
                // (Several Win95 files are in this category.)
                fRC = FALSE;
                goto tryout;
            }
        } else {

            // No DOS header indicates an image built w/o a dos stub

            LoadedImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader);
        }

        NtHeaders = LoadedImage->FileHeader;

        if ( NtHeaders->Signature != IMAGE_NT_SIGNATURE ) {
            if ( (USHORT)NtHeaders->Signature == (USHORT)IMAGE_OS2_SIGNATURE ||
                 (USHORT)NtHeaders->Signature == (USHORT)IMAGE_OS2_SIGNATURE_LE
               ) {
                LoadedImage->fDOSImage = TRUE;
            }

            fRC = FALSE;
            goto tryout;
        } else {
            LoadedImage->fDOSImage = FALSE;
        }

        FileHeader = &NtHeaders->FileHeader;

        // No optional header indicates an object...

        if ( FileHeader->SizeOfOptionalHeader == 0 ) {
            fRC = FALSE;
            goto tryout;
        }

        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            // 32-bit image.  Do some tests.
            if (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase >= 0x80000000) {
                LoadedImage->fSystemImage = TRUE;
            } else {
                LoadedImage->fSystemImage = FALSE;
            }

            if (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.MajorLinkerVersion < 3 &&
                ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.MinorLinkerVersion < 5)
            {
                fRC = FALSE;
                goto tryout;
            }

        } else {
            LoadedImage->fSystemImage = FALSE;
        }

        LoadedImage->Sections = IMAGE_FIRST_SECTION(NtHeaders);

        InitializeListHead( &LoadedImage->Links );
        LoadedImage->Characteristics = FileHeader->Characteristics;
        LoadedImage->NumberOfSections = FileHeader->NumberOfSections;
        LoadedImage->LastRvaSection = LoadedImage->Sections;

tryout:
        if (fRC == FALSE) {
            UnmapViewOfFile(LoadedImage->MappedAddress);
            SetLastError(ERROR_BAD_FORMAT);
        }

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {
        fRC = FALSE;
    }

    return fRC;
}

BOOL
UnMapAndLoad(
    PLOADED_IMAGE pLi
    )
{
    UnMapIt(pLi);

    if (pLi->hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(pLi->hFile);
    }

    return TRUE;
}

BOOL
GrowMap (
    PLOADED_IMAGE   pLi,
    LONG            lSizeOfDelta
    )
{
    if (pLi->hFile == INVALID_HANDLE_VALUE) {
        // Can't grow read/only files.
        return FALSE;
    } else {
        HANDLE hMappedFile;
        FlushViewOfFile(pLi->MappedAddress, pLi->SizeOfImage);
        UnmapViewOfFile(pLi->MappedAddress);

        pLi->SizeOfImage += lSizeOfDelta;

        SetFilePointer(pLi->hFile, pLi->SizeOfImage, NULL, FILE_BEGIN);
        SetEndOfFile(pLi->hFile);

        hMappedFile = CreateFileMapping(
                        pLi->hFile,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        pLi->SizeOfImage,
                        NULL
                        );
        if ( !hMappedFile ) {
            CloseHandle(pLi->hFile);
            pLi->hFile = INVALID_HANDLE_VALUE;
            return FALSE;
        }

        pLi->MappedAddress = (PUCHAR) MapViewOfFile(
                                        hMappedFile,
                                        FILE_MAP_WRITE,
                                        0,
                                        0,
                                        0
                                        );

        CloseHandle(hMappedFile);

        if (!pLi->MappedAddress) {
            CloseHandle(pLi->hFile);
            pLi->hFile = INVALID_HANDLE_VALUE;
            return(FALSE);
        }

        // Win95 doesn't zero fill when it extends.  Do it here.
        if (lSizeOfDelta > 0) {
            memset(pLi->MappedAddress + pLi->SizeOfImage - lSizeOfDelta, 0, lSizeOfDelta);
        }

        // Recalc the LoadedImage struct (remapping may have changed the map address)
        if (!CalculateImagePtrs(pLi)) {
            CloseHandle(pLi->hFile);
            pLi->hFile = INVALID_HANDLE_VALUE;
            return(FALSE);
        }

        return TRUE;
    }
}


VOID
UnMapIt(
    PLOADED_IMAGE pLi
    )
{
    DWORD HeaderSum, CheckSum;
    BOOL bl;
    DWORD dw;
    PIMAGE_NT_HEADERS NtHeaders;

    // Test for read-only
    if (pLi->hFile == INVALID_HANDLE_VALUE) {
        UnmapViewOfFile(pLi->MappedAddress);
    } else {
        CheckSumMappedFile( pLi->MappedAddress,
                            pLi->SizeOfImage,
                            &HeaderSum,
                            &CheckSum
                          );

        NtHeaders = pLi->FileHeader;

        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
        } else {
            if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
            }
        }

        FlushViewOfFile(pLi->MappedAddress, pLi->SizeOfImage);
        UnmapViewOfFile(pLi->MappedAddress);

        if (pLi->SizeOfImage != GetFileSize(pLi->hFile, NULL)) {
            dw = SetFilePointer(pLi->hFile, pLi->SizeOfImage, NULL, FILE_BEGIN);
            dw = GetLastError();
            bl = SetEndOfFile(pLi->hFile);
            dw = GetLastError();
        }
    }
}


BOOL
GetImageConfigInformation(
    PLOADED_IMAGE LoadedImage,
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation
    )
{
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
    ULONG i;

    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY) ImageDirectoryEntryToData( LoadedImage->MappedAddress,
                                                 FALSE,
                                                 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                 &i
                                               );
    if (ImageConfigData != NULL && i == sizeof( *ImageConfigData )) {
        memcpy( ImageConfigInformation, ImageConfigData, sizeof( *ImageConfigData ) );
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
SetImageConfigInformation(
    PLOADED_IMAGE LoadedImage,
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation
    )
{
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
    ULONG i;
    ULONG DirectoryAddress;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_DATA_DIRECTORY pLoadCfgDataDir;

    if (LoadedImage->hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY) ImageDirectoryEntryToData( LoadedImage->MappedAddress,
                                                 FALSE,
                                                 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                 &i
                                               );
    if (ImageConfigData != NULL && i == sizeof( *ImageConfigData )) {
        memcpy( ImageConfigData, ImageConfigInformation, sizeof( *ImageConfigData ) );
        return TRUE;
    }

    DirectoryAddress = GetImageUnusedHeaderBytes( LoadedImage, &i );
    if (i < sizeof(*ImageConfigData)) {
        return FALSE;
    }

    NtHeaders = LoadedImage->FileHeader;

    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        pLoadCfgDataDir = &((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG];
    } else {
        pLoadCfgDataDir = &((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG];
    }
    pLoadCfgDataDir->VirtualAddress = DirectoryAddress;
    pLoadCfgDataDir->Size = sizeof(*ImageConfigData);
    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY) ((PCHAR)LoadedImage->MappedAddress + DirectoryAddress);
    memcpy( ImageConfigData, ImageConfigInformation, sizeof( *ImageConfigData ) );
    return TRUE;
}


BOOLEAN ImageLoadInit;
LIST_ENTRY ImageLoadList;

PLOADED_IMAGE
ImageLoad(
    LPSTR DllName,
    LPSTR DllPath
    )
{
    PLIST_ENTRY Head,Next;
    PLOADED_IMAGE LoadedImage;
    CHAR Drive[_MAX_DRIVE];
    CHAR Dir[_MAX_DIR];
    CHAR Filename[_MAX_FNAME];
    CHAR Ext[_MAX_EXT];
    CHAR LoadedModuleName[_MAX_PATH];
    BOOL fFileNameOnly;

    if (!ImageLoadInit) {
        InitializeListHead( &ImageLoadList );
        ImageLoadInit = TRUE;
    }

    Head = &ImageLoadList;
    Next = Head->Flink;

    _splitpath(DllName, Drive, Dir, Filename, Ext);
    if (!strlen(Drive) && !strlen(Dir)) {
        // The user only specified a filename (no drive/path).
        fFileNameOnly = TRUE;
    } else {
        fFileNameOnly = FALSE;
    }

    while (Next != Head) {
        LoadedImage = CONTAINING_RECORD( Next, LOADED_IMAGE, Links );
        if (fFileNameOnly) {
            _splitpath(LoadedImage->ModuleName, NULL, NULL, Filename, Ext);
            strcpy(LoadedModuleName, Filename);
            strcat(LoadedModuleName, Ext);
        } else {
            strcpy(LoadedModuleName, LoadedImage->ModuleName);
        }

        if (!_stricmp( DllName, LoadedModuleName )) {
            return LoadedImage;
        }

        Next = Next->Flink;
    }

    LoadedImage = (PLOADED_IMAGE) MemAlloc( sizeof( *LoadedImage ) + strlen( DllName ) + 1 );
    if (LoadedImage != NULL) {
        LoadedImage->ModuleName = (LPSTR)(LoadedImage + 1);
        strcpy( LoadedImage->ModuleName, DllName );
        if (MapAndLoad( DllName, DllPath, LoadedImage, TRUE, TRUE )) {
            InsertTailList( &ImageLoadList, &LoadedImage->Links );
            return LoadedImage;
        }

        MemFree( LoadedImage );
        LoadedImage = NULL;
    }

    return LoadedImage;
}

BOOL
ImageUnload(
    PLOADED_IMAGE LoadedImage
    )
{
    if (!IsListEmpty( &LoadedImage->Links )) {
        RemoveEntryList( &LoadedImage->Links );
    }

    UnMapAndLoad( LoadedImage );
    MemFree( LoadedImage );

    return TRUE;
}

BOOL
UnloadAllImages()
{
    PLIST_ENTRY Head,Next;
    PLOADED_IMAGE LoadedImage;

    if (!ImageLoadInit) {
        return(TRUE);
    }

    Head = &ImageLoadList;
    Next = Head->Flink;

    while (Next != Head) {
        LoadedImage = CONTAINING_RECORD( Next, LOADED_IMAGE, Links );
        Next = Next->Flink;
        ImageUnload(LoadedImage);
    }

    ImageLoadInit = FALSE;
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\linesym.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    linesym.c

Abstract:

    Source file and line support.

Author:

    Drew Bliss (drewb) 07-07-1997

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>

#include "private.h"
#include "symbols.h"
#include "globals.h"

// private version of qsort used to avoid compat problems on NT4 and win2k.
// code is published from base\crts
extern
void __cdecl dbg_qsort(void *, size_t, size_t,
                       int (__cdecl *) (const void *, const void *));

// #define DBG_LINES
// #define DBG_COFF_LINES
// #define DBG_ADDR_SEARCH
BOOL
diaAddLinesForAllMod(
    PMODULE_ENTRY mi
    );


#if defined(DBG_LINES) || defined(DBG_COFF_LINES) || defined(DBG_ADDR_SEARCH)
void __cdecl
DbgOut(PCSTR Format, ...)
{
    char Buf[512];
    va_list Args;

    va_start(Args, Format);
    _vsnprintf(Buf, sizeof(Buf), Format, Args);
    va_end(Args);
    OutputDebugStringA(Buf);
}
#endif

int
__cdecl
CompareLineAddresses(
    const void *v1,
    const void *v2
    )
{
    PSOURCE_LINE Line1 = (PSOURCE_LINE)v1;
    PSOURCE_LINE Line2 = (PSOURCE_LINE)v2;

    if (Line1->Addr < Line2->Addr) {
        return -1;
    } else if (Line1->Addr > Line2->Addr) {
        return 1;
    } else {
        return 0;
    }
}

VOID
AddSourceEntry(
    PMODULE_ENTRY mi,
    PSOURCE_ENTRY Src
    )
{
    PSOURCE_ENTRY SrcCur;

    // Overlap is currently permitted.
#if 0
    // Check for overlap between SOURCE_ENTRY address ranges.
    for (SrcCur = mi->SourceFiles;
         SrcCur != NULL;
         SrcCur = SrcCur->Next)
    {
        if (!(SrcCur->MinAddr > Src->MaxAddr ||
              SrcCur->MaxAddr < Src->MinAddr))
        {
            DbgOut("SOURCE_ENTRY overlap between %08I64X:%08I64X "
                   "and %08I64X:%08I64X\n",
                   Src->MinAddr, Src->MaxAddr,
                   SrcCur->MinAddr, SrcCur->MaxAddr);
        }
    }
#endif

    // Sort line info by address.
    dbg_qsort((PVOID)Src->LineInfo, Src->Lines, sizeof(Src->LineInfo[0]),
          CompareLineAddresses);

    // Link new source information into list, sorted by address
    // range covered by information.

    for (SrcCur = mi->SourceFiles;
         SrcCur != NULL;
         SrcCur = SrcCur->Next) {
        if (SrcCur->MinAddr > Src->MinAddr) {
            break;
        }
    }

    Src->Next = SrcCur;
    if (SrcCur == NULL) {
        if (mi->SourceFilesTail == NULL) {
            mi->SourceFiles = Src;
        } else {
            mi->SourceFilesTail->Next = Src;
        }
        Src->Prev = mi->SourceFilesTail;
        mi->SourceFilesTail = Src;
    } else {
        if (SrcCur->Prev == NULL) {
            mi->SourceFiles = Src;
        } else {
            SrcCur->Prev->Next = Src;
        }
        Src->Prev = SrcCur->Prev;
        SrcCur->Prev = Src;
    }

#ifdef DBG_LINES
    DbgOut("%08I64X %08I64X: %5d lines, '%s'\n",
           Src->MinAddr, Src->MaxAddr, Src->Lines, Src->File);
#endif
}

#define IS_SECTION_SYM(Sym) \
    ((Sym)->StorageClass == IMAGE_SYM_CLASS_STATIC && \
     (Sym)->Type == IMAGE_SYM_TYPE_NULL && \
     (Sym)->NumberOfAuxSymbols == 1)

BOOL
AddLinesForCoff(
    PMODULE_ENTRY mi,
    PIMAGE_SYMBOL allSymbols,
    DWORD numberOfSymbols,
    PIMAGE_LINENUMBER LineNumbers
    )
{
    PIMAGE_LINENUMBER *SecLines;
    BOOL Ret = FALSE;
    PIMAGE_SECTION_HEADER sh;
    ULONG i;
    PIMAGE_SYMBOL Symbol;
    ULONG LowestPointer;

    // Allocate some space for per-section data.
    SecLines = (PIMAGE_LINENUMBER *)MemAlloc(sizeof(PIMAGE_LINENUMBER)*mi->NumSections);
    if (SecLines == NULL) {
        return FALSE;
    }

    //
    // Add line number information for file groups if such
    // groups exist.
    //

    // First locate the lowest file offset for linenumbers.  This
    // is necessary to be able to compute relative linenumber pointers
    // in split images because currently the pointers aren't updated
    // during stripping.
    sh = mi->SectionHdrs;
    LowestPointer = 0xffffffff;
    for (i = 0; i < mi->NumSections; i++, sh++) {
        if (sh->NumberOfLinenumbers > 0 &&
            sh->PointerToLinenumbers != 0 &&
            sh->PointerToLinenumbers < LowestPointer)
        {
            LowestPointer = sh->PointerToLinenumbers;
        }
    }

    if (LowestPointer == 0xffffffff) {
        goto EH_FreeSecLines;
    }

    sh = mi->SectionHdrs;
    for (i = 0; i < mi->NumSections; i++, sh++) {
        if (sh->NumberOfLinenumbers > 0 &&
            sh->PointerToLinenumbers != 0)
        {
            SecLines[i] = (PIMAGE_LINENUMBER)
                (sh->PointerToLinenumbers - LowestPointer + (DWORD_PTR)LineNumbers);

#ifdef DBG_COFF_LINES
            DbgOut("Section %d: %d lines at %08X\n",
                   i, sh->NumberOfLinenumbers, SecLines[i]);
#endif
        } else {
            SecLines[i] = NULL;
        }
    }

    // Look for a file symbol.
    Symbol = allSymbols;
    for (i = 0; i < numberOfSymbols; i++) {
        if (Symbol->StorageClass == IMAGE_SYM_CLASS_FILE) {
            break;
        }

        i += Symbol->NumberOfAuxSymbols;
        Symbol += 1+Symbol->NumberOfAuxSymbols;
    }

    // If no file symbols were found, don't attempt to add line
    // number information.  Something could be done with the raw
    // linenumber info in the image (if it exists) but this probably
    // isn't an important enough case to worry about.

    while (i < numberOfSymbols) {
        ULONG iNextFile, iAfterFile;
        ULONG iCur, iSym;
        PIMAGE_SYMBOL SymAfterFile, CurSym;
        PIMAGE_AUX_SYMBOL AuxSym;
        ULONG Lines;
        ULONG MinAddr, MaxAddr;
        LPSTR FileName;
        ULONG FileNameLen;

#ifdef DBG_COFF_LINES
        DbgOut("%3X: '%s', %X\n", i, Symbol+1, Symbol->Value);
#endif

        // A file symbol's Value is the index of the next file symbol.
        // In between the two file symbols there may be static
        // section symbols which give line number counts for all
        // the line numbers in the file.
        // The file chain can be NULL terminated or a circular list,
        // in which case this code assumes the end comes when the
        // list wraps around.

        if (Symbol->Value == 0 || Symbol->Value <= i) {
            iNextFile = numberOfSymbols;
        } else {
            iNextFile = Symbol->Value;
        }

        // Compute the index of the first symbol after the current file
        // symbol.
        iAfterFile = i+1+Symbol->NumberOfAuxSymbols;
        SymAfterFile = Symbol+1+Symbol->NumberOfAuxSymbols;

        // Look for section symbols and count up the number of linenumber
        // references, the min address and the max address.
        CurSym = SymAfterFile;
        iCur = iAfterFile;
        Lines = 0;
        MinAddr = 0xffffffff;
        MaxAddr = 0;
        while (iCur < iNextFile) {
            DWORD Addr;

            if (IS_SECTION_SYM(CurSym) &&
                SecLines[CurSym->SectionNumber-1] != NULL)
            {
                AuxSym = (PIMAGE_AUX_SYMBOL)(CurSym+1);

                Lines += AuxSym->Section.NumberOfLinenumbers;

                Addr = (ULONG)(CurSym->Value+mi->BaseOfDll);

#ifdef DBG_COFF_LINES
                DbgOut("    Range %08X %08X, min %08X max %08X\n",
                       Addr, Addr+AuxSym->Section.Length-1,
                       MinAddr, MaxAddr);
#endif

                if (Addr < MinAddr) {
                    MinAddr = Addr;
                }
                Addr += AuxSym->Section.Length-1;
                if (Addr > MaxAddr) {
                    MaxAddr = Addr;
                }
            }

            iCur += 1+CurSym->NumberOfAuxSymbols;
            CurSym += 1+CurSym->NumberOfAuxSymbols;
        }

        if (Lines > 0) {
            PSOURCE_ENTRY Src;
            PSOURCE_LINE SrcLine;
            ULONG iLine;

            // We have a filename and some linenumber information,
            // so create a SOURCE_ENTRY and fill it in.

            FileName = (LPSTR)(Symbol+1);
            FileNameLen = strlen(FileName);

            Src = (PSOURCE_ENTRY)MemAlloc(sizeof(SOURCE_ENTRY)+
                                          sizeof(SOURCE_LINE)*Lines+
                                          FileNameLen+1);
            if (Src == NULL) {
                goto EH_FreeSecLines;
            }

            Src->ModuleId = 0;
            Src->MinAddr = MinAddr;
            Src->MaxAddr = MaxAddr;
            Src->Lines = Lines;

            SrcLine = (PSOURCE_LINE)(Src+1);
            Src->LineInfo = SrcLine;

            // Now that we've got a place to put linenumber information,
            // retraverse the section symbols and grab COFF linenumbers
            // from the appropriate sections and format them into
            // the generic format.
            CurSym = SymAfterFile;
            iCur = iAfterFile;
            while (iCur < iNextFile) {
                if (IS_SECTION_SYM(CurSym) &&
                    SecLines[CurSym->SectionNumber-1] != NULL) {
                    PIMAGE_LINENUMBER CoffLine;

                    AuxSym = (PIMAGE_AUX_SYMBOL)(CurSym+1);
                    CoffLine = SecLines[CurSym->SectionNumber-1];

#ifdef DBG_COFF_LINES
                    DbgOut("    %d lines at %08X\n",
                           AuxSym->Section.NumberOfLinenumbers,
                           CoffLine);
#endif

                    for (iLine = 0;
                         iLine < AuxSym->Section.NumberOfLinenumbers;
                         iLine++)
                    {
                        SrcLine->Addr = CoffLine->Type.VirtualAddress+
                            mi->BaseOfDll;
                        SrcLine->Line = CoffLine->Linenumber;
                        CoffLine++;
                        SrcLine++;
                    }

                    SecLines[CurSym->SectionNumber-1] = CoffLine;
                }

                iCur += 1+CurSym->NumberOfAuxSymbols;
                CurSym += 1+CurSym->NumberOfAuxSymbols;
            }

            // Stick file name at the very end of the data block so
            // it doesn't interfere with alignment.
            Src->File = (LPSTR)SrcLine;
            memcpy(Src->File, FileName, FileNameLen+1);

            AddSourceEntry(mi, Src);

            // This routine is successful as long as it adds at least
            // one new source entry.
            Ret = TRUE;
        }

        // After the loops above iCur and CurSym refer to the next
        // file symbol, so update the loop counters from them.
        i = iCur;
        Symbol = CurSym;
    }

 EH_FreeSecLines:
    MemFree(SecLines);

    return Ret;
}

BOOL
AddLinesForOmfSourceModule(
    PMODULE_ENTRY mi,
    BYTE *Base,
    OMFSourceModule *OmfSrcMod,
    PVOID PdbModule
    )
{
    BOOL Ret;
    ULONG iFile;

    Ret = FALSE;

    for (iFile = 0; iFile < (ULONG)OmfSrcMod->cFile; iFile++) {
        OMFSourceFile *OmfSrcFile;
        BYTE OmfFileNameLen;
        LPSTR OmfFileName;
        PULONG OmfAddrRanges;
        OMFSourceLine *OmfSrcLine;
        ULONG iSeg;
        PSOURCE_ENTRY Src;
        PSOURCE_ENTRY Seg0Src;
        PSOURCE_LINE SrcLine;
        ULONG NameAllocLen;

        OmfSrcFile = (OMFSourceFile *)(Base+OmfSrcMod->baseSrcFile[iFile]);

        // The baseSrcLn array of offsets is immediately followed by
        // SVA pairs which define the address ranges for the segments.
        OmfAddrRanges = &OmfSrcFile->baseSrcLn[OmfSrcFile->cSeg];

        // The name length and data immediately follows the address
        // range information.
        OmfFileName = (LPSTR)(OmfAddrRanges+2*OmfSrcFile->cSeg)+1;
        OmfFileNameLen = *(BYTE *)(OmfFileName-1);

        // The compiler can potentially generate a lot of segments
        // per file.  The segments within a file have disjoint
        // address ranges as long as they are treated as separate
        // SOURCE_ENTRYs.  If all segments for a particular file get
        // combined into one SOURCE_ENTRY it leads to address range overlap
        // because of combining non-contiguous segments.  Allocating
        // a SOURCE_ENTRY per segment isn't that bad, particularly since
        // the name information only needs to be allocated in the first
        // entry for a file and the rest can share it.

        NameAllocLen = OmfFileNameLen+1;

        for (iSeg = 0; iSeg < (ULONG)OmfSrcFile->cSeg; iSeg++) {
            PULONG Off;
            PUSHORT Ln;
            ULONG iLine;
            PIMAGE_SECTION_HEADER sh;

            OmfSrcLine = (OMFSourceLine *)(Base+OmfSrcFile->baseSrcLn[iSeg]);

            Src = (PSOURCE_ENTRY)MemAlloc(sizeof(SOURCE_ENTRY)+
                                          sizeof(SOURCE_LINE)*OmfSrcLine->cLnOff+
                                          NameAllocLen);
            if (Src == NULL) {
                return Ret;
            }

            Src->ModuleId = (ULONG) (ULONG64) PdbModule;
            Src->Lines = OmfSrcLine->cLnOff;

            sh = &mi->SectionHdrs[OmfSrcLine->Seg-1];

            // Process raw segment limits into current addresses.
            Src->MinAddr = mi->BaseOfDll+sh->VirtualAddress+(*OmfAddrRanges++);
            Src->MaxAddr = mi->BaseOfDll+sh->VirtualAddress+(*OmfAddrRanges++);

            // Retrieve line numbers and offsets from raw data and
            // process them into current pointers.

            SrcLine = (SOURCE_LINE *)(Src+1);
            Src->LineInfo = SrcLine;

            Off = (ULONG *)&OmfSrcLine->offset[0];
            Ln = (USHORT *)(Off+OmfSrcLine->cLnOff);

            for (iLine = 0; iLine < OmfSrcLine->cLnOff; iLine++) {
                SrcLine->Line = *Ln++;
                SrcLine->Addr = (*Off++)+mi->BaseOfDll+sh->VirtualAddress;

                // Line symbol information names the IA64 bundle
                // syllables with 0,1,2 whereas the debugger expects
                // 0,4,8.  Convert.
                if (mi->MachineType == IMAGE_FILE_MACHINE_IA64 &&
                    (SrcLine->Addr & 3)) {
                    SrcLine->Addr = (SrcLine->Addr & ~3) |
                        ((SrcLine->Addr & 3) << 2);
                }
                
                SrcLine++;
            }

            if (iSeg == 0) {
                // Stick file name at the very end of the data block so
                // it doesn't interfere with alignment.
                Src->File = (LPSTR)SrcLine;
                memcpy(Src->File, OmfFileName, OmfFileNameLen);
                Src->File[OmfFileNameLen] = 0;

                // Later segments will share this initial name storage
                // space so they don't need to alloc their own.
                NameAllocLen = 0;
                Seg0Src = Src;
            } else {
                Src->File = Seg0Src->File;
            }

            AddSourceEntry(mi, Src);

            // This routine is successful as long as it adds at least
            // one new source entry.
            Ret = TRUE;
        }
    }

    return Ret;
}


VOID
FillLineInfo(
    PSOURCE_ENTRY Src,
    PSOURCE_LINE SrcLine,
    PIMAGEHLP_LINE64 Line
    )
{
    Line->Key = (PVOID)SrcLine;
    Line->LineNumber = SrcLine->Line;
    Line->FileName = Src->File;
    Line->Address = SrcLine->Addr;
}

PSOURCE_LINE
FindLineInSource(
    PSOURCE_ENTRY Src,
    DWORD64 Addr
    )
{
    int Low, Middle, High;
    PSOURCE_LINE SrcLine;

    Low = 0;
    High = Src->Lines-1;

    while (High >= Low) {
        Middle = (High <= Low) ? Low : (Low + High) >> 1;
        SrcLine = &Src->LineInfo[Middle];

#ifdef DBG_ADDR_SEARCH
        DbgOut("    Checking %4d:%x`%08X\n", Middle,
               (ULONG)(SrcLine->Addr>>32), (ULONG)SrcLine->Addr);
#endif

        if (Addr < SrcLine->Addr) {
            High = Middle-1;
        }
        else if (Middle < (int)Src->Lines-1 &&
                 Addr >= (SrcLine+1)->Addr) {
            Low = Middle+1;
        } else {
            PSOURCE_LINE HighLine;
            
            // Find the highest source line with this offset.
            // Source lines are sorted by offset so the highest
            // source line could be before or after this one.
            
            while (SrcLine > Src->LineInfo &&
                   (SrcLine - 1)->Addr == SrcLine->Addr) {
                SrcLine--;
            }
            HighLine = SrcLine;
            while (SrcLine < Src->LineInfo + Src->Lines - 1 &&
                   (++SrcLine)->Addr == HighLine->Addr) {
                if (SrcLine->Line > HighLine->Line) {
                    HighLine = SrcLine;
                }
            }
            return HighLine;
        }
    }

    return NULL;
}

PSOURCE_ENTRY
FindNextSourceEntryForAddr(
    PMODULE_ENTRY mi,
    DWORD64 Addr,
    PSOURCE_ENTRY SearchFrom
    )
{
    PSOURCE_ENTRY Src;

    Src = SearchFrom != NULL ? SearchFrom->Next : mi->SourceFiles;
    while (Src != NULL) {
        if (Addr < Src->MinAddr) {
            // Source files are kept sorted by increasing address so this
            // means that the address will not be found later and
            // we can stop checking.
            return NULL;
        } else if (Addr <= Src->MaxAddr) {
            // Found one.
            return Src;
        }
        Src = Src->Next;
    }

    return NULL;
}

BOOL
GetLineFromAddr(
    PMODULE_ENTRY mi,
    DWORD64 Addr,
    PDWORD Displacement,
    PIMAGEHLP_LINE64 Line
    )
{
    PSOURCE_ENTRY Src;
    DWORD Bias;
    DWORD64 srcAddr;

    if (mi == NULL) {
        return FALSE;
    }

    if (mi->dia)
        return diaGetLineFromAddr(mi, Addr, Displacement, Line);

    srcAddr = ConvertOmapToSrc( mi,
                               Addr,
                               &Bias,
                               (g.SymOptions & SYMOPT_OMAP_FIND_NEAREST) != 0
                               );

    if (srcAddr == 0) {
        return FALSE;
    }

    // We have successfully converted

    srcAddr += Bias;

    for (;;) {
        PSOURCE_ENTRY BestSrc;
        PSOURCE_LINE BestSrcLine;
        DWORD64 BestDisp;

        // Search through all the source entries that contain the given
        // address, looking for the line with the smallest displacement.

        BestDisp = 0xffffffffffffffff;
        BestSrc = NULL;
        Src = NULL;
        while (Src = FindNextSourceEntryForAddr(mi, srcAddr, Src)) {
            PSOURCE_LINE SrcLine;

#ifdef DBG_ADDR_SEARCH
            DbgOut("Found '%s' %d lines: %08I64X %08I64X for %08I64X\n",
                   Src->File, Src->Lines, Src->MinAddr, Src->MaxAddr, Addr);
#endif

            // Found a matching source entry, so look up the line
            // information.
            SrcLine = FindLineInSource(Src, srcAddr);
            if (SrcLine != NULL &&
                Addr-SrcLine->Addr < BestDisp) {
                BestDisp = Addr-SrcLine->Addr;

#ifdef DBG_ADDR_SEARCH
                DbgOut("  Best disp %I64X\n", BestDisp);
#endif

                BestSrc = Src;
                BestSrcLine = SrcLine;
                if (BestDisp == 0) {
                    break;
                }
            }
        }

        // Only accept displaced answers if there's no more symbol
        // information to load.
        if (BestSrc != NULL && BestDisp == 0) {
            FillLineInfo(BestSrc, BestSrcLine, Line);
            *Displacement = (ULONG)BestDisp;
            return TRUE;
        }

        return FALSE;
    }

    return FALSE;
}

PSOURCE_ENTRY
FindNextSourceEntryForFile(
    PMODULE_ENTRY mi,
    LPSTR FileStr,
    PSOURCE_ENTRY SearchFrom
    )
{
    PSOURCE_ENTRY Src;

    Src = SearchFrom != NULL ? SearchFrom->Next : mi->SourceFiles;
    while (Src != NULL)
    {
        if (SymMatchFileName(Src->File, FileStr, NULL, NULL))
        {
            return Src;
        }

        Src = Src->Next;
    }

    return NULL;
}

PSOURCE_ENTRY
FindPrevSourceEntryForFile(
    PMODULE_ENTRY mi,
    LPSTR FileStr,
    PSOURCE_ENTRY SearchFrom
    )
{
    PSOURCE_ENTRY Src;

    Src = SearchFrom != NULL ? SearchFrom->Prev : mi->SourceFilesTail;
    while (Src != NULL)
    {
        if (SymMatchFileName(Src->File, FileStr, NULL, NULL))
        {
            return Src;
        }

        Src = Src->Prev;
    }

    return NULL;
}

BOOL
FindLineByName(
    PMODULE_ENTRY mi,
    LPSTR FileName,
    DWORD LineNumber,
    PLONG Displacement,
    PIMAGEHLP_LINE64 Line
    )
{
    PSOURCE_ENTRY Src;
    BOOL TryLoad;
    BOOL AtOrGreater;

    if (mi == NULL)
    {
        return FALSE;
    }

    if (FileName == NULL)
    {
        // If no file was given then it's assumed that the file
        // is the same as for the line information passed in.
        FileName = Line->FileName;
    }

    // If the high bit of the line number is set
    // it means that the caller only wants lines at
    // or greater than the given line.
    AtOrGreater = (LineNumber & 0x80000000) != 0;
    LineNumber &= 0x7fffffff;
    
    if (mi->dia)
        if (diaGetLineFromName(mi, FileName, LineNumber, Displacement, Line))
            return TRUE;

    // We only lazy load here for symbols, and only if we're allowed to.
    TryLoad = mi->SymType == SymDia &&
        (g.SymOptions & SYMOPT_LOAD_LINES) != 0;

    for (;;)
    {
        ULONG Disp;
        ULONG BestDisp;
        PSOURCE_ENTRY BestSrc;
        PSOURCE_LINE BestSrcLine;

        //
        // Search existing source information for a filename match.
        // There can be multiple SOURCE_ENTRYs with the same filename,
        // so make sure and search them all for an exact match
        // before settling on an approximate match.
        //

        Src = NULL;
        BestDisp = 0x7fffffff;
        BestSrcLine = NULL;
        while (Src = FindNextSourceEntryForFile(mi, FileName, Src))
        {
            PSOURCE_LINE SrcLine;
            ULONG i;

            // Found a matching source entry, so look up the closest
            // line.  Line number info is sorted by address so the actual
            // line numbers can be in any order so we can't optimize
            // this linear search.

            SrcLine = Src->LineInfo;
            for (i = 0; i < Src->Lines; i++)
            {
                if (LineNumber > SrcLine->Line)
                {
                    if (AtOrGreater)
                    {
                        Disp = 0x7fffffff;
                    }
                    else
                    {
                        Disp = LineNumber-SrcLine->Line;
                    }
                }
                else
                {
                    Disp = SrcLine->Line-LineNumber;
                }

                if (Disp < BestDisp)
                {
                    BestDisp = Disp;
                    BestSrc = Src;
                    BestSrcLine = SrcLine;
                    if (Disp == 0)
                    {
                        break;
                    }
                }

                SrcLine++;
            }

            // If we found an exact match we can stop.
            if (BestDisp == 0)
            {
                break;
            }
        }

        // Only accept displaced answers if there's no more symbol
        // information to load.
        if (BestSrcLine != NULL && (BestDisp == 0 || !TryLoad))
        {
            FillLineInfo(BestSrc, BestSrcLine, Line);
            *Displacement = (LONG)(LineNumber-BestSrcLine->Line);
            return TRUE;
        }
        if (!TryLoad)
        {
            // There's no more line information to try and load so
            // we're out of luck.
            return FALSE;
        }

        TryLoad = FALSE;

        // There doesn't seem to be an easy way to look up a module by
        // filename.  It's possible to query by object filename, but
        // that can be much different from the source filename.
        // Just load the info all PDB modules.

        if (!diaAddLinesForAllMod(mi))
        {
            return FALSE;
        }

    }

    return FALSE;
}

#define LINE_ERROR 0xffffffff

ULONG
GetFileLineOffsets(
    PMODULE_ENTRY mi,
    LPSTR FileName,
    PDWORD64 Buffer,
    ULONG BufferLines
    )
{
    PSOURCE_ENTRY Src;
    ULONG HighestLine = 0;
    
    // This routine collects all line information in one pass so
    // there's no opportunity for lazy loading.  We have to
    // force lines to be loaded up front.
    if (mi->dia && (g.SymOptions & SYMOPT_LOAD_LINES) != 0) {
        if (!diaAddLinesForAllMod(mi)) {
            return LINE_ERROR;
        }
    }


    Src = NULL;
    while (Src = FindNextSourceEntryForFile(mi, FileName, Src)) {
        PSOURCE_LINE Line;
        ULONG i;
        ULONG Num;

        Line = Src->LineInfo;
        for (i = 0; i < Src->Lines; i++) {
            if (Line->Line > HighestLine) {
                HighestLine = Line->Line;
            }

            Num = Line->Line - 1;
            if (Num < BufferLines) {
                Buffer[Num] = Line->Addr;
            }

            Line++;
        }
    }

    return HighestLine;
}

ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    IN  HANDLE                  hProcess,
    IN  LPSTR                   ModuleName,
    IN  LPSTR                   FileName,
    OUT PDWORD64                Buffer,
    IN  ULONG                   BufferLines
    )

/*++

Routine Description:

    This function locates the given file's line information
    and fills the given buffer with offsets for each
    line.  Buffer[Line - 1] is set to the offset for
    Line.  Buffer entries for lines that do not have information
    are left unchanged.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    ModuleName          - Module name or NULL.

    FileName            - File name.

    Buffer              - Array of offsets to fill.

    BufferLines         - Number of entries in the Buffer array.

Return Value:

    0                   - No information was found.

    LINE_ERROR          - Failure during operation.  Call GetLastError to
                          discover the cause of the failure.

    Otherwise the return value is the highest line number found.

--*/

{
    PPROCESS_ENTRY      ProcessEntry;
    PMODULE_ENTRY       mi;
    ULONG               HighestLine = 0;
    PLIST_ENTRY         Next;

    __try {
        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return LINE_ERROR;
        }

        if (ModuleName != NULL) {

            mi = FindModule(hProcess, ProcessEntry, ModuleName, TRUE);
            if (mi != NULL) {
                return GetFileLineOffsets(mi, FileName, Buffer, BufferLines);
            }

            SetLastError( ERROR_MOD_NOT_FOUND );
            return LINE_ERROR;
        }

        Next = ProcessEntry->ModuleList.Flink;
        if (Next) {
            while (Next != &ProcessEntry->ModuleList) {

                mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                Next = mi->ListEntry.Flink;

                if (!LoadSymbols(hProcess, mi, LS_QUALIFIED | LS_LOAD_LINES)) {
                    continue;
                }

                HighestLine = GetFileLineOffsets(mi, FileName, Buffer,
                                                 BufferLines);
                // This will break on lines found or LINE_ERROR.
                if (HighestLine > 0) {
                    break;
                }
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return LINE_ERROR;

    }

    return HighestLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\mapdebug.c ===
#include <private.h>
#include <symbols.h>
#include "globals.h"

// forward reference
      
void
RetrievePdbInfo(
    PIMGHLP_DEBUG_DATA pIDD,
    CHAR const *szReference
    );

BOOL
FindDebugInfoFileExCallback(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

BOOL
FindExecutableImageExCallback(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    );

BOOL
ProcessDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD,
    DWORD datasrc
    );

__inline
BOOL
ProcessImageDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    return ProcessDebugInfo(pIDD, dsImage);
}


__inline
BOOL
ProcessInProcDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    return ProcessDebugInfo(pIDD, dsInProc);
}


__inline
BOOL
ProcessDbgDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    return ProcessDebugInfo(pIDD, dsDbg);
}


BOOL
ProcessCallerDataDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    PMODLOAD_DATA mld = pIDD->mld;
    PIMAGE_DEBUG_DIRECTORY dd;
    PCHAR pCV;
    DWORD cdd;
    DWORD i;

    if (!mld)
        return FALSE;

    if (!mld->ssize 
        || !mld->size
        || !mld->data)
        return FALSE;

    if (mld->ssig != DBHHEADER_DEBUGDIRS)
        return FALSE;

    cdd = mld->size / sizeof(IMAGE_DEBUG_DIRECTORY);
    dd = (PIMAGE_DEBUG_DIRECTORY)mld->data;
    for (i = 0; i < cdd; i++, dd++) {
        if (dd->Type != IMAGE_DEBUG_TYPE_CODEVIEW)
            continue;
        pCV = (PCHAR)mld->data + dd->PointerToRawData;
        pIDD->fCvMapped = TRUE;
        pIDD->pMappedCv = (PCHAR)pCV;
        pIDD->cMappedCv = dd->SizeOfData;
        pIDD->dsCV = dsCallerData;
        pIDD->PdbSignature = 0;
        pIDD->PdbAge = 0;
        RetrievePdbInfo(pIDD, pIDD->ImageFilePath);
        mdSet(pIDD->md, dd->Type, dsNone, dsCallerData);
        break;
    }

    return TRUE;
}


// functions called by the MODULE_DATA array...

BOOL
mdfnOpenDbgFile(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    dprint("mdfnOpenDbgFile()\n");

    if (pIDD->DbgFileHandle)
        return TRUE;

    if (*pIDD->OriginalDbgFileName) {
        pIDD->DbgFileHandle = fnFindDebugInfoFileEx(
                                    pIDD->OriginalDbgFileName,
                                    pIDD->SymbolPath,
                                    pIDD->DbgFilePath,
                                    FindDebugInfoFileExCallback,
                                    pIDD,
                                    fdifRECURSIVE);
    }
    if (!pIDD->DbgFileHandle) {
        pIDD->DbgFileHandle = fnFindDebugInfoFileEx(
                                    pIDD->ImageName,
                                    pIDD->SymbolPath,
                                    pIDD->DbgFilePath,
                                    FindDebugInfoFileExCallback,
                                    pIDD,
                                    fdifRECURSIVE);
    }
    if (!pIDD->DbgFileHandle)
        g.LastSymLoadError = SYMLOAD_DBGNOTFOUND;

    // if we have a .dbg file.  See what we can get from it.
    if (pIDD->DbgFileHandle) {
        ProcessDbgDebugInfo(pIDD);
    }

    return TRUE;
}

BOOL
mdfnGetExecutableImage(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    dprint("mdfnGetExecutableImage()\n");

    if (!*pIDD->ImageName)
        return TRUE;

    if (!pIDD->ImageFileHandle)
        pIDD->ImageFileHandle = FindExecutableImageEx(pIDD->ImageName,
                                                      pIDD->SymbolPath,
                                                      pIDD->ImageFilePath,
                                                      FindExecutableImageExCallback,
                                                      pIDD);

    if (pIDD->ImageFileHandle) 
        ProcessImageDebugInfo(pIDD);

    return TRUE;
}

// this struct is used to initilaize the module data array for a new module

static MODULE_DATA gmd[NUM_MODULE_DATA_ENTRIES] =
{
    {mdHeader,                       dsNone, dsNone, FALSE, NULL},
    {mdSecHdrs,                      dsNone, dsNone, FALSE, NULL},
    {IMAGE_DEBUG_TYPE_UNKNOWN,       dsNone, dsNone, FALSE, NULL},
    {IMAGE_DEBUG_TYPE_COFF,          dsNone, dsNone, FALSE, NULL},
    {IMAGE_DEBUG_TYPE_CODEVIEW,      dsNone, dsNone, FALSE, NULL},  
    {IMAGE_DEBUG_TYPE_FPO,           dsNone, dsNone, TRUE,  mdfnGetExecutableImage},  
    {IMAGE_DEBUG_TYPE_MISC,          dsNone, dsNone, FALSE, NULL},  
    {IMAGE_DEBUG_TYPE_EXCEPTION,     dsNone, dsNone, FALSE, NULL},  
    {IMAGE_DEBUG_TYPE_FIXUP,         dsNone, dsNone, FALSE, NULL},  
    {IMAGE_DEBUG_TYPE_OMAP_TO_SRC,   dsNone, dsNone, FALSE, NULL},  
    {IMAGE_DEBUG_TYPE_OMAP_FROM_SRC, dsNone, dsNone, FALSE, NULL},  
    {IMAGE_DEBUG_TYPE_BORLAND,       dsNone, dsNone, FALSE, NULL},  
    {IMAGE_DEBUG_TYPE_RESERVED10,    dsNone, dsNone, FALSE, NULL},  
    {IMAGE_DEBUG_TYPE_CLSID,         dsNone, dsNone, FALSE, NULL}
};
                 
DWORD
mdSet(
    PMODULE_DATA md,
    DWORD        id,
    DWORD        hint,
    DWORD        src
    )
{
    DWORD i;

    for (i = 0; i < NUM_MODULE_DATA_ENTRIES; md++, i++) {
        if (md->id == id) {
            if (hint != dsNone)
                md->hint = hint;
            if (src != dsNone)
                md->src = src;
            return i;
        }
    }

    return 0;
}

void
mdDump(
    PMODULE_DATA md,
    BOOL         verbose
    )
{
    DWORD i;

    static PCHAR idstr[] = 
    {
    "mdHeader",
    "mdSecHdrs",
    "IMAGE_DEBUG_TYPE_UNKNOWN",
    "IMAGE_DEBUG_TYPE_COFF",
    "IMAGE_DEBUG_TYPE_CODEVIEW",
    "IMAGE_DEBUG_TYPE_FPO",
    "IMAGE_DEBUG_TYPE_MISC",
    "IMAGE_DEBUG_TYPE_EXCEPTION",
    "IMAGE_DEBUG_TYPE_FIXUP",
    "IMAGE_DEBUG_TYPE_OMAP_TO_SRC",
    "IMAGE_DEBUG_TYPE_OMAP_FROM_SRC",
    "IMAGE_DEBUG_TYPE_BORLAND",
    "IMAGE_DEBUG_TYPE_RESERVED10",
    "IMAGE_DEBUG_TYPE_CLSID"
    };

    static PCHAR dsstr[] = 
    {
        "dsNone", 
        "dsInProc", 
        "dsImage", 
        "dsDbg", 
        "dsPdb", 
        "dsDia"
    };
    
    for (i = 0; i < NUM_MODULE_DATA_ENTRIES; md++, i++) {
        if (verbose | md->hint | md->src) {
            dprint("MD:%30s hint=%s src=%s\n", 
                   idstr[i],
                   dsstr[md->hint],
                   dsstr[md->src]);
        }
    }
    dprint("\n");
}

BOOL
GetUnfoundData(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    DWORD i;
    PMODULE_DATA md;

    for (md = pIDD->md, i = 0; i < NUM_MODULE_DATA_ENTRIES; md++, i++) {
        if (!md->required)
            continue;
        if (md->hint == dsNone)
            continue;
        if (md->src != dsNone)
            continue;
        if (!md->fn)
            continue;
        if (!md->fn(pIDD))
            return FALSE;
    }

    return TRUE;
}


BOOL
IsImageMachineType64(
    DWORD MachineType
    )
{
   switch(MachineType) {
   case IMAGE_FILE_MACHINE_AXP64:
   case IMAGE_FILE_MACHINE_IA64:
   case IMAGE_FILE_MACHINE_AMD64:
       return TRUE;
   default:
       return FALSE;
   }
}

ULONG
ReadImageData(
    IN  HANDLE  hprocess,
    IN  ULONG64 ul,
    IN  ULONG64 addr,
    OUT LPVOID  buffer,
    IN  ULONG   size
    )
{
    ULONG bytesread;

    if (hprocess) {

        ULONG64 base = ul;

        BOOL rc;

        rc = ReadInProcMemory(hprocess,
                              base + addr,
                              buffer,
                              size,
                              &bytesread);

        if (!rc || (bytesread < (ULONG)size))
            return 0;

    } else {

        PCHAR p = (PCHAR)ul + addr;

        memcpy(buffer, p, size);
    }

    return size;
}

PVOID
MapItRO(
      HANDLE FileHandle
      )
{
    PVOID MappedBase = NULL;

    if (FileHandle) {

        HANDLE MappingHandle = CreateFileMapping( FileHandle, NULL, PAGE_READONLY, 0, 0, NULL );
        if (MappingHandle) {
            MappedBase = MapViewOfFile( MappingHandle, FILE_MAP_READ, 0, 0, 0 );
            CloseHandle(MappingHandle);
        }
    }

    return MappedBase;
}


void
CloseSymbolServer(
    VOID
    )
{
    if (!g.hSrv)
        return;

    if (g.fnSymbolServerClose)
        g.fnSymbolServerClose();

    FreeLibrary(g.hSrv);

    g.hSrv = 0;
    *g.szSrvName = 0;
    g.szSrvParams = NULL;
    g.fnSymbolServer = NULL;
    g.fnSymbolServerClose = NULL;
    g.fnSymbolServerSetOptions = NULL;
}


DWORD
ProcessSymbolServerError(
    BOOL   success,
    LPCSTR params
    )
{
    DWORD rc;

    if (success)
        return NO_ERROR;

    rc = GetLastError();
    switch(rc)
    {
    case ERROR_FILE_NOT_FOUND:      // obvious
    case ERROR_MORE_DATA:           // didn't pass any tokens
        break;
    case ERROR_INVALID_NAME:
        CloseSymbolServer();
        g.hSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        evtprint(NULL, sevProblem, ERROR_INVALID_NAME, NULL, "SYMSRV: %s needs a downstream store.\n", params);
        break;
    case ERROR_FILE_INVALID:
        evtprint(NULL, sevProblem, ERROR_FILE_INVALID, NULL, "SYMSRV: Compressed file needs a downstream store.\n");
        break;
    default:
        dprint("symsrv error 0x%x\n", rc);
        break;
    }

    return rc;
}


BOOL
GetFileFromSymbolServer(
    IN  LPCSTR ServerInfo,
    IN  LPCSTR FileName,
    IN  GUID  *guid,
    IN  DWORD  two,
    IN  DWORD  three,
    OUT LPSTR FilePath
    )
{
    BOOL   rc;
    CHAR  *params;
    LPCSTR fname;

    // strip any path information from the filename

    for (fname = FileName + strlen(FileName); fname > FileName; fname--) {
        if (*fname == '\\') {
            fname++;
            break;
        }
    }

    // initialize server, if needed
    
    if (g.hSrv == (HINSTANCE)INVALID_HANDLE_VALUE)
        return FALSE;

    if (!g.hSrv) {
        g.hSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        strcpy(g.szSrvName, &ServerInfo[7]);
        if (!*g.szSrvName)
            return FALSE;
        g.szSrvParams = strchr(g.szSrvName, '*');
        if (!g.szSrvParams )
            return FALSE;
        *g.szSrvParams++ = '\0';
        g.hSrv = LoadLibrary(g.szSrvName);
        if (g.hSrv) {
            g.fnSymbolServer = (PSYMBOLSERVERPROC)GetProcAddress(g.hSrv, "SymbolServer");
            if (!g.fnSymbolServer) {
                FreeLibrary(g.hSrv);
                g.hSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
            }
            g.fnSymbolServerClose = (PSYMBOLSERVERCLOSEPROC)GetProcAddress(g.hSrv, "SymbolServerClose");
            g.fnSymbolServerSetOptions = (PSYMBOLSERVERSETOPTIONSPROC)GetProcAddress(g.hSrv, "SymbolServerSetOptions");
            SetSymbolServerOptions(SSRVOPT_RESET, 0);
            SetSymbolServerOptions(SSRVOPT_GUIDPTR, 1);
        } else {
            g.hSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        }
    }

    // bail, if we have no valid server

    if (g.hSrv == INVALID_HANDLE_VALUE) {
        dprint("SymSrv load failure: %s\n", g.szSrvName);
        return FALSE;
    }

    params = strchr(ServerInfo, '*');
    if (!params)
        return FALSE;
    params = strchr(params+1, '*');
    if (!params)
        return FALSE;
    SetCriticalErrorMode();
    rc = g.fnSymbolServer(params+1, fname, guid, two, three, FilePath);
#ifdef GETRIDOFTHISASAP
    if (!rc) {
        SetSymbolServerOptions(SSRVOPT_RESET, 0);
        SetSymbolServerOptions(SSRVOPT_OLDGUIDPTR, 1);
        rc = g.fnSymbolServer(params+1, fname, guid, two, three, FilePath);
        SetSymbolServerOptions(SSRVOPT_RESET, 0);
        SetSymbolServerOptions(SSRVOPT_GUIDPTR, 1);
    }
#endif    
    ResetCriticalErrorMode();
    ProcessSymbolServerError(rc, params+1);

    return rc;
}


BOOL
SymbolServerCallback(
    UINT_PTR action,
    ULONG64 data,
    ULONG64 context
    )
{
    BOOL rc = TRUE;
    char *sz;

    switch (action) {

    case SSRVACTION_TRACE:
        sz = (char *)data;
        eprint((char *)data);
        break;

    default:
        // unsupported
        rc = FALSE;
        break;
    }

    return rc;
}


void
SetSymbolServerOptions(
    ULONG_PTR options,
    ULONG64   data
    )
{
    static ULONG_PTR ssopts = 0;
    static ULONG64   ssdata = 0;

    if (options != SSRVOPT_RESET) {
        ssopts = options;
        ssdata = data;
    }

    if (g.fnSymbolServerSetOptions)
        g.fnSymbolServerSetOptions(ssopts, ssdata);
}


void
SetSymbolServerCallback(
    BOOL state
    )
{
    if (state)
        SetSymbolServerOptions(SSRVOPT_CALLBACK, (ULONG64)SymbolServerCallback);
    else
        SetSymbolServerOptions(0, 0);
}


BOOL
ProcessOldStyleCodeView(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    OMFSignature    *omfSig;
    OMFDirHeader    *omfDirHdr;
    OMFDirEntry     *omfDirEntry;
    OMFSegMap       *omfSegMap;
    OMFSegMapDesc   *omfSegMapDesc;
    DWORD            i, j, k, SectionSize;
    DWORD            SectionStart;
    PIMAGE_SECTION_HEADER   Section;

    if (pIDD->cOmapFrom) {
        // If there's omap, we need to generate the original section map

        omfSig = (OMFSignature *)pIDD->pMappedCv;
        omfDirHdr = (OMFDirHeader*) ((PCHAR)pIDD->pMappedCv + (DWORD)omfSig->filepos);
        omfDirEntry = (OMFDirEntry*) ((PCHAR)omfDirHdr + sizeof(OMFDirHeader));

        if (!omfDirHdr->cDir) {
            pIDD->cOmapFrom = 0;
            pIDD->cOmapTo = 0;
        }

        for (i=0; i<omfDirHdr->cDir; i++,omfDirEntry++) {
            if (omfDirEntry->SubSection == sstSegMap) {

                omfSegMap = (OMFSegMap*) ((PCHAR)pIDD->pMappedCv + omfDirEntry->lfo);

                omfSegMapDesc = (OMFSegMapDesc*)&omfSegMap->rgDesc[0];

                SectionStart = *(DWORD *)pIDD->pOmapFrom;
                SectionSize = 0;

                Section = (PIMAGE_SECTION_HEADER) MemAlloc(omfSegMap->cSeg * sizeof(IMAGE_SECTION_HEADER));

                if (Section) {
                    for (j=0, k=0; j < omfSegMap->cSeg; j++) {
                        if (omfSegMapDesc[j].frame) {
                            // The linker sets the frame field to the actual section header number.  Zero is
                            // used to track absolute symbols that don't exist in a real sections.

                            Section[k].VirtualAddress =
                                SectionStart =
                                    SectionStart + ((SectionSize + (pIDD->ImageAlign-1)) & ~(pIDD->ImageAlign-1));
                            Section[k].Misc.VirtualSize =
                                SectionSize = omfSegMapDesc[j].cbSeg;
                            k++;
                        }
                    }

                    pIDD->pOriginalSections = Section;
                    pIDD->cOriginalSections = k;
                }
            }
        }
    }

    return TRUE;
}

__inline
DWORD
IsDataInSection (PIMAGE_SECTION_HEADER Section,
                 PIMAGE_DATA_DIRECTORY Data
                 )
{
    DWORD RealDataOffset;
    if ((Data->VirtualAddress >= Section->VirtualAddress) &&
        ((Data->VirtualAddress + Data->Size) <= (Section->VirtualAddress + Section->SizeOfRawData))) {
        RealDataOffset = (DWORD)(Data->VirtualAddress -
                                 Section->VirtualAddress +
                                 Section->PointerToRawData);
    } else {
        RealDataOffset = 0;
    }
    return RealDataOffset;
}

__inline
DWORD
SectionContains (
    HANDLE hp,
    PIMAGE_SECTION_HEADER pSH,
    PIMAGE_DATA_DIRECTORY ddir
    )
{
    DWORD rva = 0;

    if (!ddir->VirtualAddress)
        return 0;

    if (ddir->VirtualAddress >= pSH->VirtualAddress) {
        if ((ddir->VirtualAddress + ddir->Size) <= (pSH->VirtualAddress + pSH->SizeOfRawData)) {
            rva = ddir->VirtualAddress;
            if (!hp)
                rva = rva - pSH->VirtualAddress + pSH->PointerToRawData;
        }
    }

    return rva;
}


void
RetrievePdbInfo(
    PIMGHLP_DEBUG_DATA pIDD,
    CHAR const *szReference
    )
{
    CHAR szRefDrive[_MAX_DRIVE];
    CHAR szRefPath[_MAX_DIR];
    PCVDD pcv = (PCVDD)pIDD->pMappedCv;

    if (pIDD->PdbSignature)
        return;

    switch (pcv->dwSig)
    {
    case '01BN':
        pIDD->PdbAge = pcv->nb10i.age;
        pIDD->PdbSignature = pcv->nb10i.sig;
        strcpy(pIDD->PdbFileName, pcv->nb10i.szPdb);
        break;
    case 'SDSR':
        pIDD->PdbRSDS = TRUE;
        pIDD->PdbAge = pcv->rsdsi.age;
        memcpy(&pIDD->PdbGUID, &pcv->rsdsi.guidSig, sizeof(GUID));
        strcpy(pIDD->PdbFileName, pcv->rsdsi.szPdb);
        break;
    default:
        return;
    }

    // if there is a path in the CV record - use it

    if ((g.SymOptions & SYMOPT_IGNORE_CVREC) == 0) {
        _splitpath(szReference, szRefDrive, szRefPath, NULL, NULL);
        _makepath(pIDD->PdbReferencePath, szRefDrive, szRefPath, NULL, NULL);
        if (strlen(szRefPath) > 1) {
            pIDD->PdbReferencePath[strlen(pIDD->PdbReferencePath)-1] = '\0';
            return;
        } 
    }

    // if we have full path info for the image - use it

    _splitpath(pIDD->ImageName, szRefDrive, szRefPath, NULL, NULL);
    _makepath(pIDD->PdbReferencePath, szRefDrive, szRefPath, NULL, NULL);
    if (strlen(szRefPath) > 1) {
        pIDD->PdbReferencePath[strlen(pIDD->PdbReferencePath)-1] = '\0';
        return;
    }

    // No path.  Put on at least a dot "."

    strcpy(pIDD->PdbReferencePath, ".");
}

BOOL
FakePdbName(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    CHAR szName[_MAX_FNAME];

    if (pIDD->PdbSignature) {
        return FALSE;
    }

    if (!pIDD->ImageName)
        return FALSE;

    _splitpath(pIDD->ImageName, NULL, NULL, szName, NULL);
    if (!*szName)
        return FALSE;

    strcpy(pIDD->PdbFileName, szName);
    strcat(pIDD->PdbFileName, ".pdb");

    return TRUE;
}

BOOL
FindDebugInfoFileExCallback(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    )
{
    PIMGHLP_DEBUG_DATA pIDD;
    PIMAGE_SEPARATE_DEBUG_HEADER DbgHeader;
    PVOID FileMap;
    BOOL  rc;

    rc = TRUE;

    if (!CallerData)
        return TRUE;

    pIDD = (PIMGHLP_DEBUG_DATA)CallerData;

    FileMap = MapItRO(FileHandle);

    if (!FileMap) {
        return FALSE;
    }

    DbgHeader = (PIMAGE_SEPARATE_DEBUG_HEADER)FileMap;

    // Only support .dbg files for X86 and Alpha (32 bit).

    if ((DbgHeader->Signature != IMAGE_SEPARATE_DEBUG_SIGNATURE) ||
        ((DbgHeader->Machine != IMAGE_FILE_MACHINE_I386) &&
         (DbgHeader->Machine != IMAGE_FILE_MACHINE_ALPHA)))
    {
        rc = FALSE;
        goto cleanup;
    }

    // ignore checksums, they are bogus
    rc = (pIDD->TimeDateStamp == DbgHeader->TimeDateStamp) ? TRUE : FALSE;

cleanup:
    if (FileMap)
        UnmapViewOfFile(FileMap);

    return rc;
}

BOOL
ProcessDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD,
    DWORD datasrc
    )
{
    BOOL                         status;
    ULONG                        cb;
    IMAGE_DOS_HEADER             dh;
    IMAGE_NT_HEADERS32           nh32;
    IMAGE_NT_HEADERS64           nh64;
    PIMAGE_ROM_OPTIONAL_HEADER   rom = NULL;
    IMAGE_SEPARATE_DEBUG_HEADER  sdh;
    PIMAGE_FILE_HEADER           fh;
    PIMAGE_DEBUG_MISC            md;
    ULONG                        ddva;
    ULONG                        shva;
    ULONG                        nSections;
    PIMAGE_SECTION_HEADER        psh;
    IMAGE_DEBUG_DIRECTORY        dd;
    PIMAGE_DATA_DIRECTORY        datadir;
    PCHAR                        pCV;
    ULONG                        i;
    int                          nDebugDirs = 0;
    HANDLE                       hp;
    ULONG64                      base;
    IMAGE_ROM_HEADERS            ROMImage;

    DWORD                        rva;
    PCHAR                        filepath;
    IMAGE_EXPORT_DIRECTORY       expdir;
    DWORD                        fsize;
    BOOL                         rc;
    USHORT                       filetype;

    // setup pointers for grabing data

    switch (datasrc) {
    case dsInProc:
        hp = pIDD->hProcess;
        base = pIDD->InProcImageBase;
        fsize = 0;
        filepath = pIDD->ImageFilePath;
        pIDD->PdbSrc = srcCVRec;
        break;
    case dsImage:
        hp = NULL;
        pIDD->ImageMap = MapItRO(pIDD->ImageFileHandle);
        base = (ULONG64)pIDD->ImageMap;
        fsize = GetFileSize(pIDD->ImageFileHandle, NULL);
        filepath = pIDD->ImageFilePath;
        pIDD->PdbSrc = srcImagePath;
        break;
    case dsDbg:
        hp = NULL;
        pIDD->DbgFileMap = MapItRO(pIDD->DbgFileHandle);
        base = (ULONG64)pIDD->DbgFileMap;
        fsize = GetFileSize(pIDD->DbgFileHandle, NULL);
        filepath = pIDD->DbgFilePath;
        pIDD->PdbSrc = srcDbgPath;
        break;
    default:
        return FALSE;
    }

    // some initialization
    pIDD->fNeedImage = FALSE;
    rc = FALSE;
    ddva = 0;

    __try {

        // test the file type

        status = ReadImageData(hp, base, 0, &filetype, sizeof(filetype));
        if (!status) {
            g.LastSymLoadError = SYMLOAD_HEADERPAGEDOUT;
            return FALSE;
        }
        pIDD->ImageType = datasrc;
        if (filetype == IMAGE_SEPARATE_DEBUG_SIGNATURE)
            goto dbg;

        if (filetype == IMAGE_DOS_SIGNATURE)
        {
            // grab the dos header

            status = ReadImageData(hp, base, 0, &dh, sizeof(dh));
            if (!status) {
                g.LastSymLoadError = SYMLOAD_HEADERPAGEDOUT;
                return FALSE;
            }

            // grab the pe header

            status = ReadImageData(hp, base, dh.e_lfanew, &nh32, sizeof(nh32));
            if (!status) {
                g.LastSymLoadError = SYMLOAD_HEADERPAGEDOUT;
                return FALSE;
            }

            // read header info

            if (nh32.Signature != IMAGE_NT_SIGNATURE) {

                // if header is not NT sig, this is a ROM image

                rom = (PIMAGE_ROM_OPTIONAL_HEADER)&nh32.OptionalHeader;
                fh = &nh32.FileHeader;
                shva = dh.e_lfanew + sizeof(DWORD) +
                       sizeof(IMAGE_FILE_HEADER) + fh->SizeOfOptionalHeader;
            }

        } else if (filetype == IMAGE_FILE_MACHINE_I386) {
            
            // This is an X86 ROM image
            status = ReadImageData(hp, base, 0, &nh32.FileHeader, sizeof(nh32.FileHeader)+sizeof(nh32.OptionalHeader));
            if (!status)
                return FALSE;
            nh32.Signature = 'ROM ';

        } else {
            // This may be a ROM image

            status = ReadImageData(hp, base, 0, &ROMImage, sizeof(ROMImage));
            if (!status) {
                g.LastSymLoadError = SYMLOAD_HEADERPAGEDOUT;
                return FALSE;
            }
            if ((ROMImage.FileHeader.Machine == IMAGE_FILE_MACHINE_I386)  ||
                (ROMImage.FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA) ||
                (ROMImage.FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA64))
            {
                rom = (PIMAGE_ROM_OPTIONAL_HEADER)&ROMImage.OptionalHeader;
                fh = &ROMImage.FileHeader;
                shva = sizeof(IMAGE_FILE_HEADER) + fh->SizeOfOptionalHeader;
            } else {
                return FALSE;
            }
        }

        if (rom) {
            if (rom->Magic == IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
                pIDD->fROM = TRUE;
                pIDD->iohMagic = rom->Magic;

                pIDD->ImageBaseFromImage = rom->BaseOfCode;
                pIDD->SizeOfImage = rom->SizeOfCode;
                pIDD->CheckSum = 0;
            } else {
                return FALSE;
            }

        } else {

            // otherwise, get info from appropriate header type for 32 or 64 bit

            if (IsImageMachineType64(nh32.FileHeader.Machine)) {

                // Reread the header as a 64bit header.
                status = ReadImageData(hp, base, dh.e_lfanew, &nh64, sizeof(nh64));
                if (!status) {
                    g.LastSymLoadError = SYMLOAD_HEADERPAGEDOUT;
                    return FALSE;
                }

                fh = &nh64.FileHeader;
                datadir = nh64.OptionalHeader.DataDirectory;
                shva = dh.e_lfanew + sizeof(nh64);
                pIDD->iohMagic = nh64.OptionalHeader.Magic;
                pIDD->fPE64 = TRUE;       // seems to be unused
    
                if (datasrc == dsImage || datasrc == dsInProc) {
                    pIDD->ImageBaseFromImage = nh64.OptionalHeader.ImageBase;
                    pIDD->ImageAlign = nh64.OptionalHeader.SectionAlignment;
                    pIDD->CheckSum = nh64.OptionalHeader.CheckSum;
                }
                pIDD->SizeOfImage = nh64.OptionalHeader.SizeOfImage;
            }
            else {
                fh = &nh32.FileHeader;
                datadir = nh32.OptionalHeader.DataDirectory;
                pIDD->iohMagic = nh32.OptionalHeader.Magic;
                if (nh32.Signature == 'ROM ') {
                    shva = sizeof(nh32.FileHeader)+sizeof(nh32.OptionalHeader);
                } else {
                    shva = dh.e_lfanew + sizeof(nh32);
                }
                
                if (datasrc == dsImage || datasrc == dsInProc) {
                    pIDD->ImageBaseFromImage = nh32.OptionalHeader.ImageBase;
                    pIDD->ImageAlign = nh32.OptionalHeader.SectionAlignment;
                    pIDD->CheckSum = nh32.OptionalHeader.CheckSum;
                }
                pIDD->SizeOfImage = nh32.OptionalHeader.SizeOfImage;
            }
        }

        mdSet(pIDD->md, mdHeader, datasrc, datasrc);

        // read the section headers

        nSections = fh->NumberOfSections;
        psh = (PIMAGE_SECTION_HEADER) MemAlloc(nSections * sizeof(IMAGE_SECTION_HEADER));
        if (!psh)
            goto debugdirs;
        status = ReadImageData(hp, base, shva, psh, nSections * sizeof(IMAGE_SECTION_HEADER));
        if (!status)
            goto debugdirs;

        // store off info to return struct

        pIDD->pCurrentSections = psh;
        pIDD->cCurrentSections = nSections;
        pIDD->pImageSections   = psh;
        pIDD->cImageSections   = nSections;
        pIDD->Machine = fh->Machine;
        pIDD->TimeDateStamp = fh->TimeDateStamp;
        pIDD->Characteristics = fh->Characteristics;

        mdSet(pIDD->md, mdSecHdrs, datasrc, datasrc);

        // get information from the sections

        for (i = 0; i < nSections; i++, psh++) {
            DWORD offset;

            if (pIDD->fROM &&
                ((fh->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) == 0) &&
                (!strcmp((LPSTR)psh->Name, ".rdata")))
            {
                nDebugDirs = 1;
                ddva = psh->VirtualAddress;
                break;
            }
            if (offset = SectionContains(hp, psh, &datadir[IMAGE_DIRECTORY_ENTRY_EXPORT]))
            {
                pIDD->dsExports = datasrc;
                pIDD->cExports = datadir[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                pIDD->oExports = offset;
                ReadImageData(hp, base, offset, &pIDD->expdir, sizeof(pIDD->expdir));
            }

            if (offset = SectionContains(hp, psh, &datadir[IMAGE_DIRECTORY_ENTRY_DEBUG]))
            {
                ddva = offset;
                nDebugDirs = datadir[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof(IMAGE_DEBUG_DIRECTORY);
            }
        }

        goto debugdirs;

dbg:

        // grab the dbg header

        status = ReadImageData(hp, base, 0, &sdh, sizeof(sdh));
        if (!status)
            return FALSE;

        // Only support .dbg files for X86 and Alpha (32 bit).

        if ((sdh.Machine != IMAGE_FILE_MACHINE_I386)
            && (sdh.Machine != IMAGE_FILE_MACHINE_ALPHA))
        {
            UnmapViewOfFile(pIDD->DbgFileMap);
            pIDD->DbgFileMap = 0;
            return FALSE;
        }

        pIDD->ImageAlign = sdh.SectionAlignment;
        pIDD->CheckSum = sdh.CheckSum;
        pIDD->Machine = sdh.Machine;
        pIDD->TimeDateStamp = sdh.TimeDateStamp;
        pIDD->Characteristics = sdh.Characteristics;
        if (!pIDD->ImageBaseFromImage) {
            pIDD->ImageBaseFromImage = sdh.ImageBase;
        }

        if (!pIDD->SizeOfImage) {
            pIDD->SizeOfImage = sdh.SizeOfImage;
        }

        nSections = sdh.NumberOfSections;
        psh = (PIMAGE_SECTION_HEADER) MemAlloc(nSections * sizeof(IMAGE_SECTION_HEADER));
        if (!psh)
            goto debugdirs;
        status = ReadImageData(hp,
                               base,
                               sizeof(IMAGE_SEPARATE_DEBUG_HEADER),
                               psh,
                               nSections * sizeof(IMAGE_SECTION_HEADER));
        if (!status)
            goto debugdirs;

        pIDD->pCurrentSections   = psh;
        pIDD->cCurrentSections   = nSections;
        pIDD->pDbgSections       = psh;
        pIDD->cDbgSections       = nSections;
//        pIDD->ExportedNamesSize = sdh.ExportedNamesSize;

        if (sdh.DebugDirectorySize) {
            nDebugDirs = (int)(sdh.DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY));
            ddva = sizeof(IMAGE_SEPARATE_DEBUG_HEADER)
                   + (sdh.NumberOfSections * sizeof(IMAGE_SECTION_HEADER))
                   + sdh.ExportedNamesSize;
        }

debugdirs:

        rc = TRUE;

        // copy the virtual addr of the debug directories over for MapDebugInformation

        if (datasrc == dsImage) {
            pIDD->ddva = ddva;
            pIDD->cdd  = nDebugDirs;
        }

        // read the debug directories

        while (nDebugDirs) {

            status = ReadImageData(hp, base, (ULONG_PTR)ddva, &dd, sizeof(dd));
            if (!status)
                break;
            if (!dd.SizeOfData)
                goto nextdebugdir;

            // indicate that we found the debug directory

            mdSet(pIDD->md, dd.Type, datasrc, dsNone);

            // these debug directories are processed both in-proc and from file

            switch (dd.Type)
            {
            case IMAGE_DEBUG_TYPE_CODEVIEW:
                // get info on pdb file
                if (hp && dd.AddressOfRawData) {
                    // in-proc image
                    if (!(pCV = (PCHAR)MemAlloc(dd.SizeOfData)))
                        break;
                    status = ReadImageData(hp, base, dd.AddressOfRawData, pCV, dd.SizeOfData);
                    if (!status) {
                        MemFree(pCV);
                        break;
                    }
                } else {
                    // file-base image
                    if (dd.PointerToRawData >= fsize)
                        break;
                    pCV = (PCHAR)base + dd.PointerToRawData;
                    pIDD->fCvMapped = TRUE;
                }
                pIDD->pMappedCv = (PCHAR)pCV;
                pIDD->cMappedCv = dd.SizeOfData;
                pIDD->dsCV = datasrc;
                RetrievePdbInfo(pIDD, filepath);
                mdSet(pIDD->md, dd.Type, dsNone, datasrc);
                break;

            case IMAGE_DEBUG_TYPE_MISC:
                // on stripped files, find the dbg file
                // on dbg file, find the original file name
                if (dd.PointerToRawData < fsize) {
                    md = (PIMAGE_DEBUG_MISC)((PCHAR)base + dd.PointerToRawData);
                    if (md->DataType != IMAGE_DEBUG_MISC_EXENAME)
                        break;
                    if (datasrc == dsDbg) {
                        if (!*pIDD->OriginalImageFileName)
                            strncpy(pIDD->OriginalImageFileName, (LPSTR)md->Data, sizeof(pIDD->OriginalImageFileName));
                        break;
                    }
                    if (fh->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
                        strncpy(pIDD->OriginalDbgFileName, (LPSTR)md->Data, sizeof(pIDD->OriginalDbgFileName));
                    } else {
                        strncpy(pIDD->OriginalImageFileName, (LPSTR)md->Data, sizeof(pIDD->OriginalImageFileName));
                    }
                }
                mdSet(pIDD->md, dd.Type, dsNone, datasrc);
                break;

            case IMAGE_DEBUG_TYPE_COFF:
                if (dd.PointerToRawData < fsize) {
//                  pIDD->fNeedImage = TRUE;
                    pIDD->pMappedCoff = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cMappedCoff = dd.SizeOfData;
                    pIDD->fCoffMapped = TRUE;
                    pIDD->dsCoff = datasrc;
                    mdSet(pIDD->md, dd.Type, dsNone, datasrc);
                } else {
                    pIDD->fNeedImage = TRUE;
                }
                break;
#ifdef INPROC_SUPPORT
            case IMAGE_DEBUG_TYPE_FPO:
                if (dd.PointerToRawData < fsize) {
                    pIDD->pFpo = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cFpo = dd.SizeOfData / SIZEOF_RFPO_DATA;
                    pIDD->fFpoMapped = TRUE;
                    pIDD->dsFPO = datasrc;
                    mdSet(pIDD->md, dd.Type, dsNone, datasrc);
                } else {
                    dprint("found fpo in-process\n");
                }
                break;
            case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                if (dd.PointerToRawData < fsize) {
                    pIDD->pOmapTo = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cOmapTo = dd.SizeOfData / sizeof(OMAP);
                    pIDD->fOmapToMapped = TRUE;
                    pIDD->dsOmapTo = datasrc;
                    mdSet(pIDD->md, dd.Type, dsNone, datasrc);
                } else {
                    dprint("found found omap-to in-process\n");
                }
                break;

            case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                if (dd.PointerToRawData < fsize) {
                    pIDD->pOmapFrom = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cOmapFrom = dd.SizeOfData / sizeof(OMAP);
                    pIDD->fOmapFromMapped = TRUE;
                    pIDD->dsOmapFrom = datasrc;
                    mdSet(pIDD->md, dd.Type, dsNone, datasrc);
                } else {
                    dprint("found omap-from in-process\n");
                }
                break;
#endif
            }

            // these debug directories are only processed for disk-based images

            if (dd.PointerToRawData < fsize) {

                switch (dd.Type)
                {
                case IMAGE_DEBUG_TYPE_FPO:
                    pIDD->pFpo = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cFpo = dd.SizeOfData / SIZEOF_RFPO_DATA;
                    pIDD->fFpoMapped = TRUE;
                    pIDD->dsFPO = datasrc;
                    mdSet(pIDD->md, dd.Type, dsNone, datasrc);
                    break;

                case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                    pIDD->pOmapTo = (POMAP)((PCHAR)base + dd.PointerToRawData);
                    pIDD->cOmapTo = dd.SizeOfData / sizeof(OMAP);
                    pIDD->fOmapToMapped = TRUE;
                    pIDD->dsOmapTo = datasrc;
                    mdSet(pIDD->md, dd.Type, dsNone, datasrc);
                    break;

                case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                    pIDD->pOmapFrom = (POMAP)((PCHAR)base + dd.PointerToRawData);
                    pIDD->cOmapFrom = dd.SizeOfData / sizeof(OMAP);
                    pIDD->fOmapFromMapped = TRUE;
                    pIDD->dsOmapFrom = datasrc;
                    mdSet(pIDD->md, dd.Type, dsNone, datasrc);
                    break;

                case IMAGE_DEBUG_TYPE_EXCEPTION:
                    pIDD->dsExceptions = datasrc;
                    mdSet(pIDD->md, dd.Type, dsNone, datasrc);
                    break;
                }
            }

nextdebugdir:

            ddva += sizeof(IMAGE_DEBUG_DIRECTORY);
            nDebugDirs--;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

          // We might have gotten enough information
          // to be okay.  So don't indicate error.
    }

    return rc;
}


BOOL
FigureOutImageName(
    PIMGHLP_DEBUG_DATA pIDD
    )
/*
    We got here because we didn't get the image name passed in from the original call
    to GetDebugData AND we were unable to find the MISC data with the name
    Have to figure it out.

    A couple of options here.  First, if the DLL bit is set, try looking for Export
    table.  If found, IMAGE_EXPORT_DIRECTORY->Name is a rva pointer to the dll name.
    If it's not found, see if there's a OriginalDbgFileName.
      If so see if the format is <ext>\<filename>.dbg.
        If there's more than one backslash or no backslash, punt and label it with a .dll
        extension.
        Otherwise a splitpath will do the trick.
    If there's no DbgFilePath, see if there's a PDB name.  The same rules apply there as
    for .dbg files.  Worst case, you s/b able to get the base name and just stick on a
    If this all fails, label it as mod<base address>.
    If the DLL bit is not set, assume an exe and tag it with that extension.  The base name
    can be retrieved from DbgFilePath, PdbFilePath, or use just APP.
*/
{
    // Quick hack to get Dr. Watson going.

    CHAR szName[_MAX_FNAME];
    CHAR szExt[_MAX_FNAME];

    if (pIDD->OriginalDbgFileName[0]) {
        _splitpath(pIDD->OriginalDbgFileName, NULL, NULL, szName, NULL);
        strcpy(pIDD->OriginalImageFileName, szName);
        strcat(pIDD->OriginalImageFileName, pIDD->Characteristics & IMAGE_FILE_DLL ? ".dll" : ".exe");
    } else if (pIDD->ImageName) {
        _splitpath(pIDD->ImageName, NULL, NULL, szName, szExt);
        strcpy(pIDD->OriginalImageFileName, szName);
        if (*szExt) {
            strcat(pIDD->OriginalImageFileName, szExt);
        }
    } else if (pIDD->PdbFileName[0]) {
        _splitpath(pIDD->PdbFileName, NULL, NULL, szName, NULL);
        strcpy(pIDD->OriginalImageFileName, szName);
        strcat(pIDD->OriginalImageFileName, pIDD->Characteristics & IMAGE_FILE_DLL ? ".dll" : ".exe");
    } else {
        sprintf(pIDD->OriginalImageFileName, "MOD%p", pIDD->InProcImageBase);
    }


    return TRUE;
}


BOOL
FindExecutableImageExCallback(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    )
{
    PIMGHLP_DEBUG_DATA pIDD;
    PIMAGE_FILE_HEADER FileHeader = NULL;
    PVOID ImageMap = NULL;
    BOOL rc;

    if (!CallerData)
        return TRUE;

    pIDD = (PIMGHLP_DEBUG_DATA)CallerData;
    if (!pIDD->TimeDateStamp)
        return TRUE;

    // Crack the image and let's see what we're working with
    ImageMap = MapItRO(FileHandle);
    if (!ImageMap)
        return TRUE;

    // Check the first word.  We're either looking at a normal PE32/PE64 image, or it's
    // a ROM image (no DOS stub) or it's a random file.
    switch (*(PUSHORT)ImageMap) {
        case IMAGE_FILE_MACHINE_I386:
            // Must be an X86 ROM image (ie: ntldr)
            FileHeader = &((PIMAGE_ROM_HEADERS)ImageMap)->FileHeader;

            // Make sure
            if (!(FileHeader->SizeOfOptionalHeader == sizeof(IMAGE_OPTIONAL_HEADER32) &&
                pIDD->iohMagic == IMAGE_NT_OPTIONAL_HDR32_MAGIC))
            {
                FileHeader = NULL;
            }
            break;

        case IMAGE_FILE_MACHINE_ALPHA:
        case IMAGE_FILE_MACHINE_ALPHA64:
        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_AMD64:
            // Should be an Alpha/IA64 ROM image (ie: osloader.exe)
            FileHeader = &((PIMAGE_ROM_HEADERS)ImageMap)->FileHeader;

            // Make sure
            if (!(FileHeader->SizeOfOptionalHeader == sizeof(IMAGE_ROM_OPTIONAL_HEADER) &&
                 pIDD->iohMagic == IMAGE_ROM_OPTIONAL_HDR_MAGIC))
            {
                FileHeader = NULL;
            }
            break;

        case IMAGE_DOS_SIGNATURE:
            {
                PIMAGE_NT_HEADERS NtHeaders = ImageNtHeader(ImageMap);
                if (NtHeaders) {
                    FileHeader = &NtHeaders->FileHeader;
                }
            }
            break;

        default:
            break;
    }

    // default return is a match

    rc = TRUE;

    // compare timestamps

    if (FileHeader && FileHeader->TimeDateStamp != pIDD->TimeDateStamp)
        rc = FALSE;

    pIDD->ImageSrc = srcSearchPath;

    // cleanup

    if (ImageMap)
        UnmapViewOfFile(ImageMap);

    return rc;
}


BOOL
SymbolInfoFound(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    OMFSignature           *omfSig;

    if (pIDD->dia)
        return TRUE;

    // look for embedded codeview

    if (pIDD->pMappedCv) {
        omfSig = (OMFSignature*) pIDD->pMappedCv;
        if (*(DWORD *)(omfSig->Signature) == '80BN')
            return TRUE;
        if (*(DWORD *)(omfSig->Signature) == '90BN')
            return TRUE;
        if (*(DWORD *)(omfSig->Signature) == '11BN')
            return TRUE;
    }

    // look for coff symbols

    if (pIDD->pMappedCoff)
        return TRUE;

    // must be no debug info

    return FALSE;
}


BOOL FileNameIsPdb(
    PIMGHLP_DEBUG_DATA pIDD,
    LPSTR FileName
    )
{
    CHAR drive[_MAX_DRIVE];
    CHAR path[_MAX_DIR];
    char ext[20];

    _splitpath(FileName, drive, path, NULL, ext);
    if (_strcmpi(ext, ".pdb")) 
        return FALSE;

    strcpy(pIDD->PdbFileName, FileName);


    _makepath(pIDD->PdbReferencePath, drive, path, NULL, NULL);
    if (strlen(path) > 1) {
        // Chop off trailing backslash.
        pIDD->PdbReferencePath[strlen(pIDD->PdbReferencePath)-1] = '\0';
    } else {
        // No path.  Put on at least a dot "."
        strcpy(pIDD->PdbReferencePath, ".");
    }

    return TRUE;
}


PIMGHLP_DEBUG_DATA
GetDebugData(
    HANDLE        hProcess,
    HANDLE        FileHandle,
    LPSTR         FileName,
    LPSTR         SymbolPath,
    ULONG64       ImageBase,
    PMODLOAD_DATA mld,
    ULONG         dwFlags
    )
/*
   Given:
     ImageFileHandle - Map the thing.  The only time FileHandle s/b non-null
                       is if we're given an image handle.  If this is not
                       true, ignore the handle.
    !ImageFileHandle - Use the filename and search for first the image name,
                       then the .dbg file, and finally a .pdb file.

    dwFlags:           NO_PE64_IMAGES - Return failure if only image is PE64.
                                        Used to implement MapDebugInformation()

*/
{
    PIMGHLP_DEBUG_DATA pIDD;

//  if (traceSubName(FileName)) // for setting debug breakpoints from DBGHELP_TOKEN
//      dprint("debug(%s)\n", FileName);

    // No File handle and   no file name.  Bail

    if (!FileHandle && (!FileName || !*FileName)) {
        return NULL;
    }

    SetLastError(NO_ERROR);

    pIDD = InitDebugData();
    if (!pIDD)
        return NULL;

    pIDD->flags = dwFlags;

    __try {

        // store off parameters

        pIDD->InProcImageBase = ImageBase;
        pIDD->hProcess = hProcess;
        pIDD->mld = mld;
        
        if (FileName && !FileNameIsPdb(pIDD, FileName)) 
            lstrcpy(pIDD->ImageName, FileName);

        if (SymbolPath) {
            pIDD->SymbolPath = (PCHAR)MemAlloc(strlen(SymbolPath) + 1);
            if (pIDD->SymbolPath) {
                strcpy(pIDD->SymbolPath, SymbolPath);
            }
        }

        // if we have a base pointer into process memory.  See what we can get here.
        if (pIDD->InProcImageBase) {
            pIDD->fInProcHeader = ProcessInProcDebugInfo(pIDD);
            if (pIDD->fInProcHeader)
                pIDD->ImageSrc = srcMemory;
        } 
        
        // find disk-based image

        if (FileHandle) {
            // if passed a handle, save it

            if (!DuplicateHandle(
                                 GetCurrentProcess(),
                                 FileHandle,
                                 GetCurrentProcess(),
                                 &pIDD->ImageFileHandle,
                                 GENERIC_READ,
                                 FALSE,
                                 DUPLICATE_SAME_ACCESS
                                ))
            {
                return NULL;
            }
            pIDD->ImageSrc = srcHandle;
            if (FileName) {
                strcpy(pIDD->ImageFilePath, FileName);
            }

        } else if (!pIDD->fInProcHeader)
        {
            // otherwise use the file name to open the disk image
            // only if we didn't have access to in-proc headers
            pIDD->ImageFileHandle = FindExecutableImageEx(pIDD->ImageName,
                                                          SymbolPath,
                                                          pIDD->ImageFilePath,
                                                          FindExecutableImageExCallback,
                                                          pIDD);
        }

        // if we have a file handle.  See what we can get here.
        if (pIDD->ImageFileHandle) {
            if (!pIDD->DbgFileHandle && !*pIDD->PdbFileName) {
                ProcessImageDebugInfo(pIDD);
            }
        }

        // get info from the caller's data struct
        ProcessCallerDataDebugInfo(pIDD);

        // search for pdb, if indicated or if we have found no image info, so far
        pIDD->DbgFileHandle = 0;
        if (!pIDD->Characteristics || (pIDD->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {
            if (*pIDD->OriginalDbgFileName) {
                pIDD->DbgFileHandle = fnFindDebugInfoFileEx(
                                            pIDD->OriginalDbgFileName,
                                            pIDD->SymbolPath,
                                            pIDD->DbgFilePath,
                                            FindDebugInfoFileExCallback,
                                            pIDD,
                                            fdifRECURSIVE);
            }
            if (!pIDD->DbgFileHandle) {
                pIDD->DbgFileHandle = fnFindDebugInfoFileEx(
                                            pIDD->ImageName,
                                            pIDD->SymbolPath,
                                            pIDD->DbgFilePath,
                                            FindDebugInfoFileExCallback,
                                            pIDD,
                                            fdifRECURSIVE);
            }
            if (!pIDD->DbgFileHandle)
                g.LastSymLoadError = SYMLOAD_DBGNOTFOUND;
        }

        // if we have a .dbg file.  See what we can get from it.
        if (pIDD->DbgFileHandle) {
            ProcessDbgDebugInfo(pIDD);
        }

        // make sure we can process omaps
        if (!pIDD->ImageAlign)
            pIDD->fNeedImage = TRUE;

        // check one more time to see if information we have acquired
        // indicates we need the image from disk.
        if (FileName && *FileName && pIDD->fNeedImage) {
            pIDD->ImageFileHandle = FindExecutableImageEx(FileName,
                                                          SymbolPath,
                                                          pIDD->ImageFilePath,
                                                          FindExecutableImageExCallback,
                                                          pIDD);
            if (pIDD->ImageFileHandle) { 
                ProcessImageDebugInfo(pIDD);
            }
        }

        // if there's a pdb.  Pull what we can from there.
        if (*pIDD->PdbFileName) {
            diaOpenPdb(pIDD);

        // otherwise, if old codeview, pull from there
        } else if (pIDD->pMappedCv) {
            ProcessOldStyleCodeView(pIDD);

        // otherwise if we couldn't read from the image info, look for PDB anyway
        } else if (!pIDD->ImageFileHandle && !pIDD->DbgFileHandle) {
            if (FakePdbName(pIDD)) {
                diaOpenPdb(pIDD);
            }
        }

        // if all else fails, one more try for a dbg
        if (!(pIDD->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)
            && !pIDD->DbgFileHandle
            && !SymbolInfoFound(pIDD)
            )
        {
            pIDD->DbgFileHandle = fnFindDebugInfoFileEx(
                                        (*pIDD->OriginalDbgFileName) ? pIDD->OriginalDbgFileName : pIDD->ImageName,
                                        pIDD->SymbolPath,
                                        pIDD->DbgFilePath,
                                        FindDebugInfoFileExCallback,
                                        pIDD,
                                        fdifRECURSIVE);
            
            // if we have a .dbg file.  See what we can get from it.
            if (pIDD->DbgFileHandle) {
                ProcessDbgDebugInfo(pIDD);
            }
        }

        if (!pIDD->OriginalImageFileName[0]) {
            FigureOutImageName(pIDD);
        }

        GetUnfoundData(pIDD);
//      mdDump(pIDD->md, FALSE);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        if (pIDD) {
            ReleaseDebugData(pIDD, IMGHLP_FREE_ALL);
            pIDD = NULL;
        }
    }

    return pIDD;
}


PIMGHLP_DEBUG_DATA
InitDebugData(
    VOID
    )
{
    PIMGHLP_DEBUG_DATA pIDD;

    pIDD = (PIMGHLP_DEBUG_DATA)MemAlloc(sizeof(IMGHLP_DEBUG_DATA));
    if (!pIDD) {
        SetLastError(ERROR_OUTOFMEMORY);
        g.LastSymLoadError = SYMLOAD_OUTOFMEMORY;
        return NULL;
    }
    
    ZeroMemory(pIDD, sizeof(IMGHLP_DEBUG_DATA));

    pIDD->md = (PMODULE_DATA)MemAlloc(sizeof(gmd));
    if (!pIDD->md) {
        SetLastError(ERROR_OUTOFMEMORY);
        g.LastSymLoadError = SYMLOAD_OUTOFMEMORY;
        MemFree(pIDD);
        return NULL;
    }
    memcpy(pIDD->md, gmd, sizeof(gmd));

    return pIDD;
}


void
ReleaseDebugData(
    PIMGHLP_DEBUG_DATA pIDD,
    DWORD              dwFlags
    )
{
    if (!pIDD)
        return;

    if (pIDD->ImageMap) {
        UnmapViewOfFile(pIDD->ImageMap);
    }

    if (pIDD->ImageFileHandle) {
        CloseHandle(pIDD->ImageFileHandle);
    }

    if (pIDD->DbgFileMap) {
        UnmapViewOfFile(pIDD->DbgFileMap);
    }

    if (pIDD->DbgFileHandle) {
        CloseHandle(pIDD->DbgFileHandle);
    }

    if ((dwFlags & IMGHLP_FREE_FPO) &&
        pIDD->pFpo &&
        !pIDD->fFpoMapped
       )
    {
        MemFree(pIDD->pFpo);
    }

    if ((dwFlags & IMGHLP_FREE_PDATA) &&
        pIDD->pPData &&
        !pIDD->fPDataMapped
       )
    {
        MemFree(pIDD->pPData);
    }

    if ((dwFlags & IMGHLP_FREE_XDATA) &&
        pIDD->pXData &&
        !pIDD->fXDataMapped
       )
    {
        MemFree(pIDD->pXData);
    }

    if ((dwFlags & IMGHLP_FREE_PDATA) &&
        pIDD->pMappedCoff &&
        !pIDD->fCoffMapped
       )
    {
        MemFree(pIDD->pMappedCoff);
    }

    if ((dwFlags & IMGHLP_FREE_PDATA) &&
        pIDD->pMappedCv &&
        !pIDD->fCvMapped
       )
    {
        MemFree(pIDD->pMappedCv);
    }

    if ((dwFlags & IMGHLP_FREE_OMAPT) &&
        pIDD->pOmapTo &&
        !pIDD->fOmapToMapped
       )
    {
        MemFree(pIDD->pOmapTo);
    }

    if ((dwFlags & IMGHLP_FREE_OMAPF) &&
        pIDD->pOmapFrom &&
        !pIDD->fOmapFromMapped
       )
    {
        MemFree(pIDD->pOmapFrom);
    }

    if ((dwFlags & IMGHLP_FREE_OSECT) &&
        pIDD->pOriginalSections
       )
    {
        MemFree(pIDD->pOriginalSections);
    }

    if ((dwFlags & IMGHLP_FREE_CSECT) &&
        pIDD->pCurrentSections &&
        !pIDD->fCurrentSectionsMapped
       )
    {
        MemFree(pIDD->pCurrentSections);
    }

    if (pIDD->SymbolPath) {
        MemFree(pIDD->SymbolPath);
    }

    MemFree(pIDD->md);

    MemFree(pIDD);

    return;
}



#ifdef MAP_DEBUG_TEST

#if 0

void
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    CHAR szSymPath[4096];
    PIMGHLP_DEBUG_DATA pDebugInfo;

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test1");
    pDebugInfo = GetDebugData(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test1\\ntoskrnl.exe", szSymPath, 0x1000000, NULL, 0);
    ReleaseDebugData(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test2");
    pDebugInfo = GetDebugData(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test2\\ntoskrnl.exe", szSymPath, 0x1000000, NULL, 0);
    ReleaseDebugData(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test3");
    pDebugInfo = GetDebugData(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test3\\ntoskrnl.exe", szSymPath, 0x1000000, NULL, 0);
    ReleaseDebugData(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test4");
    pDebugInfo = GetDebugData(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test4\\ntoskrnl.exe", szSymPath, 0x1000000, NULL, 0);
    ReleaseDebugData(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test5");
    pDebugInfo = GetDebugData(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test5\\ntdll.dll", szSymPath, 0x1000000, NULL, 0);
    ReleaseDebugData(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test6");
    pDebugInfo = GetDebugData(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test6\\ntdll.dll", szSymPath, 0x1000000, NULL, 0);
    ReleaseDebugData(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test7");
    pDebugInfo = GetDebugData(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test7\\osloader.exe", szSymPath, 0x1000000, NULL, 0);
    ReleaseDebugData(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test8");
    pDebugInfo = GetDebugData(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test8\\osloader.exe", szSymPath, 0x1000000, NULL, 0);
    ReleaseDebugData(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test9");
    pDebugInfo = GetDebugData(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test9\\msvcrt.dll", szSymPath, 0x1000000, NULL, 0);
    ReleaseDebugData(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test10");
    pDebugInfo = GetDebugData(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test10\\msvcrt.dll", szSymPath, 0x1000000, NULL, 0);
    ReleaseDebugData(pDebugInfo, IMGHLP_FREE_ALL);
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\mapdebugtst.c ===
#define MAP_DEBUG_TEST
#include "mapdebug.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\pdbp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pdb.h

Abstract:

    This header file contains typedefs and prototypes
    necessary for accessing pdb files thru the msvc pdb dll.

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

__inline
char *
DataSymNameStart(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return (char *)&((DATASYM32_16t *)dataSym)->name[1];

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return (char *)&((DATASYM32 *)dataSym)->name[1];
    }
}


__inline
unsigned char
DataSymNameLength(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return(((DATASYM32_16t *)dataSym)->name[0]);

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return(((DATASYM32 *)dataSym)->name[0]);
    }
}


__inline
unsigned short
DataSymSeg(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return(((DATASYM32_16t *)dataSym)->seg);

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return(((DATASYM32 *)dataSym)->seg);
    }
}


__inline
unsigned long
DataSymOffset(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return(((DATASYM32_16t *)dataSym)->off);

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return(((DATASYM32 *)dataSym)->off);
    }
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\msvcrtp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msvcrtp.c

Abstract:

    This module implements vector new and delete so that
    dbghelp will run on systems with old copies of msvcrt.dll

Author:

    Pat Styles (patst) 09-November-2000

Revision History:

--*/

#ifdef _X86_
              
// these two exist so that we can work with old
// versions of msvcrt.dll that ships in NT4, SP6 and earlier

void __cdecl operator delete[](void * p)
{
    operator delete( p );
}

void * __cdecl operator new[]( size_t cb )
{
    void *res = operator new(cb);
    return res;
}

#endif // #ifdef _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\private.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    imagehlp.h

Abstract:

    This is a private header file for imagehlp.

Revision History:

--*/

#ifndef _IMAGEHLP_PRV_
#define _IMAGEHLP_PRV_

#define _IMAGEHLP_SOURCE_
#define _IA64REG_
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <memory.h>
#include <malloc.h>
#include <dbgeng.h>
#if DBG
// disable the -DNDEBUG set by oak\bin\makefile.def
#undef NDEBUG
#endif // DBG
#include <assert.h>
#include <string.h>
#include <time.h>
#include <ntverp.h>
#include <cvexefmt.h>
#define PDB_LIBRARY
#include <pdb.h>
#include "pdbp.h"

#ifdef __cplusplus
extern "C" {
#endif

// used for delayloading the pdb handler

#define REGKEY_DBGHELP    "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\dbgHelp"
#define REGVAL_PDBHANDLER "PDBHandler"

// define the module

#ifdef BUILD_DBGHELP
 #define MOD_FILENAME "dbghelp.dll"
 #define MOD_NAME     "dbghelp"
#else
 #define MOD_FILENAME "imagehlp.dll"
 #define MOD_NAME     "imagehlp"
#endif

#ifndef SIZEOF_ARRAY
    #define SIZEOF_ARRAY(_ar)        (sizeof(_ar)/sizeof((_ar)[0]))
#endif // !defined(SIZEOF_ARRAY)

/******************************************************************************
On a Hydra System, we don't want imaghlp.dll to load user32.dll since it
prevents CSRSS from exiting when running a under a debugger.
The following two functions have been copied from user32.dll so that we don't
link to user32.dll.
******************************************************************************/
#undef CharNext
#undef CharPrev

LPSTR CharNext(
    LPCSTR lpCurrentChar);

LPSTR CharPrev(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar);


// Define some list prototypes

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
// some helpers for PE32/PE64 issues
//

#define OPTIONALHEADER(field) (OptionalHeader32 ? (OptionalHeader32->field) : (OptionalHeader64 ? OptionalHeader64->field : 0))
#define OPTIONALHEADER_LV(field) (*(OptionalHeader32 ? &(OptionalHeader32->field) : &(OptionalHeader64->field)))
#define OPTIONALHEADER_ASSIGN(field,value) (OptionalHeader32 ? (OptionalHeader32->field=(value)) : (OptionalHeader64->field=(value)))
#define OPTIONALHEADER_SET_FLAG(field,flag) (OptionalHeader32 ? (OptionalHeader32->field |=(flag)) : (OptionalHeader64->field|=(flag)))
#define OPTIONALHEADER_CLEAR_FLAG(field,flag) (OptionalHeader32 ? (OptionalHeader32->field &=(~flag)) : (OptionalHeader64->field&=(~flag)))


// IA64 unwind specific structures
#define VWNDIA64_FIXUP_TABLE_SIZE           5
#define VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE  5

typedef struct _VWNDIA64_FUXUP_REGION {
    ULONGLONG Ip;
    ULONGLONG Begin;
    ULONGLONG End;
    ULONGLONG Fixup;
} VWNDIA64_FUXUP_REGION, *PVWNDIA64_FUXUP_REGION;

typedef struct _VWNDIA64_UNWIND_CONTEXT {
    BOOL bFailureReported;
    VWNDIA64_FUXUP_REGION FixupTable[VWNDIA64_FIXUP_TABLE_SIZE];
} VWNDIA64_UNWIND_CONTEXT, *PVWNDIA64_UNWIND_CONTEXT;

// stackwalk operation flags

#define WALK_FIX_FPO_EBP    0x1

__inline
void
OptionalHeadersFromNtHeaders(
    PIMAGE_NT_HEADERS32 NtHeaders,
    PIMAGE_OPTIONAL_HEADER32 *OptionalHeader32,
    PIMAGE_OPTIONAL_HEADER64 *OptionalHeader64
    )
{
    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        if ( OptionalHeader32 )   {
            *OptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)&NtHeaders->OptionalHeader;
        }
        if ( OptionalHeader64 )  {
            *OptionalHeader64 = NULL;
        }
    } else
    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        if ( OptionalHeader64 )    {
            *OptionalHeader64 = (PIMAGE_OPTIONAL_HEADER64)&NtHeaders->OptionalHeader;
        }
        if ( OptionalHeader32 )  {
            *OptionalHeader32 = NULL;
        }
    }
}

#define DebugDirectoryIsUseful(Pointer, Size) (    \
    (Pointer != NULL) &&                          \
    (Size >= sizeof(IMAGE_DEBUG_DIRECTORY)) &&    \
    ((Size % sizeof(IMAGE_DEBUG_DIRECTORY)) == 0) \
    )

ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    IN  HANDLE                  hProcess,
    IN  LPSTR                   ModuleName,
    IN  LPSTR                   FileName,
    OUT PDWORD64                Buffer,
    IN  ULONG                   BufferLines
    );

BOOL
CalculateImagePtrs(
    PLOADED_IMAGE LoadedImage
    );

typedef void * ( __cdecl * Alloc_t )( unsigned int );
typedef void   ( __cdecl * Free_t  )( void * );

typedef BOOL  (__stdcall *PINTERNAL_GET_MODULE)(HANDLE,LPSTR,DWORD64,DWORD,PVOID);
typedef PCHAR (__cdecl *PUNDNAME)( char *, const char *, int, Alloc_t, Free_t, unsigned short);

#ifdef IMAGEHLP_HEAP_DEBUG

#define HEAP_SIG 0x69696969
typedef struct _HEAP_BLOCK {
    LIST_ENTRY  ListEntry;
    ULONG       Signature;
    ULONG_PTR   Size;
    ULONG       Line;
    CHAR        File[16];
} HEAP_BLOCK, *PHEAP_BLOCK;

#define MemAlloc(s)     pMemAlloc(s,__LINE__,__FILE__)
#define MemReAlloc(s,n) pMemReAlloc(s,n,__LINE__,__FILE__)
#define MemFree(p)      pMemFree(p,__LINE__,__FILE__)
#define CheckHeap(p)    pCheckHeap(p,__LINE__,__FILE__)
#define HeapDump(s)     pHeapDump(s,__LINE__,__FILE__)
#define MemSize(p)      pMemSize(p)
#define HeapInitList(p) InitializeListHead(p);
#else
#define MemAlloc(s)     pMemAlloc(s)
#define MemReAlloc(s,n) pMemReAlloc(s,n)
#define MemFree(p)      pMemFree(p)
#define CheckHeap(p)
#define HeapDump(s)
#define MemSize(p)      pMemSize(p)
#define HeapInitList(p)
#endif

#ifdef IMAGEHLP_HEAP_DEBUG
BOOL
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    );
 
BOOL
pHeapDump(
    LPSTR sz,
    ULONG line,
    LPSTR file
    );

VOID PrintAllocations(VOID);
#endif
         

PVOID
pMemAlloc(
    ULONG_PTR AllocSize
#ifdef IMAGEHLP_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

PVOID
pMemReAlloc(
    PVOID OldAlloc,
    ULONG_PTR AllocSize
#ifdef IMAGEHLP_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

VOID
pMemFree(
    PVOID MemPtr
#ifdef IMAGEHLP_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

ULONG_PTR
pMemSize(
    PVOID MemPtr
    );

#define MAP_READONLY  TRUE
#define MAP_READWRITE FALSE


BOOL
MapIt(
    HANDLE FileHandle,
    PLOADED_IMAGE LoadedImage,
    BOOL ReadOnly
    );

VOID
UnMapIt(
    PLOADED_IMAGE LoadedImage
    );

BOOL
GrowMap(
    PLOADED_IMAGE   LoadedImage,
    LONG            lSizeOfDelta
    );

DWORD
ImagepSetLastErrorFromStatus(
    IN DWORD Status
    );

BOOL
UnloadAllImages(
    void
    );

#define CALLBACK_STACK(f)      (f->KdHelp.ThCallbackStack)
#define CALLBACK_BSTORE(f)     (f->KdHelp.ThCallbackBStore)
#define CALLBACK_NEXT(f)       (f->KdHelp.NextCallback)
#define CALLBACK_FUNC(f)       (f->KdHelp.KiCallUserMode)
#define CALLBACK_THREAD(f)     (f->KdHelp.Thread)
#define CALLBACK_FP(f)         (f->KdHelp.FramePointer)
#define CALLBACK_DISPATCHER(f) (f->KdHelp.KeUserCallbackDispatcher)
#define SYSTEM_RANGE_START(f)  (f->KdHelp.SystemRangeStart)

// These modifications of the RF_ macros are required because of the need
// for an explicit ULONG64 result

#define ALPHA_RF_FIXED_RETURN64(RF) (((ULONG64)(RF)->ExceptionHandler) & (~3))
#define ALPHA_RF_ALT_PROLOG64(RF)   (((ULONG64)(RF)->ExceptionHandler) & (~3))

extern ULONG g_vc7fpo;

BOOL
WalkX86(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress,
    DWORD                             flags
    );

BOOL
WalkIa64(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
WalkAlpha(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    BOOL                              Use64
    );

BOOL
WalkAmd64(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

void
ConvertAlphaRf32To64(
    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY rf32,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY rf64
    );

void
SymParseArgs(
    LPCSTR args
    );

VOID
EnsureTrailingBackslash(
    LPSTR sz
    );

enum {
    dsNone = 0,
    dsInProc,
    dsImage,
    dsDbg,
    dsPdb,
    dsDia,
    dsCallerData
};

typedef struct _OMAP {
    ULONG  rva;
    ULONG  rvaTo;
} OMAP, *POMAP;

typedef struct _OMAPLIST {
   struct _OMAPLIST *next;
   OMAP             omap;
   ULONG            cb;
} OMAPLIST, *POMAPLIST;

enum {
    mdHeader = 100,
    mdSecHdrs,
    mdNum
};

#define NUM_MODULE_DATA_ENTRIES 14

typedef BOOL (*PGETINFOPROC)(struct _IMGHLP_DEBUG_DATA *);

typedef struct _MODULE_DATA {
    DWORD        id;
    DWORD        hint;
    DWORD        src;
    BOOL         required;
    PGETINFOPROC fn;
} MODULE_DATA, *PMODULE_DATA;

typedef struct _IMGHLP_DEBUG_DATA {
    PCHAR   SymbolPath;
    ULONG64 InProcImageBase;
    ULONG64 ImageBaseFromImage;
    DWORD   SizeOfImage;
    DWORD   CheckSum;
    DWORD   TimeDateStamp;
    DWORD   Characteristics;
    USHORT  Machine;
    CHAR    ImageFilePath[_MAX_PATH];
    CHAR    OriginalImageFileName[_MAX_PATH];           // Retrieved from the .dbg file for cases when we only have a file handle...
    HANDLE  ImageFileHandle;
    PVOID   ImageMap;
    USHORT  iohMagic;
    CHAR    DbgFilePath[_MAX_PATH];
    CHAR    OriginalDbgFileName[_MAX_PATH];
    HANDLE  DbgFileHandle;
    PVOID   DbgFileMap;
    DWORD   PdbAge;
    DWORD   PdbSignature;
    BOOL    PdbRSDS;
    GUID    PdbGUID;
    CHAR    PdbFileName[_MAX_PATH];
    CHAR    PdbReferencePath[_MAX_PATH];
    ULONG   ImageType;
    ULONG   ImageSrc;
    ULONG   PdbSrc;
    PCHAR   pMappedCv;
    PCHAR   pMappedCoff;
//  PCHAR   pMappedExportDirectory;
    PCHAR   pMappedDbgFunction;     // PIMAGE_FUNCTION_ENTRY from the .dbg file
    PVOID   pFpo;
    PVOID   pPData;                 // PIMAGE_RUNTIME_FUNCTION_ENTRY from the image.
    PVOID   pXData;
    POMAP   pOmapTo;
    POMAP   pOmapFrom;
    PIMAGE_SECTION_HEADER   pImageSections;
    PIMAGE_SECTION_HEADER   pDbgSections;
    PIMAGE_SECTION_HEADER   pOriginalSections;
    PIMAGE_SECTION_HEADER   pCurrentSections;
    DWORD   ddva;                   // only used by MapDebugInformation - virtual addr of debug dirs
    DWORD   cdd;                    // only used by MapDebugInformation - number of debug dirs
//  ULONG   NumberOfPdataFunctionEntries;
    ULONG   cFpo;
    ULONG   cPData;
    ULONG   cbPData;
    ULONG   cXData;
    ULONG   cbXData;
    ULONG   cOmapTo;
    ULONG   cOmapFrom;
    ULONG   cImageSections;
    ULONG   cDbgSections;
    ULONG   cOriginalSections;
    ULONG   cCurrentSections;
    ULONG   cMappedCv;
    ULONG   cMappedCoff;
    ULONG   ImageAlign;
    BOOL    fPE64;
    BOOL    fROM;
    BOOL    fCoffMapped;
    BOOL    fCvMapped;               
    BOOL    fFpoMapped;
    BOOL    fPDataMapped;
    BOOL    fXDataMapped;
    BOOL    fOmapToMapped;
    BOOL    fOmapFromMapped;
    BOOL    fCurrentSectionsMapped;
    BOOL    fInProcHeader;
    HANDLE  hProcess;
    CHAR    ImageName[_MAX_PATH];
    DWORD   dsExports;
    DWORD   dsCoff;
    DWORD   dsCV;
    DWORD   dsMisc;
    DWORD   dsFPO;
    DWORD   dsOmapTo;
    DWORD   dsOmapFrom;
    DWORD   dsExceptions;
    IMAGE_EXPORT_DIRECTORY expdir;
    DWORD   fNeedImage;
    PVOID   dia;
    DWORD   flags;
    PMODULE_DATA md;
    DWORD64 oExports;
    DWORD   cExports;
    PMODLOAD_DATA mld;
} IMGHLP_DEBUG_DATA, *PIMGHLP_DEBUG_DATA;

typedef struct {
    DWORD rvaBeginAddress;
    DWORD rvaEndAddress;
    DWORD rvaPrologEndAddress;
    DWORD rvaExceptionHandler;
    DWORD rvaHandlerData;
} IMGHLP_RVA_FUNCTION_DATA, *PIMGHLP_RVA_FUNCTION_DATA;

#ifndef _WIN64

typedef struct {
    PIMGHLP_DEBUG_DATA pIDD;
} PIDI_HEADER, *PPIDI_HEADER;

typedef struct {
    PIDI_HEADER             hdr;
    IMAGE_DEBUG_INFORMATION idi;
} PIDI, *PPIDI;

#endif


PIMGHLP_DEBUG_DATA
GetDebugData(
    HANDLE        hProcess,
    HANDLE        FileHandle,
    LPSTR         FileName,
    LPSTR         SymbolPath,
    ULONG64       ImageBase,
    PMODLOAD_DATA mld,
    ULONG         dwFlags
    );

BOOL
CopyPdb(
    CHAR const * SrcPdb,
    CHAR const * DestPdb,
    BOOL StripPrivate
    );

BOOL
IMAGEAPI
RemovePrivateCvSymbolic(
    PCHAR   DebugData,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    );

BOOL
IMAGEAPI
RemovePrivateCvSymbolicEx(
    PCHAR   DebugData,
    ULONG   DebugSize,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    );


#define NO_PE64_IMAGES  0x01000

#define IMGHLP_FREE_ALL     0xffffffff
#define IMGHLP_FREE_FPO     0x00000001
#define IMGHLP_FREE_PDATA   0x00000002
#define IMGHLP_FREE_OMAPT   0x00000004
#define IMGHLP_FREE_OMAPF   0x00000008
#define IMGHLP_FREE_PDB     0x00000010
#define IMGHLP_FREE_SYMPATH 0x00000020
#define IMGHLP_FREE_OSECT   0x00000040
#define IMGHLP_FREE_CSECT   0x00000080
#define IMGHLP_FREE_XDATA   0x00000100

PIMGHLP_DEBUG_DATA
InitDebugData(
    VOID
    );

void
ReleaseDebugData(
    PIMGHLP_DEBUG_DATA,
    DWORD
    );

ULONG
ReadImageData(
    IN  HANDLE  hprocess,
    IN  ULONG64 ul,
    IN  ULONG64 addr,
    OUT LPVOID  buffer,
    IN  ULONG   size
    );

#if DBG

VOID
__cdecl
dbPrint(
    LPCSTR fmt,
    ...
    );

#else

 #define dbPrint

#endif

__inline
BOOL
IsPE64(PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER) OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC ? TRUE : FALSE;
}

__inline
UCHAR *
OHMajorLinkerVersion(PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->MajorLinkerVersion);
}

__inline
UCHAR *
OHMinorLinkerVersion(PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->MinorLinkerVersion);
}

__inline
ULONG  *
OHSizeOfCode (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->SizeOfCode);
}

__inline
ULONG  *
OHSizeOfInitializedData (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->SizeOfInitializedData);
}

__inline
ULONG  *
OHSizeOfUninitializedData (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->SizeOfUninitializedData);
}

__inline
ULONG  *
OHAddressOfEntryPoint (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->AddressOfEntryPoint);
}

__inline
ULONG  *
OHBaseOfCode (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->BaseOfCode);
}

__inline
ULONG  *
OHImageBase (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->ImageBase) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->ImageBase);
}

__inline
ULONG  *
OHSectionAlignment (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SectionAlignment) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SectionAlignment);
}

__inline
ULONG  *
OHFileAlignment (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->FileAlignment) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->FileAlignment);
}

__inline
USHORT *
OHMajorOperatingSystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MajorOperatingSystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MajorOperatingSystemVersion);
}

__inline
USHORT *
OHMinorOperatingSystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MinorOperatingSystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MinorOperatingSystemVersion);
}

__inline
USHORT *
OHMajorImageVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MajorImageVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MajorImageVersion);
}

__inline
USHORT *
OHMinorImageVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MinorImageVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MinorImageVersion);
}

__inline
USHORT *
OHMajorSubsystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MajorSubsystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MajorSubsystemVersion);
}

__inline
USHORT *
OHMinorSubsystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MinorSubsystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MinorSubsystemVersion);
}

__inline
ULONG  *
OHWin32VersionValue (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->Win32VersionValue) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->Win32VersionValue);
}

__inline
ULONG  *
OHSizeOfImage (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfImage) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfImage);
}

__inline
ULONG  *
OHSizeOfHeaders (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfHeaders) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfHeaders);
}

__inline
ULONG  *
OHCheckSum (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->CheckSum) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->CheckSum);
}

__inline
USHORT *
OHSubsystem (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->Subsystem) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->Subsystem);
}

__inline
USHORT *
OHDllCharacteristics (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->DllCharacteristics) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->DllCharacteristics);
}

__inline
ULONG  *
OHSizeOfStackReserve (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfStackReserve) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfStackReserve);
}

__inline
ULONG  *
OHSizeOfStackCommit (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfStackCommit) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfStackCommit);
}

__inline
ULONG  *
OHSizeOfHeapReserve (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfHeapReserve) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfHeapReserve);
}

__inline
ULONG  *
OHSizeOfHeapCommit (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfHeapCommit) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfHeapCommit);
}

__inline
ULONG  *
OHLoaderFlags (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->LoaderFlags) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->LoaderFlags);
}

__inline
ULONG  *
OHNumberOfRvaAndSizes (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->NumberOfRvaAndSizes) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->NumberOfRvaAndSizes);
}

__inline
IMAGE_DATA_DIRECTORY *
OHDataDirectory (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->DataDirectory[0]) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->DataDirectory[0]);
}

PVOID
MapItRO(
      HANDLE FileHandle
      );

HANDLE
IMAGEAPI
fnFindDebugInfoFileEx(
    IN  LPSTR FileName,
    IN  LPSTR SymbolPath,
    OUT LPSTR DebugFilePath,
    IN  PFIND_DEBUG_FILE_CALLBACK Callback,
    IN  PVOID CallerData,
    IN  DWORD flag
    );

BOOL
GetFileFromSymbolServer(
    IN  LPCSTR ServerInfo,
    IN  LPCSTR FileName,
    IN  GUID  *id,
    IN  DWORD  two,
    IN  DWORD  three,
    OUT LPSTR FilePath
    );

void
CloseSymbolServer(
    VOID
    );

void
SetSymbolServerOptions(
    ULONG_PTR options,
    ULONG64   data
    );

void
SetSymbolServerCallback(
    BOOL state
    );

#define fdifRECURSIVE   0x1

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\rebase.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rebase.c

Abstract:

    Source file for the REBASE utility that takes a group of image files and
    rebases them so they are packed as closely together in the virtual address
    space as possible.

Author:

    Mark Lucovsky (markl) 30-Apr-1993

Revision History:

--*/

#include <private.h>

#define ROUNDUP(x, y) ((x + (y-1)) & ~(y-1))

VOID
RemoveRelocations(
    PCHAR ImageName
    );


#define REBASE_ERR 99
#define REBASE_OK  0
ULONG ReturnCode = REBASE_OK;

#define ROUND_UP( Size, Amount ) (((ULONG)(Size) + ((Amount) - 1)) & ~((Amount) - 1))

BOOL fVerbose;
BOOL fQuiet;
BOOL fGoingDown;
BOOL fSumOnly;
BOOL fRebaseSysfileOk;
BOOL fShowAllBases;
BOOL fCoffBaseIncExt;
FILE *CoffBaseDotTxt;
FILE *BaseAddrFile;
FILE *RebaseLog;
ULONG SplitFlags;
BOOL fRemoveRelocs;
BOOL fUpdateSymbolsOnly;

LPSTR BaseAddrFileName;

BOOL
ProcessGroupList(
    LPSTR ImagesRoot,
    LPSTR GroupListFName,
    BOOL  fReBase,
    BOOL  fOverlay
    );

BOOL
FindInIgnoreList(
    LPSTR chName
    );

ULONG64
FindInBaseAddrFile(
    LPSTR Name,
    PULONG pulSize
    );

VOID
ReBaseFile(
    LPSTR pstrName,
    BOOL  fReBase
    );

VOID
ParseSwitch(
    CHAR chSwitch,
    int *pArgc,
    char **pArgv[]
    );


VOID
ShowUsage(
    VOID
    );

typedef struct _GROUPNODE {
    struct _GROUPNODE *pgnNext;
    PCHAR chName;
} GROUPNODE, *PGROUPNODE;

PGROUPNODE pgnIgnoreListHdr, pgnIgnoreListEnd;

typedef BOOL (__stdcall *REBASEIMAGE64) (
    IN     PSTR CurrentImageName,
    IN     PSTR SymbolPath,
    IN     BOOL  fReBase,          // TRUE if actually rebasing, false if only summing
    IN     BOOL  fRebaseSysfileOk, // TRUE is system images s/b rebased
    IN     BOOL  fGoingDown,       // TRUE if the image s/b rebased below the given base
    IN     ULONG CheckImageSize,   // Max size allowed  (0 if don't care)
    OUT    ULONG *OldImageSize,    // Returned from the header
    OUT    ULONG64 *OldImageBase,  // Returned from the header
    OUT    ULONG *NewImageSize,    // Image size rounded to next separation boundary
    IN OUT ULONG64 *NewImageBase,  // (in) Desired new address.
                                   // (out) Next address (actual if going down)
    IN     ULONG TimeStamp         // new timestamp for image, if non-zero
    );

REBASEIMAGE64 pReBaseImage64;

UCHAR ImagesRoot[ MAX_PATH+1 ];
PCHAR SymbolPath;
UCHAR DebugFilePath[ MAX_PATH+1 ];

ULONG64 OriginalImageBase;
ULONG OriginalImageSize;
ULONG64 NewImageBase;
ULONG NewImageSize;

ULONG64 InitialBase = 0;
ULONG64 MinBase = (~((ULONG64)0));
ULONG64 TotalSize;

ULONG SizeAdjustment;


int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    char chChar, *pchChar;
    envp;
    _tzset();

    pgnIgnoreListHdr = (PGROUPNODE) malloc( sizeof ( GROUPNODE ) );
    pgnIgnoreListHdr->chName = NULL;
    pgnIgnoreListHdr->pgnNext = NULL;
    pgnIgnoreListEnd = pgnIgnoreListHdr;

    pReBaseImage64 = (REBASEIMAGE64) GetProcAddress(GetModuleHandle("imagehlp.dll"), "ReBaseImage64");
    if (!pReBaseImage64) {
        puts("REBASE: Warning\n"
             "REBASE: Warning - unable to correctly rebase 64-bit images - update your imagehlp.dll\n"
             "REBASE: Warning");
        pReBaseImage64 = (REBASEIMAGE64) GetProcAddress(GetModuleHandle("imagehlp.dll"), "ReBaseImage");
    }

    fVerbose = FALSE;
    fQuiet = FALSE;
    fGoingDown = FALSE;
    fSumOnly = FALSE;
    fRebaseSysfileOk = FALSE;
    fShowAllBases = FALSE;

    ImagesRoot[ 0 ] = '\0';

    if (argc <= 1) {
        ShowUsage();
        }

    while (--argc) {
        pchChar = *++argv;
        if (*pchChar == '/' || *pchChar == '-') {
            while (chChar = *++pchChar) {
                ParseSwitch( chChar, &argc, &argv );
                }
            }
        else {
            if (*pchChar == '@') {
                // Inline response file with a list of files to rebase.
                FILE *hFiles =fopen(pchChar+1, "rt");
                int ScanRet;
                CHAR pchFileName[_MAX_PATH];
                if (hFiles == NULL) {
                    fprintf( stderr, "REBASE: fopen %s failed %d\n", pchChar+1, errno );
                    ExitProcess( REBASE_ERR );
                }

                ScanRet = fscanf( hFiles, "%s", pchFileName );
                while (ScanRet && ScanRet != EOF) {
                    if ( !FindInIgnoreList( pchFileName ) ) {
                        ReBaseFile( pchFileName, TRUE );
                    }
                    ScanRet = fscanf( hFiles, "%s", pchFileName );
                }
                fclose(hFiles);
            } else {
                if ( !FindInIgnoreList( pchChar ) ) {
                    ReBaseFile( pchChar, TRUE );
                    }
                }
            }
        }

    if ( !fQuiet ) {

        if ( BaseAddrFile ) {
            InitialBase = MinBase;
        }

        if ( fGoingDown ) {
            TotalSize = InitialBase - NewImageBase;
        }
        else {
            TotalSize = NewImageBase - InitialBase;
        }

        fprintf( stdout, "\n" );
        fprintf( stdout, "REBASE: Total Size of mapping 0x%016I64x\n", TotalSize );
        fprintf( stdout, "REBASE: Range 0x%016I64x -0x%016I64x\n",
                 min(NewImageBase, InitialBase), max(NewImageBase, InitialBase));

        if (RebaseLog) {
            fprintf( RebaseLog, "\nTotal Size of mapping 0x%016I64x\n", TotalSize );
            fprintf( RebaseLog, "Range 0x%016I64x -0x%016I64x\n\n",
                     min(NewImageBase, InitialBase), max(NewImageBase, InitialBase));
        }
    }

    if (RebaseLog) {
        fclose(RebaseLog);
        }

    if (BaseAddrFile){
        fclose(BaseAddrFile);
        }

    if (CoffBaseDotTxt){
        fclose(CoffBaseDotTxt);
        }

    return ReturnCode;
}


VOID
ShowUsage(
    VOID
    )
{
    fputs( "usage: REBASE [switches]\n"
           "              [-R image-root [-G filename] [-O filename] [-N filename]]\n"
           "              image-names... \n"
           "\n"
           "              One of -b and -i switches are mandatory.\n"
           "\n"
           "              [-a] Does nothing\n"
           "              [-b InitialBase] specify initial base address\n"
           "              [-c coffbase_filename] generate coffbase.txt\n"
           "                  -C includes filename extensions, -c does not\n"
           "              [-d] top down rebase\n"
           "              [-e SizeAdjustment] specify extra size to allow for image growth\n"
           "              [-f] Strip relocs after rebasing the image\n"
           "              [-i coffbase_filename] get base addresses from coffbase_filename\n"
           "              [-l logFilePath] write image bases to log file.\n"
           "              [-p] Does nothing\n"
           "              [-q] minimal output\n"
           "              [-s] just sum image range\n"
           "              [-u symbol_dir] Update debug info in .DBG along this path\n"
           "              [-v] verbose output\n"
           "              [-x symbol_dir] Same as -u\n"
           "              [-z] allow system file rebasing\n"
           "              [-?] display this message\n"
           "\n"
           "              [-R image_root] set image root for use by -G, -O, -N\n"
           "              [-G filename] group images together in address space\n"
           "              [-O filename] overlay images in address space\n"
           "              [-N filename] leave images at their origional address\n"
           "                  -G, -O, -N, may occur multiple times.  File \"filename\"\n"
           "                  contains a list of files (relative to \"image-root\")\n" ,
           stderr );

    exit( REBASE_ERR );
}


VOID
ParseSwitch(
    CHAR chSwitch,
    int *pArgc,
    char **pArgv[]
    )
{

    switch (toupper( chSwitch )) {

        case '?':
            ShowUsage();
            break;

        case 'A':
            break;

        case 'B':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            if (sscanf(**pArgv, "%I64x", &InitialBase) == 1) {
                NewImageBase = InitialBase;
            }
            break;

        case 'C':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            fCoffBaseIncExt = (chSwitch == 'C');
            CoffBaseDotTxt = fopen( *(*pArgv), "at" );
            if ( !CoffBaseDotTxt ) {
                fprintf( stderr, "REBASE: fopen %s failed %d\n", *(*pArgv), errno );
                ExitProcess( REBASE_ERR );
                }
            break;

        case 'D':
            fGoingDown = TRUE;
            break;

        case 'E':
            if (!--(*pArgc)) {
                ShowUsage();
            }
            (*pArgv)++;
            if (sscanf(**pArgv, "%x", &SizeAdjustment) != 1) {
                ShowUsage();
            }
            break;

        case 'F':
            fRemoveRelocs = TRUE;
            break;

        case 'G':
        case 'O':
        case 'N':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            if (!ImagesRoot[0]) {
                fprintf( stderr, "REBASE: -R must preceed -%c\n", chSwitch );
                exit( REBASE_ERR );
                }
            ProcessGroupList( (PCHAR) ImagesRoot,
                              *(*pArgv),
                              toupper(chSwitch) != 'N',
                              toupper(chSwitch) == 'O');
            break;

        case 'I':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            BaseAddrFileName = *(*pArgv);
            BaseAddrFile = fopen( *(*pArgv), "rt" );
            if ( !BaseAddrFile ) {
                fprintf( stderr, "REBASE: fopen %s failed %d\n", *(*pArgv), errno );
                ExitProcess( REBASE_ERR );
                }
            break;

        case 'L':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            RebaseLog = fopen( *(*pArgv), "at" );
            if ( !RebaseLog ) {
                fprintf( stderr, "REBASE: fopen %s failed %d\n", *(*pArgv), errno );
                ExitProcess( REBASE_ERR );
                }
            break;

        case 'P':
            break;

        case 'Q':
            fQuiet = TRUE;
            break;

        case 'R':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            strcpy( (PCHAR) ImagesRoot, *(*pArgv) );
            break;

        case 'S':
            fprintf(stdout,"\n");
            fSumOnly = TRUE;
            break;

        case 'U':
        case 'X':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            fUpdateSymbolsOnly = TRUE;
            SymbolPath = **pArgv;
            break;

        case 'V':
            fVerbose = TRUE;
            break;

        case 'Z':
            fRebaseSysfileOk = TRUE;
            break;

        default:
            fprintf( stderr, "REBASE: Invalid switch - /%c\n", chSwitch );
            ShowUsage();
            break;

        }
}


BOOL
ProcessGroupList(
    LPSTR ImagesRoot,
    LPSTR GroupListFName,
    BOOL  fReBase,
    BOOL  fOverlay
    )
{

    PGROUPNODE pgn;
    FILE *GroupList;

    CHAR  chName[MAX_PATH+1];
    int   ateof;
    ULONG64 SavedImageBase;
    ULONG MaxImageSize=0;

    DWORD dw;
    CHAR  Buffer[ MAX_PATH+1 ];
    LPSTR FilePart;


    if (RebaseLog) {
        fprintf( RebaseLog, "*** %s\n", GroupListFName );
    }

    GroupList = fopen( GroupListFName, "rt" );
    if ( !GroupList ) {
        fprintf( stderr, "REBASE: fopen %s failed %d\n", GroupListFName, errno );
        ExitProcess( REBASE_ERR );
    }

    ateof = fscanf( GroupList, "%s", chName );

    SavedImageBase = NewImageBase;

    while ( ateof && ateof != EOF ) {

        dw = SearchPath( ImagesRoot, chName, NULL, sizeof(Buffer), Buffer, &FilePart );
        if ( dw == 0 || dw > sizeof( Buffer ) ) {
            if (!fQuiet) {
                fprintf( stderr, "REBASE: Could Not Find %s\\%s\n", ImagesRoot, chName );
            }
        }
        else {

            _strlwr( Buffer );  // Lowercase for consistency when displayed.

            pgn = (PGROUPNODE) malloc( sizeof( GROUPNODE ) );
            if ( NULL == pgn ) {
                fprintf( stderr, "REBASE: *** malloc failed.\n" );
                ExitProcess( REBASE_ERR );
            }
            pgn->chName = _strdup( Buffer );
            if ( NULL == pgn->chName ) {
                fprintf( stderr, "REBASE: *** strdup failed (%s).\n", Buffer );
                ExitProcess( REBASE_ERR );
            }
            pgn->pgnNext = NULL;
            pgnIgnoreListEnd->pgnNext = pgn;
            pgnIgnoreListEnd = pgn;

            ReBaseFile( Buffer, fReBase );

            if ( fOverlay ) {
                if ( MaxImageSize < NewImageSize ) {
                    MaxImageSize = NewImageSize;
                }
                NewImageBase = SavedImageBase;
            }
        }

        ateof = fscanf( GroupList, "%s", chName );
    }

    fclose( GroupList );

    if ( fOverlay ) {
        if ( fGoingDown ) {
            NewImageBase -= ROUND_UP( MaxImageSize, IMAGE_SEPARATION );
        }
        else {
            NewImageBase += ROUND_UP( MaxImageSize, IMAGE_SEPARATION );
        }
    }

    if (RebaseLog) {
        fprintf( RebaseLog, "\n" );
    }

    return TRUE;
}


BOOL
FindInIgnoreList(
    LPSTR chName
    )
{
    PGROUPNODE pgn;

    DWORD dw;
    CHAR  Buffer[ MAX_PATH+1 ];
    LPSTR FilePart;


    dw = GetFullPathName( chName, sizeof(Buffer), Buffer, &FilePart );
    if ( dw == 0 || dw > sizeof( Buffer ) ) {
        fprintf( stderr, "REBASE: *** GetFullPathName failed (%s).\n", chName );
        ExitProcess( REBASE_ERR );
        }

    for (pgn = pgnIgnoreListHdr->pgnNext;
         pgn != NULL;
         pgn = pgn->pgnNext) {

        if (!_stricmp( Buffer, pgn->chName ) ) {
            return TRUE;
            }

        }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
/*
******************************************************************************
On a Hydra System, we don't want imaghlp.dll to load user32.dll since it
prevents CSRSS from exiting when running a under a debugger.
The following function has been copied from user32.dll so that we don't
link to user32.dll.
******************************************************************************
*/

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


VOID
ReBaseFile(
    LPSTR CurrentImageName,
    BOOL fReBase
    )
{
    DWORD dw;
    CHAR  Buffer[ MAX_PATH+1 ];
    CHAR  Buffer2[ MAX_PATH+1 ];
    LPSTR FilePart;
    LPSTR LocalSymbolPath;
    ULONG ThisImageExpectedSize = 0;
    ULONG64 ThisImageRequestedBase = NewImageBase;
    ULONG TimeStamp;
    static char LastName = '\0';
    static ULONG LastTimeStamp = 0;
    BOOL FirstPass = TRUE;

    if ( !InitialBase && !BaseAddrFile ) {
        fprintf( stderr, "REBASE: -b switch must specify a non-zero base  --or--\n" );
        fprintf( stderr, "        -i must specify a filename\n" );
        exit( REBASE_ERR );
        }

    if ( BaseAddrFile && ( InitialBase || fGoingDown || CoffBaseDotTxt ) ) {
        fprintf( stderr, "REBASE: -i is incompatible with -b, -d, and -c\n" );
        exit( REBASE_ERR );
    }

    dw = GetFullPathName( CurrentImageName, sizeof(Buffer), Buffer, &FilePart );
    if ( dw == 0 || dw > sizeof(Buffer) ) {
        FilePart = CurrentImageName;
    }
    _strlwr( FilePart );  // Lowercase for consistency when displayed.

    if ( BaseAddrFile && !(NewImageBase = ThisImageRequestedBase = FindInBaseAddrFile( FilePart, &ThisImageExpectedSize )) ) {
        fprintf( stdout, "REBASE: %-16s Not listed in %s\n", FilePart, BaseAddrFileName );
    }

    if (fUpdateSymbolsOnly) {
        // On update, the symbol path is a semi-colon delimited path.  Find the one we want and
        // then fix the path for RebaseImage.
        HANDLE hDebugFile;
        CHAR Drive[_MAX_DRIVE];
        CHAR Dir[_MAX_DIR];
        PCHAR s;
        hDebugFile = FindDebugInfoFile(CurrentImageName, SymbolPath, DebugFilePath);
        if ( hDebugFile ) {
            CloseHandle(hDebugFile);
            _splitpath(DebugFilePath, Drive, Dir, NULL, NULL);
            _makepath(Buffer2, Drive, Dir, NULL, NULL);
            s = Buffer2 + strlen(Buffer2);
            s = CharPrev(Buffer2, s);
            if (*s == '\\') {
                *s = '\0';
            }
            LocalSymbolPath = Buffer2;
        } else {
            LocalSymbolPath = NULL;
        }
    } else {
        LocalSymbolPath = SymbolPath;
    }

    NewImageSize = (ULONG) -1;  // Hack so we can tell when system images are skipped.

    time( (time_t *) &TimeStamp );

    // Ensure all images with the same first letter have unique timestamps.

    if (!LastTimeStamp)
        LastTimeStamp = TimeStamp;

    if (LastName ==  *FilePart) {
        TimeStamp = LastTimeStamp++;
    } else {
        LastTimeStamp = TimeStamp;
        LastName = *FilePart;
    }

RebaseAgain:

    if (!(*pReBaseImage64)( CurrentImageName,
                      (PCHAR) LocalSymbolPath,
                      fReBase && !fSumOnly,
                      fRebaseSysfileOk,
                      fGoingDown,
                      ThisImageExpectedSize,
                      &OriginalImageSize,
                      &OriginalImageBase,
                      &NewImageSize,
                      &ThisImageRequestedBase,
                      TimeStamp ) ) {

        if (ThisImageRequestedBase == 0) {
            fprintf(stderr,
                    "REBASE: %-16s ***Grew too large (Size=0x%x; ExpectedSize=0x%x)\n",
                    FilePart,
                    OriginalImageSize,
                    ThisImageExpectedSize);
        } else {
            if (GetLastError() == ERROR_BAD_EXE_FORMAT) {
                if (fVerbose) {
                    fprintf( stderr,
                            "REBASE: %-16s DOS or OS/2 image ignored\n",
                            FilePart );
                }
            } else
            if (GetLastError() == ERROR_INVALID_ADDRESS) {
                fprintf( stderr,
                        "REBASE: %-16s Rebase failed.  Relocations are missing or new address is invalid\n",
                        FilePart );
                if (RebaseLog) {
                    fprintf( RebaseLog,
                             "%16s based at 0x%016I64x (size 0x%08x)  Unable to rebase. (missing relocations or new address is invalid)\n",
                             FilePart,
                             OriginalImageBase,
                             OriginalImageSize);
                }
            } else {
                fprintf( stderr,
                        "REBASE: *** RelocateImage failed (%s).  Image may be corrupted\n",
                        FilePart );
            }
        }

        ReturnCode = REBASE_ERR;
        return;

    } else {
        if (GetLastError() == ERROR_INVALID_DATA) {
            fprintf(stderr, "REBASE: Warning: DBG checksum did not match image.\n");
        }
    }

    // Keep track of the lowest base address.

    if (MinBase > NewImageBase) {
        MinBase = NewImageBase;
    }

    if ( fSumOnly || !fReBase ) {
        if (!fQuiet) {
            fprintf( stdout,
                     "REBASE: %16s mapped at %016I64x (size 0x%08x)\n",
                     FilePart,
                     OriginalImageBase,
                     OriginalImageSize);
        }
    } else {
        if (SizeAdjustment && FirstPass && (NewImageSize != (ULONG) -1)) {
            if ((OriginalImageSize + SizeAdjustment) > NewImageSize) {
                // If we were to add SizeAdjustment to the image (say as a ServicePack or QFE fix), we'd blow
                // out our space.  Make room so this isn't necessary.
    
                if (fGoingDown) {
                    // Going down - the requested base is where we need our image
                    // to end - adjust it down so we have room to grow and go again.
                    FirstPass = FALSE;
                    NewImageBase -= IMAGE_SEPARATION;
                    ThisImageRequestedBase = NewImageBase;
                    goto RebaseAgain;
                } else {
                    // Going up.  Move the next guy up so we can grow.
                    ThisImageRequestedBase += IMAGE_SEPARATION;
                }
            }
        }
    
        if (RebaseLog) {
            fprintf( RebaseLog,
                     "%16s rebased to 0x%016I64x (size 0x%08x)\n",
                     FilePart,
                     fGoingDown ? ThisImageRequestedBase : NewImageBase,
                     NewImageSize);
        }

        if ((NewImageSize != (ULONG) -1) &&
            (OriginalImageBase != (fGoingDown ? ThisImageRequestedBase : NewImageBase)) &&
            ( fVerbose || fQuiet )
           ) {
            if ( fVerbose ) {
                fprintf( stdout,
                         "REBASE: %16s initial base at 0x%016I64x (size 0x%08x)\n",
                         FilePart,
                         OriginalImageBase,
                         OriginalImageSize);
            }

            fprintf( stdout,
                     "REBASE: %16s rebased to 0x%016I64x (size 0x%08x)\n",
                     FilePart,
                     fGoingDown ? ThisImageRequestedBase : NewImageBase,
                     NewImageSize);

            if ( fVerbose && fUpdateSymbolsOnly && DebugFilePath[0]) {
                char szExt[_MAX_EXT];
                _splitpath(DebugFilePath, NULL, NULL, NULL, szExt);
                if (_stricmp(szExt, ".pdb")) {
                    fprintf( stdout, "REBASE: %16s updated image base in %s\n", FilePart, DebugFilePath );
                }
            }
        }

        if (fRemoveRelocs) {
            RemoveRelocations(CurrentImageName);
        }
    }

    if ( CoffBaseDotTxt ) {
        if ( !fCoffBaseIncExt ) {
            char *n;
            if ( n  = strrchr(FilePart,'.') ) {
                *n = '\0';
            }
        }

        fprintf( CoffBaseDotTxt,
                 "%-16s 0x%016I64x 0x%08x\n",
                 FilePart,
                 fSumOnly ? OriginalImageBase : (fGoingDown ? ThisImageRequestedBase : NewImageBase),
                 NewImageSize);
    }

    NewImageBase = ThisImageRequestedBase;   // Set up the next one...
}

ULONG64
FindInBaseAddrFile(
    LPSTR Name,
    PULONG pulSize
    )
{

    struct {
        CHAR  Name[MAX_PATH+1];
        ULONG64 Base;
        ULONG Size;
    } BAFileEntry;

    CHAR NameNoExt[MAX_PATH+1];
//    PCHAR pchExt;
    int ateof;


    strcpy(NameNoExt,Name);
//    if (pchExt = strrchr(NameNoExt,'.')) {
//        *pchExt = '\0';
//        }

    if (fseek(BaseAddrFile, 0, SEEK_SET)) {
        return 0;
    }

    ateof = fscanf(BaseAddrFile,"%s %I64x %x",BAFileEntry.Name,&BAFileEntry.Base,&BAFileEntry.Size);
    while ( ateof && ateof != EOF ) {
        if ( !_stricmp(NameNoExt,BAFileEntry.Name) ) {
            *pulSize = BAFileEntry.Size;
            return BAFileEntry.Base;
            }
        ateof = fscanf(BaseAddrFile,"%s %I64x %x",BAFileEntry.Name,&BAFileEntry.Base,&BAFileEntry.Size);
        }

    *pulSize = 0;
    return 0;
}

VOID
RemoveRelocations(
    PCHAR ImageName
    )
{
    // UnSafe...

    LOADED_IMAGE li;
    IMAGE_SECTION_HEADER RelocSectionHdr, *Section, *pRelocSecHdr;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    ULONG DebugDirectorySize, i, RelocSecNum;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    if (!MapAndLoad(ImageName, NULL, &li, FALSE, FALSE)) {
        return;
    }

    FileHeader = &li.FileHeader->FileHeader;

    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)li.FileHeader, &OptionalHeader32, &OptionalHeader64);
    if (!OptionalHeader32 && !OptionalHeader64)
        return;

    // See if the image has already been stripped or there are no relocs.

    if ((FileHeader->Characteristics & IMAGE_FILE_RELOCS_STRIPPED) ||
        (!OPTIONALHEADER(DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size))) {
        UnMapAndLoad(&li);
        return;
    }

    for (Section = li.Sections, i = 0; i < li.NumberOfSections; Section++, i++) {
        if (Section->PointerToRawData != 0) {
            if (!_stricmp( (char *) Section->Name, ".reloc" )) {
                RelocSectionHdr = *Section;
                pRelocSecHdr = Section;
                RelocSecNum = i + 1;
            }
        }
    }

    RelocSectionHdr.Misc.VirtualSize = ROUNDUP(RelocSectionHdr.Misc.VirtualSize, OPTIONALHEADER(SectionAlignment));
    RelocSectionHdr.SizeOfRawData = ROUNDUP(RelocSectionHdr.SizeOfRawData, OPTIONALHEADER(FileAlignment));

    if (RelocSecNum != li.NumberOfSections) {
        // Move everything else up and fixup old addresses.
        for (i = RelocSecNum - 1, Section = pRelocSecHdr;i < li.NumberOfSections - 1; Section++, i++) {
            *Section = *(Section + 1);
            Section->VirtualAddress -= RelocSectionHdr.Misc.VirtualSize;
            Section->PointerToRawData -= RelocSectionHdr.SizeOfRawData;
        }
    }

    // Zero out the last one.

    RtlZeroMemory(Section, sizeof(IMAGE_SECTION_HEADER));

    // Reduce the section count.

    FileHeader->NumberOfSections--;

    // Set the strip bit in the header

    FileHeader->Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;

    // If there's a pointer to the coff symbol table, move it back.

    if (FileHeader->PointerToSymbolTable) {
        FileHeader->PointerToSymbolTable -= RelocSectionHdr.SizeOfRawData;
    }

    // Clear out the base reloc entry in the data dir.

    OPTIONALHEADER_LV(DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) = 0;
    OPTIONALHEADER_LV(DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress) = 0;

    // Reduce the Init Data size.

    OPTIONALHEADER_LV(SizeOfInitializedData) -= RelocSectionHdr.Misc.VirtualSize;

    // Reduce the image size.

    OPTIONALHEADER_LV(SizeOfImage) -=
        ((RelocSectionHdr.SizeOfRawData +
          (OPTIONALHEADER(SectionAlignment) - 1)
         ) & ~(OPTIONALHEADER(SectionAlignment) - 1));

    // Move the debug info up (if there is any).

    DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
                            ImageDirectoryEntryToData( li.MappedAddress,
                                                      FALSE,
                                                      IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                      &DebugDirectorySize
                                                    );
    if (DebugDirectoryIsUseful(DebugDirectory, DebugDirectorySize)) {
        for (i = 0; i < (DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY)); i++) {
            RtlMoveMemory(li.MappedAddress + DebugDirectory->PointerToRawData - RelocSectionHdr.SizeOfRawData,
                            li.MappedAddress + DebugDirectory->PointerToRawData,
                            DebugDirectory->SizeOfData);

            DebugDirectory->PointerToRawData -= RelocSectionHdr.SizeOfRawData;

            if (DebugDirectory->AddressOfRawData) {
                DebugDirectory->AddressOfRawData -= RelocSectionHdr.Misc.VirtualSize;
            }

            DebugDirectory++;
        }
    }

    // Truncate the image size

    li.SizeOfImage -= RelocSectionHdr.SizeOfRawData;

    // And we're done.

    UnMapAndLoad(&li);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\splitsymx.h ===
BOOL
SplitSymbolsX(
    LPSTR ImageName,
    LPSTR SymbolsPath,
    LPSTR SymbolFilePath,
    ULONG Flags,
    PCHAR RSDSDllToLoad,
    LPSTR DestinationSymbol,
    DWORD LenDestSymbolBuffer
);

BOOL
CopyPdbX(
    CHAR const * szSrcPdb,
    CHAR const * szDestPdb,
    BOOL StripPrivate,
    CHAR const * szRSDSDllToLoad
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\sources.inc ===
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\imagehlp.def

PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(TARGETNAME).lib}

USE_NOLIBS=1
USE_MSVCRT=1

INCLUDES=..;..\..\dbg-common;..\vc

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\rpcrt4.lib \
    $(SDK_LIB_PATH)\uuid.lib \
    $(SDK_LIB_PATH)\version.lib  \
    $(SDK_LIB_PATH)\advapi32.lib


C_DEFINES=$(C_DEFINES) -DCC_CVTYPE32 -D_VC_VER_INC -DBBTFIX -DUSE_CACHE

UMTYPE=console
SUBSYSTEM_VERSION=4.00

USECXX_FLAG=/TP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\splitsymi.c ===
#include <private.h>
#include <dbgimage.h>

#if defined(use_SplitSymbolsX)
#include <splitsymx.h>
#endif // use_SplitSymbolsX

#define CLEAN_PD(addr) ((addr) & ~0x3)
#define CLEAN_PD64(addr) ((addr) & ~0x3UI64)

#if defined(use_SplitSymbolsX)

BOOL
SplitSymbolsX(
    LPSTR ImageName,
    LPSTR SymbolsPath,
    LPSTR SymbolFilePath,
    ULONG Flags,
    PCHAR RSDSDllToLoad,
    LPSTR DestinationSymbol,
    DWORD LenDestSymbolBuffer
    )

#else

BOOL
IMAGEAPI
SplitSymbols(
    LPSTR ImageName,
    LPSTR SymbolsPath,
    LPSTR SymbolFilePath,
    ULONG Flags
    )

#endif // use_SplitSymbolsX

{
    // UnSafe...

    HANDLE FileHandle, SymbolFileHandle;
    HANDLE hMappedFile;
    LPVOID ImageBase;
    PIMAGE_NT_HEADERS32 NtHeaders;
    LPSTR ImageFileName;
    DWORD SizeOfSymbols;
    ULONG_PTR ImageNameOffset;
    ULONG_PTR DebugSectionStart;
    PIMAGE_SECTION_HEADER DebugSection = NULL;
    DWORD SectionNumber, BytesWritten, NewFileSize, HeaderSum, CheckSum;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory, DebugDirectories, DbgDebugDirectories = NULL;
    IMAGE_DEBUG_DIRECTORY MiscDebugDirectory = {0};
    IMAGE_DEBUG_DIRECTORY FpoDebugDirectory = {0};
    IMAGE_DEBUG_DIRECTORY FunctionTableDir;
    PIMAGE_DEBUG_DIRECTORY pFpoDebugDirectory = NULL;
    DWORD DebugDirectorySize, DbgFileHeaderSize, NumberOfDebugDirectories;
    IMAGE_SEPARATE_DEBUG_HEADER DbgFileHeader;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    DWORD  ExportedNamesSize;
    LPDWORD pp;
    LPSTR ExportedNames = NULL, Src, Dst;
    DWORD i, j, RvaOffset, ExportDirectorySize;
    PFPO_DATA FpoTable = NULL;
    DWORD FpoTableSize;
    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY RuntimeFunctionTable, pSrc;
    DWORD RuntimeFunctionTableSize;
    PIMAGE_FUNCTION_ENTRY FunctionTable = NULL, pDst;
    DWORD FunctionTableSize;
    ULONG NumberOfFunctionTableEntries, DbgOffset;
    DWORD SavedErrorCode;
    BOOL InsertExtensionSubDir;
    LPSTR ImageFilePathToSaveInImage;
    BOOL MiscInRdata = FALSE;
    BOOL DiscardFPO = Flags & SPLITSYM_EXTRACT_ALL;
    BOOL MiscDebugFound, OtherDebugFound, PdbDebugFound;
    BOOL fNewCvData = FALSE;
    PCHAR  NewDebugData = NULL;
    CHAR AltPdbPath[_MAX_PATH];
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader;
    PIMAGE_SECTION_HEADER Sections;
    PCVDD pDebugCV;

    if (Flags & SPLITSYM_SYMBOLPATH_IS_SRC) {
        strncpy(AltPdbPath, SymbolFilePath, sizeof(AltPdbPath));
    }

    ImageFileName = ImageName + strlen( ImageName );
    while (ImageFileName > ImageName) {
        if (*ImageFileName == '\\' ||
            *ImageFileName == '/' ||
            *ImageFileName == ':' )
        {
            ImageFileName = CharNext(ImageFileName);
            break;
        } else {
            ImageFileName = CharPrev(ImageName, ImageFileName);
        }
    }

    if (SymbolsPath == NULL ||
        SymbolsPath[ 0 ] == '\0' ||
        SymbolsPath[ 0 ] == '.' )
    {
        strncpy( SymbolFilePath, ImageName, (int)(ImageFileName - ImageName) );
        SymbolFilePath[ ImageFileName - ImageName ] = '\0';
        InsertExtensionSubDir = FALSE;
    } else {
        strcpy( SymbolFilePath, SymbolsPath );
        InsertExtensionSubDir = TRUE;
    }

    Dst = SymbolFilePath + strlen( SymbolFilePath );
    if (Dst > SymbolFilePath &&
        *CharPrev(SymbolFilePath, Dst) != '\\' &&
        *CharPrev(SymbolFilePath, Dst) != '/'  &&
        *CharPrev(SymbolFilePath, Dst) != ':')
    {
        *Dst++ = '\\';
    }
    ImageFilePathToSaveInImage = Dst;
    Src = strrchr( ImageFileName, '.' );
    if (Src != NULL && InsertExtensionSubDir) {
        while (*Dst = *++Src) {
            Dst += 1;
        }
        *Dst++ = '\\';
    }

    strcpy( Dst, ImageFileName );
    Dst = strrchr( Dst, '.' );
    if (Dst == NULL) {
        Dst = SymbolFilePath + strlen( SymbolFilePath );
    }
    strcpy( Dst, ".dbg" );

#ifdef _WIN64
    return TRUE;
#else

    // Now, open and map the input file.

    FileHandle = CreateFile( ImageName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );


    if (FileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    hMappedFile = CreateFileMapping( FileHandle,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     0,
                                     NULL
                                   );
    if (!hMappedFile) {
        CloseHandle( FileHandle );
        return FALSE;
    }

    ImageBase = MapViewOfFile( hMappedFile,
                               FILE_MAP_WRITE,
                               0,
                               0,
                               0
                             );
    CloseHandle( hMappedFile );
    if (!ImageBase) {
        CloseHandle( FileHandle );
        return FALSE;
    }

    //
    // Everything is mapped. Now check the image and find nt image headers
    //

    NtHeaders = ImageNtHeader( ImageBase );
    if (NtHeaders == NULL) {
        FileHeader = (PIMAGE_FILE_HEADER)ImageBase;
        OptionalHeader = ((PIMAGE_OPTIONAL_HEADER32)((ULONG_PTR)FileHeader+IMAGE_SIZEOF_FILE_HEADER));
        // One last check
        if (OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
            goto HeaderOk;
HeaderBad:
        UnmapViewOfFile( ImageBase );
        CloseHandle( FileHandle );
        SetLastError( ERROR_BAD_EXE_FORMAT );
        return FALSE;
    } else {
        FileHeader = &NtHeaders->FileHeader;
        OptionalHeader = &NtHeaders->OptionalHeader;
        if (OptionalHeader->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
            goto HeaderBad;
    }

HeaderOk:

    if ((OptionalHeader->MajorLinkerVersion < 3) &&
        (OptionalHeader->MinorLinkerVersion < 5) )
    {
        UnmapViewOfFile( ImageBase );
        CloseHandle( FileHandle );
        SetLastError( ERROR_BAD_EXE_FORMAT );
        return FALSE;
    }

    {
        DWORD dwCertificateSize;
        PVOID pCertificates;
        pCertificates = ImageDirectoryEntryToData(ImageBase, FALSE, IMAGE_DIRECTORY_ENTRY_SECURITY, &dwCertificateSize);
        if (pCertificates || dwCertificateSize) {
            // This image has been signed.  Can't strip the symbols w/o invalidating the certificate.
            UnmapViewOfFile( ImageBase );
            CloseHandle( FileHandle );
            SetLastError( ERROR_BAD_EXE_FORMAT );
            return FALSE;
        }
    }

    if (FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)
    {
        // The symbols have already been stripped.  No need to continue.
        UnmapViewOfFile( ImageBase );
        CloseHandle( FileHandle );
        SetLastError( ERROR_ALREADY_ASSIGNED );
        return FALSE;
    }

    DebugDirectories = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData( ImageBase,
                                                  FALSE,
                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                  &DebugDirectorySize
                                                );
    if (!DebugDirectoryIsUseful(DebugDirectories, DebugDirectorySize)) {
        UnmapViewOfFile( ImageBase );
        CloseHandle( FileHandle );
        SetLastError( ERROR_BAD_EXE_FORMAT );
        return FALSE;
    }

    NumberOfDebugDirectories = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

    // See if there's a MISC debug dir and if not, there s/b ONLY a CV data or it's an error.

    MiscDebugFound = FALSE;
    OtherDebugFound = FALSE;
    for (i=0,DebugDirectory=DebugDirectories; i<NumberOfDebugDirectories; i++,DebugDirectory++) {
        switch (DebugDirectory->Type) {
            case IMAGE_DEBUG_TYPE_MISC:
                MiscDebugFound = TRUE;
                break;

            case IMAGE_DEBUG_TYPE_CODEVIEW:
                pDebugCV = ( PCVDD ) (DebugDirectory->PointerToRawData + (PCHAR)ImageBase);
                if (pDebugCV->dwSig == '01BN') {
                    PdbDebugFound = TRUE;
                }
#if defined(use_SplitSymbolsX)
                if (pDebugCV->dwSig == 'SDSR') {
                    PdbDebugFound = TRUE;
                }
#endif
                break;

            default:
                OtherDebugFound = TRUE;
                break;
        }
    }

    if (OtherDebugFound && !MiscDebugFound) {
        UnmapViewOfFile( ImageBase );
        CloseHandle( FileHandle );
        SetLastError( ERROR_BAD_EXE_FORMAT );
        return FALSE;
    }

    if (PdbDebugFound && !OtherDebugFound && (OptionalHeader->MajorLinkerVersion >= 6)) {
        // This is a VC6 generated image.  Don't create a .dbg file.
        MiscDebugFound = FALSE;
    }

    // Make sure we can open the .dbg file before we continue...
    if (!MakeSureDirectoryPathExists( SymbolFilePath )) {
        return FALSE;
    }

    if (MiscDebugFound) {
        // Try to open the symbol file
        SymbolFileHandle = CreateFile( SymbolFilePath,
                                       GENERIC_WRITE,
                                       0,
                                       NULL,
                                       CREATE_ALWAYS,
                                       0,
                                       NULL
                                     );
        if (SymbolFileHandle == INVALID_HANDLE_VALUE) {
            goto nosyms;
        }
    }

    // The entire file is mapped so we don't have to care if the rva's
    // are correct.  It is interesting to note if there's a debug section
    // we need to whack before terminating, though.

    {
        if (NtHeaders) {
            Sections = IMAGE_FIRST_SECTION( NtHeaders );
        } else {
            Sections = (PIMAGE_SECTION_HEADER)
                        ((ULONG_PTR)ImageBase +
                          ((PIMAGE_FILE_HEADER)ImageBase)->SizeOfOptionalHeader +
                          IMAGE_SIZEOF_FILE_HEADER );
        }

        for (SectionNumber = 0;
             SectionNumber < FileHeader->NumberOfSections;
             SectionNumber++ ) {

            if (Sections[ SectionNumber ].PointerToRawData != 0 &&
                !_stricmp( (char *) Sections[ SectionNumber ].Name, ".debug" )) {
                DebugSection = &Sections[ SectionNumber ];
            }
        }
    }

    FpoTable           = NULL;
    ExportedNames      = NULL;
    DebugSectionStart  = 0xffffffff;

    //
    // Find the size of the debug section.
    //

    SizeOfSymbols = 0;

    for (i=0,DebugDirectory=DebugDirectories; i<NumberOfDebugDirectories; i++,DebugDirectory++) {

        switch (DebugDirectory->Type) {
            case IMAGE_DEBUG_TYPE_MISC :

                // Save it away.
                MiscDebugDirectory = *DebugDirectory;

                // check to see if the misc debug data is in some other section.

                // If Address Of Raw Data is cleared, it must be in .debug (there's no such thing as not-mapped rdata)
                // If it's set and there's no debug section, it must be somewhere else.
                // If it's set and there's a debug section, check the range.

                if ((DebugDirectory->AddressOfRawData != 0) &&
                    ((DebugSection == NULL) ||
                     (((DebugDirectory->PointerToRawData < DebugSection->PointerToRawData) ||
                       (DebugDirectory->PointerToRawData >= DebugSection->PointerToRawData + DebugSection->SizeOfRawData)
                      )
                     )
                    )
                   )
                {
                    MiscInRdata = TRUE;
                } else {
                    if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                        DebugSectionStart = DebugDirectory->PointerToRawData;
                    }
                }

                break;

            case IMAGE_DEBUG_TYPE_FPO:
                if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                    DebugSectionStart = DebugDirectory->PointerToRawData;
                }

                // Save it away.

                FpoDebugDirectory = *DebugDirectory;
                pFpoDebugDirectory = DebugDirectory;
                break;

            case IMAGE_DEBUG_TYPE_CODEVIEW:
                {
                    ULONG   NewDebugSize;

                    if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                        DebugSectionStart = DebugDirectory->PointerToRawData;
                    }

                    // If private's are removed do so to the static CV data and save the new size...
                    pDebugCV = ( PCVDD ) (DebugDirectory->PointerToRawData + (PCHAR)ImageBase);
                    if (pDebugCV->dwSig == '01BN') {
                        // Got a PDB.  The name immediately follows the signature.

                        CHAR PdbName[_MAX_PATH];
                        CHAR NewPdbName[_MAX_PATH];
                        CHAR Drive[_MAX_DRIVE];
                        CHAR Dir[_MAX_DIR];
                        CHAR Filename[_MAX_FNAME];
                        CHAR FileExt[_MAX_EXT];
                        BOOL rc;

                        memset(PdbName, 0, sizeof(PdbName));
                        memcpy(PdbName, ((PCHAR)pDebugCV)+ sizeof(NB10IH), DebugDirectory->SizeOfData - sizeof(NB10IH));

                        _splitpath(PdbName, NULL, NULL, Filename, FileExt);
                        _splitpath(SymbolFilePath, Drive, Dir, NULL, NULL);
                        _makepath(NewPdbName, Drive, Dir, Filename, FileExt);
#if defined(use_SplitSymbolsX)
                        if (DestinationSymbol)
                        {
                            strncpy(DestinationSymbol, NewPdbName, LenDestSymbolBuffer);
                            DestinationSymbol[LenDestSymbolBuffer-1] = '\0'; // ensure termination
                        }
                        rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, NULL);
#else
                        rc = CopyPdb(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE);
#endif

                        if (!rc) {
                            if (Flags & SPLITSYM_SYMBOLPATH_IS_SRC) {
                                // Try the AltPdbPath.
                                strcpy(PdbName, AltPdbPath);
                                strcat(PdbName, Filename);
                                strcat(PdbName, FileExt);
#if defined(use_SplitSymbolsX)
                                rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, NULL);
#else
                                rc = CopyPdb(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE);
#endif
                            }

                            if ( !rc) {
                                // It's possible the name in the pdb isn't in the same location as it was when built.  See if we can
                                //  find it in the same dir as the image...
                                _splitpath(ImageName, Drive, Dir, NULL, NULL);
                                _makepath(PdbName, Drive, Dir, Filename, FileExt);
#if defined(use_SplitSymbolsX)
                                rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, NULL);
#else
                                rc = CopyPdb(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE);
#endif
                            }
                        }

                        if (rc) {
                            SetFileAttributes(NewPdbName, FILE_ATTRIBUTE_NORMAL);

                            // Change the data so only the pdb name is in the .dbg file (no path).

                            if (MiscDebugFound) {
                                NewDebugSize = sizeof(NB10IH) + strlen(Filename) + strlen(FileExt) + 1;
#if defined(use_SplitSymbolsX)
                                NewDebugData = (PCHAR) malloc( NewDebugSize );
#else
                                NewDebugData = (PCHAR) MemAlloc( NewDebugSize );
#endif
                                ((PCVDD)NewDebugData)->nb10ih  = pDebugCV->nb10ih;
                                strcpy(NewDebugData + sizeof(NB10IH), Filename);
                                strcat(NewDebugData + sizeof(NB10IH), FileExt);

                                DebugDirectory->PointerToRawData = (ULONG) (NewDebugData - (PCHAR)ImageBase);
                                DebugDirectory->SizeOfData = NewDebugSize;
                            } else {
                                strcpy(((PCHAR)pDebugCV) + sizeof(NB10IH), Filename);
                                strcat(((PCHAR)pDebugCV) + sizeof(NB10IH), FileExt);
                            }
                        } else {
                            // Replace <Path>\<filename>.<ext> with just <filename>.<ext> in the debug data
                            strcpy(((PCHAR)pDebugCV) + sizeof(NB10IH), Filename);
                            strcat(((PCHAR)pDebugCV) + sizeof(NB10IH), FileExt);
                            DebugDirectory->SizeOfData = sizeof(NB10IH) + strlen(Filename) + strlen(FileExt) + 1;
                        }

#if defined(use_SplitSymbolsX)
                    } else if ( pDebugCV->dwSig == 'SDSR') {
                        // Got a PDB.  The name immediately follows the signature.

                        CHAR PdbName[sizeof(((PRSDSI)(0))->szPdb)];
                        CHAR NewPdbName[_MAX_PATH];
                        CHAR Drive[_MAX_DRIVE];
                        CHAR Dir[_MAX_DIR];
                        CHAR Filename[_MAX_FNAME];
                        CHAR FileExt[_MAX_EXT];
                        BOOL rc;

                        ZeroMemory(PdbName, sizeof(PdbName));
                        memcpy(PdbName, ((PCHAR)pDebugCV)+ sizeof(RSDSIH), __min(DebugDirectory->SizeOfData - sizeof(RSDSIH), sizeof(PdbName)));

                        _splitpath(PdbName, NULL, NULL, Filename, FileExt);
                        _splitpath(SymbolFilePath, Drive, Dir, NULL, NULL);
                        _makepath(NewPdbName, Drive, Dir, Filename, FileExt);
                        if (DestinationSymbol)
                        {
                            strncpy(DestinationSymbol, NewPdbName, LenDestSymbolBuffer);
                            DestinationSymbol[LenDestSymbolBuffer-1] = '\0'; // ensure termination
                        }
                        rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, RSDSDllToLoad);

                        if (!rc) {
                            if (Flags & SPLITSYM_SYMBOLPATH_IS_SRC) {
                                // Try the AltPdbPath.
                                strcpy(PdbName, AltPdbPath);
                                strcat(PdbName, Filename);
                                strcat(PdbName, FileExt);
                                rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, RSDSDllToLoad);
                            }

                            if ( !rc) {
                                // It's possible the name in the pdb isn't in the same location as it was when built.  See if we can
                                //  find it in the same dir as the image...
                                _splitpath(ImageName, Drive, Dir, NULL, NULL);
                                _makepath(PdbName, Drive, Dir, Filename, FileExt);
                                rc = CopyPdbX(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE, RSDSDllToLoad);
                            }
                        }

                        if (rc) {
                            SetFileAttributes(NewPdbName, FILE_ATTRIBUTE_NORMAL);

                            // Change the data so only the pdb name is in the .dbg file (no path).

                            if (MiscDebugFound) {
                                NewDebugSize = sizeof(RSDSIH) + strlen(Filename) + strlen(FileExt) + 1;
                                NewDebugData = (PCHAR) malloc( NewDebugSize );
                                ((PCVDD)NewDebugData)->rsdsih  = pDebugCV->rsdsih;
                                strcpy(NewDebugData + sizeof(RSDSIH), Filename);
                                strcat(NewDebugData + sizeof(RSDSIH), FileExt);

                                DebugDirectory->PointerToRawData = (ULONG) (NewDebugData - (PCHAR)ImageBase);
                                DebugDirectory->SizeOfData = NewDebugSize;
                            } else {
                                strcpy(((PCHAR)pDebugCV) + sizeof(RSDSIH), Filename);
                                strcat(((PCHAR)pDebugCV) + sizeof(RSDSIH), FileExt);
                            }
                        } else {
                            // Replace <Path>\<filename>.<ext> with just <filename>.<ext> in the debug data
                            strcpy(((PCHAR)pDebugCV) + sizeof(NB10IH), Filename);
                            strcat(((PCHAR)pDebugCV) + sizeof(NB10IH), FileExt);
                            DebugDirectory->SizeOfData = sizeof(RSDSIH) + strlen(Filename) + strlen(FileExt) + 1;
                        }

#endif
                    } else {
                        if (Flags & SPLITSYM_REMOVE_PRIVATE) {
                            if (RemovePrivateCvSymbolicEx(DebugDirectory->PointerToRawData + (PCHAR)ImageBase,
                                                    DebugDirectory->SizeOfData,
                                                    &NewDebugData,
                                                    &NewDebugSize)) {
                                if (DebugDirectory->PointerToRawData != (ULONG) (NewDebugData - (PCHAR)ImageBase))
                                {
                                    DebugDirectory->PointerToRawData = (ULONG) (NewDebugData - (PCHAR)ImageBase);
                                    DebugDirectory->SizeOfData = NewDebugSize;
                                } else {
                                    NewDebugData = NULL;
                                }
                            }
                        }
                    }
                }

                break;

            case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
            case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                    DebugSectionStart = DebugDirectory->PointerToRawData;
                }

                // W/o the OMAP, FPO is useless.
                DiscardFPO = TRUE;
                break;

            case IMAGE_DEBUG_TYPE_FIXUP:
                if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                    DebugSectionStart = DebugDirectory->PointerToRawData;
                }

                // If all PRIVATE debug is removed, don't send FIXUP along.
                if (Flags & SPLITSYM_REMOVE_PRIVATE) {
                    DebugDirectory->SizeOfData = 0;
                }
                break;

            default:
                if (DebugDirectory->SizeOfData &&
                   (DebugDirectory->PointerToRawData < DebugSectionStart))
                {
                    DebugSectionStart = DebugDirectory->PointerToRawData;
                }

                // Nothing else to special case...
                break;
        }

        SizeOfSymbols += (DebugDirectory->SizeOfData + 3) & ~3; // Minimally align it all.
    }

    if (!MiscDebugFound) {
        NewFileSize = GetFileSize(FileHandle, NULL);

        CheckSumMappedFile( ImageBase,
                            NewFileSize,
                            &HeaderSum,
                            &CheckSum
                          );
        OptionalHeader->CheckSum = CheckSum;

        goto nomisc;
    }

    if (DiscardFPO) {
        pFpoDebugDirectory = NULL;
    }

    if (pFpoDebugDirectory) {
        // If FPO stays here, make a copy so we don't need to worry about stomping on it.

        FpoTableSize = pFpoDebugDirectory->SizeOfData;
#if defined(use_SplitSymbolsX)
        FpoTable = (PFPO_DATA) malloc( FpoTableSize );
#else
        FpoTable = (PFPO_DATA) MemAlloc( FpoTableSize );
#endif
        if ( FpoTable == NULL ) {
            goto nosyms;
        }

        RtlMoveMemory( FpoTable,
                       (PCHAR) ImageBase + pFpoDebugDirectory->PointerToRawData,
                       FpoTableSize );
    }

    ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
        ImageDirectoryEntryToData( ImageBase,
                                   FALSE,
                                   IMAGE_DIRECTORY_ENTRY_EXPORT,
                                   &ExportDirectorySize
                                 );
    if (ExportDirectory) {
        //
        // This particular piece of magic gets us the RVA of the
        // EXPORT section.  Dont ask.
        //

        RvaOffset = (ULONG_PTR)
            ImageDirectoryEntryToData( ImageBase,
                                       TRUE,
                                       IMAGE_DIRECTORY_ENTRY_EXPORT,
                                       &ExportDirectorySize
                                     ) - (ULONG_PTR)ImageBase;

        pp = (LPDWORD)((ULONG_PTR)ExportDirectory +
                      (ULONG_PTR)ExportDirectory->AddressOfNames - RvaOffset
                     );

        ExportedNamesSize = 1;
        for (i=0; i<ExportDirectory->NumberOfNames; i++) {
            Src = (LPSTR)((ULONG_PTR)ExportDirectory + *pp++ - RvaOffset);
            ExportedNamesSize += strlen( Src ) + 1;
        }
        ExportedNamesSize = (ExportedNamesSize + 16) & ~15;

#if defined(use_SplitSymbolsX)
        Dst = (LPSTR) malloc( ExportedNamesSize );
#else
        Dst = (LPSTR) MemAlloc( ExportedNamesSize );
#endif
        if (Dst != NULL) {
            ExportedNames = Dst;
            pp = (LPDWORD)((ULONG_PTR)ExportDirectory +
                          (ULONG_PTR)ExportDirectory->AddressOfNames - RvaOffset
                         );
            for (i=0; i<ExportDirectory->NumberOfNames; i++) {
                Src = (LPSTR)((ULONG_PTR)ExportDirectory + *pp++ - RvaOffset);
                while (*Dst++ = *Src++) {
                    ;
                }
            }
        }
    } else {
        ExportedNamesSize = 0;
    }

    RuntimeFunctionTable = (PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)
        ImageDirectoryEntryToData( ImageBase,
                                   FALSE,
                                   IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                   &RuntimeFunctionTableSize
                                 );
    if (RuntimeFunctionTable == NULL) {
        RuntimeFunctionTableSize = 0;
        FunctionTableSize = 0;
        FunctionTable = NULL;
        }
    else {
        NumberOfFunctionTableEntries = RuntimeFunctionTableSize / sizeof( IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY );
        FunctionTableSize = NumberOfFunctionTableEntries * sizeof( IMAGE_FUNCTION_ENTRY );
#if defined(use_SplitSymbolsX)
        FunctionTable = (PIMAGE_FUNCTION_ENTRY) malloc( FunctionTableSize );
#else
        FunctionTable = (PIMAGE_FUNCTION_ENTRY) MemAlloc( FunctionTableSize );
#endif
        if (FunctionTable == NULL) {
            goto nosyms;
            }

        pSrc = RuntimeFunctionTable;
        pDst = FunctionTable;
        for (i=0; i<NumberOfFunctionTableEntries; i++) {
            //
            // Make .pdata entries in .DBG file relative.
            //
            pDst->StartingAddress = CLEAN_PD(pSrc->BeginAddress) - OptionalHeader->ImageBase;
            pDst->EndingAddress = CLEAN_PD(pSrc->EndAddress) - OptionalHeader->ImageBase;
            pDst->EndOfPrologue = CLEAN_PD(pSrc->PrologEndAddress) - OptionalHeader->ImageBase;
            pSrc += 1;
            pDst += 1;
            }
        }

    DbgFileHeaderSize = sizeof( DbgFileHeader ) +
                        ((FileHeader->NumberOfSections - (DebugSection ? 1 : 0)) *
                         sizeof( IMAGE_SECTION_HEADER )) +
                        ExportedNamesSize +
                        FunctionTableSize +
                        DebugDirectorySize;

    if (FunctionTable != NULL) {
        DbgFileHeaderSize += sizeof( IMAGE_DEBUG_DIRECTORY );
        memset( &FunctionTableDir, 0, sizeof( IMAGE_DEBUG_DIRECTORY ) );
        FunctionTableDir.Type = IMAGE_DEBUG_TYPE_EXCEPTION;
        FunctionTableDir.SizeOfData = FunctionTableSize;
        FunctionTableDir.PointerToRawData = DbgFileHeaderSize - FunctionTableSize;
    }

    DbgFileHeaderSize = ((DbgFileHeaderSize + 15) & ~15);

    BytesWritten = 0;

    if (SetFilePointer( SymbolFileHandle,
                        DbgFileHeaderSize,
                        NULL,
                        FILE_BEGIN
                      ) == DbgFileHeaderSize ) {

        for (i=0, DebugDirectory=DebugDirectories;
             i < NumberOfDebugDirectories;
             i++, DebugDirectory++) {

            DWORD WriteCount;

            if (DebugDirectory->SizeOfData) {
                WriteFile( SymbolFileHandle,
                           (PCHAR) ImageBase + DebugDirectory->PointerToRawData,
                           (DebugDirectory->SizeOfData +3) & ~3,
                           &WriteCount,
                           NULL );

                BytesWritten += WriteCount;
            }
        }
    }

    if (BytesWritten == SizeOfSymbols) {
        FileHeader->PointerToSymbolTable = 0;
        FileHeader->NumberOfSymbols = 0;
        FileHeader->Characteristics |= IMAGE_FILE_DEBUG_STRIPPED;

        if (DebugSection != NULL) {
            OptionalHeader->SizeOfImage = DebugSection->VirtualAddress;
            OptionalHeader->SizeOfInitializedData -= DebugSection->SizeOfRawData;
            FileHeader->NumberOfSections--;
            // NULL out that section
            memset(DebugSection, 0, IMAGE_SIZEOF_SECTION_HEADER);
        }

        NewFileSize = DebugSectionStart;  // Start with no symbolic

        //
        // Now that the data has moved to the .dbg file, rebuild the original
        // with MISC debug first and FPO second.
        //

        if (MiscDebugDirectory.SizeOfData) {
            if (MiscInRdata) {
                // Just store the new name in the existing misc field...

                ImageNameOffset = (ULONG_PTR) ((PCHAR)ImageBase +
                                  MiscDebugDirectory.PointerToRawData +
                                  FIELD_OFFSET( IMAGE_DEBUG_MISC, Data ));

                RtlCopyMemory( (LPVOID) ImageNameOffset,
                               ImageFilePathToSaveInImage,
                               strlen(ImageFilePathToSaveInImage) + 1 );
            } else {
                if (DebugSectionStart != MiscDebugDirectory.PointerToRawData) {
                    RtlMoveMemory((PCHAR) ImageBase + DebugSectionStart,
                                  (PCHAR) ImageBase + MiscDebugDirectory.PointerToRawData,
                                  MiscDebugDirectory.SizeOfData);
                }

                ImageNameOffset = (ULONG_PTR) ((PCHAR)ImageBase + DebugSectionStart +
                                  FIELD_OFFSET( IMAGE_DEBUG_MISC, Data ));

                RtlCopyMemory( (LPVOID)ImageNameOffset,
                               ImageFilePathToSaveInImage,
                               strlen(ImageFilePathToSaveInImage) + 1 );

                NewFileSize += MiscDebugDirectory.SizeOfData;
                NewFileSize = (NewFileSize + 3) & ~3;
            }
        }

        if (FpoTable) {
            RtlCopyMemory( (PCHAR) ImageBase + NewFileSize,
                           FpoTable,
                           FpoTableSize );

            NewFileSize += FpoTableSize;
            NewFileSize = (NewFileSize + 3) & ~3;
        }

        // Make a copy of the Debug directory that we can write into the .dbg file

#if defined(use_SplitSymbolsX)
        DbgDebugDirectories = (PIMAGE_DEBUG_DIRECTORY) malloc( NumberOfDebugDirectories * sizeof(IMAGE_DEBUG_DIRECTORY) );
#else
        DbgDebugDirectories = (PIMAGE_DEBUG_DIRECTORY) MemAlloc( NumberOfDebugDirectories * sizeof(IMAGE_DEBUG_DIRECTORY) );
#endif

        RtlMoveMemory(DbgDebugDirectories,
                        DebugDirectories,
                        sizeof(IMAGE_DEBUG_DIRECTORY) * NumberOfDebugDirectories);


        // Then write the MISC and (perhaps) FPO data to the image.

        FpoDebugDirectory.PointerToRawData = DebugSectionStart;
        DebugDirectorySize = 0;

        if (MiscDebugDirectory.SizeOfData != 0) {
            if (!MiscInRdata) {
                MiscDebugDirectory.PointerToRawData = DebugSectionStart;
                FpoDebugDirectory.PointerToRawData += MiscDebugDirectory.SizeOfData;
                MiscDebugDirectory.AddressOfRawData = 0;
            }

            DebugDirectories[0] = MiscDebugDirectory;
            DebugDirectorySize  += sizeof(IMAGE_DEBUG_DIRECTORY);
        }

        if (pFpoDebugDirectory) {
            FpoDebugDirectory.AddressOfRawData = 0;
            DebugDirectories[DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY)] = FpoDebugDirectory;
            DebugDirectorySize += sizeof(IMAGE_DEBUG_DIRECTORY);
        }

        // Zero out remaining slots in image.

        if (NumberOfDebugDirectories < (DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY))) {
            ZeroMemory(&DebugDirectories[DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY)],
                       NumberOfDebugDirectories * sizeof(IMAGE_DEBUG_DIRECTORY) -
                       DebugDirectorySize);
        }

        OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size = DebugDirectorySize;

        DbgOffset = DbgFileHeaderSize;

        for (i = 0, j=0, DebugDirectory=DbgDebugDirectories;
             i < NumberOfDebugDirectories; i++) {

            if (DebugDirectory[i].SizeOfData) {
                DebugDirectory[j] = DebugDirectory[i];

                DebugDirectory[j].AddressOfRawData = 0;
                DebugDirectory[j].PointerToRawData = DbgOffset;

                DbgOffset += (DebugDirectory[j].SizeOfData + 3 )& ~3;
                j++;
            }
        }

        if (FunctionTable) {
            FunctionTableDir.PointerToRawData -= sizeof(IMAGE_DEBUG_DIRECTORY) * (NumberOfDebugDirectories - j);
        }
        NumberOfDebugDirectories = j;

        CheckSumMappedFile( ImageBase,
                            NewFileSize,
                            &HeaderSum,
                            &CheckSum
                          );
        OptionalHeader->CheckSum = CheckSum;

        DbgFileHeader.Signature = IMAGE_SEPARATE_DEBUG_SIGNATURE;
        DbgFileHeader.Flags = 0;
        DbgFileHeader.Machine = FileHeader->Machine;
        DbgFileHeader.Characteristics = FileHeader->Characteristics;
        DbgFileHeader.TimeDateStamp = FileHeader->TimeDateStamp;
        DbgFileHeader.CheckSum = CheckSum;
        DbgFileHeader.ImageBase = OptionalHeader->ImageBase;
        DbgFileHeader.SizeOfImage = OptionalHeader->SizeOfImage;
        DbgFileHeader.ExportedNamesSize = ExportedNamesSize;
        DbgFileHeader.DebugDirectorySize = NumberOfDebugDirectories * sizeof(IMAGE_DEBUG_DIRECTORY);
        if (FunctionTable) {
            DbgFileHeader.DebugDirectorySize += sizeof (IMAGE_DEBUG_DIRECTORY);
        }
        DbgFileHeader.NumberOfSections = FileHeader->NumberOfSections;
        memset( DbgFileHeader.Reserved, 0, sizeof( DbgFileHeader.Reserved ) );
        DbgFileHeader.SectionAlignment = OptionalHeader->SectionAlignment;

        SetFilePointer( SymbolFileHandle, 0, NULL, FILE_BEGIN );
        WriteFile( SymbolFileHandle,
                   &DbgFileHeader,
                   sizeof( DbgFileHeader ),
                   &BytesWritten,
                   NULL
                 );
        if (NtHeaders) {
            Sections = IMAGE_FIRST_SECTION( NtHeaders );
        } else {
            Sections = (PIMAGE_SECTION_HEADER)
                        ((ULONG_PTR)ImageBase +
                          ((PIMAGE_FILE_HEADER)ImageBase)->SizeOfOptionalHeader +
                          IMAGE_SIZEOF_FILE_HEADER );
        }
        WriteFile( SymbolFileHandle,
                   (PVOID)Sections,
                   sizeof( IMAGE_SECTION_HEADER ) * FileHeader->NumberOfSections,
                   &BytesWritten,
                   NULL
                 );

        if (ExportedNamesSize) {
            WriteFile( SymbolFileHandle,
                       ExportedNames,
                       ExportedNamesSize,
                       &BytesWritten,
                       NULL
                     );
        }

        WriteFile( SymbolFileHandle,
                   DbgDebugDirectories,
                   sizeof (IMAGE_DEBUG_DIRECTORY) * NumberOfDebugDirectories,
                   &BytesWritten,
                   NULL );


        if (FunctionTable) {
            WriteFile( SymbolFileHandle,
                       &FunctionTableDir,
                       sizeof (IMAGE_DEBUG_DIRECTORY),
                       &BytesWritten,
                       NULL );

            WriteFile( SymbolFileHandle,
                       FunctionTable,
                       FunctionTableSize,
                       &BytesWritten,
                       NULL
                     );
        }

        SetFilePointer( SymbolFileHandle, 0, NULL, FILE_END );
        CloseHandle( SymbolFileHandle );

nomisc:

        FlushViewOfFile( ImageBase, NewFileSize );
        UnmapViewOfFile( ImageBase );

        SetFilePointer( FileHandle, NewFileSize, NULL, FILE_BEGIN );
        SetEndOfFile( FileHandle );

        TouchFileTimes( FileHandle, NULL );
        CloseHandle( FileHandle );

        if (ExportedNames) {
#if defined(use_SplitSymbolsX)
            free( ExportedNames );
#else
            MemFree( ExportedNames );
#endif
        }

        if (FpoTable) {
#if defined(use_SplitSymbolsX)
            free( FpoTable );
#else
            MemFree( FpoTable );
#endif
        }

        if (FunctionTable) {
#if defined(use_SplitSymbolsX)
            free( FunctionTable );
#else
            MemFree( FunctionTable );
#endif
        }

        if (NewDebugData) {
#if defined(use_SplitSymbolsX)
            free(NewDebugData);
#else
            MemFree(NewDebugData);
#endif
        }

        if (DbgDebugDirectories) {
#if defined(use_SplitSymbolsX)
            free(DbgDebugDirectories);
#else
            MemFree(DbgDebugDirectories);
#endif
        }

        return TRUE;

    } else {
        CloseHandle( SymbolFileHandle );
        DeleteFile( SymbolFilePath );
    }

nosyms:
    SavedErrorCode = GetLastError();
    if (ExportedNames != NULL) {
#if defined(use_SplitSymbolsX)
        free( ExportedNames );
#else
        MemFree( ExportedNames );
#endif
    }

    if (FpoTable != NULL) {
#if defined(use_SplitSymbolsX)
        free( FpoTable );
#else
        MemFree( FpoTable );
#endif
    }

    if (FunctionTable != NULL) {
#if defined(use_SplitSymbolsX)
        free( FunctionTable );
#else
        MemFree( FunctionTable );
#endif
    }

    UnmapViewOfFile( ImageBase );
    CloseHandle( FileHandle );
    SetLastError( SavedErrorCode );
    return FALSE;
#endif
}


#if defined(use_SplitSymbolsX)
LPSTR CharNext(
    LPCSTR lpCurrentChar)
{
    if (IsDBCSLeadByte(*lpCurrentChar)) {
        lpCurrentChar++;
    }
    /*
     * if we have only DBCS LeadingByte, we will point string-terminaler.
     */

    if (*lpCurrentChar) {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;
}

LPSTR CharPrev(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar)
{
    if (lpCurrentChar > lpStart) {
        LPCSTR lpChar;
        BOOL bDBC = FALSE;

        for (lpChar = --lpCurrentChar - 1 ; lpChar >= lpStart ; lpChar--) {
            if (!IsDBCSLeadByte(*lpChar))
                break;
            bDBC = !bDBC;
        }

        if (bDBC)
            lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\rebasei.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rebase.c

Abstract:

    Source file for the REBASE utility that takes a group of image files and
    rebases them so they are packed as closely together in the virtual address
    space as possible.

Author:

    Mark Lucovsky (markl) 30-Apr-1993

Revision History:

--*/

#include <private.h>

//
// byte swapping macros (LE/BE) used for IA64 relocations
// source != destination
//

#define SWAP_SHORT(_dst,_src)                                                  \
   ((((unsigned char *)_dst)[1] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[1]))

#define SWAP_INT(_dst,_src)                                                    \
   ((((unsigned char *)_dst)[3] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[1]),                 \
    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[2]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[3]))

#define SWAP_LONG_LONG(_dst,_src)                                              \
   ((((unsigned char *)_dst)[7] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[6] = ((unsigned char *)_src)[1]),                 \
    (((unsigned char *)_dst)[5] = ((unsigned char *)_src)[2]),                 \
    (((unsigned char *)_dst)[4] = ((unsigned char *)_src)[3]),                 \
    (((unsigned char *)_dst)[3] = ((unsigned char *)_src)[4]),                 \
    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[5]),                 \
    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[6]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[7]))


#define REBASE_ERR 99
#define REBASE_OK  0

static
PVOID
RvaToVa(
    ULONG Rva,
    PLOADED_IMAGE Image
    );

typedef
PIMAGE_BASE_RELOCATION
(WINAPI *LPRELOCATE_ROUTINE)(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff
    );

typedef
PIMAGE_BASE_RELOCATION
(WINAPI *LPRELOCATE_ROUTINE64)(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONGLONG Diff
    );


static LPRELOCATE_ROUTINE RelocRoutineNative;
static LPRELOCATE_ROUTINE64 RelocRoutine64;

PIMAGE_BASE_RELOCATION
xxLdrProcessRelocationBlock64(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONGLONG Diff
    );



#define x256MEG (256*(1024*1024))

#define x256MEGSHIFT 28

#define ROUND_UP( Size, Amount ) (((ULONG)(Size) + ((Amount) - 1)) & ~((Amount) - 1))

VOID
AdjImageBaseSize(
    PULONG  pImageBase,
    PULONG  ImageSize,
    BOOL    fGoingDown
    );


BOOL
RelocateImage(
    PLOADED_IMAGE LoadedImage,
    ULONG64 NewBase,
    ULONG64 *Diff,
    ULONG tstamp
    );

BOOL
ReBaseImage(
    IN     LPSTR CurrentImageName,
    IN     LPSTR SymbolPath,        // Symbol path (if
    IN     BOOL  fReBase,           // TRUE if actually rebasing, false if only summing
    IN     BOOL  fRebaseSysfileOk,  // TRUE is system images s/b rebased
    IN     BOOL  fGoingDown,        // TRUE if the image s/b rebased below the given base
    IN     ULONG CheckImageSize,    // Max size allowed  (0 if don't care)
    OUT    ULONG *OldImageSize,     // Returned from the header
    OUT    ULONG_PTR *OldImageBase, // Returned from the header
    OUT    ULONG *NewImageSize,     // Image size rounded to next separation boundary
    IN OUT ULONG_PTR *NewImageBase, // (in) Desired new address.
                                    // (out) Next new address (above/below this one)
    IN     ULONG tstamp             // new timestamp for image
    )
{
    ULONG64 xOldImageBase = *OldImageBase;
    ULONG64 xNewImageBase = *NewImageBase;
    BOOL rc;

    rc = ReBaseImage64(
        CurrentImageName,
        SymbolPath,
        fReBase,
        fRebaseSysfileOk,
        fGoingDown,
        CheckImageSize,
        OldImageSize,
        &xOldImageBase,
        NewImageSize,
        &xNewImageBase,
        tstamp);

    *OldImageBase = (ULONG_PTR)xOldImageBase;
    *NewImageBase = (ULONG_PTR)xNewImageBase;
    return rc;
}

BOOL
ReBaseImage64(
    IN     LPSTR CurrentImageName,
    IN     LPSTR SymbolPath,       // Symbol path (if
    IN     BOOL  fReBase,          // TRUE if actually rebasing, false if only summing
    IN     BOOL  fRebaseSysfileOk, // TRUE is system images s/b rebased
    IN     BOOL  fGoingDown,       // TRUE if the image s/b rebased below the given base
    IN     ULONG CheckImageSize,   // Max size allowed  (0 if don't care)
    OUT    ULONG *OldImageSize,    // Returned from the header
    OUT    ULONG64 *OldImageBase,  // Returned from the header
    OUT    ULONG *NewImageSize,    // Image size rounded to next separation boundary
    IN OUT ULONG64 *NewImageBase,  // (in) Desired new address.
                                   // (out) Next new address (above/below this one)
    IN     ULONG tstamp            // new timestamp for image
    )
{
    BOOL  fSymbolsAlreadySplit = FALSE;
    CHAR  DebugFileName[ MAX_PATH+1 ];
    CHAR  DebugFilePath[ MAX_PATH+1 ];
    ULONG CurrentImageSize;
    ULONG64 DesiredImageBase;
    ULONG OldChecksum;
    ULONG64 Diff = 0;
    ULONG UpdateSymbolsError = 0;
    LOADED_IMAGE CurrentImage = {0};

    BOOL rc = TRUE;

    if (fReBase && (*NewImageBase & 0x0000FFFF) != 0) {
        rc = FALSE;
        UpdateSymbolsError = ERROR_INVALID_ADDRESS;
        goto Exit;
    }

    // Map and load the current image

    if ( MapAndLoad( CurrentImageName, NULL, &CurrentImage, FALSE, fReBase ? FALSE : TRUE ) ) {
        PVOID pData;
        DWORD dwDataSize;
        pData = ImageDirectoryEntryToData(
                                          CurrentImage.MappedAddress,
                                          FALSE,
                                          IMAGE_DIRECTORY_ENTRY_SECURITY,
                                          &dwDataSize
                                          );

        if (pData || dwDataSize) {
            // Certificates in the image, can't rebase
            UpdateSymbolsError = ERROR_BAD_EXE_FORMAT;
            rc = FALSE;
            goto CleanupAndExit;
        }

        pData = ImageDirectoryEntryToData(
                                          CurrentImage.MappedAddress,
                                          FALSE,
                                          IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                                          &dwDataSize
                                          );

        if (pData || dwDataSize) {
            // COR header found - see if it's strong signed
            if (((IMAGE_COR20_HEADER *)pData)->StrongNameSignature.VirtualAddress &&
                ((IMAGE_COR20_HEADER *)pData)->StrongNameSignature.Size)
            {
                UpdateSymbolsError = ERROR_BAD_EXE_FORMAT;
                rc = FALSE;
                goto CleanupAndExit;
            }
        }

        if (!(!fRebaseSysfileOk && CurrentImage.fSystemImage)) {
            fSymbolsAlreadySplit = CurrentImage.Characteristics & IMAGE_FILE_DEBUG_STRIPPED ? TRUE : FALSE;
            if ( fSymbolsAlreadySplit ) {

                // Find DebugFileName for later use.

                PIMAGE_DEBUG_DIRECTORY DebugDirectories;
                ULONG DebugDirectoriesSize;
                PIMAGE_DEBUG_MISC MiscDebug;

                strcpy( DebugFileName, CurrentImageName );

                DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryEntryToData(
                                                        CurrentImage.MappedAddress,
                                                        FALSE,
                                                        IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                        &DebugDirectoriesSize
                                                        );
                if (DebugDirectoryIsUseful(DebugDirectories, DebugDirectoriesSize)) {
                    while (DebugDirectoriesSize != 0) {
                        if (DebugDirectories->Type == IMAGE_DEBUG_TYPE_MISC) {
                            MiscDebug = (PIMAGE_DEBUG_MISC)
                                ((PCHAR)CurrentImage.MappedAddress +
                                 DebugDirectories->PointerToRawData
                                );
                            strcpy( DebugFileName, (PCHAR) MiscDebug->Data );
                            break;
                        }
                        else {
                            DebugDirectories += 1;
                            DebugDirectoriesSize -= sizeof( *DebugDirectories );
                        }
                    }
                }
            }

            if (CurrentImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                CurrentImageSize = ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.SizeOfImage;
                *OldImageBase = ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.ImageBase;
            } else {
                CurrentImageSize = ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.SizeOfImage;
                *OldImageBase = ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.ImageBase;
            }

            // Save the current settings for the caller.

            *OldImageSize = CurrentImageSize;
            *NewImageSize = ROUND_UP( CurrentImageSize, IMAGE_SEPARATION );

            if (CheckImageSize) {
                // The user asked for a max size test.

                if ( *NewImageSize > ROUND_UP(CheckImageSize, IMAGE_SEPARATION) ) {
                    *NewImageBase = 0;
                    rc = FALSE;
                    goto CleanupAndExit;
                }
            }

            DesiredImageBase = *NewImageBase;

            // So long as we're not basing to zero or rebasing to the same address,
            // go for it.

            if (fReBase) {
                BOOL fAdjust;
                if ((CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) &&
                    (CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_ALPHA) &&
                    (CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_ALPHA64) &&
                    (CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_IA64))
                {
                    fAdjust = TRUE;
                } else {
                    fAdjust = FALSE;
                }

                if (fGoingDown) {
                    DesiredImageBase -= *NewImageSize;
                    if (fAdjust) {
                        AdjImageBaseSize( (PULONG)&DesiredImageBase, &CurrentImageSize, fGoingDown );
                    }
                }

                if ((DesiredImageBase) &&
                    (DesiredImageBase != *OldImageBase)
                   ) {

                    if (CurrentImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                        OldChecksum = ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum;
                    } else {
                        OldChecksum = ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.CheckSum;
                    }
                    if ( !RelocateImage( &CurrentImage, DesiredImageBase, &Diff, tstamp ) ) {
                        UpdateSymbolsError = GetLastError();
                        rc = FALSE;
                        goto CleanupAndExit;
                    }

                    if ( fSymbolsAlreadySplit && Diff ) {
                        if ( UpdateDebugInfoFileEx(CurrentImageName,
                                                   SymbolPath,
                                                   DebugFilePath,
                                                   (PIMAGE_NT_HEADERS32)(CurrentImage.FileHeader),
                                                   OldChecksum )) {
                            UpdateSymbolsError = GetLastError();
                        } else {
                            UpdateSymbolsError = 0;
                        }
                    }
                } else {
                    //
                    // Should this be -1??  shouldn't it be 0 instead? - kentf
                    //
                    Diff = (ULONG) -1;
                }

                if (!fGoingDown && Diff) {
                    DesiredImageBase += *NewImageSize;
                    if (fAdjust) {
                        AdjImageBaseSize( (PULONG)&DesiredImageBase, &CurrentImageSize, fGoingDown );
                    }
                }

            }
        }

        if (fReBase) {
            if (Diff) {
                *NewImageBase = DesiredImageBase;
            } else {
                UpdateSymbolsError = ERROR_INVALID_ADDRESS;
                rc = FALSE;
                goto CleanupAndExit;
            }
        }
    } else {
        if (CurrentImage.fDOSImage == TRUE) {
            UpdateSymbolsError = ERROR_BAD_EXE_FORMAT;
        } else {
            UpdateSymbolsError = GetLastError();
        }
        rc = FALSE;
        goto Exit;
    }

CleanupAndExit:
    UnmapViewOfFile( CurrentImage.MappedAddress );
    if ( CurrentImage.hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( CurrentImage.hFile );
    }
    ZeroMemory( &CurrentImage, sizeof( CurrentImage ) );

Exit:

    SetLastError(UpdateSymbolsError);

    return(TRUE);
}


VOID
AdjImageBaseSize (
    PULONG pulImageBase,
    PULONG pulImageSize,
    BOOL   fGoingDown
    )
{

    DWORD Meg1, Meg2, Delta;

    //
    // ImageBase is the base for the current image. Make sure that
    // the image does not span a 256Mb boundry. This is due to an r4000
    // chip bug that has problems computing the correct address for absolute
    // jumps that occur in the last few instructions of a 256mb region
    //

    Meg1 = *pulImageBase >> x256MEGSHIFT;
    Meg2 = ( *pulImageBase + ROUND_UP( *pulImageSize, IMAGE_SEPARATION ) ) >> x256MEGSHIFT;

    if ( Meg1 != Meg2 ) {

        //
        // If we are going down, then subtract the overlap from ThisBase
        //

        if ( fGoingDown ) {

            Delta = ( *pulImageBase + ROUND_UP( *pulImageSize, IMAGE_SEPARATION ) ) -
                    ( Meg2 << x256MEGSHIFT );
            Delta += IMAGE_SEPARATION;
            *pulImageBase = *pulImageBase - Delta;
            *pulImageSize += Delta;
            }
        else {
            Delta = ( Meg2 << x256MEGSHIFT ) - *pulImageBase;
            *pulImageBase += Delta;
            *pulImageSize += Delta;
            }
        }
}

BOOL
RelocateImage(
    PLOADED_IMAGE LoadedImage,
    ULONG64 NewBase,
    ULONG64 *Diff,
    ULONG tstamp
    )
{
    ULONG_PTR VA;
    ULONG64 OldBase;
    ULONG SizeOfBlock;
    PUSHORT NextOffset;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;
    ULONG CheckSum;
    ULONG HeaderSum;
    PIMAGE_FILE_HEADER FileHeader;
    BOOL rc = TRUE;
    ULONG TotalCountBytes = 0;

    static BOOL  fInit = FALSE;

    if (!fInit) {

        RelocRoutineNative = (LPRELOCATE_ROUTINE)GetProcAddress(GetModuleHandle("ntdll"), "LdrProcessRelocationBlock");

#ifdef _WIN64
        RelocRoutine64 = RelocRoutineNative;
#else
        RelocRoutine64 = xxLdrProcessRelocationBlock64;
#endif
    }

    __try {
        if (LoadedImage->FileHeader->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED) {
            // Relocations stripped.  Nothing to do.
            __leave;
        }

        NtHeaders = LoadedImage->FileHeader;
        FileHeader = &NtHeaders->FileHeader;
        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            OldBase = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase;
        } else {
            OldBase = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase;
        }

        //
        // Locate the relocation section.
        //

        NextBlock = (PIMAGE_BASE_RELOCATION)ImageDirectoryEntryToData(
                                                LoadedImage->MappedAddress,
                                                FALSE,
                                                IMAGE_DIRECTORY_ENTRY_BASERELOC,
                                                &TotalCountBytes
                                                );

        *Diff = NewBase - OldBase;

        //
        // If the image has a relocation table, then apply the specified fixup
        // information to the image.
        //

        while (TotalCountBytes) {
            SizeOfBlock = NextBlock->SizeOfBlock;
            TotalCountBytes -= SizeOfBlock;
            SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
            SizeOfBlock /= sizeof(USHORT);
            NextOffset = (PUSHORT)(NextBlock + 1);

            //
            // Compute the address and value for the fixup.
            //

            if ( SizeOfBlock ) {
                VA = (ULONG_PTR)RvaToVa(NextBlock->VirtualAddress,LoadedImage);
                if ( !VA ) {
                    NtHeaders->Signature = (ULONG)-1;
                    rc = FALSE;
                    __leave;
                    }

                if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                    if ( !(NextBlock = (RelocRoutine64)(VA,SizeOfBlock,NextOffset,*Diff)) ) {
                        NtHeaders->Signature = (ULONG)-1;
                        rc = FALSE;
                        __leave;
                    }
                } else {
                    if ( !(NextBlock = (RelocRoutineNative)(VA,SizeOfBlock,NextOffset,(LONG_PTR)*Diff)) ) {
                        NtHeaders->Signature = (ULONG)-1;
                        rc = FALSE;
                        __leave;
                        }
                    }
                }
            else {
                NextBlock++;
                }
            }

        if (tstamp) {
            FileHeader->TimeDateStamp = tstamp;
        } else {
            FileHeader->TimeDateStamp++;
        }

        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase = (ULONG)NewBase;
            if ( LoadedImage->hFile != INVALID_HANDLE_VALUE ) {

                ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum = 0;

                CheckSumMappedFile(
                            (PVOID)LoadedImage->MappedAddress,
                            GetFileSize(LoadedImage->hFile, NULL),
                            &HeaderSum,
                            &CheckSum
                            );
                ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
            }
        } else {
            ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase = NewBase;
            if ( LoadedImage->hFile != INVALID_HANDLE_VALUE ) {
                ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum = 0;

                CheckSumMappedFile(
                            (PVOID)LoadedImage->MappedAddress,
                            GetFileSize(LoadedImage->hFile, NULL),
                            &HeaderSum,
                            &CheckSum
                            );

                ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
            }
        }

        FlushViewOfFile(LoadedImage->MappedAddress,0);
        TouchFileTimes(LoadedImage->hFile,NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = FALSE;
    }

    return rc;
}


PVOID
RvaToVa(
    ULONG Rva,
    PLOADED_IMAGE Image
    )
{

    PIMAGE_SECTION_HEADER Section;
    ULONG i;
    PVOID Va;

    Va = NULL;
    Section = Image->LastRvaSection;
    if (Rva == 0) {
        // a NULL Rva will be sent if there are relocs before the first page
        //  (ie: we're relocating a system image)

        Va = Image->MappedAddress;

    } else {
        if ( Rva >= Section->VirtualAddress &&
             Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
            Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
        } else {
            for(Section = Image->Sections,i=0; i<Image->NumberOfSections; i++,Section++) {
                if ( Rva >= Section->VirtualAddress &&
                     Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
                    Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
                    Image->LastRvaSection = Section;
                    break;
                }
            }
        }
    }

    return Va;
}

#ifndef IMAGE_REL_BASED_SECTION
#define IMAGE_REL_BASED_SECTION               6
#endif
#ifndef IMAGE_REL_BASED_REL32
#define IMAGE_REL_BASED_REL32                 7
#endif

PIMAGE_BASE_RELOCATION
xxLdrProcessRelocationBlock64(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONGLONG Diff
    )
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;
    ULONG Temp32;
    ULONGLONG Value64;
    LONGLONG Temp64;

    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                *(LONG UNALIGNED *)FixupVA += (ULONG) Diff;
                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //

                Temp = *(PUSHORT)FixupVA << 16;
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                Temp = *(PSHORT)FixupVA;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)Temp;
                break;

            case IMAGE_REL_BASED_IA64_IMM64:

                //
                // Align it to bundle address before fixing up the
                // 64-bit immediate value of the movl instruction.
                //

                FixupVA = (PUCHAR)((ULONG_PTR)FixupVA & ~(15));
                Value64 = (ULONGLONG)0;

                //
                // Extract the lower 32 bits of IMM64 from bundle
                //


                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X,
                        EMARCH_ENC_I17_IMM7B_SIZE_X,
                        EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM7B_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X,
                        EMARCH_ENC_I17_IMM9D_SIZE_X,
                        EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM9D_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X,
                        EMARCH_ENC_I17_IMM5C_SIZE_X,
                        EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM5C_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X,
                        EMARCH_ENC_I17_IC_SIZE_X,
                        EMARCH_ENC_I17_IC_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IC_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X,
                        EMARCH_ENC_I17_IMM41a_SIZE_X,
                        EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41a_VAL_POS_X);

                //
                // Update 64-bit address
                //

                Value64+=Diff;
                Value64 = (__int64)(__int32)PtrToLong((PULONG)Value64);

                //
                // Insert IMM64 into bundle
                //

                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X),
                        EMARCH_ENC_I17_IMM7B_SIZE_X,
                        EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM7B_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X),
                        EMARCH_ENC_I17_IMM9D_SIZE_X,
                        EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM9D_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X),
                        EMARCH_ENC_I17_IMM5C_SIZE_X,
                        EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM5C_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X),
                        EMARCH_ENC_I17_IC_SIZE_X,
                        EMARCH_ENC_I17_IC_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IC_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41a_SIZE_X,
                        EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41a_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41b_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41b_SIZE_X,
                        EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41b_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41c_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41c_SIZE_X,
                        EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41c_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_SIGN_INST_WORD_X),
                        EMARCH_ENC_I17_SIGN_SIZE_X,
                        EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
                        EMARCH_ENC_I17_SIGN_VAL_POS_X);
                break;

            case IMAGE_REL_BASED_DIR64:

                *(ULONGLONG UNALIGNED *)FixupVA += Diff;

                break;

            case IMAGE_REL_BASED_MIPS_JMPADDR :
                //
                // JumpAddress - (32-bits) relocate a MIPS jump address.
                //
                Temp = (*(PULONG)FixupVA & 0x3ffffff) << 2;
                Temp += (ULONG) Diff;
                *(PULONG)FixupVA = (*(PULONG)FixupVA & ~0x3ffffff) |
                                                ((Temp >> 2) & 0x3ffffff);

                break;

            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}



// Dummy stub so the rebase.exe that shipped with VC5/VC6 will load.
VOID
RemoveRelocations(
    PCHAR ImageName
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\splitsymx.c ===
#define use_SplitSymbolsX 1

#include <splitsymi.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\smashlck.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    smashlck.c

Abstract:

    This function smashes lock prefixes replacing them with NOPs

Author:

    Mark Lucovsky (markl) 30-Apr-1993

Revision History:

--*/

#include <private.h>


BOOL fVerbose;
BOOL fUpdate;
BOOL fUsage;

UCHAR LockPrefixOpcode = 0xf0;
UCHAR NoOpOpcode = 0x90;

LPSTR CurrentImageName;
PIMAGE_OPTIONAL_HEADER32 OptionalHeader32;
PIMAGE_OPTIONAL_HEADER64 OptionalHeader64;
PIMAGE_FILE_HEADER FileHeader;
LOADED_IMAGE CurrentImage;
CHAR DebugFilePath[_MAX_PATH];
LPSTR SymbolPath;

PVOID
ImageVaToLoadVa(
    PVOID ImageVa,
    PLOADED_IMAGE Image
    )
{
    PIMAGE_SECTION_HEADER Section;
    ULONG i, Rva;
    PVOID Va;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    FileHeader = &((PIMAGE_NT_HEADERS32)Image->FileHeader)->FileHeader;

    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Image->FileHeader,
                                 &OptionalHeader32,
                                 &OptionalHeader64);
    if (!OptionalHeader32 && !OptionalHeader64)
        return NULL;

    Rva = (ULONG)((ULONG_PTR)((PUCHAR)ImageVa - (PUCHAR)OPTIONALHEADER(ImageBase)));
    Va = NULL;
    Section = Image->LastRvaSection;
    if ( Rva >= Section->VirtualAddress &&
         Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
        Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
    } else {
        for(Section = Image->Sections,i=0; i<Image->NumberOfSections; i++,Section++) {
            if ( Rva >= Section->VirtualAddress &&
                 Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
                Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
                Image->LastRvaSection = Section;
                break;
            }
        }
    }
    if ( !Va ) {
        fprintf(stderr,"SMASHLOCK: ImageVaToLoadVa %p in image %p failed\n",ImageVa,Image);
    }
    return Va;
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    DWORD dw;
    LPSTR FilePart;
    CHAR Buffer[MAX_PATH];
    PIMAGE_LOAD_CONFIG_DIRECTORY ConfigInfo;
    ULONG whocares;
    char c, *p;
    BOOLEAN LocksSmashed;
    ULONG CheckSum;
    ULONG HeaderSum;
    ULONG OldChecksum;
    int   retval = 0;

    fUsage = FALSE;
    fVerbose = FALSE;
    fUpdate = FALSE;

    _tzset();

    if (argc <= 1) {
        goto showUsage;
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (toupper( c )) {
                case '?':
                    fUsage = TRUE;
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'U':
                    fUpdate = TRUE;
                    break;

                case 'S':
                    argc--, argv++;
                    SymbolPath = *argv;
                    break;

                default:
                    fprintf( stderr, "SMASHLOCK: Invalid switch - /%c\n", c );
                    fUsage = TRUE;
                    break;
            }

            if ( fUsage ) {
showUsage:
                fputs("usage: SMASHLOCK [switches] image-names... \n"
                      "              [-?] display this message\n"
                      "              [-u] update image\n"
                      "              [-v] verbose output\n"
                      "              [-s] path to symbol files\n", stderr );
                exit(1);
            }
        } else {
            LocksSmashed = FALSE;

            CurrentImageName = p;
            dw = GetFullPathName(CurrentImageName,sizeof(Buffer),Buffer,&FilePart);
            if ( dw == 0 || dw > sizeof(Buffer) ) {
                FilePart = CurrentImageName;
            }

            //
            // Map and load the current image
            //

            if ( MapAndLoad(CurrentImageName, NULL, &CurrentImage, FALSE, !fUpdate )) {

                FileHeader = &((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->FileHeader;

                OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader,
                                             &OptionalHeader32,
                                             &OptionalHeader64);
                //
                // make sure the image has correct configuration information,
                // and that the LockPrefixTable is set up properly
                //

                ConfigInfo = (PIMAGE_LOAD_CONFIG_DIRECTORY)ImageDirectoryEntryToData(
                                                                CurrentImage.MappedAddress,
                                                                FALSE,
                                                                IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                                &whocares
                                                                );
                if ( ConfigInfo && ConfigInfo->LockPrefixTable ) {

                    //
                    // Walk through the lock prefix table
                    //

                    PUCHAR *LockPrefixs;
                    PUCHAR LockPrefix;

                    LockPrefixs =  (PUCHAR *)ImageVaToLoadVa((PVOID)ConfigInfo->LockPrefixTable,&CurrentImage);

                    while(LockPrefixs && *LockPrefixs) {
                        LockPrefix = (PUCHAR) ImageVaToLoadVa(*LockPrefixs,&CurrentImage);
                        if ( LockPrefix && *LockPrefix == LockPrefixOpcode ) {
                            if (fVerbose) {
                                printf("LockPrefix Found at 0x%p = %x\n",*LockPrefixs,*LockPrefix);
                            }
                            if (fUpdate) {
                                LocksSmashed = TRUE;
                                *LockPrefix = NoOpOpcode;
                            }
                        }
                        LockPrefixs++;
                    }
                }

                if ( fUpdate && LocksSmashed ) {

                    //
                    // recompute the checksum.
                    //

                    OldChecksum = OPTIONALHEADER(CheckSum);
                    if ( CurrentImage.hFile != INVALID_HANDLE_VALUE ) {

                        OPTIONALHEADER_ASSIGN(CheckSum, 0);

                        CheckSumMappedFile(
                                    (PVOID)CurrentImage.MappedAddress,
                                    GetFileSize(CurrentImage.hFile, NULL),
                                    &HeaderSum,
                                    &CheckSum
                                    );

                        OPTIONALHEADER_ASSIGN(CheckSum, CheckSum);
                    }

                    FlushViewOfFile(CurrentImage.MappedAddress,0);
                    TouchFileTimes(CurrentImage.hFile,NULL);

                    // And update the .dbg file (if requested)
                    if (SymbolPath &&
                        FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
                        if ( UpdateDebugInfoFileEx( CurrentImageName,
                                                    SymbolPath,
                                                    DebugFilePath,
                                                    (PIMAGE_NT_HEADERS32) CurrentImage.FileHeader,
                                                    OldChecksum) ) {
                            if (GetLastError() == ERROR_INVALID_DATA) {
                                printf( "Warning: Old checksum did not match for %s\n", DebugFilePath);
                                }
                            printf("Updated symbols for %s\n", DebugFilePath);
                        } else {
                            printf("Unable to update symbols: %s\n", DebugFilePath);
                            retval=1;
                        }
                    }
                }

                UnmapViewOfFile(CurrentImage.MappedAddress);
                if ( CurrentImage.hFile != INVALID_HANDLE_VALUE ) {
                    CloseHandle(CurrentImage.hFile);
                }
                ZeroMemory(&CurrentImage,sizeof(CurrentImage));
            } else {
                if (!CurrentImage.fSystemImage && !CurrentImage.fDOSImage) {
                    fprintf(stderr,"SMASHLOCK: failure mapping and loading %s\n",CurrentImageName);
                    retval=1;
                }
            }
        }
    }

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\stripcv.cxx ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>
#include <cvinfo.h>
#include <private.h>

extern "C"
BOOL
IMAGEAPI
CopyPdb(
    CHAR const * szSrcPdb,
    CHAR const * szDestPdb,
    BOOL StripPrivate
    );

BOOL
StripCv(
    PSZ szImage
    );

void __cdecl main(int argc, char *argv[]);
void Usage(void);

void
Usage (void)
{
    puts("USAGE: StripCV <imagename>\n"
         "\tRemove non-public CV info from an image.\n");
}

void __cdecl
main(
    int argc,
    char *argv[])
{
    int i;

    if (argc < 2) {
        Usage();
        exit(1);
    }

    for (i = 1; i < argc; i++) {
        StripCv(argv[i]);
    }
}

BOOL
StripCv(
    PSZ szImage
    )
{
    PCHAR               CvDebugData;
    unsigned int        i, NumberOfDebugDirectories;
    ULONG               DebugDirectorySize, NewCvSize = 0, CvDebugSize;
    PCHAR               NewCvData;
    HANDLE              FileHandle, hMappedFile;
    PVOID               DebugDirectories, ImageBase;
    PIMAGE_NT_HEADERS   NtHeaders;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    BOOL                fRemoveCV = FALSE;
    BOOL                fDbgFile = FALSE;
    ULONG              *pDebugSize, FileSize;
    BOOL                RC = TRUE;

    FileHandle = CreateFile(
                     szImage,
                     GENERIC_READ | GENERIC_WRITE,
                     FILE_SHARE_READ,
                     NULL,
                     OPEN_EXISTING,
                     0,
                     NULL );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        printf("Error: Unable to open %s - rc: %d\n", szImage, GetLastError());
        RC = FALSE;
        goto cleanup1;
    }

    FileSize = GetFileSize(FileHandle, NULL);

    hMappedFile = CreateFileMapping( FileHandle, NULL, PAGE_READWRITE, 0, 0, NULL );
    if (!hMappedFile) {
        printf("Error: Unable to create read/write map on %s - rc: %d\n", szImage, GetLastError());
        RC = FALSE;
        goto cleanup2;
    }

    ImageBase = MapViewOfFile( hMappedFile, FILE_MAP_WRITE, 0, 0, 0 );
    if (!ImageBase) {
        printf("Error: Unable to Map view of file %s - rc: %d\n", szImage, GetLastError());
        RC = FALSE;
        goto cleanup3;
    }

    if (*(USHORT *)ImageBase == IMAGE_SEPARATE_DEBUG_SIGNATURE) {

        fDbgFile = TRUE;

        PIMAGE_SEPARATE_DEBUG_HEADER DbgFile = (PIMAGE_SEPARATE_DEBUG_HEADER) ImageBase;

        DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)((PUCHAR)ImageBase +
                                    sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
                                    (DbgFile->NumberOfSections * sizeof(IMAGE_SECTION_HEADER)) +
                                    DbgFile->ExportedNamesSize );
        pDebugSize = &(DbgFile->DebugDirectorySize);

        DebugDirectorySize = DbgFile->DebugDirectorySize;

    } else {

        NtHeaders = ImageNtHeader( ImageBase );
        if (NtHeaders == NULL) {
            printf("Error: %s is not an NT image\n", szImage);
            RC = FALSE;
            goto cleanup4;
        }

        DebugDirectories =
            ImageDirectoryEntryToData(
                ImageBase,
                FALSE,
                IMAGE_DIRECTORY_ENTRY_DEBUG,
                &DebugDirectorySize );
        pDebugSize = &(NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    }

    if (DebugDirectories == NULL || DebugDirectorySize == 0)
    {
        printf("Warning: No debug info found on %s\n", szImage);
        RC = FALSE;
        goto cleanup4;
    }

    DebugDirectory = (PIMAGE_DEBUG_DIRECTORY) DebugDirectories;

    NumberOfDebugDirectories = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

    CvDebugData = NULL;

    for (i=0; i < NumberOfDebugDirectories; i++) {
        if (DebugDirectory->Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
            CvDebugData = (PCHAR)ImageBase + DebugDirectory->PointerToRawData;
            CvDebugSize = DebugDirectory->SizeOfData;
            break;
        }

        // Zero out the Fixup data

        if (DebugDirectory->Type == IMAGE_DEBUG_TYPE_FIXUP) {
            printf("Info: Removing Fixup data from %s\n", szImage);
            RtlZeroMemory(((PUCHAR)ImageBase + DebugDirectory->PointerToRawData),
                          DebugDirectory->SizeOfData);
            DebugDirectory = DebugDirectory+1;
            *pDebugSize -= sizeof(IMAGE_DEBUG_DIRECTORY);
        } else {
            DebugDirectory++;
        }
    }

    if (CvDebugData == NULL) {
        printf("Info: No CV Debug found on %s\n", szImage);
        RC = FALSE;
        goto cleanup5;
    }

    if (RemovePrivateCvSymbolicEx(CvDebugData, CvDebugSize, &NewCvData, &NewCvSize)) {
        // No CV debug in new size.  Let's check for PDB's.  If so, copy the pdb to
        // <filename>pub

        typedef struct NB10I {                 // NB10 debug info
            DWORD   nb10;                      // NB10
            DWORD   off;                       // offset, always 0
            DWORD   sig;
            DWORD   age;
        } NB10I;

        NB10I *NB10Data = (NB10I *)CvDebugData;
        PCHAR  szPrivatePdb;
        CHAR  szPublicPdb[_MAX_PATH];

        if (NB10Data->nb10 == '01BN') {
            // It has a NB10 signature.  Get the name.
            szPrivatePdb = CvDebugData + sizeof(NB10I);
            strcpy(szPublicPdb, szPrivatePdb);
            strcat(szPublicPdb, "pub");
            CopyPdb(szPrivatePdb, szPublicPdb, TRUE);
        } else {
            printf("Info: CV types info stripped from %s\n", szImage);
        }
    }

    RtlCopyMemory(CvDebugData, NewCvData, NewCvSize);

    DebugDirectory = (PIMAGE_DEBUG_DIRECTORY) DebugDirectories;

    for (i=0; i < NumberOfDebugDirectories; i++) {
        if (DebugDirectory->Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
            if (i+1 == NumberOfDebugDirectories) {
                // This is the simple case.  cv is the last entry.  Simply truncate the image.
                FileSize += NewCvSize - DebugDirectory->SizeOfData;
            }
            DebugDirectory->SizeOfData = NewCvSize;
            break;
        }

        DebugDirectory++;
    }

cleanup5:

    // All done.

    if (!fDbgFile) {
        PIMAGE_NT_HEADERS pHdr = NULL;
        DWORD SumHeader;
        DWORD SumTotal;

        pHdr = CheckSumMappedFile(ImageBase, FileSize, &SumHeader, &SumTotal);
        if (pHdr != NULL) {
            pHdr->OptionalHeader.CheckSum = SumTotal;
        }
    }

    FlushViewOfFile(ImageBase, NULL);
cleanup4:
    UnmapViewOfFile(ImageBase);
cleanup3:
    CloseHandle(hMappedFile);
cleanup2:
    SetFilePointer(FileHandle, FileSize, NULL, FILE_BEGIN);
    SetEndOfFile(FileHandle);
    CloseHandle(FileHandle);
cleanup1:
    return(RC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\splitsym.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    splitsym.c

Abstract:

    This is the main source file for the SPLITSYM utility program.  This
    program can be used to split the debugging information contained in
    an executable image file into a separate .DBG file and strip it from
    the image file.  Allow stripped image files to be distributed which
    significantly reduces disk space requirements, but allows full
    debugging by accesing the associated .DBG files over the network
    when needed.

Author:

    Steve Wood (stevewo) 03-May-1993

Revision History:

--*/

#include <private.h>
#include <splitsymx.h>


BOOL fVerbose;
BOOL fRecurse;
ULONG SplitFlags = 0;

UCHAR RecurseDirectory[ MAX_PATH ];

UCHAR CurrentImageName[ MAX_PATH ];

UCHAR SymbolPath[ MAX_PATH ];
UCHAR RSDSDllPath[ MAX_PATH ];

UCHAR DbgFileName[ MAX_PATH ];

VOID
SplitSymbolsInTree(
    LPSTR RootPath
    );

void
Usage( void )
{
    fputs ( "usage: SPLITSYM [-?] [-v] [-p] [-a] [-s symbol directory] [-r directory] image-names...\n"
            "              [-?] display this message\n"
            "              [-v] verbose output\n"
            "              [-p] remove private debug info when creating .dbg file\n"
            "              [-a] extract all debug info into .dbg file\n"
            "              [-m] RSDS dll to load, default is mspdb70.dll\n"
            "              [-r directory] - recursively process all image files.\n"
            "              [-s symbol directory] - where to put .DBG files.\n"
            "                                      Default is same place as image file.\n",
            stderr );
    exit( 1 );
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *s;
    LPSTR FilePart;

    if (argc <= 1) {
        Usage();
        }

    strcpy(RSDSDllPath, "mspdb70.dll");

    SymbolPath[ 0 ] = '\0';
    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            while (c = *++s)
                switch (toupper( c )) {
                case '?':
                    Usage();
                    break;

                case 'M':
                    if (--argc) {
                        strcpy( (PCHAR) RSDSDllPath, *++argv );
                        }
                    else {
                        fprintf( stderr, "SPLITSYM: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'R':
                    if (--argc) {
                        fRecurse = TRUE;
                        strcpy( (PCHAR) RecurseDirectory, *++argv );
                        }
                    else {
                        fprintf( stderr, "SPLITSYM: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                case 'S':
                    if (--argc) {
                        strcpy( (PCHAR) SymbolPath, *++argv );
                        }
                    else {
                        fprintf( stderr, "SPLITSYM: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                case 'P':
                    SplitFlags |= SPLITSYM_REMOVE_PRIVATE;
                    break;

                case 'A':
                    SplitFlags |= SPLITSYM_EXTRACT_ALL;
                    break;

                default:
                    fprintf( stderr, "SPLITSYM: Invalid switch - /%c\n", c );
                    Usage();
                    break;
                }
            }
        else {
            if (fRecurse) {
                fprintf( stderr, "SPLITSYM: May not specify specific file names with /R switch.\n" );
                Usage();
                }
            else
            if (!GetFullPathNameA( s, sizeof( CurrentImageName ), (PCHAR) CurrentImageName, &FilePart )) {
                fprintf( stderr, "SPLITSYM: invalid file name - %s (%u)\n", s, GetLastError() );
                }
            else {
                if (SplitSymbolsX( (PCHAR) CurrentImageName, (PCHAR) SymbolPath, (PCHAR) DbgFileName, 
                                   SplitFlags, RSDSDllPath, NULL, 0L )) {
                    if (fVerbose) {
                        fprintf( stdout,
                                 "SPLITSYM: %16s symbols split into %s\n",
                                 FilePart,
                                 DbgFileName
                               );
                        }
                    }
                else
                if (GetLastError() != ERROR_BAD_EXE_FORMAT &&
                    GetLastError() != ERROR_ALREADY_ASSIGNED
                   ) {
                    fprintf( stderr, "SPLITSYM: Unable to split symbols from '%s' into '%s' (%u)\n",
                             CurrentImageName,
                             DbgFileName,
                             GetLastError()
                           );
                    }
                }
            }
        }

    if (fRecurse) {
        SplitSymbolsInTree( (PCHAR) RecurseDirectory );
        }

    exit( 0 );
    return 0;
}


#define MAX_DEPTH 32

VOID
SplitSymbolsInTree(
    LPSTR RootPath
    )
{
    LPSTR FilePart;
    PUCHAR Prefix = (PUCHAR) "";
    CHAR PathBuffer[ MAX_PATH ];
    ULONG Depth;
    PCHAR PathTail[ MAX_DEPTH ];
    PCHAR FindHandle[ MAX_DEPTH ];
    LPWIN32_FIND_DATA FindFileData;
    UCHAR FindFileBuffer[ MAX_PATH + sizeof( WIN32_FIND_DATA ) ];

    strcpy( PathBuffer, RootPath );
    FindFileData = (LPWIN32_FIND_DATA)FindFileBuffer;
    Depth = 0;
    while (TRUE) {
startDirectorySearch:
        PathTail[ Depth ] = strchr( PathBuffer, '\0' );
        if (PathTail[ Depth ] > PathBuffer && PathTail[ Depth ][ -1 ] != '\\') {
            *(PathTail[ Depth ])++ = '\\';
            }

        strcpy( PathTail[ Depth ], "*.*" );
        FindHandle[ Depth ] = (PCHAR) FindFirstFile( PathBuffer, FindFileData );
        if (FindHandle[ Depth ] != INVALID_HANDLE_VALUE) {
            do {
                if (FindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    if (strcmp( FindFileData->cFileName, "." ) &&
                        strcmp( FindFileData->cFileName, ".." ) &&
                        Depth < MAX_DEPTH
                       ) {
                        sprintf( PathTail[ Depth ], "%s\\", FindFileData->cFileName );
                        Depth++;
                        goto startDirectorySearch;
                        }
                    }
                else
                if (!(FindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY)) {
                    strcpy( PathTail[ Depth ], FindFileData->cFileName );
                    if (!GetFullPathNameA( PathBuffer, sizeof( CurrentImageName ), (PCHAR) CurrentImageName, &FilePart )) {
                        fprintf( stderr, "SPLITSYM: invalid file name - %s (%u)\n", PathBuffer, GetLastError() );
                        }
                    else {
                        if (SplitSymbolsX( (PCHAR) CurrentImageName, (PCHAR) SymbolPath, (PCHAR) DbgFileName, 
                                           SplitFlags, RSDSDllPath, NULL, 0L )) {
                            if (fVerbose) {
                                fprintf( stdout,
                                         "SPLITSYM: %16s symbols split into %s\n",
                                         FilePart,
                                         DbgFileName
                                       );
                                }
                            }
                        else
                        if (GetLastError() != ERROR_BAD_EXE_FORMAT ) {
                            fprintf( stderr, "SPLITSYM: Unable to split symbols from '%s' into '%s' (%u)\n",
                                     CurrentImageName,
                                     DbgFileName,
                                     GetLastError()
                                   );
                            }
                        }
                    }

restartDirectorySearch:
                ;
                }
            while (FindNextFile( FindHandle[ Depth ], FindFileData ));
            FindClose( FindHandle[ Depth ] );

            if (Depth == 0) {
                break;
                }

            Depth--;
            goto restartDirectorySearch;
            }
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\symutilx.c ===
#define use_SymutilX 1

#include <symutil.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\symutil.c ===
#include <assert.h>
#include "symutil.h"
#include "private.h"
#include "dbgimage.h"
#include "cvinfo.h"
#include "exe_vxd.h"
#include "share.h"
#include "winbase.h"

// Stuff for Checking symbols

#define DBGSYM 2
#define PDBSYM 3
#define lengthof(a) (sizeof(a) / sizeof(a[0]))

BOOL CheckPrivate=FALSE;
BOOL CheckCodeView=TRUE;
PEXCLUDE_LIST pErrorFilterList=NULL;
P_LIST pCDIncludeList=NULL;
BOOL Recurse = FALSE;
BOOL LogCheckSumErrors = TRUE;

// private version of qsort used to avoid compat problems on NT4 and win2k.
// code is published from base\crts
extern
void __cdecl dbg_qsort(void *, size_t, size_t,
                       int (__cdecl *) (const void *, const void *));

#if defined(use_SymutilX)

static BOOL RSDSLibLoaded=FALSE;

// Typedefs
typedef BOOL ( __cdecl *PPDBOPENVALIDATE4 ) (
    const wchar_t *wszPDB,
    const char *szMode,
    PCSIG70 pcsig70,
    SIG sig,
    AGE age,
    OUT EC *pec,
    OUT wchar_t *wszError,
    size_t cchErrMax,
    OUT PDB **pppdb
    );

typedef BOOL ( __cdecl *PPDBCLOSE ) (
    PDB* ppdb
    );

typedef BOOL ( __cdecl *PDBIQUERYNEXTMOD ) (
    DBI* pdbi, Mod* pmod, Mod** ppmodNext
    );

typedef BOOL ( __cdecl *PMODCLOSE ) (
    Mod* pmod
    );

typedef BOOL ( __cdecl *PMODQUERYLINES ) (
    Mod* pmod, BYTE* pbLines, long* pcb
    );

typedef BOOL ( __cdecl *PMODQUERYSYMBOLS ) (
    Mod* pmod, BYTE* pbSym, long* pcb
    );

typedef BOOL ( __cdecl *PDBIQUERYTYPESERVER ) (
    DBI* pdbi, ITSM itsm, OUT TPI** pptpi
    );

typedef BOOL ( __cdecl *PPDBOPENTPI ) (
    PDB* ppdb, const char* szMode, OUT TPI** pptpi
    );

typedef BOOL ( __cdecl *PTYPESQUERYTIMINEX ) (
    TPI* ptpi
    );

typedef BOOL ( __cdecl *PTYPESQUERYTIMACEX ) (
    TPI* ptpi
    );

typedef BOOL ( __cdecl *PTYPESCLOSE ) (
    TPI* ptpi
    );

typedef BOOL ( __cdecl *PPDBOPENDBI ) (
    PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi
    );

typedef BOOL ( __cdecl *PDBICLOSE ) (
    DBI* pdbi
    );

static PPDBOPENVALIDATE4 pPDBOpenValidate4 = NULL;
static PPDBCLOSE pPDBClose = NULL;
static PDBIQUERYNEXTMOD pDBIQueryNextMod = NULL;
static PMODCLOSE pModClose = NULL;
static PMODQUERYLINES pModQueryLines = NULL;
static PMODQUERYSYMBOLS pModQuerySymbols = NULL;
static PDBIQUERYTYPESERVER pDBIQueryTypeServer = NULL;
static PPDBOPENTPI pPDBOpenTpi = NULL;
static PTYPESQUERYTIMINEX pTypesQueryTiMinEx = NULL;
static PTYPESQUERYTIMACEX pTypesQueryTiMacEx = NULL;
static PTYPESCLOSE pTypesClose = NULL;
static PPDBOPENDBI pPDBOpenDBI = NULL;
static PDBICLOSE pDBIClose = NULL;

#endif

BOOL
ansi2wcs(
    PSTR  psz,
    PWSTR pwsz,
    DWORD pwszlen
);

typedef struct _FILE_INFO {
    DWORD       TimeDateStamp;
    DWORD       SizeOfImage;
    DWORD       CheckSum;
    TCHAR       szName[MAX_PATH];
} FILE_INFO, *PFILE_INFO;


PIMAGE_DOS_HEADER
MapFileHeader (
              LPTSTR szFileName,
              PHANDLE phFile,
              PSYM_ERR pSymErr
              );

PIMAGE_NT_HEADERS
GetNtHeader (
            PIMAGE_DOS_HEADER pDosHeader,
            HANDLE hDosFile,
            LPTSTR szFileName,
            PSYM_ERR pSymErr,
            LPBY_HANDLE_FILE_INFORMATION lpFileInfo  
            );

BOOL
ResourceOnlyDll(
               PVOID pImageBase,
               BOOLEAN bMappedAsImage
               );

PIMAGE_SEPARATE_DEBUG_HEADER
MapDbgHeader (
             LPTSTR szFileName,
             PHANDLE phFile,
             PSYM_ERR pSymErr
             );

BOOL
UnmapFile(
         LPCVOID phFileMap,
         HANDLE hFile
         );

IMAGE_DEBUG_DIRECTORY UNALIGNED *
GetDebugDirectoryInExe(
                      PIMAGE_DOS_HEADER pDosHeader,
                      ULONG *NumberOfDebugDirectories
                      );

IMAGE_DEBUG_DIRECTORY UNALIGNED *
GetDebugDirectoryInDbg(
                      PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader,
                      ULONG *NumberOfDebugDirectories
                      );

PIMAGE_SEPARATE_DEBUG_HEADER
MapMatchingDbgFile(
                  LPTSTR szSearchPath,
                  PFILE_INFO pFileInfo,
                  LPTSTR szFoundPath
                  );

BOOL
VerifyCV(
        LPTSTR szFileName,
        PCHAR pImageBase,
        IMAGE_DEBUG_DIRECTORY UNALIGNED *pDbgDir,
        LPTSTR szExtPath,
        LPTSTR szSearchPath,
        PSYM_ERR pSymErr,
        LPTSTR szRSDSDllToLoad
        );

LPSTR
GetMiscFile(
           PCHAR pImageBase,
           IMAGE_DEBUG_DIRECTORY UNALIGNED *pDbgDir
           );

BOOL
SearchForSymbolFile (
                    LPTSTR szSearchPath,
                    LPTSTR szSymName,
                    LPTSTR szPathExt,
                    PSYM_ERR pSymErr,
                    DWORD SymType,
                    PVOID  pelem1,
                    LPTSTR  szResult,
                    DWORD  dwResultLength,
                    LPTSTR szRSDSDllToLoad
                    );

USHORT
__cdecl
CompDbg(
       PVOID pelem1,
       LPTSTR szSymName,
       PSYM_ERR pSymErr
       );

USHORT
__cdecl
CompPdb(
       PVOID pelem1,
       LPTSTR szSymName,
       PSYM_ERR pSymErr,
       LPTSTR szRSDSDllToLoad
       );

BOOL
AddToSymbolsCDLog(
                 FILE *hSymCDLog,
                 PSYM_ERR pSymErr,
                 LPTSTR szSymbolPath,
                 LPTSTR szFileExt
                 );

BOOL PDBPrivateStripped(
                       PDB *ppdb,
                       DBI *pdbi
                       );

#if defined(use_SymutilX)
BOOL PDBPrivateStrippedX(
                       PDB *ppdb,
                       DBI *pdbi
                       );
#endif

BOOL
RemoveDuplicateSlashes(
   LPTSTR Str
); 

int __cdecl
SymComp(
       const void *e1,
       const void *e2
       );

PEXCLUDE_LIST
GetExcludeList(
              LPTSTR szFileName
              )

{
    PEXCLUDE_LIST pExcList;

    FILE  *fFile;
    TCHAR szCurFile[_MAX_FNAME+1], *c;
    TCHAR fname[_MAX_FNAME+1], ext[_MAX_EXT+1];
    DWORD i;
    LPTSTR szEndName;

    if (  (fFile = _tfopen(szFileName,_T("r") )) == NULL ) {
        // printf( "Cannot open the exclude file %s\n",szFileName );
        return FALSE;
    }

    pExcList = (PEXCLUDE_LIST)malloc(sizeof(EXCLUDE_LIST));

    if (pExcList)
    {
        pExcList->dNumFiles = 0;

        while ( _fgetts(szCurFile,_MAX_FNAME,fFile) ) {
            if ( szCurFile[0] == ';' ) continue;
            (pExcList->dNumFiles)++;
        }

        // Go back to the beginning of the file
        fseek(fFile,0,0);
        pExcList->szExcList = (LPTSTR*)malloc( sizeof(LPTSTR) *
                                               (pExcList->dNumFiles));
        if (pExcList->szExcList == NULL)
        {
            free(pExcList);
            pExcList = NULL;
        }
        else
        {
            i = 0;
            while ( i < pExcList->dNumFiles )
            {
                pExcList->szExcList[i] = NULL;

                memset(szCurFile,'\0',sizeof(TCHAR) * (_MAX_FNAME+1) );
                _fgetts(szCurFile,_MAX_FNAME,fFile);

                // Replace the \n with \0
                c = NULL;
                c  = _tcschr(szCurFile, '\n');
                if ( c != NULL)
                {
                    *c='\0';
                }

                if ( szCurFile[0] == ';' )
                {
                    continue;
                }

                if ( _tcslen(szCurFile) > _MAX_FNAME )
                {
                    printf("File %s has a string that is too large\n",szFileName);
                    continue;
                }

                // Allow for spaces and a ; after the file name
                // Move the '\0' back until it has erased the ';' and any
                // tabs and spaces that might come before it

                // Set the pointer to the ; if there is a comment
                szEndName = _tcschr(szCurFile, ';');

                // Set the pointer to the last character in the string if 
                // there wasn't a comment
                if (szEndName == NULL ) {
                    if (_tcslen(szCurFile) > 0 ) {
                        szEndName = szCurFile + _tcslen(szCurFile) - 1;
                    }
                }

                if (szEndName != NULL ) {
                    while ( *szEndName == ';' || *szEndName == ' '
                            || *szEndName == '\t' ) {
                        *szEndName = '\0';
                        if ( szEndName > szCurFile ) szEndName--;
                    }
                }

                pExcList->szExcList[i]=(LPTSTR)
                                       malloc( sizeof(TCHAR) * (_tcslen(szCurFile)+1) );

                if (pExcList->szExcList[i] == NULL )
                {
                    printf("Malloc failed for %s\n",szCurFile);
                }
                else
                {
                    _tsplitpath(szCurFile,NULL,NULL,fname,ext);

                    _tcscpy(pExcList->szExcList[i],fname);
                    _tcscat(pExcList->szExcList[i],ext);
                }

                i++;
            }

            // Sort the List
            dbg_qsort( (void*)pExcList->szExcList, (size_t)pExcList->dNumFiles,
                   (size_t)sizeof(LPTSTR), SymComp );
        }
    }

    fclose(fFile);

    return (pExcList);

}

BOOL
InExcludeList(
             LPTSTR szFileName,
             PEXCLUDE_LIST pExcludeList
             )

{
    DWORD i;
    int High;
    int Low;
    int Middle;
    int Result;

    // Lookup the name using a binary search
    if ( pExcludeList == NULL ) return FALSE;
    if ( pExcludeList->dNumFiles == 0 ) return FALSE;

    Low = 0;
    High = pExcludeList->dNumFiles - 1;
    while ( High >= Low ) {

        Middle = (Low + High) >> 1;
        Result = _tcsicmp( szFileName, pExcludeList->szExcList[Middle] );

        if ( Result < 0 ) {
            High = Middle - 1;

        } else if ( Result > 0 ) {
            Low = Middle + 1;

        } else {
            break;
        }
    }

    if ( High < Low ) return FALSE;

    return TRUE;
}


BOOL
InList(
      LPTSTR szFileName,
      P_LIST pExcludeList
      )

{
    DWORD i;
    int High;
    int Low;
    int Middle;
    int Result;

    // Lookup the name using a binary search
    if ( pExcludeList == NULL ) return FALSE;
    if ( pExcludeList->dNumFiles == 0 ) return FALSE;

    Low = 0;
    High = pExcludeList->dNumFiles - 1;
    while ( High >= Low ) {

        Middle = (Low + High) >> 1;
        Result = _tcsicmp( szFileName, pExcludeList->List[Middle].Path );

        if ( Result < 0 ) {
            High = Middle - 1;

        } else if ( Result > 0 ) {
            Low = Middle + 1;

        } else {
            break;
        }
    }

    if ( High < Low ) return FALSE;

    return TRUE;
}


int __cdecl
SymComp(
       const void *e1,
       const void *e2
       )
{
    LPTSTR* p1;
    LPTSTR* p2;

    p1 = (LPTSTR*)e1;
    p2 = (LPTSTR*)e2;

    return ( _tcsicmp(*p1,*p2) );
}


BOOL
CheckSymbols (
             LPTSTR ErrMsg,
             LPTSTR szSearchPath,
             LPTSTR szFileName,
             FILE   *hSymCDLog,
             ULONG SymchkFlag,
             BOOL Verbose,
             LPTSTR szRSDSDllToLoad
             )
/*++

Routine Description:

    This function accepts a file name and a symbol search path
    (delimited by ;) and determines if its symbols match.

Arguments:
    szSearchPath    Search path delimited by ;

    szFileName      Full path and name of the file to verify symbols for

    szCopyDest      If this is not a NULL value, then generate actually copy the
                    symbols to this destination

    SymchkFlag      Specifies action to take according to whether symbols are
                    split or not split.

                    Possible values:
                        ERROR_IF_SPLIT      Print an error if the image is split already
                        ERROR_IF_NOT_SPLIT  Error if image is not split
                        IGNORE_IF_SPLIT     Don't check symbols for split images

    Verbose         If true, print an output line for every file
                    If false, print output only for files that fail

Return Value:
    TRUE    if symbols are correct, or symbol checking was ignored
    FALSE   if symbols are not correct

--*/

{

    PIMAGE_NT_HEADERS pNtHeader = NULL;
    PIMAGE_DOS_HEADER pDosHeader = NULL;
    PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader= NULL;

    IMAGE_DEBUG_DIRECTORY UNALIGNED *DebugDirectory;
    IMAGE_DEBUG_DIRECTORY UNALIGNED *pDbgDir=NULL;
    PIMAGE_DEBUG_MISC pDebugMisc;

    PTCHAR pImageBase;

    ULONG NumberOfDebugDirectories;
    FILE_INFO FileInfo;
    LPSTR szMiscFileName;
    UINT i;
    PNB10I pDebugCV;


    TCHAR path_buffer[_MAX_PATH];
    TCHAR drive[_MAX_DRIVE];
    TCHAR dir[_MAX_DIR];
    TCHAR fname[_MAX_FNAME];
    TCHAR ext[_MAX_EXT];
    TCHAR szDbgFileName[_MAX_PATH*sizeof(TCHAR)];
    DWORD dwDbgFileNameLength = _MAX_PATH;

    HANDLE DbgFile = 0;
    HANDLE DosFile = 0;

    BOOL SymbolsOK = TRUE;
    BOOL CVFound = FALSE;
    BOOL MiscFound = FALSE;
    BOOL RawDataFound = FALSE;
    BOOL rc= FALSE;
    BY_HANDLE_FILE_INFORMATION HandleFileInfo;  

    SYM_ERR SymErr;

    // Get the file name and the extension
    _tsplitpath( szFileName,drive,dir,fname,ext);


    // Initialize SymErr
    memset( &SymErr,0,sizeof(SYM_ERR) );
    SymErr.Verbose = Verbose;
    _tcscpy( SymErr.szFileName, szFileName );
    _tcscpy( SymErr.szSymbolSearchPath, szSearchPath );
    _tcscpy( SymErr.szSymbolFileName, _T("") );
    _tcscpy( SymErr.szPdbErr, _T("") );
    _tcscpy( SymErr.szPdbFileName, _T("") );

    pDosHeader = MapFileHeader( szFileName, &DosFile, &SymErr );
    if ( SymErr.ErrNo > 0 ) {
        LogError( ErrMsg, &SymErr, 0);
        return TRUE;
    }

    pNtHeader = GetNtHeader( pDosHeader, DosFile, szFileName, &SymErr, &HandleFileInfo );
    if ( SymErr.ErrNo > 0 ) {
        UnmapFile((LPCVOID)pDosHeader,DosFile);
        LogError( ErrMsg, &SymErr,0 );
        return TRUE;
    }

    __try {
        // Resource Dll's shouldn't have symbols
        if ( ResourceOnlyDll((PVOID)pDosHeader, FALSE) ) {
            LogError( ErrMsg, &SymErr,RESOURCE_ONLY_DLL);
            SymbolsOK = TRUE;
            __leave;
        }

        // Get info out of file header for comparison later
        if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            FileInfo.CheckSum = ((PIMAGE_NT_HEADERS32)pNtHeader)->OptionalHeader.CheckSum;
            FileInfo.SizeOfImage = ((PIMAGE_NT_HEADERS32)pNtHeader)->OptionalHeader.SizeOfImage;
        } else {
            if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                FileInfo.CheckSum = ((PIMAGE_NT_HEADERS64)pNtHeader)->OptionalHeader.CheckSum;
                FileInfo.SizeOfImage = ((PIMAGE_NT_HEADERS64)pNtHeader)->OptionalHeader.SizeOfImage;
            } else {
                FileInfo.CheckSum = -1;
            }
        }
        FileInfo.TimeDateStamp = pNtHeader->FileHeader.TimeDateStamp;
        _tcscpy(FileInfo.szName,szFileName);


        // Locate the Debug Directory in this file
        DebugDirectory = NULL;
        DebugDirectory = GetDebugDirectoryInExe(
                                               pDosHeader,
                                               &NumberOfDebugDirectories
                                               );
        if (!DebugDirectory) {
            LogError( ErrMsg, &SymErr,NO_DEBUG_DIRECTORIES);
            SymbolsOK = FALSE;
            __leave;
        }
        pImageBase = (PCHAR) pDosHeader;

        // Do some checks on the Debug Directories

        // Debug Information is stripped, we need the misc directory to find
        // out the DBG file name
        if ( (pNtHeader->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED) ) {
            if (SymchkFlag & ERROR_IF_SPLIT) {
                // Image is split, log error and continue;
                LogError( ErrMsg, &SymErr,ERROR_IF_SPLIT);
                SymbolsOK = FALSE;
                __leave;
            } else if (SymchkFlag & IGNORE_IF_SPLIT ) {
                // Image is split, don't check the symbols
                LogError( ErrMsg, &SymErr,IGNORE_IF_SPLIT);
                SymbolsOK = TRUE;
                __leave;
            }

            // Get the MISC entry
            i=0;
            while ( (i<NumberOfDebugDirectories) &&
                    ((DebugDirectory+i)->Type != IMAGE_DEBUG_TYPE_MISC) ) i++;

            if (i >= NumberOfDebugDirectories) {
                LogError( ErrMsg, &SymErr,NO_MISC_ENTRY);
                SymbolsOK = FALSE;
                __leave;
            }

            szMiscFileName = NULL;
            szMiscFileName = GetMiscFile(pImageBase,DebugDirectory + i);
            if (!szMiscFileName) {
                LogError( ErrMsg, &SymErr,NO_FILE_IN_MISC);
                SymbolsOK = FALSE;
                __leave;
            }

            // Debug info is stripped.
            // First, locate the correct DBG file
            rc = SearchForSymbolFile (
                                       szSearchPath,
                                       szMiscFileName,
                                       ext+1, // Extension of the image
                                       &SymErr,
                                       DBGSYM,
                                       (PVOID)&FileInfo,
                                       szDbgFileName,
                                       dwDbgFileNameLength,
                                       szRSDSDllToLoad );

            if (!rc) {
                LogDbgError(ErrMsg, &SymErr);
                SymbolsOK = FALSE;
                __leave;
            } else if ( hSymCDLog != NULL) {
                AddToSymbolsCDLog( hSymCDLog, &SymErr, SymErr.szSymbolFileName, ext+1);
            }

            pDbgHeader = NULL;
            pDbgHeader = MapDbgHeader(szDbgFileName,&DbgFile, &SymErr);
            if (!pDbgHeader) {
                SymbolsOK = FALSE;
                // 0 means info is inside of SymErr
                LogError(ErrMsg, &SymErr,0);
                __leave;
            }

            DebugDirectory = NULL;
            DebugDirectory = GetDebugDirectoryInDbg(
                                                   pDbgHeader,
                                                   &NumberOfDebugDirectories
                                                   );
            if (!DebugDirectory) {
                LogError( ErrMsg, &SymErr,NO_DEBUG_DIRECTORIES_IN_DBG_HEADER);
                SymbolsOK = FALSE;
                __leave;
            }
            pImageBase = (PCHAR)pDbgHeader;
        }

        // Image is not split
        else {

            // VC 6 compiler always produces non-split images.
            // Check the debug directories to determine if this is a VC 6 image.

            RawDataFound = FALSE;
            CVFound = FALSE;
            MiscFound = FALSE;
            for ( i=0; i< NumberOfDebugDirectories; i++ ) {
                pDbgDir = DebugDirectory + i;
                switch (pDbgDir->Type) {
                    case IMAGE_DEBUG_TYPE_MISC:
                        MiscFound = TRUE;
                        break;

                    case IMAGE_DEBUG_TYPE_CODEVIEW:
                        CVFound = TRUE;
                        break;

                    default:
                        // Nothing except the CV entry should point to raw data
                        if ( pDbgDir->SizeOfData != 0 ) {
                            RawDataFound = TRUE;
                        }
                        break;
                }
            }

            if ( !MiscFound && CVFound ) {

                // This is using the 6.0 linker.  It does not
                // need to be split into iamge + dbg, so don't
                // give an error for it, unless there is another
                // debug directory with a non-null pointer to raw data.

                if ( RawDataFound ) {
                    LogError( ErrMsg, &SymErr, EXTRA_RAW_DATA_IN_6);
                    return ( FALSE);
                } else {
                    // Continue - image should not be split
                }
            } else {
                DWORD CertificateSize;
                PVOID pCertificates = ImageDirectoryEntryToData(
                                                     (PVOID)pDosHeader,
                                                     FALSE,
                                                     IMAGE_DIRECTORY_ENTRY_SECURITY,
                                                     &CertificateSize
                                                     );
                if ( pCertificates ) {
                    // Image is signed and non-split
                    // It should be split before it is signed
                    LogError( ErrMsg, &SymErr, SIGNED_AND_NON_SPLIT);
                    SymbolsOK = FALSE;
                    __leave;
                } else if (SymchkFlag & ERROR_IF_NOT_SPLIT) {
                    // Image isn't split, log error and continue;
                    LogError( ErrMsg, &SymErr,ERROR_IF_NOT_SPLIT);
                    SymbolsOK = FALSE;
                    __leave;
                }
            }

            // File with the DBG info is the original image file name
            // This line may not be necessary.
            _tcscpy( SymErr.szSymbolFileName, szFileName );
        }

        CVFound = FALSE;
        // Process the Debug Directories
        for ( i=0; i<NumberOfDebugDirectories; i++) {
            pDbgDir = DebugDirectory + i;
            switch (pDbgDir->Type) {

                // Don't need to process entry since directory table has
                // already been located.
                case IMAGE_DEBUG_TYPE_MISC:  break;

                case IMAGE_DEBUG_TYPE_CODEVIEW:
                    CVFound = TRUE;
                    if ( !VerifyCV(
                                  szFileName,
                                  pImageBase,
                                  pDbgDir,
                                  ext+1,
                                  szSearchPath,
                                  &SymErr,
                                  szRSDSDllToLoad
                                  )
                       ) {
                        LogPdbError(ErrMsg, &SymErr);
                        SymbolsOK = FALSE;
                    } else if (hSymCDLog != NULL && _tcscmp(SymErr.szPdbFileName, "") ) {
                        // Copy SymErr.szPdbFileName to Symbol Dest\ext
                        AddToSymbolsCDLog( hSymCDLog, &SymErr, SymErr.szPdbFileName, ext+1 );
                    }
                    break;
                default:    break;
            }
        }
        if (!CVFound && CheckCodeView ) {
            SymErr.ErrNo = NO_CODE_VIEW;
            LogPdbError(ErrMsg, &SymErr);
            SymbolsOK=FALSE;
        }
    } __finally {
        UnmapFile((LPCVOID)pDbgHeader,DbgFile);
        UnmapFile((LPCVOID)pDosHeader,DosFile);
    }

    if (SymbolsOK) {
        LogError( ErrMsg, &SymErr, IMAGE_PASSED );
    }
    return SymbolsOK;
}


PIMAGE_DOS_HEADER
MapFileHeader (
              LPTSTR szFileName,
              PHANDLE phFile,
              PSYM_ERR pSymErr
              )

{

    /*
        Creates a file mapping and returns Handle for the DOS_HEADER
        If the file does not have a DOS_HEADER, then it returns NULL.


    */
    HANDLE hFileMap;
    PIMAGE_DOS_HEADER pDosHeader;
    DWORD  dFileType;
    BOOL rc;


    // phFile map needs to be returned, so it can be closed later
    (*phFile) = CreateFile( (LPCTSTR) szFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                          );

    if (*phFile == INVALID_HANDLE_VALUE) {
        pSymErr->ErrNo  = CREATE_FILE_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        return(NULL);
    }

    hFileMap = CreateFileMapping( *phFile,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL
                                );

    if ( hFileMap == INVALID_HANDLE_VALUE) {
        pSymErr->ErrNo = CREATE_FILE_MAPPING_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        CloseHandle(*phFile);
        return(NULL);
    }

    pDosHeader = (PIMAGE_DOS_HEADER) MapViewOfFile( hFileMap,
                                                    FILE_MAP_READ,
                                                    0,  // high
                                                    0,  // low
                                                    0   // whole file
                                                  );

    rc = CloseHandle(hFileMap);

    if ( !pDosHeader ) {
        pSymErr->ErrNo = MAPVIEWOFFILE_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        CloseHandle(*phFile);
        return(NULL);
    }

    //
    // Check to determine if this is an NT image (PE format)

    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        pSymErr->ErrNo = NO_DOS_HEADER;
        UnmapViewOfFile(pDosHeader);
        CloseHandle(*phFile);
        return(NULL);
    }
    return (pDosHeader);
}


PIMAGE_NT_HEADERS
GetNtHeader ( PIMAGE_DOS_HEADER pDosHeader,
              HANDLE hDosFile,
              LPTSTR szFileName,
              PSYM_ERR pSymErr,
              LPBY_HANDLE_FILE_INFORMATION lpFileInfo  
            )
{

    /*
        Returns the pointer the address of the NT Header.  If there isn't
        an NT header, it returns NULL
    */
    PIMAGE_NT_HEADERS pNtHeader;

    if (!GetFileInformationByHandle( hDosFile, lpFileInfo)) {
        pSymErr->ErrNo = GET_FILE_INFO_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        return(NULL);
    }

    if ( ((ULONG)(pDosHeader->e_lfanew) & 3) != 0) {

        //
        // The image header is not aligned on a long boundary.
        // Report this as an invalid protect mode image.
        //

        pSymErr->ErrNo = HEADER_NOT_ON_LONG_BOUNDARY;
        return (NULL);
    }


    if ((ULONG)(pDosHeader->e_lfanew) > lpFileInfo->nFileSizeLow) {
        pSymErr->ErrNo = IMAGE_BIGGER_THAN_FILE;
        return (NULL);
    }


    pNtHeader = (PIMAGE_NT_HEADERS)((PCHAR)pDosHeader +
                                    (ULONG)pDosHeader->e_lfanew);

    if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
        pSymErr->ErrNo = NOT_NT_IMAGE;
        return(NULL);
    }

    return (pNtHeader);
}


PIMAGE_SEPARATE_DEBUG_HEADER
MapDbgHeader (
             LPTSTR szFileName,
             PHANDLE phFile,
             PSYM_ERR pSymErr
             )
{
    HANDLE hFileMap;
    PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader;
    DWORD  dFileType;


    (*phFile) = CreateFile( (LPCTSTR) szFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                          );

    if (*phFile == INVALID_HANDLE_VALUE) {
        pSymErr->ErrNo  = CREATE_FILE_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        CloseHandle(*phFile);
        return(NULL);
    }

    hFileMap = CreateFileMapping( *phFile,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL
                                );

    if ( hFileMap == INVALID_HANDLE_VALUE) {
        pSymErr->ErrNo = CREATE_FILE_MAPPING_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        CloseHandle(*phFile);
        return(NULL);
    }


    pDbgHeader = (PIMAGE_SEPARATE_DEBUG_HEADER) MapViewOfFile( hFileMap,
                                                               FILE_MAP_READ,
                                                               0,  // high
                                                               0,  // low
                                                               0   // whole file
                                                             );
    CloseHandle(hFileMap);

    if ( !pDbgHeader ) {
        pSymErr->ErrNo = MAPVIEWOFFILE_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        UnmapFile((LPCVOID)pDbgHeader, *phFile);
        return(NULL);
    }

    return (pDbgHeader);
}

BOOL
UnmapFile( LPCVOID phFileMap, HANDLE hFile )
{
BOOL rc;

    if ((PHANDLE)phFileMap != NULL) {
        FlushViewOfFile(phFileMap,0);
        rc = UnmapViewOfFile( phFileMap );
        if (rc == 0) {
            printf("UnmapView of File failed with GetLastError=%d\n",GetLastError() );
        }
    }
    if (hFile) {
        rc = CloseHandle(hFile);
    }
    return TRUE;
}


IMAGE_DEBUG_DIRECTORY UNALIGNED *
GetDebugDirectoryInExe(
                      PIMAGE_DOS_HEADER pDosHeader,
                      ULONG *NumberOfDebugDirectories
                      )
{

    /* Exe is already mapped and a pointer to the base is
       passed in. Find a pointer to the Debug Directories
    */
    ULONG size;

    IMAGE_DEBUG_DIRECTORY UNALIGNED *pDebugDirectory = NULL;
    ULONG DebugDirectorySize;
    PIMAGE_SECTION_HEADER pSectionHeader;

    size = sizeof(IMAGE_DEBUG_DIRECTORY);

    pDebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
                      ImageDirectoryEntryToDataEx (
                                                  (PVOID)pDosHeader,
                                                  FALSE,
                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                  &DebugDirectorySize,
                                                  &pSectionHeader );

    if (pDebugDirectory) {
        (*NumberOfDebugDirectories) =
        DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY);
        return (pDebugDirectory);
    } else return(NULL);
}

IMAGE_DEBUG_DIRECTORY UNALIGNED *
GetDebugDirectoryInDbg(
                      PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader,
                      ULONG *NumberOfDebugDirectories
                      )
/*  Dbg is already mapped and a pointer to the base is
    passed in.  Returns a pointer to the Debug directories
*/
{
    IMAGE_DEBUG_DIRECTORY UNALIGNED *pDebugDirectory = NULL;

    pDebugDirectory = (PIMAGE_DEBUG_DIRECTORY) ((PCHAR)pDbgHeader +
                                                sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
                                                pDbgHeader->NumberOfSections * sizeof(IMAGE_SECTION_HEADER) +
                                                pDbgHeader->ExportedNamesSize);

    if (!pDebugDirectory) {
        return(NULL);
    }

    (*NumberOfDebugDirectories) =   pDbgHeader->DebugDirectorySize /
                                    sizeof(IMAGE_DEBUG_DIRECTORY);
    return (pDebugDirectory);

}


BOOL
VerifyCV(
        LPTSTR szFileName,
        PCHAR pImageBase,
        IMAGE_DEBUG_DIRECTORY UNALIGNED *pDbgDir,
        LPTSTR szExtPath,
        LPTSTR szSearchPath,
        PSYM_ERR pSymErr,
        LPTSTR szRSDSDllToLoad
        )

{
    TCHAR szFName[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];
    TCHAR szPdbFileName[_MAX_PATH*sizeof(TCHAR)];
    DWORD dwPdbFileNameLength = _MAX_PATH;
    BOOL rc;


    PCVDD pDebugCV = (PCVDD) (pImageBase +
                              pDbgDir->PointerToRawData );

    // Initialize pSymErr
    pSymErr->PdbFileFound = FALSE;
    pSymErr->PdbValid = FALSE;
    _tcscpy(pSymErr->szPdbErr,_T("") );
    _tcscpy(pSymErr->szPdbFileName,_T("") );

    switch (pDebugCV->dwSig)
    {

    case '05BN': 
        // CVpack failed
        // Symbols are not OK
        _tcscpy(pSymErr->szPdbErr,_T("Codeview type is NB05") );
        return (FALSE);
        break;
    case '90BN': 
        // For NB09 and NB11, the codeview info is in the image file
        // Thus, no need to locate symbols.  They are probably OK.
        return(TRUE);
        break;
    case '11BN':
        return(TRUE);
        break;
    case '01BN':
        // Symbols are type NB10
        // Locate the PDB information

        rc = SearchForSymbolFile (
                                            szSearchPath,
                                            pDebugCV->nb10i.szPdb, // File Name
                                            szExtPath,
                                            pSymErr,
                                            PDBSYM,
                                            (PVOID)pDebugCV,
                                            szPdbFileName,
                                            dwPdbFileNameLength,
                                            szRSDSDllToLoad
                                            );
        if (rc ) {
            // SearchForSymbolFile already gave pSymErr->szPdbFilename its value
            return TRUE;
        } else {
            _tsplitpath(pDebugCV->nb10i.szPdb,NULL,NULL,szFName,szExt);
            _tcscpy(pSymErr->szPdbFileName,szFName);
            _tcscat(pSymErr->szPdbFileName,szExt);
            return FALSE;
        }
        break;
    case 'SDSR':
        rc = SearchForSymbolFile (
                                            szSearchPath,
                                            pDebugCV->rsdsi.szPdb, // File Name
                                            szExtPath,
                                            pSymErr,
                                            PDBSYM,
                                            (PVOID)pDebugCV,
                                            szPdbFileName,
                                            dwPdbFileNameLength,
                                            szRSDSDllToLoad
                                            );
        if (rc ) {
            // SearchForSymbolFile already gave pSymErr->szPdbFilename its value
            return TRUE;
        } else {
            _tsplitpath(pDebugCV->rsdsi.szPdb,NULL,NULL,szFName,szExt);
            _tcscpy(pSymErr->szPdbFileName,szFName);
            _tcscat(pSymErr->szPdbFileName,szExt);
            return FALSE;
        }
        break;
    default:
        _tcscpy(pSymErr->szPdbErr,
                _T("Codeview info is not NB09, NB10, or NB11\n") );
        return(FALSE);
        break;
    }
}


LPSTR
GetMiscFile(
           PCHAR pImageBase,
           IMAGE_DEBUG_DIRECTORY UNALIGNED *pDbgDir
           )

{
    PIMAGE_DEBUG_MISC pDebugMisc;
    LPSTR szData;

    // Nothing to verify, but here is how to get to the DBG entry
    // Get the debug directory

    pDebugMisc = (PIMAGE_DEBUG_MISC)(pImageBase +
                                     pDbgDir->PointerToRawData );
    szData = (LPSTR) &pDebugMisc->Data[0];
    return(szData);
}


BOOL SearchForSymbolFile (   LPTSTR     szSearchPath, // ; separated search path
                             LPTSTR     szSymName,    // Symbol File to search for
                             LPTSTR     szPathExt,    // Extension directory
                             PSYM_ERR   pSymErr,
                             DWORD      dSymType,
                             PVOID      pelem1,
                             LPTSTR     szResult,
                             DWORD      dwResultLength,
                             LPTSTR     szRSDSDllToLoad
                           )

{
    /*++

    Routine Description:
       For each symbol path in szSearchPath, this function looks in the path
       and in the path concatenated with the szPathExt subdirectory.

    Arguments:
        szSearchPath    ; separated symbol path

        szSymName       Symbol file to search for

        szPathExt       Extension for the image that the symbol file matches

        pSymErr         Error structure

        dSymType        Type of symbol.  Possible values: DBGSYM, PDBSYM

        pelem1          Pointer to structure needed for comparing the symbols

        szResult        OUT Filename returned
        dwResultLength  IN Length of szResult


    Return Value:
        If the symbol file is found and verifies, it returns the full path and
        name of the symbol file.  Otherwise, it returns NULL.

    --*/

    TCHAR szTmpSearchPath[_MAX_PATH];
    TCHAR szExtPath[_MAX_PATH];
    TCHAR szFName[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];

    LPTSTR szResultFileName;
    LPTSTR seps = _T(";");
    LPTSTR szCurPath;
    DWORD  FoundLength;
    DWORD  CurLen, ExtLen;

    _tcscpy( szResult,_T("") );

    // Make a copy of szSearchPath because tcstok alters it
    _tcscpy(szTmpSearchPath,(LPCTSTR)szSearchPath);

    // Strip FileName from its path
    _tsplitpath(szSymName, NULL, NULL, szFName, szExt);
    _tcscat(szFName, szExt);

    // Try each search path
    szCurPath = _tcstok(szTmpSearchPath,seps);

    while ( szCurPath != NULL ) {

        FoundLength = SearchPath( szCurPath,
                                  szFName,
                                  NULL,
                                  dwResultLength,
                                  szResult,
                                  &szResultFileName
                                );
        if (FoundLength > 0 && FoundLength < dwResultLength) {

            switch ( dSymType ) {
                case DBGSYM:
                    // Status info, a match was found
                    pSymErr->SymbolFileFound = TRUE;
                    _tcscpy(pSymErr->szSymbolFileName, szResult);

                    // Validate the DBG file
                    if ( CompDbg(pelem1, szResult, pSymErr) ) {
                        return (TRUE);
                    }
                    break;

                case PDBSYM:
                    // Status info, a match was found
                    pSymErr->PdbFileFound = TRUE;
                    _tcscpy(pSymErr->szPdbFileName, szResult);

                    // Validate the PDB file
                    if ( CompPdb(pelem1, szResult, pSymErr, szRSDSDllToLoad) ) {
                        return (TRUE);
                    }
                    break;

                default: break;
            }
        }

        // Now try the path with szPathExt at the end of it
        // Don't try it if current path already has the extension
        // at the end of it
        CurLen = _tcslen(szCurPath);
        ExtLen = _tcslen(szPathExt);

        if ( _tcscmp ( (szCurPath + CurLen - ExtLen), szPathExt ) ) {

            _tcscpy(szExtPath, szCurPath);
            _tcscat(szExtPath, _T("\\") );
            _tcscat(szExtPath, szPathExt);

            FoundLength = SearchPath( szExtPath,
                                      szFName,
                                      NULL,
                                      dwResultLength,
                                      szResult,
                                      &szResultFileName
                                    );
            if (FoundLength > 0 && FoundLength < dwResultLength) {
                switch ( dSymType ) {
                    case DBGSYM:
                        // Status info, a match was found
                        pSymErr->SymbolFileFound = TRUE;
                        _tcscpy(pSymErr->szSymbolFileName, szResult);

                        // Validate the DBG file
                        if ( CompDbg(pelem1, szResult, pSymErr) ) {
                            return (TRUE);
                        }
                        break;
                    case PDBSYM:
                        // Status info, a match was found
                        pSymErr->PdbFileFound = TRUE;
                        _tcscpy(pSymErr->szPdbFileName, szResult);

                        // Validate the PDB file
                        if ( CompPdb(pelem1, szResult, pSymErr, szRSDSDllToLoad) ) {
                            return (TRUE);
                        }
                        break;
                    default: break;
                }
            }
        }
        szCurPath = _tcstok(NULL,seps);
    }

    // Symbol wasn't found.  Put name of file into SymErr for error message
    switch ( dSymType ) {
        case DBGSYM:
            _tcscpy(pSymErr->szSymbolFileName,szFName);
            break;
        case PDBSYM:
            _tcscpy(pSymErr->szPdbFileName, szFName);
            break;
        default: break;
    }

    return (FALSE);
}


USHORT
__cdecl
CompDbg(
       PVOID pelem1,
       LPTSTR szSymName,
       PSYM_ERR pSymErr
       )

/*++

    Routine Description:
        Validates the DBG against the original image

    Return Value:
        TRUE -  DBG matches
        FALSE - DBG doesn't match timedatestamp and checksum


--*/
{

    PFILE_INFO pFileInfo;
    PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader;
    HANDLE hFile;

    pFileInfo = (PFILE_INFO)(pelem1);
    pDbgHeader = MapDbgHeader ( szSymName, &hFile, pSymErr );

    if (pDbgHeader == NULL) {
        printf("ERROR: CompDbg(), %s was not opened successfully\n",szSymName);
        UnmapFile((LPCVOID)pDbgHeader, hFile);
        return FALSE;
    }
    if (pDbgHeader->Signature != IMAGE_SEPARATE_DEBUG_SIGNATURE) {
        printf("ERROR: CompDbg(), %s doesn't have Debug signature in header\n", szSymName);
        UnmapFile((LPCVOID)pDbgHeader, hFile);
        return FALSE;
    }

    // Record specifics of whether timedatestamp and checksum matched
    if ( pDbgHeader->SizeOfImage == pFileInfo->SizeOfImage ) {
        pSymErr->SizeOfImageMatch = TRUE;
    } else pSymErr->SizeOfImageMatch = FALSE;

    if ( pDbgHeader->TimeDateStamp == pFileInfo->TimeDateStamp ) {
        pSymErr->TimeDateStampsMatch = TRUE;
    } else pSymErr->TimeDateStampsMatch = FALSE;

    if ( pDbgHeader->CheckSum == pFileInfo->CheckSum ) {
        pSymErr->CheckSumsMatch = TRUE;
    } else pSymErr->CheckSumsMatch = FALSE;

    // Just check the timedatestamp for determining if the DBG matches
    // VC and KD don't pay attention to the checksum anymore.
    if ( pSymErr->TimeDateStampsMatch  &&
         pSymErr->SizeOfImageMatch &&
         ( !LogCheckSumErrors || pSymErr->CheckSumsMatch ) ) {
        UnmapFile((LPCVOID)pDbgHeader, hFile);
        return TRUE;
    } else {
        UnmapFile((LPCVOID)pDbgHeader, hFile);
        return FALSE;
    }
}

USHORT
__cdecl
CompPdb(
       PVOID pelem1,
       LPTSTR szSymName,
       PSYM_ERR pSymErr,
       LPTSTR szRSDSDllToLoad
       )

/*++

    Routine Description:
        Validates the PDB

    Return Value:
        TRUE    PDB validates
        FALSE   PDB doesn't validate
--*/

{

    PCVDD pPdbInfo;
    WCHAR wszSymName[_MAX_PATH + 1];

    BOOL valid=FALSE;
    PDB *pdb;
    EC ec;
    char  szError[cbErrMax] = _T("");
    wchar_t wszError[cbErrMax] = L"";
    DBI *pdbi;
    HMODULE hDll;

    pdb=NULL;
    pPdbInfo = (PCVDD)(pelem1);

    switch (pPdbInfo->dwSig)
    {
    case '01BN':
        __try
        {
            valid = PDBOpenValidate(szSymName,
                            NULL,
                            _T("r"),
                            pPdbInfo->nb10i.sig,
                            pPdbInfo->nb10i.age,
                            &ec,
                            szError,
                            &pdb
                           );

           if ( !valid ) {
               pSymErr->PdbValid = FALSE;
               __leave;
           } else pSymErr->PdbValid = TRUE;


           if (!CheckPrivate) {
               PDBClose(pdb);
               __leave;
           }

           // Verify that private information is stripped
           // Verify that line information is removed

           if ( !PDBOpenDBI(pdb, pdbRead, NULL, &pdbi) ) {
               // OpenDBI failed
               pSymErr->PdbValid = FALSE;
               pSymErr->ErrNo = PDB_MAY_BE_CORRUPT;
               DBIClose(pdbi);
               __leave;
           }

           if ( !PDBPrivateStripped(pdb, pdbi) ) {
               //Error - Source line info is not stripped
               pSymErr->PdbValid = FALSE;
               pSymErr->ErrNo = PRIVATE_INFO_NOT_REMOVED;
           }

           DBIClose(pdbi);
           PDBClose(pdb);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            pSymErr->PdbValid = FALSE;
            valid=FALSE;
        }

        return (USHORT)pSymErr->PdbValid;
        break;

    case 'SDSR':

#if defined(use_SymutilX)
        if ( !RSDSLibLoaded ) {
            hDll = LoadLibrary( szRSDSDllToLoad );
            if (hDll != NULL) {
                RSDSLibLoaded = TRUE;
                pPDBOpenValidate4 = ( PPDBOPENVALIDATE4 ) GetProcAddress( hDll, "PDBOpenValidate4" );
                if (pPDBOpenValidate4 == NULL ) {
                    _tcscpy(pSymErr->szPdbErr,"Cannot load PDBOpenValidate4");
                    return (FALSE);
                }
                pPDBClose = ( PPDBCLOSE ) GetProcAddress( hDll, "PDBClose" );
                if (pPDBClose == NULL ) {
                    _tcscpy(pSymErr->szPdbErr,"Cannot load PDBClose");
                    return (FALSE);
                } 
            } else {
                if (_tcslen(szRSDSDllToLoad) + _tcslen("Cannot load ") + 1 < MAX_PDB_ERR ) {
                    _tcscpy(pSymErr->szPdbErr,"Cannot load ");
                    _tcscat(pSymErr->szPdbErr, szRSDSDllToLoad);
                } else {
                    pSymErr->ErrNo = CANNOT_LOAD_RSDS;
                }
                pSymErr->PdbValid = FALSE;
                return (FALSE);
            }
        }
#endif

        ansi2wcs(szSymName, wszSymName, lengthof(wszSymName)); 

        __try
        {
#if defined(use_SymutilX)
            valid = pPDBOpenValidate4(wszSymName,
#else
            valid = PDBOpenValidate4(wszSymName,
#endif
                            _T("r"),
                            (PCSIG70) &(pPdbInfo->rsdsi.guidSig),
                            0,
                            (AGE) pPdbInfo->rsdsi.age,
                            &ec,
                            wszError,
                            cbErrMax,
                            &pdb
                           );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            valid = FALSE;
        }

        if ( !valid ) {
            pSymErr->PdbValid = FALSE;

            return FALSE;
        } else pSymErr->PdbValid = TRUE;


        if (!CheckPrivate) {
#if defined(use_SymutilX)
            pPDBClose(pdb);
#else
            PDBClose(pdb);
#endif
            return (USHORT)pSymErr->PdbValid;
        }

        // Verify that private information is stripped
        // Verify that line information is removed

#if defined(use_SymutilX)
        if ( pDBIQueryNextMod == NULL ) {
            pDBIQueryNextMod = ( PDBIQUERYNEXTMOD ) GetProcAddress( hDll, "DBIQueryNextMod" );
            if (pPDBOpenValidate4 == NULL ) {
                _tcscpy(pSymErr->szPdbErr,"Cannot load PDBClose, GetProcAddress failed.");
                return (FALSE);
            }
        }

        if ( pModClose == NULL ) {
            pModClose = ( PMODCLOSE ) GetProcAddress( hDll, "ModClose" );
            if (pModClose == NULL ) {  
                _tcscpy(pSymErr->szPdbErr,"Cannot load PDBClose, GetProcAddress failed.");
                return (FALSE);
            }
        }

        if ( pModQueryLines == NULL ) {
            pModQueryLines = ( PMODQUERYLINES ) GetProcAddress( hDll, "ModQueryLines" );
            if (pModQueryLines == NULL ) {
                _tcscpy(pSymErr->szPdbErr,"Cannot load ModQueryLines, GetProcAddress failed.");
                return (FALSE);
            }
        }

        if ( pModQuerySymbols == NULL ) {
            pModQuerySymbols = ( PMODQUERYSYMBOLS ) GetProcAddress( hDll, "ModQuerySymbols" );
            if (pModQuerySymbols == NULL ) {
                _tcscpy(pSymErr->szPdbErr,"Cannot load ModQuerySymbols, GetProcAddress failed.");
                return (FALSE);
            }
        }

        if ( pDBIQueryTypeServer == NULL ) {
            pDBIQueryTypeServer = ( PDBIQUERYTYPESERVER ) GetProcAddress( hDll, "DBIQueryTypeServer" );
            if (pDBIQueryTypeServer == NULL ) {
                _tcscpy(pSymErr->szPdbErr,"Cannot load DBIQueryTypeServer, GetProcAddress failed.");
                return (FALSE);
            }
        }

        if ( pPDBOpenTpi == NULL ) {
            pPDBOpenTpi = ( PPDBOPENTPI ) GetProcAddress( hDll, "PDBOpenTpi" );
            if (pPDBOpenTpi == NULL ) {
                _tcscpy(pSymErr->szPdbErr,"Cannot load PDBOpenTpi, GetProcAddress failed.");
                return (FALSE);
            }
        }

        if ( pTypesQueryTiMinEx == NULL ) {
            pTypesQueryTiMinEx = ( PTYPESQUERYTIMINEX ) GetProcAddress( hDll, "TypesQueryTiMinEx" );
            if (pTypesQueryTiMinEx == NULL ) {
                _tcscpy(pSymErr->szPdbErr,"Cannot load TypesQueryTiMinEx, GetProcAddress failed.");
                return (FALSE);
            }
        }

        if ( pTypesQueryTiMacEx == NULL ) {
            pTypesQueryTiMacEx = ( PTYPESQUERYTIMACEX ) GetProcAddress( hDll, "TypesQueryTiMacEx" );
            if (pTypesQueryTiMacEx == NULL ) {
                _tcscpy(pSymErr->szPdbErr,"Cannot load TypesQueryTiMacEx, GetProcAddress failed.");
                return (FALSE);
            }
        }

        if ( pTypesClose == NULL ) {
            pTypesClose = ( PTYPESCLOSE ) GetProcAddress( hDll, "TypesClose" );
            if (pTypesClose == NULL ) {
                _tcscpy(pSymErr->szPdbErr,"Cannot load TypesClose, GetProcAddress failed.");
                return (FALSE);
            }
        }

        if ( pPDBOpenDBI == NULL ) {
            pPDBOpenDBI = ( PPDBOPENDBI ) GetProcAddress( hDll, "PDBOpenDBI" );
            if (pPDBOpenDBI == NULL ) {
                _tcscpy(pSymErr->szPdbErr,"Cannot load PDBOpenDBI, GetProcAddress failed.");
                return (FALSE);
            }
        }

        if ( pDBIClose == NULL ) {
            pDBIClose = ( PDBICLOSE ) GetProcAddress( hDll, "DBIClose" );
            if (pDBIClose == NULL ) {
                _tcscpy(pSymErr->szPdbErr,"Cannot load DBIClose, GetProcAddress failed.");
                return (FALSE);
            }
        }

        if ( !pPDBOpenDBI(pdb, pdbRead, NULL, &pdbi) ) {
            // OpenDBI failed
            pSymErr->ErrNo = PDB_MAY_BE_CORRUPT;
            pDBIClose(pdbi);
            return FALSE;
        }

        if ( !PDBPrivateStrippedX(pdb, pdbi) ) {
            //Error - Source line info is not stripped
            pSymErr->PdbValid = FALSE;
            pSymErr->ErrNo = PRIVATE_INFO_NOT_REMOVED;
        }

        pDBIClose(pdbi);
        pPDBClose(pdb);
        return (USHORT)pSymErr->PdbValid;
        break;
#else
        if ( !PDBOpenDBI(pdb, pdbRead, NULL, &pdbi) ) {
            // OpenDBI failed
            pSymErr->ErrNo = PDB_MAY_BE_CORRUPT;
            DBIClose(pdbi);
            return FALSE;
        }

        if ( !PDBPrivateStripped(pdb, pdbi) ) {
            //Error - Source line info is not stripped
            pSymErr->PdbValid = FALSE;
            pSymErr->ErrNo = PRIVATE_INFO_NOT_REMOVED;
        }

        DBIClose(pdbi);
        PDBClose(pdb);
        return (USHORT)pSymErr->PdbValid;
        break;

#endif

    default: break;
    }
    return (FALSE);
}


BOOL
ResourceOnlyDll(
               PVOID pImageBase,
               BOOLEAN bMappedAsImage
               )

/*++

Routine Description:

    Returns true if the image is a resource only dll.

--*/

{

    PVOID pExports, pImports, pResources;
    DWORD dwExportSize, dwImportSize, dwResourceSize;
    BOOL fResourceOnlyDll;

    pExports = ImageDirectoryEntryToData(pImageBase,
                                         bMappedAsImage,
                                         IMAGE_DIRECTORY_ENTRY_EXPORT,
                                         &dwExportSize);

    pImports = ImageDirectoryEntryToData(pImageBase,
                                         bMappedAsImage,
                                         IMAGE_DIRECTORY_ENTRY_IMPORT,
                                         &dwImportSize);

    pResources = ImageDirectoryEntryToData(pImageBase,
                                           bMappedAsImage,
                                           IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                           &dwResourceSize);

    if (pResources && dwResourceSize &&
        !pImports && !dwImportSize &&
        !pExports && !dwExportSize) {
        return (TRUE);
    } else {
        return (FALSE);
    }
}


BOOL
LogError(
        LPTSTR ErrMsg,
        PSYM_ERR pSymErr,
        UINT ErrNo )
{

    TCHAR szFName[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];
    TCHAR szCurName[_MAX_FNAME];


    if (pSymErr->ErrNo != 0) ErrNo = pSymErr->ErrNo;

    // Get the file name without any path info:
    _tsplitpath(pSymErr->szFileName,NULL,NULL,szFName,szExt);
    _tcscpy(szCurName,szFName);
    _tcscat(szCurName,szExt);

    _tcscpy(ErrMsg,_T(""));

    // See if this is a file that we aren't supposed to report errors
    // for.  If it is, just return without writing an error.

    if ( pErrorFilterList != NULL ) {
        if ( InExcludeList( szCurName, pErrorFilterList ) ) {
            return(TRUE);
        }
    }

    switch (ErrNo) {
        case NO_DEBUG_DIRECTORIES:
            _stprintf(ErrMsg, "%-20s FAILED  - Built with no debugging information\n",
                      szCurName);
            return(TRUE);

        case NO_DEBUG_DIRECTORIES_IN_DBG_HEADER:
            _stprintf(ErrMsg, "%-20s FAILED  - Image header has no debugging information\n",
                      szCurName);
            return(TRUE);

        case NO_MISC_ENTRY:
            _stprintf(ErrMsg, "%-20s FAILED  - No MISC entry in debug directories\n",
                      szCurName);
            return(TRUE);

        case NO_FILE_IN_MISC:
            _stprintf(ErrMsg, "%-20s FAILED  - MISC entry contains no .dbg file information\n",
                      szCurName);
            return(TRUE);

        case ERROR_IF_SPLIT:
            _stprintf(ErrMsg, "%-20s FAILED  - Image points to a .DBG symbol file - fix with dbgtopdb.exe\n",
                      szCurName);
            return(TRUE);

        case ERROR_IF_NOT_SPLIT:
            _stprintf(ErrMsg, "%-20s FAILED  - Image contains .DBG file data - fix with dbgtopdb.exe\n",
                      szCurName);
            return(TRUE);

        case EXTRA_RAW_DATA_IN_6:
            _stprintf(ErrMsg, "%-20s FAILED  - No misc entry, but debug directories point to non-Codeview data\n",
                      szCurName );
            return (TRUE);

        case IGNORE_IF_SPLIT:
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image is already split\n",szCurName);
            }
            return(TRUE);


        case NO_CODE_VIEW:
            _stprintf(ErrMsg, "%-20s FAILED  - %s does not have a pointer to CodeView information\n",
                      szCurName, pSymErr->szSymbolFileName);
            return(TRUE);

        case FILE_NOT_FOUND:
            _stprintf(ErrMsg, "%-20s FAILED  - File does not exist\n",szCurName);
            return(TRUE);

        case CREATE_FILE_FAILED :
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image is not a valid NT image.\n", szCurName);
            }
            return(TRUE);

        case CREATE_FILE_MAPPING_FAILED :
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image is not a valid NT image.\n", szCurName);
            }
            return(TRUE);

        case MAPVIEWOFFILE_FAILED :
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image is not a valid NT image.\n", szCurName);
            }
            return(TRUE);

        case GET_FILE_INFO_FAILED :
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image is not a valid NT image.\n", szCurName);
            }
            return(TRUE);

        case HEADER_NOT_ON_LONG_BOUNDARY:
            // Not an NT image - ignore the error
            if (pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - This is either corrupt or a DOS image\n", szCurName);
            }
            return(TRUE);

        case IMAGE_BIGGER_THAN_FILE:
            if (pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - This is either corrupt or a DOS image\n", szCurName);
            }
            return(TRUE);

        case INVALID_ADDRESSOFRAWDATA_ZERO_DEBUG:
            _stprintf(ErrMsg, "%-20s FAILED  - Invalid AddressOfRawData for zero sized debug info\n",
                      szCurName);
            return(TRUE);

        case INVALID_POINTERTORAWDATA_NON_ZERO:
            _stprintf(ErrMsg, "%-20s FAILED  - Invalid PointerToRawData for non-zero sized debug info\n",
                      szCurName);
            return(TRUE);

        case INVALID_POINTERTORAWDATA_ZERO_DEBUG:
            _stprintf(ErrMsg, "%-20s FAILED  - Invalid PointerToRawData for zero sized debug info\n",
                      szCurName);
            return(TRUE);

        case NO_DOS_HEADER:
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image does not have a DOS header\n",
                          szCurName);
            }
            return(TRUE);

        case NOT_NT_IMAGE:
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image does not have an NT header\n",
                          szCurName);
            }
            return(TRUE);
        case IMAGE_PASSED :
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s PASSED \n",szCurName);
            }
            return(TRUE);

        case RESOURCE_ONLY_DLL:
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Resource only DLL\n",szCurName);
            }
            return(TRUE);

        case SIGNED_AND_NON_SPLIT:
            _stprintf(ErrMsg, "%-20s FAILED  - It is signed and debug info can't be stripped without invalidating the signature\n",
                      szCurName);
            return(TRUE);

        default:
            return(TRUE);
    }
    return (FALSE);
}


BOOL
LogDbgError(
           LPTSTR ErrMsg,
           PSYM_ERR pSymErr
           )

{

    TCHAR szFName[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];
    TCHAR szCurName[_MAX_FNAME];
    TCHAR szSymName[_MAX_FNAME];

    // Get the file name without any path info:
    _tsplitpath(pSymErr->szFileName,NULL,NULL,szFName,szExt);
    _tcscpy(szCurName,szFName);
    _tcscat(szCurName,szExt);

    _tcscpy(ErrMsg,_T("") );

    // See if this is a file that we aren't supposed to report errors
    // for.  If it is, just return without writing an error.

    if ( pErrorFilterList != NULL ) {
        if ( InExcludeList( szCurName, pErrorFilterList ) ) {
            return(TRUE);
        }
    }

    // Get the file name without any path info:
    _tsplitpath(pSymErr->szSymbolFileName,NULL,NULL,szFName,szExt);
    _tcscpy(szSymName,szFName);
    _tcscat(szSymName,szExt);


    if ( !pSymErr->SymbolFileFound ) {
        _stprintf(ErrMsg, "%-20s FAILED  - Image is split correctly, but %s is missing\n",
                  szCurName, szSymName);
        return(TRUE);
    }

    if ( LogCheckSumErrors && !pSymErr->CheckSumsMatch) {
        _stprintf(ErrMsg, "%-20s FAILED  - Checksum doesn't match with %s\n",
                  szCurName, szSymName);
        return(TRUE);
    }

    if ( !pSymErr->SizeOfImageMatch) {
        _stprintf(ErrMsg, "%-20s FAILED  - Size of image doesn't match with %s\n",
                  szCurName, szSymName);
        return(TRUE);
    }

    if ( !pSymErr->TimeDateStampsMatch) {
        _stprintf(ErrMsg, "%-20s FAILED  - Timedate stamp doesn't match with %s\n",
                  szCurName, szSymName);
        return(TRUE);
    }

    return(TRUE);
}


BOOL
LogPdbError(
           LPTSTR ErrMsg,
           PSYM_ERR pSymErr
           )

{

    TCHAR szFName[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];
    TCHAR szCurName[_MAX_FNAME];
    TCHAR szSymName[_MAX_FNAME];
    TCHAR szPdbName[_MAX_FNAME];

    // Get the file name without any path info:
    _tsplitpath(pSymErr->szFileName,NULL,NULL,szFName,szExt);
    _tcscpy(szCurName,szFName);
    _tcscat(szCurName,szExt);

    _tcscpy(ErrMsg,_T("") );

    // See if this is a file that we aren't supposed to report errors
    // for.  If it is, just return without writing an error.

    if ( pErrorFilterList != NULL ) {
        if ( InExcludeList( szCurName, pErrorFilterList ) ) {
            return(TRUE);
        }
    }

    // Get the file name without any path info:
    _tsplitpath(pSymErr->szSymbolFileName,NULL,NULL,szFName,szExt);
    _tcscpy(szSymName,szFName);
    _tcscat(szSymName,szExt);


    // Get the file name without any path info:
    _tsplitpath(pSymErr->szPdbFileName,NULL,NULL,szFName,szExt);
    _tcscpy(szPdbName,szFName);
    _tcscat(szPdbName,szExt);

    if (pSymErr->ErrNo == NO_CODE_VIEW) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s does not point to CodeView information\n",
                  szCurName, szSymName);
        return(TRUE);
    }

    if (pSymErr->ErrNo == PRIVATE_INFO_NOT_REMOVED) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s contains private information\n",
                  szCurName, szPdbName);
        return(TRUE);
    }

    if (pSymErr->ErrNo == PDB_MAY_BE_CORRUPT) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s may be corrupt\n",
                  szCurName, szPdbName);
        return(TRUE);
    }

    if (pSymErr->ErrNo == CANNOT_LOAD_RSDS) {
        _stprintf(ErrMsg, "%-20s FAILED  - Cannot load the RSDS dll \n",
                  szCurName);
        return(TRUE);
    }

    if ( _tcscmp(pSymErr->szPdbErr,_T("") ) ) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s\n",szCurName, pSymErr->szPdbErr );
        return(TRUE);
    }

    if ( pSymErr->SymbolFileFound  && !pSymErr->PdbFileFound ) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s is correct, but %s is missing\n",
                  szCurName, szSymName, szPdbName);
        return(TRUE);
    }

    if ( !pSymErr->PdbFileFound ) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s is missing \n",szCurName,szPdbName );
        return(TRUE);
    }

    // There was a DBG file, but PDB file didn't validate

    if ( pSymErr->SymbolFileFound && !pSymErr->PdbValid ) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s and %s signatures do not match\n",
                  szCurName, szSymName, szPdbName);
        return(TRUE);
    }

    // There isn't supposed to be a DBG file.  PDB doesn't validate against
    // image.

    if ( !pSymErr->PdbValid ) {
        _stprintf(ErrMsg, "%-20s FAILED  - signature does not match %s\n",
                  szCurName, szPdbName );
        return(TRUE);
    }
    return(FALSE);
}


BOOL AddToSymbolsCDLog(
                      FILE *hSymCDLog,
                      PSYM_ERR pSymErr,
                      LPTSTR szSymbolPath,
                      LPTSTR szFileExt
                      )

/*
   szSymbolPath is the full path and name to the symbol file
   szFileExt is the extension of the image without the '.' at
   the front
*/

{

    LPTSTR szSrc;
    LPTSTR szDest;
    LPTSTR szTmp;

    TCHAR szFName[_MAX_FNAME+1];
    TCHAR szExt[_MAX_EXT+1];
    TCHAR szCurName[_MAX_FNAME + _MAX_EXT + 1];
    TCHAR szDestDir[_MAX_PATH];
    TCHAR szSymName[_MAX_FNAME + 1];
    TCHAR szSymExt[_MAX_EXT + 1];

    // If there is a list of the files that belong on the
    // CD, then only write this file to the log for the
    // symbol CD if the file is in the list
    //
    // Originally, this was used for the international
    // incremental builds.
    //
    if ( pCDIncludeList != NULL ) {
        if ( !InList( szSymbolPath, pCDIncludeList ) ) {
            return (TRUE);
        }
    }

    // Get the file name without any path info:
    _tsplitpath(pSymErr->szFileName,NULL,NULL,szFName,szExt);
    _tcscpy(szCurName,szFName);


    // Put the path below "binaries" as the source
    szSrc = _tcsstr(szSymbolPath, _T("symbols\\") );

    if (szSrc == NULL) {
        printf("%s: Cannot find \"symbols\\\" in the symbol file's path\n",
               szCurName);
        exit(1);
    }
    if ( _tcscmp( szSrc, _T("symbols\\") )  == 0 ) {
        printf("Symbol file name cannot end with \"symbols\\\"\n");
        exit(1);
    }

    // Move the Destination up to the directory after symbols.  If this is
    // the retail directory, don't include retail in the path.
    szDest = szSrc + _tcslen(_T("symbols\\"));

    if ( _tcsncmp( szDest, _T("retail\\"), _tcslen(_T("retail\\")) ) == 0 ) {
        szDest = szDest + _tcslen(_T("retail\\"));
    }

    _tsplitpath(szDest,NULL,szDestDir,NULL,NULL);

    // Remove the '\' from the end of the string;
    szTmp = szDestDir + _tcslen(szDestDir) - 1;
    while ( _tcscmp( szTmp, _T("\\")) == 0 ) {
        _tcscpy( szTmp, _T("") );
        szTmp--;
    }

    // get the symbol file name
    _tsplitpath(szSymbolPath,NULL,NULL,szSymName,szSymExt);

    RemoveDuplicateSlashes(pSymErr->szFileName);

    fprintf(hSymCDLog, "%s,%s%s,%s,%s\n", pSymErr->szFileName,
            szSymName,szSymExt,szSrc,szDestDir);

    return (TRUE);
}



P_LIST
GetList(
       LPTSTR szFileName
       )

{

    /* GetList gets the list and keeps the original file name which could
     * have included the path to the file
     * Note, it can be merged with GetExcludeList.  I first created it for
     * use in creating the symbols CD, and didn't want to risk entering a
     * bug into symchk
     */

    P_LIST pList;

    FILE  *fFile;
    TCHAR szCurFile[_MAX_FNAME+1], *c;
    TCHAR fname[_MAX_FNAME+1], ext[_MAX_EXT+1];
    DWORD i;
    LPTSTR szEndName;


    if (  (fFile = _tfopen(szFileName,_T("r") )) == NULL )
    {
        // printf( "Cannot open the exclude file %s\n",szFileName );
        return NULL;
    }

    pList = (P_LIST)malloc(sizeof(LIST));

    if (pList)
    {
        pList->dNumFiles = 0;
        while ( _fgetts(szCurFile,_MAX_FNAME,fFile) )
        {
            if ( szCurFile[0] == ';' ) continue;
            (pList->dNumFiles)++;
        }

        // Go back to the beginning of the file
        fseek(fFile,0,0);
        pList->List = (LIST_ELEM*)malloc( sizeof(LIST_ELEM) *
                                          (pList->dNumFiles));
        if (pList->List == NULL)
        {
            free(pList);
            pList = NULL;
        }
        else
        {
            i = 0;
            while ( i < pList->dNumFiles )
            {
                memset(szCurFile,'\0',sizeof(TCHAR) * (_MAX_FNAME+1) );
                _fgetts(szCurFile,_MAX_FNAME,fFile);

                // Replace the \n with \0
                c = NULL;
                c  = _tcschr(szCurFile, '\n');
                if ( c != NULL) *c='\0';

                if ( szCurFile[0] == ';' ) continue;

                if ( _tcslen(szCurFile) > _MAX_FNAME ) {
                    printf("File %s has a string that is too large\n",szFileName);
                    free(pList->List);
                    free(pList);
                    fclose(fFile);
                    return(NULL);
                }

                // Allow for spaces and a ; after the file name
                // Move the '\0' back until it has erased the ';' and any
                // tabs and spaces that might come before it
                szEndName = _tcschr(szCurFile, ';');

                // Set the pointer to the last character in the string if
                // there wasn't a comment
                if (szEndName == NULL ) {
                    if (_tcslen(szCurFile) > 0 ) {
                        szEndName = szCurFile + _tcslen(szCurFile) - 1;
                    }
                }

                if (szEndName != NULL ) {
                    while ( *szEndName == ';' || *szEndName == ' '
                            || *szEndName == '\t' ) {
                        *szEndName = '\0';
                        if ( szEndName > szCurFile ) szEndName--;
                    }
                }

                _tcscpy(pList->List[i].Path,szCurFile);

                _tsplitpath(szCurFile,NULL,NULL,fname,ext);

                _tcscpy(pList->List[i].FName,fname);
                _tcscat(pList->List[i].FName,ext);

                i++;
            }

            // Sort the List
            dbg_qsort( (void*)pList->List, (size_t)pList->dNumFiles,
                   (size_t)sizeof(LIST_ELEM), SymComp2 );
        }
    }

    fclose(fFile);

    return (pList);
}

int __cdecl
SymComp2(
        const void *e1,
        const void *e2
        )
{
    LPTSTR p1,n1;
    LPTSTR p2,n2;
    int rc;

    p1 = ((LIST_ELEM*)e1)->FName;
    p2 = ((LIST_ELEM*)e2)->FName;

    n1 = ((LIST_ELEM*)e1)->Path;
    n2 = ((LIST_ELEM*)e2)->Path;

    rc = _tcsicmp(p1,p2);
    if (rc == 0) return ( _tcsicmp(n1,n2) );
    else return (rc);
}



BOOL PDBPrivateStripped(
                       PDB *ppdb,
                       DBI *pdbi
                       )
{
    // Return values:
    // FALSE - Private Information has NOT been stripped
    // TRUE - Private Information has been stripped

    Mod *pmod;
    Mod *prevmod; 
    long cb;

    unsigned itsm;
    TPI *ptpi;
    TI  tiMin;
    TI  tiMac;

    pmod = NULL;
    prevmod=NULL;
    while (DBIQueryNextMod(pdbi, pmod, &pmod) && pmod) {
        if (prevmod != NULL) ModClose(prevmod);

        // Check that Source line info is removed
        ModQueryLines(pmod, NULL, &cb);

        if (cb != 0) {
            ModClose(pmod);
            return FALSE;
        }

        // Check that local symbols are removed
        ModQuerySymbols(pmod, NULL, &cb);

        if (cb != 0) {
            ModClose(pmod);
            return FALSE;
        }
        prevmod=pmod;
    }
    if (pmod != NULL) ModClose(pmod);
    if (prevmod != NULL) ModClose(prevmod);

    // Check that types are removed
    for ( itsm = 0; itsm < 256; itsm++) {
        ptpi = 0;
        if (DBIQueryTypeServer(pdbi, (ITSM) itsm, &ptpi)) {
            continue;
        }
        if (!ptpi) {

            PDBOpenTpi(ppdb, pdbRead, &ptpi);
            tiMin = TypesQueryTiMinEx(ptpi);
            tiMac = TypesQueryTiMacEx(ptpi);
            if (tiMin < tiMac) {
                TypesClose(ptpi);
                return FALSE;
            }
        }
    }
    TypesClose(ptpi);
    return (TRUE);
}

#if defined(use_SymutilX)

BOOL PDBPrivateStrippedX(
                       PDB *ppdb,
                       DBI *pdbi
                       )
{
    // Return values:
    // FALSE - Private Information has NOT been stripped
    // TRUE - Private Information has been stripped

    Mod *pmod;
    Mod *prevmod;
    long cb;

    unsigned itsm;
    TPI *ptpi;
    TI  tiMin;
    TI  tiMac;

    pmod = NULL;
    prevmod=NULL;
    while (pDBIQueryNextMod(pdbi, pmod, &pmod) && pmod) {
        if (prevmod != NULL) pModClose(prevmod);

        // Check that Source line info is removed
        pModQueryLines(pmod, NULL, &cb);

        if (cb != 0) {
            pModClose(pmod);
            return FALSE;
        }

        // Check that local symbols are removed
        pModQuerySymbols(pmod, NULL, &cb);

        if (cb != 0) {
            pModClose(pmod);
            return FALSE;
        }
        prevmod=pmod;
    }
    if (pmod != NULL) pModClose(pmod);
    if (prevmod != NULL) pModClose(prevmod);

    // Check that types are removed
    for ( itsm = 0; itsm < 256; itsm++) {
        ptpi = 0;
        if (pDBIQueryTypeServer(pdbi, (ITSM) itsm, &ptpi)) {
            continue;
        }
        if (!ptpi) {

            pPDBOpenTpi(ppdb, pdbRead, &ptpi);
            tiMin = pTypesQueryTiMinEx(ptpi);
            tiMac = pTypesQueryTiMacEx(ptpi);
            if (tiMin < tiMac) {
                pTypesClose(ptpi);
                return FALSE;
            }
        }
    }
    pTypesClose(ptpi);
    return (TRUE);
}

#endif


BOOL
RemoveDuplicateSlashes(
   LPTSTR Str
) {

ULONG i,j;
BOOL prev;
LPTSTR cur;

   prev = FALSE;   // False means the previous character was not a '\'
                   // True means the previous character was a '\'

   j = _tcslen(Str);
   if (j == 0 ) return TRUE;
   cur = Str;

   for (i=0; i< j; i++ ) {
      if ( *(Str+i) == _T('\\') ) {

        if ( prev == FALSE ) {

           prev=TRUE;
           *cur=*(Str+i);
           cur++;

        } else {

           // do nothing 
        }

      } else {

           prev=FALSE;
           *cur=*(Str+i);
           cur++;
      }
   }

   *cur=_T('\0');
   return(TRUE);
}


BOOL
ansi2wcs(
    PSTR  psz,
    PWSTR pwsz,
    DWORD pwszlen
    )
{
    BOOL rc;
    int  len;

    assert(psz && pwsz);

    len = strlen(psz);
    if (!len)
        return FALSE;

    rc = MultiByteToWideChar(CP_ACP,
                             MB_COMPOSITE,
                             psz,
                             len,
                             pwsz,
                             pwszlen);
    if (!rc)
        return FALSE;

    pwsz[len] = 0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\symutil.h ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tchar.h>


#define MAX_SYM_ERR         500

#define IGNORE_IF_SPLIT     0x1
#define ERROR_IF_SPLIT      0x2
#define ERROR_IF_NOT_SPLIT  0x4

typedef struct _EXCLUDE_LIST {
    LPTSTR *szExcList;      // Pointers to the file names
    DWORD dNumFiles;
} EXCLUDE_LIST, *PEXCLUDE_LIST;

PEXCLUDE_LIST
GetExcludeList(
    LPTSTR szFileName
);

BOOL
InExcludeList(
    LPTSTR szFileName,
    PEXCLUDE_LIST pExcludeList
);

BOOL
CheckSymbols (
    LPTSTR ErrMsg,
    LPTSTR szSearchpath,
    LPTSTR szFileName,
    FILE   *hSymCDLog,
    ULONG SymchkFlag,
    BOOL Verbose,
    LPTSTR szRSDSDllToLoad
);

// Stuff for logging the errors

#define NO_DEBUG_DIRECTORIES                10
#define NO_DEBUG_DIRECTORIES_IN_DBG_HEADER  11
#define NO_MISC_ENTRY                       12
#define NO_FILE_IN_MISC                     13
#define NO_CODE_VIEW                        15
#define CREATE_FILE_FAILED                  16
#define CREATE_FILE_MAPPING_FAILED          17
#define MAPVIEWOFFILE_FAILED                18
#define GET_FILE_INFO_FAILED                19
#define HEADER_NOT_ON_LONG_BOUNDARY         20
#define IMAGE_BIGGER_THAN_FILE              21
#define NO_DOS_HEADER                       22
#define NOT_NT_IMAGE                        23
#define IMAGE_PASSED                        24
#define RESOURCE_ONLY_DLL                   25
#define FILE_NOT_FOUND                      26
#define EXTRA_RAW_DATA_IN_6                 27
#define INVALID_POINTERTORAWDATA_NON_ZERO   28
#define INVALID_ADDRESSOFRAWDATA_ZERO_DEBUG 29
#define INVALID_POINTERTORAWDATA_ZERO_DEBUG 30
#define PRIVATE_INFO_NOT_REMOVED            31
#define PDB_MAY_BE_CORRUPT                  32
#define SIGNED_AND_NON_SPLIT                33
#define CANNOT_LOAD_RSDS                    34

#define MAX_PDB_ERR                         200

typedef struct _SymErr {
    BOOL   Verbose;
    UINT   ErrNo;                         // Error message number
    UINT   ErrNo2;                        // Additional error number
    TCHAR  szFileName[_MAX_FNAME];        // Image file
    TCHAR  szSymbolFileName[_MAX_FNAME];  // Full path and name of DBG file
    TCHAR  szSymbolSearchPath[_MAX_PATH]; // ; delimited symbol search path
    BOOL   SymbolFileFound;               // Was a DBG file found
    BOOL   SizeOfImageMatch;              // Does size of image match between
                                          //   image and the DBG?
    BOOL   CheckSumsMatch;                // Do Checksums match between the
                                          //   image and the DBG
    BOOL   TimeDateStampsMatch;           // Do TimeDateStampsMatch between
                                          //   the image and the DBG
    BOOL   PdbFileFound;                  // Pdb with correct name was located
    BOOL   PdbValid;                      // Pdb opens and validates
    TCHAR  szPdbErr[MAX_PDB_ERR];         // Pdb error message
    TCHAR  szPdbFileName[_MAX_FNAME];     // Full path and name of Pdb file
} SYM_ERR, *PSYM_ERR;

BOOL
LogError(
    LPTSTR ErrMsg,
    PSYM_ERR pSymErr,
    UINT ErrNo
);


BOOL
LogDbgError(
    LPTSTR ErrMsg,
    PSYM_ERR pSymErr
);

BOOL
LogPdbError(
    LPTSTR ErrMsg,
    PSYM_ERR pSymErr
);

int __cdecl
SymComp2(
      const void *e1,
      const void *e2
);

typedef struct _LIST_ELEM {
    CHAR FName[_MAX_PATH];
    CHAR Path[_MAX_PATH];
} LIST_ELEM, *P_LIST_ELEM;

typedef struct _LIST {
    LIST_ELEM *List;      // Pointers to the file names
    DWORD dNumFiles;
} LIST, *P_LIST;

P_LIST
GetList(
    LPTSTR szFileName
);

BOOL
InList(
    LPTSTR szFileName,
    P_LIST pExcludeList
);

// Global variables

extern BOOL CheckPrivate;
extern PEXCLUDE_LIST pErrorFilterList;
extern P_LIST pCDIncludeList;
extern BOOL Recurse;
extern BOOL CheckCodeView;
extern BOOL LogCheckSumErrors;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\sympriv.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    symbolsp.c

Abstract:

    This function implements a generic simple symbol handler.

Author:

    Wesley Witt (wesw) 1-Sep-1994

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>
#include "private.h"
#include "symbols.h"
#include "globals.h"
#include "tlhelp32.h"

#include "fecache.hpp"

typedef BOOL   (WINAPI *PMODULE32)(HANDLE, LPMODULEENTRY32);
typedef HANDLE (WINAPI *PCREATE32SNAPSHOT)(DWORD, DWORD);

typedef ULONG (NTAPI *PRTLQUERYPROCESSDEBUGINFORMATION)(HANDLE,ULONG,PRTL_DEBUG_INFORMATION);
typedef PRTL_DEBUG_INFORMATION (NTAPI *PRTLCREATEQUERYDEBUGBUFFER)(ULONG,BOOLEAN);
typedef NTSTATUS (NTAPI *PRTLDESTROYQUERYDEBUGBUFFER)(PRTL_DEBUG_INFORMATION);
typedef NTSTATUS (NTAPI *PNTQUERYSYSTEMINFORMATION)(SYSTEM_INFORMATION_CLASS,PVOID,ULONG,PULONG);
typedef ULONG (NTAPI *PRTLNTSTATUSTODOSERROR)(NTSTATUS);
//typedef NTSTATUS (NTAPI *PNTQUERYINFORMATIONPROCESS)(UINT_PTR,PROCESSINFOCLASS,UINT_PTR,ULONG,UINT_PTR);
typedef NTSTATUS (NTAPI *PNTQUERYINFORMATIONPROCESS)(HANDLE,PROCESSINFOCLASS,PVOID,ULONG,PULONG);

DWORD_PTR Win95GetProcessModules(HANDLE, PINTERNAL_GET_MODULE ,PVOID);
DWORD_PTR NTGetProcessModules(HANDLE, PINTERNAL_GET_MODULE ,PVOID);
DWORD64 miGetModuleBase(HANDLE hProcess, DWORD64 Address);

// private version of qsort used to avoid compat problems on NT4 and win2k.
// code is published from base\crts
extern
void __cdecl dbg_qsort(void *, size_t, size_t,
                       int (__cdecl *) (const void *, const void *));


typedef struct _SYMBOL_INFO_LOOKUP {
    ULONG       Segment;
    ULONG64     Offset;
    PCHAR       NamePtr;
    SYMBOL_INFO SymInfo;
} SYMBOL_INFO_LOOKUP;


BOOL
LoadSymbols(
    HANDLE        hp,
    PMODULE_ENTRY mi,
    DWORD         flags
    )
{
    if (flags & LS_JUST_TEST) {
        if ((mi->Flags & MIF_DEFERRED_LOAD) && !(mi->Flags & MIF_NO_SYMBOLS))
            return FALSE;
        else
            return TRUE;
    }

    if (flags & LS_QUALIFIED) {
        if (g.SymOptions & SYMOPT_NO_UNQUALIFIED_LOADS) {
            if ((mi->Flags & MIF_DEFERRED_LOAD) && !(mi->Flags & MIF_NO_SYMBOLS))
                return FALSE;
        }
    }

    if ((mi->Flags & MIF_DEFERRED_LOAD) && !(mi->Flags & MIF_NO_SYMBOLS))
        return load(hp, mi);
    else if (flags & LS_FAIL_IF_LOADED)
        return FALSE;

    return TRUE;
}


//
// Get the address form section no and offset in a PE file
//
ULONG
GetAddressFromOffset(
    PMODULE_ENTRY mi,
    ULONG         section,
    ULONG64       Offset,
    PULONG64      pAddress
    )
{
    ULONG Bias;
    if (section > mi->NumSections
        || !pAddress
        || !section
        || !mi
        )
    {
        // Invalid !!
        return FALSE;
    }

    *pAddress = mi->BaseOfDll + mi->OriginalSectionHdrs[section-1].VirtualAddress + Offset;
    *pAddress = ConvertOmapFromSrc( mi, *pAddress, &Bias );
    if (*pAddress) {
        *pAddress += Bias;
    }
    return TRUE;
}

/*
 * GetSymbolInfo
 *         This extracts useful information from a CV SYMBOl record into a generic
 *         SYMBOL_ENTRY structure.
 *
 *
 */
ULONG
GetSymbolInfo(
    PMODULE_ENTRY me,
    PCHAR         pRawSym,
    SYMBOL_INFO_LOOKUP  *pSymEntry
    )
{
    PCHAR SymbolInfo = pRawSym;
    ULONG symIndex, typeIndex=0, segmentNum=0;
    ULONG64 Offset=0, Address=0, Value=0;
//  ULONG Register=0, bpRel=0, BaseReg=0;
    BOOL HasAddr=FALSE, HasValue=FALSE;
    PSYMBOL_INFO pSymInfo = &pSymEntry->SymInfo;

    if ((pRawSym != NULL) && (pSymEntry != NULL)) {

        SymbolInfo = (PCHAR) pRawSym;
        typeIndex = 0;
        symIndex = ((SYMTYPE *) (pRawSym))->rectyp;
        ZeroMemory(pSymEntry, sizeof(SYMBOL_INFO));

        pSymInfo->ModBase = me->BaseOfDll;


#define ExtractSymName(from) (pSymEntry->NamePtr = ((PCHAR) from) + 1); pSymInfo->NameLen = (UCHAR) *((PUCHAR) from);
        switch (symIndex) {
        case S_COMPILE : // 0x0001   Compile flags symbol
        case S_REGISTER_16t : { // 0x0002   Register variable
            break;
        }
        case S_CONSTANT_16t : { // 0x0003   constant symbol
            DWORD len=4;
            CONSTSYM_16t *constSym;

            constSym = (CONSTSYM_16t *) SymbolInfo;
            typeIndex = constSym->typind;
//            GetNumericValue((PCHAR)&constSym->value, &Value, &len);

            pSymInfo->Flags |= IMAGEHLP_SYMBOL_INFO_VALUEPRESENT;
            pSymInfo->Value = Value;
            ExtractSymName((constSym->name + len));
            break;
        }
        case S_UDT_16t : { // 0x0004   User defined type
            UDTSYM_16t *udtSym;

            udtSym = (UDTSYM_16t *) SymbolInfo;
            typeIndex = udtSym->typind;
            ExtractSymName(udtSym->name); // strncpy(name, (PCHAR)symReturned + 7, (UCHAR) symReturned[6]);
            break;
        }
        case S_SSEARCH : // 0x0005   Start Search
        case S_END : // 0x0006   Block, procedure, "with" or thunk end
        case S_SKIP : // 0x0007   Reserve symbol space in $$Symbols table
        case S_CVRESERVE : // 0x0008   Reserved symbol for CV internal use
        case S_OBJNAME : // 0x0009   path to object file name
        case S_ENDARG : // 0x000a   end of argument/return list
        case S_COBOLUDT_16t : // 0x000b   special UDT for cobol that does not symbol pack
        case S_MANYREG_16t : // 0x000c   multiple register variable
        case S_RETURN : // 0x000d   return description symbol
        case S_ENTRYTHIS : // 0x000e   description of this pointer on entry
            break;

        case S_BPREL16 : // 0x0100   BP-relative
        case S_LDATA16 : // 0x0101   Module-local symbol
        case S_GDATA16 : // 0x0102   Global data symbol
        case S_PUB16 : // 0x0103   a public symbol
        case S_LPROC16 : // 0x0104   Local procedure start
        case S_GPROC16 : // 0x0105   Global procedure start
        case S_THUNK16 : // 0x0106   Thunk Start
        case S_BLOCK16 : // 0x0107   block start
        case S_WITH16 : // 0x0108   with start
        case S_LABEL16 : // 0x0109   code label
        case S_CEXMODEL16 : // 0x010a   change execution model
        case S_VFTABLE16 : // 0x010b   address of virtual function table
        case S_REGREL16 : // 0x010c   register relative address
        case S_BPREL32_16t : { // 0x0200   BP-relative
            break;
        }
        case S_LDATA32_16t :// 0x0201   Module-local symbol
        case S_GDATA32_16t :// 0x0202   Global data symbol
        case S_PUB32_16t : { // 0x0203   a public symbol (CV internal reserved)
            DATASYM32_16t *pData;

            pData = (DATASYM32_16t *) SymbolInfo;
            typeIndex = pData->typind;
            Offset = pData->off; segmentNum = pData->seg;
            HasAddr = TRUE;
            ExtractSymName(pData->name);
            // strncpy(name, (PCHAR)&pData->name[1], (UCHAR) pData->name[0]);
            break;
        }
        case S_LPROC32_16t : // 0x0204   Local procedure start
        case S_GPROC32_16t : { // 0x0205   Global procedure start
            PROCSYM32_16t *procSym;

            procSym = (PROCSYM32_16t *)SymbolInfo;
            // CONTEXT-SENSITIVE
            // Offset = procSym->off; segmentNum = procSym->seg;
            typeIndex = procSym->typind;
            ExtractSymName(procSym->name);
            // strncpy(name, (PCHAR)symReturned + 36, (UCHAR) symReturned[35]);
            break;
        }
        case S_THUNK32 : // 0x0206   Thunk Start
        case S_BLOCK32 : // 0x0207   block start
        case S_WITH32 : // 0x0208   with start
        case S_LABEL32 : // 0x0209   code label
        case S_CEXMODEL32 : // 0x020a   change execution model
        case S_VFTABLE32_16t : // 0x020b   address of virtual function table
        case S_REGREL32_16t : // 0x020c   register relative address
        case S_LTHREAD32_16t : // 0x020d   local thread storage
        case S_GTHREAD32_16t : // 0x020e   global thread storage
        case S_SLINK32 : // 0x020f   static link for MIPS EH implementation
        case S_LPROCMIPS_16t : // 0x0300   Local procedure start
        case S_GPROCMIPS_16t : { // 0x0301   Global procedure start
            break;
        }

        case S_PROCREF : { // 0x0400   Reference to a procedure
            // typeIndex = ((PDWORD) symReturned) + 3;
            // strncpy(name, symReturned + 13, (char) *(symReturned+12));
            break;
        }
        case S_DATAREF : // 0x0401   Reference to data
        case S_ALIGN : // 0x0402   Used for page alignment of symbols
        case S_LPROCREF : // 0x0403   Local Reference to a procedure

            // sym records with 32-bit types embedded instead of 16-bit
            // all have  0x1000 bit set for easy identification
            // only do the 32-bit target versions since we don't really
            // care about 16-bit ones anymore.
        case S_TI16_MAX : // 0x1000,
            break;

        case S_REGISTER : { // 0x1001   Register variable
            REGSYM *regSym;

            regSym             = (REGSYM *)SymbolInfo;
            typeIndex          = regSym->typind;
            pSymInfo->Flags    = IMAGEHLP_SYMBOL_INFO_REGISTER;
            LookupRegID((DWORD)regSym->reg, me->MachineType, &pSymInfo->Register);
            ExtractSymName(regSym->name);
            break;
        }

        case S_CONSTANT : { // 0x1002   constant symbol
            CONSTSYM *constSym;
            DWORD len=4, val;

            constSym = (CONSTSYM *) SymbolInfo;
//            GetNumericValue((PCHAR)&constSym->value, &Value, &len);

            pSymInfo->Flags |= IMAGEHLP_SYMBOL_INFO_VALUEPRESENT;
            pSymInfo->Value = Value;
            typeIndex = constSym->typind;
            ExtractSymName((constSym->name+len));
            break;
        }
        case S_UDT : { // 0x1003   User defined type
            UDTSYM *udtSym;

            udtSym = (UDTSYM *) SymbolInfo;
            typeIndex = udtSym->typind;
            ExtractSymName(udtSym->name);
            break;
        }

        case S_COBOLUDT : // 0x1004   special UDT for cobol that does not symbol pack
            break;

        case S_MANYREG : // 0x1005   multiple register variable
#if 0
typedef struct MANYREGSYM {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG
    CV_typ_t        typind;     // Type index
    unsigned char   count;      // count of number of registers
    unsigned char   reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM;

typedef struct MANYREGSYM2 {
    unsigned short  reclen;     // Record length
    unsigned short  rectyp;     // S_MANYREG2
    CV_typ_t        typind;     // Type index
    unsigned short  count;      // count of number of registers
    unsigned short  reg[1];     // count register enumerates followed by
                                // length-prefixed name.  Registers are
                                // most significant first.
} MANYREGSYM2;
#endif
            break;

        case S_BPREL32 : { // 0x1006   BP-relative
            BPRELSYM32 *bprelSym;

            bprelSym = (BPRELSYM32 *)SymbolInfo;
            typeIndex = bprelSym->typind;
            pSymInfo->Flags   = IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE;
            pSymInfo->Address = bprelSym->off;
            ExtractSymName(bprelSym->name);
            break;
        }

        case S_LDATA32 : // 0x1007   Module-local symbol
        case S_GDATA32 : // 0x1008   Global data symbol
        case S_PUB32 : { // 0x1009   a public symbol (CV internal reserved)
            DATASYM32 *dataSym;

            dataSym = (DATASYM32 *)SymbolInfo;
            HasAddr = TRUE;
            Offset = dataSym->off; segmentNum = dataSym->seg;
            typeIndex = dataSym->typind; //(PDWORD) symReturned;
            ExtractSymName(dataSym->name);  // strncpy(name, (PCHAR)symReturned+11, (UCHAR) symReturned[10]);

            break;
        }
        case S_LPROC32 :  // 0x100a   Local procedure start
        case S_GPROC32 : { // 0x100b   Global procedure start
            PROCSYM32 *procSym;

            procSym = (PROCSYM32 *) SymbolInfo;
            // CONTEXT-SENSITIVE
            HasAddr = TRUE;
            Offset = procSym->off; segmentNum = procSym->seg;
            typeIndex = procSym->typind;
            ExtractSymName(procSym->name);
            break;
        }

        case S_VFTABLE32 : // 0x100c   address of virtual function table
            break;

        case S_REGREL32 : { // 0x100d   register relative address
            REGREL32 *regrelSym;

            regrelSym = (REGREL32 *)SymbolInfo;
            typeIndex = regrelSym->typind;
            pSymInfo->Flags   = IMAGEHLP_SYMBOL_INFO_REGRELATIVE;
            pSymInfo->Address = regrelSym->off;
            LookupRegID((DWORD)regrelSym->reg, me->MachineType, &pSymInfo->Register);
            ExtractSymName(regrelSym->name);
            break;
        }

        case S_LTHREAD32 : // 0x100e   local thread storage
        case S_GTHREAD32 : // 0x100f   global thread storage
        case S_LPROCMIPS : // 0x1010   Local procedure start
        case S_GPROCMIPS : // 0x1011   Global procedure start
        case S_FRAMEPROC : // 0x1012   extra frame and proc information
        case S_COMPILE2 : // 0x1013   extended compile flags and info
        case S_MANYREG2 : // 0x1014   multiple register variable
        case S_LPROCIA64 : // 0x1015   Local procedure start (IA64)
        case S_GPROCIA64 : // 0x1016   Global procedure start (IA64)
        case S_RECTYPE_MAX :
        default:
            return FALSE;
        } /* switch */


        if (HasAddr && GetAddressFromOffset(me, segmentNum, Offset, &Address)) {
            pSymInfo->Address   = Address;
        }

        pSymInfo->TypeIndex = typeIndex;
        pSymEntry->Offset   = Offset;
        pSymEntry->Segment  = segmentNum;

    } else {
        return FALSE;
    }

    return TRUE;
}

/*
 * cvExtractSymbolInfo
 *         This extracts useful information from a CV SYMBOl record into a generic
 *         SYMBOL_ENTRY structure.
 *
 *
 */
ULONG
cvExtractSymbolInfo(
    PMODULE_ENTRY me,
    PCHAR         pRawSym,
    PSYMBOL_ENTRY pSymEntry,
    BOOL          fCopyName
    )
{
    SYMBOL_INFO_LOOKUP SymInfoLookup={0};
    ULONG reg;

    pSymEntry->Size       = 0;
    pSymEntry->Flags      = 0;
    pSymEntry->Address    = 0;
    if (fCopyName)
        *pSymEntry->Name  = 0;
    else
        pSymEntry->Name   = 0;
    pSymEntry->NameLength = 0;
    pSymEntry->Segment    = 0;
    pSymEntry->Offset     = 0;
    pSymEntry->TypeIndex  = 0;
    pSymEntry->ModBase    = 0;

    if (GetSymbolInfo(me, pRawSym, &SymInfoLookup)) {
        LARGE_INTEGER li;
        pSymEntry->NameLength = SymInfoLookup.SymInfo.NameLen;
        pSymEntry->TypeIndex  = SymInfoLookup.SymInfo.TypeIndex;
        pSymEntry->Offset  = SymInfoLookup.Offset;
        pSymEntry->Segment = SymInfoLookup.Segment;
        pSymEntry->ModBase = me->BaseOfDll;
        // NOTE: this was implented as a mask - but used differently
        switch (SymInfoLookup.SymInfo.Flags)
        {
        case IMAGEHLP_SYMBOL_INFO_REGISTER:
            pSymEntry->Flags = SYMF_REGISTER;
            pSymEntry->Address = SymInfoLookup.SymInfo.Register;
            break;

        case IMAGEHLP_SYMBOL_INFO_REGRELATIVE:
            // DBGHELP_HACK - HiPart of Addr = RegId , LowPart = Pffset
            pSymEntry->Flags = SYMF_REGREL;
            //LookupRegID((DWORD)SymInfoLookup.SymInfo.Register, me->MachineType, &pSymEntry->Segment);
            li.LowPart         = (ULONG) SymInfoLookup.SymInfo.Address;
            li.HighPart        = SymInfoLookup.SymInfo.Register;
            pSymEntry->Segment = SymInfoLookup.SymInfo.Register;
            pSymEntry->Address = li.QuadPart;
            break;

        case IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE:
            pSymEntry->Flags = SYMF_FRAMEREL;
            pSymEntry->Address = SymInfoLookup.SymInfo.Address;
            break;

        case IMAGEHLP_SYMBOL_INFO_VALUEPRESENT:
        default:
            pSymEntry->Address = SymInfoLookup.SymInfo.Address;
            break;
        }
        if (fCopyName) {
            if (!pSymEntry->Name)
                return FALSE;
            *pSymEntry->Name = 0;
            strncpy(pSymEntry->Name, SymInfoLookup.NamePtr ? SymInfoLookup.NamePtr : "", SymInfoLookup.SymInfo.NameLen);
        } else {
            pSymEntry->Name = SymInfoLookup.NamePtr;
        }
        return TRUE;
    }

    return FALSE;
}

DWORD_PTR
NTGetPID(
    HANDLE hProcess
    )
{
    HMODULE hModule;
    PNTQUERYINFORMATIONPROCESS NtQueryInformationProcess;
    PROCESS_BASIC_INFORMATION pi;
    NTSTATUS status;

    hModule = GetModuleHandle( "ntdll.dll" );
    if (!hModule) {
        return ERROR_MOD_NOT_FOUND;
    }

    NtQueryInformationProcess = (PNTQUERYINFORMATIONPROCESS)GetProcAddress(
        hModule,
        "NtQueryInformationProcess"
        );

    if (!NtQueryInformationProcess) {
        return ERROR_INVALID_FUNCTION;
    }


    status = NtQueryInformationProcess(hProcess,
                                       ProcessBasicInformation,
                                       &pi,
                                       sizeof(pi),
                                       NULL);

    if (!NT_SUCCESS(status))
        return 0;

    return pi.UniqueProcessId;
}


//
// the block bounded by the #ifdef _X86_ statement
// contains the code for getting the PID from an
// HPROCESS when running under Win9X
//

#ifdef _X86_

#define HANDLE_INVALID                 ((HANDLE)0xFFFFFFFF)
#define HANDLE_CURRENT_PROCESS   ((HANDLE)0x7FFFFFFF)
#define HANDLE_CURRENT_THREAD    ((HANDLE)0xFFFFFFFE)
#define MAX_HANDLE_VALUE         ((HANDLE)0x00FFFFFF)


// Thread Information Block.

typedef struct _TIB {

    DWORD     unknown[12];
    DWORD_PTR ppdb;

} TIB, *PTIB;

// Task Data Block

typedef struct _TDB {

    DWORD unknown[2];
    TIB         tib;

} TDB, *PTDB;

typedef struct _OBJ {

    BYTE    typObj;             // object type
    BYTE    objFlags;           // object flags
    WORD    cntUses;            // count of this objects usage

} OBJ, *POBJ;

typedef struct _HTE {

    DWORD   flFlags;
    POBJ    pobj;

} HTE, *PHTE;

typedef struct _HTB {

    DWORD   chteMax;
    HTE     rghte[1];

} HTB, *PHTB;

typedef struct _W9XPDB {

    DWORD  unknown[17];
    PHTB   phtbHandles;

} W9XPDB, *PW9XPDB;

#pragma warning(disable:4035)

_inline struct _TIB * GetCurrentTib(void) { _asm mov eax, fs:[0x18] }

// stuff needed to convert local handle

#define IHTETOHANDLESHIFT  2
#define GLOBALHANDLEMASK  (0x453a4d3cLU)

#define IHTEFROMHANDLE(hnd) ((hnd) == HANDLE_INVALID ? (DWORD)(hnd) : (((DWORD)(hnd)) >> IHTETOHANDLESHIFT))

#define IHTEISGLOBAL(ihte) \
        (((ihte) >> (32 - 8 - IHTETOHANDLESHIFT)) == (((DWORD)GLOBALHANDLEMASK) >> 24))

#define IS_WIN32_PREDEFINED_HANDLE(hnd) \
        ((hnd == HANDLE_CURRENT_PROCESS)||(hnd == HANDLE_CURRENT_THREAD)||(hnd == HANDLE_INVALID))

DWORD
GetWin9xObsfucator(
  VOID
  )
/*++

Routine Description:

  GetWin9xObsfucator()


Arguments:

  none


Return Value:

  Obsfucator key used by Windows9x to hide Process and Thread Id's


Notes:

  The code has only been tested on Windows98SE and Millennium.


--*/
{
    DWORD ppdb       = 0;      // W9XPDB = Process Data Block
    DWORD processId  = (DWORD) GetCurrentProcessId();

    // get PDB pointer

    ppdb = GetCurrentTib()->ppdb;

    return ppdb ^ processId;
}


DWORD_PTR
GetPtrFromHandle(
  IN HANDLE Handle
  )
/*++

Routine Description:

  GetPtrFromHandle()


Arguments:

  Handle - handle from Process handle table


Return Value:

  Real Pointer to object


Notes:

  The code has only been tested on Windows98SE and Millennium.


--*/
{
    DWORD_PTR ptr  = 0;
    DWORD     ihte = 0;
    PW9XPDB   ppdb = 0;

    ppdb = (PW9XPDB) GetCurrentTib()->ppdb;

    // check for pre-defined handle values.

    if (Handle == HANDLE_CURRENT_PROCESS) {
        ptr = (DWORD_PTR) ppdb;
    } else if (Handle == HANDLE_CURRENT_THREAD) {
        ptr = (DWORD_PTR) CONTAINING_RECORD(GetCurrentTib(), TDB, tib);
    } else if (Handle == HANDLE_INVALID) {
        ptr = 0;
    } else {
        // not a special handle, we can perform our magic.

        ihte = IHTEFROMHANDLE(Handle);

        // if we have a global handle, it is only meaningful in the context
        // of the kernel process's handle table...we don't currently deal with
        // this type of handle

        if (!(IHTEISGLOBAL(ihte))) {
            ptr = (DWORD_PTR) ppdb->phtbHandles->rghte[ihte].pobj;
        }
    }

    return ptr;
}


DWORD_PTR
Win9xGetPID(
  IN HANDLE hProcess
  )
/*++

Routine Description:

  Win9xGetPid()


Arguments:

  hProcess - Process handle


Return Value:

  Process Id


Notes:

  The code has only been tested on Windows98SE and Millennium.


--*/
{
    static DWORD dwObsfucator = 0;

    // check to see that we have a predefined handle or an index into
    // our local handle table.

    if (IS_WIN32_PREDEFINED_HANDLE(hProcess) || (hProcess < MAX_HANDLE_VALUE)) {
        if (!dwObsfucator) {
            dwObsfucator = GetWin9xObsfucator();
            assert(dwObsfucator != 0);
        }
        return dwObsfucator ^ GetPtrFromHandle(hProcess);
    }

    // don't know what we have here

    return 0;
}

#endif // _X86_


DWORD_PTR
GetPID(
    HANDLE hProcess
    )
{
    OSVERSIONINFO VerInfo;

    if (hProcess == GetCurrentProcess())
        return GetCurrentProcessId();

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        return NTGetPID(hProcess);
    } else {
#ifdef _X86_
        return Win9xGetPID(hProcess);
#else
        return 0;
#endif
    }
}


PMODULE_ENTRY
GetModFromAddr(
    PPROCESS_ENTRY    pe,
    IN  DWORD64       addr
    )
{
    PMODULE_ENTRY mi = NULL;

    __try {
        mi = GetModuleForPC(pe, addr, FALSE);
        if (!mi) {
            SetLastError(ERROR_MOD_NOT_FOUND);
            return NULL;
        }

        if (!LoadSymbols(pe->hProcess, mi, 0)) {
            SetLastError(ERROR_MOD_NOT_FOUND);
            return NULL;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return NULL;
    }

    return mi;
}


DWORD
GetProcessModules(
    HANDLE                  hProcess,
    PINTERNAL_GET_MODULE    InternalGetModule,
    PVOID                   Context
    )
{
#ifdef _X86_
    OSVERSIONINFO VerInfo;

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        return NTGetProcessModules(hProcess, InternalGetModule, Context);
    } else {
        return Win95GetProcessModules(hProcess, InternalGetModule, Context);
    }
}


DWORD
Win95GetProcessModules(
    HANDLE                  hProcess,
    PINTERNAL_GET_MODULE    InternalGetModule,
    PVOID                   Context
    )
{
    MODULEENTRY32 mi;
    PMODULE32     pModule32Next, pModule32First;
    PCREATE32SNAPSHOT pCreateToolhelp32Snapshot;
    HANDLE hSnapshot;
    HMODULE hToolHelp;
    DWORD pid;

    // get the PID:
    // this hack supports old bug workaround, in which callers were passing
    // a pid, because an hprocess didn't work on W9X.

    pid = GetPID(hProcess);
    if (!pid)
        pid = (DWORD)hProcess;

    // get the module list from toolhelp apis

    hToolHelp = GetModuleHandle("kernel32.dll");
    if (!hToolHelp)
        return ERROR_MOD_NOT_FOUND;

    pModule32Next = (PMODULE32)GetProcAddress(hToolHelp, "Module32Next");
    pModule32First = (PMODULE32)GetProcAddress(hToolHelp, "Module32First");
    pCreateToolhelp32Snapshot = (PCREATE32SNAPSHOT)GetProcAddress(hToolHelp, "CreateToolhelp32Snapshot");
    if (!pModule32Next || !pModule32First || !pCreateToolhelp32Snapshot)
        return ERROR_MOD_NOT_FOUND;

    hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
    if (hSnapshot == (HANDLE)-1) {
        return ERROR_MOD_NOT_FOUND;
    }

    mi.dwSize = sizeof(MODULEENTRY32);

    if (pModule32First(hSnapshot, &mi)) {
        do
        {
            if (!InternalGetModule(
                    hProcess,
                    mi.szModule,
                    (DWORD) mi.modBaseAddr,
                    mi.modBaseSize,
                    Context))
            {
                break;
            }

        } while ( pModule32Next(hSnapshot, &mi) );
    }

    CloseHandle(hSnapshot);

    return(ERROR_SUCCESS);
}


DWORD
NTGetProcessModules(
    HANDLE                  hProcess,
    PINTERNAL_GET_MODULE    InternalGetModule,
    PVOID                   Context
    )
{

#endif      // _X86_

    PRTLQUERYPROCESSDEBUGINFORMATION    RtlQueryProcessDebugInformation;
    PRTLCREATEQUERYDEBUGBUFFER          RtlCreateQueryDebugBuffer;
    PRTLDESTROYQUERYDEBUGBUFFER         RtlDestroyQueryDebugBuffer;
    HMODULE                             hModule;
    NTSTATUS                            Status;
    PRTL_DEBUG_INFORMATION              Buffer;
    ULONG                               i;
    DWORD_PTR                           ProcessId;

    hModule = GetModuleHandle( "ntdll.dll" );
    if (!hModule) {
        return ERROR_MOD_NOT_FOUND;
    }

    RtlQueryProcessDebugInformation = (PRTLQUERYPROCESSDEBUGINFORMATION)GetProcAddress(
        hModule,
        "RtlQueryProcessDebugInformation"
        );

    if (!RtlQueryProcessDebugInformation) {
        return ERROR_INVALID_FUNCTION;
    }

    RtlCreateQueryDebugBuffer = (PRTLCREATEQUERYDEBUGBUFFER)GetProcAddress(
        hModule,
        "RtlCreateQueryDebugBuffer"
        );

    if (!RtlCreateQueryDebugBuffer) {
        return ERROR_INVALID_FUNCTION;
    }

    RtlDestroyQueryDebugBuffer = (PRTLDESTROYQUERYDEBUGBUFFER)GetProcAddress(
        hModule,
        "RtlDestroyQueryDebugBuffer"
        );

    if (!RtlDestroyQueryDebugBuffer) {
        return ERROR_INVALID_FUNCTION;
    }

    Buffer = RtlCreateQueryDebugBuffer( 0, FALSE );
    if (!Buffer) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ProcessId = GetPID(hProcess);

    // for backwards compatibility with an old bug
    if (!ProcessId)
        ProcessId = (DWORD_PTR)hProcess;

    ULONG QueryFlags = RTL_QUERY_PROCESS_MODULES |
                       RTL_QUERY_PROCESS_NONINVASIVE;
                       
    if (g.SymOptions & SYMOPT_INCLUDE_32BIT_MODULES) {
        QueryFlags |= RTL_QUERY_PROCESS_MODULES32;
    }

    Status = RtlQueryProcessDebugInformation(
        (HANDLE)ProcessId,
        QueryFlags,
        Buffer
        );

    if (Status != STATUS_SUCCESS) {
        RtlDestroyQueryDebugBuffer( Buffer );
        return(ImagepSetLastErrorFromStatus(Status));
    }

    for (i=0; i<Buffer->Modules->NumberOfModules; i++) {
        PRTL_PROCESS_MODULE_INFORMATION Module = &Buffer->Modules->Modules[i];
        if (!InternalGetModule(
                hProcess,
                (LPSTR) &Module->FullPathName[Module->OffsetToFileName],
                (DWORD64)Module->ImageBase,
                (DWORD)Module->ImageSize,
                Context
                ))
        {
            break;
        }
    }

    RtlDestroyQueryDebugBuffer( Buffer );
    return ERROR_SUCCESS;
}


VOID
FreeModuleEntry(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi
    )
{
    FunctionEntryCache* Cache;

    if (pe && (Cache = GetFeCache(mi->MachineType, FALSE))) {
        Cache->InvalidateProcessOrModule(pe->hProcess, mi->BaseOfDll);
    }
    if (pe && pe->ipmi == mi) {
        pe->ipmi = NULL;
    }
    if (mi->symbolTable) {
        MemFree( mi->symbolTable  );
    }
    if (mi->SectionHdrs) {
        MemFree( mi->SectionHdrs );
    }
    if (mi->OriginalSectionHdrs) {
        MemFree( mi->OriginalSectionHdrs );
    }
    if (mi->pFpoData) {
        VirtualFree( mi->pFpoData, 0, MEM_RELEASE );
    }
    if (mi->pFpoDataOmap) {
        VirtualFree( mi->pFpoDataOmap, 0, MEM_RELEASE );
    }
    if (mi->pExceptionData) {
        VirtualFree( mi->pExceptionData, 0, MEM_RELEASE );
    }
    if (mi->pPData) {
        MemFree( mi->pPData );
    }
    if (mi->pXData) {
        MemFree( mi->pXData );
    }
    if (mi->TmpSym.Name) {
        MemFree( mi->TmpSym.Name );
    }
    if (mi->ImageName) {
        MemFree( mi->ImageName );
    }
    if (mi->LoadedImageName) {
        MemFree( mi->LoadedImageName );
    }
    if (mi->LoadedPdbName) {
        MemFree( mi->LoadedPdbName );
    }
    if (mi->pOmapTo) {
        MemFree( mi->pOmapTo );
    }
    if (mi->pOmapFrom) {
        MemFree( mi->pOmapFrom );
    }
    if (mi->CallerData) {
        MemFree( mi->CallerData );
    }
    if (mi->SourceFiles) {
        PSOURCE_ENTRY Src, SrcNext;

        for (Src = mi->SourceFiles; Src != NULL; Src = SrcNext) {
            SrcNext = Src->Next;
            MemFree(Src);
        }
    }
    if (mi->dia) {
        diaRelease(mi->dia);
    }

    MemFree( mi );
}




BOOL
MatchSymbolName(
    PSYMBOL_ENTRY       sym,
    LPSTR               SymName
    )
{
    if (g.SymOptions & SYMOPT_CASE_INSENSITIVE) {
        if (_stricmp( sym->Name, SymName ) == 0) {
            return TRUE;
        }
    } else {
        if (strcmp( sym->Name, SymName ) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}


PSYMBOL_ENTRY
HandleDuplicateSymbols(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    PSYMBOL_ENTRY   sym
    )
{
    DWORD                       i;
    DWORD                       Dups;
    DWORD                       NameSize;
    PIMAGEHLP_SYMBOL64          Syms64 = NULL;
    PIMAGEHLP_SYMBOL          Syms32 = NULL;
    PIMAGEHLP_DUPLICATE_SYMBOL64 DupSym64 = NULL;
    PIMAGEHLP_DUPLICATE_SYMBOL DupSym32 = NULL;
    PULONG                      SymSave;


    if (!pe->pCallbackFunction32 && !pe->pCallbackFunction64) {
        return sym;
    }

    if (!(sym->Flags & SYMF_DUPLICATE)) {
        return sym;
    }

    Dups = 0;
    NameSize = 0;
    for (i = 0; i < mi->numsyms; i++) {
        if ((mi->symbolTable[i].NameLength == sym->NameLength) &&
            (strcmp( mi->symbolTable[i].Name, sym->Name ) == 0)) {
                Dups += 1;
                NameSize += (mi->symbolTable[i].NameLength + 1);
        }
    }

    if (pe->pCallbackFunction32) {
        DupSym32 = (PIMAGEHLP_DUPLICATE_SYMBOL) MemAlloc( sizeof(IMAGEHLP_DUPLICATE_SYMBOL) );
        if (!DupSym32) {
            return sym;
        }

        Syms32 = (PIMAGEHLP_SYMBOL) MemAlloc( (sizeof(IMAGEHLP_SYMBOL) * Dups) + NameSize );
        if (!Syms32) {
            MemFree( DupSym32 );
            return sym;
        }

        SymSave = (PULONG) MemAlloc( sizeof(ULONG) * Dups );
        if (!SymSave) {
            MemFree( Syms32 );
            MemFree( DupSym32 );
            return sym;
        }

        DupSym32->SizeOfStruct    = sizeof(IMAGEHLP_DUPLICATE_SYMBOL);
        DupSym32->NumberOfDups    = Dups;
        DupSym32->Symbol          = Syms32;
        DupSym32->SelectedSymbol  = (ULONG) -1;

        Dups = 0;
        for (i = 0; i < mi->numsyms; i++) {
            if ((mi->symbolTable[i].NameLength == sym->NameLength) &&
                (strcmp( mi->symbolTable[i].Name, sym->Name ) == 0)) {
                    symcpy32( Syms32, &mi->symbolTable[i] );
                    Syms32 += (sizeof(IMAGEHLP_SYMBOL) + mi->symbolTable[i].NameLength + 1);
                    SymSave[Dups] = i;
                    Dups += 1;
            }
        }

    } else {
        DupSym64 = (PIMAGEHLP_DUPLICATE_SYMBOL64) MemAlloc( sizeof(IMAGEHLP_DUPLICATE_SYMBOL64) );
        if (!DupSym64) {
            return sym;
        }

        Syms64 = (PIMAGEHLP_SYMBOL64) MemAlloc( (sizeof(IMAGEHLP_SYMBOL64) * Dups) + NameSize );
        if (!Syms64) {
            MemFree( DupSym64 );
            return sym;
        }

        SymSave = (PULONG) MemAlloc( sizeof(ULONG) * Dups );
        if (!SymSave) {
            MemFree( Syms64 );
            MemFree( DupSym64 );
            return sym;
        }

        DupSym64->SizeOfStruct    = sizeof(IMAGEHLP_DUPLICATE_SYMBOL64);
        DupSym64->NumberOfDups    = Dups;
        DupSym64->Symbol          = Syms64;
        DupSym64->SelectedSymbol  = (ULONG) -1;

        Dups = 0;
        for (i = 0; i < mi->numsyms; i++) {
            if ((mi->symbolTable[i].NameLength == sym->NameLength) &&
                (strcmp( mi->symbolTable[i].Name, sym->Name ) == 0)) {
                    symcpy64( Syms64, &mi->symbolTable[i] );
                    Syms64 += (sizeof(IMAGEHLP_SYMBOL64) + mi->symbolTable[i].NameLength + 1);
                    SymSave[Dups] = i;
                    Dups += 1;
            }
        }

    }

    sym = NULL;

    __try {

        if (pe->pCallbackFunction32) {
            pe->pCallbackFunction32(
                pe->hProcess,
                CBA_DUPLICATE_SYMBOL,
                (PVOID) DupSym32,
                (PVOID) pe->CallbackUserContext
                );

            if (DupSym32->SelectedSymbol != (ULONG) -1) {
                if (DupSym32->SelectedSymbol < DupSym32->NumberOfDups) {
                    sym = &mi->symbolTable[SymSave[DupSym32->SelectedSymbol]];
                }
            }
        } else {
            pe->pCallbackFunction64(
                pe->hProcess,
                CBA_DUPLICATE_SYMBOL,
                (ULONG64) &DupSym64,
                pe->CallbackUserContext
                );

            if (DupSym64->SelectedSymbol != (ULONG) -1) {
                if (DupSym64->SelectedSymbol < DupSym64->NumberOfDups) {
                    sym = &mi->symbolTable[SymSave[DupSym64->SelectedSymbol]];
                }
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    if (DupSym32) {
        MemFree( DupSym32 );
    }
    if (DupSym64) {
        MemFree( DupSym64 );
    }
    if (Syms32) {
        MemFree( Syms32 );
    }
    if (Syms64) {
        MemFree( Syms64 );
    }
    MemFree( SymSave );

    return sym;
}


PSYMBOL_ENTRY
FindSymbolByName(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    )
{
    DWORD               hash;
    PSYMBOL_ENTRY       sym;
    DWORD               i;

    if (!mi || mi->dia)
        return diaFindSymbolByName(pe, mi, SymName);

    hash = ComputeHash( SymName, strlen(SymName) );
    sym = mi->NameHashTable[hash];

    if (sym) {
        //
        // there are collision(s) so lets walk the
        // collision list and match the names
        //
        while( sym ) {
            if (MatchSymbolName( sym, SymName )) {
                sym = HandleDuplicateSymbols( pe, mi, sym );
                return sym;
            }
            sym = sym->Next;
        }
    }

    //
    // the symbol did not hash to anything valid
    // this is possible if the caller passed an undecorated name
    // now we must look linearly thru the list
    //
    for (i=0; i<mi->numsyms; i++) {
        sym = &mi->symbolTable[i];
        if (MatchSymbolName( sym, SymName )) {
            sym = HandleDuplicateSymbols( pe, mi, sym );
            return sym;
        }
    }

    return NULL;
}


IMGHLP_RVA_FUNCTION_DATA *
SearchRvaFunctionTable(
    IMGHLP_RVA_FUNCTION_DATA *FunctionTable,
    LONG High,
    LONG Low,
    DWORD dwPC
    )
{
    LONG    Middle;
    IMGHLP_RVA_FUNCTION_DATA *FunctionEntry;

    // Perform binary search on the function table for a function table
    // entry that subsumes the specified PC.

    while (High >= Low) {

        // Compute next probe index and test entry. If the specified PC
        // is greater than of equal to the beginning address and less
        // than the ending address of the function table entry, then
        // return the address of the function table entry. Otherwise,
        // continue the search.

        Middle = (Low + High) >> 1;
        FunctionEntry = &FunctionTable[Middle];
        if (dwPC < FunctionEntry->rvaBeginAddress) {
            High = Middle - 1;

        } else if (dwPC >= FunctionEntry->rvaEndAddress) {
            Low = Middle + 1;

        } else {
            return FunctionEntry;
        }
    }
    return NULL;
}

PIMGHLP_RVA_FUNCTION_DATA
GetFunctionEntryFromDebugInfo (
    PPROCESS_ENTRY  pe,
    DWORD64         ControlPc
    )
{
    PMODULE_ENTRY mi;
    IMGHLP_RVA_FUNCTION_DATA   *FunctionTable;

    mi = GetModuleForPC( pe, ControlPc, FALSE );
    if (mi == NULL) {
        return NULL;
    }

    if (!GetPData(pe->hProcess, mi)) {
        return NULL;
    }

    FunctionTable = (IMGHLP_RVA_FUNCTION_DATA *)mi->pExceptionData;
    return SearchRvaFunctionTable(FunctionTable, mi->dwEntries - 1, 0,
                                  (ULONG)(ControlPc - mi->BaseOfDll));
}

PIMAGE_FUNCTION_ENTRY
LookupFunctionEntryAxp32 (
    HANDLE        hProcess,
    DWORD         ControlPc
    )
{
    FunctionEntryCache* Cache;
    FeCacheEntry* FunctionEntry;

    if ((Cache = GetFeCache(IMAGE_FILE_MACHINE_ALPHA, TRUE)) == NULL) {
        return NULL;
    }

    // Don't specify the function table access callback or it will
    // cause recursion.

    FunctionEntry = Cache->
        Find(hProcess, (ULONG64)(LONG)ControlPc, ReadInProcMemory,
             miGetModuleBase, NULL);
    if ( FunctionEntry == NULL ) {
        return NULL;
    }

    // Alpha function entries are always stored as 64-bit
    // so downconvert.
    tlsvar(FunctionEntry32).StartingAddress =
        (ULONG)FunctionEntry->Data.Axp64.BeginAddress;
    tlsvar(FunctionEntry32).EndingAddress =
        (ULONG)FunctionEntry->Data.Axp64.EndAddress;
    tlsvar(FunctionEntry32).EndOfPrologue =
        (ULONG)FunctionEntry->Data.Axp64.PrologEndAddress;
    return &tlsvar(FunctionEntry32);
}

PIMAGE_FUNCTION_ENTRY64
LookupFunctionEntryAxp64 (
    HANDLE        hProcess,
    DWORD64       ControlPc
    )
{
    FunctionEntryCache* Cache;
    FeCacheEntry* FunctionEntry;

    if ((Cache = GetFeCache(IMAGE_FILE_MACHINE_ALPHA64, TRUE)) == NULL) {
        return NULL;
    }

    // Don't specify the function table access callback or it will
    // cause recursion.

    FunctionEntry = Cache->
        Find(hProcess, ControlPc, ReadInProcMemory,
             miGetModuleBase, NULL);
    if ( FunctionEntry == NULL ) {
        return NULL;
    }

    tlsvar(FunctionEntry64).StartingAddress =
        FunctionEntry->Data.Axp64.BeginAddress;
    tlsvar(FunctionEntry64).EndingAddress =
        FunctionEntry->Data.Axp64.EndAddress;
    tlsvar(FunctionEntry64).EndOfPrologue =
        FunctionEntry->Data.Axp64.PrologEndAddress;
    return &tlsvar(FunctionEntry64);
}

// NTRAID#96939-2000/03/27-patst
//
// All the platform dependent "LookupFunctionEntryXxx" should be retyped as returning
// a PIMAGE_FUNCTION_ENTRY64. This would require a modification of the callers, especially
// the IA64 specific locations that assume that the returned function entries contains RVAs
// and not absolute addresses. I implemented a platform-independant
// "per address space /  per module" cache of function entries - capable of supporting the
// dynamic function entries scheme but I fell short of time in delivering it.

PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntryIa64 (
    HANDLE        hProcess,
    DWORD64       ControlPc
    )
{
    FunctionEntryCache* Cache;
    FeCacheEntry* FunctionEntry;

    if ((Cache = GetFeCache(IMAGE_FILE_MACHINE_IA64, TRUE)) == NULL) {
        return NULL;
    }

//
// IA64-NOTE 08/99: IA64 Function entries contain file offsets, not absolute relocated addresses.
//                  IA64 Callers assume this.
//


    // Don't specify the function table access callback or it will
    // cause recursion.

    FunctionEntry = Cache->
        Find(hProcess, ControlPc, ReadInProcMemory,
             miGetModuleBase, NULL);
    if ( FunctionEntry == NULL ) {
        return NULL;
    }

    tlsvar(Ia64FunctionEntry) = FunctionEntry->Data.Ia64;
    return &tlsvar(Ia64FunctionEntry);
}

_PIMAGE_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntryAmd64 (
    HANDLE        hProcess,
    DWORD64       ControlPc
    )
{
    FunctionEntryCache* Cache;
    FeCacheEntry* FunctionEntry;

    if ((Cache = GetFeCache(IMAGE_FILE_MACHINE_AMD64, TRUE)) == NULL) {
        return NULL;
    }

    // Don't specify the function table access callback or it will
    // cause recursion.

    FunctionEntry = Cache->
        Find(hProcess, ControlPc, ReadInProcMemory,
             miGetModuleBase, NULL);
    if ( FunctionEntry == NULL ) {
        return NULL;
    }

    tlsvar(Amd64FunctionEntry) = FunctionEntry->Data.Amd64;
    return &tlsvar(Amd64FunctionEntry);
}

PFPO_DATA
SwSearchFpoData(
    DWORD     key,
    PFPO_DATA base,
    DWORD     num
    )
{
    PFPO_DATA  lo = base;
    PFPO_DATA  hi = base + (num - 1);
    PFPO_DATA  mid;
    DWORD      half;

    while (lo <= hi) {
        if (half = num / 2) {
            mid = lo + ((num & 1) ? half : (half - 1));
            if ((key >= mid->ulOffStart)&&(key < (mid->ulOffStart+mid->cbProcSize))) {
                return mid;
            }
            if (key < mid->ulOffStart) {
                hi = mid - 1;
                num = (num & 1) ? half : half-1;
            } else {
                lo = mid + 1;
                num = half;
            }
        } else
        if (num) {
            if ((key >= lo->ulOffStart)&&(key < (lo->ulOffStart+lo->cbProcSize))) {
                return lo;
            } else {
                break;
            }
        } else {
            break;
        }
    }
    return(NULL);
}

BOOL
DoSymbolCallback (
    PPROCESS_ENTRY                  pe,
    ULONG                           CallbackType,
    IN  PMODULE_ENTRY               mi,
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl64,
    LPSTR                           FileName
    )
{
    BOOL Status;
    IMAGEHLP_DEFERRED_SYMBOL_LOAD idsl32;

    Status = FALSE;
    if (pe->pCallbackFunction32) {
        idsl32.SizeOfStruct  = sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD);
        idsl32.BaseOfImage   = (ULONG)mi->BaseOfDll;
        idsl32.CheckSum      = mi->CheckSum;
        idsl32.TimeDateStamp = mi->TimeDateStamp;
        idsl32.Reparse       = FALSE;
        idsl32.FileName[0] = 0;
        if (FileName) {
            strncat( idsl32.FileName, FileName, MAX_PATH - 1 );
        }

        __try {

            Status = pe->pCallbackFunction32(
                        pe->hProcess,
                        CallbackType,
                        (PVOID)&idsl32,
                        (PVOID)pe->CallbackUserContext
                        );
            idsl64->SizeOfStruct = sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64);
            idsl64->BaseOfImage = idsl32.BaseOfImage;
            idsl64->CheckSum = idsl32.CheckSum;
            idsl64->TimeDateStamp = idsl32.TimeDateStamp;
            idsl64->Reparse = idsl32.Reparse;
            if (idsl32.FileName) {
                strncpy( idsl64->FileName, idsl32.FileName, MAX_PATH );
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
        }
    } else
    if (pe->pCallbackFunction64) {
        idsl64->SizeOfStruct  = sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64);
        idsl64->BaseOfImage   = mi->BaseOfDll;
        idsl64->CheckSum      = mi->CheckSum;
        idsl64->TimeDateStamp = mi->TimeDateStamp;
        idsl64->Reparse       = FALSE;
        idsl64->FileName[0] = 0;
        if (FileName) {
            strncat( idsl64->FileName, FileName, MAX_PATH );
        }

        __try {

            Status = pe->pCallbackFunction64(
                        pe->hProcess,
                        CallbackType,
                        (ULONG64)(ULONG_PTR)idsl64,
                        pe->CallbackUserContext
                        );

        } __except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return Status;
}


BOOL
DoCallback(
    PPROCESS_ENTRY pe,
    ULONG          type,
    PVOID          data
    )
{
    BOOL rc = TRUE;

    __try {

        // if we weren't passed a process entry, then call all processes

        if (!pe) {
            BOOL        ret;
            PLIST_ENTRY next;

            next = g.ProcessList.Flink;
            if (!next)
                return FALSE;

            while ((PVOID)next != (PVOID)&g.ProcessList) {
                pe = CONTAINING_RECORD( next, PROCESS_ENTRY, ListEntry );
                next = pe->ListEntry.Flink;
                if (!pe)
                    return rc;
                ret = DoCallback(pe, type, data);
                if (!ret)
                    rc = ret;
            }

            return rc;
        }

        // otherwise call this process

        if (pe->pCallbackFunction32) {
            rc = pe->pCallbackFunction32(pe->hProcess,
                                         type,
                                         data,
                                         (PVOID)pe->CallbackUserContext);
        } else if (pe->pCallbackFunction64) {
            rc = pe->pCallbackFunction64(pe->hProcess,
                                         type,
                                         (ULONG64)data,
                                         pe->CallbackUserContext);
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = FALSE;
    }

    return rc;
}


VOID
SympSendDebugString(
    PPROCESS_ENTRY pe,
    LPSTR          String
    )
{
    __try {
        if (!pe)
            pe = FindFirstProcessEntry();

        if (!pe) {
            printf(String);
        } else if (pe->pCallbackFunction32) {
            pe->pCallbackFunction32(pe->hProcess,
                                              CBA_DEBUG_INFO,
                                              (PVOID)String,
                                              (PVOID)pe->CallbackUserContext
                                              );
        } else if (pe->pCallbackFunction64) {
            pe->pCallbackFunction64(pe->hProcess,
                                              CBA_DEBUG_INFO,
                                              (ULONG64)String,
                                              pe->CallbackUserContext
                                              );
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }
}

int
WINAPIV
_pprint(
    PPROCESS_ENTRY pe,
    LPSTR Format,
    ...
    )
{
    static char buf[1000] = "DBGHELP: ";
    va_list args;

    va_start(args, Format);
    _vsnprintf(buf+9, sizeof(buf)-9, Format, args);
    va_end(args);
    SympSendDebugString(pe, buf);
    return 1;
}

int
WINAPIV
_peprint(
    PPROCESS_ENTRY pe,
    LPSTR Format,
    ...
    )
{
    static char buf[1000] = "";
    va_list args;

    va_start(args, Format);
    _vsnprintf(buf, sizeof(buf), Format, args);
    va_end(args);
    SympSendDebugString(pe, buf);
    return 1;
}


int
WINAPIV
_dprint(
    LPSTR format,
    ...
    )
{
    static char buf[1000] = "DBGHELP: ";
    va_list args;

    va_start(args, format);
    _vsnprintf(buf+9, sizeof(buf)-9, format, args);
    va_end(args);
    SympSendDebugString(NULL, buf);
    return 1;
}

int
WINAPIV
_eprint(
    LPSTR format,
    ...
    )
{
    static char buf[1000] = "";
    va_list args;

    va_start(args, format);
    _vsnprintf(buf, sizeof(buf), format, args);
    va_end(args);
    SympSendDebugString(NULL, buf);
    return 1;
}


BOOL
WINAPIV
evtprint(
    PPROCESS_ENTRY pe,
    DWORD          severity,
    DWORD          code,
    PVOID          object,
    LPSTR          format,
    ...
    )
{
    static char buf[1000] = "";
    IMAGEHLP_CBA_EVENT evt;
    va_list args;

    va_start(args, format);
    _vsnprintf(buf, sizeof(buf), format, args);
    va_end(args);
    evt.severity = severity;
    evt.code = code;
    evt.desc = buf;
    evt.object = object;

    return DoCallback(pe, CBA_EVENT, &evt);
}

BOOL
traceAddr(
    DWORD64 addr
    )
{
    DWORD64 taddr = 0;

    if (!*g.DebugToken)
        return FALSE;
    sscanf(g.DebugToken, "0x%I64x", &taddr);
    taddr = EXTEND64(taddr);
    addr = EXTEND64(addr);
    return (addr == taddr);
}


BOOL
traceName(
    PCHAR name
    )
{
    if (!*g.DebugToken)
        return FALSE;
    return !_strnicmp(name, g.DebugToken, strlen(g.DebugToken));
}


BOOL
traceSubName(
    PCHAR name
    )
{
    char *lname;
    BOOL  rc;

    if (!*g.DebugToken)
        return FALSE;
    lname = (char *)MemAlloc(sizeof(char) * (strlen(name) + 1));
    if (!lname) {
        return FALSE;
    }
    strcpy(lname, name);
    if (!lname)
        return FALSE;
    _strlwr(lname);
    rc = strstr(lname, g.DebugToken) ? TRUE : FALSE;
    MemFree(lname);

    return rc;
}


BOOL
load(
    IN  HANDLE          hProcess,
    IN  PMODULE_ENTRY   mi
    )
{
    IMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;
    PPROCESS_ENTRY              pe;
    ULONG                       i;
    PIMGHLP_DEBUG_DATA          pIDD;
    ULONG                       bias;
    PIMAGE_SYMBOL               lpSymbolEntry;
    PUCHAR                      lpStringTable;
    PUCHAR                      p;
    BOOL                        SymbolsLoaded = FALSE;
    PCHAR                       CallbackFileName, ImageName;
    ULONG                       Size;

    g.LastSymLoadError = SYMLOAD_DEFERRED;
    pe = FindProcessEntry( hProcess );
    if (!pe) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

//  if (traceName(mi->ModuleName)) // for setting debug breakpoints from DBGHELP_TOKEN
//      pprint(pe, "debug(%s)\n", mi->ModuleName);

    CallbackFileName   = mi->LoadedImageName ? mi->LoadedImageName :
                                mi->ImageName ? mi->ImageName : mi->ModuleName;

    DoSymbolCallback(
        pe,
        CBA_DEFERRED_SYMBOL_LOAD_START,
        mi,
        &idsl,
        CallbackFileName
        );

    ImageName = mi->ImageName;
    for (; ;) {
        pIDD = GetDebugData(
            hProcess,
            mi->hFile,
            ImageName,
            pe->SymbolSearchPath,
            mi->BaseOfDll,
            &mi->mld,
            0
            );
        mi->SymLoadError = g.LastSymLoadError;

        if (pIDD) {
            break;
        }

        pprint(pe, "GetDebugData(%p, %s, %s, %I64x, 0) failed\n",
            mi->hFile,
            ImageName,
            pe->SymbolSearchPath,
            mi->BaseOfDll
            );

        if (!DoSymbolCallback(
                 pe,
                 CBA_DEFERRED_SYMBOL_LOAD_FAILURE,
                 mi,
                 &idsl,
                 CallbackFileName
                 ) || !idsl.Reparse)
        {
            mi->SymType = SymNone;
            mi->Flags |= MIF_NO_SYMBOLS;
            return FALSE;
        }

        ImageName = idsl.FileName;
        CallbackFileName = idsl.FileName;
    }

    pIDD->flags = mi->Flags;

    // The following code ONLY works if the dll wasn't rebased
    // during install.  Is it really useful?

    if (!mi->BaseOfDll) {
        //
        // This case occurs when modules are loaded multiple times by
        // name with no explicit base address.
        //
        if (GetModuleForPC( pe, pIDD->ImageBaseFromImage, TRUE )) {
            if (pIDD->ImageBaseFromImage) {
                pprint(pe, "GetModuleForPC(%p, %I64x, TRUE) failed\n",
                    pe,
                    pIDD->ImageBaseFromImage,
                    TRUE
                    );
            } else {
                pprint(pe, "No base address for %s:  Please specify\n", ImageName);
            }
            return FALSE;
        }
        mi->BaseOfDll    = pIDD->ImageBaseFromImage;
    }

    if (!mi->DllSize) {
        mi->DllSize      = pIDD->SizeOfImage;
    }

    mi->hProcess         = pIDD->hProcess;
    mi->InProcImageBase  = pIDD->InProcImageBase;

    mi->CheckSum         = pIDD->CheckSum;
    mi->TimeDateStamp    = pIDD->TimeDateStamp;
    mi->MachineType      = pIDD->Machine;

    mi->ImageType        = pIDD->ImageType;
    mi->PdbSrc           = pIDD->PdbSrc;
    mi->ImageSrc         = pIDD->ImageSrc;

    if (!mi->MachineType && g.MachineType) {
        mi->MachineType = (USHORT) g.MachineType;
    }
    if (pIDD->dia) {
        mi->LoadedPdbName = StringDup(pIDD->PdbFileName);
    }
    if (pIDD->DbgFileMap) {
        mi->LoadedImageName = StringDup(pIDD->DbgFilePath);
    } else if (*pIDD->ImageFilePath) {
        mi->LoadedImageName = StringDup(pIDD->ImageFilePath);
    } else if (pIDD->dia) {
        mi->LoadedImageName = StringDup(pIDD->PdbFileName);
    } else {
        mi->LoadedImageName = StringDup("");
    }

    if (pIDD->fROM) {
        mi->Flags |= MIF_ROM_IMAGE;
    }

    if (!mi->ImageName) {
        mi->ImageName = StringDup(pIDD->OriginalImageFileName);
        _splitpath( mi->ImageName, NULL, NULL, mi->ModuleName, NULL );
        mi->AliasName[0] = 0;
    }

    mi->dsExceptions = pIDD->dsExceptions;

    if (pIDD->cFpo) {
        //
        // use virtualalloc() because the rtf search function
        // return a pointer into this memory.  we want to make
        // all of this memory read only so that callers cannot
        // stomp on imagehlp's data
        //
        mi->pFpoData = (PFPO_DATA)VirtualAlloc(
            NULL,
            sizeof(FPO_DATA) * pIDD->cFpo,
            MEM_COMMIT,
            PAGE_READWRITE
            );
        if (mi->pFpoData) {
            mi->dwEntries = pIDD->cFpo;
            CopyMemory(
                mi->pFpoData,
                pIDD->pFpo,
                sizeof(FPO_DATA) * mi->dwEntries
                );
            VirtualProtect(
                mi->pFpoData,
                sizeof(FPO_DATA) * mi->dwEntries,
                PAGE_READONLY,
                &i
                );
        }
    }

    // copy the pdata block from the pdb

    if (pIDD->pPData) {
        mi->pPData = MemAlloc(pIDD->cbPData);
        if (mi->pPData) {
            mi->cPData = pIDD->cPData;
            mi->cbPData = pIDD->cbPData;
            CopyMemory(mi->pPData, pIDD->pPData, pIDD->cbPData);
        }
    }

    if (pIDD->pXData) {
        mi->pXData = MemAlloc(pIDD->cbXData);
        if (mi->pXData) {
            mi->cXData = pIDD->cXData;
            mi->cbXData = pIDD->cbXData;
            CopyMemory(mi->pXData, pIDD->pXData, pIDD->cbXData);
        }
    }

    // now the sections

    mi->NumSections = pIDD->cCurrentSections;
    if (pIDD->fCurrentSectionsMapped) {
        mi->SectionHdrs = (PIMAGE_SECTION_HEADER) MemAlloc(
            sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
            );
        if (mi->SectionHdrs) {
            CopyMemory(
                mi->SectionHdrs,
                pIDD->pCurrentSections,
                sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
                );
        }
    } else {
        mi->SectionHdrs = pIDD->pCurrentSections;
    }

    if (pIDD->pOriginalSections) {
        mi->OriginalNumSections = pIDD->cOriginalSections;
        mi->OriginalSectionHdrs = pIDD->pOriginalSections;
    } else {
        mi->OriginalNumSections = mi->NumSections;
        mi->OriginalSectionHdrs = (PIMAGE_SECTION_HEADER) MemAlloc(
            sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
            );
        if (mi->OriginalSectionHdrs) {
            CopyMemory(
                mi->OriginalSectionHdrs,
                pIDD->pCurrentSections,
                sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
                );
        }
    }

    // symbols

    mi->TmpSym.Name = (LPSTR) MemAlloc( TMP_SYM_LEN );

    if (pIDD->dia) {
        mi->SymType = SymDia;
        SymbolsLoaded = TRUE;
    } else {
        if (pIDD->pMappedCv) {
            SymbolsLoaded = LoadCodeViewSymbols(
                hProcess,
                mi,
                pIDD
                );
            pprint(pe, "codeview symbols %sloaded\n", SymbolsLoaded?"":"not ");
        }
        if (!SymbolsLoaded && pIDD->pMappedCoff) {
            SymbolsLoaded = LoadCoffSymbols(hProcess, mi, pIDD);
            pprint(pe, "coff symbols %sloaded\n", SymbolsLoaded?"":"not ");
        }

        if (!SymbolsLoaded && pIDD->cExports) {
            SymbolsLoaded = LoadExportSymbols( mi, pIDD );
            if (SymbolsLoaded) {
                mi->PdbSrc = srcNone;
            }
            pprint(pe, "export symbols %sloaded\n", SymbolsLoaded?"":"not ");
        }

        if (!SymbolsLoaded) {
            mi->SymType = SymNone;
            pprint(pe, "no symbols loaded\n");
        }
    }

    mi->dia = pIDD->dia;

    ProcessOmapForModule( mi, pIDD );

    ReleaseDebugData(pIDD,
                     IMGHLP_FREE_FPO | IMGHLP_FREE_SYMPATH | IMGHLP_FREE_PDATA | IMGHLP_FREE_XDATA);
    mi->Flags &= ~MIF_DEFERRED_LOAD;

    DoSymbolCallback(pe,
                       CBA_DEFERRED_SYMBOL_LOAD_COMPLETE,
                       mi,
                       &idsl,
                       CallbackFileName);

    return TRUE;
}


DWORD64
InternalLoadModule(
    IN  HANDLE          hProcess,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize,
    IN  HANDLE          hFile,
    IN  PMODLOAD_DATA   data,
    IN  DWORD           flags
    )
{
    IMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;
    PPROCESS_ENTRY                  pe;
    PMODULE_ENTRY                   mi;
    LPSTR                           p;
    DWORD64                         ip;

//  if (traceSubName(ImageName)) // for setting debug breakpoints from DBGHELP_TOKEN
//      dprint("debug(%s)\n", ImageName);

    if (BaseOfDll == (DWORD64)-1)
        return 0;

    __try {
        CHAR c;
        if (ImageName)
            c = *ImageName;
        if (ModuleName)
            c = *ModuleName;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    pe = FindProcessEntry( hProcess );
    if (!pe) {
        return 0;
    }

    if (BaseOfDll) {
        mi = GetModuleForPC( pe, BaseOfDll, TRUE );
    } else {
        mi = NULL;
    }

    if (mi) {
        //
        // in this case the symbols are already loaded
        // so the caller really wants the deferred
        // symbols to be loaded
        //
        if ( (mi->Flags & MIF_DEFERRED_LOAD) &&
                load( hProcess, mi )) {

            return mi->BaseOfDll;
        } else {
            return 0;
        }
    }

    //
    // look to see if there is an overlapping module entry
    //
    if (BaseOfDll) {
        do {
            mi = GetModuleForPC( pe, BaseOfDll, FALSE );
            if (mi) {
                RemoveEntryList( &mi->ListEntry );

                DoSymbolCallback(
                    pe,
                    CBA_SYMBOLS_UNLOADED,
                    mi,
                    &idsl,
                    mi->LoadedImageName ? mi->LoadedImageName : mi->ImageName ? mi->ImageName : mi->ModuleName
                    );

                FreeModuleEntry(pe, mi);
            }
        } while(mi);
    }

    mi = (PMODULE_ENTRY) MemAlloc( sizeof(MODULE_ENTRY) );
    if (!mi) {
        return 0;
    }
    InitModuleEntry(mi);

    mi->BaseOfDll = BaseOfDll;
    mi->DllSize = DllSize;
    mi->hFile = hFile;
    if (ImageName) {
        char SplitMod[_MAX_FNAME];

        mi->ImageName = StringDup(ImageName);
        _splitpath( ImageName, NULL, NULL, SplitMod, NULL );
        mi->ModuleName[0] = 0;
        strncat(mi->ModuleName, SplitMod, sizeof(mi->ModuleName) - 1);
        if (ModuleName && _stricmp( ModuleName, mi->ModuleName ) != 0) {
            mi->AliasName[0] = 0;
            strncat( mi->AliasName, ModuleName, sizeof(mi->AliasName) - 1 );
        } else {
            mi->AliasName[0] = 0;
        }
    } else {

        if (ModuleName) {
            mi->AliasName[0] = 0;
            strncat( mi->AliasName, ModuleName, sizeof(mi->AliasName) - 1 );
        }

    }
    mi->mod = NULL;
    mi->cbPdbSymbols = 0;
    mi->pPdbSymbols = NULL;

    if (data) {
        if (data->ssize != sizeof(MODLOAD_DATA)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }
        memcpy(&mi->mld, data, data->ssize);
        mi->CallerData = MemAlloc(mi->mld.size);
        if (!mi->CallerData) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return 0;
        }
        mi->mld.data = mi->CallerData;
        memcpy(mi->mld.data, data->data, mi->mld.size);
    }

    if ((g.SymOptions & SYMOPT_DEFERRED_LOADS) && BaseOfDll) {
        mi->Flags |= MIF_DEFERRED_LOAD;
        mi->SymType = SymDeferred;
    } else if (!load( hProcess, mi )) {
        FreeModuleEntry(pe, mi);
        return 0;
    }

    pe->Count += 1;

    InsertTailList( &pe->ModuleList, &mi->ListEntry);

    ip = GetIP(pe);
    if ((mi->BaseOfDll <= ip) && (mi->BaseOfDll + DllSize >= ip))
        diaSetModFromIP(pe);

    return mi->BaseOfDll;
}

PPROCESS_ENTRY
FindProcessEntry(
    HANDLE  hProcess
    )
{
    PLIST_ENTRY                 next;
    PPROCESS_ENTRY              pe;
    DWORD                       count;

    next = g.ProcessList.Flink;
    if (!next) {
        return NULL;
    }

    for (count = 0; (PVOID)next != (PVOID)&g.ProcessList; count++) {
        assert(count < g.cProcessList);
        if (count >= g.cProcessList)
            return NULL;
        pe = CONTAINING_RECORD( next, PROCESS_ENTRY, ListEntry );
        next = pe->ListEntry.Flink;
        if (pe->hProcess == hProcess) {
            return pe;
        }
    }

    return NULL;
}

PPROCESS_ENTRY
FindFirstProcessEntry(
    )
{
    return CONTAINING_RECORD(g.ProcessList.Flink, PROCESS_ENTRY, ListEntry);
}


PMODULE_ENTRY
FindModule(
    HANDLE hProcess,
    PPROCESS_ENTRY pe,
    LPSTR ModuleName,
    BOOL fLoad
    )
{
    PLIST_ENTRY next;
    PMODULE_ENTRY mi;

    if (!ModuleName || !*ModuleName)
        return NULL;

    next = pe->ModuleList.Flink;
    if (next) {
        while ((PVOID)next != (PVOID)&pe->ModuleList) {
            mi = CONTAINING_RECORD( next, MODULE_ENTRY, ListEntry );
            next = mi->ListEntry.Flink;

            if ((_stricmp( mi->ModuleName, ModuleName ) == 0) ||
                (mi->AliasName[0] &&
                 _stricmp( mi->AliasName, ModuleName ) == 0))
            {
                if (fLoad && !LoadSymbols(hProcess, mi, 0)) {
                    return NULL;
                }

                return mi;
            }
        }
    }

    return NULL;
}


#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED

BOOL
SymCheckUserGenerated(
   ULONG64 dwAddr,
   PSYMBOL_ENTRY sym,
   PMODULE_ENTRY mi
   )
{
   PSYMBOL_ENTRY nextSym;

   /*
   // We do not know the size of a user generated symbol...
   // This work because of the execution of CompleteSymbolTable() after AllocSym().
   // Particularly, the size has been adjusted.
   */

   if ( !(sym->Flags & SYMF_USER_GENERATED) )   {
      dprint("SymCheckUserGenerated: We should not call this function. This is not a user generated symbol...\n" );
      return FALSE;
   }

   if ( (dwAddr == sym->Address) || (sym == &mi->symbolTable[mi->numsyms - 1]) )  {
       return TRUE;
   }

   nextSym = sym + 1;
   if ( dwAddr < nextSym->Address )   {
       return TRUE;
   }

   return FALSE;

}

#endif // !_DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED

PSYMBOL_ENTRY
GetSymFromAddr(
    DWORD64         dwAddr,
    PDWORD64        pqwDisplacement,
    PMODULE_ENTRY   mi
    )
{
    PSYMBOL_ENTRY           sym = NULL;
    LONG                    High;
    LONG                    Low;
    LONG                    Middle;

    if (mi == NULL) {
        return NULL;
    }

    if (mi->dia)
        return diaGetSymFromAddr(dwAddr, mi, pqwDisplacement);

    //
    // do a binary search to locate the symbol
    //

    Low = 0;
    High = mi->numsyms - 1;

    while (High >= Low) {
        Middle = (Low + High) >> 1;
        sym = &mi->symbolTable[Middle];
        if (dwAddr < sym->Address) {

            High = Middle - 1;

        } else if (dwAddr >= sym->Address + sym->Size) {

#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED

            if ( (sym->Flags & SYMF_USER_GENERATED) && SymCheckUserGenerated( dwAddr, sym, mi ) ) {
                if (pqwDisplacement) {
                   *pqwDisplacement = dwAddr - sym->Address;
                }
                return sym;
            }

#endif // !_DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED

            Low = Middle + 1;

        } else {

            if (pqwDisplacement) {
                *pqwDisplacement = dwAddr - sym->Address;
            }
            return sym;

        }
    }

    return NULL;
}


PMODULE_ENTRY
GetModuleForPC(
    PPROCESS_ENTRY  pe,
    DWORD64         dwPcAddr,
    BOOL            ExactMatch
    )
{
    static PLIST_ENTRY          next = NULL;
    PMODULE_ENTRY               mi;

    if (dwPcAddr == (DWORD64)-1) {
        if (!next)
            return NULL;
        if ((PVOID)next == (PVOID)&pe->ModuleList) {
            // Reset to NULL so the list can be re-walked
            next = NULL;
            return NULL;
        }
        mi = CONTAINING_RECORD( next, MODULE_ENTRY, ListEntry );
        next = mi->ListEntry.Flink;
        return mi;
    }

    next = pe->ModuleList.Flink;
    if (!next) {
        return NULL;
    }

    while ((PVOID)next != (PVOID)&pe->ModuleList) {
        mi = CONTAINING_RECORD( next, MODULE_ENTRY, ListEntry );
        next = mi->ListEntry.Flink;
        if (dwPcAddr == 0) {
            return mi;
        }
        if (ExactMatch) {
            if (dwPcAddr == mi->BaseOfDll) {
               return mi;
            }
        } else
        if ((dwPcAddr == mi->BaseOfDll && mi->DllSize == 0) ||
            ((dwPcAddr >= mi->BaseOfDll) &&
                (dwPcAddr  < mi->BaseOfDll + mi->DllSize))) {
               return mi;
        }
    }

    return NULL;
}

PSYMBOL_ENTRY
GetSymFromAddrAllContexts(
    DWORD64         dwAddr,
    PDWORD64        pqwDisplacement,
    PPROCESS_ENTRY  pe
    )
{
    PMODULE_ENTRY mi = GetModuleForPC( pe, dwAddr, FALSE );
    if (mi == NULL) {
        return NULL;
    }
    return GetSymFromAddr( dwAddr, pqwDisplacement, mi );
}

DWORD
ComputeHash(
    LPSTR   lpbName,
    ULONG   cb
    )
{
    ULONG UNALIGNED *   lpulName;
    ULONG               ulEnd = 0;
    int                 cul;
    int                 iul;
    ULONG               ulSum = 0;

    while (cb & 3) {
        ulEnd |= (lpbName[cb - 1] & 0xdf);
        ulEnd <<= 8;
        cb -= 1;
    }

    cul = cb / 4;
    lpulName = (ULONG UNALIGNED *) lpbName;
    for (iul =0; iul < cul; iul++) {
        ulSum ^= (lpulName[iul] & 0xdfdfdfdf);
        ulSum = _lrotl( ulSum, 4);
    }
    ulSum ^= ulEnd;
    return ulSum % HASH_MODULO;
}

PSYMBOL_ENTRY
AllocSym(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    LPSTR           name
    )
{
    PSYMBOL_ENTRY       sym;
    ULONG               Length;


    if (mi->numsyms == mi->MaxSyms) {
//       dprint("AllocSym: ERROR - symbols Table overflow!\n");
        return NULL;
    }

    if (!mi->StringSize) {
//      dprint("AllocSym: ERROR - symbols strings not allocated for module!\n");
        return NULL;
    }

    Length = strlen(name);

    if ((Length + 1) > mi->StringSize) {
//      dprint("AllocSym: ERROR - symbols strings buffer overflow!\n");
        return NULL;
    }

    sym = &mi->symbolTable[mi->numsyms];

    mi->numsyms += 1;
    sym->Name = mi->SymStrings;
    mi->SymStrings += (Length + 2);
    mi->StringSize -= (Length + 2);

    strcpy( sym->Name, name );
    sym->Address = addr;
    sym->Size = 0;
    sym->Flags = 0;
    sym->Next = NULL;
    sym->NameLength = Length;

    return sym;
}

int __cdecl
SymbolTableAddressCompare(
    const void *e1,
    const void *e2
    )
{
    PSYMBOL_ENTRY    sym1 = (PSYMBOL_ENTRY) e1;
    PSYMBOL_ENTRY    sym2 = (PSYMBOL_ENTRY) e2;
    LONG64 diff;

    if ( sym1 && sym2 ) {
        diff = (sym1->Address - sym2->Address);
        return (diff < 0) ? -1 : (diff == 0) ? 0 : 1;
    } else {
        return 1;
    }
}

int __cdecl
SymbolTableNameCompare(
    const void *e1,
    const void *e2
    )
{
    PSYMBOL_ENTRY    sym1 = (PSYMBOL_ENTRY) e1;
    PSYMBOL_ENTRY    sym2 = (PSYMBOL_ENTRY) e2;

    return strcmp( sym1->Name, sym2->Name );
}

VOID
CompleteSymbolTable(
    PMODULE_ENTRY   mi
    )
{
    PSYMBOL_ENTRY       sym;
    PSYMBOL_ENTRY       symH;
    ULONG               Hash;
    ULONG               i;
    ULONG               dups;
    ULONG               seq;


    //
    // sort the symbols by name
    //
    dbg_qsort(
        mi->symbolTable,
        mi->numsyms,
        sizeof(SYMBOL_ENTRY),
        SymbolTableNameCompare
        );

    //
    // mark duplicate names
    //
    seq = 0;
    for (i=0; i<mi->numsyms; i++) {
        dups = 0;
        while ((mi->symbolTable[i+dups].NameLength == mi->symbolTable[i+dups+1].NameLength) &&
               (strcmp( mi->symbolTable[i+dups].Name, mi->symbolTable[i+dups+1].Name ) == 0)) {
                   mi->symbolTable[i+dups].Flags |= SYMF_DUPLICATE;
                   mi->symbolTable[i+dups+1].Flags |= SYMF_DUPLICATE;
                   dups += 1;
        }
        i += dups;
    }

    //
    // sort the symbols by address
    //
    dbg_qsort(
        mi->symbolTable,
        mi->numsyms,
        sizeof(SYMBOL_ENTRY),
        SymbolTableAddressCompare
        );

    //
    // calculate the size of each symbol
    //
    for (i=0; i<mi->numsyms; i++) {
        mi->symbolTable[i].Next = NULL;
        if (i+1 < mi->numsyms) {
            mi->symbolTable[i].Size = (ULONG)(mi->symbolTable[i+1].Address - mi->symbolTable[i].Address);
        }
    }

    //
    // compute the hash for each symbol
    //
    ZeroMemory( mi->NameHashTable, sizeof(mi->NameHashTable) );
    for (i=0; i<mi->numsyms; i++) {
        sym = &mi->symbolTable[i];

        Hash = ComputeHash( sym->Name, sym->NameLength );

        if (mi->NameHashTable[Hash]) {

            //
            // we have a collision
            //
            symH = mi->NameHashTable[Hash];
            while( symH->Next ) {
                symH = symH->Next;
            }
            symH->Next = sym;

        } else {

            mi->NameHashTable[Hash] = sym;

        }
    }
}

BOOL
CreateSymbolTable(
    PMODULE_ENTRY   mi,
    DWORD           SymbolCount,
    SYM_TYPE        SymType,
    DWORD           NameSize
    )
{
    //
    // allocate the symbol table
    //
    NameSize += OMAP_SYM_STRINGS;
    mi->symbolTable = (PSYMBOL_ENTRY) MemAlloc(
        (sizeof(SYMBOL_ENTRY) * (SymbolCount + OMAP_SYM_EXTRA)) + NameSize + (SymbolCount * CPP_EXTRA)
        );
    if (!mi->symbolTable) {
        return FALSE;
    }

    //
    // initialize the relevant fields
    //
    mi->numsyms    = 0;
    mi->MaxSyms    = SymbolCount + OMAP_SYM_EXTRA;
    mi->SymType    = SymType;
    mi->StringSize = NameSize + (SymbolCount * CPP_EXTRA);
    mi->SymStrings = (LPSTR)(mi->symbolTable + SymbolCount + OMAP_SYM_EXTRA);

    return TRUE;
}

PIMAGE_SECTION_HEADER
FindSection(
    PIMAGE_SECTION_HEADER   sh,
    ULONG                   NumSections,
    ULONG                   Address
    )
{
    ULONG i;
    for (i=0; i<NumSections; i++) {
        if (Address >= sh[i].VirtualAddress &&
            Address <  (sh[i].VirtualAddress + sh[i].Misc.VirtualSize)) {
                    return &sh[i];
        }
    }
    return NULL;
}

PVOID
GetSectionPhysical(
    HANDLE             hp,
    ULONG64            base,
    PIMGHLP_DEBUG_DATA pIDD,
    ULONG              Address
    )
{
    PIMAGE_SECTION_HEADER   sh;

    sh = FindSection( pIDD->pCurrentSections, pIDD->cCurrentSections, Address );
    if (!sh) {
        return 0;
    }

    return (PCHAR)pIDD->ImageMap + sh->PointerToRawData + (Address - sh->VirtualAddress);
}

BOOL
ReadSectionInfo(
    HANDLE             hp,
    ULONG64            base,
    PIMGHLP_DEBUG_DATA pIDD,
    ULONG              address,
    PVOID              buf,
    DWORD              size
    )
{
    PIMAGE_SECTION_HEADER   sh;
    DWORD_PTR status = TRUE;

    sh = FindSection( pIDD->pCurrentSections, pIDD->cCurrentSections, address );
    if (!sh)
        return FALSE;

    if (!hp) {
        status = (DWORD_PTR)memcpy((PCHAR)buf,
                               (PCHAR)base + sh->PointerToRawData + (address - sh->VirtualAddress),
                               size);
    } else {
        status = ReadImageData(hp, base, address, buf, size);
    }
    if (!status)
        return FALSE;

    return TRUE;
}


PCHAR
expptr(
    HANDLE             hp,
    ULONG64            base,
    PIMGHLP_DEBUG_DATA pIDD,
    ULONG              address
    )
{
    PIMAGE_SECTION_HEADER   sh;
    DWORD_PTR status = TRUE;

    if (hp)
        return (PCHAR)base + address;

    sh = FindSection( pIDD->pCurrentSections, pIDD->cCurrentSections, address );
    if (!sh)
        return FALSE;

    return (PCHAR)base + sh->PointerToRawData + (address - sh->VirtualAddress);
}


ULONG
LoadExportSymbols(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    PULONG                  names;
    PULONG                  addrs;
    PUSHORT                 ordinals;
    PUSHORT                 ordidx = NULL;
    ULONG                   cnt;
    ULONG                   idx;
    PIMAGE_EXPORT_DIRECTORY expdir;
    PCHAR                   expbuf = NULL;
    ULONG                   i;
    PSYMBOL_ENTRY           sym;
    ULONG                   NameSize;
    HANDLE                  hp;
    ULONG64                 base;
    CHAR                    name[2048];
    BOOL                    rc;
    DWORD64                 endExports;
    PCHAR                   p;

    if (g.SymOptions & SYMOPT_EXACT_SYMBOLS)
        return 0;

    // setup pointers for grabing data

    switch (pIDD->dsExports) {
    case dsInProc:
        hp = pIDD->hProcess;
        expbuf = (PCHAR)MemAlloc(pIDD->cExports);
        if (!expbuf)
            goto cleanup;
        if (!ReadImageData(hp, pIDD->InProcImageBase, pIDD->oExports, expbuf, pIDD->cExports))
            goto cleanup;
        base = (ULONG64)expbuf - pIDD->oExports;
        expdir = (PIMAGE_EXPORT_DIRECTORY)expbuf;
        break;
    case dsImage:
        hp = NULL;
        expbuf = NULL;
        if (!pIDD->ImageMap)
            pIDD->ImageMap = MapItRO(pIDD->ImageFileHandle);
        base = (ULONG64)pIDD->ImageMap;
        expdir = &pIDD->expdir;
        break;
    default:
        return 0;
    }

    cnt = 0;

    names = (PULONG)expptr(hp, base, pIDD, expdir->AddressOfNames);
    if (!names)
        goto cleanup;

    addrs = (PULONG)expptr(hp, base, pIDD, expdir->AddressOfFunctions);
    if (!addrs)
        goto cleanup;

    ordinals = (PUSHORT)expptr(hp, base, pIDD, expdir->AddressOfNameOrdinals);
    if (!ordinals)
        goto cleanup;

    ordidx = (PUSHORT) MemAlloc( max(expdir->NumberOfFunctions, expdir->NumberOfNames) * sizeof(USHORT) );

    if (!ordidx)
        goto cleanup;

    cnt = 0;
    NameSize = 0;

    // count the symbols

    for (i=0; i<expdir->NumberOfNames; i++) {
        *name = 0;
        p = expptr(hp, base, pIDD, names[i]);
        if (!p)
            continue;
        strcpy(name, p);
        if (!*name)
            continue;
        if (g.SymOptions & SYMOPT_UNDNAME) {
            SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN, name, strlen(name), mi->MachineType, TRUE );
            NameSize += strlen(mi->TmpSym.Name);
            cnt += 1;
        } else {
            NameSize += (strlen(name) + 2);
            cnt += 1;
        }
    }

    for (i=0,idx=expdir->NumberOfNames; i<expdir->NumberOfFunctions; i++) {
        if (!ordidx[i]) {
            NameSize += 16;
            cnt += 1;
        }
    }

    // allocate the symbol table

    if (!CreateSymbolTable( mi, cnt, SymExport, NameSize )) {
        cnt = 0;
        goto cleanup;
    }

    // allocate the symbols

    cnt = 0;
    endExports = pIDD->oExports + pIDD->cExports;

    for (i=0; i<expdir->NumberOfNames; i++) {
        idx = ordinals[i];
        ordidx[idx] = TRUE;
        *name = 0;
        p = expptr(hp, base, pIDD, names[i]);
        if (!p)
            continue;
        strcpy(name, p);
        if (!*name)
            continue;
        if (g.SymOptions & SYMOPT_UNDNAME) {
            SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN, (LPSTR)name, strlen(name), mi->MachineType, TRUE );
            sym = AllocSym( mi, addrs[idx] + mi->BaseOfDll, mi->TmpSym.Name);
        } else {
            sym = AllocSym( mi, addrs[idx] + mi->BaseOfDll, name);
        }
        if (sym) {
            cnt += 1;
        }
        if (pIDD->oExports <= addrs[idx]
            && addrs[idx] <= endExports)
        {
            sym->Flags |= SYMF_FORWARDER;
        } else {
            sym->Flags |= SYMF_EXPORT;
        }
    }

    for (i=0,idx=expdir->NumberOfNames; i<expdir->NumberOfFunctions; i++) {
        if (!ordidx[i]) {
            CHAR NameBuf[sizeof("Ordinal99999") + 1];       // Ordinals are only 64k max.
            strcpy( NameBuf, "Ordinal" );
            _itoa( i+expdir->Base, &NameBuf[7], 10 );
            sym = AllocSym( mi, addrs[i] + mi->BaseOfDll, NameBuf);
            if (sym) {
                cnt += 1;
            }
            idx += 1;
        }
    }

    CompleteSymbolTable( mi );

cleanup:
    if (expbuf) {
        MemFree(expbuf);
    }
    if (ordidx) {
        MemFree(ordidx);
    }

    return cnt;
}


BOOL
LoadCoffSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    PIMAGE_COFF_SYMBOLS_HEADER pCoffHeader = (PIMAGE_COFF_SYMBOLS_HEADER)(pIDD->pMappedCoff);
    PUCHAR              stringTable;
    PIMAGE_SYMBOL       allSymbols;
    DWORD               numberOfSymbols;
    PIMAGE_LINENUMBER   LineNumbers;
    PIMAGE_SYMBOL       NextSymbol;
    PIMAGE_SYMBOL       Symbol;
    PSYMBOL_ENTRY       sym;
    CHAR                szSymName[256];
    DWORD               i;
    DWORD64             addr;
    DWORD               CoffSymbols = 0;
    DWORD               NameSize = 0;
    DWORD64             Bias;

    allSymbols = (PIMAGE_SYMBOL)((PCHAR)pCoffHeader +
                 pCoffHeader->LvaToFirstSymbol);

    stringTable = (PUCHAR)pCoffHeader +
                  pCoffHeader->LvaToFirstSymbol +
                  (pCoffHeader->NumberOfSymbols * IMAGE_SIZEOF_SYMBOL);

    numberOfSymbols = pCoffHeader->NumberOfSymbols;
    LineNumbers = (PIMAGE_LINENUMBER)(PCHAR)pCoffHeader +
                        pCoffHeader->LvaToFirstLinenumber;

    //
    // count the number of actual symbols
    //
    NextSymbol = allSymbols;
    for (i= 0; i < numberOfSymbols; i++) {
        Symbol = NextSymbol++;
        if (Symbol->StorageClass == IMAGE_SYM_CLASS_EXTERNAL &&
            Symbol->SectionNumber > 0) {
            GetSymName( Symbol, stringTable, szSymName, sizeof(szSymName) );
            if (szSymName[0] == '?' && szSymName[1] == '?' &&
                szSymName[2] == '_' && szSymName[3] == 'C'    ) {
                //
                // ignore strings
                //
            } else if (g.SymOptions & SYMOPT_UNDNAME) {
                SymUnDNameInternal(mi->TmpSym.Name,
                                   TMP_SYM_LEN,
                                   szSymName,
                                   strlen(szSymName),
                                   mi->MachineType,
                                   TRUE);
                NameSize += strlen(mi->TmpSym.Name);
                CoffSymbols += 1;
            } else {
                CoffSymbols += 1;
                NameSize += (strlen(szSymName) + 1);
            }
        }

        NextSymbol += Symbol->NumberOfAuxSymbols;
        i += Symbol->NumberOfAuxSymbols;
    }

    //
    // allocate the symbol table
    //
    if (!CreateSymbolTable( mi, CoffSymbols, SymCoff, NameSize )) {
        return FALSE;
    }

    //
    // populate the symbol table
    //

    if (mi->Flags & MIF_ROM_IMAGE) {
        Bias = mi->BaseOfDll & 0xffffffff00000000;
    } else {
        Bias = mi->BaseOfDll;
    }

    NextSymbol = allSymbols;
    for (i= 0; i < numberOfSymbols; i++) {
        Symbol = NextSymbol++;
        if (Symbol->StorageClass == IMAGE_SYM_CLASS_EXTERNAL &&
            Symbol->SectionNumber > 0) {
            GetSymName( Symbol, stringTable, szSymName, sizeof(szSymName) );
            addr = Symbol->Value + Bias;
            if (szSymName[0] == '?' && szSymName[1] == '?' &&
                szSymName[2] == '_' && szSymName[3] == 'C'    ) {
                //
                // ignore strings
                //
            } else if (g.SymOptions & SYMOPT_UNDNAME) {
                SymUnDNameInternal(mi->TmpSym.Name,
                                   TMP_SYM_LEN,
                                   szSymName,
                                   strlen(szSymName),
                                   mi->MachineType,
                                   TRUE);
                AllocSym( mi, addr, mi->TmpSym.Name);
            } else {
                AllocSym( mi, addr, szSymName );
            }
        }

        NextSymbol += Symbol->NumberOfAuxSymbols;
        i += Symbol->NumberOfAuxSymbols;
    }

    CompleteSymbolTable( mi );

    if (g.SymOptions & SYMOPT_LOAD_LINES) {
        AddLinesForCoff(mi, allSymbols, numberOfSymbols, LineNumbers);
    }

    return TRUE;
}

BOOL
LoadCodeViewSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    DWORD                   i, j;
    PPROCESS_ENTRY          pe;
    OMFSignature           *omfSig;
    OMFDirHeader           *omfDirHdr;
    OMFDirEntry            *omfDirEntry;
    OMFSymHash             *omfSymHash;
    DATASYM32              *dataSym;
    DWORD64                 addr;
    DWORD                   CvSymbols;
    DWORD                   NameSize;
    SYMBOL_ENTRY            SymEntry;

    pe = FindProcessEntry( hProcess );
    if (!pe) {
        return FALSE;
    }

    pprint(pe, "LoadCodeViewSymbols:\n"
            " hProcess   %p\n"
            " mi         %p\n"
            " pCvData    %p\n"
            " dwSize     %x\n",
            hProcess,
            mi,
            pIDD->pMappedCv,
            pIDD->cMappedCv
            );

    omfSig = (OMFSignature*) pIDD->pMappedCv;
    if ((*(DWORD *)(omfSig->Signature) != '80BN') &&
        (*(DWORD *)(omfSig->Signature) != '90BN') &&
        (*(DWORD *)(omfSig->Signature) != '11BN'))
    {
        if ((*(DWORD *)(omfSig->Signature) != '01BN') &&
            (*(DWORD *)(omfSig->Signature) != 'SDSR'))
        {
            pprint(pe, "unrecognized OMF sig: %x\n", *(DWORD *)(omfSig->Signature));
        }
        return FALSE;
    }

    //
    // count the number of actual symbols
    //
    omfDirHdr = (OMFDirHeader*) ((ULONG_PTR)omfSig + (DWORD)omfSig->filepos);
    omfDirEntry = (OMFDirEntry*) ((ULONG_PTR)omfDirHdr + sizeof(OMFDirHeader));

    NameSize = 0;
    CvSymbols = 0;

    for (i=0; i<omfDirHdr->cDir; i++,omfDirEntry++) {
        LPSTR SymbolName;
        UCHAR SymbolLen;
        SYMBOL_ENTRY SymEntry;

        if (omfDirEntry->SubSection == sstGlobalPub) {
            omfSymHash = (OMFSymHash*) ((ULONG_PTR)omfSig + omfDirEntry->lfo);
            dataSym = (DATASYM32*) ((ULONG_PTR)omfSig + omfDirEntry->lfo + sizeof(OMFSymHash));
            for (j=sizeof(OMFSymHash); j<=omfSymHash->cbSymbol; ) {
                addr = 0;
                cvExtractSymbolInfo(mi, (PCHAR) dataSym, &SymEntry, FALSE);
                if (SymEntry.Segment && (SymEntry.Segment <= mi->OriginalNumSections))
                {
                    addr = mi->OriginalSectionHdrs[SymEntry.Segment-1].VirtualAddress + SymEntry.Offset + mi->BaseOfDll;
                    SymbolName = SymEntry.Name;
                    SymbolLen =  (UCHAR) SymEntry.NameLength;
                    if (SymbolName[0] == '?' &&
                        SymbolName[1] == '?' &&
                        SymbolName[2] == '_' &&
                        SymbolName[3] == 'C' )
                    {
                        //
                        // ignore strings
                        //
                    } else if (g.SymOptions & SYMOPT_UNDNAME) {
                        SymUnDNameInternal(mi->TmpSym.Name,
                                           TMP_SYM_LEN,
                                           SymbolName,
                                           SymbolLen,
                                           mi->MachineType,
                                           TRUE);
                        NameSize += strlen(mi->TmpSym.Name);
                        CvSymbols += 1;
                    } else {
                        CvSymbols += 1;
                        NameSize += SymbolLen + 1;
                    }
                }
                j += dataSym->reclen + 2;
                dataSym = (DATASYM32*) ((ULONG_PTR)dataSym + dataSym->reclen + 2);
            }
            break;
        }
    }

    //
    // allocate the symbol table
    //
    if (!CreateSymbolTable( mi, CvSymbols, SymCv, NameSize )) {
        pprint(pe, "CreateSymbolTable failed\n");
        return FALSE;
    }

    //
    // populate the symbol table
    //
    omfDirHdr = (OMFDirHeader*) ((ULONG_PTR)omfSig + (DWORD)omfSig->filepos);
    omfDirEntry = (OMFDirEntry*) ((ULONG_PTR)omfDirHdr + sizeof(OMFDirHeader));
    for (i=0; i<omfDirHdr->cDir; i++,omfDirEntry++) {
        LPSTR SymbolName;
        if (omfDirEntry->SubSection == sstGlobalPub) {
            omfSymHash = (OMFSymHash*) ((ULONG_PTR)omfSig + omfDirEntry->lfo);
            dataSym = (DATASYM32*) ((ULONG_PTR)omfSig + omfDirEntry->lfo + sizeof(OMFSymHash));
            for (j=sizeof(OMFSymHash); j<=omfSymHash->cbSymbol; ) {
                addr = 0;
                cvExtractSymbolInfo(mi, (PCHAR) dataSym, &SymEntry, FALSE);


                if (SymEntry.Segment && (SymEntry.Segment <= mi->OriginalNumSections))
                {
                    addr = mi->OriginalSectionHdrs[SymEntry.Segment-1].VirtualAddress + SymEntry.Offset + mi->BaseOfDll;
                    SymbolName = SymEntry.Name;
                    if (SymbolName[0] == '?' &&
                        SymbolName[1] == '?' &&
                        SymbolName[2] == '_' &&
                        SymbolName[3] == 'C' )
                    {
                        //
                        // ignore strings
                        //
                    } else if (g.SymOptions & SYMOPT_UNDNAME) {
                        SymUnDNameInternal(mi->TmpSym.Name,
                                           TMP_SYM_LEN,
                                           SymbolName,
                                           SymEntry.NameLength,
                                           mi->MachineType,
                                           TRUE);
                        AllocSym( mi, addr, (LPSTR) mi->TmpSym.Name);
                    } else {
                        mi->TmpSym.NameLength = SymEntry.NameLength;
                        memcpy( mi->TmpSym.Name, SymbolName, mi->TmpSym.NameLength );
                        mi->TmpSym.Name[mi->TmpSym.NameLength] = 0;
                        AllocSym( mi, addr, mi->TmpSym.Name);
                    }
                }
                j += dataSym->reclen + 2;
                dataSym = (DATASYM32*) ((ULONG_PTR)dataSym + dataSym->reclen + 2);
            }
            break;
        }
        else if (omfDirEntry->SubSection == sstSrcModule &&
                 (g.SymOptions & SYMOPT_LOAD_LINES)) {
            AddLinesForOmfSourceModule(mi,
                                       (PUCHAR)(pIDD->pMappedCv)+omfDirEntry->lfo,
                                       (OMFSourceModule *)
                                       ((PCHAR)(pIDD->pMappedCv)+omfDirEntry->lfo),
                                       NULL);
        }
    }

    CompleteSymbolTable( mi );

    return TRUE;
}

VOID
GetSymName(
    PIMAGE_SYMBOL Symbol,
    PUCHAR        StringTable,
    LPSTR         s,
    DWORD         size
    )
{
    DWORD i;

    if (Symbol->n_zeroes) {
        for (i=0; i<8; i++) {
            if ((Symbol->n_name[i]>0x1f) && (Symbol->n_name[i]<0x7f)) {
                *s++ = Symbol->n_name[i];
            }
        }
        *s = 0;
    }
    else {
        strncpy( s, (char *) &StringTable[Symbol->n_offset], size );
    }
}


VOID
ProcessOmapForModule(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    PSYMBOL_ENTRY       sym;
    PSYMBOL_ENTRY       symN;
    DWORD               i;
    ULONG64             addr;
    DWORD               bias;
    PFPO_DATA           fpo;

    if (pIDD->cOmapTo && pIDD->pOmapTo) {
        if (pIDD->fOmapToMapped || pIDD->dia) {
            mi->pOmapTo = (POMAP)MemAlloc(pIDD->cOmapTo * sizeof(OMAP));
            if (mi->pOmapTo) {
                CopyMemory(
                    mi->pOmapTo,
                    pIDD->pOmapTo,
                    pIDD->cOmapTo * sizeof(OMAP)
                    );
            }
        } else {
            mi->pOmapTo = pIDD->pOmapTo;
        }
        mi->cOmapTo = pIDD->cOmapTo;
    }

    if (pIDD->cOmapFrom && pIDD->pOmapFrom) {
        if (pIDD->fOmapFromMapped) {
            mi->pOmapFrom = (POMAP)MemAlloc(pIDD->cOmapFrom * sizeof(OMAP));
            if (mi->pOmapFrom) {
                CopyMemory(
                    mi->pOmapFrom,
                    pIDD->pOmapFrom,
                    pIDD->cOmapFrom * sizeof(OMAP)
                    );
            }
        } else {
            mi->pOmapFrom = pIDD->pOmapFrom;
        }
        mi->cOmapFrom = pIDD->cOmapFrom;
    }

    if (mi->pFpoData) {
        //
        // if this module is BBT-optimized, then build
        // another fpo table with omap transalation
        //
        mi->pFpoDataOmap = (PFPO_DATA)VirtualAlloc(
            NULL,
            sizeof(FPO_DATA) * mi->dwEntries,
            MEM_COMMIT,
            PAGE_READWRITE
            );
        if (mi->pFpoDataOmap) {
            CopyMemory(
                mi->pFpoDataOmap,
                pIDD->pFpo,
                sizeof(FPO_DATA) * mi->dwEntries
                );
            for (i = 0, fpo = mi->pFpoDataOmap;
                 i < mi->dwEntries;
                 i++, fpo++) {
                addr =  ConvertOmapFromSrc(mi,
                                           mi->BaseOfDll + fpo->ulOffStart,
                                           &bias);
                if (addr)
                    fpo->ulOffStart = (ULONG)(addr - mi->BaseOfDll) + bias;
            }
            VirtualProtect(
                mi->pFpoData,
                sizeof(FPO_DATA) * mi->dwEntries,
                PAGE_READONLY,
                &i
                );
        }
    }

    if (!mi->pOmapFrom ||
        !mi->symbolTable ||
        ((mi->SymType != SymCoff) && (mi->SymType != SymCv))
       )
    {
        return;
    }

    for (i=0; i<mi->numsyms; i++) {
        ProcessOmapSymbol( mi, &mi->symbolTable[i] );
    }

    CompleteSymbolTable( mi );
}


BOOL
ProcessOmapSymbol(
    PMODULE_ENTRY       mi,
    PSYMBOL_ENTRY       sym
    )
{
    DWORD           bias;
    DWORD64         OptimizedSymAddr;
    DWORD           rvaSym;
    POMAPLIST       pomaplistHead;
    DWORD64         SymbolValue;
    DWORD64         OrgSymAddr;
    POMAPLIST       pomaplistNew;
    POMAPLIST       pomaplistPrev;
    POMAPLIST       pomaplistCur;
    POMAPLIST       pomaplistNext;
    DWORD           rva;
    DWORD           rvaTo;
    DWORD           cb;
    DWORD           end;
    DWORD           rvaToNext;
    LPSTR           NewSymName;
    CHAR            Suffix[32];
    DWORD64         addrNew;
    POMAP           pomap;
    PSYMBOL_ENTRY   symOmap;

    if ((sym->Flags & SYMF_OMAP_GENERATED) || (sym->Flags & SYMF_OMAP_MODIFIED)) {
        return FALSE;
    }

    OrgSymAddr = SymbolValue = sym->Address;

    OptimizedSymAddr = ConvertOmapFromSrc( mi, SymbolValue, &bias );

    if (OptimizedSymAddr == 0) {
        //
        // No equivalent address
        //
        sym->Address = 0;
        return FALSE;

    }

    //
    // We have successfully converted
    //
    sym->Address = OptimizedSymAddr + bias;

    rvaSym = (ULONG)(SymbolValue - mi->BaseOfDll);
    SymbolValue = sym->Address;

    pomap = GetOmapFromSrcEntry( mi, OrgSymAddr );
    if (!pomap) {
        goto exit;
    }

    pomaplistHead = NULL;

    //
    // Look for all OMAP entries belonging to SymbolEntry
    //

    end = (ULONG)(OrgSymAddr - mi->BaseOfDll + sym->Size);

    while (pomap && (pomap->rva < end)) {

        if (pomap->rvaTo == 0) {
            pomap++;
            continue;
        }

        //
        // Allocate and initialize a new entry
        //
        pomaplistNew = (POMAPLIST) MemAlloc( sizeof(OMAPLIST) );
        if (!pomaplistNew) {
            return FALSE;
        }

        pomaplistNew->omap = *pomap;
        pomaplistNew->cb = pomap[1].rva - pomap->rva;

        pomaplistPrev = NULL;
        pomaplistCur = pomaplistHead;

        while (pomaplistCur != NULL) {
            if (pomap->rvaTo < pomaplistCur->omap.rvaTo) {
                //
                // Insert between Prev and Cur
                //
                break;
            }
            pomaplistPrev = pomaplistCur;
            pomaplistCur = pomaplistCur->next;
        }

        if (pomaplistPrev == NULL) {
            //
            // Insert in head position
            //
            pomaplistHead = pomaplistNew;
        } else {
            pomaplistPrev->next = pomaplistNew;
        }

        pomaplistNew->next = pomaplistCur;

        pomap++;
    }

    if (pomaplistHead == NULL) {
        goto exit;
    }

    pomaplistCur = pomaplistHead;
    pomaplistNext = pomaplistHead->next;

    //
    // we do have a list
    //
    while (pomaplistNext != NULL) {
        rva = pomaplistCur->omap.rva;
        rvaTo  = pomaplistCur->omap.rvaTo;
        cb = pomaplistCur->cb;
        rvaToNext = pomaplistNext->omap.rvaTo;

        if (rvaToNext == sym->Address - mi->BaseOfDll) {
            //
            // Already inserted above
            //
        } else if (rvaToNext < (rvaTo + cb + 8)) {
            //
            // Adjacent to previous range
            //
        } else {
            addrNew = mi->BaseOfDll + rvaToNext;
            Suffix[0] = '_';
            _ltoa( pomaplistNext->omap.rva - rvaSym, &Suffix[1], 10 );
            memcpy( mi->TmpSym.Name, sym->Name, sym->NameLength );
            strncpy( &mi->TmpSym.Name[sym->NameLength], Suffix, strlen(Suffix) + 1 );
            symOmap = AllocSym( mi, addrNew, mi->TmpSym.Name);
            if (symOmap) {
                symOmap->Flags |= SYMF_OMAP_GENERATED;
            }
        }

        MemFree(pomaplistCur);

        pomaplistCur = pomaplistNext;
        pomaplistNext = pomaplistNext->next;
    }

    MemFree(pomaplistCur);

exit:
    if (sym->Address != OrgSymAddr) {
        sym->Flags |= SYMF_OMAP_MODIFIED;
    }

    return TRUE;
}


DWORD64
ConvertOmapFromSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias
    )
{
    DWORD   rva;
    DWORD   comap;
    POMAP   pomapLow;
    POMAP   pomapHigh;
    DWORD   comapHalf;
    POMAP   pomapMid;


    *bias = 0;

    if (!mi->pOmapFrom) {
        return addr;
    }

    rva = (DWORD)(addr - mi->BaseOfDll);

    comap = mi->cOmapFrom;
    pomapLow = mi->pOmapFrom;
    pomapHigh = pomapLow + comap;

    while (pomapLow < pomapHigh) {

        comapHalf = comap / 2;

        pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

        if (rva == pomapMid->rva) {
            if (pomapMid->rvaTo) {
                return mi->BaseOfDll + pomapMid->rvaTo;
            } else {
                return(0);      // No need adding the base.  This address was discarded...
            }
        }

        if (rva < pomapMid->rva) {
            pomapHigh = pomapMid;
            comap = (comap & 1) ? comapHalf : (comapHalf - 1);
        } else {
            pomapLow = pomapMid + 1;
            comap = comapHalf;
        }
    }

    //
    // If no exact match, pomapLow points to the next higher address
    //
    if (pomapLow == mi->pOmapFrom) {
        //
        // This address was not found
        //
        return 0;
    }

    if (pomapLow[-1].rvaTo == 0) {
        //
        // This address is in a discarded block
        //
        return 0;
    }

    //
    // Return the closest address plus the bias
    //
    *bias = rva - pomapLow[-1].rva;

    return mi->BaseOfDll + pomapLow[-1].rvaTo;
}


DWORD64
ConvertOmapToSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias,
    BOOL           fBackup
    )
{
    DWORD   rva;
    DWORD   comap;
    POMAP   pomapLow;
    POMAP   pomapHigh;
    DWORD   comapHalf;
    POMAP   pomapMid;

    *bias = 0;

    if (!mi->pOmapTo) {
        return addr;
    }

    rva = (DWORD)(addr - mi->BaseOfDll);

    comap = mi->cOmapTo;
    pomapLow = mi->pOmapTo;
    pomapHigh = pomapLow + comap;

    while (pomapLow < pomapHigh) {

        comapHalf = comap / 2;

        pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

        if (rva == pomapMid->rva) {
            if (pomapMid->rvaTo == 0) {
                //
                // We may be at the start of an inserted branch instruction
                //

                if (fBackup) {
                    //
                    // Return information about the next lower address
                    //

                    rva--;
                    pomapLow = pomapMid;
                    break;
                }

                return 0;
            }

            return mi->BaseOfDll + pomapMid->rvaTo;
        }

        if (rva < pomapMid->rva) {
            pomapHigh = pomapMid;
            comap = (comap & 1) ? comapHalf : (comapHalf - 1);
        } else {
            pomapLow = pomapMid + 1;
            comap = comapHalf;
        }
    }

    //
    // If no exact match, pomapLow points to the next higher address
    //

    if (pomapLow == mi->pOmapTo) {
        //
        // This address was not found
        //
        return 0;
    }

    // find the previous valid item in the omap

    do {
        pomapLow--;
        if (pomapLow->rvaTo)
            break;
    } while (pomapLow > mi->pOmapTo);

    // should never occur

//  assert(pomapLow->rvaTo);
    if (pomapLow->rvaTo == 0) {
        return 0;
    }

    //
    // Return the new address plus the bias
    //
    *bias = rva - pomapLow->rva;

    return mi->BaseOfDll + pomapLow->rvaTo;
}

POMAP
GetOmapFromSrcEntry(
    PMODULE_ENTRY  mi,
    DWORD64        addr
    )
{
    DWORD   rva;
    DWORD   comap;
    POMAP   pomapLow;
    POMAP   pomapHigh;
    DWORD   comapHalf;
    POMAP   pomapMid;


    if (mi->pOmapFrom == NULL) {
        return NULL;
    }

    rva = (DWORD)(addr - mi->BaseOfDll);

    comap = mi->cOmapFrom;
    pomapLow = mi->pOmapFrom;
    pomapHigh = pomapLow + comap;

    while (pomapLow < pomapHigh) {

        comapHalf = comap / 2;

        pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

        if (rva == pomapMid->rva) {
            return pomapMid;
        }

        if (rva < pomapMid->rva) {
            pomapHigh = pomapMid;
            comap = (comap & 1) ? comapHalf : (comapHalf - 1);
        } else {
            pomapLow = pomapMid + 1;
            comap = comapHalf;
        }
    }

    return NULL;
}


VOID
DumpOmapForModule(
    PMODULE_ENTRY      mi
    )
{
    POMAP pomap;
    DWORD i;

    i = sizeof(ULONG_PTR);
    i = sizeof(DWORD);

    if (!mi->pOmapFrom)
        return;

    dprint("\nOMAP FROM:\n");
    for(i = 0, pomap = mi->pOmapFrom;
        i < 100; // mi->cOmapFrom;
        i++, pomap++)
    {
        dprint("%8x %8x\n", pomap->rva, pomap->rvaTo);
    }

    if (!mi->pOmapTo)
        return;

    dprint("\nOMAP TO:\n");
    for(i = 0, pomap = mi->pOmapTo;
        i < 100; // mi->cOmapTo;
        i++, pomap++)
    {
        dprint("%8x %8x\n", pomap->rva, pomap->rvaTo);
    }
}


LPSTR
StringDup(
    LPSTR str
    )
{
    LPSTR ds = (LPSTR) MemAlloc( strlen(str) + 1 );
    if (ds) {
        strcpy( ds, str );
    }
    return ds;
}


BOOL
InternalGetModule(
    HANDLE  hProcess,
    LPSTR   ModuleName,
    DWORD64 ImageBase,
    DWORD   ImageSize,
    PVOID   Context
    )
{
    InternalLoadModule(
            hProcess,
            ModuleName,
            NULL,
            ImageBase,
            ImageSize,
            NULL,
            0,
            NULL
            );

    return TRUE;
}


BOOL
LoadedModuleEnumerator(
    HANDLE         hProcess,
    LPSTR          ModuleName,
    DWORD64        ImageBase,
    DWORD          ImageSize,
    PLOADED_MODULE lm
    )
{
    if (lm->EnumLoadedModulesCallback64) {
        return lm->EnumLoadedModulesCallback64( ModuleName, ImageBase, ImageSize, lm->Context );
    } else {
        return lm->EnumLoadedModulesCallback32( ModuleName, (DWORD)ImageBase, ImageSize, lm->Context );
    }
}


BOOL
ToggleFailCriticalErrors(
    BOOL reset
    )
{
    static UINT oldmode = 0;

    if (!(g.SymOptions & SYMOPT_FAIL_CRITICAL_ERRORS))
        return FALSE;

    if (reset)
        SetErrorMode(oldmode);
    else
        oldmode = SetErrorMode(SEM_FAILCRITICALERRORS);

    return TRUE;
}


DWORD
fnGetFileAttributes(
    LPCTSTR lpFileName
    )
{
    DWORD rc;

    SetCriticalErrorMode();
    rc = GetFileAttributes(lpFileName);
    ResetCriticalErrorMode();

    return rc;
}


LPSTR
SymUnDNameInternal(
    LPSTR UnDecName,
    DWORD UnDecNameLength,
    LPSTR DecName,
    DWORD DecNameLength,
    DWORD MachineType,
    BOOL  IsPublic
    )
{
    LPSTR p;
    ULONG Suffix;
    ULONG i;
    LPSTR TmpDecName;

    UnDecName[0] = 0;

    if (DecName[0] == '?' || !strncmp(DecName, ".?", 2) || !strncmp(DecName, "..?", 3)) {

        __try {

            if (DecName[0] == '.') {
                if (DecName[1] == '.') {
                    Suffix = 2;
                    UnDecName[0] = '.';
                    UnDecName[1] = '.';
                }  else { // DecName[1] = '?'
                    Suffix = 1;
                    UnDecName[0] = '.';
                }
            } else {  // DecName[0] = '?'
                Suffix = 0;
            }

            TmpDecName = (LPSTR)MemAlloc( 4096 );
            if (!TmpDecName) {
                strncat( UnDecName, DecName, min(DecNameLength,UnDecNameLength) );
                return UnDecName;
            }
            TmpDecName[0] = 0;
            strncat( TmpDecName, DecName+Suffix, DecNameLength );

            if (UnDecorateSymbolName( TmpDecName,
                                     UnDecName+Suffix,
                                     UnDecNameLength-Suffix,
                                     UNDNAME_NAME_ONLY ) == 0 ) {
                strncat( UnDecName, DecName, min(DecNameLength,UnDecNameLength) );
            }

            MemFree( TmpDecName );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            strncat( UnDecName, DecName, min(DecNameLength,UnDecNameLength) );

        }

    } else {

        __try {

            if ((IsPublic && (DecName[0] == '_' || DecName[0] == '.'))
                || DecName[0] == '@') {
                DecName += 1;
                DecNameLength -= 1;
            }

            p = 0;
            for (i = 0; i < DecNameLength; i++) {
                if (DecName [i] == '@') {
                    p = &DecName [i];
                    break;
                }
            }
            if (p) {
                i = (int)(p - DecName);
            } else {
                i = min(DecNameLength,UnDecNameLength);
            }

            strncat( UnDecName, DecName, i );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            strncat( UnDecName, DecName, min(DecNameLength,UnDecNameLength) );

        }
    }

    if (g.SymOptions & SYMOPT_NO_CPP) {
        while (p = strstr( UnDecName, "::" )) {
            p[0] = '_';
            p[1] = '_';
        }
    }

    return UnDecName;
}


BOOL
MatchSymName(
    LPSTR matchName,
    LPSTR symName
    )
{
    assert(matchName && symName);
    if (!*matchName || !*symName)
        return FALSE;

    if (g.SymOptions & SYMOPT_CASE_INSENSITIVE) {
        if (!_strnicmp(matchName, symName, MAX_SYM_NAME))
            return TRUE;
    } else {
        if (!strncmp(matchName, symName, MAX_SYM_NAME))
            return TRUE;
    }

    return FALSE;
}


PIMAGEHLP_SYMBOL
symcpy32(
    PIMAGEHLP_SYMBOL  External,
    PSYMBOL_ENTRY       Internal
    )
{
    External->Address      = (ULONG)Internal->Address;
    External->Size         = Internal->Size;
    External->Flags        = Internal->Flags;

    External->Name[0] = 0;
    strncat( External->Name, Internal->Name, External->MaxNameLength );

    return External;
}

PIMAGEHLP_SYMBOL64
symcpy64(
    PIMAGEHLP_SYMBOL64  External,
    PSYMBOL_ENTRY       Internal
    )
{
    External->Address      = Internal->Address;
    External->Size         = Internal->Size;
    External->Flags        = Internal->Flags;

    External->Name[0] = 0;
    strncat( External->Name, Internal->Name, External->MaxNameLength );

    return External;
}

BOOL
SympConvertSymbol64To32(
    PIMAGEHLP_SYMBOL64 Symbol64,
    PIMAGEHLP_SYMBOL Symbol32
    )
{
    Symbol32->Address = (DWORD)Symbol64->Address;
    Symbol32->Size = Symbol64->Size;
    Symbol32->Flags = Symbol64->Flags;
    Symbol32->MaxNameLength = Symbol64->MaxNameLength;
    Symbol32->Name[0] = 0;
    strncat( Symbol32->Name, Symbol64->Name, Symbol32->MaxNameLength );

    return (Symbol64->Address >> 32) == 0;
}

BOOL
SympConvertSymbol32To64(
    PIMAGEHLP_SYMBOL Symbol32,
    PIMAGEHLP_SYMBOL64 Symbol64
    )
{
    Symbol64->Address = Symbol32->Address;
    Symbol64->Size = Symbol32->Size;
    Symbol64->Flags = Symbol32->Flags;
    Symbol64->MaxNameLength = Symbol32->MaxNameLength;
    Symbol64->Name[0] = 0;
    strncat( Symbol64->Name, Symbol32->Name, Symbol64->MaxNameLength );

    return TRUE;
}

BOOL
SympConvertLine64To32(
    PIMAGEHLP_LINE64 Line64,
    PIMAGEHLP_LINE Line32
    )
{
    Line32->Key = Line64->Key;
    Line32->LineNumber = Line64->LineNumber;
    Line32->FileName = Line64->FileName;
    Line32->Address = (DWORD)Line64->Address;

    return (Line64->Address >> 32) == 0;
}

BOOL
SympConvertLine32To64(
    PIMAGEHLP_LINE Line32,
    PIMAGEHLP_LINE64 Line64
    )
{
    Line64->Key = Line32->Key;
    Line64->LineNumber = Line32->LineNumber;
    Line64->FileName = Line32->FileName;
    Line64->Address = Line32->Address;

    return TRUE;
}

BOOL
__stdcall
ReadInProcMemory(
    HANDLE    hProcess,
    DWORD64   addr,
    PVOID     buf,
    DWORD     bytes,
    DWORD    *bytesread
    )
{
    DWORD                    rc;
    PPROCESS_ENTRY           pe;
    IMAGEHLP_CBA_READ_MEMORY rm;

    rm.addr      = addr;
    rm.buf       = buf;
    rm.bytes     = bytes;
    rm.bytesread = bytesread;

    rc = FALSE;

    __try {
        pe = FindProcessEntry(hProcess);
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        if (pe->pCallbackFunction32) {
            rc = pe->pCallbackFunction32(pe->hProcess,
                                         CBA_READ_MEMORY,
                                         (PVOID)&rm,
                                         (PVOID)pe->CallbackUserContext);

        } else if (pe->pCallbackFunction64) {
            rc = pe->pCallbackFunction64(pe->hProcess,
                                         CBA_READ_MEMORY,
                                         (ULONG64)&rm,
                                         pe->CallbackUserContext);
        } else {
            SIZE_T RealBytesRead=0;
            rc = ReadProcessMemory(hProcess,
                                   (LPVOID)(ULONG_PTR)addr,
                                   buf,
                                   bytes,
                                   &RealBytesRead);
            *bytesread = (DWORD)RealBytesRead;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = FALSE;
    }

    return (rc != FALSE);
}

DWORD64
miGetModuleBase(
    HANDLE  hProcess,
    DWORD64 Address
    )
{
    IMAGEHLP_MODULE64 ModuleInfo = {0};
    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);

    if (SymGetModuleInfo64(hProcess, Address, &ModuleInfo)) {
        return ModuleInfo.BaseOfImage;
    } else {
        return 0;
    }
}

BOOL
GetPData(
    HANDLE        hp,
    PMODULE_ENTRY mi
    )
{
    BOOL status;
    ULONG cb;
    PCHAR pc;
    BOOL  fROM = FALSE;
    IMAGE_DOS_HEADER DosHeader;
    IMAGE_NT_HEADERS ImageNtHeaders;
    PIMAGE_FILE_HEADER ImageFileHdr;
    PIMAGE_OPTIONAL_HEADER ImageOptionalHdr;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    ULONG feCount = 0;
    ULONG i;

    HANDLE fh = 0;
    PCHAR  base = NULL;
    USHORT                       filetype;
    PIMAGE_SEPARATE_DEBUG_HEADER  sdh;
    PIMAGE_DOS_HEADER dh;
    PIMAGE_NT_HEADERS inth;
    PIMAGE_OPTIONAL_HEADER32 ioh32;
    PIMAGE_OPTIONAL_HEADER64 ioh64;
    ULONG cdd;
    PCHAR p;
    PIMAGE_DEBUG_DIRECTORY dd;
    ULONG cexp = 0;
    ULONG tsize;
    ULONG csize = 0;

    // if the pdata is already loaded, return

    if (mi->pExceptionData)
        return TRUE;

    if (!LoadSymbols(hp, mi, 0))
        return FALSE;

    // try to get pdata from dia

    if (mi->dia) {
        if ((mi->pPData) && (mi->dsExceptions == dsDia))
            goto dia;

        if (diaGetPData(mi)) {
            p = (PCHAR)mi->pPData;
            csize = mi->cbPData;
            goto dia;
        }
    }

    if (!mi->dsExceptions)
        return FALSE;

    // open the file and get the file type

    SetCriticalErrorMode();

    fh = CreateFile(mi->LoadedImageName,
                    GENERIC_READ,
                    g.OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE) : (FILE_SHARE_READ | FILE_SHARE_WRITE),
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    ResetCriticalErrorMode();

    if (fh == INVALID_HANDLE_VALUE)
        return FALSE;

    base = (PCHAR)MapItRO(fh);
    if (!base)
        goto cleanup;
    p = base;

    filetype = *(USHORT *)p;
    if (filetype == IMAGE_DOS_SIGNATURE)
        goto image;
    if (filetype == IMAGE_SEPARATE_DEBUG_SIGNATURE)
        goto dbg;
    goto cleanup;

image:

    // process disk-based image

    dh = (PIMAGE_DOS_HEADER)p;
    p  += dh->e_lfanew;
    inth = (PIMAGE_NT_HEADERS)p;

    if (inth->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        ioh32 = (PIMAGE_OPTIONAL_HEADER32)&inth->OptionalHeader;
        p = base + ioh32->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
        csize = ioh32->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;
    }
    else if (inth->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        ioh64 = (PIMAGE_OPTIONAL_HEADER64)&inth->OptionalHeader;
        p = base + ioh64->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
        csize = ioh64->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;
    }

dia:

    if (!csize)
        goto cleanup;

    switch (mi->MachineType)
    {
    case IMAGE_FILE_MACHINE_ALPHA:
        cexp = csize / sizeof(IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY);
        break;
    case IMAGE_FILE_MACHINE_ALPHA64:
        cexp = csize / sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY);
        break;
    case IMAGE_FILE_MACHINE_IA64:
        cexp = csize / sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY);
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        cexp = csize / sizeof(_IMAGE_RUNTIME_FUNCTION_ENTRY);
        break;
    default:
        goto cleanup;
    }

    goto table;

dbg:

    // process dbg file

    sdh = (PIMAGE_SEPARATE_DEBUG_HEADER)p;
    cdd = sdh->DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY);
    p +=  sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
          (sdh->NumberOfSections * sizeof(IMAGE_SECTION_HEADER)) +
          sdh->ExportedNamesSize;
    dd = (PIMAGE_DEBUG_DIRECTORY)p;

    for (i = 0; i < cdd; i++, dd++) {
        if (dd->Type == IMAGE_DEBUG_TYPE_EXCEPTION) {
            p = base + dd->PointerToRawData;
            cexp = dd->SizeOfData / sizeof(IMAGE_FUNCTION_ENTRY);
            break;
        }
    }

table:

    // parse the pdata into a table

    if (!cexp)
        goto cleanup;

    tsize = cexp * sizeof(IMGHLP_RVA_FUNCTION_DATA);

    mi->pExceptionData = (PIMGHLP_RVA_FUNCTION_DATA)VirtualAlloc( NULL, tsize, MEM_COMMIT, PAGE_READWRITE );

    if (mi->pExceptionData) {
        PIMGHLP_RVA_FUNCTION_DATA pIRFD = mi->pExceptionData;
        switch (mi->MachineType) {

        case IMAGE_FILE_MACHINE_ALPHA:
            if (filetype == IMAGE_SEPARATE_DEBUG_SIGNATURE) {
                // easy case.  The addresses are already in rva format.
                PIMAGE_FUNCTION_ENTRY pFE = (PIMAGE_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = pFE[i].StartingAddress;
                    pIRFD[i].rvaEndAddress       = pFE[i].EndingAddress;
                    pIRFD[i].rvaPrologEndAddress = pFE[i].EndOfPrologue;
                    pIRFD[i].rvaExceptionHandler = 0;
                    pIRFD[i].rvaHandlerData      = 0;
                }
            } else {
                PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = pRFE[i].BeginAddress - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaEndAddress       = pRFE[i].EndAddress - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaPrologEndAddress = pRFE[i].PrologEndAddress - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaExceptionHandler = pRFE[i].ExceptionHandler - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaHandlerData      = pRFE[i].HandlerData - (ULONG)mi->BaseOfDll;
                }
            }
            break;

        case IMAGE_FILE_MACHINE_ALPHA64:
            {
                PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = (DWORD)(pRFE[i].BeginAddress - mi->BaseOfDll);
                    pIRFD[i].rvaEndAddress       = (DWORD)(pRFE[i].EndAddress - mi->BaseOfDll);
                    pIRFD[i].rvaPrologEndAddress = (DWORD)(pRFE[i].PrologEndAddress - mi->BaseOfDll);
                    pIRFD[i].rvaExceptionHandler = (DWORD)(pRFE[i].ExceptionHandler - mi->BaseOfDll);
                    pIRFD[i].rvaHandlerData      = (DWORD)(pRFE[i].HandlerData - mi->BaseOfDll);
                }
            }
            break;

        case IMAGE_FILE_MACHINE_IA64:
            {
                PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = pRFE[i].BeginAddress;
                    pIRFD[i].rvaEndAddress       = pRFE[i].EndAddress;
                    pIRFD[i].rvaPrologEndAddress = pRFE[i].UnwindInfoAddress;
                    pIRFD[i].rvaExceptionHandler = 0;
                    pIRFD[i].rvaHandlerData      = 0;
                }
            }
            break;

        case IMAGE_FILE_MACHINE_AMD64:
            {
                _PIMAGE_RUNTIME_FUNCTION_ENTRY pRFE = (_PIMAGE_RUNTIME_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = pRFE[i].BeginAddress;
                    pIRFD[i].rvaEndAddress       = pRFE[i].EndAddress;
                    pIRFD[i].rvaPrologEndAddress = pRFE[i].UnwindInfoAddress;
                    pIRFD[i].rvaExceptionHandler = 0;
                    pIRFD[i].rvaHandlerData      = 0;
                }
            }
            break;

        default:
            break;
        }

        VirtualProtect( mi->pExceptionData, tsize, PAGE_READONLY, &i );

        mi->dwEntries = cexp;
    }

cleanup:

    if (mi->pPData) {
        MemFree(mi->pPData);
        mi->pPData = NULL;
    }

    if (base)
        UnmapViewOfFile(base);

    if (fh)
        CloseHandle(fh);

    return (cexp) ? TRUE : FALSE;
}

BOOL
GetXData(
    HANDLE        hp,
    PMODULE_ENTRY mi
    )
{
    if (mi->pXData)
        return TRUE;

    if (LoadSymbols(hp, mi, 0) && !mi->pXData && mi->dia && !diaGetXData(mi))
        return FALSE;

    return (mi->pXData != NULL);
}

PVOID
GetXDataFromBase(
    HANDLE     hp,
    DWORD64    base,
    ULONG_PTR* size
    )
{
    PPROCESS_ENTRY pe;
    PMODULE_ENTRY  mi;

    pe = FindProcessEntry(hp);
    if (!pe) {
        SetLastError(ERROR_INVALID_HANDLE);
        return NULL;
    }

    mi = GetModuleForPC(pe, base, FALSE);
    if (!mi) {
        SetLastError(ERROR_MOD_NOT_FOUND);
        return NULL;
    }

    if (!GetXData(hp, mi))
        return NULL;

    if (size) *size = mi->cbXData;
    return mi->pXData;
}

PVOID
GetUnwindInfoFromSymbols(
    HANDLE     hProcess,
    DWORD64    ModuleBase,
    ULONG      UnwindInfoAddress,
    ULONG_PTR* Size
    )
{
    ULONG_PTR XDataSize;

    PBYTE pXData = (PBYTE)GetXDataFromBase(hProcess, ModuleBase, &XDataSize);
    if (!pXData)
        return NULL;

    DWORD DataBase = *(DWORD*)pXData;
    pXData += sizeof(DWORD);

    if (DataBase > UnwindInfoAddress)
        return NULL;

    ULONG_PTR Offset = UnwindInfoAddress - DataBase;

    if (Offset >= XDataSize)
        return NULL;

    if (Size) *Size = XDataSize - Offset;
    return pXData + Offset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\symchk.c ===
#include "symutil.h"


typedef struct _FILE_INFO {
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    TCHAR       szName[MAX_PATH];
} FILE_INFO, *PFILE_INFO;


typedef struct _COMMAND_ARGS {
    LPTSTR  szDir;                  // Directory where source files exist
    LPTSTR  szFileName;             // File name(s) to copy
    FILE *  hSymCDLog;              // SymbolsCD log file
    BOOL  Recurse;                  // Recurse in subdirectories
    LPTSTR  szSymPath;              // Directory where symbols exist
    LPTSTR  szExcludeFileName;      // File name with list of files to exclude
                                    // from symbol checking
    LPTSTR  szListFileName;         // File containing a list of files to check
    DWORD   Split;                  // TRUE - check for split images
                                    // FALSE - check for non-split images
    BOOL  Verbose;                // Print info for every file checked,
    //  not just the ones that fail
    LPTSTR  szErrorFilterList;      // Don't print errors for these files
    LPTSTR  szCDIncludeList;        // Full path to symbols that should get
                                    // written to the list that is used for creating
                                    // the symbol CD.  Originally used for
                                    // international incremental builds
} COM_ARGS, *PCOM_ARGS;

typedef struct _FILE_COUNTS {
    DWORD   NumPassedFiles;
    DWORD   NumIgnoredFiles;
    DWORD   NumFailedFiles;
} FILE_COUNTS, *PFILE_COUNTS;

// Prototypes

PCOM_ARGS
GetCommandLineArgs(
                  int argc,
                  char **argv
                  );

VOID
Usage (
      VOID
      );

DWORD
CheckDirectory(
              LPTSTR szDir,
              LPTSTR szFName,
              LPTSTR szSymPath,
              FILE*  hSymCDLog,
              PEXCLUDE_LIST pExcludeList,
              PFILE_COUNTS pFileCounts,
              DWORD Split
              );

DWORD
CheckAllDirectories(
                   LPTSTR szDir,
                   LPTSTR szFName,
                   LPTSTR szSymPath,
                   FILE*  hSymCDLog,
                   PEXCLUDE_LIST pExcludeList,
                   PFILE_COUNTS pFileCounts,
                   DWORD Split
                   );

BOOL
CorrectPath(
           LPTSTR szFileName,
           LPTSTR szPathName,
           LPTSTR szCorrectPath
           );

// Global variables

BOOL Verbose = 0;
BOOL Retail = TRUE;

int
_cdecl
main( int argc, char **argv)
{
    PCOM_ARGS pArgs;
    DWORD NumBadFiles=0;
    DWORD NumExcludeFiles=0;

    DWORD i;
    PEXCLUDE_LIST pExcludeList = NULL;
    FILE_COUNTS FileCounts;

    SYM_ERR SymErr;
    TCHAR ErrMsg[MAX_SYM_ERR];
    HFILE hListFile;

    P_LIST FileList;

    pArgs = GetCommandLineArgs(argc, argv);
    Verbose = (BOOL)pArgs->Verbose;

    memset( &SymErr, 0, sizeof(SymErr) );
    memset( &FileCounts, 0, sizeof(FILE_COUNTS) );

    if ( pArgs->szExcludeFileName != NULL ) {
        pExcludeList = GetExcludeList(pArgs->szExcludeFileName);
    }

    if ( pArgs->szErrorFilterList != NULL ) {
        pErrorFilterList = GetExcludeList(pArgs->szErrorFilterList);
    }

    if ( pArgs->szCDIncludeList != NULL ) {
        pCDIncludeList = GetList( pArgs->szCDIncludeList );
    }

    // This is the section for creating the symbols CD.
    if ( pArgs->szListFileName != NULL ) {

        FileList = GetList(pArgs->szListFileName);
        if ( FileList == NULL ) {
            printf(" Cannot open the file list %s\n", pArgs->szListFileName);
            exit(1);
        }

        if ( FileList->dNumFiles == 0 ) goto finish;

        // Do the first one, so we don't have to check for it inside the loop
        if ( CorrectPath(FileList->List[0].FName, FileList->List[0].Path, pArgs->szDir) ) {
            NumBadFiles += CheckDirectory(
                                         pArgs->szDir,
                                         FileList->List[0].FName,
                                         pArgs->szSymPath,
                                         pArgs->hSymCDLog,
                                         pExcludeList,
                                         &FileCounts,
                                         pArgs->Split
                                         );
        }

        for ( i=1; i< FileList->dNumFiles; i++) {

            // There may be some duplicates in the list ... skip them
            // Also, only check the files that are in the path given on the command line

            if ( (_tcsicmp(FileList->List[i].Path, FileList->List[i-1].Path) != 0)  &&
                 CorrectPath(FileList->List[i].FName, FileList->List[i].Path, pArgs->szDir) ) {

                NumBadFiles += CheckDirectory(
                                             pArgs->szDir,
                                             FileList->List[i].FName,
                                             pArgs->szSymPath,
                                             pArgs->hSymCDLog,
                                             pExcludeList,
                                             &FileCounts,
                                             pArgs->Split
                                             );
            }
        }
    }
    else {
        if ( !pArgs->Recurse ) {
            NumBadFiles += CheckDirectory(
                                         pArgs->szDir,
                                         pArgs->szFileName,
                                         pArgs->szSymPath,
                                         pArgs->hSymCDLog,
                                         pExcludeList,
                                         &FileCounts,
                                         pArgs->Split
                                         );
        } else {
            NumBadFiles += CheckAllDirectories(
                                              pArgs->szDir,
                                              pArgs->szFileName,
                                              pArgs->szSymPath,
                                              pArgs->hSymCDLog,
                                              pExcludeList,
                                              &FileCounts,
                                              pArgs->Split
                                              );
        }

        // CheckDirectory just returns the number of failed and passed.  If
        // no files failed or passed, then report that we couldn't find the
        // file.

        if ( (FileCounts.NumFailedFiles + FileCounts.NumPassedFiles) == 0 ) {
            _tcscpy( SymErr.szFileName, pArgs->szFileName );
            SymErr.Verbose=pArgs->Verbose;
            if (InExcludeList(SymErr.szFileName, pExcludeList) ) {
                LogError(ErrMsg, &SymErr, IMAGE_PASSED );
                FileCounts.NumPassedFiles=1;
            } else {
                LogError(ErrMsg, &SymErr, FILE_NOT_FOUND);
                FileCounts.NumFailedFiles=1;
            }
            if ( _tcscmp(ErrMsg, "") != 0 ) {
                printf("SYMCHK: %s",ErrMsg);
            }
        }
    }

    finish:

    if (pArgs->hSymCDLog) fclose(pArgs->hSymCDLog);

    free(pArgs->szDir);
    free(pArgs->szFileName);
    free(pArgs);

    printf("\nSYMCHK: FAILED files = %d\n",FileCounts.NumFailedFiles);
    printf("SYMCHK: PASSED + IGNORED files = %d\n",FileCounts.NumPassedFiles);

    if ( FileCounts.NumFailedFiles > 0 ) {
        return(1);
    } else {
        return(0);
    }
}

DWORD
CheckAllDirectories(
                   LPTSTR szDir,
                   LPTSTR szFName,
                   LPTSTR szSymPath,
                   FILE*  hSymCDLog,
                   PEXCLUDE_LIST pExcludeList,
                   PFILE_COUNTS pFileCounts,
                   DWORD Split
                   )

{
    HANDLE hFindFile;
    TCHAR szCurPath[_MAX_PATH];
    BOOL Found = FALSE;
    DWORD NumBadFiles=0;

    WIN32_FIND_DATA FindFileData;
    LPTSTR szF = NULL;
    LPTSTR szE = NULL;

    FILE_COUNTS FileCounts;

    NumBadFiles += CheckDirectory(szDir,
                                  szFName,
                                  szSymPath,
                                  hSymCDLog,
                                  pExcludeList,
                                  pFileCounts,
                                  Split
                                 );

    // Look for all the subdirectories
    _tcscpy(szCurPath, szDir);
    _tcscat(szCurPath, _T("\\*.*") );

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szCurPath, &FindFileData);
    if ( hFindFile == INVALID_HANDLE_VALUE) {
        Found = FALSE;
    }

    while ( Found ) {
        if ( FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            if ( !_tcscmp(FindFileData.cFileName, _T(".")) ||
                 !_tcscmp(FindFileData.cFileName, _T("..")) ||
                 !_tcsicmp(FindFileData.cFileName, _T("symbols")) ) {
                // Don't process these directories
            } else {
                // Get the current path that we are searching in
                _tcscpy(szCurPath, szDir);
                _tcscat(szCurPath, _T("\\"));
                _tcscat(szCurPath, FindFileData.cFileName);

                NumBadFiles += CheckAllDirectories(
                                                  szCurPath,
                                                  szFName,
                                                  szSymPath,
                                                  hSymCDLog,
                                                  pExcludeList,
                                                  pFileCounts,
                                                  Split
                                                  );
            }
        }
        Found = FindNextFile(hFindFile, &FindFileData);
    }
    FindClose(hFindFile);
    return(NumBadFiles);
}

DWORD
CheckDirectory(
              LPTSTR szDir,
              LPTSTR szFName,
              LPTSTR szSymPath,
              FILE * hSymCDLog,
              PEXCLUDE_LIST pExcludeList,
              PFILE_COUNTS pFileCounts,
              DWORD Split
              )

{
    HANDLE hFindFile;
    TCHAR szFileName[_MAX_PATH];
    TCHAR szCurPath[_MAX_PATH];
    TCHAR szCurFileName[_MAX_PATH];
    BOOL Found;
    DWORD NumBadFiles=0;
    DWORD NumGoodFiles=0;

    WIN32_FIND_DATA FindFileData;
    SYM_ERR SymErr;
    TCHAR ErrMsg[MAX_SYM_ERR];

    memset( &SymErr, 0, sizeof(SymErr) );

    // Create the file name
    _tcscpy(szFileName, szDir);
    _tcscat(szFileName, _T("\\") );
    _tcscat(szFileName, szFName);

    // Get the current path that we are searching in
    _tcscpy(szCurPath, szDir);

    Found = TRUE;
    hFindFile = FindFirstFile((LPCTSTR)szFileName, &FindFileData);
    if ( hFindFile == INVALID_HANDLE_VALUE ) {
        Found = FALSE;
    }

    while ( Found ) {
        // Found a file, not a directory
        if ( !(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            _tcscpy(szCurFileName, szCurPath);
            _tcscat(szCurFileName,_T("\\") );
            _tcscat(szCurFileName, FindFileData.cFileName );

            // Its not in the exclude list, go ahead and test it

            if (!InExcludeList(FindFileData.cFileName,pExcludeList ) ) {

                if ( !CheckSymbols( ErrMsg,
                                    szSymPath,
                                    szCurFileName,
                                    hSymCDLog,
                                    Split,
                                    Verbose,
                                    NULL ) ) {
                    pFileCounts->NumFailedFiles++;
                    NumBadFiles++;
                } else {
                    pFileCounts->NumPassedFiles++;
                }
            }

            // It is in the exclude list, add it to NumPassed Files
            else {
                pFileCounts->NumPassedFiles++;
                _tcscpy(SymErr.szFileName, szCurFileName);
                SymErr.Verbose = Verbose;
                LogError(ErrMsg, &SymErr, IMAGE_PASSED);
            }
            if ( _tcscmp(ErrMsg,"") != 0 ) {
                printf("SYMCHK: %s", ErrMsg);
            }
        }
        Found = FindNextFile(hFindFile, &FindFileData);
    }
    FindClose(hFindFile);
    return(NumBadFiles);
}


VOID
Usage (
      VOID
      )

{
    puts("\n"
         "Usage:  symchk [switches] file /s sympath \n\n"
         "    file        Name of file(s) or directory to check.\n"
         "                Can include wildcards.\n\n"
         "    [/b]        For NT4 Service Packs -- don't complain if\n"
         "                there is no CodeView data\n"
         "    [/e file]   File containing a list of files to exclude.\n"
         "                This file can have one name per line. Comment\n"
         "                lines begin with a ; . \n\n"
         "    [/p]        Check that private information is removed.\n"
         "    [/c dest]   Create an inf for the symbols CD\n\n"
         "    [/r]        Recurse into subdirectories.  This uses the\n"
         "                Windows 2000 build model and assumes that the\n"
         "                first subdirectory to traverse into is the retail\n"
         "                directory.  Example sympath: \"E:\\binaries\\symbols\" .\n"
         "                All subdirectories except \"symbols\" will be checked.\n\n"
         "    /s sympath  symbol path delimited by ; .  Checks sympath\n"
         "                and sympath\\ext for each string in the path, \n"
         "                where ext is the extension of the executable.\n\n"
         "    [/t]        Fail if a DBG file is involved.  Fails if the image points\n"
         "                to a dbg file or if it contains data that can be stripped\n"
         "                into a dbg file.  Default is to fail if data can be stripped\n"
         "                into a dbg file, but don't fail if the image points to a\n"
         "                dbg file.\n\n"
         "    [/u]        Fail if image points to a dbg file. Don't fail if image\n"
         "                contains data that can be split into a dbg file.\n\n"
         "    [/v]        Give verbose information\n"
         "    [/x]        Used with /c. Perform symbol checking on these files and\n"
         "                add the correct symbols to the symbol CD's inf, but\n"
         "                don't write error messages for the ones that are wrong.\n\n"
        );

    exit(1);

    // The purpose of /x is to not log errors for symbols in symbad.txt.  However, symchk
    // should check all of the files in symbad.txt when it is creating the list of file
    // in case some of them actually have correct symbols and symbad hasn't been updated yet.
}


PCOM_ARGS
GetCommandLineArgs(
                  int argc,
                  char **argv
                  )

{
    PCOM_ARGS pArgs;
    int i,cur,length;
    TCHAR c;
    BOOL NeedSecond = FALSE;
    BOOL Exclude = FALSE;

    LPTSTR szFileArg = NULL;
    TCHAR  szDrive[_MAX_DRIVE + 1];
    TCHAR  szDir[_MAX_DIR + 1];
    TCHAR  szFileName[_MAX_FNAME + 1];
    TCHAR  szExt[_MAX_EXT + 1];
    TCHAR  szNameExt[_MAX_FNAME + _MAX_EXT + 1];
    LPTSTR szSymCDLog = NULL;
    LPTSTR szSymbolsCDFile = NULL;

    HANDLE fHandle;
    WIN32_FIND_DATA FindFileData;

    if (argc == 1) Usage();

    if (!(pArgs = (PCOM_ARGS)malloc(sizeof(COM_ARGS))))
    {
        printf("No memory");
        exit(1);
    }

    memset( pArgs, 0, sizeof(COM_ARGS) );
    pArgs->Split = 0;
    pArgs->szListFileName = NULL;
    pArgs->szCDIncludeList = NULL;

    CheckPrivate = FALSE;

    for (i=1; i<argc; i++) {

        if (!NeedSecond) {
            if ( (argv[i][0] == '/') || (argv[i][0] == '-') ) {
                length = _tcslen(argv[i]) -1;

                for (cur=1; cur <= length; cur++) {
                    c = argv[i][cur];

                    switch (c) {
                        case 'c':   NeedSecond = TRUE;
                            break;
                        case 'b':   CheckCodeView=FALSE;
                            NeedSecond = FALSE;
                            break;
                        case 'e':   Exclude = TRUE;
                            NeedSecond = TRUE;
                            if ( length > cur) Usage();
                            break;
                        case 'l':   NeedSecond = TRUE;
                            break;
                        case 'p':   NeedSecond = FALSE;
                            CheckPrivate = TRUE;
                            break;
                        case 'r':   pArgs->Recurse = TRUE;
                            Recurse = TRUE;
                            break;
                        case 's':   NeedSecond = TRUE;
                            if ( length > cur) Usage();
                            break;
                        case 't':   
                            pArgs->Split |= ERROR_IF_NOT_SPLIT;
                            pArgs->Split |= ERROR_IF_SPLIT;
                            break;
                        case 'u':   pArgs->Split |= ERROR_IF_SPLIT;
                            break;
                        case 'v':   pArgs->Verbose = TRUE;
                            break;
                        case 'x':   NeedSecond = TRUE;
                            break;
                        case 'y':   NeedSecond = TRUE;
                            break;
                        default:    Usage();
                    }
                }
            } else {
                if (szFileArg != NULL) Usage();
                szFileArg = argv[i];
            }
        } else {
            NeedSecond = FALSE;
            switch (c) {
                case 'c':   szSymbolsCDFile = argv[i];
                    break;
                case 'e':   pArgs->szExcludeFileName = argv[i];
                    break;
                case 'l':   pArgs->szListFileName = argv[i];
                    break;
                case 's':   pArgs->szSymPath = argv[i];
                    break;
                case 'x':   pArgs->szErrorFilterList = argv[i];
                    break;
                case 'y':   pArgs->szCDIncludeList = argv[i];
                    break;
                default:    Usage();

            }
        }
    }
    if ( pArgs->Split == 0 ) {
        // This has always been the default behavior
        pArgs->Split = ERROR_IF_NOT_SPLIT;
    }

    if ( szFileArg == NULL ) Usage();

    // make the Symbol Copy log for the Support Tools CD
    if ( szSymbolsCDFile != NULL ) {

        if (  (pArgs->hSymCDLog = fopen(szSymbolsCDFile, "a+")) == NULL ) {
            printf("Cannot open %s for appending\n",szSymbolsCDFile);
            exit(1);
        }
    }


    // Get the filenames so they are correct
    _tsplitpath( szFileArg, szDrive, szDir, szFileName, szExt );

    // Get current directory if they didn't enter a directory
    if ( !_tcscmp(szDrive, "") && !_tcscmp(szDir,"") ) {
        GetCurrentDirectory(_MAX_DIR, szDir);
    }

    // If szFileName and szExt are "" then put *.* in them
    if ( !_tcscmp(szFileName,"") && !_tcscmp(szExt,"") ) {
        _tcscpy(szFileName,"*");
    }

    // User may have entered a directory with an implies * for the
    // file name.
    fHandle = FindFirstFile( szFileArg, &FindFileData );

    _tcscpy(szNameExt, szFileName);
    _tcscat(szNameExt, szExt);

    // If its a directory and the name of the directory matches
    // the filename.ext from the command line parameter, then the user
    // entered a directory, so add * to the end.

    if ( (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
         (_tcscmp( szNameExt, FindFileData.cFileName )== 0)  ) {

        // Move the filename to be the dir
        _tcscat( szDir, "\\");
        _tcscat( szDir, szFileName);

        // Put the file name as *
        _tcscpy(szFileName, "*");
    }

    pArgs->szDir=(LPTSTR) malloc( sizeof(TCHAR)* _MAX_PATH + 1 );
    _tmakepath( pArgs->szDir, szDrive, szDir, NULL, NULL);

    pArgs->szFileName = (LPTSTR) malloc( sizeof(TCHAR) * _MAX_PATH + 1 );
    _tmakepath(pArgs->szFileName, NULL, NULL, szFileName, szExt);


    // Check that everything has been entered
    if (NeedSecond ||
        (pArgs->szFileName == NULL) ||
        (pArgs->szDir == NULL)      ||
        (pArgs->szSymPath == NULL) )
    {
        Usage();
    }

    return (pArgs);
}

BOOL
CorrectPath(
           LPTSTR szFileName,
           LPTSTR szPathName,
           LPTSTR szCorrectPath
           )
{
    // To return TRUE, szPathName should equal szCorrectPath + \ + szFileName
    // The only hitch is that there could be extraneous \'s

    TCHAR CorrectPathx[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];
    TCHAR PathNamex[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];

    LONG length, index, i;

    // Get rid of any extra \'s
    length = _tcslen(szPathName);
    PathNamex[0] = szPathName[0];
    index = 1;
    for (i=1; i<=length; i++) {
        if ( (szPathName[i-1] != '\\') || (szPathName[i] != '\\') ) {
            PathNamex[index] = szPathName[i];
            index++;
        }
    }

    length = _tcslen(szCorrectPath);
    CorrectPathx[0] = szCorrectPath[0];
    index = 1;
    for (i=1; i<=length; i++) {
        if ( (szCorrectPath[i-1] != '\\') || (szCorrectPath[i] != '\\') ) {
            CorrectPathx[index] = szCorrectPath[i];
            index++;
        }
    }

    // Make sure that the correct path doesn't end in a '\'
    length = _tcslen(CorrectPathx);
    if ( CorrectPathx[length-1] == '\\' ) CorrectPathx[length-1] = '\0';

    _tcscat(CorrectPathx,"\\");
    _tcscat(CorrectPathx,szFileName);

    if ( _tcsicmp(CorrectPathx, szPathName) == 0) return TRUE;
    else return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\tracepdb.c ===
//TracePDB - Extracts trace information from the PDB
// This small tool is used to extract the same trace information that binplace does, but can be used 'after the fact'
// that is if you have the full symbols PDB but no trace information, TracePDB can generate the trace
// tmf and tmc files for you.

#ifdef __cplusplus
extern "C"{
#endif

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include "wppfmt.h"


int _cdecl main(int argc, char** argv)
{
    DWORD status;
    TCHAR lppath[MAX_PATH] ;
    TCHAR pdbname[MAX_PATH] ;
    INT len, targv=0 ;
    BOOL Verbose = FALSE ;
    BOOL bPDBName = FALSE ;
    LPSTR szRSDSDllToLoad = NULL;

    TCHAR helptext[] = "Usage: TracePDB  -f <pdbname> [-p <path>]  [-v]\n"
                       "       Options:\n"
//                     "         -r recurse into subdirectories\n"
                       "         -f specifies the PDBName from which to extract tmf's\n"
                       "         -p specifies the path to create the tmf's,\n"
                       "                by default the current directory.\n"
                       "         -v verbose, displays actions taken \n"  ;



    if (GetCurrentDirectory(MAX_PATH,lppath) == 0 ) {
       printf("TracePDB: no current directory\n") ;
       exit(-1);
    }


    while (--argc > 0) {
        ++targv;
        if (argv[targv][0] == '-' || argv[targv][0] == '/') {  // argument found

            if (argv[targv][1] == 'h' || argv[targv][1] == 'H'
                                      || argv[targv][1] == '?')
            {
                printf(helptext);
                return 1;
            } else if (argv[targv][1] == 'f') {
                if (--argc >0 ) {
                    ++targv ;
                    if ((strlen(argv[targv])+1) > MAX_PATH) {
                        printf("TracePDB: PDBname toolarge\n");
                        exit(-1);
                    }
                    strncpy(pdbname,argv[targv],strlen(argv[targv])+1);
                    bPDBName = TRUE ;
                }
            } else if (argv[targv][1] == 'p') {
                if (--argc >0 ) {
                    ++ targv ;
                    if ((strlen(argv[targv])+1) > MAX_PATH) {
                        printf("TracePDB: Path larger than MAX_PATH\n");
                        exit(-1);
                    }
                    strncpy(lppath,argv[targv],strlen(argv[targv])+1);
                }
            } else if (argv[targv][1] == 'v') {
                Verbose = TRUE ;
            } else {
                printf(helptext);
            }
        }
    }

    if (!bPDBName) {
        printf("TracePDB: No PDB specified?\n\n%s",helptext);
        return (1);
    }

    if ((szRSDSDllToLoad = (LPSTR) malloc(MAX_PATH+1)) == NULL) {
        printf("TracePDB: malloc failed\n");
        return FALSE ;
    }
    strcpy( szRSDSDllToLoad, "mspdb70.dll");

    status = BinplaceWppFmt(pdbname,
                            lppath,
                            szRSDSDllToLoad,
                            TRUE  // always verbose
                            ) ;

    if (status != ERROR_SUCCESS) {
        printf("TracePDB: failed with error %d\n", status);
    }

    return 0;
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\symbols.h ===
//
// defines for symbol file searching
//

#include <dbgimage.h>

// this private API is in msdia20-msvcrt.lib 

HRESULT
__cdecl
CompareRE(
    const wchar_t* pStr,
    const wchar_t* pRE,
    BOOL fCase
    );

#define SYMBOL_PATH             "_NT_SYMBOL_PATH"
#define ALTERNATE_SYMBOL_PATH   "_NT_ALT_SYMBOL_PATH"
#define SYMBOL_SERVER           "_NT_SYMBOL_SERVER"
#define SYMSRV                  "SYMSRV"
#define WINDIR                  "windir"
#define DEBUG_TOKEN            "DBGHELP_TOKEN"
#define HASH_MODULO             253
#define OMAP_SYM_EXTRA          1024
#define CPP_EXTRA               2
#define OMAP_SYM_STRINGS        (OMAP_SYM_EXTRA * 256)
#define TMP_SYM_LEN             4096

// Possibly truncates and sign-extends a value to 64 bits.
#define EXTEND64(Val) ((ULONG64)(LONG64)(LONG)(Val))

//
// structures
//

typedef struct _LOADED_MODULE {
    PENUMLOADED_MODULES_CALLBACK      EnumLoadedModulesCallback32;
    PENUMLOADED_MODULES_CALLBACK64      EnumLoadedModulesCallback64;
    PVOID                               Context;
} LOADED_MODULE, *PLOADED_MODULE;

#define SYMF_DUPLICATE    0x80000000
#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED
#define SYMF_USER_GENERATED   0x00000004
#endif // !_DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED

typedef struct _SYMBOL_ENTRY {
    struct _SYMBOL_ENTRY        *Next;
    DWORD                       Size;
    DWORD                       Flags;
    DWORD64                     Address;
    LPSTR                       Name;
    ULONG                       NameLength;

    ULONG                       Segment;
    ULONG64                     Offset;
    ULONG                       TypeIndex;
    ULONG64                     ModBase;
    ULONG                       Register;
} SYMBOL_ENTRY, *PSYMBOL_ENTRY;

typedef struct _SECTION_START {
    ULONG64                     Offset;
    DWORD                       Size;
    DWORD                       Flags;
} SECTION_START, *PSECTION_START;

//
// source file and line number information
//
typedef struct _SOURCE_LINE {
    DWORD64             Addr;
    DWORD               Line;
} SOURCE_LINE, *PSOURCE_LINE;

typedef struct _SOURCE_ENTRY {
    struct _SOURCE_ENTRY       *Next;
    struct _SOURCE_ENTRY       *Prev;
    DWORD64                     MinAddr;
    DWORD64                     MaxAddr;
    LPSTR                       File;
    DWORD                       Lines;
    PSOURCE_LINE                LineInfo;
    ULONG                       ModuleId;
} SOURCE_ENTRY, *PSOURCE_ENTRY;

//
// Error values for failed symbol load
//
#define SYMLOAD_OK              0x0000
#define SYMLOAD_PDBUNMATCHED    0x0001
#define SYMLOAD_PDBNOTFOUND     0x0002
#define SYMLOAD_DBGNOTFOUND     0x0003
#define SYMLOAD_OTHERERROR      0x0004
#define SYMLOAD_OUTOFMEMORY     0x0005
#define SYMLOAD_HEADERPAGEDOUT  0x0006
#define SYMLOAD_PDBERRORMASK    0xff00
#define SYMLOAD_DEFERRED        0x80000000

//
// module flags
//
#define MIF_DEFERRED_LOAD   0x00000001
#define MIF_NO_SYMBOLS      0x00000002
#define MIF_ROM_IMAGE       0x00000004

// for ImageSrc and PdbSrc elements

typedef enum  {
    srcNone = 0,
    srcSearchPath,
    srcImagePath,
    srcDbgPath,
    srcSymSrv,
    srcCVRec,
    srcHandle,
    srcMemory
};

typedef struct _MODULE_ENTRY {
    LIST_ENTRY                      ListEntry;
    ULONG64                         BaseOfDll;
    ULONG                           DllSize;
    ULONG                           TimeDateStamp;
    ULONG                           CheckSum;
    USHORT                          MachineType;
    CHAR                            ModuleName[64];
    CHAR                            AliasName[64];
    PSTR                            ImageName;
    PSTR                            LoadedImageName;
    PSTR                            LoadedPdbName;
    ULONG                           ImageType;
    ULONG                           ImageSrc;
    ULONG                           PdbSrc;
    PSYMBOL_ENTRY                   symbolTable;
    LPSTR                           SymStrings;
    PSYMBOL_ENTRY                   NameHashTable[HASH_MODULO];
    ULONG                           numsyms;
    ULONG                           MaxSyms;
    ULONG                           StringSize;
    SYM_TYPE                        SymType;
    PDB *                           pdb;
    DBI *                           dbi;
    GSI *                           gsi;
    GSI *                           globals;
    TPI *                           ptpi;
    PIMAGE_SECTION_HEADER           SectionHdrs;
    ULONG                           NumSections;
    PFPO_DATA                       pFpoData;       // pointer to fpo data (x86)
    PFPO_DATA                       pFpoDataOmap;  // pointer to fpo data (x86)
    PIMGHLP_RVA_FUNCTION_DATA       pExceptionData; // pointer to pdata (risc)
    PVOID                           pPData;         // pdata acquired from pdb
    PVOID                           pXData;         // xdata acquired from pdb
    ULONG                           dwEntries;      // # of fpo or pdata recs
    ULONG                           cPData;         // number of pdb pdata entries
    ULONG                           cXData;         // number of pdb xdata entries
    ULONG                           cbPData;        // size of pdb xdata blob
    ULONG                           cbXData;        // size of pdb xdata blob
    POMAP                           pOmapFrom;      // pointer to omap data
    ULONG                           cOmapFrom;      // count of omap entries
    POMAP                           pOmapTo;        // pointer to omap data
    ULONG                           cOmapTo;        // count of omap entries
    SYMBOL_ENTRY                    TmpSym;         // used only for pdb symbols
    SYMBOL_INFO                     si;             // used for dia symbols
    UCHAR                           siName[2048];   // must be contiguous with si
    ULONG                           Flags;
    HANDLE                          hFile;
    PIMAGE_SECTION_HEADER           OriginalSectionHdrs;
    ULONG                           OriginalNumSections;
    PSOURCE_ENTRY                   SourceFiles;
    PSOURCE_ENTRY                   SourceFilesTail;

    HANDLE                          hProcess;
    ULONG64                         InProcImageBase;
    BOOL                            fInProcHeader;
    DWORD                           dsExceptions;
    Mod                            *mod;
    USHORT                          imod;
    PBYTE                           pPdbSymbols;
    DWORD                           cbPdbSymbols;
    ULONG                           SymLoadError;
    ULONG                           code;           // used to pass back info to wrappers
    PVOID                           dia;
    CHAR                            SrcFile[_MAX_PATH + 1];
    DWORD                           CallerFlags;
    MODLOAD_DATA                    mld; 
    PVOID                           CallerData;
} MODULE_ENTRY, *PMODULE_ENTRY;

typedef VOID DBG_CONTEXT, *PDBG_CONTEXT;

#ifdef USE_CACHE

#define CACHE_BLOCK 40
#define CACHE_SIZE CACHE_BLOCK*CACHE_BLOCK

typedef struct _DIA_LARGE_DATA {
    BOOL Used;
    ULONG Index;
    ULONG LengthUsed;
    CHAR Bytes[500];
} DIA_LARGE_DATA, *PDIA_LARGE_DATA;

#define DIACH_ULVAL  0
#define DIACH_ULLVAL 1
#define DIACH_PLVAL  2
typedef struct _DIA_CACHE_DATA {
    ULONG type;
    union {
        ULONG ulVal;
        ULONGLONG ullVal;
        PDIA_LARGE_DATA plVal;
    };
} DIA_CACHE_DATA, *PDIA_CACHE_DATA;

typedef struct _DIA_CACHE_ENTRY {
    ULONG Age;
    union {
        struct {
            ULONG TypeId;
            IMAGEHLP_SYMBOL_TYPE_INFO DataType;
        } s;
        ULONGLONG SearchId;
    };
    ULONGLONG Module;
    DIA_CACHE_DATA Data;
} DIA_CACHE_ENTRY, *PDIA_CACHE_ENTRY;
#endif // USE_CACHE

typedef struct _PROCESS_ENTRY {
    LIST_ENTRY                      ListEntry;
    LIST_ENTRY                      ModuleList;
    ULONG                           Count;
    HANDLE                          hProcess;
    DWORD                           pid;
    LPSTR                           SymbolSearchPath;
    PSYMBOL_REGISTERED_CALLBACK     pCallbackFunction32;
    PSYMBOL_REGISTERED_CALLBACK64   pCallbackFunction64;
    ULONG64                         CallbackUserContext;
    PSYMBOL_FUNCENTRY_CALLBACK      pFunctionEntryCallback32;
    PSYMBOL_FUNCENTRY_CALLBACK64    pFunctionEntryCallback64;
    ULONG64                         FunctionEntryUserContext;
    PIMAGEHLP_CONTEXT               pContext;
    IMAGEHLP_STACK_FRAME            StackFrame;
    PMODULE_ENTRY                   ipmi;
#ifdef USE_CACHE
    DIA_LARGE_DATA                  DiaLargeData[2*CACHE_BLOCK];
    DIA_CACHE_ENTRY                 DiaCache[CACHE_SIZE];
#endif // USE_CACHE
} PROCESS_ENTRY, *PPROCESS_ENTRY;


// debug trace facility

int
WINAPIV
_pprint(
    PPROCESS_ENTRY ProcessEntry,
    LPSTR          Format,
    ...
    );

int
WINAPIV
_peprint(
    PPROCESS_ENTRY ProcessEntry,
    LPSTR Format,
    ...
    );

int
WINAPIV
_dprint(
    LPSTR format,
    ...
    );

int
WINAPIV
_eprint(
    LPSTR Format,
    ...
    );

#define dprint ((g.SymOptions & SYMOPT_DEBUG) == SYMOPT_DEBUG)&&_dprint
#define eprint ((g.SymOptions & SYMOPT_DEBUG) == SYMOPT_DEBUG)&&_eprint
#define cprint _dprint

#define pprint ((g.SymOptions & SYMOPT_DEBUG) == SYMOPT_DEBUG)&&_pprint
#define peprint ((g.SymOptions & SYMOPT_DEBUG) == SYMOPT_DEBUG)&&_peprint
#define pcprint _pprint

BOOL
WINAPIV
evtprint(
    PPROCESS_ENTRY pe,
    DWORD          severity,
    DWORD          code,
    PVOID          object,
    LPSTR          format,
    ...
    );

BOOL
traceAddr(
    DWORD64 addr
    );

BOOL
traceName(
    PCHAR name
    );

BOOL
traceSubName(
    PCHAR name
    );

// for use with cvtype.h

typedef SYMTYPE *SYMPTR;

__inline
DWORD64
GetIP(
    PPROCESS_ENTRY pe
    )
{
    return pe->StackFrame.InstructionOffset;
}


typedef struct _PDB_INFO {
    CHAR    Signature[4];   // "NBxx"
    ULONG   Offset;         // always zero
    ULONG   sig;
    ULONG   age;
    CHAR    PdbName[_MAX_PATH];
} PDB_INFO, *PPDB_INFO;

#define n_name          N.ShortName
#define n_zeroes        N.Name.Short
#define n_nptr          N.LongName[1]
#define n_offset        N.Name.Long

//
// internal prototypes
//

BOOL
IsImageMachineType64(
    DWORD MachineType
    );

void
InitModuleEntry(
    PMODULE_ENTRY mi
    );

PMODULE_ENTRY
GetModFromAddr(
    PPROCESS_ENTRY    pe,
    IN  DWORD64       addr
    );

DWORD_PTR
GetPID(
    HANDLE hProcess
    );

DWORD
GetProcessModules(
    HANDLE                  hProcess,
    PINTERNAL_GET_MODULE    InternalGetModule,
    PVOID                   Context
    );

BOOL
InternalGetModule(
    HANDLE  hProcess,
    LPSTR   ModuleName,
    DWORD64 ImageBase,
    DWORD   ImageSize,
    PVOID   Context
    );

VOID
FreeModuleEntry(
    PPROCESS_ENTRY pe,
    PMODULE_ENTRY  mi
    );

PPROCESS_ENTRY
FindProcessEntry(
    HANDLE  hProcess
    );

PPROCESS_ENTRY
FindFirstProcessEntry(
    );

VOID
GetSymName(
    PIMAGE_SYMBOL Symbol,
    PUCHAR        StringTable,
    LPSTR         s,
    DWORD         size
    );

BOOL
ProcessOmapSymbol(
    PMODULE_ENTRY   mi,
    PSYMBOL_ENTRY   sym
    );

DWORD64
ConvertOmapFromSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias
    );

DWORD64
ConvertOmapToSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias,
    BOOL           fBackup
    );

POMAP
GetOmapFromSrcEntry(
    PMODULE_ENTRY  mi,
    DWORD64        addr
    );

VOID
DumpOmapForModule(
    PMODULE_ENTRY      mi
    );

VOID
ProcessOmapForModule(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    );

BOOL
LoadCoffSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    );

BOOL
LoadCodeViewSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    );

ULONG
LoadExportSymbols(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    );

PMODULE_ENTRY
GetModuleForPC(
    PPROCESS_ENTRY  ProcessEntry,
    DWORD64         dwPcAddr,
    BOOL            ExactMatch
    );

PSYMBOL_ENTRY
GetSymFromAddr(
    DWORD64         dwAddr,
    PDWORD64        pqwDisplacement,
    PMODULE_ENTRY   mi
    );

LPSTR
StringDup(
    LPSTR str
    );

DWORD64
InternalLoadModule(
    IN  HANDLE          hProcess,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           SizeOfDll,
    IN  HANDLE          hFile,
    IN  PMODLOAD_DATA   data,
    IN  DWORD           flags
    );

DWORD
ComputeHash(
    LPSTR   lpname,
    ULONG   cb
    );

PSYMBOL_ENTRY
FindSymbolByName(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    );

PFPO_DATA
SwSearchFpoData(
    DWORD     key,
    PFPO_DATA base,
    DWORD     num
    );

PIMGHLP_RVA_FUNCTION_DATA
GetFunctionEntryFromDebugInfo (
    PPROCESS_ENTRY  ProcessEntry,
    DWORD64         ControlPc
    );

PIMAGE_FUNCTION_ENTRY
LookupFunctionEntryAxp32 (
    HANDLE        hProcess,
    DWORD         ControlPc
    );

PIMAGE_FUNCTION_ENTRY64
LookupFunctionEntryAxp64 (
    HANDLE        hProcess,
    DWORD64       ControlPc
    );

PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntryIa64 (
    HANDLE        hProcess,
    DWORD64       ControlPc
    );

_PIMAGE_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntryAmd64 (
    HANDLE        hProcess,
    DWORD64       ControlPc
    );

BOOL
LoadedModuleEnumerator(
    HANDLE         hProcess,
    LPSTR          ModuleName,
    DWORD64        ImageBase,
    DWORD          ImageSize,
    PLOADED_MODULE lm
    );

BOOL
load(
    IN  HANDLE          hProcess,
    IN  PMODULE_ENTRY   mi
    );

LPSTR
symfmt(
    LPSTR DstName,
    LPSTR SrcName,
    ULONG Length
    );

BOOL
MatchSymName(
    LPSTR matchName,
    LPSTR symName
    );

BOOL
strcmpre(
    LPSTR pStr,
    LPSTR pRE,
    BOOL  fCase
    );

PIMAGEHLP_SYMBOL
symcpy32(
    PIMAGEHLP_SYMBOL  External,
    PSYMBOL_ENTRY       Internal
    );

PIMAGEHLP_SYMBOL64
symcpy64(
    PIMAGEHLP_SYMBOL64  External,
    PSYMBOL_ENTRY       Internal
    );

BOOL
SympConvertSymbol32To64(
    PIMAGEHLP_SYMBOL Symbol32,
    PIMAGEHLP_SYMBOL64 Symbol64
    );

BOOL
SympConvertSymbol64To32(
    PIMAGEHLP_SYMBOL64 Symbol64,
    PIMAGEHLP_SYMBOL Symbol32
    );

BOOL
SympConvertLine32To64(
    PIMAGEHLP_LINE Line32,
    PIMAGEHLP_LINE64 Line64
    );

BOOL
SympConvertLine64To32(
    PIMAGEHLP_LINE64 Line64,
    PIMAGEHLP_LINE Line32
    );

BOOL
SympConvertAnsiModule32ToUnicodeModule32(
    PIMAGEHLP_MODULE  A_Symbol32,
    PIMAGEHLP_MODULEW W_Symbol32
    );

BOOL
SympConvertUnicodeModule32ToAnsiModule32(
    PIMAGEHLP_MODULEW W_Symbol32,
    PIMAGEHLP_MODULE  A_Symbol32
    );

BOOL
SympConvertAnsiModule64ToUnicodeModule64(
    PIMAGEHLP_MODULE64  A_Symbol64,
    PIMAGEHLP_MODULEW64 W_Symbol64
    );

BOOL
SympConvertUnicodeModule64ToAnsiModule64(
    PIMAGEHLP_MODULEW64 W_Symbol64,
    PIMAGEHLP_MODULE64  A_Symbol64
    );

BOOL
CopySymbolEntryFromSymbolInfo(
    PSYMBOL_ENTRY se,
    PSYMBOL_INFO  si
    );

PMODULE_ENTRY
FindModule(
    HANDLE hModule,
    PPROCESS_ENTRY ProcessEntry,
    LPSTR ModuleName,
    BOOL fLoad
    );

BOOL
ToggleFailCriticalErrors(
    BOOL reset
    );

DWORD 
fnGetFileAttributes(
    LPCTSTR lpFileName
    );

#define SetCriticalErrorMode()   ToggleFailCriticalErrors(FALSE)
#define ResetCriticalErrorMode() ToggleFailCriticalErrors(TRUE)

#define fileexists(path) (fnGetFileAttributes(path) != 0xFFFFFFFF) 

LPSTR
SymUnDNameInternal(
    LPSTR UnDecName,
    DWORD UnDecNameLength,
    LPSTR DecName,
    DWORD MaxDecNameLength,
    DWORD MachineType,
    BOOL  IsPublic
    );

BOOL
GetLineFromAddr(
    PMODULE_ENTRY mi,
    DWORD64 Addr,
    PDWORD Displacement,
    PIMAGEHLP_LINE64 Line
    );

BOOL
FindLineByName(
    PMODULE_ENTRY mi,
    LPSTR FileName,
    DWORD LineNumber,
    PLONG Displacement,
    PIMAGEHLP_LINE64 Line
    );

BOOL
AddLinesForCoff(
    PMODULE_ENTRY mi,
    PIMAGE_SYMBOL allSymbols,
    DWORD numberOfSymbols,
    PIMAGE_LINENUMBER LineNumbers
    );

BOOL
AddLinesForOmfSourceModule(
    PMODULE_ENTRY mi,
    BYTE *Base,
    OMFSourceModule *OmfSrcMod,
    PVOID PdbModule
    );

PSOURCE_ENTRY
FindNextSourceEntryForFile(
    PMODULE_ENTRY mi,
    LPSTR File,
    PSOURCE_ENTRY SearchFrom
    );

PSOURCE_ENTRY
FindPrevSourceEntryForFile(
    PMODULE_ENTRY mi,
    LPSTR File,
    PSOURCE_ENTRY SearchFrom
    );

BOOL
__stdcall
ReadInProcMemory(
    HANDLE    hProcess,
    DWORD64   addr,
    PVOID     buf,
    DWORD     bytes,
    DWORD    *bytesread
    );

BOOL
GetPData(
    HANDLE        hp,
    PMODULE_ENTRY mi
    );

BOOL
GetXData(
    HANDLE        hp,
    PMODULE_ENTRY mi
    );

PVOID
GetXDataFromBase(
    HANDLE     hp,
    DWORD64    base,
    ULONG_PTR* size
    );

PVOID 
GetUnwindInfoFromSymbols(
    HANDLE     hProcess, 
    DWORD64    ModuleBase, 
    ULONG      UnwindInfoAddress,
    ULONG_PTR* Size
    );


VOID
SympSendDebugString(
    PPROCESS_ENTRY ProcessEntry,
    LPSTR          String
    );

BOOL
DoEnumCallback(
    PPROCESS_ENTRY pe,
    PSYMBOL_INFO   pSymInfo,
    ULONG          SymSize,
    PROC           EnumCallback,
    PVOID          UserContext,
    BOOL           Use64,
    BOOL           UsesUnicode
    );

#ifdef __cpluspluss
extern "C" {
#endif


BOOL
MatchSymbolName(
    PSYMBOL_ENTRY       sym,
    LPSTR               SymName
    );

BOOL
LoadSymbols(
    HANDLE        hp,
    PMODULE_ENTRY mi,
    DWORD         flags
    );

// flags parameter to LoadSymbols

#define LS_QUALIFIED      0x1
#define LS_LOAD_LINES     0x2
#define LS_JUST_TEST      0x4
#define LS_FAIL_IF_LOADED 0x8

// flags indicate Next or Previous for many functions

#define NP_NEXT         1
#define NP_PREV         -1

BOOL
DoSymbolCallback (
    PPROCESS_ENTRY                  ProcessEntry,
    ULONG                           CallbackType,
    IN  PMODULE_ENTRY               mi,
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl64,
    LPSTR                           FileName
    );

BOOL
DoCallback(
    PPROCESS_ENTRY pe,
    ULONG          type,
    PVOID          data
    );

#define lengthof(a) (sizeof(a) / sizeof(a[0]))

BOOL
wcs2ansi(
    PWSTR pwsz,
    PSTR  psz,
    DWORD pszlen                                                                                
    );

BOOL
ansi2wcs(
    PSTR  psz,
    PWSTR pwsz,
    DWORD pwszlen                                                                                
    );

PWSTR AnsiToUnicode(PSTR);
PSTR  UnicodeToAnsi(PWSTR);
#if 0
BOOL CopyAnsiToUnicode(PWSTR, PSTR, DWORD);
BOOL CopyUnicodeToAnsi(PSTR, PWSTR, DWORD);
#endif

BOOL
LookupRegID (
    IN ULONG CVReg,
    IN ULONG MachineType,
    OUT PULONG pDbgReg
    );

ULONG
GetAddressFromOffset(
    PMODULE_ENTRY mi,
    ULONG         section,
    ULONG64       Offset,
    PULONG64      pAddress
    );

VOID
AddSourceEntry(
    PMODULE_ENTRY mi,
    PSOURCE_ENTRY Src
    );

BOOL
diaInit(
    VOID
    );

void
diaRelease(
    PVOID dia
    );

BOOL
diaOpenPdb(
    PIMGHLP_DEBUG_DATA pIDD
    );

BOOL
diaEnumSourceFiles(
    IN PMODULE_ENTRY mi,
    IN PCHAR         mask,
    IN PSYM_ENUMSOURCFILES_CALLBACK cbSrcFiles,
    IN PVOID         context
    );

BOOL
diaGetPData(
    PMODULE_ENTRY mi
    );

BOOL
diaGetXData(
    PMODULE_ENTRY mi
    );

PSYMBOL_ENTRY
diaFindSymbolByName(
    PPROCESS_ENTRY  pe,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    );

BOOL
diaEnumerateSymbols(
    IN PPROCESS_ENTRY pe,
    IN PMODULE_ENTRY  mi,
    IN LPSTR          mask,
    IN PROC           callback,
    IN PVOID          UserContext,
    IN BOOL           Use64,
    IN BOOL           CallBackUsesUnicode
    );

PSYMBOL_ENTRY
diaGetSymFromAddr(
    DWORD64         dwAddr,
    PMODULE_ENTRY   mi,
    PDWORD64        disp
    );

BOOL
diaGetLineFromAddr(
    PMODULE_ENTRY    mi,
    DWORD64          addr,
    PDWORD           displacement,
    PIMAGEHLP_LINE64 Line
    );

BOOL
diaGetLineNextPrev(
    PMODULE_ENTRY    mi,
    PIMAGEHLP_LINE64 line,
    DWORD            direction
    );

#define diaGetLineNext(mi, line) diaGetLineNextPrev(mi, line, NP_NEXT);
#define diaGetLinePrev(mi, line) diaGetLineNextPrev(mi, line, NP_PREV);

BOOL
diaGetLineFromName(
    PMODULE_ENTRY    mi,
    LPSTR            filename,
    DWORD            linenumber,
    PLONG            displacement,
    PIMAGEHLP_LINE64 line
    );

PSYMBOL_ENTRY
diaGetSymNextPrev(
    PMODULE_ENTRY mi,
    DWORD64       addr,
    int           direction
    );

DWORD
diaVersion(
    VOID
    );

BOOL 
diaSetModFromIP(
    PPROCESS_ENTRY pe
    );

HRESULT
diaGetSymbolInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    );

BOOL
diaGetTiForUDT(
    PMODULE_ENTRY ModuleEntry, 
    LPSTR         name, 
    PSYMBOL_INFO  psi
    );

BOOL
diaEnumUDT(
    PMODULE_ENTRY ModuleEntry,
    LPSTR         name,
    PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    PVOID         EnumContext
    );

BOOL
diaGetFrameData(
    IN HANDLE Process,
    IN ULONGLONG Offset,
    OUT interface IDiaFrameData** FrameData
    );
    
DWORD
mdSet(
    PMODULE_DATA md,
    DWORD        id,
    DWORD        hint,
    DWORD        src
    );

BOOL
InitOutputString(
    PCHAR sz
    );

BOOL
TestOutputString(
    PCHAR sz
    );

#ifdef __cpluspluss
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\symbols.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    symbols.c

Abstract:

    This function implements a generic simple symbol handler.

Author:

    Wesley Witt (wesw) 1-Sep-1994

Environment:

    User Mode

--*/

#include "private.h"
#include "symbols.h"
#include "globals.h"
#include <dbhpriv.h>

#include "fecache.hpp"

BOOL
IMAGEAPI
SympGetSymNextPrev(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol,
    IN     int                 Direction
    );

#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED

PSYMBOL_ENTRY
IMAGEAPI
AllocSym(
    IN PMODULE_ENTRY   mi,
    IN DWORD64         addr,
    IN LPSTR           name
    );

VOID
CompleteSymbolTable(
    IN PMODULE_ENTRY   mi
    );

#endif // !_DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED


typedef struct _STORE_OLD_CB {
    BOOL cb64;
    union{
        PSYM_ENUMSYMBOLS_CALLBACK   UserCallBackRoutine;
        PSYM_ENUMSYMBOLS_CALLBACK64 UserCallBackRoutine64;
    };
    PVOID         UserContext;
} STORE_OLD_CB;


BOOL
ImgHlpDummyCB(
    PSYMBOL_INFO  pSymInfo,
    ULONG         SymbolSize,
    PVOID         UserContext
    )
{
    STORE_OLD_CB *pOld = (STORE_OLD_CB *) UserContext;

    if (pSymInfo->Flags & SYMF_REGREL) {
        LARGE_INTEGER li;
        li.HighPart = pSymInfo->Register;
        li.LowPart  = (ULONG) pSymInfo->Address;
        pSymInfo->Address = li.QuadPart;
    }

    if (pOld->cb64) {
        return (*pOld->UserCallBackRoutine64) (
                                            pSymInfo->Name,
                                            pSymInfo->Address,
                                            SymbolSize,
                                            pOld->UserContext );
    } else {
        return (*pOld->UserCallBackRoutine) (
                                            pSymInfo->Name,
                                            (ULONG) pSymInfo->Address,
                                            SymbolSize,
                                            pOld->UserContext );
    }
}


void
symcpy2(
    PSYMBOL_INFO  SymInfo,
    PSYMBOL_ENTRY SymEntry
    )
{
    SymInfo->Address = SymEntry->Address;
    SymInfo->Flags   = SymEntry->Flags;
    SymInfo->TypeIndex = SymEntry->TypeIndex;
    SymInfo->ModBase = SymEntry->ModBase;
    SymInfo->NameLen = SymEntry->NameLength;
    SymInfo->Size    = SymEntry->Size;
    SymInfo->Register = SymEntry->Register;
    if (SymEntry->Name &&
        (strlen(SymEntry->Name) < SymInfo->MaxNameLen)) {
        strcpy(SymInfo->Name, SymEntry->Name);
    }
}


BOOL
TestOutputString(
    PCHAR sz
    )
{
    CHAR c;

    __try {
        c = *sz;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}


BOOL
InitOutputString(
    PCHAR sz
    )
{
    BOOL rc;

    rc = TestOutputString(sz);
    if (rc)
        *sz = 0;

    return rc;
}


BOOL
DoEnumCallback(
    PPROCESS_ENTRY pe,
    PSYMBOL_INFO   pSymInfo,
    ULONG          SymSize,
    PROC           EnumCallback,
    PVOID          UserContext,
    BOOL           Use64,
    BOOL           UsesUnicode
    )
{
    BOOL rc = FALSE;

    if (pSymInfo)
    {
        if (Use64 || (!UsesUnicode))
        {
            rc = (*(PSYM_ENUMERATESYMBOLS_CALLBACK)EnumCallback) (
                       pSymInfo,
                       SymSize,
                       UserContext);
        }
        else
        {
            PWSTR pszTmp = AnsiToUnicode(pSymInfo->Name);

            if (pszTmp)
            {
                strncpy(pSymInfo->Name, (LPSTR) pszTmp,
                        min(pSymInfo->MaxNameLen, wcslen(pszTmp)));
                *((LPWSTR) &pSymInfo->Name[min(pSymInfo->MaxNameLen, wcslen(pszTmp)) - 1 ]) = 0;
                rc = (*(PSYM_ENUMERATESYMBOLS_CALLBACK)EnumCallback) (
                           pSymInfo,
                           SymSize,
                           UserContext );
                MemFree(pszTmp);
            }
        }
    }

    return rc;
}



BOOL
IMAGEAPI
SymInitialize(
    IN HANDLE   hProcess,
    IN LPSTR    UserSearchPath,
    IN BOOL     InvadeProcess
    )

/*++

Routine Description:

    This function initializes the symbol handler for
    a process.  The process is identified by the
    process handle passed into this function.

Arguments:

    hProcess        - Process handle.  If InvadeProcess is FALSE
                      then this can be any unique value that identifies
                      the process to the symbol handler.

    UserSearchPath  - Pointer to a string of paths separated by semicolons.
                      These paths are used to search for symbol files.
                      The value NULL is acceptable.

    InvadeProcess   - If this is set to TRUE then the process identified
                      by the process handle is "invaded" and it's loaded
                      module list is enumerated.  Each module is added
                      to the symbol handler and symbols are attempted
                      to be loaded.

Return Value:

    TRUE            - The symbol handler was successfully initialized.

    FALSE           - The initialization failed.  Call GetLastError to
                      discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY  pe;

    __try {

        if (!g.SymInitialized) {
            g.SymInitialized = TRUE;
            g.cProcessList = 0;
            InitializeListHead( &g.ProcessList );
        }

        *g.DebugToken = 0;
        GetEnvironmentVariable(DEBUG_TOKEN, g.DebugToken, sizeof(g.DebugToken) / sizeof(g.DebugToken[0]));
        _strlwr(g.DebugToken);

        if (FindProcessEntry( hProcess )) {
            SetLastError( ERROR_INVALID_HANDLE );
            return TRUE;
        }

        pe = (PPROCESS_ENTRY) MemAlloc( sizeof(PROCESS_ENTRY) );
        if (!pe) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }
        ZeroMemory( pe, sizeof(PROCESS_ENTRY) );

        pe->hProcess = hProcess;
        pe->pid = (int) GetPID(hProcess);
        g.cProcessList++;
        InitializeListHead( &pe->ModuleList );
        InsertTailList( &g.ProcessList, &pe->ListEntry );

        if (!SymSetSearchPath( hProcess, UserSearchPath )) {
            //
            // last error code was set by SymSetSearchPath, so just return
            //
            SymCleanup( hProcess );
            return FALSE;
        }

        if (!diaInit()) {
            SymCleanup( hProcess );
            return FALSE;
        }

        if (InvadeProcess) {
            DWORD DosError = GetProcessModules(hProcess, InternalGetModule, NULL);
            if (DosError) {
                SymCleanup( hProcess );
                SetLastError( DosError );
                return FALSE;
            }
        }


    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}


BOOL
IMAGEAPI
SymCleanup(
    HANDLE hProcess
    )

/*++

Routine Description:

    This function cleans up the symbol handler's data structures
    for a previously initialized process.

Arguments:

    hProcess        - Process handle.

Return Value:

    TRUE            - The symbol handler was successfully cleaned up.

    FALSE           - The cleanup failed.  Call GetLastError to
                      discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY pe;
    PLIST_ENTRY    next;
    PMODULE_ENTRY  mi;
    BOOL           rc = TRUE;

    HeapDump("SymCleanup(before cleanup)\n");
    
    __try {

        pe = FindProcessEntry(hProcess);
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        next = pe->ModuleList.Flink;
        if (next) {
            while (next != &pe->ModuleList) {
                mi = CONTAINING_RECORD(next, MODULE_ENTRY, ListEntry);
                next = mi->ListEntry.Flink;
                FreeModuleEntry(pe, mi);
            }
        }

        CloseSymbolServer();

        if (pe->SymbolSearchPath) {
            MemFree(pe->SymbolSearchPath);
        }

        RemoveEntryList(&pe->ListEntry);
        MemFree(pe);
        g.cProcessList--;

        // Assume that things are shutting down and
        // dump all the function entry caches.
        ClearFeCaches();
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        rc = FALSE;

    }

    HeapDump("SymCleanup(after cleanup)\n");

    return rc;
}


DWORD
IMAGEAPI
SymSetOptions(
    DWORD   UserOptions
    )                               

/*++

Routine Description:

    This function changes the symbol handler's option mask.

Arguments:

    UserOptions     - The new options mask.

Return Value:

    The new mask is returned.

--*/

{
    g.SymOptions = UserOptions;
    SetSymbolServerCallback(g.SymOptions & SYMOPT_DEBUG ? TRUE : FALSE);
    DoCallback(NULL, CBA_SET_OPTIONS, &g.SymOptions);
    return g.SymOptions;
}


DWORD
IMAGEAPI
SymGetOptions(
    VOID
    )

/*++

Routine Description:

    This function queries the symbol handler's option mask.

Arguments:

    None.

Return Value:

    The current options mask is returned.

--*/

{
    return g.SymOptions;
}


ULONG
IMAGEAPI
SymSetContext(
    HANDLE hProcess,
    PIMAGEHLP_STACK_FRAME StackFrame,
    PIMAGEHLP_CONTEXT Context
    )
{
    PPROCESS_ENTRY pe;

    pe = FindProcessEntry(hProcess);
    if (pe) {
        pe->pContext = Context;
        pe->StackFrame = *StackFrame;
        return diaSetModFromIP(pe);
    }

    return FALSE;
};


BOOL
SympEnumerateModules(
    IN HANDLE   hProcess,
    IN PROC     EnumModulesCallback,
    IN PVOID    UserContext,
    IN BOOL     Use64
    )

/*++

Routine Description:

    This is the worker function for the 32 and 64 bit versions.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    EnumModulesCallback - Callback pointer that is called once for each
                          module that is enumerated.  If the enum callback
                          returns FALSE then the enumeration is terminated.

    UserContext         - This data is simply passed on to the callback function
                          and is completly user defined.

    Use64               - Supplies flag which determines whether to use the 32 bit
                          or 64 bit callback prototype.

Return Value:

    TRUE                - The modules were successfully enumerated.

    FALSE               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY  pe;
    PMODULE_ENTRY   mi;
    PLIST_ENTRY     Next;


    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        Next = pe->ModuleList.Flink;
        if (Next) {
            while (Next != &pe->ModuleList) {
                mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                Next = mi->ListEntry.Flink;
                if (Use64) {
                    if ( !(*(PSYM_ENUMMODULES_CALLBACK64)EnumModulesCallback) (
                            mi->ModuleName,
                            mi->BaseOfDll,
                            UserContext
                            )) {
                        break;
                    }
                } else {
                    if ( !(*(PSYM_ENUMMODULES_CALLBACK)EnumModulesCallback) (
                            mi->ModuleName,
                            (DWORD)mi->BaseOfDll,
                            UserContext
                            )) {
                        break;
                    }
                }
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}


BOOL
dbhfnModSymInfo(
    IN     HANDLE          hp,
    IN OUT PDBH_MODSYMINFO p
    )
{
    PMODULE_ENTRY  mi;
    PPROCESS_ENTRY pe;
    
    assert(p->function == dbhModSymInfo);
    
    pe = FindProcessEntry(hp);
    if (!pe) {
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    if (p->sizeofstruct != sizeof(DBH_MODSYMINFO)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
        
    mi = GetModuleForPC(pe, p->addr, FALSE);
    if (!mi) {
        SetLastError(ERROR_MOD_NOT_FOUND);
        return FALSE;
    }

    p->type = mi->SymType;
    *p->file = 0;
    switch (p->type) 
    {
    case SymPdb:
    case SymDia:
        if (mi->LoadedPdbName)
            strcpy(p->file, mi->LoadedPdbName);
        break;
    default:
        if (mi->LoadedImageName)
            strcpy(p->file, mi->LoadedImageName);
        break;
    }

    return TRUE;
}


BOOL 
dbhfnDiaVersion(
    IN OUT PDBH_DIAVERSION p
    )
{
    PMODULE_ENTRY mi;

    assert(p->function == dbhDiaVersion);
    
    if (p->sizeofstruct != sizeof(DBH_DIAVERSION)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
                
    p->ver = diaVersion();

    return TRUE;
}


BOOL
IMAGEAPI
dbghelp(
    IN     HANDLE hp,
    IN OUT PVOID  data
    )
{
    DWORD *function;
    
    if (!data) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try {

        function = (DWORD *)data;
        switch (*function)
        {
        case dbhModSymInfo:
            return dbhfnModSymInfo(hp, (PDBH_MODSYMINFO)data);

        case dbhDiaVersion:
            return dbhfnDiaVersion((PDBH_DIAVERSION)data);
        
        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return FALSE;

    }

    return FALSE;
}


BOOL
IMAGEAPI
SymEnumerateModules(
    IN HANDLE                      hProcess,
    IN PSYM_ENUMMODULES_CALLBACK EnumModulesCallback,
    IN PVOID                       UserContext
    )

/*++

Routine Description:

    This function enumerates all of the modules that are currently
    loaded into the symbol handler.  This is the 32 bit wrapper.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    EnumModulesCallback - Callback pointer that is called once for each
                          module that is enumerated.  If the enum callback
                          returns FALSE then the enumeration is terminated.

    UserContext         - This data is simply passed on to the callback function
                          and is completly user defined.

Return Value:

    TRUE                - The modules were successfully enumerated.

    FALSE               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/
{
    return SympEnumerateModules(hProcess, (PROC)EnumModulesCallback, UserContext, FALSE);
}


BOOL
IMAGEAPI
SymEnumerateModules64(
    IN HANDLE   hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64 EnumModulesCallback,
    IN PVOID    UserContext
    )

/*++

Routine Description:

    This function enumerates all of the modules that are currently
    loaded into the symbol handler.  This is the 64 bit wrapper.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    EnumModulesCallback - Callback pointer that is called once for each
                          module that is enumerated.  If the enum callback
                          returns FALSE then the enumeration is terminated.

    UserContext         - This data is simply passed on to the callback function
                          and is completly user defined.

Return Value:

    TRUE                - The modules were successfully enumerated.

    FALSE               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/
{
    return SympEnumerateModules(hProcess, (PROC)EnumModulesCallback, UserContext, TRUE);
}

DWORD
CalcItemSize(
    PDWORD64 pAddr,
    PDWORD64 pAddrsBase,
    UINT_PTR count
    )
{
    PDWORD64 p;
    PDWORD64 pAddrEnd;

    if (!pAddr)
        return 0;

    pAddrEnd = pAddrsBase + count;

    for (p = pAddr + 1; p <= pAddrEnd; p++) {
        if (*p != *pAddr)
            return (DWORD)(*p - *pAddr);
    }

    return 0;
}


BOOL
MatchModuleName(
    PMODULE_ENTRY mi,
    LPSTR         mask
    )
{
    if (!strcmpre(mi->AliasName, mask, FALSE))
        return TRUE;

    if (!strcmpre(mi->ModuleName, mask, FALSE))
        return TRUE;

    return FALSE;
}


BOOL
SympEnumerateSymbols(
    IN HANDLE  hProcess,
    IN ULONG64 BaseOfDll,
    IN LPSTR   Mask,
    IN PROC    EnumSymbolsCallback,
    IN PVOID   UserContext,
    IN BOOL    Use64,
    IN BOOL    CallBackUsesUnicode
    )

/*++

Routine Description:

    This function enumerates all of the symbols contained the module
    specified by the BaseOfDll argument.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize

    BaseOfDll           - Base address of the DLL that symbols are to be
                          enumerated for

    EnumSymbolsCallback - User specified callback routine for enumeration
                          notification

    UserContext         - Pass thru variable, this is simply passed thru to the
                          callback function

    Use64               - Supplies flag which determines whether to use the 32 bit
                          or 64 bit callback prototype.

Return Value:

    TRUE                - The symbols were successfully enumerated.

    FALSE               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       mi;
    DWORD               i;
    PSYMBOL_ENTRY       sym;
    LPSTR               szSymName;
    SYMBOL_ENTRY        SymEntry={0};
    CHAR                Buffer[2500];
    LPSTR               p;
    CHAR                modmask[200];
    BOOL                rc;
    int                 pass;
    BOOL                fCase;
    
    static DWORD        flags[2] = {LS_JUST_TEST, LS_QUALIFIED | LS_FAIL_IF_LOADED};

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        p = 0;
        modmask[0] = 0;
        if (Mask) 
            p = strchr(Mask, '!');
        if (p > Mask) {
            memcpy(modmask, Mask, (int)(p - Mask));
            modmask[p-Mask] = 0;
            Mask = p + 1;
        } else if (!BaseOfDll) {
            rc = diaEnumerateSymbols(pe,
                                     NULL,
                                     Mask,
                                     EnumSymbolsCallback,
                                     UserContext,
                                     Use64,
                                     CallBackUsesUnicode);
            if (!rc && pe->ipmi && pe->ipmi->code == ERROR_CANCELLED) {
                pe->ipmi->code = 0;
                return TRUE;
            }
            return rc;
        }

        for (pass = 0; pass < 2; pass++) {
            Next = pe->ModuleList.Flink;
            if (Next) {
                while (Next != &pe->ModuleList) {
    
                    mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                    Next = mi->ListEntry.Flink;
                    if (BaseOfDll) {
                        if (mi->BaseOfDll != BaseOfDll) 
                            continue;
                    } else if (!MatchModuleName(mi, modmask)) {
                        continue;
                    }
                    
                    if (!LoadSymbols(hProcess, mi, flags[pass])) 
                        continue;
    
                    if (mi->dia) {
                        rc = diaEnumerateSymbols(pe,
                                                 mi,
                                                 Mask,
                                                 EnumSymbolsCallback,
                                                 UserContext,
                                                 Use64,
                                                 CallBackUsesUnicode);
                        if (!rc) {
                            if (mi->code == ERROR_CANCELLED) {
                                mi->code = 0;
                                return TRUE;
                            }
                            return rc;
                        }
                        continue;
                    }
    
                    fCase = (g.SymOptions & SYMOPT_CASE_INSENSITIVE) ? FALSE : TRUE;

                    for (i = 0; i < mi->numsyms; i++) {
                        PSYMBOL_INFO SymInfo = (PSYMBOL_INFO) &Buffer[0];
    
                        sym = &mi->symbolTable[i];
                        
                        if (Mask  && *Mask && strcmpre(sym->Name, Mask, fCase))
                            continue;
                        
                        mi->TmpSym.Name[0] = 0;
                        strncat( mi->TmpSym.Name, sym->Name, TMP_SYM_LEN );
                        SymEntry = *sym;
                        SymEntry.Name = mi->TmpSym.Name;
    
                        SymInfo->MaxNameLen  = sizeof(Buffer) - sizeof(SYMBOL_INFO);
    
                        symcpy2(SymInfo, &SymEntry);
                        SymInfo->ModBase = mi->BaseOfDll;
    
                        if (!DoEnumCallback(
                                   pe,
                                   SymInfo,
                                   sym->Size,
                                   EnumSymbolsCallback,
                                   UserContext,
                                   Use64,
                                   CallBackUsesUnicode)) {
                            break;
                        }
                    }         
                    break;
                }
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymEnumerateSymbols(
    IN HANDLE                       hProcess,
    IN ULONG                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )

/*++

Routine Description:

    This function enumerates all of the symbols contained the module
    specified by the BaseOfDll argument.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize

    BaseOfDll           - Base address of the DLL that symbols are to be
                          enumerated for

    EnumSymbolsCallback - User specified callback routine for enumeration
                          notification

    UserContext         - Pass thru variable, this is simply passed thru to the
                          callback function

Return Value:

    TRUE                - The symbols were successfully enumerated.

    FALSE               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/
{
    STORE_OLD_CB OldCB;

    OldCB.UserCallBackRoutine = EnumSymbolsCallback;
    OldCB.UserContext = UserContext;
    OldCB.cb64 = FALSE;
    return SympEnumerateSymbols(hProcess, 
                                    BaseOfDll,
                                    NULL,
                                    (PROC) (EnumSymbolsCallback ? &ImgHlpDummyCB : NULL),
                                    (PVOID) &OldCB, 
                                    FALSE, 
                                    FALSE);

}

BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN ULONG                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    STORE_OLD_CB OldCB;

    OldCB.UserCallBackRoutine = (PSYM_ENUMSYMBOLS_CALLBACK) EnumSymbolsCallback;
    OldCB.UserContext = UserContext;
    OldCB.cb64 = FALSE;

    return SympEnumerateSymbols(hProcess, 
                                    BaseOfDll,
                                    NULL,
                                    (PROC) (EnumSymbolsCallback ? &ImgHlpDummyCB : NULL),
                                    (PVOID) &OldCB, 
                                    FALSE, 
                                    FALSE);

}

BOOL
IMAGEAPI
SymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    STORE_OLD_CB OldCB;

    OldCB.UserCallBackRoutine64 = EnumSymbolsCallback;
    OldCB.UserContext = UserContext;
    OldCB.cb64 = TRUE;

    return SympEnumerateSymbols(hProcess, 
                                    BaseOfDll,
                                    NULL,
                                    (PROC) (EnumSymbolsCallback ? &ImgHlpDummyCB : NULL),
                                    (PVOID) &OldCB, 
                                    FALSE, 
                                    FALSE);
}

BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    STORE_OLD_CB OldCB;

    OldCB.UserCallBackRoutine64 = (PSYM_ENUMSYMBOLS_CALLBACK64) EnumSymbolsCallback;
    OldCB.UserContext = UserContext;
    OldCB.cb64 = TRUE;

    return SympEnumerateSymbols(hProcess, 
                                    BaseOfDll,
                                    NULL,
                                    (PROC) (EnumSymbolsCallback ? &ImgHlpDummyCB : NULL),
                                    (PVOID) &OldCB, 
                                    FALSE, 
                                    FALSE);

}

BOOL
SympGetSymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    OUT PSYMBOL_ENTRY       SymRet
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on an address.
    This is the common worker function for the 32 and 64 bit API.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Address             - Address of the desired symbol.


    Displacement        - This value is set to the offset from the beginning
                          of the symbol.

    sym                 - Returns the found symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    PSYMBOL_ENTRY       psym;

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( pe, Address, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (!LoadSymbols(hProcess, mi, 0)) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        psym = GetSymFromAddr( Address, Displacement, mi );
        if (psym) {
            *SymRet = *psym;
        } else {
            SetLastError( ERROR_INVALID_ADDRESS );
            return FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on an address.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Address             - Address of the desired symbol.


    Displacement        - This value is set to the offset from the beginning
                          of the symbol.

    Symbol              - Returns the found symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    SYMBOL_ENTRY sym;

    if (SympGetSymFromAddr(hProcess, Address, Displacement, &sym)) {
        symcpy64(Symbol, &sym);
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
IMAGEAPI
SymGetSymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD               Address,
    OUT PDWORD              Displacement,
    OUT PIMAGEHLP_SYMBOL    Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on an address.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Address             - Address of the desired symbol.


    Displacement        - This value is set to the offset from the beginning
                          of the symbol.

    Symbol              - Returns the found symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    SYMBOL_ENTRY sym;
    DWORD64 qDisplacement;

    if (SympGetSymFromAddr(hProcess, Address, &qDisplacement, &sym)) {
        symcpy32(Symbol, &sym);
        if (Displacement) {
            *Displacement = (DWORD)qDisplacement;
        }
        return TRUE;
    } else {
        return FALSE;
    }
}

#ifndef _DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED

#if 0

VOID
DumpMiSymbolTable(
   PMODULE_ENTRY mi
   )
{
   PSYMBOL_ENTRY sym;

   if ( !mi )
      return;
   sym = mi->symbolTable;
   for ( sym = mi->symbolTable; sym < &mi->symbolTable[mi->numsyms] ; sym++ )   {
      dprint("sym: %40s 0x%I64x %ld\n", sym->Name, sym->Address, sym->Size );
   }
   return;

} // DumpMiSymbolTable()

#endif // 0


#ifdef __cplusplus
extern "C"
#endif
BOOL
SymSetSymWithAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    IN  LPSTR               SymString,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function allocates an entry in the symbol table based on an address.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Address             - Address of the desired symbol.

    SymString           - Symbol name.

Return Value:

    TRUE  - The symbol was allocated.

    FALSE - The symbol was not allocated.  all GetLastError to
              discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    PSYMBOL_ENTRY       psym;
    BOOL                ret;
    DWORD64             displacement;

    if ( !SymString )   {
       SetLastError( ERROR_INVALID_PARAMETER );
       return FALSE;
    }

    ret = TRUE;

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE ), ret = FALSE;
            __leave;
        }

        mi = GetModuleForPC( pe, Address, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND ), ret = FALSE;
            __leave;
        }

        if (!LoadSymbols(hProcess, mi, 0)) {
            SetLastError( ERROR_MOD_NOT_FOUND ), ret = FALSE;
            __leave;
        }

        //
        // Let's verify that this address is not already used...
        // If yes, returns FALSE. The caller could parse the LastError.
        //

        psym = GetSymFromAddr( Address, &displacement, mi );
        if ( psym )   {
            pprint(pe, "SymSetSymWithAddr64: symbol %s already exists at this address 0x%I64x\n", psym->Name, Address );
            SetLastError( ERROR_ALREADY_EXISTS ), ret = FALSE;
            __leave;
        }

        //
        // Allocate a new entry.
        // This allocation is under imagehlp rules.
        // Meaning that if the symbols table has overflow,
        // we will not allocate an entry. This implementation]
        // does not use a specific bucket of entries.
        //

        psym = AllocSym( mi, Address, SymString );
        if ( !psym )   {
            SetLastError( ERROR_INVALID_ADDRESS ), ret = FALSE;
            __leave;
        }

        psym->Flags |= SYMF_USER_GENERATED;
        symcpy64(Symbol, psym);

        CompleteSymbolTable( mi );

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        ret = FALSE;
    }

    return ret;

} // SymSetSymWithAddr64()

#endif // !_DBGHELP_USER_GENERATED_SYMBOLS_NOTSUPPORTED

BOOL
SympGetSymFromName(
    IN  HANDLE          hProcess,
    IN  LPSTR           Name,
    OUT PSYMBOL_ENTRY   SymRet
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on a name.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    SymName             - A string containing the symbol name.

    sym                 - Returns the located symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/

{
    LPSTR               p;
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi = NULL;
    PLIST_ENTRY         Next;
    PSYMBOL_ENTRY       psym;
    IMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl64;
    int                 pass;
    
    static DWORD        flags[2] = {LS_JUST_TEST, LS_QUALIFIED};

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        // first check for fully qualified symbol name I.E. mod!sym

        p = strchr( Name, '!' );
        if (p > Name) {

            LPSTR ModName = (LPSTR)MemAlloc(p - Name + 1);
            if (!ModName) {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return FALSE;
            }
            memcpy(ModName, Name, (int)(p - Name));
            ModName[p-Name] = 0;

            //
            // the caller wants to look in a specific module
            //

            mi = FindModule(hProcess, pe, ModName, TRUE);

            MemFree(ModName);

            if (mi != NULL) {
                psym = FindSymbolByName( pe, mi, p+1 );
                if (psym) {
                    *SymRet = *psym;
                    return TRUE;
                }
            }

            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        // now check, using context information

        psym = FindSymbolByName( pe, NULL, Name );
        if (psym) {
            *SymRet = *psym;
            return TRUE;
        }

        // now just look in every module

        for (pass = 0; pass < 2; pass++) {
            Next = pe->ModuleList.Flink;
            while (Next != &pe->ModuleList) {
                mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                Next = mi->ListEntry.Flink;

                if (pass && DoSymbolCallback(pe,
                                     CBA_DEFERRED_SYMBOL_LOAD_CANCEL,
                                     mi,
                                     &idsl64,
                                     NULL))
                {
                    break;
                }

                if (!LoadSymbols(hProcess, mi, flags[pass])) 
                    continue;

                psym = FindSymbolByName( pe, mi, Name );
                if (psym) {
                    *SymRet = *psym;
                    return TRUE;
                }
            }
        }

        SetLastError( ERROR_MOD_NOT_FOUND );
        return FALSE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    SetLastError( ERROR_INVALID_FUNCTION );
    return FALSE;
}

BOOL
IMAGEAPI
SymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on a name.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    SymName             - A string containing the symbol name.

    Symbol              - Returns found symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    SYMBOL_ENTRY sym;

    if (SympGetSymFromName(hProcess, Name, &sym)) {
        symcpy64(Symbol, &sym);
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
IMAGEAPI
SymGetSymFromName(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on a name.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    SymName             - A string containing the symbol name.

    Symbol              - Returns found symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    SYMBOL_ENTRY sym;

    if (SympGetSymFromName(hProcess, Name, &sym)) {
        symcpy32(Symbol, &sym);
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
IMAGEAPI
SymGetSymNext(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol32
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PIMAGEHLP_SYMBOL64 Symbol64;
    BOOL r = FALSE;

    Symbol64 = (PIMAGEHLP_SYMBOL64)MemAlloc(sizeof(IMAGEHLP_SYMBOL64) + Symbol32->MaxNameLength);

    if (Symbol64) {
        SympConvertSymbol32To64(Symbol32, Symbol64);
        if (SympGetSymNextPrev(hProcess, Symbol64, 1)) {
            SympConvertSymbol64To32(Symbol64, Symbol32);
            r = TRUE;
        }

        MemFree(Symbol64);
    }
    return r;
}


BOOL
IMAGEAPI
SymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    return SympGetSymNextPrev(hProcess, Symbol, 1);
}

BOOL
IMAGEAPI
SymGetSymPrev(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol32
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PIMAGEHLP_SYMBOL64 Symbol64;
    BOOL r = FALSE;

    Symbol64 = (PIMAGEHLP_SYMBOL64)MemAlloc(sizeof(IMAGEHLP_SYMBOL64) + Symbol32->MaxNameLength);

    if (Symbol64) {
        SympConvertSymbol32To64(Symbol32, Symbol64);
        if (SympGetSymNextPrev(hProcess, Symbol64, -1)) {
            SympConvertSymbol64To32(Symbol64, Symbol32);
            r = TRUE;
        }
        MemFree(Symbol64);
    }
    return r;
}

BOOL
IMAGEAPI
SymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    return SympGetSymNextPrev(hProcess, Symbol, -1);
}

BOOL
SympGetSymNextPrev(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_SYMBOL64   Symbol,
    IN     int                  Direction
    )

/*++

Routine Description:

    Common code for SymGetSymNext and SymGetSymPrev.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

    Dir                 - Supplies direction to search

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    ULONG64             Displacement;
    PSYMBOL_ENTRY       sym;
    SYMBOL_ENTRY SymEntry = {0};

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( pe, Symbol->Address, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (!LoadSymbols(hProcess, mi, 0)) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (mi->dia) {

            sym = diaGetSymNextPrev(mi, Symbol->Address, Direction);
            if (!sym) {
                SetLastError( ERROR_INVALID_ADDRESS );
                return FALSE;
            }

            symcpy64(Symbol, sym);

        } else {

            sym = GetSymFromAddr( Symbol->Address, &Displacement, mi );
            if (!sym) {
                SetLastError( ERROR_INVALID_ADDRESS );
                return FALSE;
            }

            if (Direction > 0 && sym+1 >= mi->symbolTable+mi->numsyms) {
                SetLastError( ERROR_INVALID_ADDRESS );
                return FALSE;
            } else if (Direction < 0 && sym-1 < mi->symbolTable) {
                SetLastError( ERROR_INVALID_ADDRESS );
                return FALSE;
            }

            symcpy64( Symbol, sym + Direction);
        }


        return TRUE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return FALSE;
}

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 dwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    )

/*++

Routine Description:

    This function finds a source file and line number entry for the
    line closest to the given address.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    dwAddr              - Supplies an address for which a line is to be
                          located.

    pdwDisplacement     - Returns the offset between the given address
                          and the first instruction of the line.

    Line                - Returns the line and file information.

Return Value:

    TRUE                - A line was located.

    FALSE               - The line was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;

    __try {
        if (Line->SizeOfStruct != sizeof(IMAGEHLP_LINE64)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( pe, dwAddr, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (!LoadSymbols(hProcess, mi, 0)) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (!GetLineFromAddr(mi, dwAddr, pdwDisplacement, Line)) {
            SetLastError( ERROR_INVALID_ADDRESS );
            return FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymGetLineFromAddr(
    IN  HANDLE                  hProcess,
    IN  DWORD                   dwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    if (SymGetLineFromAddr64(hProcess, dwAddr, pdwDisplacement, &Line64)) {
        SympConvertLine64To32(&Line64, Line32);
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
IMAGEAPI
SymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     LPSTR                ModuleName,
    IN     LPSTR                FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line
    )

/*++

Routine Description:

    This function finds an entry in the source file and line-number
    information based on a particular filename and line number.

    A module name can be given if the search is to be restricted to
    a specific module.

    The filename can be omitted if a pure line number search is desired,
    in which case Line must be a previously filled out line number
    struct.  The module and file that Line->Address lies in is used
    to look up the new line number.  This cannot be used when a module
    name is given.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    ModuleName          - Module name or NULL.

    FileName            - File name or NULL.

    dwLineNumber        - Line number of interest.

    plDisplacement      - Difference between requested line number and
                          returned line number.

    Line                - Line information input and return.

Return Value:

    TRUE                - A line was located.

    FALSE               - A line was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi = NULL;
    PLIST_ENTRY         Next;
    IMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl64;
    int                 pass;
    
    static DWORD        flags[2] = {LS_JUST_TEST, LS_QUALIFIED | LS_LOAD_LINES};
    
    __try {
        if (Line->SizeOfStruct != sizeof(IMAGEHLP_LINE64)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        if (ModuleName != NULL) {

            //
            // The caller wants to look in a specific module.
            // A filename must be given in this case because it doesn't
            // make sense to do an address-driven search when a module
            // is explicitly specified since the address also specifies
            // a module.
            //

            if (FileName == NULL) {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }

            mi = FindModule(hProcess, pe, ModuleName, TRUE);
            if (mi != NULL &&
                FindLineByName( mi, FileName, dwLineNumber, plDisplacement, Line )) {
                return TRUE;
            }

            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (FileName == NULL) {
            // Only a line number has been given, implying that
            // it's a line in the same file as the given line is currently in.

            mi = GetModuleForPC( pe, Line->Address, FALSE );
            if (mi == NULL) {
                SetLastError( ERROR_MOD_NOT_FOUND );
                return FALSE;
            }

            if (!LoadSymbols(hProcess, mi, LS_LOAD_LINES)) {
                SetLastError( ERROR_MOD_NOT_FOUND );
                return FALSE;
            }

            if (FindLineByName( mi, FileName, dwLineNumber,
                                plDisplacement, Line )) {
                return TRUE;
            }

            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        Next = pe->ModuleList.Flink;
        if (!Next) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        for (pass = 0; pass < 2; pass++) {
            Next = pe->ModuleList.Flink;
            while (Next != &pe->ModuleList) {
                mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                Next = mi->ListEntry.Flink;

                if (pass && DoSymbolCallback(pe,
                                     CBA_DEFERRED_SYMBOL_LOAD_CANCEL,
                                     mi,
                                     &idsl64,
                                     NULL))
                {
                    break;
                }

                if (!LoadSymbols(hProcess, mi, flags[pass])) 
                    continue;

                if (FindLineByName( mi, FileName, dwLineNumber, plDisplacement, Line )) 
                    return TRUE;
            }
        }

        SetLastError( ERROR_MOD_NOT_FOUND );
        return FALSE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    SetLastError( ERROR_INVALID_FUNCTION );
    return FALSE;
}

BOOL
IMAGEAPI
SymGetLineFromName(
    IN     HANDLE               hProcess,
    IN     LPSTR                ModuleName,
    IN     LPSTR                FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    SympConvertLine32To64(Line32, &Line64);
    if (SymGetLineFromName64(hProcess,
                             ModuleName,
                             FileName,
                             dwLineNumber,
                             plDisplacement,
                             &Line64)) {
        return SympConvertLine64To32(&Line64, Line32);
    } else {
        return FALSE;
    }
}


BOOL
IMAGEAPI
SymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )

/*++

Routine Description:

    This function returns line address information for the line immediately
    following the line given.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Line                - Supplies line number information for the line
                          prior to the one being located.

Return Value:

    TRUE                - A line was located.  The Key, LineNumber and Address
                          of Line are updated.

    FALSE               - No such line exists.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    PSOURCE_LINE        SrcLine;
    PSOURCE_ENTRY       Src;

    __try {
        if (Line->SizeOfStruct != sizeof(IMAGEHLP_LINE64)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( pe, Line->Address, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (!LoadSymbols(hProcess, mi, 0)) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (mi->dia)
            return diaGetLineNext(mi, Line);

        // Use existing information to look up module and then
        // locate the file information.  The key could be extended
        // to make this unnecessary but it's done as a validation step
        // more than as a way to save a DWORD.

        SrcLine = (PSOURCE_LINE)Line->Key;

        for (Src = mi->SourceFiles; Src != NULL; Src = Src->Next) {
            if (SrcLine >= Src->LineInfo &&
                SrcLine < Src->LineInfo+Src->Lines) {
                break;
            }
        }

        if (Src == NULL) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (SrcLine == Src->LineInfo+Src->Lines-1) {
            SetLastError(ERROR_NO_MORE_ITEMS);
            return FALSE;
        }

        SrcLine++;
        Line->Key = SrcLine;
        Line->LineNumber = SrcLine->Line;
        Line->Address = SrcLine->Addr;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymGetLineNext(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE     Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    SympConvertLine32To64(Line32, &Line64);
    if (SymGetLineNext64(hProcess, &Line64)) {
        return SympConvertLine64To32(&Line64, Line32);
    } else {
        return FALSE;
    }
}


BOOL
IMAGEAPI
SymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )

/*++

Routine Description:

    This function returns line address information for the line immediately
    before the line given.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Line                - Supplies line number information for the line
                          after the one being located.

Return Value:

    TRUE                - A line was located.  The Key, LineNumber and Address
                          of Line are updated.

    FALSE               - No such line exists.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      pe;
    PMODULE_ENTRY       mi;
    PSOURCE_LINE        SrcLine;
    PSOURCE_ENTRY       Src;

    __try {
        if (Line->SizeOfStruct != sizeof(IMAGEHLP_LINE64)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( pe, Line->Address, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (!LoadSymbols(hProcess, mi, 0)) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (mi->dia)
            return diaGetLinePrev(mi, Line);

        // Use existing information to look up module and then
        // locate the file information.  The key could be extended
        // to make this unnecessary but it's done as a validation step
        // more than as a way to save a DWORD.

        SrcLine = (PSOURCE_LINE)Line->Key;

        for (Src = mi->SourceFiles; Src != NULL; Src = Src->Next) {
            if (SrcLine >= Src->LineInfo &&
                SrcLine < Src->LineInfo+Src->Lines) {
                break;
            }
        }

        if (Src == NULL) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (SrcLine == Src->LineInfo) {
            SetLastError(ERROR_NO_MORE_ITEMS);
            return FALSE;
        }

        SrcLine--;
        Line->Key = SrcLine;
        Line->LineNumber = SrcLine->Line;
        Line->Address = SrcLine->Addr;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymGetLinePrev(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE     Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    SympConvertLine32To64(Line32, &Line64);
    if (SymGetLinePrev64(hProcess, &Line64)) {
        return SympConvertLine64To32(&Line64, Line32);
    } else {
        return FALSE;
    }
}


BOOL
IMAGEAPI
SymMatchFileName(
    IN  LPSTR  FileName,
    IN  LPSTR  Match,
    OUT LPSTR *FileNameStop,
    OUT LPSTR *MatchStop
    )

/*++

Routine Description:

    This function attempts to match a string against a filename and path.
    The match string is allowed to be a suffix of the complete filename,
    so this function is useful for matching a plain filename against
    a fully qualified filename.

    Matching begins from the end of both strings and proceeds backwards.
    Matching is case-insensitive and equates \ with /.

Arguments:

    FileName            - Filename to match against.

    Match               - String to match against filename.

    FileNameStop        - Returns pointer into FileName where matching stopped.
                          May be one before FileName for full matches.
                          May be NULL.

    MatchStop           - Returns pointer info Match where matching stopped.
                          May be one before Match for full matches.
                          May be NULL.

Return Value:

    TRUE                - Match is a matching suffix of FileName.

    FALSE               - Mismatch.

--*/

{
    LPSTR pF, pM;

    pF = FileName+strlen(FileName)-1;
    pM = Match+strlen(Match)-1;

    while (pF >= FileName && pM >= Match) {
        int chF, chM;

        chF = tolower(*pF);
        chF = chF == '\\' ? '/' : chF;
        chM = tolower(*pM);
        chM = chM == '\\' ? '/' : chM;

        if (chF != chM) {
            break;
        }

        pF--;
        pM--;
    }

    if (FileNameStop != NULL) {
        *FileNameStop = pF;
    }
    if (MatchStop != NULL) {
        *MatchStop = pM;
    }

    return pM < Match;
}


BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    )
/*++

Routine Description:

    Set the address of a callback routine to access extended function
    table entries directly. This function is useful when debugging
    Alpha processes where RUNTIME_FUNCTION_ENTRYs are available from
    sources other than in the image. Two existing examples are:

    1) Access to dynamic function tables for run-time code
    2) Access to function tables for ROM images

Arguments:

    hProcess    - Process handle, must have been previously registered
                  with SymInitialize.


    DirectFunctionTableRoutine - Address of direct function table callback routine.
                  On alpha this routine must return a pointer to the
                  RUNTIME_FUNCTION_ENTRY containing the specified address.
                  If no such entry is available, it must return NULL.

Return Value:

    TRUE        - The callback was successfully registered

    FALSE       - The initialization failed. Most likely failure is that
                  the hProcess parameter is invalid. Call GetLastError()
                  for specific error codes.
--*/
{
    PPROCESS_ENTRY  pe = NULL;

    __try {

        if (!CallbackFunction) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe->pFunctionEntryCallback32 = CallbackFunction;
        pe->pFunctionEntryCallback64 = NULL;
        pe->FunctionEntryUserContext = (ULONG64)UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }
    return TRUE;
}


BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    )
/*++

Routine Description:

    See SymRegisterFunctionEntryCallback64
--*/
{
    PPROCESS_ENTRY  pe = NULL;

    __try {

        if (!CallbackFunction) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe->pFunctionEntryCallback32 = NULL;
        pe->pFunctionEntryCallback64 = CallbackFunction;
        pe->FunctionEntryUserContext = (ULONG64)UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }
    return TRUE;
}

LPVOID
IMAGEAPI
SymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    )
{
    return SymFunctionTableAccess64(hProcess, EXTEND64(AddrBase));
}

LPVOID
IMAGEAPI
SymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )

/*++

Routine Description:

    This function finds a function table entry or FPO record for an address.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    AddrBase            - Supplies an address for which a function table entry
                          or FPO entry is to be located.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY  pe;
    PMODULE_ENTRY   mi;
    PVOID           rtf;
    ULONG_PTR       rva;
    DWORD           bias;
    DWORD           MachineType;

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return NULL;
        }

        // Dynamically generated function table entries
        // may not be in a module, so failing to
        // find a module is not a fatal error.
        mi = GetModuleForPC( pe, AddrBase, FALSE );
        if (mi != NULL) {
            if (!LoadSymbols(hProcess, mi, 0)) {
                SetLastError( ERROR_MOD_NOT_FOUND );
                return NULL;
            }

            MachineType = mi->MachineType;
        } else {
            // We need to guess what kind of machine we
            // should be working with.  First see if ntdll
            // is loaded and if so use its machine type.
            mi = FindModule(hProcess, pe, "ntdll", TRUE);
            if (mi != NULL) {
                MachineType = mi->MachineType;
            } else if (pe->ModuleList.Flink != NULL) {
                // Try the first module's type.
                mi = CONTAINING_RECORD( pe->ModuleList.Flink,
                                        MODULE_ENTRY, ListEntry );
            } else {
                // Use the complation machine.
#if defined(_M_IX86)
                MachineType = IMAGE_FILE_MACHINE_I386;
#elif defined(_M_IA64)
                MachineType = IMAGE_FILE_MACHINE_IA64;
#elif defined(_M_AXP64)
                MachineType = IMAGE_FILE_MACHINE_AXP64;
#elif defined(_M_ALPHA)
                MachineType = IMAGE_FILE_MACHINE_ALPHA;
#elif defined(_M_AMD64)
                MachineType = IMAGE_FILE_MACHINE_AMD64;
#else
#error( "unknown target machine" );
#endif
            }
        }

        switch (MachineType) {
            default:
                rtf = NULL;
                break;

            case IMAGE_FILE_MACHINE_I386:
                rtf = NULL;

                if (mi == NULL) {
                    SetLastError( ERROR_MOD_NOT_FOUND );
                    break;
                }
                
                DWORD64 caddr;
                
                if (!mi->pFpoData)
                    break;
                caddr = ConvertOmapToSrc( mi, AddrBase, &bias, TRUE );
                if (caddr)
                    AddrBase = caddr + bias;
                rtf = SwSearchFpoData( (ULONG)(AddrBase - mi->BaseOfDll), mi->pFpoData, mi->dwEntries );
                if (rtf && mi->cOmapFrom && mi->pFpoDataOmap) {
                    rva = (ULONG_PTR)rtf - (ULONG_PTR)mi->pFpoData;
                    rtf = (PBYTE)mi->pFpoDataOmap + rva;
                }
                break;

            case IMAGE_FILE_MACHINE_ALPHA:
                rtf = LookupFunctionEntryAxp32(hProcess, (DWORD)AddrBase);
                break;

            case IMAGE_FILE_MACHINE_IA64:
                rtf = LookupFunctionEntryIa64(hProcess, AddrBase);
                break;

            case IMAGE_FILE_MACHINE_AXP64:
                rtf = LookupFunctionEntryAxp64(hProcess, AddrBase);
                break;

            case IMAGE_FILE_MACHINE_AMD64:
                rtf = LookupFunctionEntryAmd64(hProcess, AddrBase);
                break;
        }

        if (!rtf) {
            SetLastError( ERROR_INVALID_ADDRESS );
            return NULL;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return NULL;

    }

    return rtf;
}


BOOL
IMAGEAPI
SymGetModuleInfo64(
    IN  HANDLE              hProcess,
    IN  DWORD64             dwAddr,
    OUT PIMAGEHLP_MODULE64  ModuleInfo
    )
{
    PPROCESS_ENTRY          pe;
    PMODULE_ENTRY           mi;
    DWORD                   SizeOfStruct;

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( pe, dwAddr, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        SizeOfStruct = ModuleInfo->SizeOfStruct;
        if (SizeOfStruct > sizeof(IMAGEHLP_MODULE64)) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
        ZeroMemory( ModuleInfo, SizeOfStruct);
        ModuleInfo->SizeOfStruct = SizeOfStruct;

        ModuleInfo->BaseOfImage = mi->BaseOfDll;
        ModuleInfo->ImageSize = mi->DllSize;
        ModuleInfo->NumSyms = mi->numsyms;
        ModuleInfo->CheckSum = mi->CheckSum;
        ModuleInfo->TimeDateStamp = mi->TimeDateStamp;
        ModuleInfo->SymType = mi->SymType;
        ModuleInfo->ModuleName[0] = 0;
        strncat( ModuleInfo->ModuleName, mi->ModuleName,
                 sizeof(ModuleInfo->ModuleName) - 1 );
        if (mi->ImageName) {
            strcpy( ModuleInfo->ImageName, mi->ImageName );
        }
        if (mi->LoadedImageName) {
            strcpy( ModuleInfo->LoadedImageName, mi->LoadedImageName );
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}


BOOL
IMAGEAPI
SymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW   wModInfo
    )
{
    IMAGEHLP_MODULE aModInfo;

    if (wModInfo->SizeOfStruct != sizeof(IMAGEHLP_MODULEW)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    ZeroMemory(wModInfo, sizeof(IMAGEHLP_MODULEW));
    wModInfo->SizeOfStruct = sizeof(IMAGEHLP_MODULEW);

    if (!SympConvertUnicodeModule32ToAnsiModule32(
        wModInfo, &aModInfo))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!SymGetModuleInfo(hProcess, dwAddr, &aModInfo)) {
        return FALSE;
    }

    if (!SympConvertAnsiModule32ToUnicodeModule32(
        &aModInfo, wModInfo)) {

        return FALSE;
    }
    return TRUE;
}

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    IN  HANDLE              hProcess,
    IN  DWORD64             dwAddr,
    OUT PIMAGEHLP_MODULEW64 wModInfo
    )
{

    IMAGEHLP_MODULE64 aModInfo;

    if (!SympConvertUnicodeModule64ToAnsiModule64(
        wModInfo, &aModInfo)) {

        return FALSE;
    }

    if (!SymGetModuleInfo64(hProcess, dwAddr, &aModInfo)) {
        return FALSE;
    }

    if (!SympConvertAnsiModule64ToUnicodeModule64(
        &aModInfo, wModInfo)) {

        return FALSE;
    }
    return TRUE;
}

BOOL
IMAGEAPI
SymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE   ModuleInfo
    )
{
    PPROCESS_ENTRY          pe;
    PMODULE_ENTRY           mi;
    DWORD                   SizeOfStruct;

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( pe,
            dwAddr == (DWORD)-1 ? (DWORD64)-1 : dwAddr, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        SizeOfStruct = ModuleInfo->SizeOfStruct;
        if (SizeOfStruct > sizeof(IMAGEHLP_MODULE)) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
        ZeroMemory( ModuleInfo, SizeOfStruct);
        ModuleInfo->SizeOfStruct = SizeOfStruct;

        ModuleInfo->BaseOfImage = (DWORD)mi->BaseOfDll;
        ModuleInfo->ImageSize = mi->DllSize;
        ModuleInfo->NumSyms = mi->numsyms;
        ModuleInfo->CheckSum = mi->CheckSum;
        ModuleInfo->TimeDateStamp = mi->TimeDateStamp;
        ModuleInfo->SymType = mi->SymType;
        ModuleInfo->ModuleName[0] = 0;
        strncat( ModuleInfo->ModuleName, mi->ModuleName,
                 sizeof(ModuleInfo->ModuleName) - 1 );
        if (mi->ImageName) {
            strcpy( ModuleInfo->ImageName, mi->ImageName );
        }
        if (mi->LoadedImageName) {
            strcpy( ModuleInfo->LoadedImageName, mi->LoadedImageName );
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

DWORD64
IMAGEAPI
SymGetModuleBase64(
    IN  HANDLE  hProcess,
    IN  DWORD64 dwAddr
    )
{
    PPROCESS_ENTRY          pe;
    PMODULE_ENTRY           mi;


    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            return 0;
        }

        mi = GetModuleForPC( pe, dwAddr, FALSE );
        if (mi == NULL) {
            return 0;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return mi->BaseOfDll;
}

DWORD
IMAGEAPI
SymGetModuleBase(
    IN  HANDLE hProcess,
    IN  DWORD  dwAddr
    )
{
    return (ULONG)SymGetModuleBase64(hProcess, dwAddr);
}

BOOL
IMAGEAPI
SymUnloadModule64(
    IN  HANDLE      hProcess,
    IN  DWORD64     BaseOfDll
    )

/*++

Routine Description:

    Remove the symbols for an image from a process' symbol table.

Arguments:

    hProcess - Supplies the token which refers to the process

    BaseOfDll - Supplies the offset to the image as supplies by the
        LOAD_DLL_DEBUG_EVENT and UNLOAD_DLL_DEBUG_EVENT.

Return Value:

    Returns TRUE if the module's symbols were successfully unloaded.
    Returns FALSE if the symbol handler does not recognize hProcess or
    no image was loaded at the given offset.

--*/

{
    PPROCESS_ENTRY  pe;
    PLIST_ENTRY     next;
    PMODULE_ENTRY   mi;


    __try {

        pe = FindProcessEntry(hProcess);
        if (!pe) {
            return FALSE;
        }

        next = pe->ModuleList.Flink;
        if (next) {
            while (next != &pe->ModuleList) {
                mi = CONTAINING_RECORD(next, MODULE_ENTRY, ListEntry);
                if (mi->BaseOfDll == BaseOfDll) {
                    RemoveEntryList(next);
                    FreeModuleEntry(pe, mi);
                    ZeroMemory(pe->DiaCache, sizeof(pe->DiaCache));
                    ZeroMemory(pe->DiaLargeData, sizeof(pe->DiaLargeData));
                    return TRUE;
                }
                next = mi->ListEntry.Flink;
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus(GetExceptionCode());
        return FALSE;
    }

    return FALSE;
}

BOOL
IMAGEAPI
SymUnloadModule(
    IN  HANDLE      hProcess,
    IN  DWORD       BaseOfDll
    )
{
    return SymUnloadModule64(hProcess, BaseOfDll);
}

DWORD64
IMAGEAPI
SymLoadModuleEx(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize,
    IN  PMODLOAD_DATA   Data,
    IN  DWORD           Flags
    )

/*++

Routine Description:

    Loads the symbols for an image for use by the other Sym functions.

Arguments:

    hProcess - Supplies unique process identifier.

    hFile -

    ImageName - Supplies the name of the image file.

    ModuleName - ???? Supplies the module name that will be returned by
            enumeration functions ????

    BaseOfDll - Supplies loaded base address of image.

    DllSize


Return Value:


--*/

{
    __try {

        return InternalLoadModule( hProcess, ImageName, ModuleName, BaseOfDll, DllSize, hFile, Data, Flags );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return 0;
    }
}



DWORD64
IMAGEAPI
SymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize
    )
{
    return SymLoadModuleEx(hProcess, hFile, ImageName, ModuleName, BaseOfDll, DllSize, NULL, 0);
}

DWORD
IMAGEAPI
SymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           DllSize
    )
{
    return (DWORD)SymLoadModule64( hProcess, hFile, ImageName, ModuleName, BaseOfDll, DllSize );
}


BOOL
IMAGEAPI
SymUnDName(
    IN  PIMAGEHLP_SYMBOL  sym,
    OUT LPSTR               UnDecName,
    OUT DWORD               UnDecNameLength
    )
{
    __try {

        if (SymUnDNameInternal( UnDecName,
                                UnDecNameLength-1,
                                sym->Name,
                                strlen(sym->Name),
                                IMAGE_FILE_MACHINE_UNKNOWN,
                                TRUE )) {
            return TRUE;
        } else {
            return FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }
}

BOOL
IMAGEAPI
SymUnDName64(
    IN  PIMAGEHLP_SYMBOL64  sym,
    OUT LPSTR               UnDecName,
    OUT DWORD               UnDecNameLength
    )
{
    __try {

        if (SymUnDNameInternal( UnDecName,
                                UnDecNameLength-1,
                                sym->Name,
                                strlen(sym->Name),
                                IMAGE_FILE_MACHINE_UNKNOWN,
                                TRUE )) {
            return TRUE;
        } else {
            return FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }
}


BOOL
IMAGEAPI
SymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT LPSTR           SearchPath,
    IN  DWORD           SearchPathLength
    )

/*++

Routine Description:

    This function looks up the symbol search path associated with a process.

Arguments:

    hProcess - Supplies the token associated with a process.

Return Value:

    A pointer to the search path.  Returns NULL if the process is not
    know to the symbol handler.

--*/

{
    PPROCESS_ENTRY pe;


    __try {

        pe = FindProcessEntry( hProcess );

        if (!pe) {
            return FALSE;
        }

        SearchPath[0] = 0;
        strncat( SearchPath, pe->SymbolSearchPath, SearchPathLength );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}


BOOL
IMAGEAPI
SymSetSearchPath(
    HANDLE      hProcess,
    LPSTR       UserSearchPath
    )

/*++

Routine Description:

    This functions sets the searh path to be used by the symbol loader
    for the given process.  If UserSearchPath is not supplied, a default
    path will be used.

Arguments:

    hProcess - Supplies the process token associated with a symbol table.

    UserSearchPath - Supplies the new search path to associate with the
        process. If this argument is NULL, the following path is generated:

        .;%_NT_SYMBOL_PATH%;%_NT_ALTERNATE_SYMBOL_PATH%

        It is ok if any or all of the environment variables is missing.

Return Value:

    A pointer to the new search path.  The user should not modify this string.
    Returns NULL if the process is not known to the symbol handler.

--*/

{
    PPROCESS_ENTRY  pe;
    LPSTR           p;
    DWORD           cbSymPath;
    DWORD           cb;
    char            ExpandedSearchPath[MAX_PATH];

    __try {

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            return FALSE;
        }

        if (pe->SymbolSearchPath) {
            MemFree(pe->SymbolSearchPath);
        }

        if (UserSearchPath) {
            cbSymPath = ExpandEnvironmentStrings(UserSearchPath,
                                     ExpandedSearchPath,
                                     sizeof(ExpandedSearchPath) / sizeof(ExpandedSearchPath[0]));
            if (cbSymPath < sizeof(ExpandedSearchPath)/sizeof(ExpandedSearchPath[0])) {
            pe->SymbolSearchPath = StringDup(ExpandedSearchPath);
            } else {
                pe->SymbolSearchPath = (LPSTR)MemAlloc( cbSymPath );
                ExpandEnvironmentStrings(UserSearchPath,
                                         pe->SymbolSearchPath,
                                         cbSymPath );
            }
        } else {

            //
            // ".;%_NT_SYMBOL_PATH%;%_NT_ALTERNATE_SYMBOL_PATH%
            //

            cbSymPath = 3;     // ".;" and ";" between env vars.

            //
            // GetEnvironmentVariable returns the size of the string
            // INCLUDING the '\0' in this case.
            //
            cbSymPath += GetEnvironmentVariable( SYMBOL_PATH, NULL, 0 );
            cbSymPath += GetEnvironmentVariable( ALTERNATE_SYMBOL_PATH, NULL, 0 );

            p = pe->SymbolSearchPath = (LPSTR) MemAlloc( cbSymPath );
            if (!p) {
                return FALSE;
            }

            *p++ = '.';
            --cbSymPath;

            cb = GetEnvironmentVariable(SYMBOL_PATH, p+1, cbSymPath-1);
            if (cb) {
                *p = ';';
                p += cb+1;
                cbSymPath -= cb+1;
            }

            cb = GetEnvironmentVariable(ALTERNATE_SYMBOL_PATH,
                                        p+1, cbSymPath-1);
            if (cb) {
                *p = ';';
                p += cb+1;
            }

            *p = 0;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    CloseSymbolServer();

    return TRUE;
}


BOOL
IMAGEAPI
EnumerateLoadedModules(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK     EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    )
{
    LOADED_MODULE lm;
    DWORD status = NO_ERROR;

    __try {

        lm.EnumLoadedModulesCallback32 = EnumLoadedModulesCallback;
        lm.EnumLoadedModulesCallback64 = NULL;
        lm.Context = UserContext;

        status = GetProcessModules( hProcess, (PINTERNAL_GET_MODULE)LoadedModuleEnumerator, (PVOID)&lm );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return (status == NO_ERROR);
}


BOOL
IMAGEAPI
EnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    )
{
    LOADED_MODULE lm;
    DWORD status = NO_ERROR;

    __try {

        lm.EnumLoadedModulesCallback64 = EnumLoadedModulesCallback;
        lm.EnumLoadedModulesCallback32 = NULL;
        lm.Context = UserContext;

        status = GetProcessModules(hProcess,
                                   (PINTERNAL_GET_MODULE)LoadedModuleEnumerator,
                                   (PVOID)&lm );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return (status == NO_ERROR);
}

BOOL
IMAGEAPI
SymRegisterCallback(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK   CallbackFunction,
    IN PVOID                         UserContext
    )
{
    PPROCESS_ENTRY  pe = NULL;

    __try {

        if (!CallbackFunction) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe->pCallbackFunction32 = CallbackFunction;
        pe->pCallbackFunction64 = NULL;
        pe->CallbackUserContext = (ULONG64)UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}


BOOL
IMAGEAPI
SymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    )
{
    PPROCESS_ENTRY  pe = NULL;

    __try {

        if (!CallbackFunction) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe = FindProcessEntry( hProcess );
        if (!pe) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pe->pCallbackFunction32 = NULL;
        pe->pCallbackFunction64 = CallbackFunction;
        pe->CallbackUserContext = UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}


void
InitModuleEntry(
    PMODULE_ENTRY mi
    )
{
    ZeroMemory(mi, sizeof(MODULE_ENTRY));
    mi->si.MaxNameLen = 2048;
}


BOOL
SympConvertAnsiModule32ToUnicodeModule32(
    PIMAGEHLP_MODULE  aMod32,
    PIMAGEHLP_MODULEW wMod32
    )
{
    ZeroMemory(wMod32, sizeof(*wMod32));
    wMod32->SizeOfStruct = sizeof(*wMod32);

    wMod32->BaseOfImage = aMod32->BaseOfImage;
    wMod32->ImageSize = aMod32->ImageSize;
    wMod32->TimeDateStamp = aMod32->TimeDateStamp;
    wMod32->CheckSum = aMod32->CheckSum;
    wMod32->NumSyms = aMod32->NumSyms;
    wMod32->SymType = aMod32->SymType;

    if (!ansi2wcs(aMod32->ModuleName, wMod32->ModuleName, 256)) 
        return FALSE;

    if (!ansi2wcs(aMod32->ImageName, wMod32->ImageName, 256))
        return FALSE;

    if (!ansi2wcs(aMod32->LoadedImageName, wMod32->LoadedImageName, 256))
        return FALSE;

    return TRUE;
}

BOOL
SympConvertUnicodeModule32ToAnsiModule32(
    PIMAGEHLP_MODULEW wMod32,
    PIMAGEHLP_MODULE  aMod32
    )
{
    ZeroMemory(aMod32, sizeof(*aMod32));
    aMod32->SizeOfStruct = sizeof(*aMod32);

    aMod32->BaseOfImage = wMod32->BaseOfImage;
    aMod32->ImageSize = wMod32->ImageSize;
    aMod32->TimeDateStamp = wMod32->TimeDateStamp;
    aMod32->CheckSum = wMod32->CheckSum;
    aMod32->NumSyms = wMod32->NumSyms;
    aMod32->SymType = wMod32->SymType;

    if (!wcs2ansi(wMod32->ModuleName, aMod32->ModuleName, lengthof(wMod32->ModuleName)))
        return FALSE;

    if (!wcs2ansi(wMod32->ImageName, aMod32->ImageName, lengthof(wMod32->ImageName)))
        return FALSE;

    if (!wcs2ansi(wMod32->LoadedImageName, aMod32->LoadedImageName, lengthof(wMod32->LoadedImageName)))
        return FALSE;

    return TRUE;
}


BOOL
SympConvertAnsiModule64ToUnicodeModule64(
    PIMAGEHLP_MODULE64  aMod64,
    PIMAGEHLP_MODULEW64 wMod64
    )
{
    ZeroMemory(wMod64, sizeof(*wMod64));
    wMod64->SizeOfStruct = sizeof(*wMod64);

    wMod64->BaseOfImage = aMod64->BaseOfImage;
    wMod64->ImageSize = aMod64->ImageSize;
    wMod64->TimeDateStamp = aMod64->TimeDateStamp;
    wMod64->CheckSum = aMod64->CheckSum;
    wMod64->NumSyms = aMod64->NumSyms;
    wMod64->SymType = aMod64->SymType;

    if (!ansi2wcs(aMod64->ModuleName, wMod64->ModuleName, 256))
        return FALSE;

    if (!ansi2wcs(aMod64->ImageName, wMod64->ImageName, 256))
        return FALSE;

    if (!ansi2wcs(aMod64->LoadedImageName, wMod64->LoadedImageName, 256))
        return FALSE;

    return TRUE;
}

BOOL
SympConvertUnicodeModule64ToAnsiModule64(
    PIMAGEHLP_MODULEW64 wMod64,
    PIMAGEHLP_MODULE64  aMod64
    )
{
    ZeroMemory(aMod64, sizeof(*aMod64));
    aMod64->SizeOfStruct = sizeof(*aMod64);

    aMod64->BaseOfImage = wMod64->BaseOfImage;
    aMod64->ImageSize = wMod64->ImageSize;
    aMod64->TimeDateStamp = wMod64->TimeDateStamp;
    aMod64->CheckSum = wMod64->CheckSum;
    aMod64->NumSyms = wMod64->NumSyms;
    aMod64->SymType = wMod64->SymType;

    if (!wcs2ansi(wMod64->ModuleName, aMod64->ModuleName, lengthof(wMod64->ModuleName)))
        return FALSE;

    if (!wcs2ansi(wMod64->ImageName, aMod64->ImageName, lengthof(wMod64->ImageName)))
        return FALSE;

    if (!wcs2ansi(wMod64->LoadedImageName, aMod64->LoadedImageName, lengthof(wMod64->LoadedImageName)))
        return FALSE;

    return TRUE;
}

BOOL
CopySymbolEntryFromSymbolInfo(
    PSYMBOL_ENTRY se,
    PSYMBOL_INFO  si
    )
{
    se->Size       = si->SizeOfStruct;
    se->Flags      = si->Flags;
    se->Address    = si->Address;
    if (si->Name && se->Name)
        strcpy(se->Name, si->Name);
    se->NameLength = si->NameLen;
    // segment is not used
    // offset is not used
    se->TypeIndex  = si->TypeIndex;
    se->ModBase    = si->ModBase;
    se->Register   = si->Register;

    if (si->Register) {
        ((LARGE_INTEGER *) &se->Address)->HighPart = si->Register;
    }
     return TRUE;
}

BOOL
IMAGEAPI
SymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    IN OUT PSYMBOL_INFO     Symbol
    )
{
    SYMBOL_ENTRY   SymEntry={0};

    if (SympGetSymFromAddr(hProcess, Address, Displacement, &SymEntry)) {
        symcpy2(Symbol, &SymEntry);
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
IMAGEAPI
SymFromName(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    )
{
    SYMBOL_ENTRY sym;

    if (SympGetSymFromName(hProcess, Name, &sym)) {
        symcpy2(Symbol, &sym);
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
IMAGEAPI
SymEnumSymbols(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PCSTR                        Mask,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    return SympEnumerateSymbols(hProcess, 
                                BaseOfDll,
                                (LPSTR)Mask,
                                (PROC) EnumSymbolsCallback,
                                UserContext, 
                                FALSE, 
                                FALSE);
}


BOOL
IMAGEAPI
SymEnumSym(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    return SymEnumSymbols(hProcess, 
                          BaseOfDll,
                          NULL,
                          EnumSymbolsCallback,
                          UserContext); 
}


BOOL
IMAGEAPI
SymEnumTypes(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMERATESYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    PPROCESS_ENTRY      pe;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       mi;

    pe = FindProcessEntry( hProcess );
    if (!pe) {
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    mi = NULL;
    Next = pe->ModuleList.Flink;
    if (Next) {
        while (Next != &pe->ModuleList) {
            mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
            if (!mi)
                break;
            Next = mi->ListEntry.Flink;
            if (mi->BaseOfDll == BaseOfDll)
                break;
        }
    }

    if (!mi) {
        return FALSE;
    }

    return diaEnumUDT(mi, "", EnumSymbolsCallback, UserContext);
}


BOOL
IMAGEAPI
SymGetTypeFromName(
    IN  HANDLE              hProcess,
    IN  ULONG64             BaseOfDll,
    IN  LPSTR               Name,
    OUT PSYMBOL_INFO        Symbol
    )
{
    PPROCESS_ENTRY      pe;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       mi;

    pe = FindProcessEntry( hProcess );
    if (!pe) {
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    mi = NULL;
    Next = pe->ModuleList.Flink;
    if (Next) {
        while (Next != &pe->ModuleList) {
            mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
            if (!mi)
                break;
            Next = mi->ListEntry.Flink;
            if (mi->BaseOfDll == BaseOfDll)
                break;
        }
    }

    if (!mi || mi->BaseOfDll != BaseOfDll) {
        LPSTR p;
        // first check for fully qualified symbol name I.E. mod!sym

        p = strchr( Name, '!' );
        if (p > Name) {

            LPSTR ModName = (LPSTR)MemAlloc(p - Name + 1);
            if (!ModName) {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return FALSE;
            }
            memcpy(ModName, Name, (int)(p - Name));
            ModName[p-Name] = 0;

            //
            // the caller wants to look in a specific module
            //

            mi = FindModule(hProcess, pe, ModName, TRUE);

            MemFree(ModName);

            if (mi == NULL) {

                return FALSE;
            }
            Name = p+1;
        }
    }

    if (diaGetTiForUDT(mi, Name, Symbol)) {
        return TRUE;
    } else {
        return FALSE;
    }

    return FALSE;
}

BOOL
strcmpre(
    LPSTR pStr,
    LPSTR pRE,
    BOOL  fCase
    )
{
    DWORD rc;
    CHAR sz[MAX_SYM_NAME + 2];
    PWSTR wStr = NULL;
    PWSTR wRE = NULL;

    rc = TRUE;

    wStr = AnsiToUnicode(pStr);
    if (!wStr)
        goto exit;;
    wRE = AnsiToUnicode(pRE);
    if (!wRE)
        goto exit;

    rc = CompareRE(wStr, wRE, fCase);
    if (rc == S_OK)
        rc = FALSE;
    else
        rc = TRUE;

exit:
    if (wStr) MemFree(wStr);
    if (wRE) MemFree(wRE);
    
    return (BOOL)rc;
}


BOOL
IMAGEAPI
SymMatchString(
    IN LPSTR string,
    IN LPSTR expression,
    IN BOOL  fCase
    )
{
    return !strcmpre(string, expression, fCase);
}

BOOL
SymEnumSourceFiles(
    IN HANDLE  hProcess,
    IN ULONG64 ModBase,
    IN LPSTR   Mask,
    IN PSYM_ENUMSOURCFILES_CALLBACK cbSrcFiles,
    IN PVOID   UserContext
    )
{
    PPROCESS_ENTRY      pe;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       mi;
    DWORD               i;
    PSYMBOL_ENTRY       sym;
    LPSTR               szSymName;
    SYMBOL_ENTRY        SymEntry={0};
    CHAR                Buffer[2500];
    LPSTR               p;
    CHAR                modmask[200];
    BOOL                rc;
    int                 pass;
    BOOL                fCase;
    
    static DWORD        flags[2] = {LS_JUST_TEST, LS_QUALIFIED | LS_FAIL_IF_LOADED};

    if (!cbSrcFiles) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try {

        pe = FindProcessEntry(hProcess);
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        p = 0;
        modmask[0] = 0;
        if (Mask) 
            p = strchr(Mask, '!');
        if (p > Mask) {
            memcpy(modmask, Mask, (int)(p - Mask));
            modmask[p-Mask] = 0;
            Mask = p + 1;
        }

        for (pass = 0; pass < 2; pass++) {
            Next = pe->ModuleList.Flink;
            if (Next) {
                while (Next != &pe->ModuleList) {
    
                    mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                    Next = mi->ListEntry.Flink;
                    if (ModBase) {
                        if (mi->BaseOfDll != ModBase) 
                            continue;
                    } else if (!MatchModuleName(mi, modmask)) {
                        continue;
                    }
                    
                    if (!LoadSymbols(hProcess, mi, flags[pass])) 
                        continue;
    
                    if (mi->dia) {
                        rc = diaEnumSourceFiles(mi, Mask, cbSrcFiles, UserContext);
                        if (!rc) {
                            if (mi->code == ERROR_CANCELLED) {
                                mi->code = 0;
                                return TRUE;
                            }
                            return rc;
                        }
                        continue;
                    }
#if 0
                    fCase = (g.SymOptions & SYMOPT_CASE_INSENSITIVE) ? FALSE : TRUE;

                    for (i = 0; i < mi->numsyms; i++) {
                        PSYMBOL_INFO SymInfo = (PSYMBOL_INFO) &Buffer[0];
    
                        sym = &mi->symbolTable[i];
                        
                        if (Mask  && *Mask && strcmpre(sym->Name, Mask, fCase))
                            continue;
                        
                    }         
#endif
                }
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}


PWSTR
AnsiToUnicode(
    PSTR pszAnsi
    )
{
    UINT uSizeUnicode;
    PWSTR pwszUnicode;

    if (!pszAnsi) {
        return NULL;
    }

    uSizeUnicode = (strlen(pszAnsi) + 1) * sizeof(wchar_t);
    pwszUnicode = (PWSTR)MemAlloc(uSizeUnicode);

    if (*pszAnsi && pwszUnicode) {

        ZeroMemory(pwszUnicode, uSizeUnicode);
        if (!MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
            pszAnsi, strlen(pszAnsi),
            pwszUnicode, uSizeUnicode)) {

            // Error. Free the string, return NULL.
            MemFree(pwszUnicode);
            pwszUnicode = NULL;
        }
    }

    return pwszUnicode;
}


BOOL
wcs2ansi(
    PWSTR pwsz,
    PSTR  psz,
    DWORD pszlen
    )
{
    BOOL rc;
    int  len;

    assert(psz && pwsz);

    len = wcslen(pwsz);
    if (!len) {
        *psz = 0;
        return TRUE;
    }

    rc = WideCharToMultiByte(CP_ACP,
                             WC_SEPCHARS | WC_COMPOSITECHECK,
                             pwsz,
                             len,
                             psz,
                             pszlen,
                             NULL,
                             NULL);
    if (!rc)
        return FALSE;

    psz[len] = 0;

    return TRUE;
}


BOOL
ansi2wcs(
    PSTR  psz,
    PWSTR pwsz,
    DWORD pwszlen
    )
{
    BOOL rc;
    int  len;

    assert(psz && pwsz);

    len = strlen(psz);
    if (!len) {
        *pwsz = 0L;
        return TRUE;
    }

    rc = MultiByteToWideChar(CP_ACP,
                             MB_COMPOSITE,
                             psz,
                             len,
                             pwsz,
                             pwszlen);
    if (!rc)
        return FALSE;

    pwsz[len] = 0;

    return TRUE;
}


PSTR
UnicodeToAnsi(
    PWSTR pwszUnicode
    )
{
    UINT uSizeAnsi;
    PSTR pszAnsi;

    if (!pwszUnicode) {
        return NULL;
    }

    uSizeAnsi = wcslen(pwszUnicode) + 1;
    pszAnsi = (PSTR)MemAlloc(uSizeAnsi);

    if (*pwszUnicode && pszAnsi) {

        ZeroMemory(pszAnsi, uSizeAnsi);
        if (!WideCharToMultiByte(CP_ACP, WC_SEPCHARS | WC_COMPOSITECHECK,
            pwszUnicode, wcslen(pwszUnicode),
            pszAnsi, uSizeAnsi, NULL, NULL)) {

            // Error. Free the string, return NULL.
            free(pszAnsi);
            pszAnsi = NULL;
        }
    }

    return pszAnsi;
}


#if 0
BOOL
CopyAnsiToUnicode(
    PWSTR pszDest,
    PSTR pszSrc,
    DWORD dwCharCountSizeOfDest
    )
{
    PWSTR pszTmp = AnsiToUnicode(pszSrc);

    if (!pszTmp) {
        return FALSE;
    } else {
        wcsncpy(pszDest, pszTmp, dwCharCountSizeOfDest);
        return TRUE;
    }
}

BOOL
CopyUnicodeToAnsi(
    PSTR pszDest,
    PWSTR pszSrc,
    DWORD dwCharCountSizeOfDest
    )
{
    PSTR pszTmp = UnicodeToAnsi(pszSrc);

    if (!pszTmp) {
        return FALSE;
    } else {
        strncpy(pszDest, pszTmp, dwCharCountSizeOfDest);
        return TRUE;
    }
}
#endif

BOOL
IMAGEAPI
SymGetTypeInfo(
    IN  HANDLE          hProcess,
    IN  DWORD64         ModBase,
    IN  ULONG           TypeId,
    IN  IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    OUT PVOID           pInfo
    )
{
    HRESULT err;

    err = diaGetSymbolInfo(hProcess, ModBase, TypeId, GetType, pInfo);
    SetLastError((ULONG) err);
    return (err==S_OK);
}

//#ifdef _WIN64
#if 0
BOOL  __cdecl  PDBOpenTpi(PDB* ppdb, const char* szMode,  TPI** pptpi) {return FALSE;}
BOOL  __cdecl  PDBCopyTo(PDB* ppdb, const char* szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved){return FALSE;}
BOOL  __cdecl  PDBClose(PDB* ppdb) {return FALSE;}
BOOL  __cdecl  ModQueryImod(Mod* pmod,  USHORT* pimod) {return FALSE;}
BOOL  __cdecl  ModQueryLines(Mod* pmod, BYTE* pbLines, long* pcb) {return FALSE;}
BOOL  __cdecl  DBIQueryModFromAddr(DBI* pdbi, USHORT isect, long off,  Mod** ppmod,  USHORT* pisect,  long* poff,  long* pcb){return FALSE;}
BOOL  __cdecl  ModClose(Mod* pmod){return FALSE;}
BOOL  __cdecl  DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext) {return FALSE;}
BYTE* __cdecl  GSINextSym (GSI* pgsi, BYTE* pbSym) {return NULL;}
BOOL  __cdecl  PDBOpen(char* szPDB,char* szMode,SIG sigInitial,EC* pec,char szError[cbErrMax],PDB** pppdb) {return FALSE;}
BOOL  __cdecl  TypesClose(TPI* ptpi){return FALSE;}
BOOL  __cdecl  GSIClose(GSI* pgsi){return FALSE;}
BOOL  __cdecl  DBIClose(DBI* pdbi){return FALSE;}
BYTE* __cdecl  GSINearestSym (GSI* pgsi, USHORT isect, long off, long* pdisp){return NULL;}
BOOL  __cdecl  PDBOpenValidate(char* szPDB,char* szPath,char* szMode,SIG sig,AGE age,EC* pec,char szError[cbErrMax],PDB** pppdb){return FALSE;}
BOOL  __cdecl  PDBOpenDBI(PDB* ppdb, const char* szMode, const char* szTarget,  DBI** ppdbi){return FALSE;}
BOOL  __cdecl  DBIOpenPublics(DBI* pdbi,  GSI **ppgsi){return FALSE;}
BOOL  __cdecl  DBIQuerySecMap(DBI* pdbi,  BYTE* pb, long* pcb){return FALSE;}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\undname.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    undname.c

Abstract:

    This is the main source file for the UNDNAME utility program.
    This is a simple command line utility for undecorating C++ symbol
    names.

Author:

    Weslwy Witt (wesw) 09-June-1993

Revision History:

--*/

#include <private.h>
#include <ntverp.h>
#include <common.ver>


void
Usage( void )
{
    fprintf( stderr,
             "usage: UNDNAME [-f] decorated-names...\n"
             "       -f Undecorate fully.  Default is to only undecorate the class::member\n");
    exit( 1 );
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char UnDecoratedName[4000];
    DWORD Flags;

    fputs(VER_PRODUCTNAME_STR "\nUNDNAME Version " VER_PRODUCTVERSION_STR, stderr );
    fputs(VER_LEGALCOPYRIGHT_STR "\n\n", stderr);

    if (argc <= 1) {
        Usage();
    }

    if ((argv[1][0] == '-') && (argv[1][1] == 'f')) {
        Flags = UNDNAME_COMPLETE;
        argc--;
        argv++;
    } else {
        Flags = UNDNAME_NAME_ONLY;
    }

    if (argc <= 1) {
        Usage();
    }

    while (--argc) {
        UnDecorateSymbolName( *++argv, UnDecoratedName, sizeof(UnDecoratedName), Flags );
        printf( ">> %s == %s\n", *argv, UnDecoratedName );
    }

    exit( 0 );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\upddbg.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    upddbg.c

Abstract:

    This tool updates debug files to match corresponding binary checksum,
    base address and timestamp

Author:

    Matthew Hoehnen (matthoe) 08-Jun-1995

Revision History:

--*/
#define _IMAGEHLP_SOURCE_
#include <private.h>

BOOL                            fUpdate;
LPSTR                           CurrentImageName;
LOADED_IMAGE                    CurrentImage;
CHAR                            DebugFilePath[_MAX_PATH];
CHAR                            SymbolPathBuffer[MAX_PATH*10];
LPSTR                           SymbolPath;
DWORD                           dw;
LPSTR                           FilePart;
CHAR                            Buffer[MAX_PATH];
PIMAGE_LOAD_CONFIG_DIRECTORY    ConfigInfo;
CHAR                            c;
LPSTR                           p;
BOOL                            DbgHeaderModified;
ULONG                           CheckSum;
HANDLE                          hDbgFile;
ULONG                           cb;
IMAGE_SEPARATE_DEBUG_HEADER     DbgHeader;


VOID
DisplayUsage(
    VOID
    )
{
    fputs("usage: UPDDBG [switches] image-names... \n"
          "              [-?] display this message\n"
          "              [-u] update image\n"
          "              [-s] path to symbol files\n", stderr
          );
}



int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    if (argc <= 1) {
        DisplayUsage();
        return 1;
    }

    _tzset();

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (tolower( c )) {
                case '?':
                    DisplayUsage();
                    return 0;

                case 'u':
                    fUpdate = TRUE;
                    break;

                case 's':
                    argc--, argv++;
                    SymbolPath = *argv;
                    break;

                default:
                    fprintf( stderr, "UPDDBG: Invalid switch - /%c\n", c );
                    DisplayUsage();
                    return 1;
            }
        }
    }

    if (!SymbolPath) {
        if (GetEnvironmentVariable( "_nt_symbol_path", SymbolPathBuffer, sizeof(SymbolPathBuffer)-1 )) {
            SymbolPath = SymbolPathBuffer;
        }
    }

    if (!SymbolPath) {
        fprintf( stderr, "UPDDBG: uknown symbol file path\n" );
        return 1;
    }

    CurrentImageName = p;

    //
    // Map and load the current image
    //

    if (!MapAndLoad( CurrentImageName, NULL, &CurrentImage, FALSE, TRUE )) {
        fprintf( stderr, "UPDDBG: failure mapping and loading %s\n", CurrentImageName );
        return 1;
    }

    CurrentImageName = CurrentImage.ModuleName;

    FlushViewOfFile( CurrentImage.MappedAddress, 0 );

    if (!fUpdate) {
        hDbgFile = FindDebugInfoFile( CurrentImageName, SymbolPath, DebugFilePath );
        if (hDbgFile == INVALID_HANDLE_VALUE || hDbgFile == NULL) {
            fprintf( stderr, "UPDDBG: could not locate DBG file %s\n", CurrentImageName );
            return 1;
        }

        if (!ReadFile( hDbgFile, &DbgHeader, sizeof(IMAGE_SEPARATE_DEBUG_HEADER), &cb, NULL )) {
            fprintf( stderr, "UPDDBG: could not read DBG file %s\n", CurrentImageName );
            return 1;
        }

        printf( "*\n" );
        if (((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum != DbgHeader.CheckSum) {
            printf( "*************************************\n" );
            printf( "* WARNING: checksums do not match   *\n" );
            printf( "*************************************\n" );
            printf( "*\n" );
        }

        _strlwr( CurrentImageName );
        _strlwr( DebugFilePath );

        printf( "Image    0x%08x %s\n", ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum, CurrentImageName );
        printf( "DBG File 0x%08x %s\n", DbgHeader.CheckSum, DebugFilePath );

        return 0;
    }

    if (!((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
        fprintf( stderr, "UPDDBG: symbols have not been split %s\n", CurrentImageName );
        return 1;
    }

    if ( UpdateDebugInfoFileEx( CurrentImageName,
                                SymbolPath,
                                DebugFilePath,
                                (PIMAGE_NT_HEADERS32)(CurrentImage.FileHeader),
                                ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum
                                ) ) {
        if (GetLastError() == ERROR_INVALID_DATA) {
            printf( "UPDDBG: Warning - Old checksum did not match for %s\n", DebugFilePath );
        }
        printf( "Updated symbols for %s\n", DebugFilePath );
    } else {
        printf( "Unable to update symbols: %s\n", DebugFilePath );
    }

    return 0;
}

#define _BUILDING_UPDDBG_
#include "upddbgi.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\upddbgi.c ===
#include <private.h>
#include <globals.h>

// Random debug info modification functions for imagehlp


BOOL
IMAGEAPI
UpdateDebugInfoFile(
    LPSTR ImageFileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath,
    PIMAGE_NT_HEADERS32 NtHeaders
    )
{
    return UpdateDebugInfoFileEx(
                ImageFileName,
                SymbolPath,
                DebugFilePath,
                NtHeaders,
                NtHeaders->OptionalHeader.CheckSum);
}

BOOL
IMAGEAPI
UpdateDebugInfoFileEx(
    LPSTR ImageFileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath,
    PIMAGE_NT_HEADERS32 NtHeaders,
    DWORD OldCheckSum
    )
{
    // UnSafe...

    HANDLE hDebugFile, hMappedFile;
    PVOID MappedAddress;
    PIMAGE_SEPARATE_DEBUG_HEADER DbgFileHeader;
    DWORD dwError = ERROR_SUCCESS;

#ifdef _BUILDING_UPDDBG_
    OSVERSIONINFO OSVerInfo;
    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OSVerInfo);
#endif

    hDebugFile = FindDebugInfoFile(
                    ImageFileName,
                    SymbolPath,
                    DebugFilePath
                    );
    if ( hDebugFile == NULL ) {
        return FALSE;
    }
    CloseHandle(hDebugFile);

    hDebugFile = CreateFile( DebugFilePath,
                             GENERIC_READ | GENERIC_WRITE,
                             g.OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE) : (FILE_SHARE_READ | FILE_SHARE_WRITE),
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );
    if ( hDebugFile == INVALID_HANDLE_VALUE ) {
        return FALSE;
    }

    hMappedFile = CreateFileMapping(
                    hDebugFile,
                    NULL,
                    PAGE_READWRITE,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        CloseHandle(hDebugFile);
        return FALSE;
    }

    MappedAddress = MapViewOfFile(hMappedFile,
                        FILE_MAP_WRITE,
                        0,
                        0,
                        0
                        );
    CloseHandle(hMappedFile);
    if ( !MappedAddress ) {
        CloseHandle(hDebugFile);
        return FALSE;
    }

    DbgFileHeader = (PIMAGE_SEPARATE_DEBUG_HEADER)MappedAddress;
    if (DbgFileHeader->ImageBase != NtHeaders->OptionalHeader.ImageBase ||
        DbgFileHeader->CheckSum != NtHeaders->OptionalHeader.CheckSum   ||
        DbgFileHeader->SizeOfImage != NtHeaders->OptionalHeader.SizeOfImage
       ) {
        DbgFileHeader->ImageBase = NtHeaders->OptionalHeader.ImageBase;
        if (OldCheckSum != DbgFileHeader->CheckSum) {
            DbgFileHeader->Flags |= IMAGE_SEPARATE_DEBUG_MISMATCH;
            dwError = ERROR_INVALID_DATA;
        }
        DbgFileHeader->CheckSum = NtHeaders->OptionalHeader.CheckSum;
        DbgFileHeader->TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
        DbgFileHeader->SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;
        FlushViewOfFile(MappedAddress,0);
        UnmapViewOfFile(MappedAddress);
        TouchFileTimes(hDebugFile,NULL);
        CloseHandle(hDebugFile);
        SetLastError(dwError);
        return TRUE;
    } else {
        FlushViewOfFile(MappedAddress,0);
        UnmapViewOfFile(MappedAddress);
        CloseHandle(hDebugFile);
        return FALSE;
    }
}
#ifndef _BUILDING_UPDDBG_

BOOL
IMAGEAPI
RemovePrivateCvSymbolic(
    PCHAR   DebugData,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    )
{
    BOOL rc;
    rc = RemovePrivateCvSymbolicEx(DebugData, 0, NewDebugData, NewDebugSize);
    if (rc && (*NewDebugSize == 0) && (*NewDebugData == DebugData)) {
        *NewDebugData = NULL;
    }
    return(rc);
}

BOOL
IMAGEAPI
RemovePrivateCvSymbolicEx(
    PCHAR   DebugData,
    ULONG   DebugSize,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    )
{
    OMFSignature       *CvDebugData, *NewStartCvSig, *NewEndCvSig;
    OMFDirEntry        *CvDebugDirEntry;
    OMFDirHeader       *CvDebugDirHead;
    unsigned int        i, j;
    PCHAR               NewCvData;
    ULONG               NewCvSize = 0, NewCvOffset;
    BOOL                RC = FALSE;

    __try {
        CvDebugDirHead  = NULL;
        CvDebugDirEntry = NULL;
        CvDebugData = (OMFSignature *)DebugData;

        if ((((*(PULONG)(CvDebugData->Signature)) == '90BN') ||
             ((*(PULONG)(CvDebugData->Signature)) == '80BN') ||
             ((*(PULONG)(CvDebugData->Signature)) == '11BN'))  &&
            ((CvDebugDirHead = (OMFDirHeader *)((PUCHAR) CvDebugData + CvDebugData->filepos)) != NULL) &&
            ((CvDebugDirEntry = (OMFDirEntry *)((PUCHAR) CvDebugDirHead + CvDebugDirHead->cbDirHeader)) != NULL)) {

            // Walk the directory.  Keep what we want, zero out the rest.

            for (i=0, j=0; i < CvDebugDirHead->cDir; i++) {
                switch (CvDebugDirEntry[i].SubSection) {
                    case sstSegMap:
                    case sstSegName:
                    case sstOffsetMap16:
                    case sstOffsetMap32:
                    case sstModule:
                    case SSTMODULE:
                    case SSTPUBLIC:
                    case sstPublic:
                    case sstPublicSym:
                    case sstGlobalPub:
                        CvDebugDirEntry[j] = CvDebugDirEntry[i];
                        NewCvSize += CvDebugDirEntry[j].cb;
                        NewCvSize = (NewCvSize + 3) & ~3;
                        if (i != j++) {
                            // Clear the old entry.
                            RtlZeroMemory(&CvDebugDirEntry[i], CvDebugDirHead->cbDirEntry);
                        }
                        break;

                    default:
                        RC = TRUE;
                        RtlZeroMemory(CvDebugDirEntry[i].lfo + (PUCHAR) CvDebugData, CvDebugDirEntry[i].cb);
                        RtlZeroMemory(&CvDebugDirEntry[i], CvDebugDirHead->cbDirEntry);
                        break;
                }
            }

            // Now, allocate the new cv data.

            CvDebugDirHead->cDir = j;

            NewCvSize += (j * CvDebugDirHead->cbDirEntry) + // The directory itself
                            CvDebugDirHead->cbDirHeader +   // The directory header
                            (sizeof(OMFSignature) * 2);     // The signature/offset pairs at each end.

            NewCvData = (PCHAR) MemAlloc( NewCvSize );

            // And move the stuff we kept into the new section.

            NewCvOffset = sizeof(OMFSignature);

            RtlCopyMemory(NewCvData + NewCvOffset, CvDebugDirHead, CvDebugDirHead->cbDirHeader);

            CvDebugDirHead = (OMFDirHeader *) (NewCvData + NewCvOffset);

            NewCvOffset += CvDebugDirHead->cbDirHeader;

            RtlCopyMemory(NewCvData + NewCvOffset,
                        CvDebugDirEntry,
                        CvDebugDirHead->cDir * CvDebugDirHead->cbDirEntry);

            CvDebugDirEntry = (OMFDirEntry *)(NewCvData + NewCvOffset);

            NewCvOffset += (CvDebugDirHead->cbDirEntry * CvDebugDirHead->cDir);

            for (i=0; i < CvDebugDirHead->cDir; i++) {
                RtlCopyMemory(NewCvData + NewCvOffset,
                            CvDebugDirEntry[i].lfo + (PCHAR) CvDebugData,
                            CvDebugDirEntry[i].cb);
                CvDebugDirEntry[i].lfo = NewCvOffset;
                NewCvOffset += (CvDebugDirEntry[i].cb + 3) & ~3;
            }


            // Re-do the start/end signatures

            NewStartCvSig = (OMFSignature *) NewCvData;
            NewEndCvSig   = (OMFSignature *) ((PCHAR)NewCvData + NewCvOffset);
            *(PULONG)(NewStartCvSig->Signature) = *(PULONG)(CvDebugData->Signature);
            NewStartCvSig->filepos = (int)((PCHAR)CvDebugDirHead - (PCHAR)NewStartCvSig);
            *(PULONG)(NewEndCvSig->Signature) = *(PULONG)(CvDebugData->Signature);
            NewCvOffset += sizeof(OMFSignature);
            NewEndCvSig->filepos = (LONG)NewCvOffset;

            // Set the return values appropriately

            *NewDebugData = NewCvData;
            *NewDebugSize = NewCvSize;

        } else {
            if (*(PULONG)(CvDebugData->Signature) == '01BN') {
                *NewDebugData = DebugData;
                *NewDebugSize = DebugSize;
                RC = TRUE;
            } else {
                // Not NB10, NB09 or NB08.  Forget we ever heard of it.
                *NewDebugData = DebugData;
                *NewDebugSize = 0;
                RC = TRUE;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        RC = FALSE;
    }

    return(RC);
}

#include <copypdb.c>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\verfix.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    verfix.c

Abstract:

    This module fixes updates the major and minor subsystem version
    numbers in an executable and recomputes the checksum.

Author:

    Robert Reichel (robertre) 2-May-1993

Revision History:

--*/

#include <private.h>


#define NEW_MAJOR_VERSION  3
#define NEW_MINOR_VERSION  10

void Usage()
{
    fputs(  "usage: VERFIX [-?] [-v] [-q] image-names...\n"
            "              [-?] display this message\n"
            "              [-n #.#] Subsystem Major.Minor versions (default to 3.10)\n"
            "              [-q] quiet on failure\n"
            "              [-v] verbose output\n",
          stderr);
    exit( 1 );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID BaseAddress;
    ULONG CheckSum;
    ULONG FileLength;
    ULONG HeaderSum;
    ULONG OldCheckSum;
    USHORT MajorSubsystemVersion;
    USHORT MinorSubsystemVersion;
    ULONG NewMajorSubsystemVersion = NEW_MAJOR_VERSION;
    ULONG NewMinorSubsystemVersion = NEW_MINOR_VERSION;
    LPSTR ImageName;
    BOOLEAN fVerbose = FALSE;
    BOOLEAN fQuiet = FALSE;
    LPSTR s;
    UCHAR c;

    if (argc <= 1) {
        Usage();
        }

    --argc;
    while (argc) {
        s = *++argv;
        if ( *s == '-' ) {
            while (c=*++s) {
                switch (c) {
                    case 'q':
                    case 'Q':
                        fQuiet = TRUE;
                        break;

                    case 'v':
                    case 'V':
                        fVerbose=TRUE;
                        break;

                    case 'n':
                    case 'N':
                        s = *++argv;
                        --argc;
                        sscanf(s, "%d.%d", &NewMajorSubsystemVersion, &NewMinorSubsystemVersion);
                        goto NextArgument;
                        break;

                    case 'h':
                    case 'H':
                    case '?':
                        Usage();

                    default:
                        fprintf( stderr, "VERFIX: illegal option /%c\n", c );
                        Usage();
                    }
                }
        } else {
            ImageName = s;
            FileHandle = CreateFile( ImageName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL
                                   );
            if (FileHandle == INVALID_HANDLE_VALUE) {
                if (!fQuiet) {
                    fprintf( stderr, "VERFIX: Unable to open %s (%u) - skipping\n", ImageName, GetLastError() );
                    goto NextArgument;
                }
            }

            MappingHandle = CreateFileMapping( FileHandle,
                                           NULL,
                                           PAGE_READWRITE,
                                           0,
                                           0,
                                           NULL
                                         );
            if (MappingHandle == NULL) {
                CloseHandle( FileHandle );
                if (!fQuiet) {
                    fprintf( stderr, "VERFIX: Unable to create mapping object for file %s (%u) - skipping\n", ImageName, GetLastError() );
                }
            } else {
                BaseAddress = MapViewOfFile( MappingHandle,
                                             FILE_MAP_READ | FILE_MAP_WRITE,
                                             0,
                                             0,
                                             0
                                           );
                CloseHandle( MappingHandle );
                if (BaseAddress == NULL) {
                    CloseHandle( FileHandle );
                    if (!fQuiet ) {
                        fprintf( stderr, "VERFIX: Unable to map view of file %s (%u) - skipping\n", ImageName, GetLastError() );
                    }
                } else {
                    //
                    // Get the length of the file in bytes and compute the checksum.
                    //

                    FileLength = GetFileSize( FileHandle, NULL );

                    //
                    // Obtain a pointer to the header information.
                    //

                    NtHeaders = ImageNtHeader( BaseAddress );
                    if (NtHeaders == NULL) {
                        CloseHandle( FileHandle );
                        UnmapViewOfFile( BaseAddress );
                        if (!fQuiet) {
                            fprintf( stderr, "VERFIX: %s is not a valid image file - skipping\n", ImageName, GetLastError() );
                        }
                    } else {
                        //
                        // Write the information to the file.  Update the
                        // SubsystemVersion major and minor codes.
                        //

                        MajorSubsystemVersion = NtHeaders->OptionalHeader.MajorSubsystemVersion;
                        MinorSubsystemVersion = NtHeaders->OptionalHeader.MinorSubsystemVersion;
                        OldCheckSum = NtHeaders->OptionalHeader.CheckSum;

                        NtHeaders->OptionalHeader.MajorSubsystemVersion = (USHORT)NewMajorSubsystemVersion;
                        NtHeaders->OptionalHeader.MinorSubsystemVersion = (USHORT)NewMinorSubsystemVersion;

                        //
                        // Recompute and reset the checksum of the modified file.
                        //

                        (VOID) CheckSumMappedFile( BaseAddress,
                                                   FileLength,
                                                   &HeaderSum,
                                                   &CheckSum
                                                 );

                        NtHeaders->OptionalHeader.CheckSum = CheckSum;

                        if (fVerbose) {
                            printf( "%s - Old version: %u.%u  Old Checksum: %x",
                                    ImageName, MajorSubsystemVersion, MinorSubsystemVersion, OldCheckSum
                                  );

                            printf( "  New version: %u.%u  New Checksum: %x\n",
                                    NtHeaders->OptionalHeader.MajorSubsystemVersion,
                                    NtHeaders->OptionalHeader.MinorSubsystemVersion,
                                    NtHeaders->OptionalHeader.CheckSum
                                  );
                        }

                        if (!FlushViewOfFile( BaseAddress, FileLength )) {
                            if (!fQuiet) {
                                fprintf( stderr,
                                         "VERFIX: Flush of %s failed (%u)\n",
                                         ImageName,
                                         GetLastError()
                                       );
                            }
                        }

                        UnmapViewOfFile( BaseAddress );
                        if (!TouchFileTimes( FileHandle, NULL )) {
                            if (!fQuiet) {
                                fprintf( stderr, "VERFIX: Unable to touch file %s (%u)\n", ImageName, GetLastError() );
                            }
                        }

                        CloseHandle( FileHandle );
                    }
                }
            }
        }
NextArgument:
        --argc;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\walk.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    walk.c

Abstract:

    This function implements the stack walking api.

Author:

    Wesley Witt (wesw) 1-Oct-1993

Environment:

    User Mode

--*/

#include <private.h>
#include "globals.h"

#ifndef PAGE_SIZE
#if defined(_X86_) || defined(_AMD64_)
#define PAGE_SIZE 0x1000
#elif defined(_ALPHA_) || defined(_IA64_)
#define PAGE_SIZE 0x2000
#else
#error Unknown processor architecture
#endif
#endif

BOOL
ReadMemoryRoutineLocal(
    HANDLE  hProcess,
    DWORD64 qwBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    );

LPVOID
FunctionTableAccessRoutineLocal(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

DWORD64
GetModuleBaseRoutineLocal(
    HANDLE  hProcess,
    DWORD64 ReturnAddress
    );

DWORD64
TranslateAddressRoutineLocal(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    );

BOOL
ImagepReadMemoryThunk(
    HANDLE  hProcess,
    DWORD64 qwBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    PREAD_PROCESS_MEMORY_ROUTINE fnImagepUserReadMemory32;
    
    fnImagepUserReadMemory32 = tlsvar(ImagepUserReadMemory32);
    return fnImagepUserReadMemory32(
                        hProcess,
                        (DWORD)qwBaseAddress,
                        lpBuffer,
                        nSize,
                        lpNumberOfBytesRead
                        );
}

LPVOID
ImagepFunctionTableAccessThunk(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{
    PFUNCTION_TABLE_ACCESS_ROUTINE  fnImagepUserFunctionTableAccess32;
    
    fnImagepUserFunctionTableAccess32 = tlsvar(ImagepUserFunctionTableAccess32);
    return fnImagepUserFunctionTableAccess32(
                hProcess,
                (DWORD)AddrBase
                );
}

PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
AlphaFunctionTableAccessThunk(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{
    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY FunctionEntry32;
    PFUNCTION_TABLE_ACCESS_ROUTINE  fnImagepUserFunctionTableAccess32;

    fnImagepUserFunctionTableAccess32 = tlsvar(ImagepUserFunctionTableAccess32);
    FunctionEntry32 = (PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)
                        fnImagepUserFunctionTableAccess32(
                            hProcess,
                            (DWORD)AddrBase
                            );

    if (FunctionEntry32) {
        ConvertAlphaRf32To64( FunctionEntry32, &tlsvar(Axp64FunctionEntry) );

        return &tlsvar(Axp64FunctionEntry);
    }

    return NULL;
}

DWORD64
ImagepGetModuleBaseThunk(
    HANDLE  hProcess,
    DWORD64 ReturnAddress
    )
{
    PGET_MODULE_BASE_ROUTINE fnImagepUserGetModuleBase32;
    
    fnImagepUserGetModuleBase32 = tlsvar(ImagepUserGetModuleBase32);
    return (ULONG64)(LONG64)(LONG)fnImagepUserGetModuleBase32(
                hProcess,
                (DWORD)ReturnAddress
                );
}

DWORD64
ImagepTranslateAddressThunk(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    )
{
    return 0;
}

void
StackFrame32To64(
    LPSTACKFRAME StackFrame32,
    LPSTACKFRAME64 StackFrame64
    )
{
    Address32To64(&StackFrame32->AddrPC, &StackFrame64->AddrPC );
    Address32To64(&StackFrame32->AddrReturn, &StackFrame64->AddrReturn );
    Address32To64(&StackFrame32->AddrFrame, &StackFrame64->AddrFrame );
    Address32To64(&StackFrame32->AddrStack, &StackFrame64->AddrStack );
    StackFrame64->FuncTableEntry = StackFrame32->FuncTableEntry;
    StackFrame64->Far = StackFrame32->Far;
    StackFrame64->Virtual = StackFrame32->Virtual;
    StackFrame64->Params[0] = StackFrame32->Params[0];
    StackFrame64->Params[1] = StackFrame32->Params[1];
    StackFrame64->Params[2] = StackFrame32->Params[2];
    StackFrame64->Params[3] = StackFrame32->Params[3];
    StackFrame64->Reserved[0] = StackFrame32->Reserved[0];
    StackFrame64->Reserved[1] = StackFrame32->Reserved[1];
    StackFrame64->Reserved[2] = StackFrame32->Reserved[2];
    KdHelp32To64(&StackFrame32->KdHelp, &StackFrame64->KdHelp);
}

void
StackFrame64To32(
    LPSTACKFRAME64 StackFrame64,
    LPSTACKFRAME StackFrame32
    )
{
    Address64To32(&StackFrame64->AddrPC, &StackFrame32->AddrPC );
    Address64To32(&StackFrame64->AddrReturn, &StackFrame32->AddrReturn );
    Address64To32(&StackFrame64->AddrFrame, &StackFrame32->AddrFrame );
    Address64To32(&StackFrame64->AddrStack, &StackFrame32->AddrStack );
    StackFrame32->FuncTableEntry = StackFrame64->FuncTableEntry;
    StackFrame32->Far = StackFrame64->Far;
    StackFrame32->Virtual = StackFrame64->Virtual;
    StackFrame32->Params[0] = (ULONG)StackFrame64->Params[0];
    StackFrame32->Params[1] = (ULONG)StackFrame64->Params[1];
    StackFrame32->Params[2] = (ULONG)StackFrame64->Params[2];
    StackFrame32->Params[3] = (ULONG)StackFrame64->Params[3];
    StackFrame32->Reserved[0] = (ULONG)StackFrame64->Reserved[0];
    StackFrame32->Reserved[1] = (ULONG)StackFrame64->Reserved[1];
    StackFrame32->Reserved[2] = (ULONG)StackFrame64->Reserved[2];
}

BOOL
StackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                    StackFrame32,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE    ReadMemory32,
    PFUNCTION_TABLE_ACCESS_ROUTINE  FunctionTableAccess32,
    PGET_MODULE_BASE_ROUTINE        GetModuleBase32,
    PTRANSLATE_ADDRESS_ROUTINE      TranslateAddress32
    )
{
    BOOL rval;
    BOOL UseSym = FALSE;
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory;
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess;
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase;
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress;
    STACKFRAME64                      StackFrame;

    // Alpha stack walking no longer requires the FunctionTableAccess callback
    // except for backward compatability with debuggers that didn't specify
    // a GetModuleBase callback. If the GetModuleBase routine is provided
    // then set FunctionTableAccess to NULL to prevent a mixture of the
    // callback and read-from-image methods of accessing function table entries.

    if (MachineType == IMAGE_FILE_MACHINE_ALPHA) {
        if (GetModuleBase32 == NULL && FunctionTableAccess32) {
            FunctionTableAccess = (PFUNCTION_TABLE_ACCESS_ROUTINE64)AlphaFunctionTableAccessThunk;
            tlsvar(ImagepUserFunctionTableAccess32) = FunctionTableAccess32;
        } else {
            FunctionTableAccess = NULL;
        }
    } else {
        if (FunctionTableAccess32) {
            tlsvar(ImagepUserFunctionTableAccess32) = FunctionTableAccess32;
            FunctionTableAccess = ImagepFunctionTableAccessThunk;
        } else {
            FunctionTableAccess = FunctionTableAccessRoutineLocal;
            UseSym = TRUE;
        }
    }

    if (GetModuleBase32) {
        tlsvar(ImagepUserGetModuleBase32) = GetModuleBase32;
        GetModuleBase = ImagepGetModuleBaseThunk;
    } else {
        GetModuleBase = GetModuleBaseRoutineLocal;
        UseSym = TRUE;
    }

    if (ReadMemory32) {
        tlsvar(ImagepUserReadMemory32) = ReadMemory32;
        ReadMemory = ImagepReadMemoryThunk;
    } else {
        ReadMemory = ReadMemoryRoutineLocal;
    }

    if (TranslateAddress32) {
        tlsvar(ImagepUserTranslateAddress32) = TranslateAddress32;
        TranslateAddress = ImagepTranslateAddressThunk;
    } else {
        TranslateAddress = TranslateAddressRoutineLocal;
    }

    if (UseSym) {
        //
        // We are using the code in symbols.c
        // hProcess better be a real valid process handle
        //

        //
        // Always call syminitialize.  It's a nop if process
        // is already loaded.
        //
        if (!SymInitialize( hProcess, NULL, FALSE )) {
            return FALSE;
        }

    }

    StackFrame32To64(StackFrame32, &StackFrame);

    switch (MachineType) {
        case IMAGE_FILE_MACHINE_I386:
            rval = WalkX86( hProcess,
                            hThread,
                            &StackFrame,
                            ContextRecord,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress,
                            0
                            );
            break;

        case IMAGE_FILE_MACHINE_ALPHA:
            rval = WalkAlpha( hProcess,
                              &StackFrame,
                              ContextRecord,
                              ReadMemory,
                              GetModuleBase,
                              FunctionTableAccess,
                              FALSE
                              );
            break;

        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_ALPHA64:
        case IMAGE_FILE_MACHINE_AMD64:
        default:
            rval = FALSE;
            break;
    }
    if (rval) {
        StackFrame64To32(&StackFrame, StackFrame32);
    }

    return rval;
}


BOOL
StackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL rval;
    BOOL UseSym = FALSE;

    g.MachineType = MachineType;
    if (!FunctionTableAccess) {
        FunctionTableAccess = FunctionTableAccessRoutineLocal;
        UseSym = TRUE;
    }

    if (!GetModuleBase) {
        GetModuleBase = GetModuleBaseRoutineLocal;
        UseSym = TRUE;
    }

    if (!ReadMemory) {
        ReadMemory = ReadMemoryRoutineLocal;
    }

    if (!TranslateAddress) {
        TranslateAddress = TranslateAddressRoutineLocal;
    }

    if (UseSym) {
        //
        // We are using the code in symbols.c
        // hProcess better be a real valid process handle
        //

        //
        // Always call syminitialize.  It's a nop if process
        // is already loaded.
        //
        if (!SymInitialize( hProcess, NULL, FALSE )) {
            return FALSE;
        }

    }

    switch (MachineType) {
        case IMAGE_FILE_MACHINE_I386:
            rval = WalkX86( hProcess,
                            hThread,
                            StackFrame,
                            ContextRecord,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress,
                            WALK_FIX_FPO_EBP
                            );

            break;

        case IMAGE_FILE_MACHINE_IA64:
            rval = WalkIa64( hProcess,
                             StackFrame,
                             ContextRecord,
                             ReadMemory,
                             FunctionTableAccess,
                             GetModuleBase
                             );
            break;

        case IMAGE_FILE_MACHINE_ALPHA:
            rval = WalkAlpha( hProcess,
                              StackFrame,
                              ContextRecord,
                              ReadMemory,
                              GetModuleBase,
                              FunctionTableAccess,
                              FALSE
                              );
            break;

        case IMAGE_FILE_MACHINE_ALPHA64:
            rval = WalkAlpha( hProcess,
                              StackFrame,
                              ContextRecord,
                              ReadMemory,
                              GetModuleBase,
                              FunctionTableAccess,
                              TRUE
                              );
            break;

        case IMAGE_FILE_MACHINE_AMD64:
            rval = WalkAmd64( hProcess,
                              StackFrame,
                              ContextRecord,
                              ReadMemory,
                              FunctionTableAccess,
                              GetModuleBase
                              );
            break;

        default:
            rval = FALSE;
            break;
    }

    return rval;
}

BOOL
ReadMemoryRoutineLocal(
    HANDLE  hProcess,
    DWORD64 qwBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    // ReadProcessMemory will fail if any part of the
    // region to read does not have read access.  This
    // routine attempts to read the largest valid prefix
    // so it has to break up reads on page boundaries.

    BOOL Status = TRUE;
    SIZE_T TotalBytesRead = 0;
    SIZE_T Read;
    ULONG ReadSize;

    while (nSize > 0) {
        
        // Calculate bytes to read and don't let read cross
        // a page boundary.
        ReadSize = PAGE_SIZE - (ULONG)(qwBaseAddress & (PAGE_SIZE - 1));
        ReadSize = min(nSize, ReadSize);

        if (!ReadProcessMemory(hProcess, (PVOID)(ULONG_PTR)qwBaseAddress,
                               lpBuffer, ReadSize, &Read)) {
            if (TotalBytesRead == 0) {
                // If we haven't read anything indicate failure.
                Status = FALSE;
            }
            break;
        }

        TotalBytesRead += Read;
        qwBaseAddress += Read;
        lpBuffer = (PVOID)((PUCHAR)lpBuffer + Read);
        nSize -= (DWORD)Read;
    }

    *lpNumberOfBytesRead = (DWORD)TotalBytesRead;
    return Status;
}

LPVOID
FunctionTableAccessRoutineLocal(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{
    return SymFunctionTableAccess64(hProcess, AddrBase);
}

DWORD64
GetModuleBaseRoutineLocal(
    HANDLE  hProcess,
    DWORD64 ReturnAddress
    )
{
    IMAGEHLP_MODULE64 ModuleInfo = {0};
    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);

    if (SymGetModuleInfo64(hProcess, ReturnAddress, &ModuleInfo)) {
        return ModuleInfo.BaseOfImage;
    } else {
        return 0;
    }
}


DWORD64
TranslateAddressRoutineLocal(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 paddr
    )
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\vwndia64.c ===
/**
***  Copyright  (C) 1996-1999 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
****************************************************************************
***
*** Thierry 09/21/99 - v16
*** WARNING: ntos\rtl\ia64\vunwind.c and sdktools\imagehlp\vwndia64.c are
***          identical. For sake of maintenance and for debug purposes,
***          please keep them as this. Thank you.
***
****************************************************************************
**/

#define _CROSS_PLATFORM_
#define _IA64REG_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#include "globals.h"
#include "ia64inst.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include <stdlib.h>

#ifdef _IMAGEHLP_SOURCE_
#include <symbols.h>

#define NOT_IMAGEHLP(E)
#define FUNCTION_ENTRY_IS_IMAGE_STYLE
#define RtlVirtualUnwind VirtualUnwindIa64
#define VUW_DEBUG_PRINT OutputDebugString

#else  // !_IMAGEHLP_SOURCE_

#define NOT_IMAGEHLP(E) E
#define VUW_DEBUG_PRINT DbgPrint

#endif // !_IMAGEHLP_SOURCE_

#ifdef MASK
#undef MASK
#endif // MASK
#define MASK(bp,value)  (value << bp)

//
// ABI values
//

#define SVR4_ABI      0
#define HPUX_ABI      1
#define NT_ABI        2


#ifdef KERNEL_DEBUGGER
#define FUNCTION_ENTRY_IS_IMAGE_STYLE
#define RtlVirtualUnwind VirtualUnwind
#endif

#define STATE_RECORD_STACK_SIZE 32

#define SPILLSIZE_OF_FLOAT128_IN_DWORDS   4
#define SPILLSIZE_OF_ULONGLONG_IN_DWORDS  2

#define REGISTER_SIZE                sizeof(ULONGLONG)
#define STATIC_REGISTER_SET_SIZE     32
#define SLOTS_PER_BUNDLE             3

#define R1_MASK              0xC0
#define R1_PREFIX            0x0
#define R1_REGION_TYPE_MASK  0x20
#define R1_LENGTH_MASK       0x1F

#define R2_MASK              0xE0
#define R2_PREFIX            0x40

#define R3_MASK              0xE0
#define R3_PREFIX            0x60
#define R3_REGION_TYPE_MASK  0x3

#define P1_MASK              0xE0
#define P1_PREFIX            0x80
#define P2_MASK              0xF0
#define P2_PREFIX            0xA0
#define P3_MASK              0xF8
#define P3_PREFIX            0xB0
#define P4_MASK              0xFF
#define P4_PREFIX            0xB8
#define P5_MASK              0xFF
#define P5_PREFIX            0xB9
#define P6_MASK              0xE0
#define P6_PREFIX            0xC0
#define P7_MASK              0xF0
#define P7_PREFIX            0xE0
#define P8_MASK              0xFF
#define P8_PREFIX            0xF0
#define P9_MASK              0xFF
#define P9_PREFIX            0xF1
#define P10_MASK             0xFF
#define P10_PREFIX           0xFF

#define B1_MASK              0xC0
#define B1_PREFIX            0x80
#define B1_TYPE_MASK         0x20
#define B1_LABEL_MASK        0x1F
#define B2_MASK              0xE0
#define B2_PREFIX            0xC0
#define B2_ECOUNT_MASK       0x1F
#define B3_MASK              0xF0
#define B3_PREFIX            0xE0
#define B4_MASK              0xF0
#define B4_PREFIX            0xF0
#define B4_TYPE_MASK         0x08

//
// P3 descriptor type
//

#define PSP_GR               0
#define RP_GR                1
#define PFS_GR               2
#define PREDS_GR             3
#define UNAT_GR              4
#define LC_GR                5
#define RP_BR                6
#define RNAT_GR              7
#define BSP_GR               8
#define BSPSTORE_GR          9
#define FPSR_GR              10
#define PRIUNAT_GR           11

//
// P7 descriptor type
//

#define MEM_STACK_F          0
#define MEM_STACK_V          1
#define SPILL_BASE           2
#define PSP_SPREL            3
#define RP_WHEN              4
#define RP_PSPREL            5
#define PFS_WHEN             6
#define PFS_PSPREL           7
#define PREDS_WHEN           8
#define PREDS_PSPREL         9
#define LC_WHEN              10
#define LC_PSPREL            11
#define UNAT_WHEN            12
#define UNAT_PSPREL          13
#define FPSR_WHEN            14
#define FPSR_PSPREL          15

//
// P8 descriptor type
//

#define PSP_PSPREL           0
#define RP_SPREL             1
#define PFS_SPREL            2
#define PREDS_SPREL          3
#define LC_SPREL             4
#define UNAT_SPREL           5
#define FPSR_SPREL           6
#define BSP_WHEN             7
#define BSP_PSPREL           8
#define BSP_SPREL            9
#define BSPSTORE_WHEN        10
#define BSPSTORE_PSPREL      11
#define BSPSTORE_SPREL       12
#define RNAT_WHEN            13
#define RNAT_PSPREL          14
#define RNAT_SPREL           15
#define PRIUNAT_WHEN         16
#define PRIUNAT_PSPREL       17
#define PRIUNAT_SPREL        18


#define STACK_POINTER_GR     12

#define FIRST_PRESERVED_GR                4
#define LAST_PRESERVED_GR                 7
#define NUMBER_OF_PRESERVED_GR            4

#define FIRST_LOW_PRESERVED_FR            2
#define LAST_LOW_PRESERVED_FR             5
#define NUMBER_OF_LOW_PRESERVED_FR        4

#define FIRST_HIGH_PRESERVED_FR           16
#define LAST_HIGH_PRESERVED_FR            31
#define NUMBER_OF_HIGH_PRESERVED_FR       16
#define NUMBER_OF_PRESERVED_FR            NUMBER_OF_LOW_PRESERVED_FR+NUMBER_OF_HIGH_PRESERVED_FR

#define FIRST_PRESERVED_BR                1
#define LAST_PRESERVED_BR                 5
#define NUMBER_OF_PRESERVED_BR            5

#define NUMBER_OF_PRESERVED_MISC          7

#define NUMBER_OF_PRESERVED_REGISTERS     12


#define REG_MISC_BASE        0
#define REG_PREDS            (REG_MISC_BASE+0)
#define REG_SP               (REG_MISC_BASE+1)
#define REG_PFS              (REG_MISC_BASE+2)
#define REG_RP               (REG_MISC_BASE+3)
#define REG_UNAT             (REG_MISC_BASE+4)
#define REG_LC               (REG_MISC_BASE+5)
#define REG_NATS             (REG_MISC_BASE+6)

#define REG_BR_BASE          (REG_MISC_BASE+NUMBER_OF_PRESERVED_MISC)

#define REG_FPSR             0xff // REG_MISC_BASE+7
#define REG_BSP              0xff // REG_MISC_BASE+8
#define REG_BSPSTORE         0xff // REG_MISC_BASE+9
#define REG_RNAT             0xff // REG_MISC_BASE+10

//
// Where is a preserved register saved?
//
//     1. stack general register
//     2. memory stack (pspoff)
//     3. memory stack (spoff)
//     4. branch register
//

#define GENERAL_REG          0
#define PSP_RELATIVE         1
#define SP_RELATIVE          2
#define BRANCH_REG           3


#define ADD_STATE_RECORD(States, RegionLength, DescBeginIndex)       \
    States.Top++;                                                    \
    States.Top->IsTarget = FALSE;                                    \
    States.Top->MiscMask = 0;                                        \
    States.Top->FrMask = 0;                                          \
    States.Top->GrMask = 0;                                          \
    States.Top->Label = (LABEL)0;                                    \
    States.Top->Ecount = 0;                                          \
    States.Top->RegionLen = RegionLength;                            \
    States.Top->RegionBegin = UnwindContext.SlotCount;               \
    States.Top->SpWhen = 0;                                          \
    States.Top->SpAdjustment = 0;                                    \
    States.Top->SpillBase = (States.Top-1)->SpillPtr;                \
    States.Top->SpillPtr = (States.Top-1)->SpillPtr;                 \
    States.Top->Previous = States.Current;                           \
    States.Top->DescBegin = DescBeginIndex;                          \
    States.Current = States.Top


#define VALID_LABEL_BIT_POSITION    15

#define LABEL_REGION(Region, Label)                                    \
    Region->Label = Label;                                             \
    Region->MiscMask |= (1 << VALID_LABEL_BIT_POSITION)

#define IS_REGION_LABELED(Region)  \
    (Region->MiscMask & (1 << VALID_LABEL_BIT_POSITION))

#define CHECK_LABEL(State, Label) \
    ( (IS_REGION_LABELED(State)) && (Label == State->Label) )


#define EXTRACT_NAT_FROM_UNAT(NatBit)  \
    NatBit = (UCHAR)((IntNats >> (((ULONG_PTR)Source & 0x1F8) >> 3)) & 0x1);


#if DBG
int UnwindDebugLevel = 0;
# ifdef _IMAGEHLP_SOURCE_
#  define UW_DEBUG(x) if (UnwindDebugLevel) dbPrint##x
# else
#  define UW_DEBUG(x) if (UnwindDebugLevel) DbgPrint##x
# endif
#else
# define UW_DEBUG(x)
#endif // DBG

typedef struct _REGISTER_RECORD {
    ULONG Where : 2;                  // 2-bit field
    ULONG SaveOffset : 30;            // 30 bits for offset, big enough?
    ULONG When;                       // slot offset relative to region
} REGISTER_RECORD, *PREGISTER_RECORD;

typedef ULONG LABEL;

typedef struct _STATE_RECORD {
    struct _STATE_RECORD *Previous;   // pointer to outer nested prologue
    BOOLEAN IsTarget;       // TRUE if the control pc is in this prologue
    UCHAR GrMask;           // Mask that specifies which GRs to be restored
    USHORT MiscMask;        // Mask that specifies which BRs and misc. registers
                            // are to be restored.
                            // N.B. MSBit indicates Label is valid or not.
    ULONG FrMask;           // Mask that specifies which FRs to be restored
    ULONG SpAdjustment;     // size of stack frame allocated in the prologue
    ULONG SpWhen;           // slot offset relative to region
    ULONG SpillPtr;         // current spill location
    ULONG SpillBase;        // spill base of the region
    ULONG RegionBegin;      // first slot of region relative to function entry
    ULONG RegionLen;        // number of slots in the region
    LABEL Label;            // label that identifies a post-prologue state
    ULONG Ecount;           // number of prologue regions to pop
    ULONG DescBegin;        // first prologue descriptor for the region
    ULONG DescEnd;          // last prologue descriptor for the region
} STATE_RECORD, *PSTATE_RECORD;

typedef struct _UNWIND_CONTEXT {
    REGISTER_RECORD MiscRegs[NUMBER_OF_PRESERVED_REGISTERS];
    REGISTER_RECORD Float[NUMBER_OF_PRESERVED_FR];
    REGISTER_RECORD Integer[NUMBER_OF_PRESERVED_GR];
    BOOLEAN ActiveRegionFound;
    UCHAR AlternateRp;
    USHORT Version;
    PUCHAR Descriptors;               // beginning of descriptor data
    ULONG Size;                       // total size of all descriptors
    ULONG DescCount;                  // number of descriptor bytes processed
    ULONG TargetSlot;
    ULONG SlotCount;
} UNWIND_CONTEXT, *PUNWIND_CONTEXT;

typedef struct _STATE_RECORD_STACK {
    ULONG Size;
    PSTATE_RECORD Current;
    PSTATE_RECORD Top;
    PSTATE_RECORD Base;
} STATE_RECORD_STACK, *PSTATE_RECORD_STACK;

#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

static const USHORT MiscContextOffset[NUMBER_OF_PRESERVED_REGISTERS] = {
    OFFSET(IA64_CONTEXT, Preds),
    OFFSET(IA64_CONTEXT, IntSp),
    OFFSET(IA64_CONTEXT, RsPFS),
    OFFSET(IA64_CONTEXT, BrRp),
    OFFSET(IA64_CONTEXT, ApUNAT),
    OFFSET(IA64_CONTEXT, ApLC),
    0,
    OFFSET(IA64_CONTEXT, BrS0),
    OFFSET(IA64_CONTEXT, BrS1),
    OFFSET(IA64_CONTEXT, BrS2),
    OFFSET(IA64_CONTEXT, BrS3),
    OFFSET(IA64_CONTEXT, BrS4)
};

static const USHORT MiscContextPointersOffset[NUMBER_OF_PRESERVED_REGISTERS] = {
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, Preds),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, IntSp),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, RsPFS),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrRp),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, ApUNAT),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, ApLC),
    0,
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS0),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS1),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS2),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS3),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS4)
};

static const PSTR RegOffsetNames[NUMBER_OF_PRESERVED_REGISTERS] = {
    "Preds",
    "IntSp",
    "RsPFS",
    "BrRp",
    "ApUNAT",
    "ApLC",
    "<invalid>",
    "BrS0",
    "BrS1",
    "BrS2",
    "BrS3",
    "BrS4",
};

static const UCHAR P3RecordTypeToRegisterIndex[] =
    {REG_SP, REG_RP, REG_PFS, REG_PREDS, REG_UNAT, REG_LC, REG_RP};

static const UCHAR P7RecordTypeToRegisterIndex[] =
    {0, REG_SP, 0, REG_SP, REG_RP, REG_RP, REG_PFS, REG_PFS, REG_PREDS,
     REG_PREDS, REG_LC, REG_LC, REG_UNAT, REG_UNAT, REG_FPSR, REG_FPSR};

static const UCHAR P8RecordTypeToRegisterIndex[] =
    {REG_SP, REG_RP, REG_PFS, REG_PREDS, REG_LC, REG_UNAT, REG_FPSR,
     REG_BSP, REG_BSP, REG_BSP, REG_BSPSTORE, REG_BSPSTORE, REG_BSPSTORE,
     REG_RNAT, REG_RNAT, REG_RNAT, REG_NATS, REG_NATS, REG_NATS};


/*++
            
Description:

    The next code defines mechanism to handle the context of
    the unwind process

--*/


/*++

Routine Description:

    Initializes the FixupTable

Arguments:

    iContext - index of the context in UnwindContext

--*/

void
Vwndia64InitFixupTable(UINT iContext)
{
    if (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        PVWNDIA64_UNWIND_CONTEXT pContext = tlsvar(UnwindContext) + iContext;
        ZeroMemory(pContext->FixupTable, sizeof(pContext->FixupTable));
    }
} // Vwndia64InitFixupTable


/*++

Routine Description:

    Adds new fixup region into the table

Arguments:

    iContext - index of the context in UnwindContext
    Begin, End, Fixup - fixup region data

--*/

void
Vwndia64AddFixupRegion(UINT iContext,
                       ULONGLONG Ip,
                       ULONGLONG Begin, ULONGLONG End, ULONGLONG Fixup)
{
    if (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        PVWNDIA64_UNWIND_CONTEXT pContext = tlsvar(UnwindContext) + iContext;

        PVWNDIA64_FUXUP_REGION FixupReg = pContext->FixupTable;
        PVWNDIA64_FUXUP_REGION FixupRegLast = FixupReg + 
                                              VWNDIA64_FIXUP_TABLE_SIZE;

        //
        // Search for the empty region
        //
        while (
            (FixupReg < FixupRegLast) &&
            (FixupReg->Fixup &&
                ((FixupReg->Ip != Ip) ||
                 (FixupReg->Begin != Begin) ||
                 (FixupReg->End != End) ||
                 (FixupReg->Fixup != Fixup))))
        {
            ++FixupReg;
        } // while

        if (FixupReg >= FixupRegLast) // not found (rare)
        {
            //
            // Scroll the table (destructive)
            //
            MoveMemory(pContext->FixupTable, 
                       pContext->FixupTable + 1,
                       sizeof(pContext->FixupTable) - 
                            sizeof(VWNDIA64_FUXUP_REGION));
            FixupReg = FixupRegLast - 1;
        } // if

        FixupReg->Ip = Ip;
        FixupReg->Begin = Begin;
        FixupReg->End = End;
        FixupReg->Fixup = Fixup;
    } // if
} // Vwndia64AddFixupRegion

/*++

Routine Description:

    Fixes the address using the specified fixup table

Arguments:

    iContext - index of the context in UnwindContext
    Size - size of the buffer in bytes
    Addr - point to the address that have to be fixed

Return Value:

    Addr contains the fixed value

--*/

void
Vwndia64FixAddress(UINT iContext, IN OUT ULONGLONG* Addr)
{
    if (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        PVWNDIA64_UNWIND_CONTEXT pContext = tlsvar(UnwindContext) + iContext;
        PVWNDIA64_FUXUP_REGION FixupReg = NULL;

        //
        // find last containing region
        //
        {
            PVWNDIA64_FUXUP_REGION FixupSearch = pContext->FixupTable;
            PVWNDIA64_FUXUP_REGION FixupRegLast = FixupSearch + 
                                                  VWNDIA64_FIXUP_TABLE_SIZE;

            while ((FixupSearch < FixupRegLast) && FixupSearch->Fixup)
            {
                if ((FixupSearch->Begin <= *Addr) && (*Addr < FixupSearch->End))
                {
                    FixupReg = FixupSearch;
                }
                ++FixupSearch;
            } // while
        }

        if (FixupReg)
        {
            *Addr = FixupReg->Fixup - (FixupReg->End - *Addr);
        } // if
    } // if
} // Vwndia64FixAddress

/*++

Routine Description:

    Checks whether specified Ip exists in fixup table

Arguments:

    iContext - index of the context in UnwindContext
    Ip - to search

Return Value:

    Addr contains the fixed value

--*/

BOOL
Vwndia64IsFixupIp(UINT iContext, ULONGLONG Ip)
{
    if (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        PVWNDIA64_UNWIND_CONTEXT pContext = tlsvar(UnwindContext) + iContext;

        PVWNDIA64_FUXUP_REGION FixupSearch = pContext->FixupTable;
        PVWNDIA64_FUXUP_REGION FixupRegLast = FixupSearch + 
                                              VWNDIA64_FIXUP_TABLE_SIZE;

        while ((FixupSearch < FixupRegLast) &&
               FixupSearch->Ip && (FixupSearch->Ip != Ip))
        {
            ++FixupSearch;
        } // while

        return (FixupSearch->Ip == Ip);
    } // if

    return FALSE;
} // Vwndia64IsFixupIp

/*++

Routine Description:

    Initializes the new context

Return Value:

    returns ID of the record (index in UnwindContext)

--*/

UINT
Vwndia64NewContext()
{
    UINT* iContext = &tlsvar(UnwindContextNew);
    
    if (*iContext >= VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        *iContext = 0;
    }

    Vwndia64InitFixupTable(*iContext);
    tlsvar(UnwindContext[*iContext]).bFailureReported = FALSE;

    return (*iContext)++;
} // Vwndia64NewContext()

/*++

Routine Description:

    Checks if the specified context index valid and
    creates new context if otherwise

--*/

BOOL
Vwndia64ValidateContext(UINT* iContext)
{
    if (!iContext) return FALSE;
    if (*iContext >= VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        *iContext = Vwndia64NewContext();
        return FALSE;
    }
    return TRUE;
} //Vwndia64ValidateContext

/*++

Routine Description:

    Check whether any failure have been reported

Arguments:

    iContext - index of the context in UnwindContext

Return Value:

    Returns true whether any failure have been reported

--*/

BOOL
Vwndia64FailureReported(UINT iContext)
{
    PVWNDIA64_UNWIND_CONTEXT pContext;
    
    pContext = tlsvar(UnwindContext);
    return (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE) ? 
            pContext[iContext].bFailureReported : FALSE;
} // Vwndia64FailureReported

/*++

Routine Description:

    Reports failure and sets appropriate flag is the unwind context

Arguments:

    iContext - index of the context in UnwindContext;
               use (-1) to report unconditionaly

Return Value:

    none

--*/

void
Vwndia64ReportFailure(UINT iContext, LPCSTR szFormat, ...)
{
    if ((g.SymOptions & SYMOPT_DEBUG) != SYMOPT_DEBUG)
    {
        return;
    }

    if (iContext < VWNDIA64_UNWIND_CONTEXT_TABLE_SIZE)
    {
        PVWNDIA64_UNWIND_CONTEXT pContext = tlsvar(UnwindContext) + iContext;
        if (pContext->bFailureReported)
        {
            return;
        }
        pContext->bFailureReported = TRUE;
    } // if

    //
    // Printout failure
    //
    {
        char buf[1024];
        va_list args;

        va_start(args, szFormat);
        strcpy(buf, "DBGHELP: ");
        _vsnprintf(buf + 9, sizeof(buf) - 11, szFormat, args);
        va_end(args);

        SympSendDebugString(NULL, buf);
    } // Printout failure
} // Vwndia64ReportFailure

UCHAR
NewParsePrologueRegionPhase0 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD StateRecord,
    IN OUT PUCHAR AbiImmContext
    );

VOID
NewParsePrologueRegionPhase1 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD StateRecord
    );


VOID
SrInitialize (
    IN PSTATE_RECORD_STACK StateTable,
    IN PSTATE_RECORD StateRecord,
    IN ULONG Size
    )
{
    StateTable->Size = Size;
    StateTable->Base = StateRecord;
    StateTable->Top = StateRecord;
    StateTable->Current = StateRecord;
    RtlZeroMemory(StateTable->Top, sizeof(STATE_RECORD));
}

ULONG
ReadLEB128 (
    IN PUCHAR Descriptors,
    IN OUT PULONG CurrentDescIndex
    )
{
    PUCHAR Buffer;
    ULONG Value;
    ULONG ShiftCount = 7;
    ULONG Count;

    Buffer = Descriptors + *CurrentDescIndex;
    Count = 1;

    Value = Buffer[0] & 0x7F;
    if (Buffer[0] & 0x80) {
        while (TRUE) {
            Value += ((Buffer[Count] & 0x7F) << ShiftCount);
            if (Buffer[Count++] & 0x80) {
                ShiftCount += 7;
            } else {
                break;
            }
        }
    }

    *CurrentDescIndex += Count;

    return Value;
}

ULONGLONG
RestorePreservedRegisterFromGR (
    IN PIA64_CONTEXT Context,
    IN SHORT BsFrameSize,
    IN SHORT RNatSaveIndex,
    IN SHORT GrNumber,
#ifdef _IMAGEHLP_SOURCE_
    IN HANDLE hProcess,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    IN UINT iContext,
    OUT BOOL *Succeed,
#else
    OUT ULONG64 *SourceAddress,
#endif // _IMAGEHLP_SOURCE_
    OUT PUCHAR Nat OPTIONAL
    )
{
    ULONGLONG Result = 0;
    SHORT Offset;
    SHORT Temp;
#ifdef _IMAGEHLP_SOURCE_
    ULONG Size;
#endif // _IMAGEHLP_SOURCE_

#ifdef _IMAGEHLP_SOURCE_
    *Succeed = FALSE;
#endif // _IMAGEHLP_SOURCE_

    if (GrNumber >= STATIC_REGISTER_SET_SIZE) {

        Offset = GrNumber - STATIC_REGISTER_SET_SIZE;
        if ( Offset < BsFrameSize ) {

            Temp = Offset + RNatSaveIndex - IA64_NAT_BITS_PER_RNAT_REG;
            while (Temp >= 0) {
                Offset++;
                Temp -= IA64_NAT_BITS_PER_RNAT_REG;
            }
            Offset = Offset * sizeof(ULONGLONG);

#ifdef _IMAGEHLP_SOURCE_
            {
                ULONGLONG Reg = (ULONGLONG)Context->RsBSP + (ULONGLONG)Offset;
                Vwndia64FixAddress(iContext, &Reg);
                *Succeed = ReadMemory(hProcess, Reg,
                                      &Result, sizeof(ULONGLONG), &Size);
            }
#else
            *SourceAddress = (ULONG64)(Context->RsBSP + Offset);
            Result = *(PULONGLONG)(Context->RsBSP + Offset);
#endif // _IMAGEHLP_SOURCE_

        } else {

            UW_DEBUG(("ERROR: Invalid GR!\n"));
        }

    } else {

        if (GrNumber == 0 || GrNumber == 12) {

            //
            // Invalid GR number -> Invalid Unwind Descriptor
            //

            UW_DEBUG(("ERROR: Invalid GR!\n"));

        } else {

            UW_DEBUG(("WARNING: Target register is not a stacked GR!\n"));
            Offset = GrNumber - 1;
            NOT_IMAGEHLP(*SourceAddress = (ULONG64)(&Context->IntGp + Offset));
            Result = *(&Context->IntGp + Offset);

#ifdef _IMAGEHLP_SOURCE_
            *Succeed = TRUE;
#endif // _IMAGEHLP_SOURCE_

        }
    }

    if (ARGUMENT_PRESENT(Nat)) {

        //
        // TBD: Pick up the corresponding Nat bit
        //

        *Nat = (UCHAR) 0;

    }

    return (Result);
}

UCHAR
ParseBodyRegionDescriptors (
    IN PUNWIND_CONTEXT UnwindContext,
    IN PSTATE_RECORD_STACK StateTable,
    IN ULONG RegionLen
    )
{
    LABEL Label;
    UCHAR FirstByte;
    BOOLEAN EcountDefined;
    BOOLEAN CopyLabel;
    ULONG Ecount;
    ULONG SlotOffset;
    PSTATE_RECORD StateTablePtr;
    PUCHAR Descriptors;

    CopyLabel = EcountDefined = FALSE;
    Descriptors = UnwindContext->Descriptors;

    while (UnwindContext->DescCount < UnwindContext->Size) {

        FirstByte = Descriptors[UnwindContext->DescCount++];

        if ( (FirstByte & B1_MASK) == B1_PREFIX ) {

            Label = (LABEL)(FirstByte & B1_LABEL_MASK);
            if (FirstByte & B1_TYPE_MASK) {

                //
                // copy the entry state
                //

                CopyLabel = TRUE;

            } else {

                //
                // label the entry state
                //

                LABEL_REGION(StateTable->Top, Label);
            }

            UW_DEBUG(("Body region desc B1: copy=%d, label_num=%d\n",
                     FirstByte & B1_TYPE_MASK ? TRUE : FALSE, Label));

        } else if ( (FirstByte & B2_MASK) == B2_PREFIX ) {

            Ecount = FirstByte & B2_ECOUNT_MASK;
            SlotOffset = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            EcountDefined = TRUE;

            UW_DEBUG(("Epilog desc B2: ecount=%d, LEB128(slot)=%d\n",
                      Ecount, SlotOffset));

        } else if ( (FirstByte & B3_MASK) == B3_PREFIX ) {

            SlotOffset = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            Ecount = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            EcountDefined = TRUE;

            UW_DEBUG(("Epilog desc B3: ecount=%d, LEB128 val=%d\n",
                      Ecount, SlotOffset));

        } else if ( (FirstByte & B4_MASK) == B4_PREFIX ) {

            Label = ReadLEB128(Descriptors, &UnwindContext->DescCount);

            if (FirstByte & B4_TYPE_MASK) {

                //
                // copy the entry state
                //

                CopyLabel = TRUE;

            } else {

                //
                // label the current top of stack
                //

                LABEL_REGION(StateTable->Top, Label);
            }

            UW_DEBUG(("Body region desc B4: copy=%d, label_num=%d\n",
                     FirstByte & B4_TYPE_MASK, Label));

        } else {

            //
            // Encounter another region header record
            //

            break;
        }
    }

    if (CopyLabel) {
        StateTablePtr = StateTable->Top;
        while (TRUE) {
            if (CHECK_LABEL(StateTablePtr, Label)) {
                StateTable->Current = StateTablePtr;
                break;
            } else if ((StateTablePtr == StateTable->Base)) {
                UW_DEBUG(("Undefined Label %d\n", Label));
                break;
            }
            StateTablePtr--;
        }
    }

    if (EcountDefined) {

        Ecount++;    // Ecount specifies additional level of prologue
                     // regions to undo (i.e. a value of 0 implies 1
                     // prologue region)

        if (UnwindContext->ActiveRegionFound == FALSE) {
            while (Ecount-- > 0) {
                if (StateTable->Current->Previous) {
                    StateTable->Current = StateTable->Current->Previous;
                }

#if DBG
                else {
                    UW_DEBUG(("WARNING: Ecount is greater than the # of active prologues!\n"));
                }
#endif // DBG

            }
        } else {

            //
            // control PC is in this body/epilog region
            //

            if ((UnwindContext->SlotCount + RegionLen - SlotOffset)
                    <= UnwindContext->TargetSlot)
            {
                PSTATE_RECORD SrPointer;

                StateTable->Current->Ecount = Ecount;
                SrPointer = StateTable->Current;
                while (Ecount > 0) {

                    if (SrPointer->Previous) {
                        SrPointer->Ecount = Ecount;
                        SrPointer->SpWhen = 0;
                        SrPointer->SpAdjustment = 0;
                        SrPointer = SrPointer->Previous;
                    }

#if DBG
                    else {
                        UW_DEBUG(("WARNING: Ecount is greater than the # of active prologues!\n"));
                    }
#endif // DBG
                    Ecount--;

                }
            }
        }
    }

    return FirstByte;
}

ULONGLONG
ProcessInterruptRegion (
#ifdef _IMAGEHLP_SOURCE_
    IN HANDLE hProcess,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    IN UINT iContext,
#else
    IN PIA64_KNONVOLATILE_CONTEXT_POINTERS ContextPointers,
#endif _IMAGEHLP_SOURCE_
    IN PUNWIND_CONTEXT UnwindContext,
    IN PIA64_CONTEXT Context,
    IN SHORT BsFrameSize,
    IN SHORT RNatSaveIndex,
    IN UCHAR AbiImmContext
    )
{
    //
    // no prologue descriptor in interrupt region.
    //

    ULONGLONG NextPc;
    ULONG Index;
    SHORT TempFrameSize;
    BOOLEAN Success;
#ifdef _IMAGEHLP_SOURCE_
    ULONG Size;
#else
    PIA64_CONTEXT PrevContext;
    PVOID *Source;
    PVOID Address;
#endif _IMAGEHLP_SOURCE_


    if (AbiImmContext != IA64_CONTEXT_FRAME) {

        PIA64_KTRAP_FRAME TrapFrame;
        PIA64_KEXCEPTION_FRAME ExFrame;
#ifdef _IMAGEHLP_SOURCE_
        IA64_KTRAP_FRAME TF;
        IA64_KEXCEPTION_FRAME ExF;
#endif // _IMAGEHLP_SOURCE_

        TrapFrame = (PIA64_KTRAP_FRAME) Context->IntSp;
#ifdef _IMAGEHLP_SOURCE_
        if (!ReadMemory(hProcess, Context->IntSp, &TF, sizeof(IA64_KTRAP_FRAME), &Size))
        {
            return 0;
        }
        TrapFrame = &TF;
#endif // _IMAGEHLP_SOURCE_

        Context->ApDCR = TrapFrame->ApDCR;
        Context->ApUNAT = TrapFrame->ApUNAT;
        Context->StFPSR = TrapFrame->StFPSR;
        Context->Preds = TrapFrame->Preds;
        Context->IntSp = TrapFrame->IntSp;
        Context->StIPSR = TrapFrame->StIPSR;
        Context->StIFS = TrapFrame->StIFS;
        Context->BrRp = TrapFrame->BrRp;
        Context->RsPFS = TrapFrame->RsPFS;

#ifndef _IMAGEHLP_SOURCE_
        if (ARGUMENT_PRESENT(ContextPointers)) {
            ContextPointers->ApUNAT = &TrapFrame->ApUNAT;
            ContextPointers->IntSp = &TrapFrame->IntSp;
            ContextPointers->BrRp = &TrapFrame->BrRp;
            ContextPointers->RsPFS = &TrapFrame->RsPFS;
            ContextPointers->Preds = &TrapFrame->Preds;
        }
#endif // _IMAGEHLP_SOURCE_

        switch (AbiImmContext) {

        case IA64_SYSCALL_FRAME:

            //
            // System Call Handler Frame
            //

            BsFrameSize = (SHORT)(TrapFrame->StIFS >> IA64_PFS_SIZE_SHIFT);
            BsFrameSize &= IA64_PFS_SIZE_MASK;
            break;

        case IA64_INTERRUPT_FRAME:
        case IA64_EXCEPTION_FRAME:

            //
            // External Interrupt Frame / Exception Frame
            //

            BsFrameSize = (SHORT)TrapFrame->StIFS & IA64_PFS_SIZE_MASK;
            break;

        default:

            break;
        }

        RNatSaveIndex = (SHORT)(TrapFrame->RsBSP >> 3) & IA64_NAT_BITS_PER_RNAT_REG;
        TempFrameSize = BsFrameSize - RNatSaveIndex;
        while (TempFrameSize > 0) {
            BsFrameSize++;
            TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
        }

        NextPc = Ia64InsertIPSlotNumber(TrapFrame->StIIP,
                     ((TrapFrame->StIPSR >> PSR_RI) & 0x3));

#ifdef _IMAGEHLP_SOURCE_
        Vwndia64AddFixupRegion(iContext,
                               NextPc,
                               TrapFrame->RsBSPSTORE, TrapFrame->RsBSP,
                               Context->RsBSP);
#endif // _IMAGEHLP_SOURCE_

        Context->RsBSP = TrapFrame->RsBSP - BsFrameSize * sizeof(ULONGLONG);
        Context->RsBSPSTORE = Context->RsBSP;
        Context->RsRNAT = TrapFrame->RsRNAT;

        return (NextPc);
    }

    //
    // Kernel-to-User thunk, context of the previous frame can be
    // found on the user stack (i.e. context's address = sp+SCRATCH_AREA)
    //

#ifdef _IMAGEHLP_SOURCE_
    if (!ReadMemory(hProcess,
                    Context->IntSp + IA64_STACK_SCRATCH_AREA,
                    Context,
                    sizeof(IA64_CONTEXT),
                    &Size))
    {
        return 0;
    }
    NextPc = Ia64InsertIPSlotNumber(Context->StIIP,
                                       ((Context->StIPSR >> PSR_RI) & 0x3));
#else

    PrevContext = (PIA64_CONTEXT)(Context->IntSp + IA64_STACK_SCRATCH_AREA);

    RtlCopyMemory(&Context->BrRp, &PrevContext->BrRp,
                  (NUMBER_OF_PRESERVED_BR+1) * sizeof(ULONGLONG));
    RtlCopyMemory(&Context->FltS0, &PrevContext->FltS0,
                  NUMBER_OF_LOW_PRESERVED_FR * sizeof(FLOAT128));
    RtlCopyMemory(&Context->FltS4, &PrevContext->FltS4,
                  NUMBER_OF_HIGH_PRESERVED_FR * sizeof(FLOAT128));
    RtlCopyMemory(&Context->IntS0, &PrevContext->IntS0,
                  NUMBER_OF_PRESERVED_GR * sizeof(ULONGLONG));

    Context->IntSp = PrevContext->IntSp;
    Context->IntNats = PrevContext->IntNats;
    Context->ApUNAT = PrevContext->ApUNAT;
    Context->ApLC = PrevContext->ApLC;
    Context->ApEC = PrevContext->ApEC;
    Context->Preds = PrevContext->Preds;
    Context->RsPFS = PrevContext->RsPFS;
    Context->RsBSP = PrevContext->RsBSP;
    Context->RsBSPSTORE = PrevContext->RsBSPSTORE;
    Context->RsRSC = PrevContext->RsRSC;
    Context->RsRNAT = PrevContext->RsRNAT;
    Context->StIFS = PrevContext->StIFS;
    Context->StIPSR = PrevContext->StIPSR;
    NextPc = Ia64InsertIPSlotNumber(PrevContext->StIIP,
                 ((PrevContext->StIPSR >> PSR_RI) & 0x3));

#endif // _IMAGEHLP_SOURCE_

    return(NextPc);
}


#ifdef _IMAGEHLP_SOURCE_

BOOL
IsValidUnwindInfo64 (
    const IA64_UNWIND_INFO* pUnwindInfo
    )
/*++

Routine Description:

    This function validates the unwind info record

Return Value:

    returns false if record looks like invalid
--*/

{
    if (!pUnwindInfo) return FALSE;

    switch (pUnwindInfo->Version) {
    case 1:
    case 2:
    case 3: 
        if (
            !pUnwindInfo->DataLength ||
            (pUnwindInfo->DataLength > ((1024 / sizeof(ULONG64)) * 64)))
        {
            return FALSE;
        }
        break;
    default:
        return FALSE;
    } // switch

    return TRUE;
} // IsValidUnwindInfo64

BOOL 
GetUnwindInfo(
    IN HANDLE hProcess,
    IN ULONGLONG ImageBase,
    IN ULONG UnwindInfoAddress,

    IN OUT PIA64_UNWIND_INFO UnwindInfo,
    IN OUT PUCHAR* Descriptors,
    IN OUT PULONG DescriptorsSize,

    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
    )
{
    ULONG BytesRead = 0;

    //
    // try to get UnwindInfo from the image
    //
    ULONG64 UnwindInfoPtr = ImageBase + UnwindInfoAddress;

    if (ReadMemory(hProcess, UnwindInfoPtr, 
                   UnwindInfo, sizeof(*UnwindInfo), &BytesRead) &&
        (BytesRead == sizeof(*UnwindInfo)) &&
        IsValidUnwindInfo64(UnwindInfo))
    {
        if (!Descriptors)
        {
            return TRUE;
        }

        if (!UnwindInfo->DataLength) 
        {
            *Descriptors = NULL;
            *DescriptorsSize = 0;
            return TRUE;
        }

        ULONG Size = UnwindInfo->DataLength * sizeof(ULONGLONG);
        *Descriptors = (PUCHAR)MemAlloc(Size);

        if (*Descriptors &&
            ReadMemory(hProcess, 
                       UnwindInfoPtr + sizeof(*UnwindInfo), 
                       *Descriptors, Size, &BytesRead) &&
            BytesRead == Size) 
        {
            if (DescriptorsSize) 
            {
                *DescriptorsSize = Size;
            }
            return TRUE;
        }
        MemFree(*Descriptors);
    }

    //
    // try to get UnwindInfo from the symbols
    //
    ULONG_PTR XDataSize;
    PBYTE pXData = 
        (PBYTE)GetUnwindInfoFromSymbols(hProcess, 
                                        ImageBase, 
                                        UnwindInfoAddress, 
                                        &XDataSize);

    if (pXData && (XDataSize >= sizeof(*UnwindInfo))) 
    {
        memcpy(UnwindInfo, pXData, sizeof(*UnwindInfo));

        if (IsValidUnwindInfo64(UnwindInfo)) 
        {
            if (!Descriptors)
            {
                return TRUE;
            }

            if (!UnwindInfo->DataLength)
            {
                *Descriptors = NULL;
                *DescriptorsSize = 0;
                return TRUE;
            }

            ULONG Size = UnwindInfo->DataLength * sizeof(ULONG64);

            if (Size <= (XDataSize - sizeof(*UnwindInfo)))
            {
                *Descriptors = (PUCHAR)MemAlloc(Size);
                if (*Descriptors)
                {
                    memcpy(*Descriptors, 
                           pXData + sizeof(*UnwindInfo), 
                           Size);

                    if (DescriptorsSize) 
                    {
                        *DescriptorsSize = Size;
                    }

                    return TRUE;
                }
                MemFree(*Descriptors);
            }
        }
    }

    return FALSE;
}
#endif // defined(_IMAGEHLP_SOURCE_)

ULONGLONG
RtlVirtualUnwind (
#ifdef _IMAGEHLP_SOURCE_
    IN  HANDLE hProcess,
    IN  ULONGLONG ImageBase,
    IN  ULONGLONG ControlPc,
    IN  PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    OUT PIA64_CONTEXT ContextRecord,
    IN  PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    IN  UINT iContext
#define ContextPointers ((PIA64_KNONVOLATILE_CONTEXT_POINTERS)0)
#else
    IN ULONGLONG ImageBase,
    IN ULONGLONG ControlPc,
    IN PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    IN OUT PIA64_CONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PFRAME_POINTERS EstablisherFrame,
    IN OUT PIA64_KNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
#endif
    )

/*++

Routine Description:

    This function virtually unwinds the specfified function by executing its
    prologue code backwards.

    If the function is a leaf function, then the address where control left
    the previous frame is obtained from the context record. If the function
    is a nested function, but not an exception or interrupt frame, then the
    prologue code is executed backwards and the address where control left
    the previous frame is obtained from the updated context record.

    Otherwise, an exception or interrupt entry to the system is being unwound
    and an especially coded prologue restores the return address twice. Once
    from the fault instruction address and once from the saved return address
    register. The first restore is returned as the function value and the
    second restore is placed in the updated context record.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

Arguments:

    ImageBase - Supplies the base address of the module to which the
        function belongs.

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    InFunction - Supplies a pointer to a variable that receives whether the
        control PC is within the current function.

    EstablisherFrame - Supplies a pointer to a variable that receives the
        the establisher frame pointer value.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

    The address where control left the previous frame is returned as the
    function value.

--*/

{
#ifdef _IMAGEHLP_SOURCE_
    BOOL Succeed;
#endif // _IMAGEHLP_SOURCE_
    PUCHAR Descriptors = NULL;
    UCHAR AbiImmContext = 0xFF;
    ULONG Mask;
    ULONGLONG NextPc;
    ULONG RegionLen;
    UCHAR FirstByte;
    UCHAR Nat;
    SHORT BsFrameSize;                  // in 8-byte units
    SHORT LocalFrameSize;                  // in 8-byte units
    SHORT TempFrameSize;                // in 8-byte units
    SHORT RNatSaveIndex;
    ULONG i;
    PULONG Buffer;
    BOOLEAN IsPrologueRegion;
    BOOLEAN PspRestored;
    ULONGLONG PreviousIntSp;
    PVOID Destination;
    ULONG64 Source;
    ULONG64 *CtxPtr;
    ULONG64 *NatCtxPtr;
    ULONG64 IntNatsSource;
    ULONG64 IntNats;
    ULONG Size;
    ULONG DescrSize;
    ULONGLONG OldTopRnat;
    ULONGLONG NewTopRnat;
    UNWIND_CONTEXT UnwindContext;
    PSTATE_RECORD SrPointer;
    STATE_RECORD_STACK StateTable;
    STATE_RECORD StateRecords[STATE_RECORD_STACK_SIZE];

    BsFrameSize = (SHORT)ContextRecord->StIFS & IA64_PFS_SIZE_MASK;
    RNatSaveIndex = (SHORT)(ContextRecord->RsBSP >> 3) & IA64_NAT_BITS_PER_RNAT_REG;
    TempFrameSize = RNatSaveIndex + BsFrameSize - IA64_NAT_BITS_PER_RNAT_REG;
    while (TempFrameSize >= 0) {
        BsFrameSize++;
        TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
    }

#ifdef _IMAGEHLP_SOURCE_
    {
        IA64_UNWIND_INFO UnwindInfo;
        if (!GetUnwindInfo(hProcess, ImageBase, FunctionEntry->UnwindInfoAddress, 
                          &UnwindInfo, &Descriptors, &Size, 
                          ReadMemory))
        {
            Vwndia64ReportFailure(-1, 
                                  "Can't read Unwind Info - "
                                      "StackWalk can not continue\n");
            return 0;
        }

        UnwindContext.Version = UnwindInfo.Version;
    }
#else
    {
        ULONG64 UnwindInfoPtr = ImageBase + FunctionEntry->UnwindInfoAddress;
        UnwindContext.Version = ((PIA64_UNWIND_INFO)UnwindInfoPtr)->Version;
        Size = ((PIA64_UNWIND_INFO)UnwindInfoPtr)->DataLength * sizeof(ULONGLONG);
        Descriptors = (PUCHAR)UnwindInfoPtr + sizeof(IA64_UNWIND_INFO);
    }
#endif // _IMAGEHLP_SOURCE_

    UnwindContext.Size = Size;
    UnwindContext.ActiveRegionFound = FALSE;
    UnwindContext.AlternateRp = 0;
    UnwindContext.DescCount = 0;
    UnwindContext.SlotCount = 0;
    UnwindContext.TargetSlot = (ULONG)(((ControlPc - FunctionEntry->BeginAddress - ImageBase) >> 4) * SLOTS_PER_BUNDLE + ((ControlPc >> 2) & 0x3));
    UnwindContext.Descriptors = Descriptors;

    SrInitialize(&StateTable, StateRecords, STATE_RECORD_STACK_SIZE);

    if (Size) {
        FirstByte = Descriptors[UnwindContext.DescCount++];
    }


    while ( (UnwindContext.DescCount < UnwindContext.Size) &&
            (!UnwindContext.ActiveRegionFound) )
    {

        //
        // Assume a prologue region but not an interrupt region.
        //

        IsPrologueRegion = TRUE;

        //
        // Based on the type of region header, dispatch
        // to the corresponding routine that processes
        // the succeeding descriptors until the next
        // region header record.
        //

        if ((FirstByte & R1_MASK) == R1_PREFIX) {

            //
            // region header record in short format
            //

            RegionLen = FirstByte & R1_LENGTH_MASK;

            if (FirstByte & R1_REGION_TYPE_MASK) {
                IsPrologueRegion = FALSE;
            } else {
                ADD_STATE_RECORD(StateTable, RegionLen, UnwindContext.DescCount);
            }

            UW_DEBUG(("Region R1 format: body=%x, length=%d\n",
                     IsPrologueRegion ? 0 : 1, RegionLen));

        } else if ((FirstByte & R2_MASK) == R2_PREFIX) {

            //
            // general prologue region header
            // N.B. Skip the 2nd byte of the header and proceed to read
            //      the region length; the header descriptors will be
            //      processed again in phase 1.
            //

            ULONG R2DescIndex;

            R2DescIndex = UnwindContext.DescCount - 1;
            UnwindContext.DescCount++;
            RegionLen = ReadLEB128(Descriptors, &UnwindContext.DescCount);
            ADD_STATE_RECORD(StateTable, RegionLen, R2DescIndex);
            UW_DEBUG(("Region R2: body=0, length=%d\n", RegionLen));

        } else if ((FirstByte & R3_MASK) == R3_PREFIX) {

            //
            // region header record in long format
            //

            RegionLen = ReadLEB128(Descriptors, &UnwindContext.DescCount);

            switch (FirstByte & R3_REGION_TYPE_MASK) {

            case 0:      // prologue region header

                ADD_STATE_RECORD(StateTable, RegionLen, UnwindContext.DescCount);
                break;

            case 1:      // body region header

                IsPrologueRegion = FALSE;
                break;

            }

            UW_DEBUG(("Region R3: body=%x, length=%d\n",
                      IsPrologueRegion ? 0 : 1, RegionLen));

        } else {

            //
            // Not a region header record -> Invalid unwind descriptor.
            //

            UW_DEBUG(("Invalid unwind descriptor!\n"));

        }

        if (UnwindContext.TargetSlot < (UnwindContext.SlotCount + RegionLen)) {
            UnwindContext.ActiveRegionFound = TRUE;
            StateTable.Current->IsTarget = IsPrologueRegion;
        }

        if (IsPrologueRegion) {
            FirstByte = NewParsePrologueRegionPhase0(&UnwindContext,
                                                     StateTable.Current,
                                                     &AbiImmContext);
        } else {
            FirstByte = ParseBodyRegionDescriptors(&UnwindContext,
                                                   &StateTable,
                                                   RegionLen);
        }

        UnwindContext.SlotCount += RegionLen;
    }

    //
    // Restore the value of psp and save the current NatCr.
    // N.B. If the value is restored from stack/bstore, turn off the
    //      corresponding sp bit in the saved mask associated with the
    //      prologue region in which psp is saved.
    //

    if (ARGUMENT_PRESENT(ContextPointers)) {
        IntNatsSource = (ULONG64)ContextPointers->ApUNAT;
    }
    IntNats = ContextRecord->ApUNAT;
    PreviousIntSp = ContextRecord->IntSp;
    PspRestored = FALSE;

    SrPointer = StateTable.Current;
    while (SrPointer != StateTable.Base) {
        NewParsePrologueRegionPhase1(&UnwindContext, SrPointer);

        if (SrPointer->MiscMask & (1 << REG_SP)) {
            if (UnwindContext.MiscRegs[REG_SP].Where == GENERAL_REG) {
                PreviousIntSp = RestorePreservedRegisterFromGR (
                                    ContextRecord,
                                    BsFrameSize,
                                    RNatSaveIndex,
                                    (SHORT)UnwindContext.MiscRegs[REG_SP].SaveOffset,
#ifdef _IMAGEHLP_SOURCE_
                                    hProcess,
                                    ReadMemory,
                                    iContext,
                                    &Succeed,
#else
                                    &Source,
#endif // _IMAGEHLP_SOURCE_
                                    &Nat
                                    );
#ifdef _IMAGEHLP_SOURCE_
                if (!Succeed) {
                    return 0;
                }

                UW_DEBUG(("Restored IntSp to %I64x\n", PreviousIntSp));
                
#endif // _IMAGEHLP_SOURCE_

            } else {

                Source = ContextRecord->IntSp + UnwindContext.MiscRegs[REG_SP].SaveOffset*4;
#ifdef _IMAGEHLP_SOURCE_
                if (!ReadMemory(hProcess, (ULONG64)(Source), &PreviousIntSp, sizeof(ULONGLONG), &Size)) {
                    return 0;
                }
#else
                PreviousIntSp = *(PULONGLONG)Source;
#endif // _IMAGEHLP_SOURCE_
                EXTRACT_NAT_FROM_UNAT(Nat);

            }
            ContextRecord->IntNats &= ~(0x1 << STACK_POINTER_GR);
            ContextRecord->IntNats |= (Nat << STACK_POINTER_GR);
            SrPointer->MiscMask &= ~(1 << REG_SP);
            if (ARGUMENT_PRESENT(ContextPointers)) {
                CtxPtr = (ULONG64 *)((ULONG_PTR)ContextPointers +
                                   MiscContextPointersOffset[REG_SP]);
                *CtxPtr = Source;
            }
            PspRestored = TRUE;
        }
        if (PspRestored == FALSE) {
            PreviousIntSp += SrPointer->SpAdjustment * 4;
        }
        SrPointer = SrPointer->Previous;
    }

    if (AbiImmContext != 0xFF) {

        ContextRecord->IntSp = PreviousIntSp;  // trap/context frame address
        NextPc = ProcessInterruptRegion(
#ifdef _IMAGEHLP_SOURCE_
                     hProcess,
                     ReadMemory,
                     iContext,
#else
                     ContextPointers,
#endif _IMAGEHLP_SOURCE_
                     &UnwindContext,
                     ContextRecord,
                     BsFrameSize,
                     RNatSaveIndex,
                     AbiImmContext);

        goto FastExit;
    }

    //
    // Restore the contents of any preserved registers saved in this frame.
    //

    SrPointer = StateTable.Current;
    while (SrPointer != StateTable.Base) {

        Mask = SrPointer->MiscMask;
        UW_DEBUG(("MiscMask = 0x%x\n", Mask));

        for (i = 0; i < NUMBER_OF_PRESERVED_REGISTERS; i++) {
            Destination = (PVOID)((ULONG_PTR)ContextRecord + MiscContextOffset[i]);
            if (Mask & 0x1) {

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    CtxPtr = (ULONG64 *)((ULONG_PTR)ContextPointers +
                                       MiscContextPointersOffset[i]);
                    Source = *CtxPtr;
                }

                if (UnwindContext.MiscRegs[i].Where == GENERAL_REG) {

                    *(PULONGLONG)Destination =
                        RestorePreservedRegisterFromGR (
                            ContextRecord,
                            BsFrameSize,
                            RNatSaveIndex,
                            (SHORT)UnwindContext.MiscRegs[i].SaveOffset,
#ifdef _IMAGEHLP_SOURCE_
                            hProcess,
                            ReadMemory,
                            iContext,
                            &Succeed,
#else
                            &Source,
#endif // _IMAGEHLP_SOURCE_
                            NULL
                            );
#ifdef _IMAGEHLP_SOURCE_
                    if (!Succeed) {
                        *(PULONGLONG)Destination = 0;
                    } else {
                        UW_DEBUG(("Restored %s to %I64x\n",
                                  RegOffsetNames[i],
                                  *(PULONGLONG)Destination));
                    }

#endif // _IMAGEHLP_SOURCE_

                } else if (UnwindContext.MiscRegs[i].Where == BRANCH_REG) {

                    //
                    // restore return pointer from branch register
                    //

                    USHORT Offset;

                    Offset = (USHORT)UnwindContext.MiscRegs[i].SaveOffset-FIRST_PRESERVED_BR;
                    Source = (ULONG64)(&ContextRecord->BrS0 + Offset);
#ifdef _IMAGEHLP_SOURCE_
                    Vwndia64FixAddress(iContext, &Source);

                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        *(PULONGLONG)Destination = 0;
                    }
#else
                    *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_

                } else if (UnwindContext.MiscRegs[i].Where == PSP_RELATIVE) {

                    if ((SrPointer->Ecount == 0) || (UnwindContext.MiscRegs[i].SaveOffset <= (IA64_STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                        Source = PreviousIntSp + IA64_STACK_SCRATCH_AREA
                                     - UnwindContext.MiscRegs[i].SaveOffset*4;

                        if (i == REG_NATS) {
                            Destination = (PVOID)&IntNats;
                            IntNatsSource = Source;
                        }

#ifdef _IMAGEHLP_SOURCE_
                        if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                            *(PULONGLONG)Destination = 0;
                        }
#else
                        *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_
                    }

                } else if (UnwindContext.MiscRegs[i].Where == SP_RELATIVE) {

                    //
                    // Make the necessary adjustment depending on whether
                    // the preserved register is saved before or after the
                    // stack pointer has been adjusted in this prologue.
                    //

                    if ((UnwindContext.MiscRegs[i].When >= SrPointer->SpWhen) && SrPointer->RegionLen) 
                    {
                        Source = ContextRecord->IntSp 
                            + UnwindContext.MiscRegs[i].SaveOffset*4;
                    }
                    else {
                        Source = ContextRecord->IntSp + SrPointer->SpAdjustment*4 
                            + UnwindContext.MiscRegs[i].SaveOffset*4;
                    }

                    if (i == REG_NATS) {
                        Destination = (PVOID)&IntNats;
                        IntNatsSource = Source;
                    }

#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        *(PULONGLONG)Destination = 0;
                    }
#else
                    *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_
                }

                if (ARGUMENT_PRESENT(ContextPointers) && (i != REG_NATS)) {
                    *CtxPtr = Source;
                }

            } else if (Mask == 0) {

                //
                // No more registers to restore
                //

                break;
            }

            Mask = Mask >> 1;
        }

        //
        // Restore preserved FRs (f2 - f5, f16 - f31)
        //

        Mask = SrPointer->FrMask;
        Destination = (PVOID)&ContextRecord->FltS0;
        CtxPtr = (ULONG64 *)&ContextPointers->FltS0;

        UW_DEBUG(("FrMask = 0x%x\n", Mask));
        for (i = 0; i < NUMBER_OF_PRESERVED_FR; i++) {
            if (Mask & 0x1) {

                if ((SrPointer->Ecount == 0) || (UnwindContext.Float[i].SaveOffset <= (IA64_STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                    Source = PreviousIntSp + IA64_STACK_SCRATCH_AREA
                                 - UnwindContext.Float[i].SaveOffset*4;
#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(FLOAT128), &Size)) {
                        *(PULONGLONG)Destination = 0;
                    }
#else
                    *(FLOAT128 *)Destination = *(FLOAT128 *)Source;
#endif // _IMAGEHLP_SOURCE_

                    if (ARGUMENT_PRESENT(ContextPointers)) {
                        *CtxPtr = Source;
                    }
                }

            } else if (Mask == 0) {
                break;
            }

            Mask = Mask >> 1;

            if (i == (NUMBER_OF_LOW_PRESERVED_FR - 1)) {
                Destination = (PVOID)&ContextRecord->FltS4;
                CtxPtr = (ULONG64 *)(&ContextPointers->FltS4);
            } else {
                Destination = (PVOID)((FLOAT128 *)Destination+1);
                CtxPtr++;
            }
        }

        //
        // Restore preserved GRs (r4 - r7)
        //

        Mask = SrPointer->GrMask;
        Destination = (PVOID)&ContextRecord->IntS0;
        CtxPtr = (ULONG64 *)&ContextPointers->IntS0;
        NatCtxPtr = (ULONG64 *)&ContextPointers->IntS0Nat;

        UW_DEBUG(("GrMask = 0x%x\n", Mask));
        for (i = 0; i < NUMBER_OF_PRESERVED_GR; i++)
        {
            if (Mask & 0x1) {

                if ((SrPointer->Ecount == 0) || (UnwindContext.Integer[i].SaveOffset <= (IA64_STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                    Source = PreviousIntSp + IA64_STACK_SCRATCH_AREA
                                 - UnwindContext.Integer[i].SaveOffset*4;

#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        *(PULONGLONG)Destination = 0;
                    }
#else
                    *(PULONGLONG)Destination = *(PULONGLONG)Source;
#endif // _IMAGEHLP_SOURCE_
                    EXTRACT_NAT_FROM_UNAT(Nat);
                    Nat = (UCHAR)((IntNats >> (((ULONG_PTR)Source & 0x1F8) >> 3)) & 0x1);
                    ContextRecord->IntNats &= ~(0x1 << (i+FIRST_PRESERVED_GR));
                    ContextRecord->IntNats |= (Nat << (i+FIRST_PRESERVED_GR));

#ifndef _IMAGEHLP_SOURCE_
                    if (ARGUMENT_PRESENT(ContextPointers)) {
                        *CtxPtr = Source;
                        *NatCtxPtr = IntNatsSource;
                    }
#endif
                }

            } else if (Mask == 0) {
                break;
            }

            Mask = Mask >> 1;
            Destination = (PVOID)((PULONGLONG)Destination+1);
            CtxPtr++;
            NatCtxPtr++;
        }

        ContextRecord->IntSp += SrPointer->SpAdjustment * 4;
        SrPointer = SrPointer->Previous;
    }

    ContextRecord->IntSp = PreviousIntSp;

    //
    // Restore the value of the epilogue count from the PFS
    //

    ContextRecord->ApEC = (ContextRecord->RsPFS >> IA64_PFS_EC_SHIFT) &
                               ~(((ULONGLONG)1 << IA64_PFS_EC_SIZE) - 1);
    if (ARGUMENT_PRESENT(ContextPointers)) {
        ContextPointers->ApEC = ContextPointers->RsPFS;
    }


FastExit:

    NOT_IMAGEHLP(*InFunction = TRUE);
    NOT_IMAGEHLP(EstablisherFrame->MemoryStackFp = ContextRecord->IntSp);
    NOT_IMAGEHLP(EstablisherFrame->BackingStoreFp = ContextRecord->RsBSP);

#ifdef _IMAGEHLP_SOURCE_
    if (Descriptors)
        MemFree(Descriptors);
#endif // _IMAGEHLP_SOURCE_

    if (AbiImmContext == 0xFF) {

        NextPc = *(&ContextRecord->BrRp + UnwindContext.AlternateRp);
#ifndef _IMAGEHLP_SOURCE_
        NextPc = RtlIa64InsertIPSlotNumber((NextPc-0x10), 2);
#endif // _IMAGEHLP_SOURCE_

        //
        // determine the local frame size of previous frame and compute
        // the new bsp.
        //

        OldTopRnat = (ContextRecord->RsBSP+(BsFrameSize-1)*8) | IA64_RNAT_ALIGNMENT;

        ContextRecord->StIFS = MASK(IA64_IFS_V, (ULONGLONG)1) | ContextRecord->RsPFS;
        BsFrameSize = (SHORT)ContextRecord->StIFS & IA64_PFS_SIZE_MASK;
        LocalFrameSize = (SHORT)(ContextRecord->StIFS >> IA64_PFS_SIZE_SHIFT) & IA64_PFS_SIZE_MASK;
        TempFrameSize = LocalFrameSize - RNatSaveIndex;
        while (TempFrameSize > 0) {
            LocalFrameSize++;
            BsFrameSize++;
            TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
        }
        ContextRecord->RsBSP -= LocalFrameSize * 8;
        ContextRecord->RsBSPSTORE = ContextRecord->RsBSP;

        //
        // determine if the RNAT field needs to be updated.
        //

        NewTopRnat = (ContextRecord->RsBSP+(BsFrameSize-1)*8) | IA64_RNAT_ALIGNMENT;

        if (NewTopRnat < OldTopRnat) {

#ifdef _IMAGEHLP_SOURCE_
            Destination = &ContextRecord->RsRNAT;
            Source = NewTopRnat;
            if (!ReadMemory(hProcess, (ULONG64)Source, Destination, 8, &Size)) {
                *(PULONGLONG)Destination = 0;
            }
#else
            ContextRecord->RsRNAT = *(PULONGLONG)(NewTopRnat);
#endif // _IMAGEHLP_SOURCE_

        }
    }

#ifdef _IMAGEHLP_SOURCE_
    UW_DEBUG(("NextPc = 0x%lx, PSP = 0x%lx, BSP = 0x%lx\n",
               (ULONGLONG)NextPc,
               (ULONGLONG)ContextRecord->IntSp,
               (ULONGLONG)ContextRecord->RsBSP));
#else
    UW_DEBUG(("NextPc = 0x%lx, PSP = 0x%lx, BSP = 0x%lx\n",
               (ULONGLONG)NextPc,
               EstablisherFrame->MemoryStackFp,
               EstablisherFrame->BackingStoreFp));
#endif // _IMAGEHLP_SOURCE_
    return (NextPc);
}

UCHAR
NewParsePrologueRegionPhase0 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD State,
    IN OUT PUCHAR AbiImmContext
    )
{
    PUCHAR Desc = UwContext->Descriptors;
    ULONG Offset;
    ULONG FrameSize;
    ULONG Index;
    UCHAR RecType;
    UCHAR FirstByte;
    UCHAR SecondByte;
    ULONG GrSave;
    ULONG TempMask;
    ULONG i;

    while (UwContext->DescCount < UwContext->Size) {

        FirstByte = Desc[UwContext->DescCount++];

        if ( (FirstByte & P1_MASK) == P1_PREFIX) {

            continue;

        } else if ( (FirstByte & P2_MASK) == P2_PREFIX ) {

            UwContext->DescCount++;

        } else if ( (FirstByte & P3_MASK) == P3_PREFIX ) {

            UwContext->DescCount++;

        } else if ( (FirstByte & P4_MASK) == P4_PREFIX ) {

            UwContext->DescCount += ((State->RegionLen+3) >> 2);

        } else if ( (FirstByte & P5_MASK) == P5_PREFIX ) {

            UwContext->DescCount += 3;

        } else if ( (FirstByte & P6_MASK) == P6_PREFIX ) {

            continue;

        } else if ( (FirstByte & P7_MASK) == P7_PREFIX ) {

            RecType = FirstByte & ~P7_MASK;

            switch (RecType) {

            case MEM_STACK_F:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                FrameSize = ReadLEB128(Desc, &UwContext->DescCount);

                if ((UwContext->TargetSlot > (UwContext->SlotCount+Offset)) || !State->RegionLen)
                {
                    State->SpAdjustment += FrameSize*4;
                    State->SpWhen = Offset;
                }
                break;

            case SPILL_BASE:

                State->SpillBase = ReadLEB128(Desc, &UwContext->DescCount);
                State->SpillPtr = State->SpillBase;
                break;

            case MEM_STACK_V:
            case RP_WHEN:
            case PFS_WHEN:
            case PREDS_WHEN:
            case LC_WHEN:
            case UNAT_WHEN:
            case FPSR_WHEN:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                if ((State->IsTarget) &&
                    (UwContext->TargetSlot > (UwContext->SlotCount+Offset)))
                {
                    Index = P7RecordTypeToRegisterIndex[RecType];
                    if (!(State->MiscMask & (1 << Index))) {
                        State->MiscMask |= MASK(Index,1);
                        UwContext->MiscRegs[Index].When = Offset;
                    } else {
                        UW_DEBUG(("Duplicate descriptors,"));
                        UW_DEBUG(("unwinder may produce incorrect result!\n"));
                    }
                }
                UW_DEBUG(("Prolog P7: type=%d slot= %d\n", RecType, Offset));
                break;

            case PSP_SPREL:
            case RP_PSPREL:
            case PFS_PSPREL:
            case PREDS_PSPREL:
            case LC_PSPREL:
            case UNAT_PSPREL:
            case FPSR_PSPREL:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                break;

            default:

                UW_DEBUG(("Invalid record type for descriptor P7!\n"));

            }

        } else if ( (FirstByte & P8_MASK) == P8_PREFIX ) {

            RecType = Desc[UwContext->DescCount++];

            switch (RecType) {

            case PSP_PSPREL:
            case RP_SPREL:
            case PFS_SPREL:
            case PREDS_SPREL:
            case LC_SPREL:
            case UNAT_SPREL:
            case FPSR_SPREL:
            case BSP_PSPREL:
            case BSP_SPREL:
            case BSPSTORE_PSPREL:
            case BSPSTORE_SPREL:
            case RNAT_PSPREL:
            case RNAT_SPREL:
            case PRIUNAT_PSPREL:
            case PRIUNAT_SPREL:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                UW_DEBUG(("Prolog P8: type=%d slot= %d\n", RecType, Offset));
                break;

            case BSP_WHEN:
            case BSPSTORE_WHEN:
            case RNAT_WHEN:
            case PRIUNAT_WHEN:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                if ((State->IsTarget) &&
                    (UwContext->TargetSlot > (UwContext->SlotCount+Offset)))
                {
                    Index = P7RecordTypeToRegisterIndex[RecType];
                    if (!(State->MiscMask & (1 << Index))) {
                        State->MiscMask |= MASK(Index,1);
                        UwContext->MiscRegs[Index].When = Offset;
                    } else {
                        UW_DEBUG(("Duplicate descriptors,"));
                        UW_DEBUG(("unwinder may produce incorrect result!\n"));
                    }
                }
                UW_DEBUG(("Prolog P8: type=%d slot= %d\n", RecType, Offset));
                break;

            default:

                UW_DEBUG(("Invalid record type for descriptor P8!\n"));

            }

        } else if ( (FirstByte & P9_MASK) == P9_PREFIX ) {

            UwContext->DescCount += 2;
            VUW_DEBUG_PRINT("Format P9 not supported yet!\n");

        } else if ( (FirstByte & P10_MASK) == P10_PREFIX ) {

            UCHAR Abi = Desc[UwContext->DescCount++];
            UCHAR Context = Desc[UwContext->DescCount++];

            *AbiImmContext = Context;

            if (Abi != NT_ABI) {
                VUW_DEBUG_PRINT("Unknown ABI unwind descriptor\n");
            }

        } else {

            //
            // Encounter another region header record
            //

            break;
        }
    }

    State->DescEnd = UwContext->DescCount - 2;

    return FirstByte;
}

VOID
NewParsePrologueRegionPhase1 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD State
    )
{
    ULONG FrameSize;
    ULONG Offset;
    ULONG GrSave;
    ULONG BrBase;
    ULONG Index;
    ULONG Count;
    UCHAR RecType;
    UCHAR FirstByte, SecondByte;   // 1st & 2nd bytes of a region header record
    ULONG DescIndex;
    ULONG ImaskBegin;
    UCHAR NextBr, NextGr, NextFr;
    USHORT MiscMask;
    ULONG TempMask;
    ULONG FrMask = 0;
    UCHAR BrMask = 0;
    UCHAR GrMask = 0;
    PUCHAR Desc = UwContext->Descriptors;
    BOOLEAN SpillMaskOmitted = TRUE;

    DescIndex = State->DescBegin;

    FirstByte = Desc[DescIndex];

    if ((FirstByte & R2_MASK) == R2_PREFIX) {

        //
        // general prologue region header; need to process it first
        //

        ULONG GrSave, Count;
        UCHAR MiscMask;
        UCHAR SecondByte;
        USHORT i;

        DescIndex++;
        SecondByte = Desc[DescIndex++];
        MiscMask = ((FirstByte & 0x7) << 1) | ((SecondByte & 0x80) >> 7);
        GrSave = SecondByte & 0x7F;
        ReadLEB128(Desc, &DescIndex);    // advance the descriptor index

        if (GrSave < STATIC_REGISTER_SET_SIZE) {
            UW_DEBUG(("Invalid unwind descriptor!\n"));
        }

        UW_DEBUG(("Region R2: rmask=%x,grsave=%d,length=%d\n",
                  MiscMask, GrSave, State->RegionLen));

        Count = 0;
        for (Index = REG_PREDS; Index <= REG_RP; Index++) {
            if (MiscMask & 0x1) {
                if (!(State->IsTarget) ||
                    (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = GENERAL_REG;
                    UwContext->MiscRegs[Index].SaveOffset = GrSave+Count;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                Count++;
            }
            MiscMask = MiscMask >> 1;
        }
    }

    while (DescIndex <= State->DescEnd) {

        FirstByte = Desc[DescIndex++];

        if ( (FirstByte & P1_MASK) == P1_PREFIX) {

            BrMask = FirstByte & ~P1_MASK;
            State->MiscMask |= (BrMask << REG_BR_BASE);

            UW_DEBUG(("Prolog P1: brmask=%x\n", BrMask));

            for (Count = REG_BR_BASE;
                 Count < REG_BR_BASE+NUMBER_OF_PRESERVED_BR;
                 Count++)
            {
                if (BrMask & 0x1) {
                    UwContext->MiscRegs[Count].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Count].When = State->RegionLen;
                }
                BrMask = BrMask >> 1;
            }

        } else if ( (FirstByte & P2_MASK) == P2_PREFIX ) {

            SecondByte = Desc[DescIndex++];
            GrSave = SecondByte & 0x7F;
            BrMask = ((FirstByte & ~P2_MASK) << 1) | ((SecondByte & 0x80) >> 7);
            UW_DEBUG(("Prolog P2: brmask=%x reg base=%d\n", BrMask, GrSave));

            State->MiscMask |= (BrMask << REG_BR_BASE);

            for (Count = REG_BR_BASE;
                 Count < REG_BR_BASE+NUMBER_OF_PRESERVED_BR;
                 Count++)
            {
                if (BrMask & 0x1) {
                    UwContext->MiscRegs[Count].Where = GENERAL_REG;
                    UwContext->MiscRegs[Count].SaveOffset = GrSave++;
                }
                BrMask = BrMask >> 1;
            }

        } else if ( (FirstByte & P3_MASK) == P3_PREFIX ) {

            SecondByte = Desc[DescIndex++];
            RecType = ((SecondByte & 0x80) >> 7) | ((FirstByte & 0x7) << 1);
            Index = P3RecordTypeToRegisterIndex[RecType];

            if (RecType == RP_BR) 
            {
                UwContext->AlternateRp = SecondByte & 0x7F;
            } 
            else if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
            {
                UwContext->MiscRegs[Index].Where = GENERAL_REG;
                UwContext->MiscRegs[Index].SaveOffset = SecondByte & 0x7F;
                UwContext->MiscRegs[Index].When = 0;
                State->MiscMask |= MASK(Index,1);

                UW_DEBUG(("Prolog P3: type=%d reg=%d\n",
                          RecType, UwContext->MiscRegs[Index].SaveOffset));
            }

        } else if ( (FirstByte & P4_MASK) == P4_PREFIX ) {

            SpillMaskOmitted = FALSE;
            ImaskBegin = DescIndex;
            DescIndex += ((State->RegionLen+3) >> 2);

        } else if ( (FirstByte & P5_MASK) == P5_PREFIX ) {

            GrMask = (Desc[DescIndex] & 0xF0) >> 4;
            FrMask = ((ULONG)(Desc[DescIndex] & 0xF) << 16) |
                         ((ULONG)Desc[DescIndex+1] << 8) |
                         ((ULONG)Desc[DescIndex+2]);

            DescIndex += 3;    // increment the descriptor index

            State->GrMask |= GrMask;
            State->FrMask |= FrMask;

            UW_DEBUG(("Prolog P5: grmask = %x, frmask = %x\n",
                      State->GrMask, State->FrMask));

        } else if ( (FirstByte & P6_MASK) == P6_PREFIX ) {

            if (FirstByte & 0x10) {

                GrMask = FirstByte & 0xF;
                State->GrMask |= GrMask;

            } else {

                FrMask = FirstByte & 0xF;
                State->FrMask |= FrMask;

            }

            UW_DEBUG(("Prolog P6: is_gr = %d, mask = %x\n",
                      (FirstByte & 0x10) ? 1 : 0,
                      (FirstByte & 0x10) ? State->GrMask : State->FrMask));

        } else if ( (FirstByte & P7_MASK) == P7_PREFIX ) {

            RecType = FirstByte & ~P7_MASK;

            switch (RecType) {

            case PSP_SPREL:

                //
                // sp-relative location
                //

                Index = P7RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = SP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    if (!(State->MiscMask & MASK(Index,1))) {
                        UwContext->MiscRegs[Index].When = State->RegionLen;
                        State->MiscMask |= MASK(Index,1);
                    }
                }
                UW_DEBUG(("Prolog P7: type=%d spoff = %d\n", RecType, Offset));
                break;


            case RP_PSPREL:
            case PFS_PSPREL:
            case PREDS_PSPREL:
            case LC_PSPREL:
            case UNAT_PSPREL:
            case FPSR_PSPREL:

                //
                // psp-relative location
                //

                Index = P7RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                UW_DEBUG(("Prolog P7: type=%d pspoff= %d\n", RecType, Offset));
                break;

            case MEM_STACK_V:
            case RP_WHEN:
            case PFS_WHEN:
            case PREDS_WHEN:
            case LC_WHEN:
            case UNAT_WHEN:
            case FPSR_WHEN:

                //
                // Nevermind processing these descriptors because they
                // have been taken care of in phase 0
                //

                Offset = ReadLEB128(Desc, &DescIndex);
                break;

            case MEM_STACK_F:

                Offset = ReadLEB128(Desc, &DescIndex);
                FrameSize = ReadLEB128(Desc, &DescIndex);

                UW_DEBUG(("Prolog P7: type=%d Slot=%d FrameSize=%d\n",
                          RecType, Offset, FrameSize));
                break;

            case SPILL_BASE:

                State->SpillBase = ReadLEB128(Desc, &DescIndex);
                State->SpillPtr = State->SpillBase;
                UW_DEBUG(("Prolog P7: type=%d, spillbase=%d\n",
                          RecType, State->SpillBase));
                break;

            default:

                UW_DEBUG(("invalid unwind descriptors\n"));

            }

        } else if ( (FirstByte & P8_MASK) == P8_PREFIX ) {

            RecType = Desc[DescIndex++];

            switch (RecType) {

            case PSP_PSPREL:
                 VUW_DEBUG_PRINT("Unsupported Unwind Descriptor!\n");
                 break;

            case RP_SPREL:
            case PFS_SPREL:
            case PREDS_SPREL:
            case LC_SPREL:
            case UNAT_SPREL:
            case FPSR_SPREL:
            case BSP_SPREL:
            case BSPSTORE_SPREL:
            case RNAT_SPREL:
            case PRIUNAT_SPREL:

                //
                // sp-relative location
                //

                Index = P8RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = SP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    if (!(State->MiscMask & MASK(Index,1))) {
                        UwContext->MiscRegs[Index].When=State->RegionLen;
                        State->MiscMask |= MASK(Index,1);
                    }
                }
                UW_DEBUG(("Prolog P8: type=%d spoff= %d\n", RecType, Offset));
                break;

            case BSP_PSPREL:
            case BSPSTORE_PSPREL:
            case RNAT_PSPREL:
            case PRIUNAT_PSPREL:

                //
                // psp-relative location
                //

                Index = P8RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                UW_DEBUG(("Prolog P8: type=%d pspoff= %d\n", RecType, Offset));
                break;

            case BSP_WHEN:
            case BSPSTORE_WHEN:
            case RNAT_WHEN:
            case PRIUNAT_WHEN:

                //
                // Nevermind processing these descriptors because they
                // have been taken care of in phase 0
                //

                Offset = ReadLEB128(Desc, &DescIndex);
                break;

            default:

                UW_DEBUG(("Invalid record type for descriptor P8!\n"));

            }

        } else if ( (FirstByte & P9_MASK) == P9_PREFIX ) {

            DescIndex += 2;
            VUW_DEBUG_PRINT("Format P9 not supported yet!\n");

        } else if ( (FirstByte & P10_MASK) == P10_PREFIX ) {

            UCHAR Abi = Desc[DescIndex++];
            UCHAR Context = Desc[DescIndex++];

        } else {

            UW_DEBUG(("Invalid descriptor!\n"));

        }
    }

    GrMask = State->GrMask;
    FrMask = State->FrMask;
    BrMask = State->MiscMask >> REG_BR_BASE;

    if (!(GrMask | FrMask | BrMask)) {

        return;

    } else if (SpillMaskOmitted && !(State->IsTarget)) {

        //
        // When spillmask is omitted, floating point registers, general
        // registers, and then branch regisers are spilled in order.
        // They are not modified in the prologue region; therefore, there
        // is no need to restore their contents when the control ip is
        // in this prologue region.
        //

        // 1. floating point registers

        State->SpillPtr &= ~(SPILLSIZE_OF_FLOAT128_IN_DWORDS - 1);
        NextFr = NUMBER_OF_PRESERVED_FR - 1;
        while (FrMask & 0xFFFFF) {
            if (FrMask & 0x80000) {
                State->SpillPtr += SPILLSIZE_OF_FLOAT128_IN_DWORDS;
                UwContext->Float[NextFr].SaveOffset = State->SpillPtr;
            }
            FrMask = FrMask << 1;
            NextFr--;
        }

        // 2. branch registers

        NextBr = REG_BR_BASE + NUMBER_OF_PRESERVED_BR - 1;
        while (BrMask & 0x1F) {
            if (BrMask & 0x10) {
                if (UwContext->MiscRegs[Index].Where == PSP_RELATIVE) {
                    State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                    UwContext->MiscRegs[NextBr].SaveOffset = State->SpillPtr;
                }
            }
            BrMask = BrMask << 1;
            NextBr--;
        }

        // 3. general registers

        NextGr = NUMBER_OF_PRESERVED_GR - 1;
        while (GrMask & 0xF) {
            if (GrMask & 0x8) {
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                UwContext->Integer[NextGr].SaveOffset = State->SpillPtr;
            }
            GrMask = GrMask << 1;
            NextGr--;
        }

    } else if (SpillMaskOmitted && State->IsTarget) {

        State->GrMask = 0;
        State->FrMask = 0;
        State->MiscMask &= MASK(REG_BR_BASE, 1) - 1;

    } else if (SpillMaskOmitted == FALSE) {

        ULONG Length;

        if (State->IsTarget) {

            //
            // control ip is in the prologue region; clear the masks
            // and then process the imask to determine which preserved
            // Gr/Fr/Br have been saved and set the corresponding bits.
            //

            State->GrMask = 0;
            State->FrMask = 0;
            State->MiscMask &= MASK(REG_BR_BASE, 1) - 1;
            Length = UwContext->TargetSlot - State->RegionBegin;
        } else {
            Length = State->RegionLen;
        }

        NextGr = NUMBER_OF_PRESERVED_GR - 1;
        NextBr = NUMBER_OF_PRESERVED_BR - 1;
        NextFr = NUMBER_OF_PRESERVED_FR - 1;
        for (Count = 0; Count < Length; Count++) {

            if ((Count % 4) == 0) {
                FirstByte = Desc[ImaskBegin++];
            } else {
                FirstByte = FirstByte << 2;
            }

            switch (FirstByte & 0xC0) {

            case 0x40:                  // 0x01 - save next fr

                while ( !(FrMask & 0x80000) && (NextFr > 0) ) {
                    NextFr--;
                    FrMask = FrMask << 1;
                }

                UW_DEBUG(("spilled register FS%lx\n", (ULONG)NextFr));

                State->FrMask |= MASK(NextFr,1);
                UwContext->Float[NextFr].When = Count;
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                State->SpillPtr &= ~(SPILLSIZE_OF_FLOAT128_IN_DWORDS - 1);
                State->SpillPtr += SPILLSIZE_OF_FLOAT128_IN_DWORDS;
                UwContext->Float[NextFr].SaveOffset = State->SpillPtr;

                NextFr--;
                FrMask = FrMask << 1;
                break;

            case 0x80:                  // 0x10 - save next gr

                while ( !(GrMask & 0x8) && (NextGr > 0) ) {
                    NextGr--;
                    GrMask = GrMask << 1;
                }

                UW_DEBUG(("spilled register S%lx\n", (ULONG)NextGr));

                State->GrMask |= MASK(NextGr,1);
                UwContext->Integer[NextGr].When = Count;
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                UwContext->Integer[NextGr].SaveOffset = State->SpillPtr;

                NextGr--;
                GrMask = GrMask << 1;
                break;

            case 0xC0:                  // 0x11 - save next br

                while ( !(BrMask & 0x10) && (NextBr > 0) ) {
                    NextBr--;
                    BrMask = BrMask << 1;
                }

                UW_DEBUG(("spilled register BS%lx\n", (ULONG)NextBr));

                Index = REG_BR_BASE + NextBr;
                State->MiscMask |= MASK(Index,1);
                UwContext->MiscRegs[Index].When = Count;
                if (UwContext->MiscRegs[Index].Where == PSP_RELATIVE) {
                    State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                    UwContext->MiscRegs[Index].SaveOffset = State->SpillPtr;
                }

                NextBr--;
                BrMask = BrMask << 1;
                break;

            default:                    // 0x00 - save no register
                break;

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\userdump.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    userdump.c

Abstract:

    This module implements full user-mode dump writing.

--*/

#include "private.h"

// hack to make it build
typedef ULONG UNICODE_STRING32;
typedef ULONG UNICODE_STRING64;

#include <ntiodump.h>

DWORD_PTR
DmppGetFilePointer(
    HANDLE hFile
    )
{
#ifdef _WIN64
    LONG dwHigh = 0;

    return SetFilePointer(hFile, 0, &dwHigh, FILE_CURRENT) |
        ((DWORD_PTR)dwHigh << 32);
#else
    return SetFilePointer(hFile, 0, NULL, FILE_CURRENT);
#endif
}

WCHAR *
DmppGetHotFixString(
    )
{
    WCHAR *pszBigBuffer = NULL;
    HKEY hkey = 0;

    //
    // Get the hot fixes. Concat hotfixes into a list that looks like:
    //  "Qxxxx, Qxxxx, Qxxxx, Qxxxx"
    //        
    RegOpenKeyExW(HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix", 0, KEY_READ, &hkey);

    if (hkey) {
        DWORD dwMaxKeyNameLen = 0;
        DWORD dwNumSubKeys = 0;
        WCHAR *pszNameBuffer = NULL;
        
        if (ERROR_SUCCESS != RegQueryInfoKeyW(hkey,     // handle of key to query
                                            NULL,               // address of buffer for class string
                                            NULL,               // address of size of class string buffer
                                            0,                  // reserved
                                            &dwNumSubKeys,      // address of buffer for number of subkeys
                                            &dwMaxKeyNameLen,   // address of buffer for longest subkey name length
                                            NULL,               // address of buffer for longest class string length
                                            NULL,               // address of buffer for number of value entries
                                            NULL,               // address of buffer for longest value name length
                                            NULL,               // address of buffer for longest value data length
                                            NULL,               // address of buffer for security descriptor length
                                            NULL)) {            // address of buffer for last write time);


        
            pszNameBuffer = (WCHAR *) calloc(dwMaxKeyNameLen, sizeof(WCHAR));
            pszBigBuffer = (WCHAR *) calloc(dwMaxKeyNameLen * dwNumSubKeys 
                // Factor in the space required for each ", " between the hotfixes
                + (dwNumSubKeys -1) * 2, sizeof(WCHAR));
        
            if (!pszNameBuffer || !pszBigBuffer) {
                if (pszBigBuffer) {
                    free(pszBigBuffer);
                    pszBigBuffer = NULL;
                }
            } else {
                DWORD dw;
                // So far so good, get each entry
                for (dw=0; dw<dwNumSubKeys; dw++) {
                    DWORD dwSize = dwMaxKeyNameLen;
                    
                    if (ERROR_SUCCESS == RegEnumKeyExW(hkey, 
                                                      dw, 
                                                      pszNameBuffer, 
                                                      &dwSize, 
                                                      0, 
                                                      NULL, 
                                                      NULL, 
                                                      NULL)) {

                        // concat the list
                        wcscat(pszBigBuffer, pszNameBuffer);
                        if (dw < dwNumSubKeys-1) {
                            wcscat(pszBigBuffer, L", ");
                        }
                    }
                }
            }
        }
        
        if (pszNameBuffer) {
            free(pszNameBuffer);
        }

        RegCloseKey(hkey);
    }

    return pszBigBuffer;
}

BOOL
DbgHelpCreateUserDump(
    LPSTR                              CrashDumpName,
    PDBGHELP_CREATE_USER_DUMP_CALLBACK DmpCallback,
    PVOID                              lpv
    )
{
    UINT uSizeDumpFile;
    UINT uSizeUnicode;
    PWSTR pwszUnicode = NULL;
    BOOL b;

    if (CrashDumpName)
    {
        uSizeDumpFile = strlen(CrashDumpName);
        uSizeUnicode = (uSizeDumpFile + 1) * sizeof(wchar_t);
        pwszUnicode = (PWSTR)calloc(uSizeUnicode, 1);
        if (!pwszUnicode) {
            return FALSE;
        }
        *pwszUnicode = UNICODE_NULL;
        if (*CrashDumpName) {

            if (!MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
                                     CrashDumpName, uSizeDumpFile,
                                     pwszUnicode, uSizeUnicode))
            {
                // Error. Free the string, return NULL.
                free(pwszUnicode);
                return FALSE;
            }
        }
    }

    b = DbgHelpCreateUserDumpW(pwszUnicode, DmpCallback, lpv);

    if (pwszUnicode)
    {
        free(pwszUnicode);
    }
    return b;
}

BOOL
DbgHelpCreateUserDumpW(
    LPWSTR                             CrashDumpName,
    PDBGHELP_CREATE_USER_DUMP_CALLBACK DmpCallback,
    PVOID                              lpv
    )

/*++

Routine Description:

    Create a usermode dump file.

Arguments:

    CrashDumpName - Supplies a name for the dump file.

    DmpCallback - Supplies a pointer to a callback function pointer which
        will provide debugger service such as ReadMemory and GetContext.

    lpv - Supplies private data which is sent to the callback functions.

Return Value:

    TRUE - Success.

    FALSE - Error.

--*/

{
    OSVERSIONINFO               OsVersion = {0};
    USERMODE_CRASHDUMP_HEADER   DumpHeader = {0};
    DWORD                       cb;
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    BOOL                        rval;
    PVOID                       DumpData;
    DWORD                       DumpDataLength;
    SECURITY_ATTRIBUTES         SecAttrib;
    SECURITY_DESCRIPTOR         SecDescript;


    if (CrashDumpName == NULL)
    {
        DmpCallback( DMP_DUMP_FILE_HANDLE, &hFile, &DumpDataLength, lpv );
    }
    else
    {
        //
        // Create a DACL that allows all access to the directory
        //
        SecAttrib.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecAttrib.lpSecurityDescriptor = &SecDescript;
        SecAttrib.bInheritHandle = FALSE;

        InitializeSecurityDescriptor(&SecDescript, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&SecDescript, TRUE, NULL, FALSE);


        hFile = CreateFileW(
            CrashDumpName,
            GENERIC_READ | GENERIC_WRITE,
            0,
            &SecAttrib,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    }

    if ((hFile == NULL) || (hFile == INVALID_HANDLE_VALUE))
    {
        return FALSE;
    }

    // Write out an empty header
    if (!WriteFile( hFile, &DumpHeader, sizeof(DumpHeader), &cb, NULL )) {
        goto bad_file;
    }

    //
    // write the debug event
    //
    DumpHeader.DebugEventOffset = DmppGetFilePointer( hFile );
    DmpCallback( DMP_DEBUG_EVENT, &DumpData, &DumpDataLength, lpv );
    if (!WriteFile( hFile, DumpData, sizeof(DEBUG_EVENT), &cb, NULL )) {
        goto bad_file;
    }

    //
    // write the memory map
    //
    DumpHeader.MemoryRegionOffset = DmppGetFilePointer( hFile );
    do {
        __try {
            rval = DmpCallback(
                DMP_MEMORY_BASIC_INFORMATION,
                &DumpData,
                &DumpDataLength,
                lpv
                );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }
        if (rval) {
            DumpHeader.MemoryRegionCount += 1;
            if (!WriteFile( hFile, DumpData, sizeof(MEMORY_BASIC_INFORMATION), &cb, NULL )) {
                goto bad_file;
            }
        }
    } while( rval );

    //
    // write the thread contexts
    //
    DumpHeader.ThreadOffset = DmppGetFilePointer( hFile );
    do {
        __try {
            rval = DmpCallback(
                DMP_THREAD_CONTEXT,
                &DumpData,
                &DumpDataLength,
                lpv
                );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }
        if (rval) {
            if (!WriteFile( hFile, DumpData, DumpDataLength, &cb, NULL )) {
                goto bad_file;
            }
            DumpHeader.ThreadCount += 1;
        }
    } while( rval );

    //
    // write the thread states
    //
    DumpHeader.ThreadStateOffset = DmppGetFilePointer( hFile );
    do {
        __try {
            rval = DmpCallback(
                DMP_THREAD_STATE,
                &DumpData,
                &DumpDataLength,
                lpv
                );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }
        if (rval) {
            if (!WriteFile( hFile, DumpData, sizeof(CRASH_THREAD), &cb, NULL )) {
                goto bad_file;
            }
        }
    } while( rval );

    //
    // write the module table
    //
    DumpHeader.ModuleOffset = DmppGetFilePointer( hFile );
    do {
        __try {
            rval = DmpCallback(
                DMP_MODULE,
                &DumpData,
                &DumpDataLength,
                lpv
                );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }
        if (rval) {
            if (!WriteFile(
                hFile,
                DumpData,
                sizeof(CRASH_MODULE) +
                ((PCRASH_MODULE)DumpData)->ImageNameLength,
                &cb,
                NULL
                )) {
                goto bad_file;
            }
            DumpHeader.ModuleCount += 1;
        }
    } while( rval );

    //
    // write the virtual memory
    //
    DumpHeader.DataOffset = DmppGetFilePointer( hFile );
    do {
        __try {
            rval = DmpCallback(
                DMP_MEMORY_DATA,
                &DumpData,
                &DumpDataLength,
                lpv
                );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            rval = FALSE;
        }
        if (rval) {
            if (!WriteFile(
                hFile,
                DumpData,
                DumpDataLength,
                &cb,
                NULL
                )) {
                goto bad_file;
            }
        }
    } while( rval );

    //
    // VersionInfoOffset will be an offset into the dump file that will contain 
    // misc information about drwatson. The format of the information 
    // will be a series of NULL terminated strings with two zero 
    // terminating the multistring. The string will be UNICODE.
    //
    // FORMAT:
    //  This data refers to the specific data about Dr. Watson
    //      DRW: OS version: XX.XX
    //          OS version of headers
    //      DRW: build: XXXX
    //          Build number of Dr. Watson binary
    //      DRW: QFE: X
    //          QFE number of the Dr. Watson binary
    //  Refers to info describing the OS on which the app crashed,
    //  including Service pack, hotfixes, etc...
    //      CRASH: OS SP: X
    //          Service Pack number of the OS where the app AV'd (we 
    //          already store the build number, but not the SP)
    //
    DumpHeader.VersionInfoOffset = DmppGetFilePointer( hFile );

    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx( &OsVersion );

    {
        WCHAR szBuf[1024] = {0};
        WCHAR * psz = szBuf;
        WCHAR * pszHotfixes;

        wcscat(psz, L"DRW: OS version");
        psz += wcslen(psz) +1;
        // Let the printf function convert it from ANSI to unicode
        swprintf(psz, L"%S", VER_PRODUCTVERSION_STRING);
        psz += wcslen(psz) +1;
        
        wcscat(psz, L"DRW: build");
        psz += wcslen(psz) +1;
        swprintf(psz, L"%d", (int) VER_PRODUCTBUILD);
        psz += wcslen(psz) +1;

        wcscat(psz, L"DRW: QFE");
        psz += wcslen(psz) +1;
        swprintf(psz, L"%d", (int) VER_PRODUCTBUILD_QFE);
        psz += wcslen(psz) +1;

        wcscat(psz, L"CRASH: OS SP");
        psz += wcslen(psz) +1;
        if (OsVersion.szCSDVersion[0]) {
            // Let the printf function convert it from ANSI to unicode
            swprintf(psz, L"%S", OsVersion.szCSDVersion);
        } else {
            wcscat(psz, L"none");
        }
        psz += wcslen(psz) +1;

        wcscat(psz, L"CRASH: Hotfixes");
        psz += wcslen(psz) +1;
        pszHotfixes = DmppGetHotFixString ();
        if (pszHotfixes) {
            wcscat(psz, pszHotfixes);
            free(pszHotfixes);
        } else {
            wcscat(psz, L"none");
        }
        psz += wcslen(psz) +1;

        // Include last terminating zero
        psz++;

        // Calc length of data.  This should always fit in a ULONG.
        DumpDataLength = (ULONG)((PBYTE) psz - (PBYTE) szBuf);
        if (!WriteFile(
            hFile,
            szBuf,
            DumpDataLength,
            &cb,
            NULL
            )) {
            goto bad_file;
        }
    
    }

    //
    // re-write the dump header with some valid data
    //
    
    DumpHeader.Signature = USERMODE_CRASHDUMP_SIGNATURE;
    DumpHeader.MajorVersion = OsVersion.dwMajorVersion;
    DumpHeader.MinorVersion =
        (OsVersion.dwMinorVersion & 0xffff) |
        (OsVersion.dwBuildNumber << 16);
#if defined(_M_IX86)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_I386;
    DumpHeader.ValidDump = USERMODE_CRASHDUMP_VALID_DUMP32;
#elif defined(_M_IA64)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_IA64;
    DumpHeader.ValidDump = USERMODE_CRASHDUMP_VALID_DUMP64;
#elif defined(_M_AXP64)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_AXP64;
    DumpHeader.ValidDump = USERMODE_CRASHDUMP_VALID_DUMP64;
#elif defined(_M_ALPHA)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_ALPHA;
    DumpHeader.ValidDump = USERMODE_CRASHDUMP_VALID_DUMP32;
#elif defined(_M_AMD64)
    DumpHeader.MachineImageType = IMAGE_FILE_MACHINE_AMD64;
    DumpHeader.ValidDump = USERMODE_CRASHDUMP_VALID_DUMP64;
#else
#error( "unknown target machine" );
#endif

    SetFilePointer( hFile, 0, 0, FILE_BEGIN );
    if (!WriteFile( hFile, &DumpHeader, sizeof(DumpHeader), &cb, NULL )) {
        goto bad_file;
    }

    //
    // close the file
    //
    if (CrashDumpName)
    {
        CloseHandle( hFile );
    }
    return TRUE;

bad_file:

    if (CrashDumpName)
    {
        CloseHandle( hFile );
    }

    DeleteFileW( CrashDumpName );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\walkalp.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    walkalpha.c

Abstract:

    This file implements the ALPHA stack walking api.

Author:

    Wesley Witt (wesw) 1-Oct-1993

Environment:

    User Mode

--*/

#define _IMAGEHLP_SOURCE_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "symbols.h"
#include "alphaops.h"
#include <stdlib.h>
#include <stddef.h>
#include <globals.h>
#include "fecache.hpp"

#ifdef __cplusplus
extern "C"
#endif

BOOL
WalkAlphaInit(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    );

BOOL
WalkAlphaNext(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    );

BOOL
WalkAlphaGetStackFrame(
    HANDLE                            hProcess,
    PULONG64                          ReturnAddress,
    PULONG64                          FramePointer,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    PKDHELP64                         KdHelp,
    BOOL                              Use64
    );

VOID
GetUnwindFunctionEntry(
    HANDLE                                hProcess,
    ULONG64                               ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64        ReadMemory,
    PGET_MODULE_BASE_ROUTINE64            GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64      GetFunctionEntry,
    BOOL                                  Use64,
    FeCacheEntry*                         FunctionEntry,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY UnwindFunctionEntry,
    PULONG                                StackAdjust,
    PULONG64                              FixedReturn
    );

#define ZERO 0x0                /* integer register 0 */
#define SP 0x1d                 /* integer register 29 */
#define RA 0x1f                 /* integer register 31 */
#define SAVED_FLOATING_MASK 0xfff00000 /* saved floating registers */
#define SAVED_INTEGER_MASK 0xf3ffff02 /* saved integer registers */
#define IS_FLOATING_SAVED(Register) ((SAVED_FLOATING_MASK >> Register) & 1L)
#define IS_INTEGER_SAVED(Register) ((SAVED_INTEGER_MASK >> Register) & 1L)

#define IS_HANDLER_DEFINED(FunctionEntry) \
    (RF_EXCEPTION_HANDLER(FunctionEntry) != 0)

BOOL
WalkAlpha(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    )
{
    BOOL rval;
    PALPHA_NT5_CONTEXT Context = (PALPHA_NT5_CONTEXT)ContextRecord;

    if (StackFrame->Virtual) {

        rval = WalkAlphaNext( hProcess,
                              StackFrame,
                              Context,
                              ReadMemory,
                              GetModuleBase,
                              GetFunctionEntry,
                              Use64
                            );

    } else {

        rval = WalkAlphaInit( hProcess,
                              StackFrame,
                              Context,
                              ReadMemory,
                              GetModuleBase,
                              GetFunctionEntry,
                              Use64
                            );

    }

    return rval;
}


ULONG64
VirtualUnwind (
    HANDLE                                  hProcess,
    ULONG64                                 ControlPc,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY   FunctionEntry,
    ULONG                                   StackAdjust,
    ULONG64                                 FixedReturn,
    PALPHA_NT5_CONTEXT                      Context,
    PREAD_PROCESS_MEMORY_ROUTINE64          ReadMemory
//    PKNONVOLATILE_CONTEXT_POINTERS          ContextPointers OPTIONAL
    )

/*++

Routine Description:

    This function virtually unwinds the specified function by executing its
    prologue code backwards. Given the current context and the instructions
    that preserve registers in the prologue, it is possible to recreate the
    nonvolatile context at the point the function was called.

    If the function is a leaf function, then the address where control left
    the previous frame is obtained from the context record. If the function
    is a nested function, but not an exception or interrupt frame, then the
    prologue code is executed backwards and the address where control left
    the previous frame is obtained from the updated context record.

    Otherwise, an exception or interrupt entry to the system is being unwound
    and a specially coded prologue restores the return address twice. Once
    from the fault instruction address and once from the saved return address
    register. The first restore is returned as the function value and the
    second restore is placed in the updated context record.

    During the unwind, the virtual and real frame pointers for the function
    are calculated and returned in the given frame pointers structure.

    If a context pointers record is specified, then the address where each
    register is restored from is recorded in the appropriate element of the
    context pointers record.

Arguments:

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

    The address where control left the previous frame is returned as the
    function value.

Implementation Notes:

    N.B. "where control left" is not the "return address" of the call in the
    previous frame. For normal frames, NextPc points to the last instruction
    that completed in the previous frame (the JSR/BSR). The difference between
    NextPc and NextPc + 4 (return address) is important for correct behavior
    in boundary cases of exception addresses and scope tables.

    For exception and interrupt frames, NextPc is obtained from the trap frame
    contination address (Fir). For faults and synchronous traps, NextPc is both
    the last instruction to execute in the previous frame and the next
    instruction to execute if the function were to return. For asynchronous
    traps, NextPc is the continuation address. It is the responsibility of the
    compiler to insert TRAPB instructions to insure asynchronous traps do not
    occur outside the scope from the instruction(s) that caused them.

    N.B. in this and other files where RtlVirtualUnwind is used, the variable
    named NextPc is perhaps more accurately, LastPc - the last PC value in
    the previous frame, or CallPc - the address of the call instruction, or
    ControlPc - the address where control left the previous frame. Instead
    think of NextPc as the next PC to use in another call to virtual unwind.

    The Alpha version of virtual unwind is similar in design, but slightly
    more complex than the Mips version. This is because Alpha compilers
    are given more flexibility to optimize generated code and instruction
    sequences, including within procedure prologues. And also because of
    compiler design issues, the function must manage both virtual and real
    frame pointers.

Version Information:  This version was taken from exdspatch.c@v37 (Feb 1993)

--*/

{
    ALPHA_INSTRUCTION FollowingInstruction;
    ALPHA_INSTRUCTION Instruction;
    ULONGLONG         Address;
    ULONG             DecrementOffset;
    ULONG             DecrementRegister;
    PULONGLONG        FloatingRegister;
    ULONG             FrameSize;
    ULONG             Function;
    PULONGLONG        IntegerRegister;
    ULONG             Literal8;
    ULONGLONG         NextPc;
    LONG              Offset16;
    ULONG             Opcode;
    ULONG             Ra;
    ULONG             Rb;
    ULONG             Rc;
    BOOLEAN           RestoredRa;
    BOOLEAN           RestoredSp;
    DWORD             cb;
    PVOID             Prolog;


    //
    // perf hack: fill cache with prolog
    // skip it if this is a secondary function entry
    //

    if (FunctionEntry &&
        (ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) > ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) &&
        (ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) < ALPHA_RF_END_ADDRESS(FunctionEntry)) ) {

        cb = (ULONG)(ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) - ALPHA_RF_BEGIN_ADDRESS(FunctionEntry));

        //
        // If the function is a leaf it doesn't have a prolog, skip this
        // optimization.
        //

        if (cb != 0) {
            Prolog = (PVOID) MemAlloc( cb );
            if (!ReadMemory( hProcess,
                             ALPHA_RF_BEGIN_ADDRESS(FunctionEntry),
                             Prolog,
                             cb,
                             &cb )) {
                return 0;
            }
            MemFree(Prolog);
        }
    }

    //
    // Set the base address of the integer and floating register arrays within
    // the context record. Each set of 32 registers is known to be contiguous.
    //

    // assuming that quad values are together in context.

    IntegerRegister      = &Context->IntV0;
    FloatingRegister     = &Context->FltF0;

    //
    // Handle the epilogue case where the next instruction is a return.
    //
    // Exception handlers cannot be called if the ControlPc is within the
    // epilogue because exception handlers expect to operate with a current
    // stack frame. The value of SP is not current within the epilogue.
    //

    if (!ReadMemory(hProcess, ControlPc, &Instruction.Long, 4, &cb))  {
        return(0);
    }

    if (IS_RETURN_0001_INSTRUCTION(Instruction.Long)) {
        Rb = Instruction.Jump.Rb;
        NextPc = IntegerRegister[Rb] - 4;

        //
        // The instruction at the point where control left the specified
        // function is a return, so any saved registers have already been
        // restored, and the stack pointer has already been adjusted. The
        // stack does not need to be unwound in this case and the saved
        // return address register is returned as the function value.
        //
        // In fact, reverse execution of the prologue is not possible in
        // this case: the stack pointer has already been incremented and
        // so, for this frame, neither a valid stack pointer nor frame
        // pointer exists from which to begin reverse execution of the
        // prologue. In addition, the integrity of any data on the stack
        // below the stack pointer is never guaranteed (due to interrupts
        // and exceptions).
        //
        // The epilogue instruction sequence is:
        //
        // ==>  ret   zero, (Ra), 1     // return
        // or
        //
        //      mov   ra, Rx            // save return address
        //      ...
        // ==>  ret   zero, (Rx), 1     // return
        //

        return NextPc;
    }

    //
    // Handle the epilogue case where the next two instructions are a stack
    // frame deallocation and a return.
    //

    if (!ReadMemory(hProcess,(ControlPc+4),&FollowingInstruction.Long,4,&cb)) {
        return 0;
    }

    if (IS_RETURN_0001_INSTRUCTION(FollowingInstruction.Long)) {
        Rb = FollowingInstruction.Jump.Rb;
        NextPc = IntegerRegister[Rb] - 4;

        //
        // The second instruction following the point where control
        // left the specified function is a return. If the instruction
        // before the return is a stack increment instruction, then all
        // saved registers have already been restored except for SP.
        // The value of the stack pointer register cannot be recovered
        // through reverse execution of the prologue because in order
        // to begin reverse execution either the stack pointer or the
        // frame pointer (if any) must still be valid.
        //
        // Instead, the effect that the stack increment instruction
        // would have had on the context is manually applied to the
        // current context. This is forward execution of the epilogue
        // rather than reverse execution of the prologue.
        //
        // In an epilogue, as in a prologue, the stack pointer is always
        // adjusted with a single instruction: either an immediate-value
        // (lda) or a register-value (addq) add instruction.
        //

        Function = Instruction.OpReg.Function;
        Offset16 = Instruction.Memory.MemDisp;
        Opcode = Instruction.OpReg.Opcode;
        Ra = Instruction.OpReg.Ra;
        Rb = Instruction.OpReg.Rb;
        Rc = Instruction.OpReg.Rc;

        if ((Opcode == LDA_OP) && (Ra == SP_REG)) {

            //
            // Load Address instruction.
            //
            // Since the destination (Ra) register is SP, an immediate-
            // value stack deallocation operation is being performed. The
            // displacement value should be added to SP. The displacement
            // value is assumed to be positive. The amount of stack
            // deallocation possible using this instruction ranges from
            // 16 to 32752 (32768 - 16) bytes. The base register (Rb) is
            // usually SP, but may be another register.
            //
            // The epilogue instruction sequence is:
            //
            // ==>  lda   sp, +N(sp)        // deallocate stack frame
            //      ret   zero, (ra)        // return
            // or
            //
            // ==>  lda   sp, +N(Rx)        // restore SP and deallocate frame
            //      ret   zero, (ra)        // return
            //

            Context->IntSp = Offset16 + IntegerRegister[Rb];
            return NextPc;

        } else if ((Opcode == ARITH_OP) && (Function == ADDQ_FUNC) &&
                   (Rc == SP_REG) &&
                   (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT)) {

            //
            // Add Quadword instruction.
            //
            // Since both source operands are registers, and the
            // destination register is SP, a register-value stack
            // deallocation is being performed. The value of the two
            // source registers should be added and this is the new
            // value of SP. One of the source registers is usually SP,
            // but may be another register.
            //
            // The epilogue instruction sequence is:
            //
            //      ldiq  Rx, N             // set [large] frame size
            //      ...
            // ==>  addq  sp, Rx, sp        // deallocate stack frame
            //      ret   zero, (ra)        // return
            // or
            //
            // ==>  addq  Rx, Ry, sp        // restore SP and deallocate frame
            //      ret   zero, (ra)        // return
            //

            Context->IntSp = IntegerRegister[Ra] + IntegerRegister[Rb];
            return NextPc;
        }
    }

    //
    // By default set the frame pointers to the current value of SP.
    //
    // When a procedure is called, the value of SP before the stack
    // allocation instruction is the virtual frame pointer. When reverse
    // executing instructions in the prologue, the value of SP before the
    // stack allocation instruction is encountered is the real frame
    // pointer. This is the current value of SP unless the procedure uses
    // a frame pointer (e.g., FP_REG).
    //

    //
    // If the address where control left the specified function is beyond
    // the end of the prologue, then the control PC is considered to be
    // within the function and the control address is set to the end of
    // the prologue. Otherwise, the control PC is not considered to be
    // within the function (i.e., the prologue).
    //
    // N.B. PrologEndAddress is equal to BeginAddress for a leaf function.
    //
    // The low-order two bits of PrologEndAddress are reserved for the IEEE
    // exception mode and so must be masked out.
    //

    if ((ControlPc < ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
        (ControlPc >= ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry))) {
        ControlPc = ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry);
    }

    //
    // Scan backward through the prologue to reload callee saved registers
    // that were stored or copied and to increment the stack pointer if it
    // was decremented.
    //

    DecrementRegister = ZERO_REG;
    NextPc = Context->IntRa - 4;
    RestoredRa = FALSE;
    RestoredSp = FALSE;
    while (ControlPc > ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) {

        //
        // Get instruction value, decode fields, case on opcode value, and
        // reverse register store and stack decrement operations.
        // N.B. The location of Opcode, Ra, Rb, and Rc is the same across
        // all opcode formats. The same is not true for Function.
        //

        ControlPc -= 4;
        if (!ReadMemory(hProcess, ControlPc, &Instruction.Long, 4, &cb)) {
             return 0;
        }
        Function = Instruction.OpReg.Function;
        Literal8 = Instruction.OpLit.Literal;
        Offset16 = Instruction.Memory.MemDisp;
        Opcode = Instruction.OpReg.Opcode;
        Ra = Instruction.OpReg.Ra;
        Rb = Instruction.OpReg.Rb;
        Rc = Instruction.OpReg.Rc;

        //
        // Compare against each instruction type that will affect the context
        // and that is allowed in a prologue. Any other instructions found
        // in the prologue will be ignored since they are assumed to have no
        // effect on the context.
        //

        switch (Opcode) {

        case STQ_OP :

            //
            // Store Quad instruction.
            //
            // If the base register is SP, then reload the source register
            // value from the value stored on the stack.
            //
            // The prologue instruction sequence is:
            //
            // ==>  stq   Rx, N(sp)         // save integer register Rx
            //

            if ((Rb == SP_REG) && (Ra != ZERO_REG)) {

                //
                // Reload the register by retrieving the value previously
                // stored on the stack.
                //

                Address = (Offset16 + Context->IntSp);
                if (!ReadMemory(hProcess, Address, &IntegerRegister[Ra], 8L, &cb)) {
                    return 0;
                }

                //
                // If the destination register is RA and this is the first
                // time that RA is being restored, then set the address of
                // where control left the previous frame. Otherwise, if this
                // is the second time RA is being restored, then the first
                // one was an interrupt or exception address and the return
                // PC should not have been biased by 4.
                //

                if (Ra == RA_REG) {
                    if (RestoredRa == FALSE) {
                        NextPc = Context->IntRa - 4;
                        RestoredRa = TRUE;

                    } else {
                        NextPc += 4;
                    }

                //
                // Otherwise, if the destination register is SP and this is
                // the first time that SP is being restored, then set the
                // establisher frame pointers.
                //

                } else if ((Ra == SP_REG) && (RestoredSp == FALSE)) {
                    RestoredSp = TRUE;
                }

                //
                // If a context pointer record is specified, then record
                // the address where the destination register contents
                // are stored.
                //

                //if (ContextPointers != (PKNONVOLATILE_CONTEXT_POINTERS) NULL) {
                //    ContextPointers->IntegerContext[Ra] = (PULONGLONG)Address;
                //}
            }
            break;

        case LDAH_OP :
            Offset16 <<= 16;

        case LDA_OP :

            //
            // Load Address High, Load Address instruction.
            //
            // There are several cases where the lda and/or ldah instructions
            // are used: one to decrement the stack pointer directly, and the
            // others to load immediate values into another register and that
            // register is then used to decrement the stack pointer.
            //
            // In the examples below, as a single instructions or as a pair,
            // a lda may be substituted for a ldah and visa-versa.
            //

            if (Ra == SP_REG) {
                if (Rb == SP_REG) {

                    //
                    // If both the destination (Ra) and base (Rb) registers
                    // are SP, then a standard stack allocation was performed
                    // and the negated displacement value is the stack frame
                    // size. The amount of stack allocation possible using
                    // the lda instruction ranges from 16 to 32768 bytes and
                    // the amount of stack allocation possible using the ldah
                    // instruction ranges from 65536 to 2GB in multiples of
                    // 65536 bytes. It is rare for the ldah instruction to be
                    // used in this manner.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  lda   sp, -N(sp)    // allocate stack frame
                    //

                    FrameSize = -Offset16;
                    goto StackAllocation;

                } else {

                    //
                    // The destination register is SP and the base register
                    // is not SP, so this instruction must be the second
                    // half of an instruction pair to allocate a large size
                    // (>32768 bytes) stack frame. Save the displacement value
                    // as the partial decrement value and postpone adjusting
                    // the value of SP until the first instruction of the pair
                    // is encountered.
                    //
                    // The prologue instruction sequence is:
                    //
                    //      ldah  Rx, -N(sp)    // prepare new SP (upper)
                    // ==>  lda   sp, sN(Rx)    // allocate stack frame
                    //

                    DecrementRegister = Rb;
                    DecrementOffset = Offset16;
                }

            } else if (Ra == DecrementRegister) {
                if (Rb == DecrementRegister) {

                    //
                    // Both the destination and base registers are the
                    // decrement register, so this instruction exists as the
                    // second half of a two instruction pair to load a
                    // 31-bit immediate value into the decrement register.
                    // Save the displacement value as the partial decrement
                    // value.
                    //
                    // The prologue instruction sequence is:
                    //
                    //      ldah  Rx, +N(zero)      // set frame size (upper)
                    // ==>  lda   Rx, sN(Rx)        // set frame size (+lower)
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    //

                    DecrementOffset += Offset16;

                } else if (Rb == ZERO_REG) {

                    //
                    // The destination register is the decrement register and
                    // the base register is zero, so this instruction exists
                    // to load an immediate value into the decrement register.
                    // The stack frame size is the new displacement value added
                    // to the previous displacement value, if any.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  lda   Rx, +N(zero)      // set frame size
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    // or
                    //
                    // ==>  ldah  Rx, +N(zero)      // set frame size (upper)
                    //      lda   Rx, sN(Rx)        // set frame size (+lower)
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    //

                    FrameSize = (Offset16 + DecrementOffset);
                    goto StackAllocation;

                } else if (Rb == SP_REG) {

                    //
                    // The destination (Ra) register is SP and the base (Rb)
                    // register is the decrement register, so a two
                    // instruction, large size (>32768 bytes) stack frame
                    // allocation was performed. Add the new displacement
                    // value to the previous displacement value. The negated
                    // displacement value is the stack frame size.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  ldah  Rx, -N(sp)    // prepare new SP (upper)
                    //      lda   sp, sN(Rx)    // allocate stack frame
                    //

                    FrameSize = -(Offset16 + (LONG)DecrementOffset);
                    goto StackAllocation;
                }
            }
            break;

        case ARITH_OP :

            if ((Function == ADDQ_FUNC) &&
                (Instruction.OpReg.RbvType != RBV_REGISTER_FORMAT)) {

                //
                // Add Quadword (immediate) instruction.
                //
                // If the first source register is zero, and the second
                // operand is a literal, and the destination register is
                // the decrement register, then the instruction exists
                // to load an unsigned immediate value less than 256 into
                // the decrement register. The immediate value is the stack
                // frame size.
                //
                // The prologue instruction sequence is:
                //
                // ==>  addq  zero, N, Rx       // set frame size
                //      ...
                //      subq  sp, Rx, sp        // allocate stack frame
                //

                if ((Ra == ZERO_REG) && (Rc == DecrementRegister)) {
                    FrameSize = Literal8;
                    goto StackAllocation;
                }

            } else if ((Function == SUBQ_FUNC) &&
                       (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT)) {

                //
                // Subtract Quadword (register) instruction.
                //
                // If both source operands are registers and the first
                // source (minuend) register and the destination
                // (difference) register are both SP, then a register value
                // stack allocation was performed and the second source
                // (subtrahend) register value will be added to SP when its
                // value is known. Until that time save the register number of
                // this decrement register.
                //
                // The prologue instruction sequence is:
                //
                //      ldiq  Rx, N             // set frame size
                //      ...
                // ==>  subq  sp, Rx, sp        // allocate stack frame
                //

                if ((Ra == SP_REG) && (Rc == SP_REG)) {
                    DecrementRegister = Rb;
                    DecrementOffset = 0;
                }
            }
            break;

        case BIT_OP :

            //
            // If the second operand is a register the bit set instruction
            // may be a register move instruction, otherwise if the second
            // operand is a literal, the bit set instruction may be a load
            // immediate value instruction.
            //

            if ((Function == BIS_FUNC) && (Rc != ZERO_REG)) {
                if (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT) {

                    //
                    // Bit Set (register move) instruction.
                    //
                    // If both source registers are the same register, or
                    // one of the source registers is zero, then this is a
                    // register move operation. Restore the value of the
                    // source register by copying the current destination
                    // register value back to the source register.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  bis   Rx, Rx, Ry        // copy register Rx
                    // or
                    //
                    // ==>  bis   Rx, zero, Ry      // copy register Rx
                    // or
                    //
                    // ==>  bis   zero, Rx, Ry      // copy register Rx
                    //

                    if (Ra == ZERO_REG) {

                        //
                        // Map the third case above to the first case.
                        //

                        Ra = Rb;

                    } else if (Rb == ZERO_REG) {

                        //
                        // Map the second case above to the first case.
                        //

                        Rb = Ra;
                    }

                    if ((Ra == Rb) && (Ra != ZERO_REG)) {
                        IntegerRegister[Ra] = IntegerRegister[Rc];


                        //
                        // If the destination register is RA and this is the
                        // first time that RA is being restored, then set the
                        // address of where control left the previous frame.
                        // Otherwise, if this is the second time RA is being
                        // restored, then the first one was an interrupt or
                        // exception address and the return PC should not
                        // have been biased by 4.
                        //

                        if (Ra == RA_REG) {
                            if (RestoredRa == FALSE) {
                                NextPc = Context->IntRa - 4;
                                RestoredRa = TRUE;

                            } else {
                                NextPc += 4;
                            }
                        }

                        //
                        // If the source register is SP and this is the first
                        // time SP is set, then this is a frame pointer set
                        // instruction. Reset the frame pointers to this new
                        // value of SP.
                        //

                        if ((Ra == SP_REG) && (RestoredSp == FALSE)) {
                            RestoredSp = TRUE;
                        }
                    }

                } else {

                    //
                    // Bit Set (load immediate) instruction.
                    //
                    // If the first source register is zero, and the second
                    // operand is a literal, and the destination register is
                    // the decrement register, then this instruction exists
                    // to load an unsigned immediate value less than 256 into
                    // the decrement register. The decrement register value is
                    // the stack frame size.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  bis   zero, N, Rx       // set frame size
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    //

                    if ((Ra == ZERO_REG) && (Rc == DecrementRegister)) {
                        FrameSize = Literal8;
StackAllocation:
                        //
                        // Add the frame size to SP to reverse the stack frame
                        // allocation, leave the real frame pointer as is, set
                        // the virtual frame pointer with the updated SP value,
                        // and clear the decrement register.
                        //

                        Context->IntSp += FrameSize;
                        DecrementRegister = ZERO_REG;
                    }
                }
            }
            break;

        case STT_OP :

            //
            // Store T-Floating (quadword integer) instruction.
            //
            // If the base register is SP, then reload the source register
            // value from the value stored on the stack.
            //
            // The prologue instruction sequence is:
            //
            // ==>  stt   Fx, N(sp)         // save floating register Fx
            //

            if ((Rb == SP_REG) && (Ra != FZERO_REG)) {

                //
                // Reload the register by retrieving the value previously
                // stored on the stack.
                //

                Address = (Offset16 + Context->IntSp);
                if (!ReadMemory(hProcess, Address, &FloatingRegister[Ra], 8L, &cb)) {
                    return 0;
                }

                //
                // If a context pointer record is specified, then record
                // the address where the destination register contents are
                // stored.
                //

                //if (ContextPointers != (PKNONVOLATILE_CONTEXT_POINTERS) NULL) {
                //    ContextPointers->FloatingContext[Ra] = (PULONGLONG)Address;
                //}
            }
            break;


        case STS_OP :

            //
            // Store T-Floating (dword integer) instruction.
            //
            // If the base register is SP, then reload the source register
            // value from the value stored on the stack.
            //
            // The prologue instruction sequence is:
            //
            // ==>  stt   Fx, N(sp)         // save floating register Fx
            //

            if ((Rb == SP_REG) && (Ra != FZERO_REG)) {

                //
                // Reload the register by retrieving the value previously
                // stored on the stack.
                //

                float f;

                Address = (Offset16 + Context->IntSp);
                if (!ReadMemory(hProcess, Address, &f, sizeof(float), &cb)) {
                    return 0;
                }

                //
                // value was stored as a float.  Do a conversion to a
                // double, since registers are Always read as doubles
                //
                FloatingRegister[Ra] = (ULONGLONG)(double)f;

                //
                // If a context pointer record is specified, then record
                // the address where the destination register contents are
                // stored.
                //

                //if (ContextPointers != (PKNONVOLATILE_CONTEXT_POINTERS) NULL) {
                //    ContextPointers->FloatingContext[Ra] = (PULONGLONG)Address;
                //}
            }
            break;

        case FPOP_OP :

            //
            // N.B. The floating operate function field is not the same as
            // the integer operate nor the jump function fields.
            //

            if (Instruction.FpOp.Function == CPYS_FUNC) {

                //
                // Copy Sign (floating-point move) instruction.
                //
                // If both source registers are the same register, then this is
                // a floating-point register move operation. Restore the value
                // of the source register by copying the current destination
                // register value to the source register.
                //
                // The prologue instruction sequence is:
                //
                // ==>  cpys  Fx, Fx, Fy        // copy floating register Fx
                //

                if ((Ra == Rb) && (Ra != FZERO_REG)) {
                    FloatingRegister[Ra] = FloatingRegister[Rc];
                }
            }

        default :
            break;
        }
    }

    if (StackAdjust) {
        // Check for exlicit stack adjust amount

        Context->IntSp += StackAdjust;
    }

    if (FixedReturn != 0) {
        NextPc = FixedReturn;
    }

    return NextPc;
}

BOOL
WalkAlphaGetStackFrame(
    HANDLE                            hProcess,
    PULONG64                          ReturnAddress,
    PULONG64                          FramePointer,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    PKDHELP64                         KdHelp,
    BOOL                              Use64
    )
{
    FeCacheEntry*                    CacheEntry;
    FeCacheEntry                     UnwindFunctionEntry;
    ULONG64                          NextPc = Context->IntRa;
    BOOL                             rval = TRUE;
    ULONG                            cb;
    ULONG                            StackAdjust;
    ULONG64                          FixedReturn;


    if (*ReturnAddress == 0) {
        return FALSE;
    }

    __try {
        FunctionEntryCache* Cache =
            GetFeCache(Use64 ?
                       IMAGE_FILE_MACHINE_ALPHA64 : IMAGE_FILE_MACHINE_ALPHA,
                       TRUE);
        if (Cache != NULL) {
            CacheEntry = Cache->Find(hProcess, *ReturnAddress, ReadMemory,
                                     GetModuleBase, GetFunctionEntry);
        } else {
            CacheEntry = NULL;
        }

        if (CacheEntry != NULL) {

            // Construct a function entry suitable for unwinding from ControlPc

            UnwindFunctionEntry.Address = 0;
            UnwindFunctionEntry.Process = 0;

            GetUnwindFunctionEntry( hProcess, *ReturnAddress, ReadMemory, GetModuleBase, GetFunctionEntry, Use64, CacheEntry,
                                    &UnwindFunctionEntry.Data.Axp64, &StackAdjust, &FixedReturn );
            FE_SET_DESC(&UnwindFunctionEntry, "from UnwindFunctionEntry");
            FE_ShowRuntimeFunctionAxp64((&UnwindFunctionEntry,
                                         "VirtualUnwind: unwind function entry"));
#if DBG
            if (tlsvar(DebugFunctionEntries)) {
                dbPrint("    FixedReturn      = %16.8I64x\n", FixedReturn );
                dbPrint("    StackAdjust      = %16x\n", StackAdjust );
            }
#endif

            NextPc = VirtualUnwind( hProcess, *ReturnAddress, &UnwindFunctionEntry.Data.Axp64, StackAdjust, FixedReturn, Context, ReadMemory);
#if DBG
            if (tlsvar(DebugFunctionEntries)) {
                dbPrint("NextPc = %.8I64x\n", NextPc );
            }
#endif
            if (!NextPc) {
                rval = FALSE;
            }

            //
            // The Ra value coming out of mainCRTStartup is set by some RTL
            // routines to be "1"; return out of mainCRTStartup is actually
            // done through Jump/Unwind, so this serves to cause an error if
            // someone actually does a return.  That's why we check here for
            // NextPc == 1 - this happens when in the frame for CRTStartup.
            //
            // We test for (0-4) and (1-4) because on ALPHA, the value returned by
            // VirtualUnwind is the value to be passed to the next call to
            // VirtualUnwind, which is NOT the same as the Ra - it's sometimes
            // decremented by four - this gives the faulting instruction -
            // in particular, we want the fault instruction so we can get the
            // correct scope in the case of an exception.
            //
            if ((NextPc == 1) || (NextPc == 4) || (NextPc == (0-4)) || (NextPc == (1-4)) ) {
                NextPc = 0;
            }
            if ( !NextPc || (NextPc == *ReturnAddress && *FramePointer == Context->IntSp) ) {
                rval = FALSE;
            }

            *ReturnAddress = NextPc;
            *FramePointer  = Context->IntSp;

        } else {

            if ( (NextPc == *ReturnAddress && *FramePointer == Context->IntSp) ||
                 (NextPc == 1) || (NextPc == 0) || (NextPc == (-4)) ) {
                rval = FALSE;
            }

            *ReturnAddress = Context->IntRa;
            *FramePointer  = Context->IntSp;

        }

    } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        rval = FALSE;
    }

    return rval;
}


BOOL
WalkAlphaInit(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    )
{
    ALPHA_NT5_CONTEXT  ContextSave;
    ULONG64            PcOffset;
    ULONG64            FrameOffset;
    DWORD              cb;
    ALPHA_KEXCEPTION_FRAME   ExceptionFrame;
    PALPHA_KEXCEPTION_FRAME  pef = &ExceptionFrame;
    DWORD              Result;

    if (StackFrame->AddrFrame.Offset) {
#if 0
        if (ReadMemory( hProcess,
                        StackFrame->AddrFrame.Offset,
                        &ExceptionFrame,
                        sizeof(ALPHA_KEXCEPTION_FRAME),
                        &cb )) {
            //
            // successfully read an exception frame from the stack
            //
            Context->IntSp  = StackFrame->AddrFrame.Offset;
            Context->Fir    = pef->SwapReturn;
            Context->IntRa  = pef->SwapReturn;
            Context->IntS0  = pef->IntS0;
            Context->IntS1  = pef->IntS1;
            Context->IntS2  = pef->IntS2;
            Context->IntS3  = pef->IntS3;
            Context->IntS4  = pef->IntS4;
            Context->IntS5  = pef->IntS5;
            Context->Psr    = pef->Psr;
        } else {
            return FALSE;
        }
#endif

    }

    ZeroMemory( StackFrame, FIELD_OFFSET( STACKFRAME64, KdHelp.ThCallbackBStore) );

    StackFrame->Virtual = TRUE;

    StackFrame->AddrPC.Offset       = Context->Fir;
    StackFrame->AddrPC.Mode         = AddrModeFlat;

    StackFrame->AddrFrame.Offset    = Context->IntSp;
    StackFrame->AddrFrame.Mode      = AddrModeFlat;

    ContextSave = *Context;
    PcOffset    = StackFrame->AddrPC.Offset;
    FrameOffset = StackFrame->AddrFrame.Offset;

    if (!WalkAlphaGetStackFrame( hProcess,
                        &PcOffset,
                        &FrameOffset,
                        &ContextSave,
                        ReadMemory,
                        GetModuleBase,
                        GetFunctionEntry,
                        &StackFrame->KdHelp,
                        Use64) ) {

        StackFrame->AddrReturn.Offset = Context->IntRa;

    } else {

        StackFrame->AddrReturn.Offset = PcOffset;
    }

    StackFrame->AddrReturn.Mode     = AddrModeFlat;

    //
    // get the arguments to the function
    //
    StackFrame->Params[0] = Context->IntA0;
    StackFrame->Params[1] = Context->IntA1;
    StackFrame->Params[2] = Context->IntA2;
    StackFrame->Params[3] = Context->IntA3;

    return TRUE;
}


BOOL
WalkAlphaNext(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    )
{
    DWORD              cb;
    ALPHA_NT5_CONTEXT  ContextSave;
    BOOL               rval = TRUE;
    ULONG64            Address;
    FunctionEntryCache* Cache;
    FeCacheEntry*      CacheEntry;
    ULONG64            SystemRangeStart;
    DWORD              dw;
    ULONG64            qw;


    if (!WalkAlphaGetStackFrame( hProcess,
                        &StackFrame->AddrPC.Offset,
                        &StackFrame->AddrFrame.Offset,
                        Context,
                        ReadMemory,
                        GetModuleBase,
                        GetFunctionEntry,
                        &StackFrame->KdHelp,
                        Use64) ) {

        rval = FALSE;

        //
        // If the frame could not be unwound or is terminal, see if
        // there is a callback frame:
        //

        if (g.AppVersion.Revision >= 4 && CALLBACK_STACK(StackFrame)) {

            if (g.AppVersion.Revision >= 6) {
                SystemRangeStart = SYSTEM_RANGE_START(StackFrame);
            } else {
                //
                // This might not really work right with old debuggers, but it keeps
                // us from looking off the end of the structure anyway.
                //
                SystemRangeStart = 0x80000000;
            }

           if (CALLBACK_STACK(StackFrame) >= SystemRangeStart) {

                //
                // it is the pointer to the stack frame that we want,
                // or -1.

                Address = CALLBACK_STACK(StackFrame);

            } else {

                //
                // if it is a positive integer, it is the offset to
                // the address in the thread.
                // Look up the pointer:
                //

                if (Use64) {
                    rval = ReadMemory(hProcess,
                                      (CALLBACK_THREAD(StackFrame) +
                                                     CALLBACK_STACK(StackFrame)),
                                      &Address,
                                      sizeof(ULONG64),
                                      &cb);
                } else {
                    rval = ReadMemory(hProcess,
                                      (CALLBACK_THREAD(StackFrame) +
                                                     CALLBACK_STACK(StackFrame)),
                                      &dw,
                                      sizeof(DWORD),
                                      &cb);
                    Address = (ULONG64)(LONG64)(LONG)dw;
                }

                if (!rval || Address == 0) {
                    Address = (ULONG64)-1;
                    CALLBACK_STACK(StackFrame) = (DWORD)-1;
                }

            }

            if ( (Address == (ULONG64)-1) ||
                 (Cache = GetFeCache(Use64 ?
                                     IMAGE_FILE_MACHINE_ALPHA64 :
                                     IMAGE_FILE_MACHINE_ALPHA,
                                     TRUE)) == NULL ||
                 (CacheEntry = Cache->Find(hProcess, CALLBACK_FUNC(StackFrame),
                                           ReadMemory, GetModuleBase,
                                           GetFunctionEntry)) == NULL ) {

                rval = FALSE;

            } else {

                if (Use64) {
                    ReadMemory(hProcess,
                               (Address + CALLBACK_NEXT(StackFrame)),
                               &CALLBACK_STACK(StackFrame),
                               sizeof(ULONG64),
                               &cb);
                    StackFrame->AddrPC.Offset = ALPHA_RF_PROLOG_END_ADDRESS(&CacheEntry->Data.Axp64);
                } else {
                    ReadMemory(hProcess,
                               (Address + CALLBACK_NEXT(StackFrame)),
                               &dw,
                               sizeof(DWORD),
                               &cb);
                    CALLBACK_STACK(StackFrame) = dw;
                    StackFrame->AddrPC.Offset = ALPHA_RF_PROLOG_END_ADDRESS((PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)&CacheEntry->Data.Axp64);
                }

                StackFrame->AddrFrame.Offset = Address;
                Context->IntSp = Address;

                rval = TRUE;
            }
        }
    }

    //
    // get the return address
    //
    ContextSave = *Context;
    StackFrame->AddrReturn.Offset = StackFrame->AddrPC.Offset;
    qw = 0;

    if (!WalkAlphaGetStackFrame( hProcess,
                        &StackFrame->AddrReturn.Offset,
                        &qw,
                        &ContextSave,
                        ReadMemory,
                        GetModuleBase,
                        GetFunctionEntry,
                        &StackFrame->KdHelp,
                        Use64) ) {

        StackFrame->AddrReturn.Offset = 0;

    }

    //
    // get the arguments to the function
    //
    StackFrame->Params[0] = ContextSave.IntA0;
    StackFrame->Params[1] = ContextSave.IntA1;
    StackFrame->Params[2] = ContextSave.IntA2;
    StackFrame->Params[3] = ContextSave.IntA3;

    return rval;
}


VOID
GetUnwindFunctionEntry(
    HANDLE                                hProcess,
    ULONG64                               ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64        ReadMemory,
    PGET_MODULE_BASE_ROUTINE64            GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64      GetFunctionEntry,
    BOOL                                  Use64,
    FeCacheEntry*                         CacheEntry,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY UnwindFunctionEntry,
    PULONG                                StackAdjust,
    PULONG64                              FixedReturn
    )
/*++

Routine Description:

    This function returns a function entry (RUNTIME_FUNCTION) suitable
    for unwinding from ControlPc. It encapsulates the handling of primary
    and secondary function entries so that this processing is not duplicated
    in VirtualUnwind and other similar functions.

Arguments:

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    UnwindFunctionEntry - Supplies the address of a function table entry which
        will be setup with appropriate fields for unwinding from ControlPc

Return Value:

    None.

--*/

{
    ULONG EntryType = 0;
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY SecondaryFunctionEntry = NULL;
    ULONG64 AlternateProlog;
    FeCacheEntry LocalCache;
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY FunctionEntry;
    FunctionEntryCache* Cache;
    FeCacheEntry* SecCache;

    *FixedReturn = 0;
    *StackAdjust = 0;

#if DBG
    if (ControlPc & 0x3) {
        dbPrint("GetUnwindFunctionEntry: invalid PC for unwinding (low bits set): %16.8I64x.\n", ControlPc);
    }
#endif

    Cache = GetFeCache(Use64 ?
                       IMAGE_FILE_MACHINE_ALPHA64 : IMAGE_FILE_MACHINE_ALPHA,
                       TRUE);
    
    // CacheEntry should never be null, but if it is create one that
    // looks like a leaf entry for ControlPc

    if (Cache == NULL || CacheEntry == NULL) {
#if DBG
        dbPrint("\nGetUnwindFunctionEntry: Null function table entry for unwinding.\n");
#endif
        UnwindFunctionEntry->BeginAddress     = ControlPc;
        UnwindFunctionEntry->EndAddress       = ControlPc+4;
        UnwindFunctionEntry->ExceptionHandler = 0;
        UnwindFunctionEntry->HandlerData      = 0;
        UnwindFunctionEntry->PrologEndAddress = ControlPc;
        return;
    }

    // Work off a local copy of the function entry passed in
    // as later function entry lookups may cause it to be
    // evicted from the cache, invalidating the pointer.
    LocalCache = *CacheEntry;
    CacheEntry = &LocalCache;
    FunctionEntry = &CacheEntry->Data.Axp64;

    //
    // Because of the secondary-to-primary function entry indirection applied by
    // Find() ControlPc may not be within the range described
    // by the supplied function entry. Call FindDirect()
    // to recover the actual (secondary) function entry.  If we don't get a
    // valid associated function entry then process the unwind with the one
    // supplied, trusting that the caller has supplied the given entry intentionally.
    //
    // A secondary function entry is a RUNTIME_FUNCTION entry where
    // PrologEndAddress is not in the range of BeginAddress to EndAddress.
    // There are three types of secondary function entries. They are
    // distinquished by the Entry Type field (2 bits):
    //
    // ALPHA_RF_NOT_CONTIGUOUS - discontiguous code
    // ALPHA_RF_ALT_ENT_PROLOG - alternate entry point prologue
    // ALPHA_RF_NULL_CONTEXT   - null-context code
    //

    if ((ControlPc <  ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
        (ControlPc >= ALPHA_RF_END_ADDRESS(FunctionEntry))) {

        // ControlPC is not in the range of the supplied function entry.
        // Get the actual function entry which is expected to be the
        // associated secondary function entry or a fixed return primary function.
#if DBG
        if (tlsvar(DebugFunctionEntries)) {
            dbPrint("\nGetUnwindFunctionEntry:LookupDirectFunctionEntry(ControlPc=%.8I64x,Use64=%d)\n", ControlPc, Use64 );
        }
#endif

        SecCache = Cache->
            FindDirect( hProcess, ControlPc, ReadMemory, GetModuleBase,
                        GetFunctionEntry );
        if (SecCache != NULL) {
            SecondaryFunctionEntry = &SecCache->Data.Axp64;
        } else {
            SecondaryFunctionEntry = NULL;
        }

        if (SecondaryFunctionEntry) {

            FE_ShowRuntimeFunctionAxp64((SecCache, "GetUnwindFunctionEntry: LookupDirectFunctionEntry"));

            // If this is a null-context tail region then unwind with a null-context-like descriptor

            if ((ControlPc >= ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry)-(ALPHA_RF_NULL_CONTEXT_COUNT(SecondaryFunctionEntry)*4)) &&
                (ControlPc <  ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                // Use the secondary function entry with PrologEndAddress = BeginAddress.
                // This ensures that the prologue is not reverse executed.

                UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
                UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
                UnwindFunctionEntry->ExceptionHandler = 0;
                UnwindFunctionEntry->HandlerData      = 0;
                UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
                return;
            }

            if ((SecondaryFunctionEntry->PrologEndAddress < ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) ||
                (SecondaryFunctionEntry->PrologEndAddress > ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                // Got a secondary function entry as expected. But if indirection doesn't point
                // to FunctionEntry then ignore it and use the caller supplied FunctionEntry.

                if (ALPHA_RF_PROLOG_END_ADDRESS(SecondaryFunctionEntry) != CacheEntry->Address) {
                    FE_ShowRuntimeFunctionAxp64((SecCache,
                                                 "GetUnwindFunctionEntry: unexpected secondary function entry from LookupDirectFunctionEntry"));
                    SecondaryFunctionEntry = NULL;
                }
            } else if (ALPHA_RF_IS_FIXED_RETURN(SecondaryFunctionEntry)) {
                // Got a fixed return entry. Switch to using the fixed return entry as the primary.

                    FunctionEntry = SecondaryFunctionEntry;
                    CacheEntry = SecCache;
                    SecondaryFunctionEntry = NULL;

            } else {

                // Got a primary function entry. Ignore it and use caller supplied FunctionEntry.
                FE_ShowRuntimeFunctionAxp64((SecCache,
                                             "GetUnwindFunctionEntry: unexpected primary function entry from LookupDirectFunctionEntry"));
                SecondaryFunctionEntry = NULL;
            }
#if DBG
        } else {
            ShowRuntimeFunctionAxp64(SecCache, "GetUnwindFunctionEntry: LookupDirectFunctionEntry returned NULL");
#endif
        }
    } else {

        // ControlPC is in the range of the supplied function entry.

        // If this is a null-context tail region then unwind with a null-context-like descriptor

        if ((ControlPc >= ALPHA_RF_END_ADDRESS(FunctionEntry)-(ALPHA_RF_NULL_CONTEXT_COUNT(FunctionEntry)*4)) &&
            (ControlPc <  ALPHA_RF_END_ADDRESS(FunctionEntry))) {

            // Use the secondary function entry with PrologEndAddress = BeginAddress.
            // This ensures that the prologue is not reverse executed.

            UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(FunctionEntry);
            UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(FunctionEntry);
            UnwindFunctionEntry->ExceptionHandler = 0;
            UnwindFunctionEntry->HandlerData      = 0;
            UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_BEGIN_ADDRESS(FunctionEntry);
            return;
        }

        // Check if it is a secondary function entry. This shouldn't happen because
        // LookupFunctionEntry is always supposed to return a primary function entry.
        // But if we get passed a secondary, then switch to it's primary. However note
        // that we've gone through this pass

        if ((FunctionEntry->PrologEndAddress < ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
            (FunctionEntry->PrologEndAddress > ALPHA_RF_END_ADDRESS(FunctionEntry))) {
            SecondaryFunctionEntry = FunctionEntry;
            SecCache = Cache->ReadImage
                ( hProcess,
                  ALPHA_RF_PROLOG_END_ADDRESS(SecondaryFunctionEntry),
                  ReadMemory, GetModuleBase );
            if (SecCache != NULL) {
                SecondaryFunctionEntry = &SecCache->Data.Axp64;
            } else {
                SecondaryFunctionEntry = NULL;
            }
            FE_ShowRuntimeFunctionAxp64((SecCache,
                                         "GetUnwindFunctionEntry: received secondary function entry"));
        }
    }

    // FunctionEntry is now the primary function entry and if SecondaryFunctionEntry is
    // not NULL then it is the secondary function entry that contains the ControlPC. Setup a
    // copy of the FunctionEntry suitable for unwinding. By default use the supplied FunctionEntry.

    if (SecondaryFunctionEntry) {

        // Extract the secondary function entry type.

        EntryType = ALPHA_RF_ENTRY_TYPE(SecondaryFunctionEntry);

        if (EntryType == ALPHA_RF_NOT_CONTIGUOUS) {
            // The exception happened in the body of the procedure but in a non-contiguous
            // section of code. Regardless of what entry point was used, it is normally valid
            // to unwind using the primary entry point prologue. The only exception is when an
            // alternate prologue is specified However, there may be an
            // alternate prologue end addresss specified in which case unwind using this
            // block as though it were the primary.

            AlternateProlog = ALPHA_RF_ALT_PROLOG64(SecondaryFunctionEntry);

            if ((AlternateProlog >= ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) &&
                (AlternateProlog <  ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                // If the control PC is in the alternate prologue, use the secondary.
                // The control Pc is not in procedure context.

                if ((ControlPc >= ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) &&
                    (ControlPc <  ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                    UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
                    UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
                    UnwindFunctionEntry->ExceptionHandler = 0;
                    UnwindFunctionEntry->HandlerData      = 0;
                    UnwindFunctionEntry->PrologEndAddress = AlternateProlog;
                    return;
                }
            }

            // Fall out of the if statement to pick up the primary function entry below.
            // This code is in-procedure-context and subject to the primary's prologue
            // and exception handlers.

        } else if (EntryType == ALPHA_RF_ALT_ENT_PROLOG) {
            // Exception occured in an alternate entry point prologue.
            // Use the secondary function entry with a fixed-up PrologEndAddress.

            UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->ExceptionHandler = 0;
            UnwindFunctionEntry->HandlerData      = 0;
            UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_END_ADDRESS(UnwindFunctionEntry);

            // Check for an alternate prologue.

            AlternateProlog = ALPHA_RF_ALT_PROLOG64(SecondaryFunctionEntry);
            if (AlternateProlog >= UnwindFunctionEntry->BeginAddress &&
                AlternateProlog <  UnwindFunctionEntry->EndAddress ) {
                // The prologue is only part of the procedure
                UnwindFunctionEntry->PrologEndAddress = AlternateProlog;
            }

            return;

        } else if (EntryType == ALPHA_RF_NULL_CONTEXT) {

            // Exception occured in null-context code associated with a primary function.
            // Use the secondary function entry with a PrologEndAddress = BeginAddress.
            // There is no prologue for null-context code.

            *StackAdjust = ALPHA_RF_STACK_ADJUST(SecondaryFunctionEntry);
            UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->ExceptionHandler = 0;
            UnwindFunctionEntry->HandlerData      = 0;
            UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
            return;
        }
    }

    // FunctionEntry is only null if there was an error fetching it from a passed in
    // secondary function entry.

    if (FunctionEntry == NULL) {
#if DBG
        dbPrint("\nGetUnwindFunctionEntry: Error in FetchFunctionEntry.\n");
#endif
        UnwindFunctionEntry->BeginAddress     = ControlPc;
        UnwindFunctionEntry->EndAddress       = ControlPc+4;
        UnwindFunctionEntry->ExceptionHandler = 0;
        UnwindFunctionEntry->HandlerData      = 0;
        UnwindFunctionEntry->PrologEndAddress = ControlPc;
        return;
    }

#if DBG
    if (ALPHA_RF_BEGIN_ADDRESS(FunctionEntry) >= ALPHA_RF_END_ADDRESS(FunctionEntry)) {
        ShowRuntimeFunctionAxp64(CacheEntry, "GetUnwindFunctionEntry: Warning - BeginAddress < EndAddress.");
    } else if (FunctionEntry->PrologEndAddress < ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) {
        ShowRuntimeFunctionAxp64(CacheEntry, "GetUnwindFunctionEntry: Warning - PrologEndAddress < BeginAddress.");
    } else if (FunctionEntry->PrologEndAddress > ALPHA_RF_END_ADDRESS(FunctionEntry)) {
        ShowRuntimeFunctionAxp64(CacheEntry, "GetUnwindFunctionEntry: Warning - PrologEndAddress > EndAddress.");
    }
#endif

    // Use the primary function entry

    *UnwindFunctionEntry = *FunctionEntry;
    UnwindFunctionEntry->EndAddress = ALPHA_RF_END_ADDRESS(UnwindFunctionEntry);  // Remove null-context count

    // If the primary has a fixed return address, pull that out now.

    if (ALPHA_RF_IS_FIXED_RETURN(FunctionEntry)) {
        *FixedReturn = ALPHA_RF_FIXED_RETURN64(FunctionEntry);
        UnwindFunctionEntry->ExceptionHandler = 0;
        UnwindFunctionEntry->HandlerData      = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\whackdbg.c ===
#include <windows.h>
#include <stdio.h>

int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE hMappedFile;
    HANDLE hFile;
    int i;
    PIMAGE_SECTION_HEADER ImageSectHdr;
    PIMAGE_FILE_HEADER ImageHdr;

    if (argc <= 1) {
        puts("Usage: whackdbg <object>\n"
             "\twhere <object> is an obj that contains CV .debug$? sections that s/b zero'd out\n");
        return 1;
    }

    argv++;
    while (--argc) {
        hFile = CreateFile(
                    *argv,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
        if ( hFile == INVALID_HANDLE_VALUE )
            goto clean0;

        hMappedFile = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        0,
                        NULL
                        );
        if ( !hMappedFile ) {
            goto clean1;
        }

        ImageHdr = (PIMAGE_FILE_HEADER) MapViewOfFile( hMappedFile, FILE_MAP_WRITE, 0, 0, 0 );

        CloseHandle(hMappedFile);

        // We're going to do very minimal testing here.  Basically if it starts with
        // a i386 or alpha machine signature, we'll assume it's an object and party on
        // it...

        if ((ImageHdr->Machine != IMAGE_FILE_MACHINE_I386) &&
            (ImageHdr->Machine != IMAGE_FILE_MACHINE_ALPHA))
        {
            goto clean2;
        }

        ImageSectHdr = (PIMAGE_SECTION_HEADER)((ULONG)ImageHdr + IMAGE_SIZEOF_FILE_HEADER);
        for (i=0;i < ImageHdr->NumberOfSections; i++) {
            if ((strcmp(ImageSectHdr->Name, ".debug$T") == 0) ||
                (strcmp(ImageSectHdr->Name, ".debug$S") == 0) ||
                (strcmp(ImageSectHdr->Name, ".debug$P") == 0)
               )
            {
                ImageSectHdr->SizeOfRawData = 0;
            }
            ImageSectHdr++;
        }

        FlushViewOfFile((PUCHAR)ImageHdr, 0);
clean2:
        UnmapViewOfFile((PUCHAR)ImageHdr);
clean1:
        CloseHandle(hFile);
clean0:
        argv++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\walki64.c ===
/*++

Copyright (c) 1996  Intel Corporation
Copyright (c) 1993  Microsoft Corporation

Module Name:

    walki64.c

Abstract:

    This file implements the IA64 stack walking api.

Author:

Environment:

    User Mode

--*/

#define _IMAGEHLP_SOURCE_
#define _IA64REG_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#include "ia64inst.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "symbols.h"
#include <stdlib.h>
#include <globals.h>

BOOL
WalkIa64Init(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
WalkIa64Next(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
GetStackFrameIa64(
    HANDLE                            hProcess,
    PULONG64                          ReturnAddress,
    PULONG64                          FramePointer,
    PULONG64                          BStorePointer,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    UINT                              iContext
    );

#define CALLBACK_STACK(f)  (f->KdHelp.ThCallbackStack)
#define CALLBACK_BSTORE(f) (f->KdHelp.ThCallbackBStore)
#define CALLBACK_NEXT(f)   (f->KdHelp.NextCallback)
#define CALLBACK_FUNC(f)   (f->KdHelp.KiCallUserMode)
#define CALLBACK_THREAD(f) (f->KdHelp.Thread)



BOOL
WalkIa64(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    BOOL rval;
    PIA64_CONTEXT Context = (PIA64_CONTEXT)ContextRecord;

    if (StackFrame->Virtual) {

        rval = WalkIa64Next( hProcess,
                             StackFrame,
                             Context,
                             ReadMemory,
                             FunctionTableAccess,
                             GetModuleBase
                           );

    } else {

        rval = WalkIa64Init( hProcess,
                             StackFrame,
                             Context,
                             ReadMemory,
                             FunctionTableAccess,
                             GetModuleBase
                           );

    } // iff

    return rval;

} // WalkIa64()

size_t 
Vwndia64InitFixupTable(UINT iContext);

BOOL 
Vwndia64IsFixupIp(UINT iContext, ULONGLONG Ip);

UINT 
Vwndia64NewContext();

BOOL
Vwndia64ValidateContext(UINT* iContextPtr);

void
Vwndia64ReportFailure(UINT iContext, LPCSTR szFormat, ...);

ULONGLONG
VirtualUnwindIa64 (
    HANDLE hProcess,
    ULONGLONG ImageBase,
    DWORD64 ControlPc,
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    PIA64_CONTEXT ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    UINT iContext
    );

BOOL
GetStackFrameIa64(
    IN     HANDLE                            hProcess,
    IN OUT PULONG64                          ReturnAddress,
    IN OUT PULONG64                          FramePointer,
    IN OUT PULONG64                          BStorePointer,
    IN     PIA64_CONTEXT                     Context,        // Context members could be modified.
    IN     PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    IN     PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    IN     PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    IN     UINT                              iContext
    )
{
    ULONGLONG                          ImageBase;
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY rf;
    ULONG64                            dwRa = (ULONG64)Context->BrRp;
    BOOL                               rval = TRUE;

    rf = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY) FunctionTableAccess( hProcess, *ReturnAddress );

    if (rf) {
        //
        // The Rp value coming out of mainCRTStartup is set by some run-time
        // routine to be 0; this serves to cause an error if someone actually
        // does a return from the mainCRTStartup frame.
        //

        ImageBase = GetModuleBase(hProcess, *ReturnAddress);
        dwRa = (ULONG64)VirtualUnwindIa64( hProcess, ImageBase, 
                                           *ReturnAddress, rf, Context, 
                                           ReadMemory, iContext);
        if (!dwRa) {
            rval = FALSE;
        }

        if ((dwRa == *ReturnAddress) &&
// TF-CHKCHK 10/20/99: (*FramePointer == Context->IntSp) &&
               (*BStorePointer == Context->RsBSP)) {
            rval = FALSE;
        }

        *ReturnAddress = dwRa;
        *FramePointer  = Context->IntSp;
        *BStorePointer = Context->RsBSP;

    } else {

        SHORT BsFrameSize;
        SHORT TempFrameSize;

        if (dwRa == *ReturnAddress)
        {
            if (dwRa) 
            {
                Vwndia64ReportFailure(iContext, 
                                     "Can't find runtime function entry info "
                                        "for %08x`%08x, "
                                        "results might be unreliable!\n",
                                     (ULONG)(*ReturnAddress >> 32), 
                                     (ULONG)(*ReturnAddress));
            }
     
            if ((*FramePointer  == Context->IntSp) &&
               (*BStorePointer == Context->RsBSP)) 
            {
                rval = FALSE;
            }
        }

        *ReturnAddress = Context->BrRp;
        *FramePointer  = Context->IntSp;
        *BStorePointer = Context->RsBSP;
        Context->StIFS = Context->RsPFS;
        BsFrameSize = (SHORT)(Context->StIFS >> IA64_PFS_SIZE_SHIFT) & IA64_PFS_SIZE_MASK;
        TempFrameSize = BsFrameSize - (SHORT)((Context->RsBSP >> 3) & IA64_NAT_BITS_PER_RNAT_REG);
        while (TempFrameSize > 0) {
            BsFrameSize++;
            TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
        }
        Context->RsBSPSTORE = ( Context->RsBSP -= (BsFrameSize * sizeof(ULONGLONG)) );
    }

    //
    // The next code intend to fix stack unwind for __declspec(noreturn) 
    // function calls (like KeBugCheck) where the return address points to 
    // another (next) function. So changing the ReturnAddress to point to 
    // calling instruction.
    //
    if (!Vwndia64IsFixupIp(iContext, *ReturnAddress))
    { 
        ULONG64 CallerAddress  = (*ReturnAddress) - 0x10;
        PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY rfFix = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)
            FunctionTableAccess(hProcess, CallerAddress);

        if (rfFix) {
            IMAGE_IA64_RUNTIME_FUNCTION_ENTRY rfFixVal = *rfFix;
            rf = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)
                FunctionTableAccess(hProcess, *ReturnAddress);
            if (
                !(
                    rf && 
                    (rfFixVal.BeginAddress == rf->BeginAddress) &&
                    (rfFixVal.EndAddress == rf->EndAddress) &&
                    (rfFixVal.UnwindInfoAddress == rf->UnwindInfoAddress)
                )
            ){
                *ReturnAddress = CallerAddress;
            } 
        } 
    } 

    return rval;
}

BOOL
ReadFunctionArgumentsFromContext( 
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    HANDLE        hProcess, 
    PIA64_CONTEXT pContext, 
    DWORD64       Params[]   // WARNING - no runtime size check. 4 entries are assumed...
    )
{
    BOOL        result;
    ULONG       index;
    DWORD       cb;
    ULONGLONG   rsBSP;
   
//  ASSERT( ReadMemory );
//  ASSERT( hProcess && (hProcess != INVALID_HANDLE_VALUE) );
    if ( !pContext || !Params  )    {
       return FALSE;
    }

//
// IA64 Notes [for the curious reader...]:
//
//   The register backing store is organized as a stack in memory that grows 
//   from lower to higher addresses.
//   The Backing Store Pointer (BSP) register contains the address of the first
//   (lowest) memory location reserved for the current frame. This corresponds
//   to the location at which the GR32 register of the current frame will be spilled.
//   The BSPSTORE register contains the address at which the new RSE spill will 
//   occur.
//   The BSP load pointer - address register which corresponds to the next RSE
//   fill operation - is not architectually visible.
//
//   The RSE spills/fills the NaT bits corresponding to the stacked registers. 
//   The NaT bits for the stacked registers are spilled/filled in groups of 63
//   corresponding to 63 consecutive physical stacked registers. When the RSE spills
//   a register to the backing store, the corresponding NaT bit is copied to the RNAT
//   register (RSE NaT collection register).
//   When BSPSTORE[8:3] bits are all one, RSE stores RNAT to the backing store. Meaning
//   that every 63 register values stored to the backing store are followed by a stored
//   RNAT. Note RNAT[63] bit is always written as zero.
//   
//   This explains the following code:
//

    // 
    // Check for spilled NaT collection register mixed w/ arguments.
    //
    rsBSP = pContext->RsBSP;
    index = (ULONG)(rsBSP & 0x1F8) >> 3; 
    if (index > 59) {

        DWORD i, j;
        DWORD64 localParams[5];

        //
        // Read in memory, 4 arguments + 1 NaT collection register.
        // 
        result = ReadMemory ( hProcess, rsBSP, localParams, sizeof(localParams), &cb );
        if (result) {
            j = 0;
            for (i = 0; i < SIZEOF_ARRAY(localParams) ; i++, index++) {
                if (index != 63) {
                    Params[j++] = localParams[i];
                }
            }
        }

    } else {

        //
        // We do not have the NaT collection register mixed w/ function arguments.
        // Read the 4 arguments from backing store memory.
        //
        result = ReadMemory ( hProcess, rsBSP, Params, 4 * sizeof(Params[0]), &cb );
    }

    return( result );

} // ReadFunctionArgumentsFromContext()


#define WALKI64_CONTEXT_INDEX(sf) ((sf).Reserved[2])

BOOL
WalkIa64Init(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    IA64_KSWITCH_FRAME SwitchFrame;
    IA64_CONTEXT       ContextSave;
    DWORD64           PcOffset;
    DWORD64           StackOffset;
    DWORD64           FrameOffset;
    DWORD             cb;
    BOOL              result;


    UINT iContext = (UINT)
        (WALKI64_CONTEXT_INDEX(*StackFrame) = Vwndia64NewContext());

    ZeroMemory( StackFrame, FIELD_OFFSET( STACKFRAME64, KdHelp ) );
// TF-XXXXXX:   ZeroMemory( StackFrame, sizeof(*StackFrame) );

    StackFrame->Virtual = TRUE;

    if (!StackFrame->AddrPC.Offset) 
    {
        StackFrame->AddrPC.Offset = Ia64InsertIPSlotNumber(
                                        (Context->StIIP & ~(ULONGLONG)0xf), 
                                        ((Context->StIPSR >> PSR_RI) & 0x3));
        StackFrame->AddrPC.Mode   = AddrModeFlat;
    }

    if (!StackFrame->AddrStack.Offset)
    {
        StackFrame->AddrStack.Offset = Context->IntSp;
        StackFrame->AddrStack.Mode   = AddrModeFlat;
    }

    if (!StackFrame->AddrFrame.Offset)
    {
        if (StackFrame->AddrBStore.Offset)
        {
            StackFrame->AddrFrame = StackFrame->AddrBStore;
        }
        else 
        {
            StackFrame->AddrFrame.Offset = Context->RsBSP;
            StackFrame->AddrFrame.Mode   = AddrModeFlat;
        } 
    }
    StackFrame->AddrBStore = StackFrame->AddrFrame;

    if ((StackFrame->AddrPC.Mode != AddrModeFlat) ||
        (StackFrame->AddrStack.Mode != AddrModeFlat) ||
        (StackFrame->AddrFrame.Mode != AddrModeFlat) ||
        (StackFrame->AddrBStore.Mode != AddrModeFlat))
    {
        return FALSE;
    }

    WALKI64_CONTEXT_INDEX(*StackFrame) = iContext;

    ContextSave = *Context;
    PcOffset    = StackFrame->AddrPC.Offset;
    StackOffset = StackFrame->AddrStack.Offset;
    FrameOffset = StackFrame->AddrFrame.Offset;

    if (!GetStackFrameIa64( hProcess,
                        &PcOffset,
                        &StackOffset,
                        &FrameOffset,
                        &ContextSave,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase,
                        iContext) ) 
    {

        StackFrame->AddrReturn.Offset = Context->BrRp;

    } else {

        StackFrame->AddrReturn.Offset = PcOffset;
    }

    StackFrame->AddrReturn.Mode     = AddrModeFlat;

    result = ReadFunctionArgumentsFromContext( ReadMemory, 
                                               hProcess, 
                                               Context, 
                                               StackFrame->Params 
                                             );
    if ( !result ) {
        StackFrame->Params[0] =
        StackFrame->Params[1] =
        StackFrame->Params[2] =
        StackFrame->Params[3] = 0;
    }

    return TRUE;
}


BOOL
WalkIa64Next(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    DWORD           cb;
    IA64_CONTEXT    ContextSave;
    BOOL            rval = TRUE;
    BOOL            result;
    DWORD64         StackAddress;
    DWORD64         BStoreAddress;
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY rf;
    DWORD64         fp  = (DWORD64)0;
    DWORD64         bsp = (DWORD64)0;

    UINT iContext = (UINT)WALKI64_CONTEXT_INDEX(*StackFrame);
    if (!Vwndia64ValidateContext(&iContext)) 
    {
        WALKI64_CONTEXT_INDEX(*StackFrame) = iContext;
    }

    if (!GetStackFrameIa64( hProcess,
                        &StackFrame->AddrPC.Offset,
                        &StackFrame->AddrStack.Offset,
                        &StackFrame->AddrFrame.Offset,
                        Context,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase,
                        iContext) ) 
    {

        rval = FALSE;

        //
        // If the frame could not be unwound or is terminal, see if
        // there is a callback frame:
        //

        if (g.AppVersion.Revision >= 4 && CALLBACK_STACK(StackFrame)) {
            DWORD64 imageBase;

            if (CALLBACK_STACK(StackFrame) & 0x80000000) {

                //
                // it is the pointer to the stack frame that we want
                //

                StackAddress = CALLBACK_STACK(StackFrame);

            } else {

                //
                // if it is a positive integer, it is the offset to
                // the address in the thread.
                // Look up the pointer:
                //

                rval = ReadMemory(hProcess,
                                  (CALLBACK_THREAD(StackFrame) +
                                                 CALLBACK_STACK(StackFrame)),
                                  &StackAddress,
                                  sizeof(DWORD64),
                                  &cb);

                if (!rval || StackAddress == 0) {
                    StackAddress = (DWORD64)-1;
                    CALLBACK_STACK(StackFrame) = (DWORD)-1;
                }

            }

            if ( (StackAddress == (DWORD64)-1) ||
                ( !(rf = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)
                     FunctionTableAccess(hProcess, CALLBACK_FUNC(StackFrame))) || !( imageBase = GetModuleBase(hProcess, CALLBACK_FUNC(StackFrame)) ) ) ) {

                rval = FALSE;

            } else {

                ReadMemory(hProcess,
                           (StackAddress + CALLBACK_NEXT(StackFrame)),
                           &CALLBACK_STACK(StackFrame),
                           sizeof(DWORD64),
                           &cb);

                StackFrame->AddrPC.Offset = imageBase + rf->BeginAddress; 
                StackFrame->AddrStack.Offset = StackAddress;
                Context->IntSp = StackAddress;

                rval = TRUE;
            }

        }
    }

    StackFrame->AddrBStore = StackFrame->AddrFrame;

    //
    // get the return address
    //
    ContextSave = *Context;
    StackFrame->AddrReturn.Offset = StackFrame->AddrPC.Offset;

    if (!GetStackFrameIa64( hProcess,
                        &StackFrame->AddrReturn.Offset,
                        &fp,
                        &bsp,
                        &ContextSave,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase, iContext) ) 
    {

// rval = FALSE;
        StackFrame->AddrReturn.Offset = 0;

    }

    result = ReadFunctionArgumentsFromContext( ReadMemory, 
                                               hProcess, 
                                               Context, 
                                               StackFrame->Params 
                                             );
    if ( !result ) {
        StackFrame->Params[0] =
        StackFrame->Params[1] =
        StackFrame->Params[2] =
        StackFrame->Params[3] = 0;
    }

    return rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\walkamd64.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    walkamd64.c

Abstract:

    This file implements the AMD64 stack walking api.

Author:

Environment:

    User Mode

--*/

#define _IMAGEHLP_SOURCE_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "symbols.h"
#include <stdlib.h>
#include <globals.h>

#if 1
#define WDB(Args) dbPrint Args
#else
#define WDB(Args)
#endif

//
// Lookup table providing the number of slots used by each unwind code.
// 

UCHAR RtlpUnwindOpSlotTableAmd64[] = {
    1,          // UWOP_PUSH_NONVOL
    2,          // UWOP_ALLOC_LARGE (or 3, special cased in lookup code)
    1,          // UWOP_ALLOC_SMALL
    1,          // UWOP_SET_FPREG
    2,          // UWOP_SAVE_NONVOL
    3,          // UWOP_SAVE_NONVOL_FAR
    2,          // UWOP_SAVE_XMM
    3,          // UWOP_SAVE_XMM_FAR
    2,          // UWOP_SAVE_XMM128
    3,          // UWOP_SAVE_XMM128_FAR
    1           // UWOP_PUSH_MACHFRAME
};

BOOL
WalkAmd64Init(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PAMD64_CONTEXT                    Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
WalkAmd64Next(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PAMD64_CONTEXT                    Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
UnwindStackFrameAmd64(
    HANDLE                            Process,
    PULONG64                          ReturnAddress,
    PULONG64                          StackPointer,
    PULONG64                          FramePointer,
    PAMD64_CONTEXT                    Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );


PAMD64_UNWIND_INFO
ReadUnwindInfoAmd64(ULONG64 Offset, BOOL ReadCodes, HANDLE Process,
                    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
                    PVOID StaticBuffer, ULONG StaticBufferSize)
{
    ULONG Done;
    ULONG UnwindInfoSize;
    PAMD64_UNWIND_INFO UnwindInfo;

    // Static buffer should at least be large enough to read the
    // basic structure.
    if (StaticBufferSize < sizeof(*UnwindInfo)) {
        return NULL;
    }
    UnwindInfo = (PAMD64_UNWIND_INFO)StaticBuffer;

    // First read just the basic structure since the information
    // is needed to compute the complete size.
    if (!ReadMemory(Process, Offset, UnwindInfo, sizeof(*UnwindInfo), &Done) ||
        Done != sizeof(*UnwindInfo)) {
        WDB(("Unable to read unwind info at %I64X\n", Offset));
        return FALSE;
    }

    if (!ReadCodes) {
        return UnwindInfo;
    }

    // Compute the size of all the data.
    UnwindInfoSize = sizeof(*UnwindInfo) +
        (UnwindInfo->CountOfCodes - 1) * sizeof(AMD64_UNWIND_CODE);
    // An extra alignment code and pointer may be added on to handle
    // the chained info case where the chain pointer is just
    // beyond the end of the normal code array.
    if ((UnwindInfo->Flags & AMD64_UNW_FLAG_CHAININFO) != 0) {
        if ((UnwindInfo->CountOfCodes & 1) != 0) {
            UnwindInfoSize += sizeof(AMD64_UNWIND_CODE);
        }
        UnwindInfoSize += sizeof(ULONG64);
    }
    if (UnwindInfoSize > StaticBufferSize) {
        if (UnwindInfoSize > 0xffff) {
            // Too large to be valid data, assume it's garbage.
            WDB(("Invalid unwind info at %I64X\n", Offset));
            return NULL;
        }
        UnwindInfo = (PAMD64_UNWIND_INFO)MemAlloc(UnwindInfoSize);
        if (UnwindInfo == NULL) {
            return NULL;
        }
    }

    // Now read all the data.
    if (!ReadMemory(Process, Offset, UnwindInfo, UnwindInfoSize, &Done) ||
        Done != UnwindInfoSize) {
        if ((PVOID)UnwindInfo != StaticBuffer) {
            MemFree(UnwindInfo);
        }

        WDB(("Unable to read unwind info at %I64X\n", Offset));
        return NULL;
    }

    return UnwindInfo;
}

//
// ****** temp - defin elsewhere ******
//

#define SIZE64_PREFIX 0x48
#define ADD_IMM8_OP 0x83
#define ADD_IMM32_OP 0x81
#define LEA_OP 0x8d
#define POP_OP 0x58
#define RET_OP 0xc3

BOOLEAN
RtlpUnwindPrologueAmd64 (
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc,
    IN ULONG64 FrameBase,
    IN _PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    IN OUT PAMD64_CONTEXT ContextRecord,
    IN HANDLE Process,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
    )

/*++

Routine Description:

    This function processes unwind codes and reverses the state change
    effects of a prologue. If the specified unwind information contains
    chained unwind information, then that prologue is unwound recursively.
    As the prologue is unwound state changes are recorded in the specified
    context structure and optionally in the specified context pointers
    structures.

Arguments:

    ImageBase - Supplies the base address of the image that contains the
        function being unwound.

    ControlPc - Supplies the address where control left the specified
        function.

    FrameBase - Supplies the base of the stack frame subject function stack
         frame.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

--*/

{

    ULONG64 FloatingAddress;
    PAMD64_M128 FloatingRegister;
    ULONG FrameOffset;
    ULONG Index;
    ULONG64 IntegerAddress;
    PULONG64 IntegerRegister;
    BOOLEAN MachineFrame;
    ULONG OpInfo;
    ULONG PrologOffset;
    PULONG64 RegisterAddress;
    ULONG64 ReturnAddress;
    ULONG64 StackAddress;
    PAMD64_UNWIND_CODE UnwindCode;
    ULONG64 UnwindInfoBuffer[32];
    PAMD64_UNWIND_INFO UnwindInfo;
    ULONG Done;
    ULONG UnwindOp;

    //
    // Process the unwind codes.
    //

    FloatingRegister = &ContextRecord->Xmm0;
    IntegerRegister = &ContextRecord->Rax;
    Index = 0;
    MachineFrame = FALSE;
    PrologOffset = (ULONG)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));

    WDB(("Prol: RIP %I64X, 0x%X bytes in function at %I64X\n",
         ControlPc, PrologOffset, FunctionEntry->BeginAddress + ImageBase));
    WDB(("Prol: Read unwind info at %I64X\n",
         PrologOffset, FunctionEntry->UnwindInfoAddress + ImageBase));

    UnwindInfo =
        ReadUnwindInfoAmd64(FunctionEntry->UnwindInfoAddress + ImageBase,
                            TRUE, Process, ReadMemory, UnwindInfoBuffer,
                            sizeof(UnwindInfoBuffer));
    if (UnwindInfo == NULL) {
        WDB(("Prol: Unable to read unwind info\n"));
        return FALSE;
    }

    WDB(("  Unwind info has 0x%X codes\n", UnwindInfo->CountOfCodes));
    
    while (Index < UnwindInfo->CountOfCodes) {

        WDB(("  %02X: Code %X offs %03X, RSP %I64X\n",
             Index, UnwindInfo->UnwindCode[Index].UnwindOp,
             UnwindInfo->UnwindCode[Index].CodeOffset,
             ContextRecord->Rsp));
        
        //
        // If the prologue offset is greater than the next unwind code offset,
        // then simulate the effect of the unwind code.
        //

        UnwindOp = UnwindInfo->UnwindCode[Index].UnwindOp;
        OpInfo = UnwindInfo->UnwindCode[Index].OpInfo;
        if (PrologOffset >= UnwindInfo->UnwindCode[Index].CodeOffset) {
            switch (UnwindOp) {

                //
                // Push nonvolatile integer register.
                //
                // The operation information is the register number of the
                // register than was pushed.
                //

            case AMD64_UWOP_PUSH_NONVOL:
                IntegerAddress = ContextRecord->Rsp;
                if (!ReadMemory(Process, IntegerAddress,
                                &IntegerRegister[OpInfo], sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }

                ContextRecord->Rsp += 8;
                break;

                //
                // Allocate a large sized area on the stack.
                //
                // The operation information determines if the size is
                // 16- or 32-bits.
                //

            case AMD64_UWOP_ALLOC_LARGE:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset;
                if (OpInfo != 0) {
                    Index += 1;
                    FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                } else {
                    // The 16-bit form is scaled.
                    FrameOffset *= 8;
                }

                ContextRecord->Rsp += FrameOffset;
                break;

                //
                // Allocate a small sized area on the stack.
                //
                // The operation information is the size of the unscaled
                // allocation size (8 is the scale factor) minus 8.
                //

            case AMD64_UWOP_ALLOC_SMALL:
                ContextRecord->Rsp += (OpInfo * 8) + 8;
                break;

                //
                // Establish the the frame pointer register.
                //
                // The operation information is not used.
                //

            case AMD64_UWOP_SET_FPREG:
                ContextRecord->Rsp = IntegerRegister[UnwindInfo->FrameRegister];
                ContextRecord->Rsp -= UnwindInfo->FrameOffset * 16;
                break;

                //
                // Save nonvolatile integer register on the stack using a
                // 16-bit displacment.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_NONVOL:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 8;
                IntegerAddress = FrameBase + FrameOffset;
                if (!ReadMemory(Process, IntegerAddress,
                                &IntegerRegister[OpInfo], sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                break;

                //
                // Save nonvolatile integer register on the stack using a
                // 32-bit displacment.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_NONVOL_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                IntegerAddress = FrameBase + FrameOffset;
                if (!ReadMemory(Process, IntegerAddress,
                                &IntegerRegister[OpInfo], sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                break;

                //
                // Save a nonvolatile XMM(64) register on the stack using a
                // 16-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 8;
                FloatingAddress = FrameBase + FrameOffset;
                FloatingRegister[OpInfo].High = 0;
                if (!ReadMemory(Process, FloatingAddress,
                                &FloatingRegister[OpInfo].Low, sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                break;

                //
                // Save a nonvolatile XMM(64) register on the stack using a
                // 32-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                FloatingAddress = FrameBase + FrameOffset;
                FloatingRegister[OpInfo].High = 0;
                if (!ReadMemory(Process, FloatingAddress,
                                &FloatingRegister[OpInfo].Low, sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                break;

                //
                // Save a nonvolatile XMM(128) register on the stack using a
                // 16-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM128:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 16;
                FloatingAddress = FrameBase + FrameOffset;
                if (!ReadMemory(Process, FloatingAddress,
                                &FloatingRegister[OpInfo], sizeof(AMD64_M128),
                                &Done) ||
                    Done != sizeof(AMD64_M128)) {
                    goto Fail;
                }
                break;

                //
                // Save a nonvolatile XMM(128) register on the stack using a
                // 32-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM128_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                FloatingAddress = FrameBase + FrameOffset;
                if (!ReadMemory(Process, FloatingAddress,
                                &FloatingRegister[OpInfo], sizeof(AMD64_M128),
                                &Done) ||
                    Done != sizeof(AMD64_M128)) {
                    goto Fail;
                }
                break;

                //
                // Push a machine frame on the stack.
                //
                // The operation information determines whether the machine
                // frame contains an error code or not.
                //

            case AMD64_UWOP_PUSH_MACHFRAME:
                MachineFrame = TRUE;
                ReturnAddress = ContextRecord->Rsp;
                StackAddress = ContextRecord->Rsp + (3 * 8);
                if (OpInfo != 0) {
                    ReturnAddress += 8;
                    StackAddress +=  8;
                }

                if (!ReadMemory(Process, ReturnAddress,
                                &ContextRecord->Rip, sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                if (!ReadMemory(Process, StackAddress,
                                &ContextRecord->Rsp, sizeof(ULONG64),
                                &Done) ||
                    Done != sizeof(ULONG64)) {
                    goto Fail;
                }
                break;

                //
                // Unused codes.
                //

            default:
                break;
            }

            Index += 1;
        
        } else {

            //
            // Skip this unwind operation by advancing the slot index by the
            // number of slots consumed by this operation.
            //

            Index += RtlpUnwindOpSlotTableAmd64[UnwindOp];

            //
            // Special case any unwind operations that can consume a variable
            // number of slots.
            // 

            switch (UnwindOp) {

                //
                // A non-zero operation information indicates that an
                // additional slot is consumed.
                //

            case AMD64_UWOP_ALLOC_LARGE:
                if (OpInfo != 0) {
                    Index += 1;
                }

                break;

                //
                // No other special cases.
                //

            default:
                break;
            }
        }
    }

    //
    // If chained unwind information is specified, then recursively unwind
    // the chained information. Otherwise, determine the return address if
    // a machine frame was not encountered during the scan of the unwind
    // codes.
    //

    if ((UnwindInfo->Flags & AMD64_UNW_FLAG_CHAININFO) != 0) {
        Index = UnwindInfo->CountOfCodes;
        if ((Index & 1) != 0) {
            Index += 1;
        }

        ULONG64 ChainEntryAddr =
            *(PULONG64)(&UnwindInfo->UnwindCode[Index]) + ImageBase;

        if (UnwindInfo != (PAMD64_UNWIND_INFO)UnwindInfoBuffer) {
            MemFree(UnwindInfo);
        }

        _IMAGE_RUNTIME_FUNCTION_ENTRY ChainEntry;

        WDB(("  Chain to entry at %I64X\n", ChainEntryAddr));
        
        if (!ReadMemory(Process, ChainEntryAddr,
                        &ChainEntry, sizeof(ChainEntry), &Done) ||
            Done != sizeof(ChainEntry)) {
            WDB(("  Unable to read entry\n"));
            return FALSE;
        }

        return RtlpUnwindPrologueAmd64(ImageBase,
                                       ControlPc,
                                       FrameBase,
                                       &ChainEntry,
                                       ContextRecord,
                                       Process,
                                       ReadMemory);

    } else {
        if (UnwindInfo != (PAMD64_UNWIND_INFO)UnwindInfoBuffer) {
            MemFree(UnwindInfo);
        }

        if (MachineFrame == FALSE) {
            if (!ReadMemory(Process, ContextRecord->Rsp,
                            &ContextRecord->Rip, sizeof(ULONG64),
                            &Done) ||
                Done != sizeof(ULONG64)) {
                return FALSE;
            }
            ContextRecord->Rsp += 8;
        }

        WDB(("Prol: Returning with RIP %I64X, RSP %I64X\n",
             ContextRecord->Rip, ContextRecord->Rsp));
        return TRUE;
    }

 Fail:
    if (UnwindInfo != (PAMD64_UNWIND_INFO)UnwindInfoBuffer) {
        MemFree(UnwindInfo);
    }
    WDB(("Prol: Unwind failed\n"));
    return FALSE;
}

BOOLEAN
RtlVirtualUnwindAmd64 (
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc,
    IN _PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    IN OUT PAMD64_CONTEXT ContextRecord,
    OUT PULONG64 EstablisherFrame,
    IN HANDLE Process,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
    )

/*++

Routine Description:

    This function virtually unwinds the specified function by executing its
    prologue code backward or its epilogue code forward.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

Arguments:

    ImageBase - Supplies the base address of the image that contains the
        function being unwound.

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    EstablisherFrame - Supplies a pointer to a variable that receives the
        the establisher frame pointer value.

--*/

{

    LONG Displacement;
    ULONG FrameRegister;
    ULONG Index;
    PULONG64 IntegerRegister;
    PUCHAR NextByte;
    ULONG PrologOffset;
    ULONG RegisterNumber;
    PAMD64_UNWIND_INFO UnwindInfo;
    ULONG64 UnwindInfoBuffer[8];
    ULONG Done;
    UCHAR InstrBuffer[32];
    ULONG InstrBytes;
    ULONG Bytes;
    ULONG UnwindFrameReg;

    //
    // If the specified function does not use a frame pointer, then the
    // establisher frame is the contents of the stack pointer. This may
    // not actually be the real establisher frame if control left the
    // function from within the prologue. In this case the establisher
    // frame may be not required since control has not actually entered
    // the function and prologue entries cannot refer to the establisher
    // frame before it has been established, i.e., if it has not been
    // established, then no save unwind codes should be encountered during
    // the unwind operation.
    //
    // If the specified function uses a frame pointer and control left the
    // function outside of the prologue or the unwind information contains
    // a chained information structure, then the establisher frame is the
    // contents of the frame pointer.
    //
    // If the specified function uses a frame pointer and control left the
    // function from within the prologue, then the set frame pointer unwind
    // code must be looked up in the unwind codes to detetermine if the
    // contents of the stack pointer or the contents of the frame pointer
    // should be used for the establisher frame. This may not atually be
    // the real establisher frame. In this case the establisher frame may
    // not be required since control has not actually entered the function
    // and prologue entries cannot refer to the establisher frame before it
    // has been established, i.e., if it has not been established, then no
    // save unwind codes should be encountered during the unwind operation.
    //
    // N.B. The correctness of these assumptions is based on the ordering of
    //      unwind codes.
    //

    UnwindInfo =
        ReadUnwindInfoAmd64(FunctionEntry->UnwindInfoAddress + ImageBase,
                            FALSE, Process, ReadMemory, UnwindInfoBuffer,
                            sizeof(UnwindInfoBuffer));
    if (UnwindInfo == NULL) {
        return FALSE;
    }

    PrologOffset = (ULONG)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));
    UnwindFrameReg = UnwindInfo->FrameRegister;
    if (UnwindFrameReg == 0) {
        *EstablisherFrame = ContextRecord->Rsp;

    } else if ((PrologOffset >= UnwindInfo->SizeOfProlog) ||
               ((UnwindInfo->Flags & AMD64_UNW_FLAG_CHAININFO) != 0)) {
        *EstablisherFrame = (&ContextRecord->Rax)[UnwindFrameReg];
        *EstablisherFrame -= UnwindInfo->FrameOffset * 16;

    } else {

        // Read all the data.
        UnwindInfo = ReadUnwindInfoAmd64(FunctionEntry->UnwindInfoAddress +
                                         ImageBase, TRUE, Process, ReadMemory,
                                         UnwindInfoBuffer,
                                         sizeof(UnwindInfoBuffer));
        if (UnwindInfo == NULL) {
            return FALSE;
        }

        Index = 0;
        while (Index < UnwindInfo->CountOfCodes) {
            if (UnwindInfo->UnwindCode[Index].UnwindOp == AMD64_UWOP_SET_FPREG) {
                break;
            }

            Index += 1;
        }

        if (PrologOffset >= UnwindInfo->UnwindCode[Index].CodeOffset) {
            *EstablisherFrame = (&ContextRecord->Rax)[UnwindFrameReg];
            *EstablisherFrame -= UnwindInfo->FrameOffset * 16;

        } else {
            *EstablisherFrame = ContextRecord->Rsp;
        }

        if (UnwindInfo != (PAMD64_UNWIND_INFO)UnwindInfoBuffer) {
            MemFree(UnwindInfo);
        }
    }

    if (!ReadMemory(Process, ControlPc, InstrBuffer, sizeof(InstrBuffer),
                    &InstrBytes)) {
        WDB(("Unable to read instruction stream at %I64X\n", ControlPc));
        return FALSE;
    }

    //
    // Check for epilogue.
    //
    // If the point at which control left the specified function is in an
    // epilogue, then emulate the execution of the epilogue forward and
    // return no exception handler.
    //

    IntegerRegister = &ContextRecord->Rax;
    NextByte = InstrBuffer;
    Bytes = InstrBytes;

    //
    // Check for one of:
    //
    //   add rsp, imm8
    //       or
    //   add rsp, imm32
    //       or
    //   lea rsp, -disp8[fp]
    //       or
    //   lea rsp, -disp32[fp]
    //

    if (Bytes >= 4 &&
        (NextByte[0] == SIZE64_PREFIX) &&
        (NextByte[1] == ADD_IMM8_OP) &&
        (NextByte[2] == 0xc4)) {

        //
        // add rsp, imm8.
        //

        NextByte += 4;
        Bytes -= 4;

    } else if (Bytes >= 7 &&
               (NextByte[0] == SIZE64_PREFIX) &&
               (NextByte[1] == ADD_IMM32_OP) &&
               (NextByte[2] == 0xc4)) {

        //
        // add rsp, imm32.
        //

        NextByte += 7;
        Bytes -= 7;

    } else if (Bytes >= 4 &&
               ((NextByte[0] & 0xf8) == SIZE64_PREFIX) &&
               (NextByte[1] == LEA_OP)) {

        FrameRegister = ((NextByte[0] & 0x7) << 3) | (NextByte[2] & 0x7);
        if ((FrameRegister != 0) &&
            (FrameRegister == UnwindFrameReg)) {
            if ((NextByte[2] & 0xf8) == 0x60) {

                //
                // lea rsp, disp8[fp].
                //

                NextByte += 4;
                Bytes -= 4;

            } else if (Bytes >= 7 &&
                       (NextByte[2] &0xf8) == 0xa0) {

                //
                // lea rsp, disp32[fp].
                //

                NextByte += 7;
                Bytes -= 7;
            }
        }
    }

    //
    // Check for any number of:
    //
    //   pop nonvolatile-integer-register[0..15].
    //

    while (TRUE) {
        if (Bytes >= 1 &&
            (NextByte[0] & 0xf8) == POP_OP) {
            NextByte += 1;
            Bytes -= 1;

        } else if (Bytes >= 2 &&
                   ((NextByte[0] & 0xf8) == SIZE64_PREFIX) &&
                   ((NextByte[1] & 0xf8) == POP_OP)) {

            NextByte += 2;
            Bytes -= 2;

        } else {
            break;
        }
    }

    //
    // If the next instruction is a return, then control is currently in
    // an epilogue and execution of the epilogue should be emulated.
    // Otherwise, execution is not in an epilogue and the prologue should
    // be unwound.
    //

    if (Bytes >= 1 &&
        NextByte[0] == RET_OP) {
        NextByte = InstrBuffer;
        Bytes = InstrBytes;

        //
        // Emulate one of (if any):
        //
        //   add rsp, imm8
        //       or
        //   add rsp, imm32
        //       or
        //   lea rsp, disp8[frame-register]
        //       or
        //   lea rsp, disp32[frame-register]
        //

        if (Bytes >= 4 &&
            NextByte[1] == ADD_IMM8_OP) {

            //
            // add rsp, imm8.
            //

            ContextRecord->Rsp += (CHAR)NextByte[3];
            NextByte += 4;
            Bytes -= 4;

        } else if (Bytes >= 7 &&
                   NextByte[1] == ADD_IMM32_OP) {

            //
            // add rsp, imm32.
            //

            Displacement = NextByte[3] | (NextByte[4] << 8);
            Displacement |= (NextByte[5] << 16) | (NextByte[6] << 24);
            ContextRecord->Rsp += Displacement;
            NextByte += 7;
            Bytes -= 7;

        } else if (Bytes >= 4 &&
                   NextByte[1] == LEA_OP) {
            if ((NextByte[2] & 0xf8) == 0x60) {

                //
                // lea rsp, disp8[frame-register].
                //

                ContextRecord->Rsp = IntegerRegister[FrameRegister];
                ContextRecord->Rsp += (CHAR)NextByte[3];
                NextByte += 4;
                Bytes -= 4;

            } else if (Bytes >= 7 &&
                       (NextByte[2] & 0xf8) == 0xa0) {

                //
                // lea rsp, disp32[frame-register].
                //

                Displacement = NextByte[3] | (NextByte[4] << 8);
                Displacement |= (NextByte[5] << 16) | (NextByte[6] << 24);
                ContextRecord->Rsp = IntegerRegister[FrameRegister];
                ContextRecord->Rsp += Displacement;
                NextByte += 7;
                Bytes -= 7;
            }
        }

        //
        // Emulate any number of (if any):
        //
        //   pop nonvolatile-integer-register.
        //

        while (TRUE) {
            if (Bytes >= 1 &&
                (NextByte[0] & 0xf8) == POP_OP) {

                //
                // pop nonvolatile-integer-register[0..7]
                //

                RegisterNumber = NextByte[0] & 0x7;
                if (!ReadMemory(Process, ContextRecord->Rsp,
                                &IntegerRegister[RegisterNumber],
                                sizeof(ULONG64), &Done) ||
                    Done != sizeof(ULONG64)) {
                    WDB(("Unable to read stack at %I64X\n",
                         ContextRecord->Rsp));
                    return FALSE;
                }
                ContextRecord->Rsp += 8;
                NextByte += 1;
                Bytes -= 1;

            } else if (Bytes >= 2 &&
                       (NextByte[0] & 0xf8) == SIZE64_PREFIX &&
                       (NextByte[1] & 0xf8) == POP_OP) {

                //
                // pop nonvolatile-integer-register[8..15]
                //

                RegisterNumber = ((NextByte[0] & 1) << 3) | (NextByte[1] & 0x7);
                if (!ReadMemory(Process, ContextRecord->Rsp,
                                &IntegerRegister[RegisterNumber],
                                sizeof(ULONG64), &Done) ||
                    Done != sizeof(ULONG64)) {
                    WDB(("Unable to read stack at %I64X\n",
                         ContextRecord->Rsp));
                    return FALSE;
                }
                ContextRecord->Rsp += 8;
                NextByte += 2;
                Bytes -= 2;

            } else {
                break;
            }
        }

        //
        // Emulate return and return null exception handler.
        //

        if (!ReadMemory(Process, ContextRecord->Rsp,
                        &ContextRecord->Rip, sizeof(ULONG64),
                        &Done) ||
            Done != sizeof(ULONG64)) {
            WDB(("Unable to read stack at %I64X\n",
                 ContextRecord->Rsp));
            return FALSE;
        }
        ContextRecord->Rsp += 8;
        return TRUE;
    }

    //
    // Control left the specified function outside an epilogue. Unwind the
    // subject function and any chained unwind information.
    //

    return RtlpUnwindPrologueAmd64(ImageBase,
                                   ControlPc,
                                   *EstablisherFrame,
                                   FunctionEntry,
                                   ContextRecord,
                                   Process,
                                   ReadMemory);
}



BOOL
WalkAmd64(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    BOOL rval;
    PAMD64_CONTEXT Context = (PAMD64_CONTEXT)ContextRecord;

#if 1
    WDB(("WalkAmd64  in: PC %I64X, SP %I64X, FP %I64X, RA %I64X\n",
         StackFrame->AddrPC.Offset,
         StackFrame->AddrStack.Offset,
         StackFrame->AddrFrame.Offset,
         StackFrame->AddrReturn.Offset));
#endif

    if (StackFrame->Virtual) {

        rval = WalkAmd64Next( Process,
                              StackFrame,
                              Context,
                              ReadMemory,
                              FunctionTableAccess,
                              GetModuleBase
                              );

    } else {

        rval = WalkAmd64Init( Process,
                              StackFrame,
                              Context,
                              ReadMemory,
                              FunctionTableAccess,
                              GetModuleBase
                              );

    }

#if 1
    WDB(("WalkAmd64 out: succ %d, PC %I64X, SP %I64X, FP %I64X, RA %I64X\n",
         rval,
         StackFrame->AddrPC.Offset,
         StackFrame->AddrStack.Offset,
         StackFrame->AddrFrame.Offset,
         StackFrame->AddrReturn.Offset));
#endif

    return rval;
}

BOOL
UnwindStackFrameAmd64(
    IN     HANDLE                            Process,
    IN OUT PULONG64                          ReturnAddress,
    IN OUT PULONG64                          StackPointer,
    IN OUT PULONG64                          FramePointer,
    IN     PAMD64_CONTEXT                    Context,        // Context members could be modified.
    IN     PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    IN     PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    IN     PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    _PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionEntry;
    ULONG64 RetAddr;
    BOOL Succ = TRUE;

    FunctionEntry = (_PIMAGE_RUNTIME_FUNCTION_ENTRY)
        FunctionTableAccess( Process, *ReturnAddress );
    if (FunctionEntry != NULL) {

        ULONG64 ImageBase;
        // Initialized to quiet a PREfix warning.
        ULONG64 EstablisherFrame = 0;

        //
        // The return value coming out of mainCRTStartup is set by some
        // run-time routine to be 0; this serves to cause an error if someone
        // actually does a return from the mainCRTStartup frame.
        //

        ImageBase = GetModuleBase(Process, *ReturnAddress);
        if (!RtlVirtualUnwindAmd64(ImageBase, *ReturnAddress, FunctionEntry,
                                   Context, &EstablisherFrame,
                                   Process, ReadMemory) ||
            Context->Rip == 0 ||
            (Context->Rip == *ReturnAddress &&
             EstablisherFrame == *FramePointer)) {
            Succ = FALSE;
        }

        *ReturnAddress = Context->Rip;
        *StackPointer = Context->Rsp;
        // The frame pointer is an artificial value set
        // to a pointer below the return address.  This
        // matches an RBP-chain style of frame while
        // also allowing easy access to the return
        // address and homed arguments above it.
        *FramePointer = Context->Rsp - 2 * sizeof(ULONG64);

    } else {

        ULONG Done;
        
        // If there's no function entry for a function
        // we assume that it's a leaf and that ESP points
        // directly to the return address.  There's no
        // stored frame pointer so we actually need to
        // set a virtual frame pointer deeper in the stack
        // so that arguments can correctly be read at
        // two ULONG64's up from it.
        *FramePointer = Context->Rsp - 8;
        *StackPointer = Context->Rsp + 8;
        Succ = ReadMemory(Process, Context->Rsp,
                          ReturnAddress, sizeof(*ReturnAddress), &Done) &&
            Done == sizeof(*ReturnAddress);

        // Update the context values to what they should be in
        // the caller.
        if (Succ) {
            Context->Rsp += 8;
            Context->Rip = *ReturnAddress;
        }
    }

    if (Succ) {
        ULONG64 CallOffset;
        _PIMAGE_RUNTIME_FUNCTION_ENTRY CallFunc;

        //
        // Calls of __declspec(noreturn) functions may not have any
        // code after them to return to since the compiler knows
        // that the function will not return.  This can confuse
        // stack traces because the return address will lie outside
        // of the function's address range and FPO data will not
        // be looked up correctly.  Check and see if the return
        // address falls outside of the calling function and, if so,
        // adjust the return address back by one byte.  It'd be
        // better to adjust it back to the call itself so that
        // the return address points to valid code but
        // backing up in X86 assembly is more or less impossible.
        //

        CallOffset = *ReturnAddress - 1;
        CallFunc = (_PIMAGE_RUNTIME_FUNCTION_ENTRY)
            FunctionTableAccess(Process, CallOffset);
        if (CallFunc != NULL) {
            _IMAGE_RUNTIME_FUNCTION_ENTRY SaveCallFunc = *CallFunc;
            _PIMAGE_RUNTIME_FUNCTION_ENTRY RetFunc =
                (_PIMAGE_RUNTIME_FUNCTION_ENTRY)
                FunctionTableAccess(Process, *ReturnAddress);
            if (RetFunc == NULL ||
                memcmp(&SaveCallFunc, RetFunc, sizeof(SaveCallFunc))) {
                *ReturnAddress = CallOffset;
            }
        }
    }

    return Succ;
}

BOOL
ReadFrameArgsAmd64(
    LPADDRESS64 FrameOffset,
    HANDLE Process,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    PULONG64 Args
    )
{
    ULONG Done;

    if (!ReadMemory(Process, FrameOffset->Offset + 2 * sizeof(ULONG64),
                    Args, 4 * sizeof(ULONG64), &Done)) {
        Done = 0;
    }

    ZeroMemory((PUCHAR)Args + Done, 4 * sizeof(ULONG64) - Done);

    return Done > 0;
}

BOOL
WalkAmd64Init(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PAMD64_CONTEXT                    Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    AMD64_CONTEXT ContextSave;
    DWORD64 PcOffset;
    DWORD64 StackOffset;
    DWORD64 FrameOffset;

    ZeroMemory( &StackFrame->AddrBStore, sizeof(StackFrame->AddrBStore) );
    StackFrame->FuncTableEntry = NULL;
    ZeroMemory( StackFrame->Params, sizeof(StackFrame->Params) );
    StackFrame->Far = FALSE;
    StackFrame->Virtual = TRUE;
    ZeroMemory( StackFrame->Reserved, sizeof(StackFrame->Reserved) );

    if (!StackFrame->AddrPC.Offset) {
        StackFrame->AddrPC.Offset = Context->Rip;
        StackFrame->AddrPC.Mode   = AddrModeFlat;
    }

    if (!StackFrame->AddrStack.Offset) {
        StackFrame->AddrStack.Offset = Context->Rsp;
        StackFrame->AddrStack.Mode   = AddrModeFlat;
    }

    if (!StackFrame->AddrFrame.Offset) {
        StackFrame->AddrFrame.Offset = Context->Rbp;
        StackFrame->AddrFrame.Mode   = AddrModeFlat;
    }

    if ((StackFrame->AddrPC.Mode != AddrModeFlat) ||
        (StackFrame->AddrStack.Mode != AddrModeFlat) ||
        (StackFrame->AddrFrame.Mode != AddrModeFlat)) {
        return FALSE;
    }

    PcOffset = StackFrame->AddrPC.Offset;
    StackOffset = StackFrame->AddrStack.Offset;
    FrameOffset = StackFrame->AddrFrame.Offset;

    ContextSave = *Context;
    ContextSave.Rip = PcOffset;
    ContextSave.Rsp = StackOffset;
    ContextSave.Rbp = FrameOffset;
    
    if (!UnwindStackFrameAmd64( Process,
                                &PcOffset,
                                &StackOffset,
                                &FrameOffset,
                                &ContextSave,
                                ReadMemory,
                                FunctionTableAccess,
                                GetModuleBase)) {
        return FALSE;
    }

    StackFrame->AddrReturn.Offset = PcOffset;
    StackFrame->AddrReturn.Mode = AddrModeFlat;

    StackFrame->AddrFrame.Offset = FrameOffset;
    ReadFrameArgsAmd64(&StackFrame->AddrFrame, Process,
                       ReadMemory, StackFrame->Params);

    return TRUE;
}


BOOL
WalkAmd64Next(
    HANDLE                            Process,
    LPSTACKFRAME64                    StackFrame,
    PAMD64_CONTEXT                    Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    DWORD Done;
    BOOL Succ = TRUE;
    DWORD64 StackAddress;
    _PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionEntry;

    if (!UnwindStackFrameAmd64( Process,
                                &StackFrame->AddrPC.Offset,
                                &StackFrame->AddrStack.Offset,
                                &StackFrame->AddrFrame.Offset,
                                Context,
                                ReadMemory,
                                FunctionTableAccess,
                                GetModuleBase)) {
        Succ = FALSE;

        //
        // If the frame could not be unwound or is terminal, see if
        // there is a callback frame:
        //

        if (g.AppVersion.Revision >= 4 && CALLBACK_STACK(StackFrame)) {
            DWORD64 ImageBase;

            if (CALLBACK_STACK(StackFrame) & 0x80000000) {

                //
                // it is the pointer to the stack frame that we want
                //

                StackAddress = CALLBACK_STACK(StackFrame);

            } else {

                //
                // if it is a positive integer, it is the offset to
                // the address in the thread.
                // Look up the pointer:
                //

                Succ = ReadMemory(Process,
                                  (CALLBACK_THREAD(StackFrame) +
                                   CALLBACK_STACK(StackFrame)),
                                  &StackAddress,
                                  sizeof(StackAddress),
                                  &Done);
                if (!Succ || Done != sizeof(StackAddress) ||
                    StackAddress == 0) {
                    StackAddress = (DWORD64)-1;
                    CALLBACK_STACK(StackFrame) = (DWORD)-1;
                }
            }

            if ((StackAddress == (DWORD64)-1) ||
                (!(FunctionEntry = (_PIMAGE_RUNTIME_FUNCTION_ENTRY)
                   FunctionTableAccess(Process, CALLBACK_FUNC(StackFrame))) ||
                 !(ImageBase = GetModuleBase(Process,
                                             CALLBACK_FUNC(StackFrame))))) {

                Succ = FALSE;

            } else {

                if (!ReadMemory(Process,
                                (StackAddress + CALLBACK_NEXT(StackFrame)),
                                &CALLBACK_STACK(StackFrame),
                                sizeof(DWORD64),
                                &Done) ||
                    Done != sizeof(DWORD64)) {
                    Succ = FALSE;
                } else {
                    StackFrame->AddrPC.Offset =
                        ImageBase + FunctionEntry->BeginAddress;
                    StackFrame->AddrStack.Offset = StackAddress;
                    Context->Rsp = StackAddress;

                    Succ = TRUE;
                }
            }
        }
    }

    if (Succ) {
        AMD64_CONTEXT ContextSave;
        ULONG64 StackOffset = 0;
        ULONG64 FrameOffset = 0;

        //
        // Get the return address.
        //
        ContextSave = *Context;
        StackFrame->AddrReturn.Offset = StackFrame->AddrPC.Offset;

        if (!UnwindStackFrameAmd64( Process,
                                    &StackFrame->AddrReturn.Offset,
                                    &StackOffset,
                                    &FrameOffset,
                                    &ContextSave,
                                    ReadMemory,
                                    FunctionTableAccess,
                                    GetModuleBase)) {
            StackFrame->AddrReturn.Offset = 0;
        }

        StackFrame->AddrFrame.Offset = FrameOffset;
        ReadFrameArgsAmd64(&StackFrame->AddrFrame, Process, ReadMemory,
                           StackFrame->Params);
    }

    return Succ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\wppfmt.c ===
//  WppFmt.c
// This module contains the routines used by BinPlace to copy out the trace format information used 
// by software tracing. It creates "guid".tmf files 
// The pre-processor TraceWpp creates annotation records in the PDB with the first string bwinfg the text
// "TMF:" we find these annotation records and extract the complete record. The first record
// after "TMF:" contains the guid and friendly name. This GUID is used to create the filename.
// Currently the remainder of the records are copied to the file, a possible future change is to turn the
// file into a pointer file.
// Based on PDB sample code from VC folks, with names kept the same.
#ifdef __cplusplus
extern "C"{
#endif


//#define UNICODE
//#define _UNICODE


#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <dbghelp.h>
#include <cvinfo.h>
#define PDB_LIBRARY
#include <pdb.h>

    typedef LONG    CB;     // count of bytes
    typedef CHAR *      ST;
    typedef SYMTYPE*    PSYM;
    typedef SYMTYPE UNALIGNED * PSYMUNALIGNED;
    typedef BYTE*       PB;     // pointer to some bytes

    FILE* TraceFileP = NULL;                        // Current File
    CHAR lastguid[MAX_PATH];                        // The last file we processed
    CHAR TraceFile[MAX_PATH];                       // The current full file spec.
    CHAR TraceFileExt[] = ".tmf" ;                  // Extension used by Trace Files
    CHAR TraceControlExt[] = ".tmc" ;               // Extension used by Trace Control Files
    BOOL TracePathChecked = FALSE ;                 // if we have ascertained the trace Path exists.
    CHAR Fname[MAX_PATH] ;
    CHAR Mname[MAX_PATH] ;

#define GUIDTEXTLENGTH  32+4                    // Guid takes 32 chars plus 4 -'s

#define MAXLINE MAX_PATH + 256
    CHAR Line[MAXLINE] ;
    CHAR FirstLine[MAXLINE] ;

    BOOL fVerbose = FALSE ;

    typedef BOOL ( __cdecl *PPDBOPEN )(
                                      LNGNM_CONST char *,
                                      LNGNM_CONST char *,
                                      SIG,
                                      EC *,
                                      char [cbErrMax],
                                      PDB **
                                      );

    typedef BOOL ( __cdecl *PPDBCLOSE ) (
                                        PDB* ppdb
                                        );

    typedef BOOL ( __cdecl *PPDBOPENDBI ) (
                                          PDB* ppdb, const char* szMode, const char* szTarget, OUT DBI** ppdbi
                                          );

    typedef BOOL ( __cdecl *PDBICLOSE ) (
                                        DBI* pdbi
                                        );

    typedef BOOL ( __cdecl *PMODQUERYSYMBOLS ) (
                                               Mod* pmod, BYTE* pbSym, long* pcb
                                               );

    typedef BOOL ( __cdecl *PDBIQUERYNEXTMOD ) (
                                               DBI* pdbi, Mod* pmod, Mod** ppmodNext
                                               );

    static PPDBOPEN    pPDBOpen = NULL;
    static PPDBCLOSE   pPDBClose = NULL;
    static PPDBOPENDBI pPDBOpenDBI = NULL;
    static PDBICLOSE   pDBIClose = NULL;
    static PMODQUERYSYMBOLS pModQuerySymbols = NULL;
    static PDBIQUERYNEXTMOD pDBIQueryNextMod = NULL;

    static BOOL RSDSLibLoaded = FALSE;

// Return the number of bytes the symbol record occupies.
#define MDALIGNTYPE_	DWORD

    __inline CB cbAlign_(CB cb) {
        return((cb + sizeof(MDALIGNTYPE_) - 1)) & ~(sizeof(MDALIGNTYPE_) - 1);}

// Return the number of bytes in an ST

    __inline CB cbForSt(ST st) { return *(PB)st + 1;}

    CB cbForSym(PSYMUNALIGNED psym)
    {
        CB cb = psym->reclen + sizeof(psym->reclen); 
        // procrefs also have a hidden length preceeded name following the record
        if ((psym->rectyp == S_PROCREF) || (psym->rectyp == S_LPROCREF))
            cb += cbAlign_(cbForSt((ST)(psym + cb)));
        return cb;
    }

// Return a pointer to the byte just past the end of the symbol record.

    PSYM pbEndSym(PSYM psym) { return(PSYM)((CHAR *)psym + cbForSym(psym));}

    CHAR * SymBuffer   = 0;
    int    SymBufferSize = 0;

    BOOL ensureBufferSizeAtLeast(int size)
    {
        if (size > SymBufferSize) {
            LocalFree(SymBuffer);
            SymBufferSize = 0;
            size = (size + 0xFFFF) & ~0xFFFF;
            SymBuffer = LocalAlloc(LMEM_FIXED, size );
            if (!SymBuffer) {
                fprintf(stderr,"%s : error BNP0000: WPPFMT alloc of %d bytes failed\n",Fname, size);
                return FALSE;
            }
            SymBufferSize = size;
        }
        return TRUE;
    }


    void dumpSymbol(PSYM psym,
                    PSTR PdbFileName,
                    PSTR TraceFormatFilePath) 
    {
        static char FuncName[256] = "Unknown";
        static char Fmode[8] = "w" ;

        if (psym->rectyp == S_GPROC32 || psym->rectyp == S_LPROC32) {
            PROCSYM32* p = (PROCSYM32*)psym;
            int n = p->name[0];
            memcpy(FuncName, p->name + 1, n);
            FuncName[n] = 0; 
            return;
        }
        //
        // The following is a complete crock to let us handle some V7 PDB changes
        // This code will have qbe changed by DIA but this lets users get work done
#define S_GPROC32_V7 0x110f
#define S_LPROC32_V7 0x1110
        if (psym->rectyp == (S_GPROC32_V7) || psym->rectyp == (S_LPROC32_V7)) {
            PROCSYM32* p = (PROCSYM32*)psym;
            strncpy(FuncName,p->name, 256);     // Note name is null terminated, not length!!!
            return;
        }
        // End of V7 PDB crock

        if (psym->rectyp == S_ANNOTATION) {
            ANNOTATIONSYM* aRec = (ANNOTATIONSYM*) psym;
            UCHAR * Aline = aRec->rgsz;
            int   cnt = aRec->csz, i; 
            CHAR* Ext;

            if ( cnt < 2 ) {
                return;
            }
            if ( strcmp(Aline, "TMF:") == 0 ) {
                Ext = TraceFileExt;
            } else if ( strcmp(Aline, "TMC:") == 0 ) {
                Ext = TraceControlExt;
            } else {
                return;
            }
            // skip tmf
            Aline += strlen(Aline) + 1; 
            // now Aline points to guid, is it the same as before?
            if ( (TraceFileP != stdout) && strncmp(Aline, lastguid, GUIDTEXTLENGTH) != 0) {
                // the guid has changed, we need to change the file
                if (TraceFileP) {
                    fclose(TraceFileP);    // Close the last one
                    TraceFileP = NULL ;
                }
                strncpy(lastguid, Aline, GUIDTEXTLENGTH);
                _snprintf(TraceFile,MAX_PATH,"%s\\%s%s",TraceFormatFilePath,lastguid,Ext);

                if (!TracePathChecked) {
                    if (!MakeSureDirectoryPathExists(TraceFile)) {    // Make the directory if we need to
                        fprintf(stderr,"%s : error BNP0000: WPPFMT Failed to make path %s\n",Fname, TraceFile);
                        return;
                    } else {
                        TracePathChecked = TRUE ;
                    }
                }

                sprintf(Fmode,"w");    // Assume its to be overwritten
                if ((TraceFileP = fopen(TraceFile,"r")) != NULL ) {
                    // Hmm it already exists, is it an old one or must we add to it.
                    if (_fgetts(Line, MAXLINE, TraceFileP)) {
                        if (strcmp(Line,FirstLine) == 0) {
                            sprintf(Fmode,"a");
                        }
                    }
                    fclose (TraceFileP);
                    TraceFileP = NULL ;
                }

                TraceFileP = fopen(TraceFile, Fmode);

                if (!TraceFileP) {
                    fprintf(stderr,"%s : error BNP0000: WPPFMT Failed to open %s\n",Fname, TraceFile);
                    return;
                }
                if (fVerbose) {
                    fprintf(stdout,"%s : warning BNP0000: WPPFMT generating %s for %s\n", 
                            Fname, TraceFile, PdbFileName);
                }
                if (!(strcmp(Fmode,"w"))) {
                    // First time around comment on what we are doing.
                    fprintf(TraceFileP,"%s",FirstLine);  // Note the name of the PDB etc.
                    fprintf(TraceFileP,"%s\n",Aline);    // Guid and friendly name
                } else {
                    fprintf(TraceFileP,"//PDB append\n");
                }
            }
            // process the annotation which is a series of null terminated strings.
            cnt -= 2; Aline += strlen(Aline) + 1; 
            for (i = 0; i < cnt; ++i) {
                if (i == 0) {
                    fprintf(TraceFileP, "%s FUNC=%s\n", Aline, FuncName);
                } else {
                    fprintf(TraceFileP,"%s\n", Aline);
                }
                Aline += strlen(Aline) + 1;
            }
        }
    }

    DWORD
    BinplaceWppFmt(
                  LPSTR PdbFileName,
                  LPSTR TraceFormatFilePath,
                  LPSTR szRSDSDllToLoad,
                  BOOL  TraceVerbose
                  )
    {
        PDB *pPdb;
        DBI *pDbi;
        HANDLE hPdb ;

        UCHAR szErr[cbErrMax];
        EC    errorCode;
        Mod*  pMod;
        DWORD Status ;
        BOOL rc;

        fVerbose = TraceVerbose ;
        // get name of the caller
        Status = GetModuleFileName(NULL, Mname, MAX_PATH);
        _splitpath(Mname, NULL, NULL, Fname, NULL);

#ifdef _WIN64
        rc = FALSE;
#else
        __try
        {
            if (hPdb = CreateFile(PdbFileName,
                                  GENERIC_READ,
                                  0,NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL)) {
                FILETIME ftime ;
                SYSTEMTIME stime ;
                if (GetFileTime(hPdb,NULL,NULL,&ftime)) {
                    if ( FileTimeToSystemTime(&ftime,&stime) ) {
                        _snprintf(FirstLine,MAXLINE,"//PDB:  %s Last Updated :%d-%d-%d:%d:%d:%d:%d (UTC) [%s]\n",
                                  PdbFileName,
                                  stime.wYear,stime.wMonth,stime.wDay,
                                  stime.wHour,stime.wMinute,stime.wSecond,stime.wMilliseconds,
                                  Fname); 

                    }
                }
                CloseHandle(hPdb);
            } else {
                // Let the failure case be dealt with by PDBOpen
            }


            rc=PDBOpen(PdbFileName, pdbRead, 0, &errorCode, szErr, &pPdb);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            rc=FALSE;
        }
#endif
        if ( !rc ) {

            // Try the one that works with RSDS 
            if ( szRSDSDllToLoad != NULL ) {

                HMODULE hDll;
                if ( !RSDSLibLoaded ) {
                    hDll = LoadLibrary( szRSDSDllToLoad );
                    if (hDll != NULL) {
                        RSDSLibLoaded = TRUE;
                        pPDBOpen = ( PPDBOPEN ) GetProcAddress( hDll, "PDBOpen" );
                        if (pPDBOpen == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed PDBOpen\n",Fname);
                            return(FALSE);
                        }
                        pPDBClose = ( PPDBCLOSE ) GetProcAddress( hDll, "PDBClose" );
                        if (pPDBClose == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed PDBOClose\n",Fname);
                            return(FALSE);
                        }
                        pPDBOpenDBI = ( PPDBOPENDBI ) GetProcAddress( hDll, "PDBOpenDBI" );
                        if (pPDBOpenDBI == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed PDBOpenDBI\n",Fname);
                            return(FALSE);
                        }
                        pDBIClose = ( PDBICLOSE ) GetProcAddress( hDll, "DBIClose" );
                        if (pDBIClose == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed DBICLOSE\n",Fname);
                            return(FALSE);
                        }

                        pDBIQueryNextMod = ( PDBIQUERYNEXTMOD ) GetProcAddress( hDll, "DBIQueryNextMod" );
                        if (pDBIQueryNextMod == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed DBIQueryNextMod\n",Fname);
                            return(FALSE);
                        }

                        pModQuerySymbols = ( PMODQUERYSYMBOLS ) GetProcAddress( hDll, "ModQuerySymbols" );
                        if (pModQuerySymbols == NULL ) {
                            fprintf(stderr,"%s : error BNP0000: WPPFMT GEtPRocAddressFailed ModQuerySymbols\n",Fname);
                            return(FALSE);
                        }

                    } else {
                        fprintf(stderr,"%s : error BNP0000: WPPFMT Failed to load library %s (0x%08X)\n",Fname, szRSDSDllToLoad,GetLastError());
                        return(FALSE);
                    }
                }
            }

            if (RSDSLibLoaded) {
                __try
                {
                    rc = pPDBOpen(PdbFileName, pdbRead, 0, &errorCode, szErr, &pPdb);
                }
                __except (EXCEPTION_EXECUTE_HANDLER )
                {
                    rc=FALSE;
                }
            }
        }

        if (!rc) {
            fprintf(stderr,"%s : warning BNP0000: WPPFMT PDBOpen failed, code %d, error %s\n",
                    Fname, errorCode, szErr);
            goto fail1;
        }

        if (RSDSLibLoaded) {
            rc = pPDBOpenDBI(pPdb, pdbRead, "<target>.exe", &pDbi);
        } else {
            rc = PDBOpenDBI(pPdb, pdbRead, "<target>.exe", &pDbi);
        }
        if (!rc) {
            fprintf(stderr,"%s : warning BNP0000: WPPFMT PDBOpenDBI failed\n",Fname);
            goto fail2;
        }

        if (RSDSLibLoaded) {
            for (pMod = 0; pDBIQueryNextMod(pDbi, pMod, &pMod) && pMod; ) {
                CB cbSyms;

                if (  pModQuerySymbols(pMod, 0, &cbSyms) 
                      && ensureBufferSizeAtLeast(cbSyms) 
                      && pModQuerySymbols(pMod, SymBuffer, &cbSyms) ) {
                    PSYM psymEnd = (PSYM)(SymBuffer + cbSyms);
                    PSYM psym    = (PSYM)(SymBuffer + sizeof(ULONG));

                    for (; psym < psymEnd; psym = pbEndSym(psym))
                        dumpSymbol(psym,PdbFileName,TraceFormatFilePath);
                } else {
                    fprintf(stderr,"%s : warning BNP0000: WPPFMT ModQuerySymbols failed pMod = %p cbSyms = %d\n",
                            Fname, pMod, cbSyms);
                    break;
                }
            }
        } else {
            for (pMod = 0; DBIQueryNextMod(pDbi, pMod, &pMod) && pMod; ) {
                CB cbSyms;

                if (  ModQuerySymbols(pMod, 0, &cbSyms) 
                      && ensureBufferSizeAtLeast(cbSyms) 
                      && ModQuerySymbols(pMod, SymBuffer, &cbSyms) ) {
                    PSYM psymEnd = (PSYM)(SymBuffer + cbSyms);
                    PSYM psym    = (PSYM)(SymBuffer + sizeof(ULONG));

                    for (; psym < psymEnd; psym = pbEndSym(psym))
                        dumpSymbol(psym,PdbFileName,TraceFormatFilePath);
                } else {
                    fprintf(stderr,"%s : warning BNP0000: WPPFMT ModQuerySymbols failed pMod = %p cbSyms = %d\n",
                            Fname, pMod, cbSyms);
                    break;
                }
            }
        }

        if (RSDSLibLoaded) {
            pDBIClose(pDbi);
        } else {
            DBIClose(pDbi);
        }
        fail2:   
        if (RSDSLibLoaded) {
            pPDBClose(pPdb);
        } else {
            PDBClose(pPdb);
        }
        fail1:
        if (TraceFileP) {
            fclose(TraceFileP);    // Close the last one
            TraceFileP = NULL ;
        }
        return errorCode;
    }
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\_qsort.c ===
#define NEW_QSORT_NAME dbg_qsort

#include "_qsort.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\imagehlp\walkx86.c ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    walkx86.c

Abstract:

    This file implements the Intel x86 stack walking api.  This api allows for
    the presence of "real mode" stack frames.  This means that you can trace
    into WOW code.

Author:

    Wesley Witt (wesw) 1-Oct-1993

Environment:

    User Mode

--*/

#define _IMAGEHLP_SOURCE_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include <objbase.h>
#include <wx86dll.h>
#include <symbols.h>
#include <globals.h>
#include "dia2.h"

#if 0
#define WDB(Args) dbPrint Args
#else
#define WDB(Args)
#endif


#define SAVE_EBP(f)        (f->Reserved[0])
#define TRAP_TSS(f)        (f->Reserved[1])
#define TRAP_EDITED(f)     (f->Reserved[1])
#define SAVE_TRAP(f)       (f->Reserved[2])
#define CALLBACK_STACK(f)  (f->KdHelp.ThCallbackStack)
#define CALLBACK_NEXT(f)   (f->KdHelp.NextCallback)
#define CALLBACK_FUNC(f)   (f->KdHelp.KiCallUserMode)
#define CALLBACK_THREAD(f) (f->KdHelp.Thread)
#define CALLBACK_FP(f)     (f->KdHelp.FramePointer)
#define CALLBACK_DISPATCHER(f) (f->KdHelp.KeUserCallbackDispatcher)
#define SYSTEM_RANGE_START(f) (f->KdHelp.SystemRangeStart)

#define STACK_SIZE         (sizeof(DWORD))
#define FRAME_SIZE         (STACK_SIZE * 2)

#define STACK_SIZE16       (sizeof(WORD))
#define FRAME_SIZE16       (STACK_SIZE16 * 2)
#define FRAME_SIZE1632     (STACK_SIZE16 * 3)

#define MAX_STACK_SEARCH   64   // in STACK_SIZE units
#define MAX_JMP_CHAIN      64   // in STACK_SIZE units
#define MAX_CALL           7    // in bytes
#define MIN_CALL           2    // in bytes
#define MAX_FUNC_PROLOGUE  64   // in bytes

#define PUSHBP             0x55
#define MOVBPSP            0xEC8B

ULONG g_vc7fpo = 1;

#define DoMemoryRead(addr,buf,sz,br) \
    ReadMemoryInternal( Process, Thread, addr, buf, sz, \
                        br, ReadMemory, TranslateAddress )


BOOL
WalkX86Init(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PX86_CONTEXT                      ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

BOOL
WalkX86Next(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PX86_CONTEXT                      ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

BOOL
ReadMemoryInternal(
    HANDLE                          Process,
    HANDLE                          Thread,
    LPADDRESS64                     lpBaseAddress,
    LPVOID                          lpBuffer,
    DWORD                           nSize,
    LPDWORD                         lpNumberOfBytesRead,
    PREAD_PROCESS_MEMORY_ROUTINE64  ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64    TranslateAddress
    );

BOOL
IsFarCall(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    BOOL                              *Ok,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

BOOL
ReadTrapFrame(
    HANDLE                            Process,
    DWORD64                           TrapFrameAddress,
    PX86_KTRAP_FRAME                  TrapFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    );

BOOL
TaskGate2TrapFrame(
    HANDLE                            Process,
    USHORT                            TaskRegister,
    PX86_KTRAP_FRAME                  TrapFrame,
    PULONG64                          off,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    );

DWORD64
SearchForReturnAddress(
    HANDLE                            Process,
    DWORD64                           uoffStack,
    DWORD64                           funcAddr,
    DWORD                             funcSize,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    BOOL                              AcceptUnreadableCallSite
    );

//----------------------------------------------------------------------------
//
// DIA IDiaStackWalkFrame implementation.
//
//----------------------------------------------------------------------------

class X86WalkFrame : public IDiaStackWalkFrame
{
public:
    X86WalkFrame(HANDLE Process,
                 X86_CONTEXT* Context,
                 PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
                 PGET_MODULE_BASE_ROUTINE64 GetModuleBase)
    {
        m_Process = Process;
        m_Context = Context;
        m_ReadMemory = ReadMemory;
        m_GetModuleBase = GetModuleBase;
        m_Locals = 0;
        m_Params = 0;
        m_VirtFrame = Context->Ebp;
    }

    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDiaStackWalkFrame.
    STDMETHOD(get_registerValue)(DWORD reg, ULONGLONG* pValue);
    STDMETHOD(put_registerValue)(DWORD reg, ULONGLONG value);
    STDMETHOD(readMemory)(ULONGLONG va, DWORD cbData,
                          DWORD* pcbData, BYTE* data);
    STDMETHOD(searchForReturnAddress)(IDiaFrameData* frame,
                                      ULONGLONG* pResult);
    STDMETHOD(searchForReturnAddressStart)(IDiaFrameData* frame,
                                           ULONGLONG startAddress,
                                           ULONGLONG* pResult);

private:
    HANDLE m_Process;
    X86_CONTEXT* m_Context;
    PREAD_PROCESS_MEMORY_ROUTINE64 m_ReadMemory;
    PGET_MODULE_BASE_ROUTINE64 m_GetModuleBase;
    ULONGLONG m_Locals;
    ULONGLONG m_Params;
    ULONGLONG m_VirtFrame;
};

STDMETHODIMP
X86WalkFrame::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;
    
    *Interface = NULL;
    Status = E_NOINTERFACE;
    
    if (IsEqualIID(InterfaceId, IID_IDiaStackWalkFrame)) {
        *Interface = (IDiaStackWalkFrame*)this;
        Status = S_OK;
    }

    return Status;
}

STDMETHODIMP_(ULONG)
X86WalkFrame::AddRef(
    THIS
    )
{
    // Stack allocated, no refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
X86WalkFrame::Release(
    THIS
    )
{
    // Stack allocated, no refcount.
    return 0;
}

STDMETHODIMP
X86WalkFrame::get_registerValue( DWORD reg, ULONGLONG* pVal )
{
    switch( reg ) {
        // debug registers
    case CV_REG_DR0:
        *pVal = m_Context->Dr0;
        break;
    case CV_REG_DR1:
        *pVal = m_Context->Dr1;
        break;
    case CV_REG_DR2:
        *pVal = m_Context->Dr2;
        break;
    case CV_REG_DR3:
        *pVal = m_Context->Dr3;
        break;
    case CV_REG_DR6:
        *pVal = m_Context->Dr6;
        break;
    case CV_REG_DR7:
        *pVal = m_Context->Dr7;
        break;

        // segment registers
    case CV_REG_GS:
        *pVal = m_Context->SegGs;
        break;
    case CV_REG_FS:
        *pVal = m_Context->SegFs;
        break;
    case CV_REG_ES:
        *pVal = m_Context->SegEs;
        break;
    case CV_REG_DS:
        *pVal = m_Context->SegDs;
        break;
        
        // integer registers
    case CV_REG_EDI:
        *pVal = m_Context->Edi;
        break;
    case CV_REG_ESI:
        *pVal = m_Context->Esi;
        break;
    case CV_REG_EBX:
        *pVal = m_Context->Ebx;
        break;
    case CV_REG_EDX:
        *pVal = m_Context->Edx;
        break;
    case CV_REG_ECX:
        *pVal = m_Context->Ecx;
        break;
    case CV_REG_EAX:
        *pVal = m_Context->Eax;
        break;

        // control registers
    case CV_REG_EBP:
        *pVal = m_Context->Ebp;
        break;
    case CV_REG_EIP:
        *pVal = m_Context->Eip;
        break;
    case CV_REG_CS:
        *pVal = m_Context->SegCs;
        break;
    case CV_REG_EFLAGS:
        *pVal = m_Context->EFlags;
        break;
    case CV_REG_ESP:
        *pVal = m_Context->Esp;
        break;
    case CV_REG_SS:
        *pVal = m_Context->SegSs;
        break;

    case CV_ALLREG_LOCALS:
        *pVal = m_Locals;
        break;
    case CV_ALLREG_PARAMS:
        *pVal = m_Params;
        break;
    case CV_ALLREG_VFRAME:
        *pVal = m_VirtFrame;
        break;
        
    default:
        *pVal = 0;
        return E_FAIL;
    }
    
    return S_OK;
}

STDMETHODIMP
X86WalkFrame::put_registerValue( DWORD reg, ULONGLONG LongVal )
{
    ULONG val = (ULONG)LongVal;
    
    switch( reg ) {
        // debug registers
    case CV_REG_DR0:
        m_Context->Dr0 = val;
        break;
    case CV_REG_DR1:
        m_Context->Dr1 = val;
        break;
    case CV_REG_DR2:
        m_Context->Dr2 = val;
        break;
    case CV_REG_DR3:
        m_Context->Dr3 = val;
        break;
    case CV_REG_DR6:
        m_Context->Dr6 = val;
        break;
    case CV_REG_DR7:
        m_Context->Dr7 = val;
        break;

        // segment registers
    case CV_REG_GS:
        m_Context->SegGs = val;
        break;
    case CV_REG_FS:
        m_Context->SegFs = val;
        break;
    case CV_REG_ES:
        m_Context->SegEs = val;
        break;
    case CV_REG_DS:
        m_Context->SegDs = val;
        break;
        
        // integer registers
    case CV_REG_EDI:
        m_Context->Edi = val;
        break;
    case CV_REG_ESI:
        m_Context->Esi = val;
        break;
    case CV_REG_EBX:
        m_Context->Ebx = val;
        break;
    case CV_REG_EDX:
        m_Context->Edx = val;
        break;
    case CV_REG_ECX:
        m_Context->Ecx = val;
        break;
    case CV_REG_EAX:
        m_Context->Eax = val;
        break;

        // control registers
    case CV_REG_EBP:
        m_Context->Ebp = val;
        break;
    case CV_REG_EIP:
        m_Context->Eip = val;
        break;
    case CV_REG_CS:
        m_Context->SegCs = val;
        break;
    case CV_REG_EFLAGS:
        m_Context->EFlags = val;
        break;
    case CV_REG_ESP:
        m_Context->Esp = val;
        break;
    case CV_REG_SS:
        m_Context->SegSs = val;
        break;

    case CV_ALLREG_LOCALS:
        m_Locals = val;
        break;
    case CV_ALLREG_PARAMS:
        m_Params = val;
        break;
    case CV_ALLREG_VFRAME:
        m_VirtFrame = val;
        break;
        
    default:
        return E_FAIL;
    }
    
    return S_OK;
}

STDMETHODIMP
X86WalkFrame::readMemory(ULONGLONG va, DWORD cbData,
                         DWORD* pcbData, BYTE* data)
{
    return m_ReadMemory( m_Process, va, data, cbData, pcbData ) != 0 ?
        S_OK : E_FAIL;
}

STDMETHODIMP
X86WalkFrame::searchForReturnAddress(IDiaFrameData* frame,
                                     ULONGLONG* pResult)
{
    HRESULT Status;
    DWORD LenLocals, LenRegs;

    if ((Status = frame->get_lengthLocals(&LenLocals)) != S_OK ||
        (Status = frame->get_lengthSavedRegisters(&LenRegs)) != S_OK) {
        return Status;
    }
    
    return searchForReturnAddressStart(frame,
                                       m_Context->Esp + LenLocals + LenRegs,
                                       pResult);
}

STDMETHODIMP
X86WalkFrame::searchForReturnAddressStart(IDiaFrameData* DiaFrame,
                                          ULONGLONG StartAddress,
                                          ULONGLONG* Result)
{
    HRESULT Status;
    BOOL IsFuncStart;
    IDiaFrameData* OrigFrame = DiaFrame;
    IDiaFrameData* NextFrame;
        
    //
    // This frame data may be a subsidiary descriptor.  Move up
    // the parent chain to the true function start.
    //

    while (DiaFrame->get_functionParent(&NextFrame) == S_OK) {
        if (DiaFrame != OrigFrame) {
            DiaFrame->Release();
        }
        DiaFrame = NextFrame;
    }

    ULONGLONG FuncStart;
    DWORD LenFunc;
    
    if ((Status = DiaFrame->get_virtualAddress(&FuncStart)) == S_OK) {
        Status = DiaFrame->get_lengthBlock(&LenFunc);
    }
    
    if (DiaFrame != OrigFrame) {
        DiaFrame->Release();
    }

    if (Status != S_OK) {
        return Status;
    }
    
    *Result = SearchForReturnAddress(m_Process,
                                     StartAddress,
                                     FuncStart,
                                     LenFunc,
                                     m_ReadMemory,
                                     m_GetModuleBase,
                                     FALSE);
    return *Result != 0 ? S_OK : E_FAIL;
}

//----------------------------------------------------------------------------
//
// Walk functions.
//
//----------------------------------------------------------------------------

BOOL
WalkX86(
    HANDLE                            Process,
    HANDLE                            Thread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress,
    DWORD                             flags
    )
{
    BOOL rval;

#if 0
    WDB(("WalkX86  in: PC %X, SP %X, FP %X, RA %X\n",
         (ULONG)StackFrame->AddrPC.Offset,
         (ULONG)StackFrame->AddrStack.Offset,
         (ULONG)StackFrame->AddrFrame.Offset,
         (ULONG)StackFrame->AddrReturn.Offset));
#endif

    if (StackFrame->Virtual) {

        rval = WalkX86Next( Process,
                            Thread,
                            StackFrame,
                            (PX86_CONTEXT)ContextRecord,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress
                          );

    } else {

        rval = WalkX86Init( Process,
                            Thread,
                            StackFrame,
                            (PX86_CONTEXT)ContextRecord,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress
                          );

    }

#if 0
    WDB(("WalkX86 out: PC %X, SP %X, FP %X, RA %X\n",
         (ULONG)StackFrame->AddrPC.Offset,
         (ULONG)StackFrame->AddrStack.Offset,
         (ULONG)StackFrame->AddrFrame.Offset,
         (ULONG)StackFrame->AddrReturn.Offset));
#endif

    // This hack fixes the fpo stack when ebp wasn't used.  
    // Don't put this fix into StackWalk() or it will break MSDEV.
#if 0
    if (rval && (flags & WALK_FIX_FPO_EBP)) {
            PFPO_DATA   pFpo = (PFPO_DATA)StackFrame->FuncTableEntry;
        if (pFpo && !pFpo->fUseBP) {
                StackFrame->AddrFrame.Offset += 4;
            }
    }
#endif

    return rval;
}

BOOL
ReadMemoryInternal(
    HANDLE                          Process,
    HANDLE                          Thread,
    LPADDRESS64                     lpBaseAddress,
    LPVOID                          lpBuffer,
    DWORD                           nSize,
    LPDWORD                         lpNumberOfBytesRead,
    PREAD_PROCESS_MEMORY_ROUTINE64  ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64    TranslateAddress
    )
{
    ADDRESS64 addr;

    addr = *lpBaseAddress;
    if (addr.Mode != AddrModeFlat) {
        TranslateAddress( Process, Thread, &addr );
    }
    return ReadMemory( Process,
                       addr.Offset,
                       lpBuffer,
                       nSize,
                       lpNumberOfBytesRead
                       );
}

DWORD64
SearchForReturnAddress(
    HANDLE                            Process,
    DWORD64                           uoffStack,
    DWORD64                           funcAddr,
    DWORD                             funcSize,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    BOOL                              AcceptUnreadableCallSite
    )
{
    DWORD64        uoffRet;
    DWORD64        uoffBestGuess = 0;
    DWORD          cdwIndex;
    DWORD          cdwIndexMax;
    INT            cbIndex;
    INT            cbLimit;
    DWORD          cBytes;
    DWORD          cJmpChain = 0;
    DWORD64        uoffT;
    DWORD          cb;
    BYTE           jmpBuffer[ sizeof(WORD) + sizeof(DWORD) ];
    LPWORD         lpwJmp = (LPWORD)&jmpBuffer[0];
    BYTE           code[MAX_CALL];
    DWORD          stack [ MAX_STACK_SEARCH ];
    BOPINSTR BopInstr;

    WDB(("      SearchForReturnAddress: start %X\n", (ULONG)uoffStack));
    
    //
    // this function is necessary for 4 reasons:
    //
    //      1) random compiler bugs where regs are saved on the
    //         stack but the fpo data does not account for them
    //
    //      2) inline asm code that does a push
    //
    //      3) any random code that does a push and it isn't
    //         accounted for in the fpo data
    //
    //      4) non-void non-fpo functions
    //         *** This case is not neccessary when the compiler
    //          emits FPO records for non-FPO funtions.  Unfortunately
    //          only the NT group uses this feature.
    //

    if (!ReadMemory(Process,
                    uoffStack,
                    stack,
                    sizeof(stack),
                    &cb)) {
        WDB(("        can't read stack\n"));
        return 0;
    }


    cdwIndexMax = cb / STACK_SIZE;

    if ( !cdwIndexMax ) {
        WDB(("        can't read stack\n"));
        return 0;
    }

    for ( cdwIndex=0; cdwIndex<cdwIndexMax; cdwIndex++,uoffStack+=STACK_SIZE ) {

        uoffRet = (DWORD64)(LONG64)(LONG)stack[cdwIndex];

        //
        // Don't try looking for Code in the first 64K of an NT app.
        //
        if ( uoffRet < 0x00010000 ) {
            continue;
        }

        //
        // if it isn't part of any known address space it must be bogus
        //

        if (GetModuleBase( Process, uoffRet ) == 0) {
            continue;
        }

        //
        // Check for a BOP instruction.
        //
        if (ReadMemory(Process,
                       uoffRet - sizeof(BOPINSTR),
                       &BopInstr,
                       sizeof(BOPINSTR),
                       &cb)) {

            if (cb == sizeof(BOPINSTR) &&
                BopInstr.Instr1 == 0xc4 && BopInstr.Instr2 == 0xc4) {
                WDB(("        BOP, use %X\n", (ULONG)uoffStack));
                return uoffStack;
            }
        }

        //
        // Read the maximum number of bytes a call could be from the istream
        //
        cBytes = MAX_CALL;
        if (!ReadMemory(Process,
                        uoffRet - cBytes,
                        code,
                        cBytes,
                        &cb)) {

            //
            // if page is not present, we will ALWAYS mess up by
            // continuing to search.  If alloca was used also, we
            // are toast.  Too Bad.
            //
            if (cdwIndex == 0 && AcceptUnreadableCallSite) {
                WDB(("        unreadable call site, use %X\n",
                     (ULONG)uoffStack));
                return uoffStack;
            } else {
                continue;
            }
        }



        //
        // With 32bit code that isn't FAR:32 we don't have to worry about
        // intersegment calls.  Check here to see if we had a call within
        // segment.  If it is we can later check it's full diplacement if
        // necessary and see if it calls the FPO function.  We will also have
        // to check for thunks and see if maybe it called a JMP indirect which
        // called the FPO function. We will fail to find the caller if it was
        // a case of tail recursion where one function doesn't actually call
        // another but rather jumps to it.  This will only happen when a
        // function who's parameter list is void calls another function who's
        // parameter list is void and the call is made as the last statement
        // in the first function.  If the call to the first function was an
        // 0xE8 call we will fail to find it here because it didn't call the
        // FPO function but rather the FPO functions caller.  If we don't get
        // specific about our 0xE8 checks we will potentially see things that
        // look like return addresses but aren't.
        //

        if (( cBytes >= 5 ) && ( ( code[ 2 ] == 0xE8 ) || ( code[ 2 ] == 0xE9 ) )) {

            // We do math on 32 bit so we can ignore carry, and then sign extended
            uoffT = (ULONG64)(LONG64)(LONG)((DWORD)uoffRet + *( (UNALIGNED DWORD *) &code[3] ));

            //
            // See if it calls the function directly, or into the function
            //
            if (( uoffT >= funcAddr) && ( uoffT < (funcAddr + funcSize) ) ) {
                WDB(("        found function, use %X\n", (ULONG)uoffStack));
                return uoffStack;
            }


            while ( cJmpChain < MAX_JMP_CHAIN ) {

                if (!ReadMemory(Process,
                                uoffT,
                                jmpBuffer,
                                sizeof(jmpBuffer),
                                &cb)) {
                    break;
                }

                if (cb != sizeof(jmpBuffer)) {
                    break;
                }

                //
                // Now we are going to check if it is a call to a JMP, that may
                // jump to the function
                //
                // If it is a relative JMP then calculate the destination
                // and save it in uoffT.  If it is an indirect JMP then read
                // the destination from where the JMP is inderecting through.
                //
                if ( *(LPBYTE)lpwJmp == 0xE9 ) {

                    // We do math on 32 bit so we can ignore carry, and then
                    // sign extended
                    uoffT = (ULONG64)(LONG64)(LONG) ((ULONG)uoffT +
                            *(UNALIGNED DWORD *)( jmpBuffer + sizeof(BYTE) ) + 5);

                } else if ( *lpwJmp == 0x25FF ) {

                    if ((!ReadMemory(Process,
                                     (ULONG64)(LONG64)(LONG) (
                                         *(UNALIGNED DWORD *)
                                         ((LPBYTE)lpwJmp+sizeof(WORD))),
                                     &uoffT,
                                     sizeof(DWORD),
                                     &cb)) || (cb != sizeof(DWORD))) {
                        uoffT = 0;
                        break;
                    }
                    uoffT =  (DWORD64)(LONG64)(LONG)uoffT;

                } else {
                    break;
                }

                //
                // If the destination is to the FPO function then we have
                // found the return address and thus the vEBP
                //
                if ( uoffT == funcAddr ) {
                    WDB(("        exact function, use %X\n",
                         (ULONG)uoffStack));
                    return uoffStack;
                }

                cJmpChain++;
            }

            //
            // We cache away the first 0xE8 call or 0xE9 jmp that we find in
            // the event we cant find anything else that looks like a return
            // address.  This is meant to protect us in the tail recursion case.
            //
            if ( !uoffBestGuess ) {
                uoffBestGuess = uoffStack;
            }
        }


        //
        // Now loop backward through the bytes read checking for a multi
        // byte call type from Grp5.  If we find an 0xFF then we need to
        // check the byte after that to make sure that the nnn bits of
        // the mod/rm byte tell us that it is a call.  It it is a call
        // then we will assume that this one called us because we can
        // no longer accurately determine for sure whether this did
        // in fact call the FPO function.  Since 0xFF calls are a guess
        // as well we will not check them if we already have an earlier guess.
        // It is more likely that the first 0xE8 called the function than
        // something higher up the stack that might be an 0xFF call.
        //
        if ( !uoffBestGuess && cBytes >= MIN_CALL ) {

            cbLimit = MAX_CALL - (INT)cBytes;

            for (cbIndex = MAX_CALL - MIN_CALL;
                 cbIndex >= cbLimit;  //MAX_CALL - (INT)cBytes;
                 cbIndex--) {

                if ( ( code [ cbIndex ] == 0xFF ) &&
                    ( ( code [ cbIndex + 1 ] & 0x30 ) == 0x10 )){

                    WDB(("        found call, use %X\n", (ULONG)uoffStack));
                    return uoffStack;

                }
            }
        }
    }

    //
    // we found nothing that was 100% definite so we'll return the best guess
    //
    WDB(("        best guess is %X\n", (ULONG)uoffBestGuess));
    return uoffBestGuess;
}


DWORD64
SearchForFramePointer(
    HANDLE                            Process,
    DWORD64                           StackAddr,
    DWORD                             NumRegs,
    DWORD64                           FuncAddr,
    DWORD                             FuncSize,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    )
{
    BYTE Code[MAX_FUNC_PROLOGUE];
    DWORD CodeLen;
    DWORD i;
    DWORD Depth;

    WDB(("      SearchForFramePointer: start %X, regs %d\n",
         (ULONG)StackAddr, NumRegs));
    
    //
    // The compiler does not push registers in a consistent
    // order and FPO information only indicates the total
    // number of registers pushed, not their order.  This
    // function searches the stack locations where registers
    // are stored and tries to find which one is EBP.
    // It searches the function code for pushes and
    // tries to use that information to help the stack
    // analysis.
    //
    // If this routine fails it just returns the base
    // of the register save area.
    //

    // Read the beginning of the function for code analysis.
    if (sizeof(Code) < FuncSize)
    {
        CodeLen = sizeof(Code);
    }
    else
    {
        CodeLen = FuncSize;
    }
    if (!ReadMemory(Process, FuncAddr, Code, CodeLen, &CodeLen))
    {
        WDB(("        unable to read code, use %X\n", (ULONG)StackAddr));
        return StackAddr;
    }

    // Scan the code for normal prologue operations like
    // sub esp, push reg and mov reg.  This code only
    // handles a very limited set of instructions.

    Depth = 0;
    for (i = 0; i < CodeLen; i++)
    {
        if (Code[i] == 0x83 && Code[i+1] == 0xec)
        {
            // sub esp, imm8
            // Skip past.
            i += 2;
        }
        else if (Code[i] == 0x8b)
        {
            BYTE Mod, Rm;
            
            // mov reg32, r/m32
            i++;
            Mod = Code[i] >> 6;
            Rm = Code[